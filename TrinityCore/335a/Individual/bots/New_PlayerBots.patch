From 0cf6245f63782b22bfda0f66535be2cd2ed3ef2a Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Sun, 28 Sep 2014 17:00:01 -0400
Subject: [PATCH] New_PlayerBots

---
 cmake/options.cmake                                |    1 +
 sql/characters_ai_playerbot.sql                    |   16 +
 sql/characters_auctionhousebot.sql                 |   37 +
 src/CMakeLists.txt                                 |    2 +-
 src/plugins/CMakeLists.txt                         |  141 ++
 src/plugins/ahbot/AhBot.cpp                        |  983 ++++++++++++
 src/plugins/ahbot/AhBot.h                          |   93 ++
 src/plugins/ahbot/AhBotConfig.cpp                  |   57 +
 src/plugins/ahbot/AhBotConfig.h                    |   91 ++
 src/plugins/ahbot/Category.cpp                     |   76 +
 src/plugins/ahbot/Category.h                       |  354 +++++
 src/plugins/ahbot/ConsumableCategory.cpp           |    5 +
 src/plugins/ahbot/ConsumableCategory.h             |   86 +
 src/plugins/ahbot/ItemBag.cpp                      |  184 +++
 src/plugins/ahbot/ItemBag.h                        |   82 +
 src/plugins/ahbot/PricingStrategy.cpp              |  220 +++
 src/plugins/ahbot/PricingStrategy.h                |   55 +
 src/plugins/ahbot/TradeCategory.cpp                |    4 +
 src/plugins/ahbot/TradeCategory.h                  |  183 +++
 src/plugins/ahbot/ahbot.conf.dist.in               |  203 +++
 src/plugins/pch/pch.cpp                            |    1 +
 src/plugins/pch/pch.h                              |   10 +
 src/plugins/pchdef.h                               |    4 +
 src/plugins/playerbot/AiFactory.cpp                |  227 +++
 src/plugins/playerbot/AiFactory.h                  |   20 +
 src/plugins/playerbot/ChatFilter.cpp               |  257 +++
 src/plugins/playerbot/ChatFilter.h                 |   24 +
 src/plugins/playerbot/ChatHelper.cpp               |  450 ++++++
 src/plugins/playerbot/ChatHelper.h                 |   52 +
 src/plugins/playerbot/FleeManager.cpp              |  160 ++
 src/plugins/playerbot/FleeManager.h                |   83 +
 src/plugins/playerbot/Helpers.cpp                  |   90 ++
 src/plugins/playerbot/LazyCalculatedValue.h        |   42 +
 src/plugins/playerbot/LootObjectStack.cpp          |  244 +++
 src/plugins/playerbot/LootObjectStack.h            |   76 +
 src/plugins/playerbot/PlayerbotAI.cpp              | 1332 ++++++++++++++++
 src/plugins/playerbot/PlayerbotAI.h                |  184 +++
 src/plugins/playerbot/PlayerbotAIAware.h           |   13 +
 src/plugins/playerbot/PlayerbotAIBase.cpp          |   51 +
 src/plugins/playerbot/PlayerbotAIBase.h            |   24 +
 src/plugins/playerbot/PlayerbotAIConfig.cpp        |  293 ++++
 src/plugins/playerbot/PlayerbotAIConfig.h          |   69 +
 src/plugins/playerbot/PlayerbotFactory.cpp         | 1655 ++++++++++++++++++++
 src/plugins/playerbot/PlayerbotFactory.h           |   67 +
 src/plugins/playerbot/PlayerbotMgr.cpp             |  467 ++++++
 src/plugins/playerbot/PlayerbotMgr.h               |   69 +
 src/plugins/playerbot/PlayerbotSecurity.cpp        |  187 +++
 src/plugins/playerbot/PlayerbotSecurity.h          |   42 +
 src/plugins/playerbot/RandomPlayerbotFactory.cpp   |  147 ++
 src/plugins/playerbot/RandomPlayerbotFactory.h     |   32 +
 src/plugins/playerbot/RandomPlayerbotMgr.cpp       |  839 ++++++++++
 src/plugins/playerbot/RandomPlayerbotMgr.h         |   72 +
 src/plugins/playerbot/aiplayerbot.conf.dist.in     |  159 ++
 src/plugins/playerbot/playerbot.h                  |   31 +
 src/plugins/playerbot/playerbotDefs.h              |    2 +
 src/plugins/playerbot/strategy/Action.cpp          |   93 ++
 src/plugins/playerbot/strategy/Action.h            |  138 ++
 src/plugins/playerbot/strategy/ActionBasket.cpp    |    4 +
 src/plugins/playerbot/strategy/ActionBasket.h      |    5 +
 src/plugins/playerbot/strategy/AiObject.cpp        |   16 +
 src/plugins/playerbot/strategy/AiObject.h          |   33 +
 src/plugins/playerbot/strategy/AiObjectContext.cpp |   48 +
 src/plugins/playerbot/strategy/AiObjectContext.h   |   81 +
 src/plugins/playerbot/strategy/Engine.cpp          |  522 ++++++
 src/plugins/playerbot/strategy/Engine.h            |  121 ++
 src/plugins/playerbot/strategy/Event.cpp           |   20 +
 src/plugins/playerbot/strategy/Event.h             |   36 +
 .../playerbot/strategy/ExternalEventHelper.h       |   69 +
 src/plugins/playerbot/strategy/ItemVisitors.h      |  258 +++
 src/plugins/playerbot/strategy/Multiplier.cpp      |    5 +
 src/plugins/playerbot/strategy/Multiplier.h        |   16 +
 .../playerbot/strategy/NamedObjectContext.h        |  249 +++
 .../playerbot/strategy/PassiveMultiplier.cpp       |   47 +
 src/plugins/playerbot/strategy/PassiveMultiplier.h |   20 +
 src/plugins/playerbot/strategy/Queue.cpp           |   81 +
 src/plugins/playerbot/strategy/Queue.h             |   21 +
 src/plugins/playerbot/strategy/Strategy.cpp        |  117 ++
 src/plugins/playerbot/strategy/Strategy.h          |   55 +
 src/plugins/playerbot/strategy/StrategyContext.h   |  141 ++
 src/plugins/playerbot/strategy/Trigger.cpp         |   27 +
 src/plugins/playerbot/strategy/Trigger.h           |   84 +
 src/plugins/playerbot/strategy/Value.cpp           |    5 +
 src/plugins/playerbot/strategy/Value.h             |  177 +++
 .../playerbot/strategy/actions/AcceptDuelAction.h  |   31 +
 .../strategy/actions/AcceptInvitationAction.h      |   47 +
 .../strategy/actions/AcceptQuestAction.cpp         |  102 ++
 .../playerbot/strategy/actions/AcceptQuestAction.h |   27 +
 .../strategy/actions/AcceptResurrectAction.h       |   31 +
 .../playerbot/strategy/actions/ActionContext.h     |  107 ++
 .../playerbot/strategy/actions/AddLootAction.cpp   |   62 +
 .../playerbot/strategy/actions/AddLootAction.h     |   32 +
 .../strategy/actions/AreaTriggerAction.cpp         |   80 +
 .../playerbot/strategy/actions/AreaTriggerAction.h |   23 +
 .../playerbot/strategy/actions/AttackAction.cpp    |  104 ++
 .../playerbot/strategy/actions/AttackAction.h      |   38 +
 .../playerbot/strategy/actions/BankAction.cpp      |  168 ++
 .../playerbot/strategy/actions/BankAction.h        |   21 +
 .../playerbot/strategy/actions/BuffAction.cpp      |  118 ++
 .../playerbot/strategy/actions/BuffAction.h        |   17 +
 .../playerbot/strategy/actions/BuyAction.cpp       |   53 +
 src/plugins/playerbot/strategy/actions/BuyAction.h |   19 +
 .../strategy/actions/CastCustomSpellAction.cpp     |   41 +
 .../strategy/actions/CastCustomSpellAction.h       |   14 +
 .../strategy/actions/ChangeChatAction.cpp          |   26 +
 .../playerbot/strategy/actions/ChangeChatAction.h  |   14 +
 .../strategy/actions/ChangeStrategyAction.cpp      |   38 +
 .../strategy/actions/ChangeStrategyAction.h        |   30 +
 .../strategy/actions/ChangeTalentsAction.cpp       |   37 +
 .../strategy/actions/ChangeTalentsAction.h         |   16 +
 .../playerbot/strategy/actions/ChatActionContext.h |  184 +++
 .../strategy/actions/ChatShortcutActions.cpp       |  108 ++
 .../strategy/actions/ChatShortcutActions.h         |   57 +
 .../strategy/actions/CheckMountStateAction.cpp     |   79 +
 .../strategy/actions/CheckMountStateAction.h       |   19 +
 .../strategy/actions/ChooseTargetActions.h         |   78 +
 .../strategy/actions/DestroyItemAction.cpp         |   34 +
 .../playerbot/strategy/actions/DestroyItemAction.h |   17 +
 .../playerbot/strategy/actions/DropQuestAction.cpp |   47 +
 .../playerbot/strategy/actions/DropQuestAction.h   |   13 +
 .../playerbot/strategy/actions/EmoteAction.cpp     |  100 ++
 .../playerbot/strategy/actions/EmoteAction.h       |   18 +
 .../playerbot/strategy/actions/EquipAction.cpp     |  105 ++
 .../playerbot/strategy/actions/EquipAction.h       |   21 +
 .../playerbot/strategy/actions/FollowActions.cpp   |   49 +
 .../playerbot/strategy/actions/FollowActions.h     |   14 +
 .../playerbot/strategy/actions/GenericActions.cpp  |    5 +
 .../playerbot/strategy/actions/GenericActions.h    |   19 +
 .../strategy/actions/GenericSpellActions.cpp       |   58 +
 .../strategy/actions/GenericSpellActions.h         |  271 ++++
 .../strategy/actions/GossipHelloAction.cpp         |   71 +
 .../playerbot/strategy/actions/GossipHelloAction.h |   13 +
 .../strategy/actions/GuildAcceptAction.cpp         |   42 +
 .../playerbot/strategy/actions/GuildAcceptAction.h |   14 +
 .../playerbot/strategy/actions/GuildBankAction.cpp |   61 +
 .../playerbot/strategy/actions/GuildBankAction.h   |   18 +
 .../playerbot/strategy/actions/HelpAction.cpp      |   54 +
 .../playerbot/strategy/actions/HelpAction.h        |   22 +
 .../playerbot/strategy/actions/InventoryAction.cpp |  288 ++++
 .../playerbot/strategy/actions/InventoryAction.h   |   24 +
 .../actions/InventoryChangeFailureAction.cpp       |   55 +
 .../actions/InventoryChangeFailureAction.h         |   12 +
 .../strategy/actions/InviteToGroupAction.h         |   28 +
 .../playerbot/strategy/actions/LeaveGroupAction.h  |   79 +
 .../playerbot/strategy/actions/LfgActions.cpp      |  215 +++
 .../playerbot/strategy/actions/LfgActions.h        |   37 +
 .../strategy/actions/ListQuestsActions.cpp         |   71 +
 .../playerbot/strategy/actions/ListQuestsActions.h |   25 +
 .../strategy/actions/ListSpellsAction.cpp          |   65 +
 .../playerbot/strategy/actions/ListSpellsAction.h  |   16 +
 .../playerbot/strategy/actions/LogLevelAction.cpp  |   43 +
 .../playerbot/strategy/actions/LogLevelAction.h    |   17 +
 .../playerbot/strategy/actions/LootAction.cpp      |  400 +++++
 .../playerbot/strategy/actions/LootAction.h        |   40 +
 .../playerbot/strategy/actions/LootRollAction.cpp  |   66 +
 .../playerbot/strategy/actions/LootRollAction.h    |   15 +
 .../strategy/actions/LootStrategyAction.cpp        |  100 ++
 .../strategy/actions/LootStrategyAction.h          |   19 +
 .../playerbot/strategy/actions/MovementActions.cpp |  373 +++++
 .../playerbot/strategy/actions/MovementActions.h   |   92 ++
 .../strategy/actions/NonCombatActions.cpp          |    6 +
 .../playerbot/strategy/actions/NonCombatActions.h  |   47 +
 .../actions/PassLeadershipToMasterAction.h         |   26 +
 .../playerbot/strategy/actions/PositionAction.cpp  |   38 +
 .../playerbot/strategy/actions/PositionAction.h    |   37 +
 .../strategy/actions/QueryItemUsageAction.cpp      |  195 +++
 .../strategy/actions/QueryItemUsageAction.h        |   24 +
 .../strategy/actions/QueryQuestAction.cpp          |   89 ++
 .../playerbot/strategy/actions/QueryQuestAction.h  |   16 +
 .../playerbot/strategy/actions/QuestAction.cpp     |  137 ++
 .../playerbot/strategy/actions/QuestAction.h       |   33 +
 .../strategy/actions/ReachTargetActions.h          |   57 +
 .../strategy/actions/ReadyCheckAction.cpp          |   84 +
 .../playerbot/strategy/actions/ReadyCheckAction.h  |   26 +
 .../strategy/actions/ReleaseSpiritAction.h         |   29 +
 .../strategy/actions/RememberTaxiAction.cpp        |   46 +
 .../strategy/actions/RememberTaxiAction.h          |   13 +
 .../playerbot/strategy/actions/RepairAllAction.cpp |   30 +
 .../playerbot/strategy/actions/RepairAllAction.h   |   13 +
 .../playerbot/strategy/actions/ResetAiAction.cpp   |   12 +
 .../playerbot/strategy/actions/ResetAiAction.h     |   14 +
 .../strategy/actions/ReviveFromCorpseAction.cpp    |   51 +
 .../strategy/actions/ReviveFromCorpseAction.h      |   21 +
 .../playerbot/strategy/actions/RewardAction.cpp    |   75 +
 .../playerbot/strategy/actions/RewardAction.h      |   17 +
 src/plugins/playerbot/strategy/actions/RtiAction.h |   44 +
 .../playerbot/strategy/actions/SaveManaAction.cpp  |   73 +
 .../playerbot/strategy/actions/SaveManaAction.h    |   20 +
 .../strategy/actions/SecurityCheckAction.cpp       |   31 +
 .../strategy/actions/SecurityCheckAction.h         |   14 +
 .../playerbot/strategy/actions/SellAction.cpp      |   95 ++
 .../playerbot/strategy/actions/SellAction.h        |   18 +
 .../playerbot/strategy/actions/SetHomeAction.cpp   |   42 +
 .../playerbot/strategy/actions/SetHomeAction.h     |   12 +
 .../playerbot/strategy/actions/StatsAction.cpp     |  145 ++
 .../playerbot/strategy/actions/StatsAction.h       |   22 +
 .../playerbot/strategy/actions/StayActions.cpp     |   34 +
 .../playerbot/strategy/actions/StayActions.h       |   23 +
 .../strategy/actions/SuggestWhatToDoAction.cpp     |  255 +++
 .../strategy/actions/SuggestWhatToDoAction.h       |   34 +
 .../strategy/actions/TalkToQuestGiverAction.cpp    |   90 ++
 .../strategy/actions/TalkToQuestGiverAction.h      |   22 +
 .../playerbot/strategy/actions/TaxiAction.cpp      |   51 +
 .../playerbot/strategy/actions/TaxiAction.h        |   13 +
 .../playerbot/strategy/actions/TeleportAction.cpp  |   54 +
 .../playerbot/strategy/actions/TeleportAction.h    |   16 +
 .../strategy/actions/TellCastFailedAction.cpp      |   75 +
 .../strategy/actions/TellCastFailedAction.h        |   22 +
 .../strategy/actions/TellItemCountAction.cpp       |   16 +
 .../strategy/actions/TellItemCountAction.h         |   14 +
 .../playerbot/strategy/actions/TellLosAction.cpp   |   61 +
 .../playerbot/strategy/actions/TellLosAction.h     |   17 +
 .../playerbot/strategy/actions/TellMasterAction.h  |   38 +
 .../strategy/actions/TellReputationAction.cpp      |   68 +
 .../strategy/actions/TellReputationAction.h        |   16 +
 .../strategy/actions/TellTargetAction.cpp          |   53 +
 .../playerbot/strategy/actions/TellTargetAction.h  |   21 +
 .../playerbot/strategy/actions/TradeAction.cpp     |   83 +
 .../playerbot/strategy/actions/TradeAction.h       |   19 +
 .../strategy/actions/TradeStatusAction.cpp         |  171 ++
 .../playerbot/strategy/actions/TradeStatusAction.h |   19 +
 .../playerbot/strategy/actions/TrainerAction.cpp   |  114 ++
 .../playerbot/strategy/actions/TrainerAction.h     |   22 +
 .../playerbot/strategy/actions/UnequipAction.cpp   |   45 +
 .../playerbot/strategy/actions/UnequipAction.h     |   18 +
 .../playerbot/strategy/actions/UseItemAction.cpp   |  302 ++++
 .../playerbot/strategy/actions/UseItemAction.h     |   47 +
 .../strategy/actions/UseMeetingStoneAction.cpp     |   81 +
 .../strategy/actions/UseMeetingStoneAction.h       |   26 +
 .../playerbot/strategy/actions/WhoAction.cpp       |  160 ++
 src/plugins/playerbot/strategy/actions/WhoAction.h |   23 +
 .../strategy/actions/WorldPacketActionContext.h    |  106 ++
 .../strategy/druid/BearTankDruidStrategy.cpp       |  171 ++
 .../strategy/druid/BearTankDruidStrategy.h         |   18 +
 .../strategy/druid/CasterDruidStrategy.cpp         |  177 +++
 .../playerbot/strategy/druid/CasterDruidStrategy.h |   39 +
 .../strategy/druid/CatDpsDruidStrategy.cpp         |  139 ++
 .../playerbot/strategy/druid/CatDpsDruidStrategy.h |   29 +
 .../playerbot/strategy/druid/DruidActions.cpp      |   31 +
 .../playerbot/strategy/druid/DruidActions.h        |  205 +++
 .../strategy/druid/DruidAiObjectContext.cpp        |  258 +++
 .../strategy/druid/DruidAiObjectContext.h          |   12 +
 .../playerbot/strategy/druid/DruidBearActions.h    |   64 +
 .../playerbot/strategy/druid/DruidCatActions.h     |   69 +
 .../playerbot/strategy/druid/DruidMultipliers.cpp  |    6 +
 .../playerbot/strategy/druid/DruidMultipliers.h    |    6 +
 .../strategy/druid/DruidShapeshiftActions.h        |   53 +
 .../playerbot/strategy/druid/DruidTriggers.cpp     |    7 +
 .../playerbot/strategy/druid/DruidTriggers.h       |  127 ++
 .../strategy/druid/FeralDruidStrategy.cpp          |   90 ++
 .../playerbot/strategy/druid/FeralDruidStrategy.h  |   75 +
 .../druid/GenericDruidNonCombatStrategy.cpp        |   73 +
 .../strategy/druid/GenericDruidNonCombatStrategy.h |   16 +
 .../strategy/druid/GenericDruidStrategy.cpp        |  132 ++
 .../strategy/druid/GenericDruidStrategy.h          |   18 +
 .../playerbot/strategy/druid/HealDruidStrategy.cpp |   57 +
 .../playerbot/strategy/druid/HealDruidStrategy.h   |   18 +
 .../generic/AttackEnemyPlayersStrategy.cpp         |   13 +
 .../strategy/generic/AttackEnemyPlayersStrategy.h  |   16 +
 .../strategy/generic/AttackRtiStrategy.cpp         |   14 +
 .../playerbot/strategy/generic/AttackRtiStrategy.h |   16 +
 .../strategy/generic/AttackWeakStrategy.cpp        |   13 +
 .../strategy/generic/AttackWeakStrategy.h          |   16 +
 .../strategy/generic/CastTimeStrategy.cpp          |   42 +
 .../playerbot/strategy/generic/CastTimeStrategy.h  |   26 +
 .../generic/ChatCommandHandlerStrategy.cpp         |  177 +++
 .../strategy/generic/ChatCommandHandlerStrategy.h  |   15 +
 .../playerbot/strategy/generic/CombatStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/CombatStrategy.h    |   13 +
 .../strategy/generic/ConserveManaStrategy.cpp      |   88 ++
 .../strategy/generic/ConserveManaStrategy.h        |   32 +
 .../playerbot/strategy/generic/DeadStrategy.cpp    |   23 +
 .../playerbot/strategy/generic/DeadStrategy.h      |   15 +
 .../playerbot/strategy/generic/DpsAoeStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/DpsAoeStrategy.h    |   18 +
 .../strategy/generic/DpsAssistStrategy.cpp         |   15 +
 .../playerbot/strategy/generic/DpsAssistStrategy.h |   16 +
 .../playerbot/strategy/generic/DuelStrategy.cpp    |   24 +
 .../playerbot/strategy/generic/DuelStrategy.h      |   15 +
 .../playerbot/strategy/generic/EmoteStrategy.cpp   |   17 +
 .../playerbot/strategy/generic/EmoteStrategy.h     |   16 +
 .../playerbot/strategy/generic/FleeStrategy.cpp    |   26 +
 .../playerbot/strategy/generic/FleeStrategy.h      |   21 +
 .../strategy/generic/FollowMasterStrategy.cpp      |   17 +
 .../strategy/generic/FollowMasterStrategy.h        |   16 +
 .../strategy/generic/GrindingStrategy.cpp          |   20 +
 .../playerbot/strategy/generic/GrindingStrategy.h  |   20 +
 .../playerbot/strategy/generic/GuardStrategy.cpp   |   16 +
 .../playerbot/strategy/generic/GuardStrategy.h     |   19 +
 .../playerbot/strategy/generic/KiteStrategy.cpp    |   16 +
 .../playerbot/strategy/generic/KiteStrategy.h      |   15 +
 .../strategy/generic/LootNonCombatStrategy.cpp     |   29 +
 .../strategy/generic/LootNonCombatStrategy.h       |   24 +
 .../strategy/generic/MeleeCombatStrategy.cpp       |   23 +
 .../strategy/generic/MeleeCombatStrategy.h         |   16 +
 .../strategy/generic/NonCombatStrategy.cpp         |   12 +
 .../playerbot/strategy/generic/NonCombatStrategy.h |   12 +
 .../strategy/generic/PassTroughStrategy.h          |   26 +
 .../playerbot/strategy/generic/PassiveStrategy.cpp |   13 +
 .../playerbot/strategy/generic/PassiveStrategy.h   |   16 +
 .../playerbot/strategy/generic/PullStrategy.cpp    |   52 +
 .../playerbot/strategy/generic/PullStrategy.h      |   24 +
 .../playerbot/strategy/generic/QuestStrategies.cpp |   69 +
 .../playerbot/strategy/generic/QuestStrategies.h   |   34 +
 .../playerbot/strategy/generic/RacialsStrategy.cpp |   39 +
 .../playerbot/strategy/generic/RacialsStrategy.h   |   15 +
 .../strategy/generic/RangedCombatStrategy.cpp      |   15 +
 .../strategy/generic/RangedCombatStrategy.h        |   15 +
 .../playerbot/strategy/generic/RunawayStrategy.cpp |   18 +
 .../playerbot/strategy/generic/RunawayStrategy.h   |   16 +
 .../playerbot/strategy/generic/StayStrategy.cpp    |   11 +
 .../playerbot/strategy/generic/StayStrategy.h      |   14 +
 .../playerbot/strategy/generic/TankAoeStrategy.cpp |   12 +
 .../playerbot/strategy/generic/TankAoeStrategy.h   |   18 +
 .../strategy/generic/TankAssistStrategy.cpp        |   13 +
 .../strategy/generic/TankAssistStrategy.h          |   17 +
 .../strategy/generic/TellTargetStrategy.cpp        |   13 +
 .../strategy/generic/TellTargetStrategy.h          |   16 +
 .../playerbot/strategy/generic/ThreatStrategy.cpp  |   32 +
 .../playerbot/strategy/generic/ThreatStrategy.h    |   25 +
 .../playerbot/strategy/generic/UseFoodStrategy.cpp |   18 +
 .../playerbot/strategy/generic/UseFoodStrategy.h   |   15 +
 .../strategy/generic/UsePotionsStrategy.cpp        |   18 +
 .../strategy/generic/UsePotionsStrategy.h          |   15 +
 .../generic/WorldPacketHandlerStrategy.cpp         |  116 ++
 .../strategy/generic/WorldPacketHandlerStrategy.h  |   25 +
 .../strategy/hunter/DpsHunterStrategy.cpp          |  118 ++
 .../playerbot/strategy/hunter/DpsHunterStrategy.h  |   39 +
 .../hunter/GenericHunterNonCombatStrategy.cpp      |   58 +
 .../hunter/GenericHunterNonCombatStrategy.h        |   17 +
 .../strategy/hunter/GenericHunterStrategy.cpp      |   66 +
 .../strategy/hunter/GenericHunterStrategy.h        |   20 +
 .../playerbot/strategy/hunter/HunterActions.cpp    |   26 +
 .../playerbot/strategy/hunter/HunterActions.h      |  154 ++
 .../strategy/hunter/HunterAiObjectContext.cpp      |  191 +++
 .../strategy/hunter/HunterAiObjectContext.h        |   12 +
 .../strategy/hunter/HunterBuffStrategies.cpp       |   35 +
 .../strategy/hunter/HunterBuffStrategies.h         |   47 +
 .../strategy/hunter/HunterMultipliers.cpp          |    5 +
 .../playerbot/strategy/hunter/HunterMultipliers.h  |    6 +
 .../playerbot/strategy/hunter/HunterTriggers.cpp   |   29 +
 .../playerbot/strategy/hunter/HunterTriggers.h     |   86 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.cpp |   64 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.h   |   18 +
 .../playerbot/strategy/mage/FireMageStrategy.cpp   |   44 +
 .../playerbot/strategy/mage/FireMageStrategy.h     |   28 +
 .../playerbot/strategy/mage/FrostMageStrategy.cpp  |   32 +
 .../playerbot/strategy/mage/FrostMageStrategy.h    |   28 +
 .../strategy/mage/GenericMageNonCombatStrategy.cpp |   87 +
 .../strategy/mage/GenericMageNonCombatStrategy.h   |   37 +
 .../strategy/mage/GenericMageStrategy.cpp          |  137 ++
 .../playerbot/strategy/mage/GenericMageStrategy.h  |   17 +
 .../playerbot/strategy/mage/MageActions.cpp        |   10 +
 src/plugins/playerbot/strategy/mage/MageActions.h  |  205 +++
 .../strategy/mage/MageAiObjectContext.cpp          |  221 +++
 .../playerbot/strategy/mage/MageAiObjectContext.h  |   12 +
 .../playerbot/strategy/mage/MageMultipliers.cpp    |    6 +
 .../playerbot/strategy/mage/MageMultipliers.h      |    6 +
 .../playerbot/strategy/mage/MageTriggers.cpp       |   15 +
 src/plugins/playerbot/strategy/mage/MageTriggers.h |   92 ++
 .../strategy/paladin/DpsPaladinStrategy.cpp        |   83 +
 .../strategy/paladin/DpsPaladinStrategy.h          |   18 +
 .../paladin/GenericPaladinNonCombatStrategy.cpp    |   65 +
 .../paladin/GenericPaladinNonCombatStrategy.h      |   16 +
 .../strategy/paladin/GenericPaladinStrategy.cpp    |   77 +
 .../strategy/paladin/GenericPaladinStrategy.h      |   18 +
 .../GenericPaladinStrategyActionNodeFactory.h      |  142 ++
 .../playerbot/strategy/paladin/PaladinActions.cpp  |    6 +
 .../playerbot/strategy/paladin/PaladinActions.h    |  365 +++++
 .../strategy/paladin/PaladinAiObjectContext.cpp    |  279 ++++
 .../strategy/paladin/PaladinAiObjectContext.h      |   12 +
 .../strategy/paladin/PaladinBuffStrategies.cpp     |   72 +
 .../strategy/paladin/PaladinBuffStrategies.h       |   86 +
 .../strategy/paladin/PaladinMultipliers.cpp        |    6 +
 .../strategy/paladin/PaladinMultipliers.h          |    6 +
 .../playerbot/strategy/paladin/PaladinTriggers.cpp |   23 +
 .../playerbot/strategy/paladin/PaladinTriggers.h   |  114 ++
 .../strategy/paladin/TankPaladinStrategy.cpp       |   70 +
 .../strategy/paladin/TankPaladinStrategy.h         |   18 +
 .../strategy/priest/GenericPriestStrategy.cpp      |   67 +
 .../strategy/priest/GenericPriestStrategy.h        |   17 +
 .../GenericPriestStrategyActionNodeFactory.h       |  173 ++
 .../strategy/priest/HealPriestStrategy.cpp         |   36 +
 .../playerbot/strategy/priest/HealPriestStrategy.h |   18 +
 .../strategy/priest/HolyPriestStrategy.cpp         |   46 +
 .../playerbot/strategy/priest/HolyPriestStrategy.h |   18 +
 .../playerbot/strategy/priest/PriestActions.cpp    |   17 +
 .../playerbot/strategy/priest/PriestActions.h      |  246 +++
 .../strategy/priest/PriestAiObjectContext.cpp      |  217 +++
 .../strategy/priest/PriestAiObjectContext.h        |   12 +
 .../strategy/priest/PriestMultipliers.cpp          |    6 +
 .../playerbot/strategy/priest/PriestMultipliers.h  |    6 +
 .../strategy/priest/PriestNonCombatStrategy.cpp    |   82 +
 .../strategy/priest/PriestNonCombatStrategy.h      |   17 +
 .../PriestNonCombatStrategyActionNodeFactory.h     |  126 ++
 .../playerbot/strategy/priest/PriestTriggers.cpp   |    7 +
 .../playerbot/strategy/priest/PriestTriggers.h     |   54 +
 .../strategy/priest/ShadowPriestStrategy.cpp       |   60 +
 .../strategy/priest/ShadowPriestStrategy.h         |   38 +
 .../priest/ShadowPriestStrategyActionNodeFactory.h |   37 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.cpp  |  110 ++
 .../playerbot/strategy/rogue/DpsRogueStrategy.h    |   18 +
 .../rogue/GenericRogueNonCombatStrategy.cpp        |   14 +
 .../strategy/rogue/GenericRogueNonCombatStrategy.h |   16 +
 .../playerbot/strategy/rogue/RogueActions.cpp      |    5 +
 .../playerbot/strategy/rogue/RogueActions.h        |   82 +
 .../strategy/rogue/RogueAiObjectContext.cpp        |  119 ++
 .../strategy/rogue/RogueAiObjectContext.h          |   12 +
 .../playerbot/strategy/rogue/RogueComboActions.h   |   45 +
 .../strategy/rogue/RogueFinishingActions.h         |   35 +
 .../playerbot/strategy/rogue/RogueMultipliers.cpp  |    6 +
 .../playerbot/strategy/rogue/RogueMultipliers.h    |    6 +
 .../playerbot/strategy/rogue/RogueOpeningActions.h |   24 +
 .../playerbot/strategy/rogue/RogueTriggers.cpp     |    7 +
 .../playerbot/strategy/rogue/RogueTriggers.h       |   36 +
 .../strategy/shaman/CasterShamanStrategy.cpp       |   75 +
 .../strategy/shaman/CasterShamanStrategy.h         |   29 +
 .../strategy/shaman/GenericShamanStrategy.cpp      |  159 ++
 .../strategy/shaman/GenericShamanStrategy.h        |   39 +
 .../strategy/shaman/HealShamanStrategy.cpp         |   82 +
 .../playerbot/strategy/shaman/HealShamanStrategy.h |   17 +
 .../strategy/shaman/MeleeShamanStrategy.cpp        |   93 ++
 .../strategy/shaman/MeleeShamanStrategy.h          |   28 +
 .../playerbot/strategy/shaman/ShamanActions.cpp    |    6 +
 .../playerbot/strategy/shaman/ShamanActions.h      |  304 ++++
 .../strategy/shaman/ShamanAiObjectContext.cpp      |  268 ++++
 .../strategy/shaman/ShamanAiObjectContext.h        |   12 +
 .../strategy/shaman/ShamanMultipliers.cpp          |    6 +
 .../playerbot/strategy/shaman/ShamanMultipliers.h  |    6 +
 .../strategy/shaman/ShamanNonCombatStrategy.cpp    |   49 +
 .../strategy/shaman/ShamanNonCombatStrategy.h      |   19 +
 .../playerbot/strategy/shaman/ShamanTriggers.cpp   |   38 +
 .../playerbot/strategy/shaman/ShamanTriggers.h     |  197 +++
 .../strategy/shaman/TotemsShamanStrategy.cpp       |   31 +
 .../strategy/shaman/TotemsShamanStrategy.h         |   17 +
 .../strategy/triggers/ChatCommandTrigger.h         |   36 +
 .../strategy/triggers/ChatTriggerContext.h         |  140 ++
 .../playerbot/strategy/triggers/CureTriggers.cpp   |   17 +
 .../playerbot/strategy/triggers/CureTriggers.h     |   35 +
 .../strategy/triggers/GenericTriggers.cpp          |  242 +++
 .../playerbot/strategy/triggers/GenericTriggers.h  |  540 +++++++
 .../playerbot/strategy/triggers/HealthTriggers.cpp |   26 +
 .../playerbot/strategy/triggers/HealthTriggers.h   |  139 ++
 .../playerbot/strategy/triggers/LfgTriggers.h      |   17 +
 .../playerbot/strategy/triggers/LootTriggers.cpp   |   20 +
 .../playerbot/strategy/triggers/LootTriggers.h     |   30 +
 .../playerbot/strategy/triggers/RangeTriggers.h    |   81 +
 .../playerbot/strategy/triggers/TriggerContext.h   |  158 ++
 .../strategy/triggers/WithinAreaTrigger.h          |   76 +
 .../strategy/triggers/WorldPacketTrigger.h         |   36 +
 .../strategy/triggers/WorldPacketTriggerContext.h  |   83 +
 .../strategy/values/AlwaysLootListValue.h          |   14 +
 .../playerbot/strategy/values/AoeHealValues.cpp    |   37 +
 .../playerbot/strategy/values/AoeHealValues.h      |   14 +
 .../strategy/values/AttackerCountValues.cpp        |  107 ++
 .../strategy/values/AttackerCountValues.h          |   59 +
 .../values/AttackerWithoutAuraTargetValue.cpp      |   26 +
 .../values/AttackerWithoutAuraTargetValue.h        |   15 +
 .../playerbot/strategy/values/AttackersValue.cpp   |   87 +
 .../playerbot/strategy/values/AttackersValue.h     |   20 +
 .../playerbot/strategy/values/AvailableLootValue.h |   40 +
 .../playerbot/strategy/values/CcTargetValue.cpp    |   88 ++
 .../playerbot/strategy/values/CcTargetValue.h      |   16 +
 src/plugins/playerbot/strategy/values/ChatValue.h  |   11 +
 .../strategy/values/CurrentCcTargetValue.cpp       |   31 +
 .../strategy/values/CurrentCcTargetValue.h         |   16 +
 .../strategy/values/CurrentTargetValue.cpp         |   22 +
 .../playerbot/strategy/values/CurrentTargetValue.h |   17 +
 .../playerbot/strategy/values/DistanceValue.h      |   35 +
 .../playerbot/strategy/values/DpsTargetValue.cpp   |   45 +
 .../playerbot/strategy/values/DpsTargetValue.h     |   16 +
 .../playerbot/strategy/values/DuelTargetValue.cpp  |   10 +
 .../playerbot/strategy/values/DuelTargetValue.h    |   15 +
 .../strategy/values/EnemyHealerTargetValue.cpp     |   36 +
 .../strategy/values/EnemyHealerTargetValue.h       |   15 +
 .../playerbot/strategy/values/EnemyPlayerValue.cpp |   34 +
 .../playerbot/strategy/values/EnemyPlayerValue.h   |   15 +
 .../playerbot/strategy/values/Formations.cpp       |  333 ++++
 src/plugins/playerbot/strategy/values/Formations.h |   52 +
 .../playerbot/strategy/values/GrindTargetValue.cpp |  116 ++
 .../playerbot/strategy/values/GrindTargetValue.h   |   20 +
 .../strategy/values/HasAvailableLootValue.h        |   20 +
 .../playerbot/strategy/values/HasTotemValue.h      |   34 +
 .../strategy/values/InvalidTargetValue.cpp         |   26 +
 .../playerbot/strategy/values/InvalidTargetValue.h |   14 +
 .../playerbot/strategy/values/IsBehindValue.h      |   25 +
 .../playerbot/strategy/values/IsFacingValue.h      |   20 +
 .../playerbot/strategy/values/IsMovingValue.h      |   42 +
 .../playerbot/strategy/values/ItemCountValue.cpp   |   37 +
 .../playerbot/strategy/values/ItemCountValue.h     |   35 +
 .../strategy/values/ItemForSpellValue.cpp          |   70 +
 .../playerbot/strategy/values/ItemForSpellValue.h  |   20 +
 .../playerbot/strategy/values/LastMovementValue.h  |   61 +
 .../strategy/values/LastSpellCastTimeValue.h       |   11 +
 .../playerbot/strategy/values/LastSpellCastValue.h |   39 +
 .../strategy/values/LeastHpTargetValue.cpp         |   33 +
 .../playerbot/strategy/values/LeastHpTargetValue.h |   15 +
 src/plugins/playerbot/strategy/values/LfgValues.h  |   12 +
 .../playerbot/strategy/values/LineTargetValue.cpp  |   33 +
 .../playerbot/strategy/values/LineTargetValue.h    |   14 +
 .../playerbot/strategy/values/LogLevelValue.h      |   12 +
 .../playerbot/strategy/values/LootStrategyValue.h  |   11 +
 .../playerbot/strategy/values/ManaSaveLevelValue.h |   11 +
 .../playerbot/strategy/values/MasterTargetValue.h  |   13 +
 .../playerbot/strategy/values/NearestAdsValue.cpp  |   11 +
 .../playerbot/strategy/values/NearestAdsValue.h    |   18 +
 .../strategy/values/NearestCorpsesValue.cpp        |   36 +
 .../strategy/values/NearestCorpsesValue.h          |   19 +
 .../strategy/values/NearestGameObjects.cpp         |   47 +
 .../playerbot/strategy/values/NearestGameObjects.h |   19 +
 .../playerbot/strategy/values/NearestNpcsValue.cpp |   23 +
 .../playerbot/strategy/values/NearestNpcsValue.h   |   18 +
 .../playerbot/strategy/values/NearestUnitsValue.h  |   36 +
 .../strategy/values/PartyMemberToDispel.cpp        |   37 +
 .../strategy/values/PartyMemberToDispel.h          |   16 +
 .../strategy/values/PartyMemberToHeal.cpp          |   60 +
 .../playerbot/strategy/values/PartyMemberToHeal.h  |   17 +
 .../strategy/values/PartyMemberToResurrect.cpp     |   44 +
 .../strategy/values/PartyMemberToResurrect.h       |   16 +
 .../playerbot/strategy/values/PartyMemberValue.cpp |  111 ++
 .../playerbot/strategy/values/PartyMemberValue.h   |   31 +
 .../values/PartyMemberWithoutAuraValue.cpp         |   35 +
 .../strategy/values/PartyMemberWithoutAuraValue.h  |   17 +
 .../playerbot/strategy/values/PetTargetValue.h     |   13 +
 .../playerbot/strategy/values/PositionValue.cpp    |   10 +
 .../playerbot/strategy/values/PositionValue.h      |   26 +
 .../strategy/values/PossibleTargetsValue.cpp       |   23 +
 .../strategy/values/PossibleTargetsValue.h         |   19 +
 .../playerbot/strategy/values/RtiTargetValue.h     |   51 +
 src/plugins/playerbot/strategy/values/RtiValue.cpp |   36 +
 src/plugins/playerbot/strategy/values/RtiValue.h   |   11 +
 .../playerbot/strategy/values/SelfTargetValue.h    |   13 +
 .../strategy/values/SpellCastUsefulValue.cpp       |   44 +
 .../strategy/values/SpellCastUsefulValue.h         |   17 +
 .../playerbot/strategy/values/SpellIdValue.cpp     |   90 ++
 .../playerbot/strategy/values/SpellIdValue.h       |   17 +
 .../playerbot/strategy/values/StatsValues.cpp      |  111 ++
 .../playerbot/strategy/values/StatsValues.h        |  133 ++
 .../playerbot/strategy/values/TankTargetValue.cpp  |   47 +
 .../playerbot/strategy/values/TankTargetValue.h    |   16 +
 .../playerbot/strategy/values/TargetValue.cpp      |   54 +
 .../playerbot/strategy/values/TargetValue.h        |   39 +
 .../playerbot/strategy/values/ThreatValues.cpp     |   62 +
 .../playerbot/strategy/values/ThreatValues.h       |   17 +
 .../playerbot/strategy/values/ValueContext.h       |  222 +++
 .../playerbot/strategy/values/formations/Arrow.cpp |  157 ++
 .../playerbot/strategy/values/formations/Arrow.h   |  109 ++
 .../strategy/warlock/DpsWarlockStrategy.cpp        |   76 +
 .../strategy/warlock/DpsWarlockStrategy.h          |   39 +
 .../warlock/GenericWarlockNonCombatStrategy.cpp    |   65 +
 .../warlock/GenericWarlockNonCombatStrategy.h      |   16 +
 .../strategy/warlock/GenericWarlockStrategy.cpp    |   74 +
 .../strategy/warlock/GenericWarlockStrategy.h      |   18 +
 .../strategy/warlock/TankWarlockStrategy.cpp       |   51 +
 .../strategy/warlock/TankWarlockStrategy.h         |   17 +
 .../playerbot/strategy/warlock/WarlockActions.cpp  |    5 +
 .../playerbot/strategy/warlock/WarlockActions.h    |  176 +++
 .../strategy/warlock/WarlockAiObjectContext.cpp    |  183 +++
 .../strategy/warlock/WarlockAiObjectContext.h      |   12 +
 .../strategy/warlock/WarlockMultipliers.cpp        |    6 +
 .../strategy/warlock/WarlockMultipliers.h          |    6 +
 .../playerbot/strategy/warlock/WarlockTriggers.cpp |   19 +
 .../playerbot/strategy/warlock/WarlockTriggers.h   |   81 +
 .../strategy/warrior/DpsWarriorStrategy.cpp        |  130 ++
 .../strategy/warrior/DpsWarriorStrategy.h          |   28 +
 .../warrior/GenericWarriorNonCombatStrategy.cpp    |    7 +
 .../warrior/GenericWarriorNonCombatStrategy.h      |   13 +
 .../strategy/warrior/GenericWarriorStrategy.cpp    |   73 +
 .../strategy/warrior/GenericWarriorStrategy.h      |   19 +
 .../strategy/warrior/TankWarriorStrategy.cpp       |  126 ++
 .../strategy/warrior/TankWarriorStrategy.h         |   18 +
 .../playerbot/strategy/warrior/WarriorActions.cpp  |   30 +
 .../playerbot/strategy/warrior/WarriorActions.h    |  210 +++
 .../strategy/warrior/WarriorAiObjectContext.cpp    |  192 +++
 .../strategy/warrior/WarriorAiObjectContext.h      |   12 +
 .../strategy/warrior/WarriorMultipliers.cpp        |    6 +
 .../strategy/warrior/WarriorMultipliers.h          |    6 +
 .../playerbot/strategy/warrior/WarriorTriggers.cpp |    7 +
 .../playerbot/strategy/warrior/WarriorTriggers.h   |   78 +
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |    8 +
 src/server/game/CMakeLists.txt                     |    2 +-
 src/server/game/DungeonFinding/LFGQueue.cpp        |   15 +
 src/server/game/Entities/Player/Player.cpp         |   13 +
 src/server/game/Entities/Player/Player.h           |   20 +
 src/server/game/Groups/Group.h                     |    5 +
 src/server/game/Handlers/CharacterHandler.cpp      |   81 +
 src/server/game/Handlers/ChatHandler.cpp           |   87 +-
 src/server/game/Server/WorldSession.cpp            |   42 +-
 src/server/game/Server/WorldSession.h              |    7 +-
 src/server/game/World/World.cpp                    |   31 +-
 src/server/scripts/Commands/cs_ahbot.cpp           |    3 +-
 src/server/scripts/Commands/cs_misc.cpp            |    7 +
 src/server/shared/Configuration/Config.h           |    2 +
 src/server/worldserver/CMakeLists.txt              |    1 +
 593 files changed, 39731 insertions(+), 11 deletions(-)
 create mode 100644 sql/characters_ai_playerbot.sql
 create mode 100644 sql/characters_auctionhousebot.sql
 create mode 100644 src/plugins/CMakeLists.txt
 create mode 100644 src/plugins/ahbot/AhBot.cpp
 create mode 100644 src/plugins/ahbot/AhBot.h
 create mode 100644 src/plugins/ahbot/AhBotConfig.cpp
 create mode 100644 src/plugins/ahbot/AhBotConfig.h
 create mode 100644 src/plugins/ahbot/Category.cpp
 create mode 100644 src/plugins/ahbot/Category.h
 create mode 100644 src/plugins/ahbot/ConsumableCategory.cpp
 create mode 100644 src/plugins/ahbot/ConsumableCategory.h
 create mode 100644 src/plugins/ahbot/ItemBag.cpp
 create mode 100644 src/plugins/ahbot/ItemBag.h
 create mode 100644 src/plugins/ahbot/PricingStrategy.cpp
 create mode 100644 src/plugins/ahbot/PricingStrategy.h
 create mode 100644 src/plugins/ahbot/TradeCategory.cpp
 create mode 100644 src/plugins/ahbot/TradeCategory.h
 create mode 100644 src/plugins/ahbot/ahbot.conf.dist.in
 create mode 100644 src/plugins/pch/pch.cpp
 create mode 100644 src/plugins/pch/pch.h
 create mode 100644 src/plugins/pchdef.h
 create mode 100644 src/plugins/playerbot/AiFactory.cpp
 create mode 100644 src/plugins/playerbot/AiFactory.h
 create mode 100644 src/plugins/playerbot/ChatFilter.cpp
 create mode 100644 src/plugins/playerbot/ChatFilter.h
 create mode 100644 src/plugins/playerbot/ChatHelper.cpp
 create mode 100644 src/plugins/playerbot/ChatHelper.h
 create mode 100644 src/plugins/playerbot/FleeManager.cpp
 create mode 100644 src/plugins/playerbot/FleeManager.h
 create mode 100644 src/plugins/playerbot/Helpers.cpp
 create mode 100644 src/plugins/playerbot/LazyCalculatedValue.h
 create mode 100644 src/plugins/playerbot/LootObjectStack.cpp
 create mode 100644 src/plugins/playerbot/LootObjectStack.h
 create mode 100644 src/plugins/playerbot/PlayerbotAI.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAI.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIAware.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.h
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/aiplayerbot.conf.dist.in
 create mode 100644 src/plugins/playerbot/playerbot.h
 create mode 100644 src/plugins/playerbot/playerbotDefs.h
 create mode 100644 src/plugins/playerbot/strategy/Action.cpp
 create mode 100644 src/plugins/playerbot/strategy/Action.h
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.cpp
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.h
 create mode 100644 src/plugins/playerbot/strategy/AiObject.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObject.h
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/Engine.cpp
 create mode 100644 src/plugins/playerbot/strategy/Engine.h
 create mode 100644 src/plugins/playerbot/strategy/Event.cpp
 create mode 100644 src/plugins/playerbot/strategy/Event.h
 create mode 100644 src/plugins/playerbot/strategy/ExternalEventHelper.h
 create mode 100644 src/plugins/playerbot/strategy/ItemVisitors.h
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.h
 create mode 100644 src/plugins/playerbot/strategy/NamedObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.h
 create mode 100644 src/plugins/playerbot/strategy/Queue.cpp
 create mode 100644 src/plugins/playerbot/strategy/Queue.h
 create mode 100644 src/plugins/playerbot/strategy/Strategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/Strategy.h
 create mode 100644 src/plugins/playerbot/strategy/StrategyContext.h
 create mode 100644 src/plugins/playerbot/strategy/Trigger.cpp
 create mode 100644 src/plugins/playerbot/strategy/Trigger.h
 create mode 100644 src/plugins/playerbot/strategy/Value.cpp
 create mode 100644 src/plugins/playerbot/strategy/Value.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReachTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RtiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidBearActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidCatActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueComboActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LfgTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/RangeTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/TriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ChatValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DistanceValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.h
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasTotemValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsBehindValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsFacingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsMovingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastMovementValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LfgValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LogLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LootStrategyValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/MasterTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestUnitsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PetTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SelfTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/ValueContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.h

diff --git a/cmake/options.cmake b/cmake/options.cmake
index d4fc2f3..4f63e5a 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -17,3 +17,4 @@ option(WITH_WARNINGS    "Show all warnings during compile"
 option(WITH_COREDEBUG   "Include additional debug-code in core"                       0)
 option(WITH_MESHEXTRACTOR "Build meshextractor (alpha)"                               0)
 option(WITHOUT_GIT      "Disable the GIT testing routines"                            0)
+
diff --git a/sql/characters_ai_playerbot.sql b/sql/characters_ai_playerbot.sql
new file mode 100644
index 0000000..e29f627
--- /dev/null
+++ b/sql/characters_ai_playerbot.sql
@@ -0,0 +1,16 @@
+DROP TABLE IF EXISTS `ai_playerbot_random_bots`;
+
+CREATE TABLE `ai_playerbot_random_bots` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `bot` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `event` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `bot` (`bot`),
+  KEY `event` (`event`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/characters_auctionhousebot.sql b/sql/characters_auctionhousebot.sql
new file mode 100644
index 0000000..c2d8824
--- /dev/null
+++ b/sql/characters_auctionhousebot.sql
@@ -0,0 +1,37 @@
+DROP TABLE IF EXISTS `ahbot_history`;
+DROP TABLE IF EXISTS `ahbot_category`;
+DROP TABLE IF EXISTS `ahbot_price`;
+
+CREATE TABLE `ahbot_history` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `buytime` bigint(20) NOT NULL,
+  `item` bigint(20) NOT NULL,
+  `bid` bigint(20) NOT NULL,
+  `buyout` bigint(20) NOT NULL,
+  `won` bigint(20) NOT NULL,
+  `category` varchar(45) DEFAULT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `won` (`won`),
+  KEY `category` (`category`),
+  KEY `auction_house` (`auction_house`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_category` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `category` varchar(45) DEFAULT NULL,
+  `multiplier` decimal(20, 2) NOT NULL,
+  `max_auction_count` bigint(20) NOT NULL,
+  `expire_time` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `helper` (`category`, `multiplier`, `expire_time`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_price` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `item` varchar(45) DEFAULT NULL,
+  `price` decimal(20, 2) NOT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `ahbot_price_item` (`item`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index e7d7576..e9ccb74 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -10,8 +10,8 @@
 
 add_subdirectory(genrev)
 add_subdirectory(server)
+add_subdirectory(plugins)
 
 if(TOOLS)
   add_subdirectory(tools)
 endif(TOOLS)
-
diff --git a/src/plugins/CMakeLists.txt b/src/plugins/CMakeLists.txt
new file mode 100644
index 0000000..d46464b
--- /dev/null
+++ b/src/plugins/CMakeLists.txt
@@ -0,0 +1,141 @@
+# Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_Playerbot playerbot/*.cpp playerbot/*.h)
+file(GLOB_RECURSE sources_Ahbot ahbot/*.cpp ahbot/*.h)
+
+# Create plugins-libary
+
+if (USE_COREPCH)
+  set(plugins_STAT_PCH_HDR pch/pch.h)
+  set(plugins_STAT_PCH_SRC pch/pch.cpp)
+endif ()
+
+set(plugins_STAT_SRCS
+  ${sources_Playerbot}
+  ${sources_Ahbot}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouseBot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/pluginsObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+)
+
+add_library(plugins STATIC
+  ${plugins_STAT_SRCS}
+  ${plugins_STAT_PCH_SRC}
+)
+
+add_dependencies(plugins revision.h)
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(plugins ${plugins_STAT_PCH_HDR} ${plugins_STAT_PCH_SRC})
+endif ()
diff --git a/src/plugins/ahbot/AhBot.cpp b/src/plugins/ahbot/AhBot.cpp
new file mode 100644
index 0000000..b9b763a
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.cpp
@@ -0,0 +1,983 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBot.h"
+#include "../World/World.h"
+#include "../Chat.h"
+#include "AhBotConfig.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../../game/Entities/Player/Player.h"
+#include "../playerbot/PlayerbotAIConfig.h"
+#include "../playerbot/playerbot.h"
+
+using namespace ahbot;
+
+bool Player::MinimalLoadFromDB( QueryResult result, uint32 guid )
+{
+    if (!result)
+    {
+        //                                        0     1           2           3           4    5          6          7
+        result = CharacterDatabase.PQuery("SELECT name, position_x, position_y, position_z, map, totaltime, leveltime, at_login FROM characters WHERE guid = '%u'",guid);
+        if (!result)
+            return false;
+    }
+
+    Field *fields = result->Fetch();
+
+    m_name = fields[0].GetString();
+
+    Relocate(fields[1].GetFloat(),fields[2].GetFloat(),fields[3].GetFloat());
+    SetLocationMapId(fields[4].GetUInt32());
+
+    m_Played_time[PLAYED_TIME_TOTAL] = fields[5].GetUInt32();
+    m_Played_time[PLAYED_TIME_LEVEL] = fields[6].GetUInt32();
+
+    m_atLoginFlags = fields[7].GetUInt32();
+
+    for (int i = 0; i < PLAYER_SLOTS_COUNT; ++i)
+        m_items[i] = NULL;
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        m_deathState = DEAD;
+
+    return true;
+}
+
+bool AhBot::HandleAhBotCommand(ChatHandler* handler, char const* args)
+{
+    auctionbot.HandleCommand(args);
+    return true;
+}
+
+uint32 AhBot::auctionIds[MAX_AUCTIONS] = {1,6,7};
+uint32 AhBot::auctioneers[MAX_AUCTIONS] = {79707,4656,23442};
+map<uint32, uint32> AhBot::factions;
+
+void AhBot::Init()
+{
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "Initializing AhBot by ike3");
+
+    if (!sAhBotConfig.Initialize())
+        return;
+
+    factions[1] = 1;
+    factions[2] = 1;
+    factions[3] = 1;
+    factions[4] = 2;
+    factions[5] = 2;
+    factions[6] = 2;
+    factions[7] = 3;
+
+    availableItems.Init();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot configuration loaded");
+}
+
+AhBot::~AhBot()
+{
+}
+
+ObjectGuid AhBot::GetAHBplayerGUID()
+{
+    return ObjectGuid(sAhBotConfig.guid);
+}
+
+void AhBotThread(AhBot* ahbot)
+{
+    ahbot->ForceUpdate();
+}
+
+void AhBot::Update()
+{
+    time_t now = time(0);
+
+    if (now < nextAICheckTime)
+        return;
+
+    if (updating)
+        return;
+
+    nextAICheckTime = time(0) + sAhBotConfig.updateInterval;
+
+    thread ahBotThread(AhBotThread, this);
+    ahBotThread.detach();
+}
+
+void AhBot::ForceUpdate()
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (updating)
+        return;
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is now checking auctions");
+    updating = true;
+
+    if (!allBidders.size())
+        LoadRandomBots();
+
+    if (!allBidders.size())
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "Ahbot is disabled but there is no bidders available");
+        return;
+    }
+
+    CheckCategoryMultipliers();
+
+    int answered = 0, added = 0;
+    for (int i = 0; i < MAX_AUCTIONS; i++)
+    {
+        InAuctionItemsBag inAuctionItems(auctionIds[i]);
+        inAuctionItems.Init(true);
+
+        for (int j = 0; j < CategoryList::instance.size(); j++)
+        {
+            Category* category = CategoryList::instance[j];
+            answered += Answer(i, category, &inAuctionItems);
+            added += AddAuctions(i, category, &inAuctionItems);
+        }
+    }
+
+    CleanupHistory();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot auction check finished. %d auctions answered, %d new auctions added. Next check in %d seconds",
+            answered, added, sAhBotConfig.updateInterval);
+    updating = false;
+}
+
+struct SortByPricePredicate
+{
+    bool operator()(AuctionEntry* const & a, AuctionEntry* const & b) const
+    {
+        if (a->startbid == b->startbid)
+            return a->buyout < b->buyout;
+
+        return a->startbid < b->startbid;
+    }
+};
+
+vector<AuctionEntry*> AhBot::LoadAuctions(AuctionHouseObject* auctionHouse,
+        Category*& category, int& auction)
+{
+    vector<AuctionEntry*> entries;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (IsBotAuction(entry->owner) || IsBotAuction(entry->bidder))
+            continue;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item)
+            continue;
+
+        if (!category->Contains(item->GetTemplate()))
+            continue;
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(item->GetTemplate(), auctionIds[auction]);
+        if (!price || !item->GetCount())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price cannot be determined",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        entries.push_back(entry);
+    }
+    sort(entries.begin(), entries.end(), SortByPricePredicate());
+    return entries;
+}
+
+void AhBot::FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+        uint32* minBuyout)
+{
+    *minBid = 0;
+    *minBuyout = 0;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *other = itr->second;
+        if (other->owner == entry->owner)
+            continue;
+
+        Item *otherItem = sAuctionMgr->GetAItem(other->itemGUIDLow);
+        if (!otherItem || !otherItem->GetCount() || otherItem->GetTemplate()->ItemId != item->GetTemplate()->ItemId)
+            continue;
+
+        uint32 startbid = other->startbid / otherItem->GetCount() * item->GetCount();
+        uint32 bid = other->bid / otherItem->GetCount() * item->GetCount();
+        uint32 buyout = other->buyout / otherItem->GetCount() * item->GetCount();
+
+        if (!bid && startbid && (!*minBid || *minBid > startbid))
+            *minBid = startbid;
+
+        if (bid && (*minBid || *minBid > bid))
+            *minBid = bid;
+
+        if (buyout && (!*minBuyout || *minBuyout > buyout))
+            *minBuyout = buyout;
+    }
+}
+
+int AhBot::Answer(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if (!ahEntry)
+        return 0;
+
+    int answered = 0;
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    int64 availableMoney = GetAvailableMoney(auctionIds[auction]);
+
+    vector<AuctionEntry*> entries = LoadAuctions(auctionHouse, category, auction);
+    for (vector<AuctionEntry*>::iterator itr = entries.begin(); itr != entries.end(); ++itr)
+    {
+        AuctionEntry *entry = *itr;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item || !item->GetCount())
+            continue;
+
+        const ItemTemplate* proto = item->GetTemplate();
+        vector<uint32> items = availableItems.Get(category);
+        if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: unavailable item",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 answerCount = GetAnswerCount(proto->ItemId, auctionIds[auction], sAhBotConfig.itemBuyInterval);
+        uint32 maxAnswerCount = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAnswerCount && answerCount > maxAnswerCount)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: answer count %d > %d (max)",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], answerCount, maxAnswerCount);
+            continue;
+        }
+
+        if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: above max required or item level",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+        if (!price)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: cannot determine price",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 bidPrice = item->GetCount() * price;
+        uint32 buyoutPrice = item->GetCount() * urand(price, 4 * price / 3);
+
+        uint32 curPrice = entry->bid;
+        if (!curPrice) curPrice = entry->startbid;
+        if (!curPrice) curPrice = entry->buyout;
+
+        if (curPrice > buyoutPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (buyout price)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, buyoutPrice);
+            continue;
+        }
+
+        if (availableMoney < curPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (available money)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, availableMoney);
+            continue;
+        }
+
+        uint32 minBid = 0, minBuyout = 0;
+        FindMinPrice(auctionHouse, entry, item, &minBid, &minBuyout);
+
+        if (minBid && entry->bid && minBid < entry->bid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (bid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->bid, minBid);
+            continue;
+        }
+
+        if (minBid && entry->startbid && minBid < entry->startbid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (startbid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->startbid, minBid);
+            continue;
+        }
+
+        double priceLevel = (double)curPrice / (double)buyoutPrice;
+        uint32 buytime = GetBuyTime(entry->Id, proto->ItemId, auctionIds[auction], category, priceLevel);
+        if (time(0) < buytime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: will buy/bid in %d seconds",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], buytime - time(0));
+            continue;
+        }
+
+        uint32 bidder = GetRandomBidder(auctionIds[auction]);
+        if (!bidder)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+            break;
+        }
+
+        entry->bidder = bidder;
+        entry->bid = curPrice + urand(1, 1 + bidPrice / 10);
+        availableMoney -= curPrice;
+
+        updateMarketPrice(item->GetTemplate()->ItemId, entry->buyout / item->GetCount(), auctionIds[auction]);
+
+        if ((entry->buyout && (entry->bid >= entry->buyout || 100 * (entry->buyout - entry->bid) / price < 25)) &&
+                !(minBuyout && entry->buyout && minBuyout < entry->buyout))
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d won %s (x%d) in auction %d for %d",
+                    bidder, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->buyout);
+
+            entry->bid = entry->buyout;
+        }
+        else
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d placed bid %d for %s (x%d) in auction %d",
+                    bidder, entry->bid, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'",
+                entry->bidder, entry->bid, entry->Id);
+            AddToHistory(entry, AHBOT_WON_BID);
+        }
+
+        CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = 4 AND auction_house = '%u' ",
+                proto->ItemId, factions[auctionIds[auction]]);
+
+        answered++;
+    }
+
+    return answered;
+}
+
+uint32 AhBot::GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type)
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT MAX(buytime) FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    if (!results)
+        return 0;
+
+    Field* fields = results->Fetch();
+    uint32 result = fields[0].GetUInt32();
+
+    return result;
+}
+
+void AhBot::SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value)
+{
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        value, id, 0, 0,
+        category.c_str(), type, factions[auctionHouse]);
+}
+
+uint32 AhBot::GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel)
+{
+    uint32 entryTime = GetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY);
+    if (entryTime > time(0))
+        return entryTime;
+
+    uint32 result = entryTime;
+
+    string categoryName = category->GetName();
+    uint32 categoryTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.updateInterval, sAhBotConfig.itemBuyInterval / 2) * priceLevel / rarity;
+    itemTime += urand(sAhBotConfig.updateInterval, sAhBotConfig.itemBuyInterval) * priceLevel / rarity;
+    entryTime = max(categoryTime, itemTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY, itemTime);
+    SetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY, entryTime);
+
+    return result ? result : entryTime;
+}
+
+uint32 AhBot::GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category)
+{
+    uint32 itemSellTime = GetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 itemBuyTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = max(itemSellTime, itemBuyTime);
+
+    if (itemTime > time(0))
+        return itemTime;
+
+    uint32 result = itemTime;
+
+    string categoryName = category->GetName();
+    uint32 categorySellTime = GetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 categoryBuyTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 categoryTime = max(categorySellTime, categoryBuyTime);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.updateInterval, sAhBotConfig.itemSellInterval / 2) * rarity;
+    itemTime += urand(sAhBotConfig.updateInterval, sAhBotConfig.itemSellInterval) * rarity;
+    itemTime = max(itemTime, categoryTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY, itemTime);
+
+    return result ? result : itemTime;
+}
+
+int AhBot::AddAuctions(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    vector<uint32>& inAuction = inAuctionItems->Get(category);
+
+    int32 maxAllowedAuctionCount = categoryMaxAuctionCount[category->GetName()];
+    if (inAuctionItems->GetCount(category) >= maxAllowedAuctionCount)
+        return 0;
+
+    int added = 0;
+    vector<uint32> available = availableItems.Get(category);
+    for (int32 i = 0; i <= maxAllowedAuctionCount && available.size() > 0 && inAuctionItems->GetCount(category) < maxAllowedAuctionCount; ++i)
+    {
+        uint32 index = urand(0, available.size() - 1);
+        uint32 itemId = available[index];
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        int32 maxAllowedItems = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAllowedItems && inAuctionItems->GetCount(category, proto->ItemId) >= maxAllowedItems)
+            continue;
+
+        uint32 sellTime = GetSellTime(proto->ItemId, auctionIds[auction], category);
+        if (time(0) < sellTime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: will add in %d seconds",
+                    proto->Name1.c_str(), auctionIds[auction], sellTime - time(0));
+            continue;
+        }
+        else if (time(0) - sellTime > sAhBotConfig.maxSellInterval)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: too old (%d secs)",
+                    proto->Name1.c_str(), auctionIds[auction], time(0) - sellTime);
+            continue;
+        }
+
+        inAuctionItems->Add(proto);
+        added += AddAuction(auction, category, proto);
+    }
+
+    return added;
+}
+
+int AhBot::AddAuction(int auction, Category* category, ItemTemplate const* proto)
+{
+    uint32 owner = GetRandomBidder(auctionIds[auction]);
+    if (!owner)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+        return 0;
+    }
+
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return 0;
+
+    uint32 price = category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddAuction: market price adjust");
+    updateMarketPrice(proto->ItemId, price, auctionIds[auction]);
+
+    price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+    uint32 stackCount = category->GetStackCount(proto);
+    if (!price || !stackCount)
+        return 0;
+
+    if (urand(0, 100) <= sAhBotConfig.underPriceProbability * 100)
+        price = price * 100 / urand(100, 200);
+
+    uint32 bidPrice = stackCount * price;
+    uint32 buyoutPrice = stackCount * urand(price, 4 * price / 3);
+
+    Item* item = Item::CreateItem(proto->ItemId, stackCount);
+    if (!item)
+        return 0;
+
+    uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(proto->ItemId);
+    if (randomPropertyId)
+        item->SetItemRandomProperties(randomPropertyId);
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return 0;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionEntry* auctionEntry = new AuctionEntry;
+    auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+    auctionEntry->itemGUIDLow = item->GetGUIDLow();
+    auctionEntry->itemEntry = item->GetEntry();
+    auctionEntry->owner = owner;
+    auctionEntry->startbid = bidPrice;
+    auctionEntry->buyout = buyoutPrice;
+    auctionEntry->auctioneer = auctioneers[auction];
+    auctionEntry->bidder = 0;
+    auctionEntry->bid = 0;
+    auctionEntry->deposit = 0;
+    auctionEntry->expire_time = (time_t) (urand(8, 24) * 60 * 60 + time(NULL));
+    auctionEntry->auctionHouseEntry = ahEntry;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    item->SaveToDB(trans);
+    sAuctionMgr->AddAItem(item);
+    auctionHouse->AddAuction(auctionEntry);
+    auctionEntry->SaveToDB(trans);
+
+    auctionHouse->AddAuction(auctionEntry);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d added %d of %s to auction %d for %d..%d", owner, stackCount, proto->Name1.c_str(), auctionIds[auction], bidPrice, buyoutPrice);
+    return 1;
+}
+
+void AhBot::HandleCommand(string command)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (command == "expire")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            Expire(i);
+
+        return;
+    }
+
+    if (command == "stats")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            PrintStats(i);
+
+        return;
+    }
+
+    if (command == "update")
+    {
+        thread ahBotThread(AhBotThread, this);
+        ahBotThread.detach();
+        return;
+    }
+
+    uint32 itemId = atoi(command.c_str());
+    if (!itemId)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot stats - show short summary");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot expire - expire all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot update - update all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot <itemId> - show item price");
+        return;
+    }
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (category->Contains(proto))
+        {
+            vector<uint32> items = availableItems.Get(category);
+            if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+                continue;
+
+            ostringstream out;
+            out << proto->Name1 << " (" << category->GetDisplayName() << "), "
+                    << category->GetMaxAllowedAuctionCount() << "x" << category->GetMaxAllowedItemAuctionCount(proto)
+                    << "x" << category->GetStackCount(proto) << " max"
+                    << "\n";
+            for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+            {
+                const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+                out << "--- auction house " << auctionIds[auction] << "(faction: " << factions[auctionIds[auction]] << ", money: "
+                    << GetAvailableMoney(auctionIds[auction])
+                    << ") ---\n";
+
+                out << "sell: " << category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainSellPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+
+                out << "buy: " << category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainBuyPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+            }
+            sLog->outMessage("ahbot", LOG_LEVEL_INFO, out.str().c_str());
+            break;
+        }
+    }
+}
+
+void AhBot::Expire(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+
+    int count = 0;
+    while (itr != auctionHouse->GetAuctionsEnd())
+    {
+        if (IsBotAuction(itr->second->owner))
+        {
+            itr->second->expire_time = sWorld->GetGameTime();
+            count++;
+        }
+
+        ++itr;
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions marked as expired in auction %d", count, auctionIds[auction]);
+}
+
+void AhBot::PrintStats(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions available on auction house %d", auctionHouse->Getcount(), auctionIds[auction]);
+}
+
+void AhBot::AddToHistory(AuctionEntry* entry, uint32 won)
+{
+    if (!sAhBotConfig.enabled || !entry)
+        return;
+
+    if (!IsBotAuction(entry->owner) && !IsBotAuction(entry->bidder))
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry->itemEntry);
+    if (!proto)
+        return;
+
+    string category = "";
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            category = CategoryList::instance[i]->GetName();
+            break;
+        }
+    }
+
+    if (!won)
+    {
+        won = AHBOT_WON_PLAYER;
+        if (IsBotAuction(entry->bidder))
+            won = AHBOT_WON_SELF;
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddToHistory: market price adjust");
+    int count = entry->itemCount ? entry->itemCount : 1;
+    updateMarketPrice(proto->ItemId, entry->buyout / count, entry->auctionHouseEntry->houseId);
+
+    uint32 now = time(0);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        now, entry->itemEntry, entry->bid ? entry->bid : entry->startbid, entry->buyout,
+        category.c_str(), won, factions[entry->auctionHouseEntry->houseId]);
+}
+
+uint32 AhBot::GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime)
+{
+    uint32 count = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT COUNT(*) FROM ahbot_history WHERE "
+        "item = '%u' AND won in (2, 3) AND auction_house = '%u' AND buytime > '%u'",
+        itemId, factions[auctionHouse], time(0) - withinTime);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            count = fields[0].GetUInt32();
+        } while (results->NextRow());
+    }
+
+    return count;
+}
+
+void AhBot::CleanupHistory()
+{
+    uint32 when = time(0) - 3600 * 24 * sAhBotConfig.historyDays;
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE buytime < '%u'", when);
+}
+
+uint32 AhBot::GetAvailableMoney(uint32 auctionHouse)
+{
+    int64 result = sAhBotConfig.alwaysAvailableMoney;
+
+    map<uint32, uint32> data;
+    data[AHBOT_WON_PLAYER] = 0;
+    data[AHBOT_WON_SELF] = 0;
+
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionHouse);
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT won, SUM(bid) FROM ahbot_history WHERE auction_house = '%u' GROUP BY won HAVING won > 0 ORDER BY won",
+        factions[auctionHouse]);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            data[fields[0].GetUInt32()] = fields[1].GetUInt32();
+
+        } while (results->NextRow());
+    }
+
+    results = CharacterDatabase.PQuery(
+        "SELECT max(buytime) FROM ahbot_history WHERE auction_house = '%u' AND won = '2'",
+        factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 lastBuyTime = fields[0].GetUInt32();
+        uint32 now = time(0);
+        if (lastBuyTime && now > lastBuyTime)
+        result += (now - lastBuyTime) / 3600 / 24 * sAhBotConfig.alwaysAvailableMoney;
+    }
+
+    AuctionHouseObject* auctionHouseObject = sAuctionMgr->GetAuctionsMap(auctionHouse);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouseObject->GetAuctionsBegin(); itr != auctionHouseObject->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (!IsBotAuction(entry->bidder))
+            continue;
+
+        result -= entry->bid;
+    }
+
+    result += (data[AHBOT_WON_PLAYER] - data[AHBOT_WON_SELF]);
+    return result < 0 ? 0 : (uint32)result;
+}
+
+void AhBot::CheckCategoryMultipliers()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT category, multiplier, max_auction_count, expire_time FROM ahbot_category");
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            categoryMultipliers[fields[0].GetString()] = fields[1].GetFloat();
+            categoryMaxAuctionCount[fields[0].GetString()] = fields[2].GetInt32();
+            categoryMultiplierExpireTimes[fields[0].GetString()] = fields[3].GetUInt64();
+
+        } while (results->NextRow());
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        string name = CategoryList::instance[i]->GetName();
+        if (categoryMultiplierExpireTimes[name] <= time(0) || categoryMultipliers[name] <= 0)
+        {
+            categoryMultipliers[name] = (double)urand(20, 100) / 20.0;
+            uint32 maxAllowedAuctionCount = CategoryList::instance[i]->GetMaxAllowedAuctionCount();
+            categoryMaxAuctionCount[name] = urand(maxAllowedAuctionCount / 2, maxAllowedAuctionCount);
+            categoryMultiplierExpireTimes[name] = time(0) + urand(4, 7) * 3600 * 24;
+        }
+
+        CharacterDatabase.PExecute("INSERT INTO ahbot_category (category, multiplier, max_auction_count, expire_time) "
+                "VALUES ('%s', '%f', '%u', '%u')",
+                name.c_str(), categoryMultipliers[name], categoryMaxAuctionCount[name], categoryMultiplierExpireTimes[name]);
+    }
+}
+
+
+void AhBot::updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    if (marketPrice > 0)
+        marketPrice = (marketPrice + price) / 2;
+    else
+        marketPrice = price;
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_price (item, price, auction_house) VALUES ('%u', '%lf', '%u')", itemId, marketPrice, auctionHouse);
+}
+
+bool AhBot::IsBotAuction(uint32 bidder)
+{
+    return allBidders.find(bidder) != allBidders.end();
+}
+
+uint32 AhBot::GetRandomBidder(uint32 auctionHouse)
+{
+    vector<uint32> guids = bidders[factions[auctionHouse]];
+    if (guids.empty())
+        return 0;
+
+    vector<uint32> online;
+    for (vector<uint32>::iterator i = guids.begin(); i != guids.end(); ++i)
+    {
+        uint32 guid = *i;
+        Player* player = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (!player)
+            continue;
+
+        online.push_back(guid);
+    }
+
+    if (online.empty())
+        return 0;
+
+    int index = urand(0, online.size() - 1);
+    return online[index];
+}
+
+void AhBot::LoadRandomBots()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            uint32 auctionHouse = PlayerbotAI::IsOpposing(race, RACE_HUMAN) ? 2 : 1;
+            bidders[auctionHouse].push_back(guid);
+            bidders[3].push_back(guid);
+            allBidders.insert(guid);
+        } while (result->NextRow());
+    }
+
+    if (allBidders.empty() && sAhBotConfig.guid)
+    {
+        uint32 guid = sAhBotConfig.guid;
+        allBidders.insert(guid);
+        for (int i = 1; i <= 3; i++)
+        {
+            bidders[i].push_back(guid);
+        }
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "{A=%d,H=%d,N=%d} bidders loaded", bidders[1].size(), bidders[2].size(), bidders[3].size());
+}
+
+int32 AhBot::GetSellPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+            if (!price)
+                price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+int32 AhBot::GetBuyPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+            if (!price)
+                continue;
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+double AhBot::GetRarityPriceMultiplier(const ItemTemplate* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 1.0;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        return category->GetPricingStrategy()->GetRarityPriceMultiplier(proto->ItemId);
+    }
+
+    return 1.0;
+
+}
diff --git a/src/plugins/ahbot/AhBot.h b/src/plugins/ahbot/AhBot.h
new file mode 100644
index 0000000..ae0c531
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "Category.h"
+#include "ItemBag.h"
+#include "../playerbot/PlayerbotAIBase.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../pchdef.h"
+
+#define MAX_AUCTIONS 3
+#define AHBOT_WON_EXPIRE 0
+#define AHBOT_WON_PLAYER 1
+#define AHBOT_WON_SELF 2
+#define AHBOT_WON_BID 3
+#define AHBOT_WON_DELAY 4
+#define AHBOT_SELL_DELAY 5
+
+namespace ahbot
+{
+    using namespace std;
+
+    class AhBot
+    {
+    public:
+        AhBot() : nextAICheckTime(0), updating(false) {}
+        virtual ~AhBot();
+        static AhBot& instance()
+        {
+            static AhBot instance;
+            return instance;
+        }
+
+    public:
+        static bool HandleAhBotCommand(ChatHandler* handler, char const* args);
+        ObjectGuid GetAHBplayerGUID();
+        void Init();
+        void Update();
+        void ForceUpdate();
+        void HandleCommand(string command);
+        void Won(AuctionEntry* entry) { AddToHistory(entry); }
+        void Expired(AuctionEntry* entry) {}
+
+        double GetCategoryMultiplier(string category)
+        {
+            return categoryMultipliers[category];
+        }
+
+        int32 GetSellPrice(const ItemTemplate* proto);
+        int32 GetBuyPrice(const ItemTemplate* proto);
+        double GetRarityPriceMultiplier(const ItemTemplate* proto);
+
+    private:
+        int Answer(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuctions(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuction(int auction, Category* category, const ItemTemplate* proto);
+        void Expire(int auction);
+        void PrintStats(int auction);
+        void AddToHistory(AuctionEntry* entry, uint32 won = 0);
+        void CleanupHistory();
+        uint32 GetAvailableMoney(uint32 auctionHouse);
+        void CheckCategoryMultipliers();
+        void updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse);
+        bool IsBotAuction(uint32 bidder);
+        uint32 GetRandomBidder(uint32 auctionHouse);
+        void LoadRandomBots();
+        uint32 GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime);
+        vector<AuctionEntry*> LoadAuctions(AuctionHouseObject* auctionHouse, Category*& category,
+                int& auction);
+        void FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+                uint32* minBuyout);
+        uint32 GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel);
+        uint32 GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type);
+        void SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value);
+        uint32 GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category);
+
+    public:
+        static uint32 auctionIds[MAX_AUCTIONS];
+        static uint32 auctioneers[MAX_AUCTIONS];
+        static map<uint32, uint32> factions;
+
+    private:
+        AvailableItemsBag availableItems;
+        time_t nextAICheckTime;
+        map<string, double> categoryMultipliers;
+        map<string, uint32> categoryMaxAuctionCount;
+        map<string, uint64> categoryMultiplierExpireTimes;
+        map<uint32, vector<uint32> > bidders;
+        set<uint32> allBidders;
+        bool updating;
+    };
+};
+
+#define auctionbot ahbot::AhBot::instance()
diff --git a/src/plugins/ahbot/AhBotConfig.cpp b/src/plugins/ahbot/AhBotConfig.cpp
new file mode 100644
index 0000000..c0e4ac9
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.cpp
@@ -0,0 +1,57 @@
+#include "../pchdef.h"
+#include "AhBotConfig.h"
+#include "SystemConfig.h"
+std::vector<std::string> split(const std::string &s, char delim);
+
+using namespace std;
+
+AhBotConfig::AhBotConfig()
+{
+}
+
+template <class T>
+void LoadSet(string value, T &res)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        res.insert(id);
+    }
+}
+
+bool AhBotConfig::Initialize()
+{
+    string error;
+    if (!config.LoadInitial("ahbot.conf", error))
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled. Unable to open configuration file ahbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AhBot.Enabled", true);
+
+    if (!enabled)
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled in ahbot.conf");
+
+    guid = (uint64)config.GetIntDefault("AhBot.GUID", 0);
+    updateInterval = config.GetIntDefault("AhBot.UpdateIntervalInSeconds", 300);
+    historyDays = config.GetIntDefault("AhBot.History.Days", 30);
+    itemBuyInterval = config.GetIntDefault("AhBot.ItemBuyInterval", 28800);
+    itemSellInterval = config.GetIntDefault("AhBot.ItemSellInterval", 14400);
+    maxSellInterval = config.GetIntDefault("AhBot.MaxSellInterval", 3600 * 8);
+    alwaysAvailableMoney = config.GetIntDefault("AhBot.AlwaysAvailableMoney", 200000);
+    priceMultiplier = config.GetFloatDefault("AhBot.PriceMultiplier", 1.0f);
+    defaultMinPrice = config.GetIntDefault("AhBot.DefaultMinPrice", 20);
+    maxItemLevel = config.GetIntDefault("AhBot.MaxItemLevel", 199);
+    maxRequiredLevel = config.GetIntDefault("AhBot.MaxRequiredLevel", 80);
+    priceQualityMultiplier = config.GetFloatDefault("AhBot.PriceQualityMultiplier", 1.0f);
+    underPriceProbability = config.GetFloatDefault("AhBot.UnderPriceProbability", 0.05f);
+    LoadSet<set<uint32> >(config.GetStringDefault("AhBot.IgnoreItemIds", "49283,52200,8494,6345,6891,2460,37164,34835"), ignoreItemIds);
+
+
+    return enabled;
+}
diff --git a/src/plugins/ahbot/AhBotConfig.h b/src/plugins/ahbot/AhBotConfig.h
new file mode 100644
index 0000000..829240c
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.h
@@ -0,0 +1,91 @@
+#pragma once
+
+#include "../../shared/Configuration/Config.h"
+
+using namespace std;
+
+class AhBotConfig
+{
+public:
+    AhBotConfig();
+    static AhBotConfig& instance()
+    {
+        static AhBotConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+
+    bool enabled;
+    uint64 guid;
+    uint32 updateInterval;
+    uint32 historyDays, itemBuyInterval, itemSellInterval, maxSellInterval;
+    uint32 alwaysAvailableMoney;
+    float priceMultiplier, priceQualityMultiplier;
+    uint32 defaultMinPrice;
+    uint32 maxItemLevel, maxRequiredLevel;
+    float underPriceProbability;
+    std::set<uint32> ignoreItemIds;
+
+    float GetSellPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(sellPriceMultipliers, "PriceMultiplier.Sell", category, 1.0f);
+    }
+
+    float GetBuyPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(buyPriceMultipliers, "PriceMultiplier.Buy", category, 1.0f);
+    }
+
+    float GetItemPriceMultiplier(string name)
+    {
+        return GetCategoryParameter(itemPriceMultipliers, "PriceMultiplier.Item", name, 1.0f);
+    }
+
+    int32 GetMaxAllowedAuctionCount(string category)
+    {
+        return (int32)GetCategoryParameter(maxAuctionCount, "MaxAuctionCount", category, 5);
+    }
+
+    std::string GetStringDefault(const char* name, const char* def)
+    {
+        return config.GetStringDefault(name, def);
+    }
+
+    bool GetBoolDefault(const char* name, const bool def = false)
+    {
+        return config.GetBoolDefault(name, def);
+    }
+
+    int32 GetIntDefault(const char* name, const int32 def)
+    {
+        return config.GetIntDefault(name, def);
+    }
+
+    float GetFloatDefault(const char* name, const float def)
+    {
+        return config.GetFloatDefault(name, def);
+    }
+
+private:
+    float GetCategoryParameter(map<string, float>& cache, string type, string category, float defaultValue)
+    {
+        if (cache.find(category) == cache.end())
+        {
+            ostringstream out; out << "AhBot."<< type << "." << category;
+            cache[category] = config.GetFloatDefault(out.str().c_str(), defaultValue);
+        }
+
+        return cache[category];
+    }
+
+private:
+    ConfigMgr config;
+    map<string, float> sellPriceMultipliers;
+    map<string, float> buyPriceMultipliers;
+    map<string, float> itemPriceMultipliers;
+    map<string, float> maxAuctionCount;
+};
+
+#define sAhBotConfig AhBotConfig::instance()
diff --git a/src/plugins/ahbot/Category.cpp b/src/plugins/ahbot/Category.cpp
new file mode 100644
index 0000000..f4369e6
--- /dev/null
+++ b/src/plugins/ahbot/Category.cpp
@@ -0,0 +1,76 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "PricingStrategy.h"
+
+using namespace ahbot;
+
+uint32 Category::GetStackCount(ItemTemplate const* proto)
+{
+    if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+        return 1;
+
+    return urand(1, proto->GetMaxStackSize());
+}
+
+uint32 Category::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return 0;
+}
+
+uint32 Category::GetMaxAllowedAuctionCount()
+{
+    return sAhBotConfig.GetMaxAllowedAuctionCount(GetName());
+}
+
+PricingStrategy* Category::GetPricingStrategy()
+{
+    if (pricingStrategy)
+        return pricingStrategy;
+
+    ostringstream out; out << "AhBot.PricingStrategy." << GetName();
+    string name = sAhBotConfig.GetStringDefault(out.str().c_str(), "default");
+    return pricingStrategy = PricingStrategyFactory::Create(name, this);
+}
+
+QualityCategoryWrapper::QualityCategoryWrapper(Category* category, uint32 quality) : Category(), quality(quality), category(category)
+{
+    ostringstream out; out << category->GetName() << ".";
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR:
+        out << "gray";
+        break;
+    case ITEM_QUALITY_NORMAL:
+        out << "white";
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        out << "green";
+        break;
+    case ITEM_QUALITY_RARE:
+        out << "blue";
+        break;
+    default:
+        out << "epic";
+        break;
+    }
+
+    combinedName = out.str();
+}
+
+bool QualityCategoryWrapper::Contains(ItemTemplate const* proto)
+{
+    return proto->Quality == quality && category->Contains(proto);
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedAuctionCount()
+{
+    uint32 count = sAhBotConfig.GetMaxAllowedAuctionCount(combinedName);
+    return count > 0 ? count : category->GetMaxAllowedAuctionCount();
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return category->GetMaxAllowedItemAuctionCount(proto);
+}
diff --git a/src/plugins/ahbot/Category.h b/src/plugins/ahbot/Category.h
new file mode 100644
index 0000000..be1dd4e
--- /dev/null
+++ b/src/plugins/ahbot/Category.h
@@ -0,0 +1,354 @@
+#pragma once
+#include "PricingStrategy.h"
+#include "../Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category
+    {
+    public:
+        Category() : pricingStrategy(NULL) {}
+        virtual ~Category() { if (pricingStrategy) delete pricingStrategy; }
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto) { return false; }
+        virtual string GetName() { return "default"; }
+        virtual string GetDisplayName() { return GetName(); }
+
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto);
+
+        virtual PricingStrategy* GetPricingStrategy();
+
+    private:
+        PricingStrategy *pricingStrategy;
+    };
+
+    class Consumable : public Category
+    {
+    public:
+        Consumable() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONSUMABLE;
+        }
+
+        virtual string GetName() { return "consumable"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 10;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (maxStackSize == 1)
+                return 1;
+
+            if (maxStackSize <= 10)
+                return urand(1, 10);
+
+            return urand(1, 4) * maxStackSize / 5;
+        }
+    };
+
+    class Quest : public Category
+    {
+    public:
+        Quest() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUEST;
+        }
+        virtual string GetName() { return "quest"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (proto->Quality == ITEM_QUALITY_UNCOMMON && maxStackSize > 10)
+                maxStackSize = urand(1, 10);
+
+            if (maxStackSize > 20)
+                maxStackSize = urand(1, 20);
+
+            return maxStackSize;
+        }
+    };
+
+    class Trade : public Category
+    {
+    public:
+        Trade() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_TRADE_GOODS;
+        }
+        virtual string GetName() { return "trade"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            uint32 maxStack = proto->GetMaxStackSize();
+            if (maxStack < 2)
+                return maxStack;
+
+            switch (proto->Quality)
+            {
+            case ITEM_QUALITY_NORMAL:
+                return maxStack;
+            case ITEM_QUALITY_UNCOMMON:
+                return urand(1, maxStack);
+            }
+
+            return 1;
+        }
+    };
+
+    class Enchant : public Category
+    {
+    public:
+        Enchant() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PERMANENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "enchant"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Reagent : public Category
+    {
+    public:
+        Reagent() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_REAGENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "reagent"; }
+    };
+
+    class Recipe : public Category
+    {
+    public:
+        Recipe() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_RECIPE && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "recipe"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Equip : public Category
+    {
+    public:
+        Equip() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return (proto->Class == ITEM_CLASS_WEAPON ||
+                proto->Class == ITEM_CLASS_ARMOR) && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "equip"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Other : public Category
+    {
+    public:
+        Other() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Quality > ITEM_QUALITY_POOR && (
+                proto->Class == ITEM_CLASS_MISC ||
+                proto->Class == ITEM_CLASS_GENERIC ||
+                proto->Class == ITEM_CLASS_MONEY) && proto->ItemLevel > 1 && proto->SubClass != ITEM_SUBCLASS_JUNK_MOUNT;
+        }
+        virtual string GetName() { return "other"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Quiver : public Category
+    {
+    public:
+        Quiver() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUIVER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "quiver"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Projectile : public Category
+    {
+    public:
+        Projectile() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PROJECTILE;
+        }
+
+        virtual string GetName() { return "projectile"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return proto->GetMaxStackSize();
+        }
+    };
+
+    class Container : public Category
+    {
+    public:
+        Container() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONTAINER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "container"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Glyph : public Category
+    {
+    public:
+        Glyph() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GLYPH;
+        }
+
+        virtual string GetName() { return "glyph"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class QualityCategoryWrapper : public Category
+    {
+    public:
+        QualityCategoryWrapper(Category* category, uint32 quality);
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto);
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual string GetName() { return category->GetName(); }
+        virtual string GetDisplayName() { return combinedName; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto) { return category->GetStackCount(proto); }
+        virtual PricingStrategy* GetPricingStrategy() { return category->GetPricingStrategy(); }
+
+    private:
+        uint32 quality;
+        Category* category;
+        string combinedName;
+    };
+};
diff --git a/src/plugins/ahbot/ConsumableCategory.cpp b/src/plugins/ahbot/ConsumableCategory.cpp
new file mode 100644
index 0000000..99f893a
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.cpp
@@ -0,0 +1,5 @@
+#include "../pchdef.h"
+#include "ConsumableCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/ConsumableCategory.h b/src/plugins/ahbot/ConsumableCategory.h
new file mode 100644
index 0000000..6a7729f
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.h
@@ -0,0 +1,86 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Alchemy : public Consumable
+    {
+    public:
+        Alchemy() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION ||
+                    proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK);
+        }
+
+        virtual string GetName() { return "Alchemy"; }
+    };
+
+    class Scroll : public Consumable
+    {
+    public:
+        Scroll() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_SCROLL ||
+                    proto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT);
+        }
+
+        virtual string GetName() { return "Scroll"; }
+    };
+
+    class Food : public Consumable
+    {
+    public:
+        Food() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_FOOD;
+        }
+
+        virtual string GetName() { return "Food"; }
+    };
+
+    class Bandage : public Consumable
+    {
+    public:
+        Bandage() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_BANDAGE;
+        }
+
+        virtual string GetName() { return "Bandage"; }
+    };
+
+    class OtherConsumable : public Consumable
+    {
+    public:
+        OtherConsumable() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) && (proto->RequiredSkill || proto->Flags & ITEM_FLAG_UNK6);
+        }
+
+        virtual string GetName() { return "OtherConsumable"; }
+    };
+};
diff --git a/src/plugins/ahbot/ItemBag.cpp b/src/plugins/ahbot/ItemBag.cpp
new file mode 100644
index 0000000..3c3938b
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.cpp
@@ -0,0 +1,184 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "ConsumableCategory.h"
+#include "TradeCategory.h"
+#include "AhBotConfig.h"
+#include "../DataStores/DBCStructure.h"
+#include "../../shared/Logging/Log.h"
+#include "../../shared/Database/QueryResult.h"
+#include "../../shared/Database/DatabaseEnv.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+
+using namespace ahbot;
+char * strstri (const char* str1, const char* str2);
+
+CategoryList CategoryList::instance;
+
+CategoryList::CategoryList()
+{
+    Add(new Equip());
+    Add(new ahbot::Quest());
+    Add(new Quiver());
+    Add(new Projectile());
+
+    Add(new Recipe());
+    Add(new Container());
+
+    Add(new Reagent());
+    Add(new Enchant());
+    Add(new Alchemy());
+    Add(new Scroll());
+    Add(new Food());
+    Add(new Bandage());
+
+    Add(new Cloth());
+    Add(new Leather());
+    Add(new Herb());
+    Add(new Metal());
+    Add(new Disenchants());
+    Add(new Meat());
+    Add(new Engineering());
+    Add(new SimpleGems());
+    Add(new SocketGems());
+    Add(new Elemental());
+
+    Add(new Glyph());
+
+    Add(new OtherConsumable());
+    Add(new OtherTrade());
+    Add(new Other());
+}
+
+void CategoryList::Add(Category* category)
+{
+    for (uint32 quality = ITEM_QUALITY_NORMAL; quality <= ITEM_QUALITY_EPIC; ++quality)
+        categories.push_back(new QualityCategoryWrapper(category, quality));
+}
+
+CategoryList::~CategoryList()
+{
+    for (vector<Category*>::const_iterator i = categories.begin(); i != categories.end(); ++i)
+        delete *i;
+}
+
+ItemBag::ItemBag()
+{
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        content[CategoryList::instance[i]] = vector<uint32>();
+    }
+}
+
+void ItemBag::Init(bool silent)
+{
+    if (silent)
+    {
+        Load();
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Loading/Scanning %s...", GetName().c_str());
+
+    Load();
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        Shuffle(content[category]);
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "loaded %d %s items", content[category].size(), category->GetDisplayName().c_str());
+    }
+}
+
+int32 ItemBag::GetCount(Category* category, uint32 item)
+{
+    uint32 count = 0;
+
+    vector<uint32>& items = content[category];
+    for (vector<uint32>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        if (*i == item)
+            count++;
+    }
+
+    return count;
+}
+
+bool ItemBag::Add(ItemTemplate const* proto)
+{
+    if (!proto ||
+        proto->Bonding == BIND_WHEN_PICKED_UP ||
+        proto->Bonding == BIND_QUEST_ITEM)
+        return false;
+
+    if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        return false;
+
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+        return false;
+
+    if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test"))
+        return false;
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            content[CategoryList::instance[i]].push_back(proto->ItemId);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void AvailableItemsBag::Load()
+{
+    set<uint32> vendorItems;
+
+      QueryResult results = WorldDatabase.PQuery("SELECT item FROM npc_vendor where maxcount = 0");
+      if (results != NULL)
+      {
+          do
+          {
+              Field* fields = results->Fetch();
+              vendorItems.insert(fields[0].GetUInt32());
+          } while (results->NextRow());
+      }
+
+      ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+      for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+      {
+          ItemTemplate const& itemTemplate = i->second;
+          uint32 itemId = i->first;
+
+          if (vendorItems.find(itemTemplate.ItemId) != vendorItems.end())
+              continue;
+
+        Add(sObjectMgr->GetItemTemplate(itemId));
+    }
+
+}
+
+void InAuctionItemsBag::Load()
+{
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionId);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->second->itemEntry);
+        if (!proto)
+            continue;
+
+        Add(proto);
+    }
+}
+
+string InAuctionItemsBag::GetName()
+{
+    ostringstream out; out << "auction house " << auctionId;
+    return out.str();
+}
diff --git a/src/plugins/ahbot/ItemBag.h b/src/plugins/ahbot/ItemBag.h
new file mode 100644
index 0000000..d3891ec
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.h
@@ -0,0 +1,82 @@
+#pragma once
+#include "Category.h"
+
+namespace ahbot
+{
+    using namespace std;
+
+    class CategoryList
+    {
+    public:
+        CategoryList();
+        virtual ~CategoryList();
+
+        Category* operator[](int index) { return categories[index]; }
+        int32 size() { return categories.size(); }
+        static CategoryList instance;
+
+    private:
+        void Add(Category* category);
+
+    private:
+        vector<Category*> categories;
+    };
+
+    template<class T>
+    void Shuffle(vector<T>& items) 
+    {
+        uint32 count = items.size();
+        for (uint32 i = 0; i < count * 5; i++)
+        {
+            int i1 = urand(0, count - 1);
+            int i2 = urand(0, count - 1);
+
+            T item = items[i1];
+            items[i1] = items[i2];
+            items[i2] = item;
+        }
+    }
+
+    class ItemBag 
+    {
+    public:
+        ItemBag();
+
+    public:
+        void Init(bool silent = false);
+        vector<uint32>& Get(Category* category) { return content[category]; }
+        int32 GetCount(Category* category) { return content[category].size(); }
+        int32 GetCount(Category* category, uint32 item);
+        bool Add(ItemTemplate const* proto);
+
+    protected:
+        virtual void Load() = 0;
+        virtual string GetName() = 0;
+
+    protected:
+        map<Category*,vector<uint32> > content;
+    };
+
+    class AvailableItemsBag : public ItemBag
+    {
+    public:
+        AvailableItemsBag() {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName() { return "available"; }
+    };
+
+    class InAuctionItemsBag : public ItemBag
+    {
+    public:
+        InAuctionItemsBag(uint32 auctionId) : auctionId(auctionId) {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName();
+
+    private:
+        uint32 auctionId;
+    };
+};
diff --git a/src/plugins/ahbot/PricingStrategy.cpp b/src/plugins/ahbot/PricingStrategy.cpp
new file mode 100644
index 0000000..c7a2345
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.cpp
@@ -0,0 +1,220 @@
+#include "PricingStrategy.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "../../shared/Database/DatabaseEnv.h"
+#include "AhBot.h"
+
+using namespace ahbot;
+
+uint32 PricingStrategy::GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    uint32 now = time(0);
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(now, auctionHouse) *
+        GetItemPriceMultiplier(proto, now, auctionHouse) *
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) *
+        GetDefaultSellPrice(proto);
+    return (uint32)price;
+}
+
+double PricingStrategy::GetMarketPrice(uint32 itemId, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    return marketPrice;
+}
+
+uint32 PricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+
+    if (marketPrice > 0)
+        return marketPrice;
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) *
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) *
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) *
+        GetDefaultBuyPrice(proto);
+    return (uint32)price;
+}
+
+string PricingStrategy::ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    uint32 untilTime = time(0);
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rariry) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) << " (sell) * " <<
+        GetDefaultSellPrice(proto) << " (price)";
+    return out.str();
+}
+
+string PricingStrategy::ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+    if (marketPrice > 0)
+    {
+        out << marketPrice << " (market)";
+        return out.str();
+    }
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rarity) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) << " (buy) * " <<
+        GetDefaultBuyPrice(proto) << " (price)";
+    return out.str();
+}
+
+double PricingStrategy::GetRarityPriceMultiplier(uint32 itemId)
+{
+    double result = 1.0;
+
+    QueryResult results = WorldDatabase.PQuery(
+        "select max(Chance) from ( "
+        "select Chance from gameobject_loot_template where item = '%u' "
+        "union select Chance from spell_loot_template where item = '%u' "
+        "union select Chance from disenchant_loot_template where item = '%u' "
+        "union select Chance from fishing_loot_template where item = '%u' "
+        "union select Chance from item_loot_template where item = '%u' "
+        "union select Chance from milling_loot_template where item = '%u' "
+        "union select Chance from pickpocketing_loot_template where item = '%u' "
+        "union select Chance from prospecting_loot_template where item = '%u' "
+        "union select Chance from reference_loot_template where item = '%u' "
+        "union select Chance from skinning_loot_template where item = '%u' "
+        "union select Chance from creature_loot_template where item = '%u' "
+        "union select 0 "
+        ") a",
+        itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        float chance = fields[0].GetFloat();
+
+        if (chance > 0 && chance <= 90.0)
+            result = sqrt((100.0 - chance) / 10.0);
+    }
+
+    return result >= 1.0 ? result : 1.0;
+}
+
+
+double PricingStrategy::GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE category = '%s' AND won = '1' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        category->GetName().c_str(), untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+double PricingStrategy::GetMultiplier(double count, double firstBuyTime, double lastBuyTime)
+{
+    double k1 = (double)count / (double)((time(0) - firstBuyTime) / 3600 / 24 + 1);
+    double k2 = (double)count / (double)((time(0) - lastBuyTime) / 3600 / 24 + 1);
+    return max(1.0, k1 + k2) * sAhBotConfig.priceMultiplier;
+}
+
+double PricingStrategy::GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE won = '1' AND item = '%u' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        proto->ItemId, untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+uint32 PricingStrategy::ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price)
+{
+    if (proto->Quality == ITEM_QUALITY_POOR)
+        return price;
+
+    return (uint32)(price * sqrt((double)proto->Quality) * sAhBotConfig.priceQualityMultiplier);
+}
+
+uint32 PricingStrategy::GetDefaultBuyPrice(ItemTemplate const* proto)
+{
+    uint32 price = 0;
+
+    if (proto->SellPrice)
+        price = proto->SellPrice;
+    if (proto->BuyPrice)
+        price = max(price, (uint32)(proto->BuyPrice / 4));
+
+    uint32 level = max(proto->ItemLevel, proto->RequiredLevel);
+    if (proto->Class == ITEM_CLASS_QUEST)
+    {
+        double result = 1.0;
+
+        QueryResult results = WorldDatabase.PQuery(
+            "select max(Level), max(MinLevel) from quest_template where RequiredItemId1 = %u or RequiredItemId2 = %u or RequiredItemId3 = %u or RequiredItemId4 = %u or RequiredItemId5 = %u or RequiredItemId6 = %u",
+            proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId);
+        if (results)
+        {
+            Field* fields = results->Fetch();
+            level = max(fields[0].GetUInt32(), fields[1].GetUInt32());
+        }
+    }
+    price = max(price, sAhBotConfig.defaultMinPrice * level * level / 10);
+    price = max(price, (uint32)100);
+
+    return ApplyQualityMultiplier(proto, price) * sAhBotConfig.priceMultiplier;
+}
+
+uint32 PricingStrategy::GetDefaultSellPrice(ItemTemplate const* proto)
+{
+    return GetDefaultBuyPrice(proto);
+}
+
+
+uint32 BuyOnlyRarePricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    if (proto->Quality < ITEM_QUALITY_RARE)
+        return 0;
+
+    return PricingStrategy::GetBuyPrice(proto, auctionHouse);
+}
+
diff --git a/src/plugins/ahbot/PricingStrategy.h b/src/plugins/ahbot/PricingStrategy.h
new file mode 100644
index 0000000..35f570f
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "../../game/Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category;
+
+    class PricingStrategy
+    {
+    public:
+        PricingStrategy(Category* category) : category(category) {}
+
+    public:
+        virtual uint32 GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual double GetRarityPriceMultiplier(uint32 itemId);
+
+    protected:
+        virtual uint32 GetDefaultBuyPrice(ItemTemplate const* proto);
+        virtual uint32 GetDefaultSellPrice(ItemTemplate const* proto);
+        virtual uint32 ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price);
+        virtual double GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse);
+        virtual double GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse);
+        double GetMultiplier(double count, double firstBuyTime, double lastBuyTime);
+        double GetMarketPrice(uint32 itemId, uint32 auctionHouse);
+
+    protected:
+        Category* category;
+    };
+
+    class BuyOnlyRarePricingStrategy : public PricingStrategy
+    {
+    public:
+        BuyOnlyRarePricingStrategy(Category* category) : PricingStrategy(category) {}
+
+    public:
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+    };
+
+    class PricingStrategyFactory
+    {
+    public:
+        static PricingStrategy* Create(string name, Category* category)
+        {
+            if (name == "buyOnlyRare")
+                return new BuyOnlyRarePricingStrategy(category);
+
+            return new PricingStrategy(category);
+        }
+    };
+};
diff --git a/src/plugins/ahbot/TradeCategory.cpp b/src/plugins/ahbot/TradeCategory.cpp
new file mode 100644
index 0000000..f0a814c
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.cpp
@@ -0,0 +1,4 @@
+#include "TradeCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/TradeCategory.h b/src/plugins/ahbot/TradeCategory.h
new file mode 100644
index 0000000..486cb61
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.h
@@ -0,0 +1,183 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Cloth : public Trade
+    {
+    public:
+        Cloth() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "Cloth"; }
+    };
+
+    class Leather : public Trade
+    {
+    public:
+        Leather() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_LEATHER;
+        }
+
+        virtual string GetName() { return "Leather"; }
+    };
+
+    class Elemental : public Trade
+    {
+    public:
+        Elemental() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                proto->SubClass == ITEM_SUBCLASS_ELEMENTAL;
+        }
+
+        virtual string GetName() { return "Elemental"; }
+    };
+
+    class Herb : public Trade
+    {
+    public:
+        Herb() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_HERB;
+        }
+
+        virtual string GetName() { return "Herb"; }
+    };
+
+    class Meat : public Trade
+    {
+    public:
+        Meat() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_MEAT;
+        }
+
+        virtual string GetName() { return "Meat"; }
+    };
+
+    class Metal : public Trade
+    {
+    public:
+        Metal() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_METAL_STONE;
+        }
+
+        virtual string GetName() { return "Metal"; }
+    };
+
+    class Disenchants : public Trade
+    {
+    public:
+        Disenchants() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_ENCHANTING;
+        }
+
+        virtual string GetName() { return "Disenchants"; }
+    };
+
+    class SimpleGems : public Trade
+    {
+    public:
+        SimpleGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SimpleGems"; }
+    };
+
+    class SocketGems : public Trade
+    {
+    public:
+        SocketGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SocketGems"; }
+    };
+
+    class Engineering : public Trade
+    {
+    public:
+        Engineering() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_PARTS ||
+                    proto->SubClass == ITEM_SUBCLASS_DEVICES ||
+                    proto->SubClass == ITEM_SUBCLASS_MATERIAL ||
+                    proto->SubClass == ITEM_SUBCLASS_EXPLOSIVES);
+        }
+
+        virtual string GetName() { return "Engineering"; }
+    };
+
+    class OtherTrade : public Trade
+    {
+    public:
+        OtherTrade() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass != ITEM_SUBCLASS_PARTS &&
+                    proto->SubClass != ITEM_SUBCLASS_DEVICES &&
+                    proto->SubClass != ITEM_SUBCLASS_MATERIAL &&
+                    proto->SubClass != ITEM_SUBCLASS_EXPLOSIVES &&
+                    proto->SubClass != ITEM_SUBCLASS_ENCHANTING &&
+                    proto->SubClass != ITEM_SUBCLASS_JEWELCRAFTING &&
+                    proto->SubClass != ITEM_SUBCLASS_METAL_STONE &&
+                    proto->SubClass != ITEM_SUBCLASS_MEAT &&
+                    proto->SubClass != ITEM_SUBCLASS_HERB &&
+                    proto->SubClass != ITEM_SUBCLASS_LEATHER &&
+                    proto->SubClass != ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "OtherTrade"; }
+    };
+};
diff --git a/src/plugins/ahbot/ahbot.conf.dist.in b/src/plugins/ahbot/ahbot.conf.dist.in
new file mode 100644
index 0000000..fb4576b
--- /dev/null
+++ b/src/plugins/ahbot/ahbot.conf.dist.in
@@ -0,0 +1,203 @@
+################################################
+# MANGOS Auction House Bot Configuration file  #
+################################################
+
+[AhbotConf]
+ConfVersion=2010102201
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+###################################################################################################################
+
+# Disable original AuctionHouseBot
+AuctionHouseBot.Seller.Enabled = 0
+AuctionHouseBot.Buyer.Enabled = 0
+
+# Replace with the new AhBot
+AhBot.Enabled = 1
+
+# Should be used only if random bots are disabled
+# AhBot.GUID = 0
+
+# 199 for 80, 80 for 70, 70 for 60, ..., 25 for 20
+AhBot.MaxItemLevel = 199
+# Same as level cap
+AhBot.MaxRequiredLevel = 80
+
+# Ignore items by ID
+AhBot.IgnoreItemIds = 49283,52200,8494,6345,6891,2460
+
+AhBot.PriceMultiplier = 1.0
+AhBot.DefaultMinPrice = 20
+AhBot.PriceQualityMultiplier = 1.0
+AhBot.AlwaysAvailableMoney = 2000000
+
+#
+# Items
+#
+
+AhBot.MaxAuctionCount.equip.green = 0
+AhBot.MaxAuctionCount.equip.blue = 40
+AhBot.MaxAuctionCount.equip.epic = 20
+AhBot.PriceMultiplier.Sell.equip = 1.0
+AhBot.PriceMultiplier.Buy.equip = 1.0
+AhBot.PricingStrategy.equip = buyOnlyRare
+
+AhBot.MaxAuctionCount.reagent.white = 6
+AhBot.MaxAuctionCount.reagent.green = 2
+AhBot.PriceMultiplier.Sell.reagent = 1.0
+AhBot.PriceMultiplier.Buy.reagent = 1.0
+AhBot.PricingStrategy.reagent = buyOnlyRare
+
+AhBot.MaxAuctionCount.other.white = 20
+AhBot.MaxAuctionCount.other.green = 10
+AhBot.MaxAuctionCount.other.blue = 6
+AhBot.PriceMultiplier.Sell.other = 1.0
+AhBot.PriceMultiplier.Buy.other = 1.0
+AhBot.PricingStrategy.other = buyOnlyRare
+
+#
+# Container
+#
+
+AhBot.MaxAuctionCount.quiver.white = 2
+AhBot.PriceMultiplier.Sell.quiver = 1.0
+AhBot.PriceMultiplier.Buy.quiver = 1.0
+AhBot.PricingStrategy.quiver = buyOnlyRare
+
+AhBot.MaxAuctionCount.container.white = 6
+AhBot.MaxAuctionCount.container.green = 2
+AhBot.MaxAuctionCount.container.blue = 2
+AhBot.PriceMultiplier.Sell.container = 1.0
+AhBot.PriceMultiplier.Buy.container = 1.0
+
+#
+# Glyph
+#
+
+AhBot.MaxAuctionCount.glyph.white = 50
+AhBot.MaxAuctionCount.glyph.green = 20
+AhBot.MaxAuctionCount.glyph.blue = 10
+AhBot.PriceMultiplier.Sell.glyph = 1.0
+AhBot.PriceMultiplier.Buy.glyph = 1.0
+
+#
+# Quest
+#
+
+AhBot.MaxAuctionCount.quest.white = 14
+AhBot.MaxAuctionCount.quest.green = 2
+AhBot.MaxAuctionCount.quest.blue = 2
+AhBot.PriceMultiplier.Sell.quest = 1.0
+AhBot.PriceMultiplier.Buy.quest = 1.0
+
+#
+# Consumables
+#
+
+AhBot.MaxAuctionCount.alchemy.white = 50
+AhBot.MaxAuctionCount.alchemy.green = 20
+AhBot.MaxAuctionCount.alchemy.blue = 10
+AhBot.PriceMultiplier.Sell.alchemy = 1.0
+AhBot.PriceMultiplier.Buy.alchemy = 1.0
+
+AhBot.MaxAuctionCount.scroll.white = 40
+AhBot.MaxAuctionCount.scroll.green = 6
+AhBot.MaxAuctionCount.scroll.blue = 4
+AhBot.PriceMultiplier.Sell.scroll = 1.0
+AhBot.PriceMultiplier.Buy.scroll = 1.0
+
+AhBot.MaxAuctionCount.Food.white = 40
+AhBot.PriceMultiplier.Sell.Food = 1.0
+AhBot.PriceMultiplier.Buy.Food = 1.0
+
+AhBot.MaxAuctionCount.bandage.white = 10
+AhBot.PriceMultiplier.Sell.bandage = 1.0
+AhBot.PriceMultiplier.Buy.bandage = 1.0
+
+AhBot.MaxAuctionCount.OtherConsumable.white = 20
+AhBot.MaxAuctionCount.OtherConsumable.green = 10
+AhBot.MaxAuctionCount.OtherConsumable.blue = 5
+AhBot.PriceMultiplier.Sell.OtherConsumable = 1.0
+AhBot.PriceMultiplier.Buy.OtherConsumable = 1.0
+
+#
+# Recipe
+#
+
+AhBot.MaxAuctionCount.recipe.white = 8
+AhBot.MaxAuctionCount.recipe.green = 4
+AhBot.MaxAuctionCount.recipe.blue = 2
+AhBot.MaxAuctionCount.recipe.epic = 2
+AhBot.PriceMultiplier.Sell.recipe = 1.0
+AhBot.PriceMultiplier.Buy.recipe = 1.0
+
+#
+# Trade
+#
+
+AhBot.MaxAuctionCount.Elemental.white = 30
+AhBot.MaxAuctionCount.Elemental.green = 20
+AhBot.MaxAuctionCount.Elemental.blue = 6
+AhBot.PriceMultiplier.Sell.Elemental = 1.0
+AhBot.PriceMultiplier.Buy.Elemental = 1.0
+
+AhBot.MaxAuctionCount.Cloth.white = 50
+AhBot.MaxAuctionCount.Cloth.green = 14
+AhBot.MaxAuctionCount.Cloth.blue = 6
+AhBot.PriceMultiplier.Sell.Cloth = 1.0
+AhBot.PriceMultiplier.Buy.Cloth = 1.0
+
+AhBot.MaxAuctionCount.Leather.white = 50
+AhBot.MaxAuctionCount.Leather.green = 14
+AhBot.MaxAuctionCount.Leather.blue = 6
+AhBot.PriceMultiplier.Sell.Leather = 1.0
+AhBot.PriceMultiplier.Buy.Leather = 1.0
+
+AhBot.MaxAuctionCount.Herb.white = 50
+AhBot.MaxAuctionCount.Herb.green = 14
+AhBot.PriceMultiplier.Sell.Herb = 1.0
+AhBot.PriceMultiplier.Buy.Herb = 1.0
+
+AhBot.MaxAuctionCount.Meat.white = 50
+AhBot.PriceMultiplier.Sell.Meat = 1.0
+AhBot.PriceMultiplier.Buy.Meat = 1.0
+
+AhBot.MaxAuctionCount.Metal.white = 50
+AhBot.MaxAuctionCount.Metal.green = 14
+AhBot.MaxAuctionCount.Metal.blue = 6
+AhBot.PriceMultiplier.Sell.Metal = 1.0
+AhBot.PriceMultiplier.Buy.Metal = 1.0
+
+AhBot.MaxAuctionCount.Engineering.white = 20
+AhBot.MaxAuctionCount.Engineering.green = 10
+AhBot.MaxAuctionCount.Engineering.blue = 4
+AhBot.PriceMultiplier.Sell.Engineering = 1.0
+AhBot.PriceMultiplier.Buy.Engineering = 1.0
+
+AhBot.MaxAuctionCount.Disenchants.white = 40
+AhBot.MaxAuctionCount.Disenchants.green = 20
+AhBot.MaxAuctionCount.Disenchants.blue = 20
+AhBot.PriceMultiplier.Sell.Disenchants = 1.0
+AhBot.PriceMultiplier.Buy.Disenchants = 1.0
+
+AhBot.MaxAuctionCount.SimpleGems.green = 30
+AhBot.MaxAuctionCount.SimpleGems.blue = 20
+AhBot.MaxAuctionCount.SimpleGems.epic = 4
+AhBot.PriceMultiplier.Sell.SimpleGems = 1.0
+AhBot.PriceMultiplier.Buy.SimpleGems = 1.0
+
+AhBot.MaxAuctionCount.SocketGems.green = 50
+AhBot.MaxAuctionCount.SocketGems.blue = 20
+AhBot.MaxAuctionCount.SocketGems.epic = 4
+AhBot.PriceMultiplier.Sell.SocketGems = 1.0
+AhBot.PriceMultiplier.Buy.SocketGems = 1.0
+
+AhBot.MaxAuctionCount.OtherTrade.white = 10
+AhBot.PriceMultiplier.Sell.OtherTrade = 1.0
+AhBot.PriceMultiplier.Buy.OtherTrade = 1.0
+
+AhBot.PriceMultiplier.Sell.projectile = 1.0
+AhBot.PriceMultiplier.Buy.projectile = 1.0
+AhBot.PricingStrategy.projectile = buyOnlyRare
diff --git a/src/plugins/pch/pch.cpp b/src/plugins/pch/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/plugins/pch/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/plugins/pch/pch.h b/src/plugins/pch/pch.h
new file mode 100644
index 0000000..c7c6ca5
--- /dev/null
+++ b/src/plugins/pch/pch.h
@@ -0,0 +1,10 @@
+//add here most rarely modified headers to speed up debug build compilation
+
+#include "Common.h"
+#include "MapManager.h"
+#include "Log.h"
+#include "ObjectAccessor.h"
+#include "ObjectDefines.h"
+#include "Opcodes.h"
+#include "SharedDefines.h"
+#include "ObjectMgr.h"
diff --git a/src/plugins/pchdef.h b/src/plugins/pchdef.h
new file mode 100644
index 0000000..7646193
--- /dev/null
+++ b/src/plugins/pchdef.h
@@ -0,0 +1,4 @@
+#ifndef PCHDEF_H_
+#define PCHDEF_H_
+
+#endif /* PCHDEF_H_ */
diff --git a/src/plugins/playerbot/AiFactory.cpp b/src/plugins/playerbot/AiFactory.cpp
new file mode 100644
index 0000000..b17eb23
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.cpp
@@ -0,0 +1,227 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "AiFactory.h"
+#include "strategy/Engine.h"
+
+#include "strategy/priest/PriestAiObjectContext.h"
+#include "strategy/mage/MageAiObjectContext.h"
+#include "strategy/warlock/WarlockAiObjectContext.h"
+#include "strategy/warrior/WarriorAiObjectContext.h"
+#include "strategy/shaman/ShamanAiObjectContext.h"
+#include "strategy/paladin/PaladinAiObjectContext.h"
+#include "strategy/druid/DruidAiObjectContext.h"
+#include "strategy/hunter/HunterAiObjectContext.h"
+#include "strategy/rogue/RogueAiObjectContext.h"
+#include "../Entities/Player/Player.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomPlayerbotMgr.h"
+
+
+AiObjectContext* AiFactory::createAiObjectContext(Player* player, PlayerbotAI* ai)
+{
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return new PriestAiObjectContext(ai);
+        break;
+    case CLASS_MAGE:
+        return new MageAiObjectContext(ai);
+        break;
+    case CLASS_WARLOCK:
+        return new WarlockAiObjectContext(ai);
+        break;
+    case CLASS_WARRIOR:
+        return new WarriorAiObjectContext(ai);
+        break;
+    case CLASS_SHAMAN:
+        return new ShamanAiObjectContext(ai);
+        break;
+    case CLASS_PALADIN:
+        return new PaladinAiObjectContext(ai);
+        break;
+    case CLASS_DRUID:
+        return new DruidAiObjectContext(ai);
+        break;
+    case CLASS_HUNTER:
+        return new HunterAiObjectContext(ai);
+        break;
+    case CLASS_ROGUE:
+        return new RogueAiObjectContext(ai);
+        break;
+    }
+    return new AiObjectContext(ai);
+}
+
+int AiFactory::GetPlayerSpecTab(Player* player)
+{
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    if (c0 >= c1 && c0 >= c2)
+        return 0;
+
+    if (c1 >= c0 && c1 >= c2)
+        return 1;
+
+    return 2;
+}
+
+void AiFactory::AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    engine->addStrategies("attack weak", "racials", "chat", "default", "aoe", "potions", "cast time", "conserve mana", "duel", "pvp", NULL);
+
+    switch (player->getClass())
+    {
+        case CLASS_PRIEST:
+            if (tab == 2)
+            {
+                engine->addStrategies("dps", "threat", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("dps debuff");
+            }
+            else
+                engine->addStrategy("heal");
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_MAGE:
+            if (tab == 0)
+                engine->addStrategies("arcane", "threat", NULL);
+            else if (tab == 1)
+                engine->addStrategies("fire", "fire aoe", "threat", NULL);
+            else
+                engine->addStrategies("frost", "frost aoe", "threat", NULL);
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_WARRIOR:
+            if (tab == 2)
+                engine->addStrategies("tank", "tank aoe", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_SHAMAN:
+            if (tab == 0)
+                engine->addStrategies("caster", "caster aoe", "bmana", "threat", "flee", NULL);
+            else if (tab == 2)
+                engine->addStrategies("heal", "bmana", "flee", NULL);
+            else
+                engine->addStrategies("dps", "melee aoe", "bdps", "threat", NULL);
+            break;
+        case CLASS_PALADIN:
+            if (tab == 1)
+                engine->addStrategies("tank", "tank aoe", "barmor", NULL);
+            else
+                engine->addStrategies("dps", "bdps", "threat", NULL);
+            break;
+        case CLASS_DRUID:
+            if (tab == 0)
+            {
+                engine->addStrategies("caster", "caster aoe", "threat", "flee", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("caster debuff");
+            }
+            else if (tab == 2)
+                engine->addStrategies("heal", "flee", NULL);
+            else
+                engine->addStrategies("bear", "tank aoe", "threat", "flee", NULL);
+            break;
+        case CLASS_HUNTER:
+            engine->addStrategies("dps", "bdps", "threat", NULL);
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+            break;
+        case CLASS_ROGUE:
+            engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_WARLOCK:
+            if (tab == 1)
+                engine->addStrategies("tank", "threat", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+
+            engine->addStrategy("flee");
+            break;
+    }
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        engine->ChangeStrategy(sPlayerbotAIConfig.randomBotCombatStrategies);
+    }
+}
+
+Engine* AiFactory::createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* engine = new Engine(facade, AiObjectContext);
+    AddDefaultCombatStrategies(player, facade, engine);
+    return engine;
+}
+
+void AiFactory::AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    switch (player->getClass()){
+        case CLASS_PALADIN:
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+            nonCombatEngine->addStrategy("bmana");
+            break;
+        case CLASS_MAGE:
+            if (tab == 1)
+                nonCombatEngine->addStrategy("bdps");
+            else
+                nonCombatEngine->addStrategy("bmana");
+            break;
+    }
+    nonCombatEngine->addStrategies("nc", "attack weak", "food", "stay", "chat",
+            "default", "quest", "loot", "gather", "duel", "emote", NULL);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        nonCombatEngine->ChangeStrategy(sPlayerbotAIConfig.randomBotNonCombatStrategies);
+    }
+
+}
+
+Engine* AiFactory::createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* nonCombatEngine = new Engine(facade, AiObjectContext);
+
+    AddDefaultNonCombatStrategies(player, facade, nonCombatEngine);
+	return nonCombatEngine;
+}
+
+void AiFactory::AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine)
+{
+    deadEngine->addStrategies("dead", "stay", "chat", "default", "follow", NULL);
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        deadEngine->removeStrategy("follow");
+    }
+}
+
+Engine* AiFactory::createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+    Engine* deadEngine = new Engine(facade, AiObjectContext);
+    AddDefaultDeadStrategies(player, facade, deadEngine);
+    return deadEngine;
+}
diff --git a/src/plugins/playerbot/AiFactory.h b/src/plugins/playerbot/AiFactory.h
new file mode 100644
index 0000000..a14576b
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.h
@@ -0,0 +1,20 @@
+#pragma once
+
+class Player;
+
+using namespace ai;
+
+class AiFactory
+{
+public:
+    static AiObjectContext* createAiObjectContext(Player* player, PlayerbotAI* ai);
+	static Engine* createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+	static Engine* createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static Engine* createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static void AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine);
+    static void AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine);
+    static void AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine);
+
+public:
+    static int GetPlayerSpecTab(Player* player);
+};
diff --git a/src/plugins/playerbot/ChatFilter.cpp b/src/plugins/playerbot/ChatFilter.cpp
new file mode 100644
index 0000000..8d9656c
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.cpp
@@ -0,0 +1,257 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatFilter.h"
+#include "strategy/values/RtiTargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+string ChatFilter::Filter(string message)
+{
+    if (message.find("@") == string::npos)
+        return message;
+
+    return message.substr(message.find(" ") + 1);
+}
+
+class StrategyChatFilter : public ChatFilter
+{
+public:
+    StrategyChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool tank = message.find("@tank") == 0;
+        if (tank && !ai->IsTank(bot))
+            return "";
+
+        bool dps = message.find("@dps") == 0;
+        if (dps && ai->IsTank(bot))
+            return "";
+
+        bool heal = message.find("@heal") == 0;
+        if (heal && !ai->IsHeal(bot))
+            return "";
+
+        if (tank || dps)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class LevelChatFilter : public ChatFilter
+{
+public:
+    LevelChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        if (message[0] != '@')
+            return message;
+
+        if (message.find("-") != string::npos)
+        {
+            int fromLevel = atoi(message.substr(message.find("@") + 1, message.find("-")).c_str());
+            int toLevel = atoi(message.substr(message.find("-") + 1, message.find(" ")).c_str());
+
+            if (bot->getLevel() >= fromLevel && bot->getLevel() <= toLevel)
+                return ChatFilter::Filter(message);
+
+            return message;
+        }
+
+		int level = atoi(message.substr(message.find("@") + 1, message.find(" ")).c_str());
+        if (bot->getLevel() == level)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class CombatTypeChatFilter : public ChatFilter
+{
+public:
+    CombatTypeChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool melee = message.find("@melee") == 0;
+        bool ranged = message.find("@ranged") == 0;
+
+        if (!melee && !ranged)
+            return message;
+
+        switch (bot->getClass())
+        {
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_DEATH_KNIGHT:
+                if (ranged)
+                    return "";
+                break;
+
+            case CLASS_HUNTER:
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+                if (melee)
+                    return "";
+                break;
+
+            case CLASS_DRUID:
+                if (ranged && ai->IsTank(bot))
+                    return "";
+                if (melee && !ai->IsTank(bot))
+                    return "";
+                break;
+
+            case CLASS_SHAMAN:
+                if (melee && ai->IsHeal(bot))
+                    return "";
+                if (ranged && !ai->IsHeal(bot))
+                    return "";
+                break;
+        }
+
+        return ChatFilter::Filter(message);
+    }
+};
+
+class RtiChatFilter : public ChatFilter
+{
+public:
+    RtiChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        rtis.push_back("@star");
+        rtis.push_back("@circle");
+        rtis.push_back("@diamond");
+        rtis.push_back("@triangle");
+        rtis.push_back("@moon");
+        rtis.push_back("@square");
+        rtis.push_back("@cross");
+        rtis.push_back("@skull");
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+        Group *group = bot->GetGroup();
+        if(!group)
+            return message;
+
+        bool found = false;
+        for (list<string>::iterator i = rtis.begin(); i != rtis.end(); i++)
+        {
+            string rti = *i;
+
+            bool isRti = message.find(rti) == 0;
+            if (!isRti)
+                continue;
+
+            ObjectGuid rtiTarget = group->GetTargetIcon(RtiTargetValue::GetRtiIndex(rti.substr(1)));
+            if (bot->GetGUID() == rtiTarget)
+                return ChatFilter::Filter(message);
+
+            Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+            if (!target)
+                return "";
+
+            if (target->GetGUID() != rtiTarget)
+                return "";
+
+            if (found |= isRti)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    list<string> rtis;
+};
+
+class ClassChatFilter : public ChatFilter
+{
+public:
+    ClassChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        classNames["@death_knight"] = CLASS_DEATH_KNIGHT;
+        classNames["@druid"] = CLASS_DRUID;
+        classNames["@hunter"] = CLASS_HUNTER;
+        classNames["@mage"] = CLASS_MAGE;
+        classNames["@paladin"] = CLASS_PALADIN;
+        classNames["@priest"] = CLASS_PRIEST;
+        classNames["@rogue"] = CLASS_ROGUE;
+        classNames["@shaman"] = CLASS_SHAMAN;
+        classNames["@warlock"] = CLASS_WARLOCK;
+        classNames["@warrior"] = CLASS_WARRIOR;
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool found = false;
+        for (map<string, uint8>::iterator i = classNames.begin(); i != classNames.end(); i++)
+        {
+            bool isClass = message.find(i->first) == 0;
+            if (isClass && bot->getClass() != i->second)
+                return "";
+
+            if (found |= isClass)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    map<string, uint8> classNames;
+};
+
+
+
+CompositeChatFilter::CompositeChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+{
+    filters.push_back(new StrategyChatFilter(ai));
+    filters.push_back(new ClassChatFilter(ai));
+    filters.push_back(new RtiChatFilter(ai));
+    filters.push_back(new CombatTypeChatFilter(ai));
+    filters.push_back(new LevelChatFilter(ai));
+}
+
+CompositeChatFilter::~CompositeChatFilter()
+{
+    for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        delete (*i);
+}
+
+string CompositeChatFilter::Filter(string message)
+{
+    for (int j = 0; j < filters.size(); ++j)
+    {
+        for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        {
+            message = (*i)->Filter(message);
+            if (message.empty())
+                break;
+        }
+    }
+
+    return message;
+}
+
diff --git a/src/plugins/playerbot/ChatFilter.h b/src/plugins/playerbot/ChatFilter.h
new file mode 100644
index 0000000..16dde4d
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.h
@@ -0,0 +1,24 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class ChatFilter : public PlayerbotAIAware
+    {
+    public:
+        ChatFilter(PlayerbotAI* ai) : PlayerbotAIAware(ai) {}
+        virtual string Filter(string message);
+    };
+
+    class CompositeChatFilter : public ChatFilter
+    {
+    public:
+        CompositeChatFilter(PlayerbotAI* ai);
+        virtual ~CompositeChatFilter();
+        string Filter(string message);
+
+    private:
+        list<ChatFilter*> filters;
+    };
+};
diff --git a/src/plugins/playerbot/ChatHelper.cpp b/src/plugins/playerbot/ChatHelper.cpp
new file mode 100644
index 0000000..3978677
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.cpp
@@ -0,0 +1,450 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatHelper.h"
+
+using namespace ai;
+using namespace std;
+
+map<string, uint32> ChatHelper::consumableSubClasses;
+map<string, uint32> ChatHelper::tradeSubClasses;
+map<string, uint32> ChatHelper::itemQualities;
+map<string, uint32> ChatHelper::slots;
+map<string, ChatMsg> ChatHelper::chats;
+map<uint8, string> ChatHelper::classes;
+map<uint8, string> ChatHelper::races;
+map<uint8, map<uint8, string> > ChatHelper::specs;
+
+template<class T>
+static bool substrContainsInMap(string searchTerm, map<string, T> searchIn)
+{
+    for (typename map<string, T>::iterator i = searchIn.begin(); i != searchIn.end(); ++i)
+    {
+		string term = i->first;
+		if (term.size() > 1 && searchTerm.find(term) != string::npos)
+            return true;
+    }
+
+    return false;
+}
+
+ChatHelper::ChatHelper(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    itemQualities["poor"] = ITEM_QUALITY_POOR;
+    itemQualities["gray"] = ITEM_QUALITY_POOR;
+    itemQualities["normal"] = ITEM_QUALITY_NORMAL;
+    itemQualities["white"] = ITEM_QUALITY_NORMAL;
+    itemQualities["uncommon"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["green"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["rare"] = ITEM_QUALITY_RARE;
+    itemQualities["blue"] = ITEM_QUALITY_RARE;
+    itemQualities["epic"] = ITEM_QUALITY_EPIC;
+    itemQualities["violet"] = ITEM_QUALITY_EPIC;
+
+    consumableSubClasses["potion"] = ITEM_SUBCLASS_POTION;
+    consumableSubClasses["elixir"] = ITEM_SUBCLASS_ELIXIR;
+    consumableSubClasses["flask"] = ITEM_SUBCLASS_FLASK;
+    consumableSubClasses["scroll"] = ITEM_SUBCLASS_SCROLL;
+    consumableSubClasses["food"] = ITEM_SUBCLASS_FOOD;
+    consumableSubClasses["bandage"] = ITEM_SUBCLASS_BANDAGE;
+    consumableSubClasses["enchant"] = ITEM_SUBCLASS_CONSUMABLE_OTHER;
+
+    tradeSubClasses["cloth"] = ITEM_SUBCLASS_CLOTH;
+    tradeSubClasses["leather"] = ITEM_SUBCLASS_LEATHER;
+    tradeSubClasses["metal"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["stone"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["ore"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["meat"] = ITEM_SUBCLASS_MEAT;
+    tradeSubClasses["herb"] = ITEM_SUBCLASS_HERB;
+    tradeSubClasses["elemental"] = ITEM_SUBCLASS_ELEMENTAL;
+    tradeSubClasses["disenchants"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["enchanting"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["gems"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewels"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewelcrafting"] = ITEM_SUBCLASS_JEWELCRAFTING;
+
+    slots["head"] = EQUIPMENT_SLOT_HEAD;
+    slots["neck"] = EQUIPMENT_SLOT_NECK;
+    slots["shoulder"] = EQUIPMENT_SLOT_SHOULDERS;
+    slots["shirt"] = EQUIPMENT_SLOT_BODY;
+    slots["chest"] = EQUIPMENT_SLOT_CHEST;
+    slots["waist"] = EQUIPMENT_SLOT_WAIST;
+    slots["legs"] = EQUIPMENT_SLOT_LEGS;
+    slots["feet"] = EQUIPMENT_SLOT_FEET;
+    slots["wrist"] = EQUIPMENT_SLOT_WRISTS;
+    slots["hands"] = EQUIPMENT_SLOT_HANDS;
+    slots["finger 1"] = EQUIPMENT_SLOT_FINGER1;
+    slots["finger 2"] = EQUIPMENT_SLOT_FINGER2;
+    slots["trinket 1"] = EQUIPMENT_SLOT_TRINKET1;
+    slots["trinket 2"] = EQUIPMENT_SLOT_TRINKET2;
+    slots["back"] = EQUIPMENT_SLOT_BACK;
+    slots["main hand"] = EQUIPMENT_SLOT_MAINHAND;
+    slots["off hand"] = EQUIPMENT_SLOT_OFFHAND;
+    slots["ranged"] = EQUIPMENT_SLOT_RANGED;
+    slots["tabard"] = EQUIPMENT_SLOT_TABARD;
+
+    chats["party"] = CHAT_MSG_PARTY;
+    chats["p"] = CHAT_MSG_PARTY;
+    chats["guild"] = CHAT_MSG_GUILD;
+    chats["g"] = CHAT_MSG_GUILD;
+    chats["raid"] = CHAT_MSG_RAID;
+    chats["r"] = CHAT_MSG_RAID;
+    chats["whisper"] = CHAT_MSG_WHISPER;
+    chats["w"] = CHAT_MSG_WHISPER;
+
+    classes[CLASS_DRUID] = "druid";
+    specs[CLASS_DRUID][0] = "balance";
+    specs[CLASS_DRUID][1] = "feral combat";
+    specs[CLASS_DRUID][2] = "restoration";
+
+    classes[CLASS_HUNTER] = "hunter";
+    specs[CLASS_HUNTER][0] = "beast mastery";
+    specs[CLASS_HUNTER][1] = "marksmanship";
+    specs[CLASS_HUNTER][2] = "survival";
+
+    classes[CLASS_MAGE] = "mage";
+    specs[CLASS_MAGE][0] = "arcane";
+    specs[CLASS_MAGE][1] = "fire";
+    specs[CLASS_MAGE][2] = "frost";
+
+    classes[CLASS_PALADIN] = "paladin";
+    specs[CLASS_PALADIN][0] = "holy";
+    specs[CLASS_PALADIN][1] = "protection";
+    specs[CLASS_PALADIN][2] = "retribution";
+
+    classes[CLASS_PRIEST] = "priest";
+    specs[CLASS_PRIEST][0] = "discipline";
+    specs[CLASS_PRIEST][1] = "holy";
+    specs[CLASS_PRIEST][2] = "shadow";
+
+    classes[CLASS_ROGUE] = "rogue";
+    specs[CLASS_ROGUE][0] = "assasination";
+    specs[CLASS_ROGUE][1] = "combat";
+    specs[CLASS_ROGUE][2] = "subtlety";
+
+    classes[CLASS_SHAMAN] = "shaman";
+    specs[CLASS_SHAMAN][0] = "elemental";
+    specs[CLASS_SHAMAN][1] = "enhancement";
+    specs[CLASS_SHAMAN][2] = "restoration";
+
+    classes[CLASS_WARLOCK] = "warlock";
+    specs[CLASS_WARLOCK][0] = "affliction";
+    specs[CLASS_WARLOCK][1] = "demonology";
+    specs[CLASS_WARLOCK][2] = "destruction";
+
+    classes[CLASS_WARRIOR] = "warrior";
+    specs[CLASS_WARRIOR][0] = "arms";
+    specs[CLASS_WARRIOR][1] = "fury";
+    specs[CLASS_WARRIOR][2] = "protection";
+
+    races[RACE_BLOODELF] = "Blood Elf";
+    races[RACE_DRAENEI] = "Draenei";
+    races[RACE_DWARF] = "Dwarf";
+    races[RACE_GNOME] = "Gnome";
+    races[RACE_HUMAN] = "Human";
+    races[RACE_NIGHTELF] = "Night Elf";
+    races[RACE_ORC] = "Orc";
+    races[RACE_TAUREN] = "Tauren";
+    races[RACE_TROLL] = "Troll";
+    races[RACE_UNDEAD_PLAYER] = "Undead";
+}
+
+string ChatHelper::formatMoney(uint32 copper)
+{
+    ostringstream out;
+	if (!copper)
+	{
+		out << "0|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+		return out.str();
+	}
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+    out << " ";
+    if (gold > 0)
+        out << gold <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\gold:0|t ";
+    if (silver > 0 && gold < 50)
+        out << silver <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\silver:0|t ";
+	if (copper > 0 && gold < 10)
+		out << copper <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+
+    return out.str();
+}
+
+uint32 ChatHelper::parseMoney(string& text)
+{
+    // if user specified money in ##g##s##c format
+    string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+ItemIds ChatHelper::parseItems(string& text)
+{
+    ItemIds itemIds;
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.insert(id);
+    }
+
+    return itemIds;
+}
+
+string ChatHelper::formatQuest(Quest const* quest)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << quest->GetTitle() << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatGameobject(GameObject* go)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hfound:" << go->GetGUID() << ":" << go->GetEntry() << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatSpell(SpellInfo const *sInfo)
+{
+    ostringstream out;
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[LOCALE_enUS] << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatItem(ItemTemplate const * proto, int count)
+{
+    char color[32];
+    sprintf(color, "%x", ItemQualityColors[proto->Quality]);
+
+    ostringstream out;
+    out << "|c" << color << "|Hitem:" << proto->ItemId
+        << ":0:0:0:0:0:0:0" << "|h[" << proto->Name1
+        << "]|h|r";
+
+    if (count > 1)
+        out << "x" << count;
+
+    return out.str();
+}
+
+ChatMsg ChatHelper::parseChat(string& text)
+{
+    if (chats.find(text) != chats.end())
+        return chats[text];
+
+    return CHAT_MSG_SYSTEM;
+}
+
+string ChatHelper::formatChat(ChatMsg chat)
+{
+    switch (chat)
+    {
+    case CHAT_MSG_GUILD:
+        return "guild";
+    case CHAT_MSG_PARTY:
+        return "party";
+    case CHAT_MSG_WHISPER:
+        return "whisper";
+    case CHAT_MSG_RAID:
+        return "raid";
+    }
+
+    return "unknown";
+}
+
+
+uint32 ChatHelper::parseSpell(string& text)
+{
+    PlayerbotChatHandler handler(ai->GetBot());
+    return handler.extractSpellId(text);
+}
+
+list<ObjectGuid> ChatHelper::parseGameobjects(string& text)
+{
+    list<ObjectGuid> gos;
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        istringstream stream(text.substr(pos, endPos - pos));
+        uint64 guid; stream >> guid;
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        ObjectGuid lootCurrent = ObjectGuid(guid);
+
+        if (guid)
+            gos.push_back(lootCurrent);
+    }
+
+    return gos;
+}
+
+string ChatHelper::formatQuestObjective(string name, int available, int required)
+{
+    ostringstream out;
+    out << "|cFFFFFFFF" << name << (available >= required ? "|c0000FF00: " : "|c00FF0000: ")
+        << available << "/" << required << "|r";
+
+    return out.str();
+}
+
+
+uint32 ChatHelper::parseItemQuality(string text)
+{
+    if (itemQualities.find(text) == itemQualities.end())
+        return MAX_ITEM_QUALITY;
+
+    return itemQualities[text];
+}
+
+bool ChatHelper::parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass)
+{
+    if (text == "questitem")
+    {
+        *itemClass = ITEM_CLASS_QUEST;
+        *itemSubClass = ITEM_SUBCLASS_QUEST;
+        return true;
+    }
+
+    if (consumableSubClasses.find(text) != consumableSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_CONSUMABLE;
+        *itemSubClass = consumableSubClasses[text];
+        return true;
+    }
+
+    if (tradeSubClasses.find(text) != tradeSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_TRADE_GOODS;
+        *itemSubClass = tradeSubClasses[text];
+        return true;
+    }
+
+    return false;
+}
+
+uint32 ChatHelper::parseSlot(string text)
+{
+    if (slots.find(text) != slots.end())
+        return slots[text];
+
+    return EQUIPMENT_SLOT_END;
+}
+
+bool ChatHelper::parseable(string text)
+{
+    return text.find("|H") != string::npos ||
+            text == "questitem" ||
+            substrContainsInMap<uint32>(text, consumableSubClasses) ||
+            substrContainsInMap<uint32>(text, tradeSubClasses) ||
+            substrContainsInMap<uint32>(text, itemQualities) ||
+            substrContainsInMap<uint32>(text, slots) ||
+            substrContainsInMap<ChatMsg>(text, chats) ||
+            parseMoney(text) > 0;
+}
+
+string ChatHelper::formatClass(Player* player, int spec)
+{
+    uint8 cls = player->getClass();
+
+    ostringstream out;
+    out << specs[cls][spec] << " (";
+
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    out << (c0 ? "|h|cff00ff00" : "") << c0 << "|h|cffffffff/";
+    out << (c1 ? "|h|cff00ff00" : "") << c1 << "|h|cffffffff/";
+    out << (c2 ? "|h|cff00ff00" : "") << c2 << "|h|cffffffff";
+
+    out <<  ") " << classes[cls];
+    return out.str();
+}
+
+string ChatHelper::formatClass(uint8 cls)
+{
+    return classes[cls];
+}
+
+string ChatHelper::formatRace(uint8 race)
+{
+    return races[race];
+}
diff --git a/src/plugins/playerbot/ChatHelper.h b/src/plugins/playerbot/ChatHelper.h
new file mode 100644
index 0000000..3d493d1
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.h
@@ -0,0 +1,52 @@
+#pragma once
+
+using namespace std;
+
+typedef set<uint32> ItemIds;
+typedef set<uint32> SpellIds;
+
+#include "../pchdef.h"
+
+namespace ai
+{
+    class ChatHelper : public PlayerbotAIAware
+    {
+    public:
+        ChatHelper(PlayerbotAI* ai);
+
+    public:
+        static string formatMoney(uint32 copper);
+        static uint32 parseMoney(string& text);
+        static ItemIds parseItems(string& text);
+        uint32 parseSpell(string& text);
+        static string formatQuest(Quest const* quest);
+        static string formatItem(ItemTemplate const * proto, int count = 0);
+        static string formatSpell(SpellInfo const *sInfo);
+        static string formatGameobject(GameObject* go);
+        static string formatQuestObjective(string name, int available, int required);
+        static list<ObjectGuid> parseGameobjects(string& text);
+
+        static ChatMsg parseChat(string& text);
+        static string formatChat(ChatMsg chat);
+
+        static string formatClass(Player* player, int spec);
+        static string formatClass(uint8 cls);
+        static string formatRace(uint8 race);
+
+        static uint32 parseItemQuality(string text);
+        static bool parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass);
+        static uint32 parseSlot(string text);
+
+        static bool parseable(string text);
+
+    private:
+        static map<string, uint32> consumableSubClasses;
+        static map<string, uint32> tradeSubClasses;
+        static map<string, uint32> itemQualities;
+        static map<string, uint32> slots;
+        static map<string, ChatMsg> chats;
+        static map<uint8, string> classes;
+        static map<uint8, string> races;
+        static map<uint8, map<uint8, string> > specs;
+    };
+};
diff --git a/src/plugins/playerbot/FleeManager.cpp b/src/plugins/playerbot/FleeManager.cpp
new file mode 100644
index 0000000..d7f93f5
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.cpp
@@ -0,0 +1,160 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "FleeManager.h"
+#include "PlayerbotAIConfig.h"
+#include "../Groups/Group.h"
+
+using namespace ai;
+using namespace std;
+
+void FleeManager::calculateDistanceToPlayers(FleePoint *point)
+{
+	Group* group = bot->GetGroup();
+	if (!group)
+		return;
+
+	for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+		Player* player = gref->GetSource();
+		if(player == bot)
+			continue;
+
+		float d = player->GetDistance(point->x, point->y, point->z);
+		point->toAllPlayers.probe(d);
+		switch (player->getClass()) {
+			case CLASS_HUNTER:
+			case CLASS_MAGE:
+			case CLASS_PRIEST:
+			case CLASS_WARLOCK:
+				point->toRangedPlayers.probe(d);
+				break;
+			case CLASS_PALADIN:
+			case CLASS_ROGUE:
+			case CLASS_WARRIOR:
+				point->toMeleePlayers.probe(d);
+				break;
+		}
+	}
+}
+
+void FleeManager::calculateDistanceToCreatures(FleePoint *point)
+{
+	RangePair &distance = point->toCreatures;
+
+	list<ObjectGuid> units = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<list<ObjectGuid> >("possible targets");
+	for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+		Unit* unit = bot->GetPlayerbotAI()->GetUnit(*i);
+		if (!unit)
+		    continue;
+
+		float d = unit->GetDistance(point->x, point->y, point->z);
+		if (d <= sPlayerbotAIConfig.tooCloseDistance)
+		    continue;
+
+		distance.probe(d);
+	}
+}
+
+void FleeManager::calculatePossibleDestinations(list<FleePoint*> &points)
+{
+	float botPosX = bot->GetPositionX();
+	float botPosY = bot->GetPositionY();
+	float botPosZ = bot->GetPositionZ();
+
+	for (float distance = maxAllowedDistance; distance > sPlayerbotAIConfig.tooCloseDistance + 5.0f; distance -= 5.0f)
+	{
+        for (float angle = -M_PI + followAngle; angle < M_PI + followAngle; angle += M_PI / 16)
+        {
+            float x = botPosX + cos(angle) * distance;
+            float y = botPosY + sin(angle) * distance;
+
+            if (!bot->IsWithinLOS(x, y, botPosZ))
+                continue;
+
+            FleePoint *point = new FleePoint(x, y, botPosZ);
+            calculateDistanceToPlayers(point);
+            calculateDistanceToCreatures(point);
+            points.push_back(point);
+        }
+	}
+}
+
+void FleeManager::cleanup(list<FleePoint*> &points)
+{
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		delete point;
+	}
+	points.clear();
+}
+
+bool FleePoint::isReasonable()
+{
+	return toAllPlayers.max <= sPlayerbotAIConfig.sightDistance && toCreatures.min >= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool FleePoint::isBetterByCreatures(FleePoint* other)
+{
+    return toCreatures.min > 0 && other->toCreatures.min > 0 &&
+            (toCreatures.min - other->toCreatures.min) >= 0;
+}
+
+bool FleePoint::isBetterByAll(FleePoint* other)
+{
+    bool isFartherFromCreatures = isBetterByCreatures(other);
+    bool isNearerToRangedPlayers = toRangedPlayers.max > 0 && other->toRangedPlayers.max > 0 &&
+            (toRangedPlayers.max - other->toRangedPlayers.max) <= 0;
+    bool isFartherFromMeleePlayers = toMeleePlayers.min > 0 && other->toMeleePlayers.min > 0 &&
+            (toMeleePlayers.min - other->toMeleePlayers.min) >= 0;
+
+    return isFartherFromCreatures && (isNearerToRangedPlayers || isFartherFromMeleePlayers);
+}
+
+FleePoint* FleeManager::selectOptimalDestination(list<FleePoint*> &points)
+{
+	FleePoint* byCreatures = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byCreatures || point->isBetterByCreatures(byCreatures)))
+			byCreatures = point;
+	}
+
+	FleePoint* byAll = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byAll || point->isBetterByAll(byAll)))
+		    byAll = point;
+	}
+
+	if (byAll && byCreatures)
+	{
+	    if (byAll->isBetterByCreatures(byCreatures))
+	        return byAll;
+	}
+
+	return byCreatures;
+}
+
+bool FleeManager::CalculateDestination(float* rx, float* ry, float* rz)
+{
+	list<FleePoint*> points;
+	calculatePossibleDestinations(points);
+
+    FleePoint* point = selectOptimalDestination(points);
+    if (!point)
+    {
+        cleanup(points);
+        return false;
+    }
+
+	*rx = point->x;
+	*ry = point->y;
+	*rz = bot->GetPositionZ();
+
+    cleanup(points);
+	return true;
+}
diff --git a/src/plugins/playerbot/FleeManager.h b/src/plugins/playerbot/FleeManager.h
new file mode 100644
index 0000000..3084cdd
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.h
@@ -0,0 +1,83 @@
+#pragma once
+
+using namespace std;
+
+class Player;
+
+namespace ai
+{
+    class Engine;
+
+	class RangePair {
+	public:
+		RangePair() {
+			min = -1.0f;
+			max = -1.0f;
+		}
+
+	public:
+		float min;
+		float max;
+
+	public:
+		void probe(float d) {
+			if (min < 0 || min > d)
+				min = d;
+
+			if (max < 0 || max < d)
+				max = d;
+		}
+	};
+
+	class FleePoint {
+	public:
+		FleePoint(float x, float y, float z) {
+			this->x = x;
+			this->y = y;
+			this->z = z;
+		}
+
+    public:
+        bool isReasonable();
+        bool isBetterByCreatures(FleePoint* other);
+        bool isBetterByAll(FleePoint* other);
+
+	public:
+		float x;
+		float y;
+		float z;
+
+		RangePair toCreatures;
+		RangePair toAllPlayers;
+		RangePair toMeleePlayers;
+		RangePair toRangedPlayers;
+	};
+
+	class FleeManager
+	{
+	public:
+		FleeManager(Player* bot, float maxAllowedDistance, float followAngle) {
+			this->bot = bot;
+			this->maxAllowedDistance = maxAllowedDistance;
+			this->followAngle = followAngle;
+		}
+
+	public:
+		bool CalculateDestination(float* rx, float* ry, float* rz);
+
+	private:
+		void calculatePossibleDestinations(list<FleePoint*> &points);
+		void calculateDistanceToPlayers(FleePoint *point);
+		void calculateDistanceToCreatures(FleePoint *point);
+		void cleanup(list<FleePoint*> &points);
+		FleePoint* selectOptimalDestination(list<FleePoint*> &points);
+		bool isReasonable(FleePoint* point);
+		bool isBetterThan(FleePoint* point, FleePoint* other);
+
+	private:
+		Player* bot;
+		float maxAllowedDistance;
+		float followAngle;
+	};
+
+};
diff --git a/src/plugins/playerbot/Helpers.cpp b/src/plugins/playerbot/Helpers.cpp
new file mode 100644
index 0000000..cabfd7f
--- /dev/null
+++ b/src/plugins/playerbot/Helpers.cpp
@@ -0,0 +1,90 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include <algorithm>
+#include <functional>
+#include <cctype>
+#include <locale>
+
+vector<string>& split(const string &s, char delim, vector<string> &elems)
+{
+    stringstream ss(s);
+    string item;
+    while(getline(ss, item, delim))
+    {
+        elems.push_back(item);
+    }
+    return elems;
+}
+
+
+vector<string> split(const string &s, char delim)
+{
+    vector<string> elems;
+    return split(s, delim, elems);
+}
+
+char *strstri(const char *haystack, const char *needle)
+{
+    if ( !*needle )
+    {
+        return (char*)haystack;
+    }
+    for ( ; *haystack; ++haystack )
+    {
+        if ( tolower(*haystack) == tolower(*needle) )
+        {
+            const char *h = haystack, *n = needle;
+            for ( ; *h && *n; ++h, ++n )
+            {
+                if ( tolower(*h) != tolower(*n) )
+                {
+                    break;
+                }
+            }
+            if ( !*n )
+            {
+                return (char*)haystack;
+            }
+        }
+    }
+    return 0;
+}
+
+
+
+uint64 extractGuid(WorldPacket& packet)
+{
+    uint8 mask;
+    packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while (true)
+    {
+        if (mask & testMask)
+        {
+            uint8 word;
+            packet >> word;
+            guid += (word << bit);
+        }
+        if (bit == 7)
+            break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+std::string &ltrim(std::string &s) {
+        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+        return s;
+}
+
+std::string &rtrim(std::string &s) {
+        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
+        return s;
+}
+
+std::string &trim(std::string &s) {
+        return ltrim(rtrim(s));
+}
diff --git a/src/plugins/playerbot/LazyCalculatedValue.h b/src/plugins/playerbot/LazyCalculatedValue.h
new file mode 100644
index 0000000..f7d3d31
--- /dev/null
+++ b/src/plugins/playerbot/LazyCalculatedValue.h
@@ -0,0 +1,42 @@
+#pragma once
+
+using namespace std;
+
+namespace ai 
+{
+    template <class TValue, class TOwner>
+    class LazyCalculatedValue
+    {
+    public:
+        typedef TValue (TOwner::*Calculator)();
+
+    public:
+        LazyCalculatedValue(TOwner* owner, Calculator calculator) 
+        {
+            this->calculator = calculator;
+            this->owner = owner;
+            Reset();
+        }
+
+    public:
+        TValue GetValue()
+        {
+            if (!calculated)
+            {
+                value = (owner->*calculator)();
+                calculated = true;
+            }
+            return value;
+        }
+        void Reset() 
+        {
+            calculated = false;
+        }
+
+    protected:
+        Calculator calculator;
+        TOwner* owner;
+        bool calculated;
+        TValue value;
+    };
+};
\ No newline at end of file
diff --git a/src/plugins/playerbot/LootObjectStack.cpp b/src/plugins/playerbot/LootObjectStack.cpp
new file mode 100644
index 0000000..8a10fef
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.cpp
@@ -0,0 +1,244 @@
+#include "../pchdef.h"
+#include "LootObjectStack.h"
+#include "playerbot.h"
+
+using namespace ai;
+using namespace std;
+
+#define MAX_LOOT_OBJECT_COUNT 10
+
+LootTarget::LootTarget(ObjectGuid guid) : guid(guid), asOfTime(time(0))
+{
+}
+
+LootTarget::LootTarget(LootTarget const& other)
+{
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+}
+
+LootTarget& LootTarget::operator=(LootTarget const& other)
+{
+    if((void*)this == (void*)&other)
+        return *this;
+
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+
+    return *this;
+}
+
+bool LootTarget::operator< (const LootTarget& other) const
+{
+    return guid < other.guid;
+}
+
+void LootTargetList::shrink(time_t fromTime)
+{
+    for (set<LootTarget>::iterator i = begin(); i != end(); )
+    {
+        if (i->asOfTime <= fromTime)
+            erase(i++);
+		else
+			++i;
+    }
+}
+
+LootObject::LootObject(Player* bot, ObjectGuid guid)
+	: guid(), skillId(SKILL_NONE), reqSkillValue(0), reqItem(NULL)
+{
+    Refresh(bot, guid);
+}
+
+void LootObject::Refresh(Player* bot, ObjectGuid guid)
+{
+    skillId = SKILL_NONE;
+    reqSkillValue = 0;
+    reqItem = NULL;
+    this->guid = ObjectGuid();
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+    {
+        if (creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            this->guid = guid;
+
+        if (creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+        {
+            skillId = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+            uint32 targetLevel = creature->getLevel();
+            reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+            if (bot->HasSkill(skillId) && bot->GetSkillValue(skillId) >= reqSkillValue)
+                this->guid = guid;
+        }
+
+        return;
+    }
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+    {
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return;
+
+        for(uint32 i = 0; i < 6; ++i)
+        {
+            if (go->GetGOInfo()->questItems[i])
+            {
+                this->guid = guid;
+                return;
+            }
+        }
+
+        for (int i = 0; i < 8; ++i)
+        {
+            switch (lockInfo->Type[i])
+            {
+            case LOCK_KEY_ITEM:
+                if (lockInfo->Index[i] > 0)
+                {
+                    reqItem = lockInfo->Index[i];
+                    this->guid = guid;
+                }
+                break;
+            case LOCK_KEY_SKILL:
+                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                {
+                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                    reqSkillValue = lockInfo->Skill[i];
+                    this->guid = guid;
+                }
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
+WorldObject* LootObject::GetWorldObject(Player* bot)
+{
+    Refresh(bot, guid);
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+        return creature;
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+        return go;
+
+    return NULL;
+}
+
+LootObject::LootObject(const LootObject& other)
+{
+    guid = other.guid;
+    skillId = other.skillId;
+    reqSkillValue = other.reqSkillValue;
+    reqItem = other.reqItem;
+}
+
+bool LootObject::IsLootPossible(Player* bot)
+{
+    if (IsEmpty() || !GetWorldObject(bot))
+        return false;
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    if (reqItem && !bot->HasItemCount(reqItem, 1))
+        return false;
+
+    if (skillId == SKILL_NONE)
+        return true;
+
+    if (skillId == SKILL_FISHING)
+        return false;
+
+    if (!bot->HasSkill(skillId))
+        return false;
+
+    if (!reqSkillValue)
+        return true;
+
+    uint32 skillValue = uint32(bot->GetPureSkillValue(skillId));
+    if (reqSkillValue > skillValue)
+        return false;
+
+    if (skillId == SKILL_MINING && !bot->HasItemTotemCategory(TC_MINING_PICK))
+        return false;
+
+    if (skillId == SKILL_SKINNING && !bot->HasItemTotemCategory(TC_SKINNING_KNIFE))
+        return false;
+
+    return true;
+}
+
+bool LootObjectStack::Add(ObjectGuid guid)
+{
+    if (!availableLoot.insert(guid).second)
+        return false;
+
+    if (availableLoot.size() < MAX_LOOT_OBJECT_COUNT)
+        return true;
+
+    vector<LootObject> ordered = OrderByDistance();
+    for (size_t i = MAX_LOOT_OBJECT_COUNT; i < ordered.size(); i++)
+        Remove(ordered[i].guid);
+
+    return true;
+}
+
+void LootObjectStack::Remove(ObjectGuid guid)
+{
+    LootTargetList::iterator i = availableLoot.find(guid);
+    if (i != availableLoot.end())
+        availableLoot.erase(i);
+}
+
+void LootObjectStack::Clear()
+{
+    availableLoot.clear();
+}
+
+bool LootObjectStack::CanLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return !ordered.empty();
+}
+
+LootObject LootObjectStack::GetLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return ordered.empty() ? LootObject() : *ordered.begin();
+}
+
+vector<LootObject> LootObjectStack::OrderByDistance(float maxDistance)
+{
+    availableLoot.shrink(time(0) - 30);
+
+    map<float, LootObject> sortedMap;
+    LootTargetList safeCopy(availableLoot);
+    for (LootTargetList::iterator i = safeCopy.begin(); i != safeCopy.end(); i++)
+    {
+        ObjectGuid guid = i->guid;
+        LootObject lootObject(bot, guid);
+        if (!lootObject.IsLootPossible(bot))
+            continue;
+
+        float distance = bot->GetDistance(lootObject.GetWorldObject(bot));
+        if (!maxDistance || distance <= maxDistance)
+            sortedMap[distance] = lootObject;
+    }
+
+    vector<LootObject> result;
+    for (map<float, LootObject>::iterator i = sortedMap.begin(); i != sortedMap.end(); i++)
+        result.push_back(i->second);
+    return result;
+}
+
diff --git a/src/plugins/playerbot/LootObjectStack.h b/src/plugins/playerbot/LootObjectStack.h
new file mode 100644
index 0000000..35b8710
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.h
@@ -0,0 +1,76 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    enum LootStrategy
+    {
+        LOOTSTRATEGY_QUEST = 1,
+        LOOTSTRATEGY_SKILL = 2,
+        LOOTSTRATEGY_GRAY = 3,
+        LOOTSTRATEGY_NORMAL = 4,
+        LOOTSTRATEGY_ALL = 5
+    };
+
+    class LootObject
+    {
+    public:
+        LootObject() {}
+        LootObject(Player* bot, ObjectGuid guid);
+        LootObject(const LootObject& other);
+
+    public:
+        bool IsEmpty() { return !guid; }
+        bool IsLootPossible(Player* bot);
+        void Refresh(Player* bot, ObjectGuid guid);
+        WorldObject* GetWorldObject(Player* bot);
+        ObjectGuid guid;
+
+        uint32 skillId;
+        uint32 reqSkillValue;
+        uint32 reqItem;
+    };
+
+    class LootTarget
+    {
+    public:
+        LootTarget(ObjectGuid guid);
+        LootTarget(LootTarget const& other);
+
+    public:
+        LootTarget& operator=(LootTarget const& other);
+        bool operator< (const LootTarget& other) const;
+
+    public:
+        ObjectGuid guid;
+        time_t asOfTime;
+    };
+
+    class LootTargetList : public set<LootTarget>
+    {
+    public:
+        void shrink(time_t fromTime);
+    };
+
+    class LootObjectStack
+    {
+    public:
+        LootObjectStack(Player* bot) : bot(bot) {}
+
+    public:
+        bool Add(ObjectGuid guid);
+        void Remove(ObjectGuid guid);
+        void Clear();
+        bool CanLoot(float maxDistance);
+        LootObject GetLoot(float maxDistance = 0);
+
+    private:
+        vector<LootObject> OrderByDistance(float maxDistance = 0);
+
+    private:
+        Player* bot;
+        LootTargetList availableLoot;
+    };
+
+};
diff --git a/src/plugins/playerbot/PlayerbotAI.cpp b/src/plugins/playerbot/PlayerbotAI.cpp
new file mode 100644
index 0000000..f8fba65
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.cpp
@@ -0,0 +1,1332 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+
+#include "AiFactory.h"
+
+#include "../Grids/Notifiers/GridNotifiers.h"
+#include "../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../Grids/Cells/CellImpl.h"
+#include "strategy/values/LastMovementValue.h"
+#include "strategy/actions/LogLevelAction.h"
+#include "strategy/values/LastSpellCastValue.h"
+#include "LootObjectStack.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotSecurity.h"
+#include "../Groups/Group.h"
+#include "../Entities/Pet/Pet.h"
+#include "../Spells/Auras/SpellAuraEffects.h"
+
+using namespace ai;
+using namespace std;
+
+vector<string>& split(const string &s, char delim, vector<string> &elems);
+vector<string> split(const string &s, char delim);
+uint64 extractGuid(WorldPacket& packet);
+std::string &trim(std::string &s);
+
+uint32 PlayerbotChatHandler::extractQuestId(string str)
+{
+    char* source = (char*)str.c_str();
+    char* cId = extractKeyFromLink(source,"Hquest");
+    return cId ? atol(cId) : 0;
+}
+
+void PacketHandlingHelper::AddHandler(uint16 opcode, string handler)
+{
+    handlers[opcode] = handler;
+}
+
+void PacketHandlingHelper::Handle(ExternalEventHelper &helper)
+{
+    while (!queue.empty())
+    {
+        helper.HandlePacket(handlers, queue.top());
+        queue.pop();
+    }
+}
+
+void PacketHandlingHelper::AddPacket(const WorldPacket& packet)
+{
+	if (handlers.find(packet.GetOpcode()) != handlers.end())
+        queue.push(WorldPacket(packet));
+}
+
+
+PlayerbotAI::PlayerbotAI() : PlayerbotAIBase(), bot(NULL), aiObjectContext(NULL),
+    currentEngine(NULL), chatHelper(this), chatFilter(this), accountId(0), security(NULL), master(NULL)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i] = NULL;
+}
+
+PlayerbotAI::PlayerbotAI(Player* bot) :
+    PlayerbotAIBase(), chatHelper(this), chatFilter(this), security(bot), master(NULL)
+{
+	this->bot = bot;
+
+	accountId = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+
+    aiObjectContext = AiFactory::createAiObjectContext(bot, this);
+
+    engines[BOT_STATE_COMBAT] = AiFactory::createCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_NON_COMBAT] = AiFactory::createNonCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_DEAD] = AiFactory::createDeadEngine(bot, this, aiObjectContext);
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_REPORT_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_AREATRIGGER, "area trigger");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LOOT_ROLL, "loot roll");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GOSSIP_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_COMPLETE_QUEST, "complete quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_ACCEPT_QUEST, "accept quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXI, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXIEXPRESS, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_MOVE_SPLINE_DONE, "taxi done");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GROUP_UNINVITE_GUID, "uninvite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_PUSHQUESTTOPARTY, "quest share");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GUILD_INVITE, "guild invite");
+
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_INVITE, "group invite");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_NOT_ENOUGHT_MONEY, "not enough money");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_REPUTATION_REQUIRE, "not enough reputation");
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_SET_LEADER, "group set leader");
+    botOutgoingPacketHandlers.AddHandler(SMSG_FORCE_RUN_SPEED_CHANGE, "check mount state");
+    botOutgoingPacketHandlers.AddHandler(SMSG_RESURRECT_REQUEST, "resurrect request");
+    botOutgoingPacketHandlers.AddHandler(SMSG_INVENTORY_CHANGE_FAILURE, "cannot equip");
+    botOutgoingPacketHandlers.AddHandler(SMSG_TRADE_STATUS, "trade status");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LOOT_RESPONSE, "loot response");
+    botOutgoingPacketHandlers.AddHandler(SMSG_QUESTUPDATE_ADD_KILL, "quest objective completed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_ITEM_PUSH_RESULT, "item push result");
+    botOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    botOutgoingPacketHandlers.AddHandler(SMSG_CAST_FAILED, "cast failed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_DUEL_REQUESTED, "duel requested");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_ROLE_CHECK_UPDATE, "lfg role check");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_PROPOSAL_UPDATE, "lfg proposal");
+
+    masterOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK, "ready check");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK_FINISHED, "ready check finished");
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i])
+            delete engines[i];
+    }
+
+    if (aiObjectContext)
+        delete aiObjectContext;
+}
+
+void PlayerbotAI::UpdateAI(uint32 elapsed)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown &&
+            bot->IsNonMeleeSpellCast(true, true, false) &&
+            *GetAiObjectContext()->GetValue<bool>("invalid target", "current target"))
+    {
+        Spell* spell = bot->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && !spell->GetSpellInfo()->IsPositive())
+        {
+            InterruptSpell();
+            SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        }
+    }
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.maxWaitForMove && bot->IsInCombat() && !bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+    {
+        nextAICheckDelay = sPlayerbotAIConfig.maxWaitForMove;
+    }
+
+    PlayerbotAIBase::UpdateAI(elapsed);
+}
+
+void PlayerbotAI::UpdateAIInternal(uint32 elapsed)
+{
+    ExternalEventHelper helper(aiObjectContext);
+    while (!chatCommands.empty())
+    {
+        ChatCommandHolder holder = chatCommands.top();
+        string command = holder.GetCommand();
+        Player* owner = holder.GetOwner();
+        if (!helper.ParseChatCommand(command, owner) && holder.GetType() == CHAT_MSG_WHISPER)
+        {
+            ostringstream out; out << "Unknown command " << command;
+            TellMaster(out);
+            helper.ParseChatCommand("help");
+        }
+        chatCommands.pop();
+    }
+
+    botOutgoingPacketHandlers.Handle(helper);
+    masterIncomingPacketHandlers.Handle(helper);
+    masterOutgoingPacketHandlers.Handle(helper);
+
+	DoNextAction();
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+	bot->GetMotionMaster()->Clear(true);
+	if (bot->IsBeingTeleportedNear())
+	{
+		WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+		p.appendPackGUID(bot->GetGUID());
+		p << (uint32) 0; // supposed to be flags? not used currently
+		p << (uint32) time(0); // time - not currently used
+		bot->GetSession()->HandleMoveTeleportAck(p);
+	}
+	else if (bot->IsBeingTeleportedFar())
+	{
+		bot->GetSession()->HandleMoveWorldportAckOpcode();
+		SetNextCheckDelay(1000);
+	}
+}
+
+void PlayerbotAI::Reset()
+{
+    if (bot->IsFlying())
+        return;
+
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    nextAICheckDelay = 0;
+
+    aiObjectContext->GetValue<Unit*>("old target")->Set(NULL);
+    aiObjectContext->GetValue<Unit*>("current target")->Set(NULL);
+    aiObjectContext->GetValue<LootObject>("loot target")->Set(LootObject());
+    aiObjectContext->GetValue<uint32>("lfg proposal")->Set(0);
+
+    LastSpellCast & lastSpell = aiObjectContext->GetValue<LastSpellCast& >("last spell cast")->Get();
+    lastSpell.Reset();
+
+    LastMovement & lastMovement = aiObjectContext->GetValue<LastMovement& >("last movement")->Get();
+    lastMovement.Set(NULL);
+
+    bot->GetMotionMaster()->Clear();
+    bot->m_taxi.ClearTaxiDestinations();
+    InterruptSpell();
+
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        engines[i]->Init();
+    }
+}
+
+void PlayerbotAI::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    if (!GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_ADDON)
+        return;
+
+    string filtered = text;
+    if (!sPlayerbotAIConfig.commandPrefix.empty())
+    {
+        if (filtered.find(sPlayerbotAIConfig.commandPrefix) != 0)
+            return;
+
+        filtered = filtered.substr(sPlayerbotAIConfig.commandPrefix.size());
+    }
+
+    filtered = chatFilter.Filter(trim((string&)filtered));
+    if (filtered.empty())
+        return;
+
+    if (filtered.find("who") != 0 && !GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_RAID_WARNING && filtered.find(bot->GetName()) != string::npos && filtered.find("award") == string::npos)
+    {
+        ChatCommandHolder cmd("warning", &fromPlayer, type);
+        chatCommands.push(cmd);
+        return;
+    }
+
+    if (filtered.size() > 2 && filtered.substr(0, 2) == "d " || filtered.size() > 3 && filtered.substr(0, 3) == "do ")
+    {
+        std::string action = filtered.substr(filtered.find(" ") + 1);
+        DoSpecificAction(action);
+    }
+    else if (filtered == "reset")
+    {
+        Reset();
+    }
+    else
+    {
+        ChatCommandHolder cmd(filtered, &fromPlayer, type);
+        chatCommands.push(cmd);
+    }
+}
+
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+    case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+
+            bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+            return;
+        }
+    case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+            bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+            return;
+        }
+    case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint8 castCount, result;
+            uint32 spellId;
+            p >> castCount >> spellId >> result;
+            if (result != SPELL_CAST_OK)
+            {
+                SpellInterrupted(spellId);
+                botOutgoingPacketHandlers.AddPacket(packet);
+            }
+            return;
+        }
+    case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            uint32 spellId;
+            p >> castCount;
+            p >> spellId;
+            SpellInterrupted(spellId);
+            return;
+        }
+    case SMSG_SPELL_DELAYED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint32 delaytime;
+            p >> delaytime;
+            if (delaytime <= 1000)
+                IncreaseNextCheckDelay(delaytime);
+            return;
+        }
+    default:
+        botOutgoingPacketHandlers.AddPacket(packet);
+    }
+}
+
+void PlayerbotAI::SpellInterrupted(uint32 spellid)
+{
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    if (lastSpell.id != spellid)
+        return;
+
+    lastSpell.Reset();
+
+    time_t now = time(0);
+    if (now <= lastSpell.time)
+        return;
+
+    uint32 castTimeSpent = 1000 * (now - lastSpell.time);
+
+    int32 globalCooldown = CalculateGlobalCooldown(lastSpell.id);
+    if (castTimeSpent < globalCooldown)
+        SetNextCheckDelay(globalCooldown - castTimeSpent);
+    else
+        SetNextCheckDelay(0);
+
+    lastSpell.id = 0;
+}
+
+int32 PlayerbotAI::CalculateGlobalCooldown(uint32 spellid)
+{
+    if (!spellid)
+        return 0;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+
+    if (bot->GetGlobalCooldownMgr().HasGlobalCooldown(spellInfo))
+        return sPlayerbotAIConfig.globalCoolDown;
+
+    return sPlayerbotAIConfig.reactDelay;
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    masterIncomingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    masterOutgoingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::ChangeEngine(BotState type)
+{
+    Engine* engine = engines[type];
+
+    if (currentEngine != engine)
+    {
+        currentEngine = engine;
+        ReInitCurrentEngine();
+
+        switch (type)
+        {
+        case BOT_STATE_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_NON_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s NON-COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_DEAD:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s DEAD ===", bot->GetName().c_str());
+            break;
+        }
+    }
+}
+
+void PlayerbotAI::DoNextAction()
+{
+    if (bot->IsBeingTeleported() || (GetMaster() && GetMaster()->IsBeingTeleported()))
+        return;
+
+    currentEngine->DoNextAction(NULL);
+
+    if (bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        // TODO
+        //WorldPacket packet(CMSG_MOVE_SET_FLY);
+        //packet.appendPackGUID(bot->GetGUID());
+        //packet << bot->m_movementInfo;
+        bot->SetMover(bot);
+        //bot->GetSession()->HandleMovementOpcodes(packet);
+    }
+
+    Player* master = GetMaster();
+    if (bot->IsMounted() && bot->IsFlying())
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        bot->SetSpeed(MOVE_FLIGHT, 1.0f, true);
+        bot->SetSpeed(MOVE_RUN, 1.0f, true);
+
+        if (master)
+        {
+            bot->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT), true);
+            bot->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT), true);
+        }
+
+    }
+
+    if (currentEngine != engines[BOT_STATE_DEAD] && !bot->IsAlive())
+    {
+        ChangeEngine(BOT_STATE_DEAD);
+    }
+
+    Group *group = bot->GetGroup();
+    if (!master && group)
+    {
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member && member->IsInWorld() && !member->GetPlayerbotAI() && (!master || master->GetPlayerbotAI()))
+            {
+                ai->SetMaster(member);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::ReInitCurrentEngine()
+{
+    InterruptSpell();
+    currentEngine->Init();
+}
+
+void PlayerbotAI::ChangeStrategy(string names, BotState type)
+{
+    Engine* e = engines[type];
+    if (!e)
+        return;
+
+    e->ChangeStrategy(names);
+}
+
+void PlayerbotAI::DoSpecificAction(string name)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        ostringstream out;
+        ActionResult res = engines[i]->ExecuteAction(name);
+        switch (res)
+        {
+        case ACTION_RESULT_UNKNOWN:
+            continue;
+        case ACTION_RESULT_OK:
+            out << name << ": done";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_IMPOSSIBLE:
+            out << name << ": impossible";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_USELESS:
+            out << name << ": useless";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_FAILED:
+            out << name << ": failed";
+            TellMaster(out);
+            return;
+        }
+    }
+    ostringstream out;
+    out << name << ": unknown action";
+    TellMaster(out);
+}
+
+bool PlayerbotAI::ContainsStrategy(StrategyType type)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i]->ContainsStrategy(type))
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasStrategy(string name, BotState type)
+{
+    return engines[type]->HasStrategy(name);
+}
+
+void PlayerbotAI::ResetStrategies()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i]->removeAllStrategies();
+
+    AiFactory::AddDefaultCombatStrategies(bot, this, engines[BOT_STATE_COMBAT]);
+    AiFactory::AddDefaultNonCombatStrategies(bot, this, engines[BOT_STATE_NON_COMBAT]);
+    AiFactory::AddDefaultDeadStrategies(bot, this, engines[BOT_STATE_DEAD]);
+}
+
+bool PlayerbotAI::IsRanged(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_RANGED);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        return false;
+    case CLASS_DRUID:
+        return !HasAnyAuraOf(player, "cat form", "bear form", "dire bear form", NULL);
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsTank(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_TANK);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "bear form", "dire bear form", NULL);
+    }
+    return false;
+}
+
+bool PlayerbotAI::IsHeal(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_HEAL);
+
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "tree of life form", NULL);
+    }
+    return false;
+}
+
+
+
+namespace MaNGOS
+{
+
+    class UnitByGuidInRangeCheck
+    {
+    public:
+        UnitByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(Unit* u)
+        {
+            return u->GetGUID() == i_guid && i_obj->IsWithinDistInMap(u, i_range);
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+    class GameObjectByGuidInRangeCheck
+    {
+    public:
+        GameObjectByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(GameObject* u)
+        {
+            if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo() && u->GetGUID() == i_guid)
+                return true;
+
+            return false;
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+};
+
+
+Unit* PlayerbotAI::GetUnit(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return ObjectAccessor::GetObjectInMap(guid, map, (Unit*)NULL);
+}
+
+
+Creature* PlayerbotAI::GetCreature(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetCreature(guid);
+}
+
+GameObject* PlayerbotAI::GetGameObject(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetGameObject(guid);
+}
+
+bool PlayerbotAI::TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!GetSecurity()->CheckLevelFor(securityLevel, true, master))
+        return false;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            master->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.whisperDistance))
+        return false;
+
+    bot->Whisper(text, LANG_UNIVERSAL, master);
+    return true;
+}
+
+bool PlayerbotAI::TellMaster(string text, PlayerbotSecurityLevel securityLevel)
+{
+    if (!TellMasterNoFacing(text, securityLevel))
+        return false;
+
+    if (!bot->isMoving() && !bot->IsInCombat() && bot->GetMapId() == master->GetMapId())
+    {
+        if (!bot->isInFront(master, M_PI / 2))
+            bot->SetFacingTo(bot->GetAngle(master));
+
+        bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+
+    return true;
+}
+
+bool IsRealAura(Player* bot, Aura const* aura, Unit* unit)
+{
+    if (!aura)
+        return false;
+
+    if (!unit->IsHostileTo(bot))
+        return true;
+
+    uint32 stacks = aura->GetStackAmount();
+    if (stacks >= aura->GetSpellInfo()->StackAmount)
+        return true;
+
+    if (aura->GetCaster() == bot || aura->GetSpellInfo()->IsPositive() || aura->IsArea())
+        return true;
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(string name, Unit* unit)
+{
+    if (!unit)
+        return false;
+
+    uint32 spellId = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellId)
+        return HasAura(spellId, unit);
+
+    wstring wnamepart;
+    if (!Utf8toWStr(name, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+
+    Unit::AuraApplicationMap& map = unit->GetAppliedAuras();
+    for (Unit::AuraApplicationMap::iterator i = map.begin(); i != map.end(); ++i)
+    {
+        Aura const* aura  = i->second->GetBase();
+        if (!aura)
+            continue;
+
+        const string auraName = aura->GetSpellInfo()->SpellName[0];
+        if (auraName.empty() || auraName.length() != wnamepart.length() || !Utf8FitTo(auraName, wnamepart))
+            continue;
+
+        if (IsRealAura(bot, aura, unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit* unit)
+{
+    if (!spellId || !unit)
+        return false;
+
+    for (uint32 effect = EFFECT_0; effect <= EFFECT_2; effect++)
+    {
+        Aura* aura = ((Unit*)unit)->GetAura(spellId);
+
+        if (IsRealAura(bot, aura, (Unit*)unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAnyAuraOf(Unit* player, ...)
+{
+    if (!player)
+        return false;
+
+    va_list vl;
+    va_start(vl, player);
+
+    const char* cur;
+    do {
+        cur = va_arg(vl, const char*);
+        if (cur && HasAura(cur, player)) {
+            va_end(vl);
+            return true;
+        }
+    }
+    while (cur);
+
+    va_end(vl);
+    return false;
+}
+
+bool PlayerbotAI::CanCastSpell(string name, Unit* target)
+{
+    return CanCastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+}
+
+bool PlayerbotAI::CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell)
+{
+    if (!spellid)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    if (checkHasSpell && !bot->HasSpell(spellid))
+        return false;
+
+    if (bot->HasSpellCooldown(spellid))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    bool positiveSpell = spellInfo->IsPositive();
+    if (positiveSpell && bot->IsHostileTo(target))
+        return false;
+
+    if (!positiveSpell && bot->IsFriendlyTo(target))
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    if (bot != target && bot->GetDistance(target) > sPlayerbotAIConfig.sightDistance)
+        return false;
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+    Spell *spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
+
+    spell->m_targets.SetUnitTarget(target);
+    spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellid)->Get();
+    spell->m_targets.SetItemTarget(spell->m_CastItem);
+    SpellCastResult result = spell->CheckCast(false);
+    delete spell;
+	if (oldSel)
+		bot->SetSelection(oldSel->GetGUID());
+
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_INFRONT:
+    case SPELL_FAILED_NOT_STANDING:
+    case SPELL_FAILED_UNIT_NOT_INFRONT:
+    case SPELL_FAILED_SUCCESS:
+    case SPELL_FAILED_MOVING:
+    case SPELL_FAILED_TRY_AGAIN:
+    case SPELL_FAILED_NOT_IDLE:
+    case SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW:
+    case SPELL_FAILED_SUMMON_PENDING:
+    case SPELL_FAILED_BAD_IMPLICIT_TARGETS:
+    case SPELL_FAILED_BAD_TARGETS:
+    case SPELL_CAST_OK:
+    case SPELL_FAILED_ITEM_NOT_FOUND:
+        return true;
+    default:
+        return false;
+    }
+}
+
+
+bool PlayerbotAI::CastSpell(string name, Unit* target)
+{
+    bool result = CastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+    if (result)
+    {
+        aiObjectContext->GetValue<time_t>("last spell cast time", name)->Set(time(0));
+    }
+
+    return result;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit* target)
+{
+    if (!spellId)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    Pet* pet = bot->GetPet();
+    const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (pet && pet->HasSpell(spellId))
+    {
+        pet->GetCharmInfo()->SetSpellAutocast(pSpellInfo, true);
+        pet->GetCharmInfo()->ToggleCreatureAutocast(pSpellInfo, true);
+        TellMaster("My pet will auto-cast this spell");
+        return true;
+    }
+
+    aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get().Set(spellId, target->GetGUID(), time(0));
+    aiObjectContext->GetValue<LastMovement&>("last movement")->Get().Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (bot->IsFlying())
+        return false;
+
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    if (bot->isMoving() && spell->GetCastTime())
+    {
+        delete spell;
+        return false;
+    }
+
+    SpellCastTargets targets;
+    WorldObject* faceTo = target;
+
+    if (pSpellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION ||
+            pSpellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
+    {
+        targets.SetDst(target->GetPosition());
+    }
+    else
+    {
+        targets.SetUnitTarget(target);
+    }
+
+    if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+    {
+        spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellId)->Get();
+        targets.SetItemTarget(spell->m_CastItem);
+    }
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        LootObject loot = *aiObjectContext->GetValue<LootObject>("loot target");
+        if (!loot.IsLootPossible(bot))
+        {
+            delete spell;
+            return false;
+        }
+
+        GameObject* go = GetGameObject(loot.guid);
+        if (go && go->isSpawned())
+        {
+            WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+            *packetgouse << loot.guid;
+            bot->GetSession()->QueuePacket(packetgouse);
+            targets.SetGOTarget(go);
+            faceTo = go;
+        }
+        else
+        {
+            Unit* creature = GetUnit(loot.guid);
+            if (creature)
+            {
+                targets.SetUnitTarget(creature);
+                faceTo = creature;
+            }
+        }
+    }
+
+
+    if (!bot->isInFront(faceTo, M_PI / 2))
+    {
+        bot->SetFacingTo(bot->GetAngle(faceTo));
+        delete spell;
+        SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        return false;
+    }
+
+	spell->prepare(&targets);
+	WaitForSpellCast(spell);
+
+    if (oldSel)
+        bot->SetSelection(oldSel->GetGUID());
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    return lastSpell.id == spellId;
+}
+
+void PlayerbotAI::WaitForSpellCast(Spell *spell)
+{
+    const SpellInfo* const pSpellInfo = spell->GetSpellInfo();
+
+    float castTime = spell->GetCastTime() + sPlayerbotAIConfig.reactDelay;
+    if (pSpellInfo->IsChanneled())
+    {
+        int32 duration = pSpellInfo->GetDuration();
+        if (duration > 0)
+            castTime += duration;
+    }
+
+    castTime = ceil(castTime);
+
+    uint32 globalCooldown = CalculateGlobalCooldown(pSpellInfo->Id);
+    if (castTime < globalCooldown)
+        castTime = globalCooldown;
+
+    SetNextCheckDelay(castTime);
+}
+
+void PlayerbotAI::InterruptSpell()
+{
+    if (bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+        return;
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+
+    for (int type = CURRENT_MELEE_SPELL; type < CURRENT_CHANNELED_SPELL; type++)
+    {
+        Spell* spell = bot->GetCurrentSpell((CurrentSpellTypes)type);
+        if (!spell)
+            continue;
+
+        bot->InterruptSpell((CurrentSpellTypes)type);
+
+        WorldPacket data(SMSG_SPELL_FAILURE, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        data.Initialize(SMSG_SPELL_FAILED_OTHER, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        SpellInterrupted(spell->m_spellInfo->Id);
+    }
+
+    SpellInterrupted(lastSpell.id);
+}
+
+
+void PlayerbotAI::RemoveAura(string name)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellid && HasAura(spellid, bot))
+        bot->RemoveAurasDueToSpell(spellid);
+}
+
+bool PlayerbotAI::IsInterruptableSpellCasting(Unit* target, string spell)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", spell)->Get();
+    if (!spellid || !target->IsNonMeleeSpellCast(true))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    for (uint32 i = EFFECT_0; i <= EFFECT_2; i++)
+    {
+        if ((spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) && spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            return true;
+
+        if ((spellInfo->Effects[i].Effect == SPELL_EFFECT_REMOVE_AURA || spellInfo->Effects[i].Effect == SPELL_EFFECT_INTERRUPT_CAST) &&
+                !target->IsImmunedToSpellEffect(spellInfo, i))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAuraToDispel(Unit* target, uint32 dispelType)
+{
+    for (uint32 type = SPELL_AURA_NONE; type < TOTAL_AURAS; ++type)
+    {
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType((AuraType)type);
+        for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            const AuraEffect *const aura = *itr;
+			const SpellInfo* entry = aura->GetSpellInfo();
+            uint32 spellId = entry->Id;
+
+            bool isPositiveSpell = entry->IsPositive();
+            if (isPositiveSpell && bot->IsFriendlyTo(target))
+                continue;
+
+            if (!isPositiveSpell && bot->IsHostileTo(target))
+                continue;
+
+            if (canDispel(entry, dispelType))
+                return true;
+        }
+    }
+    return false;
+}
+
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool PlayerbotAI::canDispel(const SpellInfo* entry, uint32 dispelType)
+{
+    if (entry->Dispel != dispelType)
+        return false;
+
+    return !entry->SpellName[0] ||
+        (strcmpi((const char*)entry->SpellName[0], "demon skin") &&
+        strcmpi((const char*)entry->SpellName[0], "mage armor") &&
+        strcmpi((const char*)entry->SpellName[0], "frost armor") &&
+        strcmpi((const char*)entry->SpellName[0], "wavering will") &&
+        strcmpi((const char*)entry->SpellName[0], "chilled") &&
+        strcmpi((const char*)entry->SpellName[0], "ice armor"));
+}
+
+bool IsAlliance(uint8 race)
+{
+    return race == RACE_HUMAN || race == RACE_DWARF || race == RACE_NIGHTELF ||
+            race == RACE_GNOME || race == RACE_DRAENEI;
+}
+
+bool PlayerbotAI::IsOpposing(Player* player)
+{
+    return IsOpposing(player->getRace(), bot->getRace());
+}
+
+bool PlayerbotAI::IsOpposing(uint8 race1, uint8 race2)
+{
+    return (IsAlliance(race1) && !IsAlliance(race2)) || (!IsAlliance(race1) && IsAlliance(race2));
+}
+
+void PlayerbotAI::RemoveShapeshift()
+{
+    RemoveAura("bear form");
+    RemoveAura("dire bear form");
+    RemoveAura("moonkin form");
+    RemoveAura("travel form");
+    RemoveAura("cat form");
+    RemoveAura("flight form");
+    RemoveAura("swift flight form");
+    RemoveAura("aquatic form");
+    RemoveAura("ghost wolf");
+    RemoveAura("tree of life");
+}
+
+uint32 PlayerbotAI::GetEquipGearScore(Player* player, bool withBags, bool withBank)
+{
+    std::vector<uint32> gearScore(EQUIPMENT_SLOT_END);
+    uint32 twoHandScore = 0;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            _fillGearScoreData(player, item, &gearScore, twoHandScore);
+    }
+
+    if (withBags)
+    {
+        // check inventory
+        for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        // check bags
+        for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Bag* pBag = (Bag*)player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                {
+                    if (Item* item2 = pBag->GetItemByPos(j))
+                        _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                }
+            }
+        }
+    }
+
+    if (withBank)
+    {
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                if (item->IsBag())
+                {
+                    Bag* bag = (Bag*)item;
+                    for (uint8 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (Item* item2 = bag->GetItemByPos(j))
+                            _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                    }
+                }
+            }
+        }
+    }
+
+    uint8 count = EQUIPMENT_SLOT_END - 2;   // ignore body and tabard slots
+    uint32 sum = 0;
+
+    // check if 2h hand is higher level than main hand + off hand
+    if (gearScore[EQUIPMENT_SLOT_MAINHAND] + gearScore[EQUIPMENT_SLOT_OFFHAND] < twoHandScore * 2)
+    {
+        gearScore[EQUIPMENT_SLOT_OFFHAND] = 0;  // off hand is ignored in calculations if 2h weapon has higher score
+        --count;
+        gearScore[EQUIPMENT_SLOT_MAINHAND] = twoHandScore;
+    }
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+       sum += gearScore[i];
+    }
+
+    if (count)
+    {
+        uint32 res = uint32(sum / count);
+        return res;
+    }
+    else
+        return 0;
+}
+
+void PlayerbotAI::_fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore)
+{
+    if (!item)
+        return;
+
+    if (player->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+        return;
+
+    uint8 type   = item->GetTemplate()->InventoryType;
+    uint32 level = item->GetTemplate()->ItemLevel;
+
+    switch (type)
+    {
+        case INVTYPE_2HWEAPON:
+            twoHandScore = std::max(twoHandScore, level);
+            break;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+            (*gearScore)[SLOT_MAIN_HAND] = std::max((*gearScore)[SLOT_MAIN_HAND], level);
+            break;
+        case INVTYPE_SHIELD:
+        case INVTYPE_WEAPONOFFHAND:
+            (*gearScore)[EQUIPMENT_SLOT_OFFHAND] = std::max((*gearScore)[EQUIPMENT_SLOT_OFFHAND], level);
+            break;
+        case INVTYPE_THROWN:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_RANGED:
+        case INVTYPE_QUIVER:
+        case INVTYPE_RELIC:
+            (*gearScore)[EQUIPMENT_SLOT_RANGED] = std::max((*gearScore)[EQUIPMENT_SLOT_RANGED], level);
+            break;
+        case INVTYPE_HEAD:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        case INVTYPE_NECK:
+            (*gearScore)[EQUIPMENT_SLOT_NECK] = std::max((*gearScore)[EQUIPMENT_SLOT_NECK], level);
+            break;
+        case INVTYPE_SHOULDERS:
+            (*gearScore)[EQUIPMENT_SLOT_SHOULDERS] = std::max((*gearScore)[EQUIPMENT_SLOT_SHOULDERS], level);
+            break;
+        case INVTYPE_BODY:
+            (*gearScore)[EQUIPMENT_SLOT_BODY] = std::max((*gearScore)[EQUIPMENT_SLOT_BODY], level);
+            break;
+        case INVTYPE_CHEST:
+            (*gearScore)[EQUIPMENT_SLOT_CHEST] = std::max((*gearScore)[EQUIPMENT_SLOT_CHEST], level);
+            break;
+        case INVTYPE_WAIST:
+            (*gearScore)[EQUIPMENT_SLOT_WAIST] = std::max((*gearScore)[EQUIPMENT_SLOT_WAIST], level);
+            break;
+        case INVTYPE_LEGS:
+            (*gearScore)[EQUIPMENT_SLOT_LEGS] = std::max((*gearScore)[EQUIPMENT_SLOT_LEGS], level);
+            break;
+        case INVTYPE_FEET:
+            (*gearScore)[EQUIPMENT_SLOT_FEET] = std::max((*gearScore)[EQUIPMENT_SLOT_FEET], level);
+            break;
+        case INVTYPE_WRISTS:
+            (*gearScore)[EQUIPMENT_SLOT_WRISTS] = std::max((*gearScore)[EQUIPMENT_SLOT_WRISTS], level);
+            break;
+        case INVTYPE_HANDS:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        // equipped gear score check uses both rings and trinkets for calculation, assume that for bags/banks it is the same
+        // with keeping second highest score at second slot
+        case INVTYPE_FINGER:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_FINGER1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = (*gearScore)[EQUIPMENT_SLOT_FINGER1];
+                (*gearScore)[EQUIPMENT_SLOT_FINGER1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_FINGER2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = level;
+            break;
+        }
+        case INVTYPE_TRINKET:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_TRINKET1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = (*gearScore)[EQUIPMENT_SLOT_TRINKET1];
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_TRINKET2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = level;
+            break;
+        }
+        case INVTYPE_CLOAK:
+            (*gearScore)[EQUIPMENT_SLOT_BACK] = std::max((*gearScore)[EQUIPMENT_SLOT_BACK], level);
+            break;
+        default:
+            break;
+    }
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAI.h b/src/plugins/playerbot/PlayerbotAI.h
new file mode 100644
index 0000000..fc722c2
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.h
@@ -0,0 +1,184 @@
+#pragma once
+
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotAIBase.h"
+#include "strategy/AiObjectContext.h"
+#include "strategy/Engine.h"
+#include "strategy/ExternalEventHelper.h"
+#include "ChatFilter.h"
+#include "PlayerbotSecurity.h"
+#include <stack>
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using namespace ai;
+
+bool IsAlliance(uint8 race);
+
+class PlayerbotChatHandler: protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer->GetSession()) {}
+    void sysmessage(string str) { SendSysMessage(str.c_str()); }
+    uint32 extractQuestId(string str);
+    uint32 extractSpellId(string str)
+    {
+        char* source = (char*)str.c_str();
+        return extractSpellIdFromLink(source);
+    }
+};
+
+namespace ai
+{
+	class MinValueCalculator {
+	public:
+		MinValueCalculator(float def = 0.0f) {
+			param = NULL;
+			minValue = def;
+		}
+
+	public:
+		void probe(float value, void* p) {
+			if (!param || minValue >= value) {
+				minValue = value;
+				param = p;
+			}
+		}
+
+	public:
+		void* param;
+		float minValue;
+	};
+};
+
+enum BotState
+{
+    BOT_STATE_COMBAT = 0,
+    BOT_STATE_NON_COMBAT = 1,
+    BOT_STATE_DEAD = 2
+};
+
+#define BOT_STATE_MAX 3
+
+class PacketHandlingHelper
+{
+public:
+    void AddHandler(uint16 opcode, string handler);
+    void Handle(ExternalEventHelper &helper);
+    void AddPacket(const WorldPacket& packet);
+
+private:
+    map<uint16, string> handlers;
+    stack<WorldPacket> queue;
+};
+
+class ChatCommandHolder
+{
+public:
+    ChatCommandHolder(string command, Player* owner = NULL, uint32 type = CHAT_MSG_WHISPER) : command(command), owner(owner), type(type) {}
+    ChatCommandHolder(ChatCommandHolder const& other)
+    {
+        this->command = other.command;
+        this->owner = other.owner;
+        this->type = other.type;
+    }
+
+public:
+    string GetCommand() { return command; }
+    Player* GetOwner() { return owner; }
+    uint32 GetType() { return type; }
+
+private:
+    string command;
+    Player* owner;
+    uint32 type;
+};
+
+class PlayerbotAI : public PlayerbotAIBase
+{
+public:
+	PlayerbotAI();
+	PlayerbotAI(Player* bot);
+	virtual ~PlayerbotAI();
+
+public:
+	virtual void UpdateAI(uint32 elapsed);
+	virtual void UpdateAIInternal(uint32 elapsed);
+    void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+	void HandleBotOutgoingPacket(const WorldPacket& packet);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+	void HandleTeleportAck();
+    void ChangeEngine(BotState type);
+    void DoNextAction();
+    void DoSpecificAction(string name);
+    void ChangeStrategy(string name, BotState type);
+    bool ContainsStrategy(StrategyType type);
+    bool HasStrategy(string name, BotState type);
+    void ResetStrategies();
+    void ReInitCurrentEngine();
+    void Reset();
+    bool IsTank(Player* player);
+    bool IsHeal(Player* player);
+    bool IsRanged(Player* player);
+    Creature* GetCreature(ObjectGuid guid);
+    Unit* GetUnit(ObjectGuid guid);
+    GameObject* GetGameObject(ObjectGuid guid);
+    bool TellMaster(ostringstream &stream, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL) { return TellMaster(stream.str(), securityLevel); }
+    bool TellMaster(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    bool TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    void SpellInterrupted(uint32 spellid);
+    int32 CalculateGlobalCooldown(uint32 spellid);
+    void InterruptSpell();
+    void RemoveAura(string name);
+    void RemoveShapeshift();
+    void WaitForSpellCast(Spell *spell);
+
+    virtual bool CanCastSpell(string name, Unit* target);
+    virtual bool CastSpell(string name, Unit* target);
+    virtual bool HasAura(string spellName, Unit* player);
+    virtual bool HasAnyAuraOf(Unit* player, ...);
+
+    virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+    virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+    bool CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell = true);
+
+    bool HasAura(uint32 spellId, const Unit* player);
+    bool CastSpell(uint32 spellId, Unit* target);
+    bool canDispel(const SpellInfo* entry, uint32 dispelType);
+
+    uint32 GetEquipGearScore(Player* player, bool withBags, bool withBank);
+
+private:
+    void _fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore);
+
+public:
+	Player* GetBot() { return bot; }
+    Player* GetMaster() { return master; }
+    void SetMaster(Player* master) { this->master = master; }
+    AiObjectContext* GetAiObjectContext() { return aiObjectContext; }
+    ChatHelper* GetChatHelper() { return &chatHelper; }
+    bool IsOpposing(Player* player);
+    static bool IsOpposing(uint8 race1, uint8 race2);
+    PlayerbotSecurity* GetSecurity() { return &security; }
+
+protected:
+	Player* bot;
+	Player* master;
+	uint32 accountId;
+    AiObjectContext* aiObjectContext;
+    Engine* currentEngine;
+    Engine* engines[BOT_STATE_MAX];
+    ChatHelper chatHelper;
+    stack<ChatCommandHolder> chatCommands;
+    PacketHandlingHelper botOutgoingPacketHandlers;
+    PacketHandlingHelper masterIncomingPacketHandlers;
+    PacketHandlingHelper masterOutgoingPacketHandlers;
+    CompositeChatFilter chatFilter;
+    PlayerbotSecurity security;
+};
+
diff --git a/src/plugins/playerbot/PlayerbotAIAware.h b/src/plugins/playerbot/PlayerbotAIAware.h
new file mode 100644
index 0000000..740628a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIAware.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class PlayerbotAIAware 
+    {
+    public:
+        PlayerbotAIAware(PlayerbotAI* const ai) : ai(ai) { }
+
+    protected:
+        PlayerbotAI* ai;
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAIBase.cpp b/src/plugins/playerbot/PlayerbotAIBase.cpp
new file mode 100644
index 0000000..7913da8
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.cpp
@@ -0,0 +1,51 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+PlayerbotAIBase::PlayerbotAIBase() : nextAICheckDelay(0)
+{
+}
+
+void PlayerbotAIBase::UpdateAI(uint32 elapsed)
+{
+    if (nextAICheckDelay > elapsed)
+        nextAICheckDelay -= elapsed;
+    else
+        nextAICheckDelay = 0;
+
+    if (!CanUpdateAI())
+        return;
+
+    UpdateAIInternal(elapsed);
+    YieldThread();
+}
+
+void PlayerbotAIBase::SetNextCheckDelay(const uint32 delay)
+{
+    nextAICheckDelay = delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "set next check delay: %d", nextAICheckDelay);
+}
+
+void PlayerbotAIBase::IncreaseNextCheckDelay(uint32 delay)
+{
+    nextAICheckDelay += delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "increase next check delay: %d", nextAICheckDelay);
+}
+
+bool PlayerbotAIBase::CanUpdateAI()
+{
+    return nextAICheckDelay < 100;
+}
+
+void PlayerbotAIBase::YieldThread()
+{
+    if (nextAICheckDelay < sPlayerbotAIConfig.reactDelay)
+        nextAICheckDelay = sPlayerbotAIConfig.reactDelay;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIBase.h b/src/plugins/playerbot/PlayerbotAIBase.h
new file mode 100644
index 0000000..8e72bf0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.h
@@ -0,0 +1,24 @@
+#pragma once
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+
+class PlayerbotAIBase
+{
+public:
+	PlayerbotAIBase();
+
+public:
+	bool CanUpdateAI();
+	void SetNextCheckDelay(const uint32 delay);
+    void IncreaseNextCheckDelay(uint32 delay);
+	void YieldThread();
+    virtual void UpdateAI(uint32 elapsed);
+    virtual void UpdateAIInternal(uint32 elapsed) = 0;
+
+protected:
+	uint32 nextAICheckDelay;
+};
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.cpp b/src/plugins/playerbot/PlayerbotAIConfig.cpp
new file mode 100644
index 0000000..0f03b8a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.cpp
@@ -0,0 +1,293 @@
+#include "../pchdef.h"
+#include "PlayerbotAIConfig.h"
+#include "playerbot.h"
+#include "RandomPlayerbotFactory.h"
+#include "../../game/Accounts/AccountMgr.h"
+#include "../../shared/SystemConfig.h"
+
+using namespace std;
+
+PlayerbotAIConfig::PlayerbotAIConfig()
+{
+}
+
+template <class T>
+void LoadList(string value, T &list)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        list.push_back(id);
+    }
+}
+
+bool PlayerbotAIConfig::Initialize()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing AI Playerbot by ike3, based on the original Playerbot by blueboy");
+
+    string error;
+    if (!config.LoadInitial("aiplayerbot.conf", error))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled. Unable to open configuration file aiplayerbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AiPlayerbot.Enabled", true);
+    if (!enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled in aiplayerbot.conf");
+        return false;
+    }
+
+    globalCoolDown = (uint32) config.GetIntDefault("AiPlayerbot.GlobalCooldown", 500);
+    maxWaitForMove = config.GetIntDefault("AiPlayerbot.MaxWaitForMove", 3000);
+    reactDelay = (uint32) config.GetIntDefault("AiPlayerbot.ReactDelay", 100);
+
+    sightDistance = config.GetFloatDefault("AiPlayerbot.SightDistance", 50.0f);
+    spellDistance = config.GetFloatDefault("AiPlayerbot.SpellDistance", 30.0f);
+    reactDistance = config.GetFloatDefault("AiPlayerbot.ReactDistance", 150.0f);
+    grindDistance = config.GetFloatDefault("AiPlayerbot.GrindDistance", 100.0f);
+    lootDistance = config.GetFloatDefault("AiPlayerbot.LootDistance", 20.0f);
+    fleeDistance = config.GetFloatDefault("AiPlayerbot.FleeDistance", 20.0f);
+    tooCloseDistance = config.GetFloatDefault("AiPlayerbot.TooCloseDistance", 7.0f);
+    meleeDistance = config.GetFloatDefault("AiPlayerbot.MeleeDistance", 1.5f);
+    followDistance = config.GetFloatDefault("AiPlayerbot.FollowDistance", 1.5f);
+    whisperDistance = config.GetFloatDefault("AiPlayerbot.WhisperDistance", 6000.0f);
+    contactDistance = config.GetFloatDefault("AiPlayerbot.ContactDistance", 0.5f);
+
+    criticalHealth = config.GetIntDefault("AiPlayerbot.CriticalHealth", 20);
+    lowHealth = config.GetIntDefault("AiPlayerbot.LowHealth", 50);
+    mediumHealth = config.GetIntDefault("AiPlayerbot.MediumHealth", 70);
+    almostFullHealth = config.GetIntDefault("AiPlayerbot.AlmostFullHealth", 85);
+    lowMana = config.GetIntDefault("AiPlayerbot.LowMana", 15);
+    mediumMana = config.GetIntDefault("AiPlayerbot.MediumMana", 40);
+
+    randomGearLoweringChance = config.GetFloatDefault("AiPlayerbot.RandomGearLoweringChance", 0.15);
+    randomBotMaxLevelChance = config.GetFloatDefault("AiPlayerbot.RandomBotMaxLevelChance", 0.4);
+
+    iterationsPerTick = config.GetIntDefault("AiPlayerbot.IterationsPerTick", 4);
+
+    allowGuildBots = config.GetBoolDefault("AiPlayerbot.AllowGuildBots", true);
+
+    randomBotMapsAsString = config.GetStringDefault("AiPlayerbot.RandomBotMaps", "0,1,530,571");
+    LoadList<vector<uint32> >(randomBotMapsAsString, randomBotMaps);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotQuestItems", "6948,5175,5176,5177,5178"), randomBotQuestItems);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotSpellIds", "54197"), randomBotSpellIds);
+
+    randomBotAutologin = config.GetBoolDefault("AiPlayerbot.RandomBotAutologin", true);
+    minRandomBots = config.GetIntDefault("AiPlayerbot.MinRandomBots", 50);
+    maxRandomBots = config.GetIntDefault("AiPlayerbot.MaxRandomBots", 200);
+    randomBotUpdateInterval = config.GetIntDefault("AiPlayerbot.RandomBotUpdateInterval", 60);
+    randomBotCountChangeMinInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMinInterval", 24 * 3600);
+    randomBotCountChangeMaxInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMaxInterval", 3 * 24 * 3600);
+    minRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MinRandomBotInWorldTime", 2 * 3600);
+    maxRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MaxRandomBotInWorldTime", 14 * 24 * 3600);
+    minRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MinRandomBotRandomizeTime", 2 * 3600);
+    maxRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MaxRandomRandomizeTime", 14 * 24 * 3600);
+    minRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MinRandomBotReviveTime", 60);
+    maxRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MaxRandomReviveTime", 300);
+    randomBotTeleportDistance = config.GetIntDefault("AiPlayerbot.RandomBotTeleportDistance", 1000);
+    minRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPerInterval", 50);
+    maxRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPerInterval", 100);
+    minRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPriceChangeInterval", 2 * 3600);
+    maxRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPriceChangeInterval", 48 * 3600);
+    randomBotJoinLfg = config.GetBoolDefault("AiPlayerbot.RandomBotJoinLfg", true);
+    logInGroupOnly = config.GetBoolDefault("AiPlayerbot.LogInGroupOnly", true);
+    logValuesPerTick = config.GetBoolDefault("AiPlayerbot.LogValuesPerTick", false);
+    fleeingEnabled = config.GetBoolDefault("AiPlayerbot.FleeingEnabled", true);
+    randomBotMinLevel = config.GetIntDefault("AiPlayerbot.RandomBotMinLevel", 1);
+    randomBotMaxLevel = config.GetIntDefault("AiPlayerbot.RandomBotMaxLevel", 255);
+    randomBotLoginAtStartup = config.GetBoolDefault("AiPlayerbot.RandomBotLoginAtStartup", true);
+
+    randomChangeMultiplier = config.GetFloatDefault("AiPlayerbot.RandomChangeMultiplier", 1.0);
+
+    randomBotCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotCombatStrategies", "+dps,+attack weak");
+    randomBotNonCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotNonCombatStrategies", "+grind,+move random,+loot");
+
+    commandPrefix = config.GetStringDefault("AiPlayerbot.CommandPrefix", "");
+
+    for (uint32 cls = 0; cls < MAX_CLASSES; ++cls)
+    {
+        for (uint32 spec = 0; spec < 3; ++spec)
+        {
+            ostringstream os; os << "AiPlayerbot.RandomClassSpecProbability." << cls << "." << spec;
+            specProbability[cls][spec] = config.GetIntDefault(os.str().c_str(), 33);
+        }
+    }
+
+    CreateRandomBots();
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot configuration loaded");
+
+    return true;
+}
+
+
+bool PlayerbotAIConfig::IsInRandomAccountList(uint32 id)
+{
+    return find(randomBotAccounts.begin(), randomBotAccounts.end(), id) != randomBotAccounts.end();
+}
+
+bool PlayerbotAIConfig::IsInRandomQuestItemList(uint32 id)
+{
+    return find(randomBotQuestItems.begin(), randomBotQuestItems.end(), id) != randomBotQuestItems.end();
+}
+
+string PlayerbotAIConfig::GetValue(string name)
+{
+    ostringstream out;
+
+    if (name == "GlobalCooldown")
+        out << globalCoolDown;
+    else if (name == "ReactDelay")
+        out << reactDelay;
+
+    else if (name == "SightDistance")
+        out << sightDistance;
+    else if (name == "SpellDistance")
+        out << spellDistance;
+    else if (name == "ReactDistance")
+        out << reactDistance;
+    else if (name == "GrindDistance")
+        out << grindDistance;
+    else if (name == "LootDistance")
+        out << lootDistance;
+    else if (name == "FleeDistance")
+        out << fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out << criticalHealth;
+    else if (name == "LowHealth")
+        out << lowHealth;
+    else if (name == "MediumHealth")
+        out << mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out << almostFullHealth;
+    else if (name == "LowMana")
+        out << lowMana;
+
+    else if (name == "IterationsPerTick")
+        out << iterationsPerTick;
+
+    return out.str();
+}
+
+void PlayerbotAIConfig::SetValue(string name, string value)
+{
+    istringstream out(value, istringstream::in);
+
+    if (name == "GlobalCooldown")
+        out >> globalCoolDown;
+    else if (name == "ReactDelay")
+        out >> reactDelay;
+
+    else if (name == "SightDistance")
+        out >> sightDistance;
+    else if (name == "SpellDistance")
+        out >> spellDistance;
+    else if (name == "ReactDistance")
+        out >> reactDistance;
+    else if (name == "GrindDistance")
+        out >> grindDistance;
+    else if (name == "LootDistance")
+        out >> lootDistance;
+    else if (name == "FleeDistance")
+        out >> fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out >> criticalHealth;
+    else if (name == "LowHealth")
+        out >> lowHealth;
+    else if (name == "MediumHealth")
+        out >> mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out >> almostFullHealth;
+    else if (name == "LowMana")
+        out >> lowMana;
+
+    else if (name == "IterationsPerTick")
+        out >> iterationsPerTick;
+}
+
+
+void PlayerbotAIConfig::CreateRandomBots()
+{
+    string randomBotAccountPrefix = config.GetStringDefault("AiPlayerbot.RandomBotAccountPrefix", "rndbot");
+    uint32 randomBotAccountCount = config.GetIntDefault("AiPlayerbot.RandomBotAccountCount", 50);
+
+    if (config.GetBoolDefault("AiPlayerbot.DeleteRandomBotAccounts", false))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot accounts...");
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", randomBotAccountPrefix.c_str());
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                sAccountMgr->DeleteAccount(fields[0].GetUInt32());
+            } while (results->NextRow());
+        }
+
+        CharacterDatabase.Execute("DELETE FROM ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot accounts deleted");
+    }
+
+    for (int accountNumber = 0; accountNumber < randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (results)
+        {
+            continue;
+        }
+
+        string password = "";
+        for (int i = 0; i < 10; i++)
+        {
+            password += (char)urand('!', 'z');
+        }
+        sAccountMgr->CreateAccount(accountName, password, "playerbot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Account %s created for random bots", accountName.c_str());
+    }
+
+    LoginDatabase.PExecute("UPDATE account SET expansion = '%u' where username like '%s%%'", 2, randomBotAccountPrefix.c_str());
+
+    int totalRandomBotChars = 0;
+    for (int accountNumber = 0; accountNumber < randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (!results)
+            continue;
+
+        Field* fields = results->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+
+        randomBotAccounts.push_back(accountId);
+
+        int count = sAccountMgr->GetCharactersCount(accountId);
+        if (count >= 10)
+        {
+            totalRandomBotChars += count;
+            continue;
+        }
+
+        RandomPlayerbotFactory factory(accountId);
+        for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+        {
+            if (cls != 10 && cls != CLASS_DEATH_KNIGHT)
+                factory.CreateRandomBot(cls);
+        }
+
+        totalRandomBotChars += sAccountMgr->GetCharactersCount(accountId);
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot accounts with %d characters available", randomBotAccounts.size(), totalRandomBotChars);
+}
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.h b/src/plugins/playerbot/PlayerbotAIConfig.h
new file mode 100644
index 0000000..d5d4a98
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.h
@@ -0,0 +1,69 @@
+#pragma once
+
+#include "../../shared/Configuration/Config.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+class PlayerbotAIConfig
+{
+public:
+    PlayerbotAIConfig();
+    static PlayerbotAIConfig& instance()
+    {
+        static PlayerbotAIConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+    bool IsInRandomAccountList(uint32 id);
+    bool IsInRandomQuestItemList(uint32 id);
+
+    bool enabled;
+    bool allowGuildBots;
+    uint32 globalCoolDown, reactDelay, maxWaitForMove;
+    float sightDistance, spellDistance, reactDistance, grindDistance, lootDistance,
+        fleeDistance, tooCloseDistance, meleeDistance, followDistance, whisperDistance, contactDistance;
+    uint32 criticalHealth, lowHealth, mediumHealth, almostFullHealth;
+    uint32 lowMana, mediumMana;
+
+    bool randomBotAutologin;
+    std::string randomBotMapsAsString;
+    std::vector<uint32> randomBotMaps;
+    std::list<uint32> randomBotQuestItems;
+    std::list<uint32> randomBotAccounts;
+    std::list<uint32> randomBotSpellIds;
+    uint32 randomBotTeleportDistance;
+    float randomGearLoweringChance;
+    float randomBotMaxLevelChance;
+    uint32 minRandomBots, maxRandomBots;
+    uint32 randomBotUpdateInterval, randomBotCountChangeMinInterval, randomBotCountChangeMaxInterval;
+    uint32 minRandomBotInWorldTime, maxRandomBotInWorldTime;
+    uint32 minRandomBotRandomizeTime, maxRandomBotRandomizeTime;
+    uint32 minRandomBotReviveTime, maxRandomBotReviveTime;
+    uint32 minRandomBotPvpTime, maxRandomBotPvpTime;
+    uint32 minRandomBotsPerInterval, maxRandomBotsPerInterval;
+    uint32 minRandomBotsPriceChangeInterval, maxRandomBotsPriceChangeInterval;
+    bool randomBotJoinLfg;
+    bool randomBotLoginAtStartup;
+    bool logInGroupOnly, logValuesPerTick;
+    bool fleeingEnabled;
+    std::string randomBotCombatStrategies, randomBotNonCombatStrategies;
+    uint32 randomBotMinLevel, randomBotMaxLevel;
+    float randomChangeMultiplier;
+    uint32 specProbability[MAX_CLASSES][3];
+    std::string commandPrefix;
+
+    uint32 iterationsPerTick;
+
+    std::string GetValue(std::string name);
+    void SetValue(std::string name, std::string value);
+
+private:
+    void CreateRandomBots();
+    ConfigMgr config;
+};
+
+#define sPlayerbotAIConfig PlayerbotAIConfig::instance()
diff --git a/src/plugins/playerbot/PlayerbotFactory.cpp b/src/plugins/playerbot/PlayerbotFactory.cpp
new file mode 100644
index 0000000..de4a4c7
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.cpp
@@ -0,0 +1,1655 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotFactory.h"
+#include "../ItemPrototype.h"
+#include "PlayerbotAIConfig.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../ahbot/AhBot.h"
+#include "../Entities/Pet/Pet.h"
+
+using namespace ai;
+using namespace std;
+
+uint32 PlayerbotFactory::tradeSkills[] =
+{
+    SKILL_ALCHEMY,
+    SKILL_ENCHANTING,
+    SKILL_SKINNING,
+    SKILL_JEWELCRAFTING,
+    SKILL_INSCRIPTION,
+    SKILL_TAILORING,
+    SKILL_LEATHERWORKING,
+    SKILL_ENGINEERING,
+    SKILL_HERBALISM,
+    SKILL_MINING,
+    SKILL_BLACKSMITHING,
+    SKILL_COOKING,
+    SKILL_FIRST_AID,
+    SKILL_FISHING
+};
+
+void PlayerbotFactory::Randomize()
+{
+    Randomize(true);
+}
+
+void PlayerbotFactory::Refresh()
+{
+    Prepare();
+    InitEquipment(true);
+    InitAmmo();
+    InitFood();
+    InitPotions();
+
+    uint32 money = urand(level * 1000, level * 5 * 1000);
+    if (bot->GetMoney() < money)
+        bot->SetMoney(money);
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::CleanRandomize()
+{
+    Randomize(false);
+}
+
+void PlayerbotFactory::Prepare()
+{
+    if (!itemQuality)
+    {
+        if (level <= 10)
+            itemQuality = urand(ITEM_QUALITY_NORMAL, ITEM_QUALITY_UNCOMMON);
+        else if (level <= 20)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_RARE);
+        else if (level <= 40)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else if (level < 60)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else
+            itemQuality = urand(ITEM_QUALITY_RARE, ITEM_QUALITY_EPIC);
+    }
+
+    if (bot->isDead())
+        bot->ResurrectPlayer(1.0f, false);
+
+    bot->CombatStop(true);
+    bot->SetLevel(level);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+}
+
+void PlayerbotFactory::Randomize(bool incremental)
+{
+    Prepare();
+
+    bot->ResetTalents(true);
+    ClearSpells();
+    ClearInventory();
+    bot->SaveToDB();
+
+    InitQuests();
+    // quest rewards boost bot level, so reduce back
+    bot->SetLevel(level);
+    ClearInventory();
+    bot->SetUInt32Value(PLAYER_XP, 0);
+    CancelAuras();
+    bot->SaveToDB();
+
+    InitAvailableSpells();
+    InitSkills();
+    InitTradeSkills();
+    InitTalents();
+    InitAvailableSpells();
+    InitSpecialSpells();
+    InitMounts();
+    UpdateTradeSkills();
+    bot->SaveToDB();
+
+    InitEquipment(incremental);
+    InitBags();
+    InitAmmo();
+    InitFood();
+    InitPotions();
+    InitSecondEquipmentSet();
+    InitInventory();
+    InitGlyphs();
+    bot->SetMoney(urand(level * 1000, level * 5 * 1000));
+    bot->SaveToDB();
+
+    InitPet();
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::InitPet()
+{
+    Pet* pet = bot->GetPet();
+    if (!pet)
+    {
+        if (bot->getClass() != CLASS_HUNTER)
+            return;
+
+        Map* map = bot->GetMap();
+        if (!map)
+            return;
+
+		vector<uint32> ids;
+	    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+	    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+	    {
+	        CreatureTemplate const& co = i->second;
+            if (!co.IsTameable(false))
+                continue;
+
+            if (co.minlevel > bot->getLevel())
+                continue;
+
+			PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co.Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+			ids.push_back(i->first);
+		}
+
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No pets available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+            return;
+        }
+
+		for (int i = 0; i < 100; i++)
+		{
+			int index = urand(0, ids.size() - 1);
+			CreatureTemplate const* co = sObjectMgr->GetCreatureTemplate(ids[index]);
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co->Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            uint32 guid = sObjectMgr->GenerateLowGuid(HIGHGUID_PET);
+            pet = new Pet(bot, HUNTER_PET);
+            if (!pet->Create(guid, map, 0, ids[index], 0))
+            {
+                delete pet;
+                pet = NULL;
+                continue;
+            }
+
+            pet->SetPosition(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), bot->GetOrientation());
+            pet->setFaction(bot->getFaction());
+            pet->SetLevel(bot->getLevel());
+            bot->SetPetGUID(pet->GetGUID());
+            bot->GetMap()->AddToMap(pet->ToCreature());
+            bot->SetMinion(pet, true);
+            pet->InitTalentForLevel();
+            bot->PetSpellInitialize();
+            bot->InitTamedPet(pet, bot->getLevel(), 0);
+
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "Bot %s: assign pet %d (%d level)", bot->GetName().c_str(), co->Entry, bot->getLevel());
+            pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+            break;
+        }
+    }
+
+    if (!pet)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot create pet for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        if(itr->second.state == PETSPELL_REMOVED)
+            continue;
+
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (spellInfo->IsPassive())
+            continue;
+
+        pet->ToggleAutocast(spellInfo, true);
+    }
+}
+
+void PlayerbotFactory::ClearSpells()
+{
+    list<uint32> spells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        spells.push_back(spellId);
+    }
+
+    for (list<uint32>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        bot->RemoveSpell(*i, false, false);
+    }
+}
+
+void PlayerbotFactory::InitSpells()
+{
+    for (int i = 0; i < 15; i++)
+        InitAvailableSpells();
+}
+
+void PlayerbotFactory::InitTalents()
+{
+    uint32 point = urand(0, 100);
+    uint8 cls = bot->getClass();
+    uint32 p1 = sPlayerbotAIConfig.specProbability[cls][0];
+    uint32 p2 = p1 + sPlayerbotAIConfig.specProbability[cls][1];
+
+    uint32 specNo = (point < p1 ? 0 : (point < p2 ? 1 : 2));
+    InitTalents(specNo);
+
+    if (bot->GetFreeTalentPoints())
+        InitTalents(2 - specNo);
+}
+
+
+class DestroyItemsVisitor : public IterateItemsVisitor
+{
+public:
+    DestroyItemsVisitor(Player* bot) : IterateItemsVisitor(), bot(bot) {}
+
+    virtual bool Visit(Item* item)
+    {
+        uint32 id = item->GetTemplate()->ItemId;
+        if (CanKeep(id))
+        {
+            keep.insert(id);
+            return true;
+        }
+
+        bot->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+        return true;
+    }
+
+private:
+    bool CanKeep(uint32 id)
+    {
+        if (keep.find(id) != keep.end())
+            return false;
+
+        if (sPlayerbotAIConfig.IsInRandomQuestItemList(id))
+            return true;
+
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        if (proto->Class == ITEM_CLASS_MISC && (proto->SubClass == ITEM_SUBCLASS_JUNK_REAGENT || proto->SubClass == ITEM_SUBCLASS_JUNK))
+            return true;
+
+        return false;
+    }
+
+private:
+    Player* bot;
+    set<uint32> keep;
+
+};
+
+bool PlayerbotFactory::CanEquipArmor(ItemTemplate const* proto)
+{
+    if (bot->HasSkill(SKILL_SHIELD) && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        return true;
+
+    if (bot->HasSkill(SKILL_PLATE_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_LEATHER))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+            return false;
+    }
+
+    if (proto->Quality <= ITEM_QUALITY_NORMAL)
+        return true;
+
+    uint8 sp = 0, ap = 0, tank = 0;
+    for (int j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
+    {
+        // for ItemStatValue != 0
+        if(!proto->ItemStat[j].ItemStatValue)
+            continue;
+
+        AddItemStats(proto->ItemStat[j].ItemStatType, sp, ap, tank);
+    }
+
+    return CheckItemStats(sp, ap, tank);
+}
+
+bool PlayerbotFactory::CheckItemStats(uint8 sp, uint8 ap, uint8 tank)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (!sp || ap > sp || tank > sp)
+            return false;
+        break;
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        if ((!ap && !tank) || sp > ap || sp > tank)
+            return false;
+        break;
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        if (!ap || sp > ap || sp > tank)
+            return false;
+        break;
+    }
+
+    return sp || ap || tank;
+}
+
+void PlayerbotFactory::AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank)
+{
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_MANA:
+    case ITEM_MOD_INTELLECT:
+    case ITEM_MOD_SPIRIT:
+    case ITEM_MOD_MANA_REGENERATION:
+    case ITEM_MOD_SPELL_POWER:
+    case ITEM_MOD_SPELL_PENETRATION:
+    case ITEM_MOD_HIT_SPELL_RATING:
+    case ITEM_MOD_CRIT_SPELL_RATING:
+    case ITEM_MOD_HASTE_SPELL_RATING:
+        sp++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_DEFENSE_SKILL_RATING:
+    case ITEM_MOD_DODGE_RATING:
+    case ITEM_MOD_PARRY_RATING:
+    case ITEM_MOD_BLOCK_RATING:
+    case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_HIT_TAKEN_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RATING:
+    case ITEM_MOD_RESILIENCE_RATING:
+    case ITEM_MOD_BLOCK_VALUE:
+        tank++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HIT_MELEE_RATING:
+    case ITEM_MOD_HIT_RANGED_RATING:
+    case ITEM_MOD_CRIT_MELEE_RATING:
+    case ITEM_MOD_CRIT_RANGED_RATING:
+    case ITEM_MOD_HASTE_MELEE_RATING:
+    case ITEM_MOD_HASTE_RANGED_RATING:
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_EXPERTISE_RATING:
+    case ITEM_MOD_ATTACK_POWER:
+    case ITEM_MOD_RANGED_ATTACK_POWER:
+    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+        ap++;
+        break;
+    }
+}
+
+bool PlayerbotFactory::CanEquipWeapon(ItemTemplate const* proto)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE)
+            return false;
+        break;
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_WARRIOR:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    case CLASS_PALADIN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_SHAMAN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_DRUID:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_HUNTER:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW)
+            return false;
+        break;
+    case CLASS_ROGUE:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    }
+
+    return true;
+}
+
+bool PlayerbotFactory::CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality)
+{
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (proto->Quality != desiredQuality)
+        return false;
+
+    if (proto->Bonding == BIND_QUEST_ITEM || proto->Bonding == BIND_WHEN_USE)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_CONTAINER)
+        return true;
+
+    uint32 requiredLevel = proto->RequiredLevel;
+    if (!requiredLevel)
+        return false;
+
+    uint32 level = bot->getLevel();
+    uint32 delta = 2;
+    if (level < 15)
+        delta = urand(7, 15);
+    else if (proto->Class == ITEM_CLASS_WEAPON || proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        delta = urand(2, 3);
+    else if (!(level % 10) || (level % 10) == 9)
+        delta = 2;
+    else if (level < 40)
+        delta = urand(5, 10);
+    else if (level < 60)
+        delta = urand(3, 7);
+    else if (level < 70)
+        delta = urand(2, 5);
+    else if (level < 80)
+        delta = urand(2, 4);
+
+    if (desiredQuality > ITEM_QUALITY_NORMAL &&
+            (requiredLevel > level || requiredLevel < level - delta))
+        return false;
+
+    for (uint32 gap = 60; gap <= 80; gap += 10)
+    {
+        if (level > gap && requiredLevel <= gap)
+            return false;
+    }
+
+    return true;
+}
+
+void PlayerbotFactory::InitEquipment(bool incremental)
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor, ITERATE_ALL_ITEMS);
+
+    map<uint8, vector<uint32> > items;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        uint32 desiredQuality = itemQuality;
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+            desiredQuality--;
+        }
+
+        do
+        {
+            for (uint32 itemId = 0; itemId < sItemStore.GetNumRows(); ++itemId)
+            {
+                ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+                if (!proto)
+                    continue;
+
+                if (proto->Class != ITEM_CLASS_WEAPON &&
+                    proto->Class != ITEM_CLASS_ARMOR &&
+                    proto->Class != ITEM_CLASS_CONTAINER &&
+                    proto->Class != ITEM_CLASS_PROJECTILE)
+                    continue;
+
+                if (!CanEquipItem(proto, desiredQuality))
+                    continue;
+
+                if (proto->Class == ITEM_CLASS_ARMOR && (
+                    slot == EQUIPMENT_SLOT_HEAD ||
+                    slot == EQUIPMENT_SLOT_SHOULDERS ||
+                    slot == EQUIPMENT_SLOT_CHEST ||
+                    slot == EQUIPMENT_SLOT_WAIST ||
+                    slot == EQUIPMENT_SLOT_LEGS ||
+                    slot == EQUIPMENT_SLOT_FEET ||
+                    slot == EQUIPMENT_SLOT_WRISTS ||
+                    slot == EQUIPMENT_SLOT_HANDS) && !CanEquipArmor(proto))
+                        continue;
+
+                if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+                    continue;
+
+                if (slot == EQUIPMENT_SLOT_OFFHAND && bot->getClass() == CLASS_ROGUE && proto->Class != ITEM_CLASS_WEAPON)
+                    continue;
+
+                uint16 dest = 0;
+                if (CanEquipUnseenItem(slot, dest, itemId))
+                    items[slot].push_back(itemId);
+            }
+        } while (items[slot].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+    }
+
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        vector<uint32>& ids = items[slot];
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to equip for slot %d", bot->GetName().c_str(), slot);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+            Item* oldItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+            if (incremental && !IsDesiredReplacement(oldItem)) {
+                continue;
+            }
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            if (oldItem)
+            {
+                bot->RemoveItem(INVENTORY_SLOT_BAG_0, slot, true);
+                oldItem->DestroyForPlayer(bot, false);
+            }
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                bot->AutoUnequipOffhandIfNeed();
+                EnchantItem(newItem);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotFactory::IsDesiredReplacement(Item* item)
+{
+    if (!item)
+        return true;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int delta = 1 + (80 - bot->getLevel()) / 10;
+    return (int)bot->getLevel() - (int)proto->RequiredLevel > delta;
+}
+
+void PlayerbotFactory::InitSecondEquipmentSet()
+{
+    if (bot->getClass() == CLASS_MAGE || bot->getClass() == CLASS_WARLOCK || bot->getClass() == CLASS_PRIEST)
+        return;
+
+    map<uint32, vector<uint32> > items;
+
+    uint32 desiredQuality = itemQuality;
+    while (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    do
+    {
+        for (uint32 itemId = 0; itemId < sItemStore.GetNumRows(); ++itemId)
+        {
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+            if (!proto)
+                continue;
+
+            if (!CanEquipItem(proto, desiredQuality))
+                continue;
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!CanEquipWeapon(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+                if (existingItem)
+                {
+                    switch (existingItem->GetTemplate()->SubClass)
+                    {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    default:
+                        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE && proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_FIST && proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    }
+                }
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (!CanEquipArmor(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                if (existingItem && existingItem->GetTemplate()->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    continue;
+            }
+            else
+                continue;
+
+            items[proto->Class].push_back(itemId);
+        }
+    } while (items[ITEM_CLASS_ARMOR].empty() && items[ITEM_CLASS_WEAPON].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+
+    for (map<uint32, vector<uint32> >::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        vector<uint32>& ids = i->second;
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to make second equipment set for slot %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            ItemPosCountVec sDest;
+            Item* newItem = StoreItem(newItemId, 1);
+            if (newItem)
+            {
+                EnchantItem(newItem);
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::InitBags()
+{
+    vector<uint32> ids;
+
+    for (uint32 itemId = 0; itemId < sItemStore.GetNumRows(); ++itemId)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto || proto->Class != ITEM_CLASS_CONTAINER)
+            continue;
+
+        if (!CanEquipItem(proto, ITEM_QUALITY_NORMAL))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: no bags found", bot->GetName().c_str());
+        return;
+    }
+
+    for (uint8 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::EnchantItem(Item* item)
+{
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance)
+        return;
+
+    if (bot->getLevel() < urand(40, 50))
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int32 itemLevel = proto->ItemLevel;
+
+    vector<uint32> ids;
+    for (int id = 0; id < sSpellStore.GetNumRows(); ++id)
+    {
+        SpellInfo const *entry = sSpellMgr->GetSpellInfo(id);
+        if (!entry)
+            continue;
+
+        int32 requiredLevel = (int32)entry->BaseLevel;
+        if (requiredLevel && (requiredLevel > itemLevel || requiredLevel < itemLevel - 35))
+            continue;
+
+        if (entry->MaxLevel && level > entry->MaxLevel)
+            continue;
+
+        uint32 spellLevel = entry->SpellLevel;
+        if (spellLevel && (spellLevel > level || spellLevel < level - 10))
+            continue;
+
+        for (int j = 0; j < 3; ++j)
+        {
+            if (entry->Effects[j].Effect != SPELL_EFFECT_ENCHANT_ITEM)
+                continue;
+
+            uint32 enchant_id = entry->Effects[j].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchant || enchant->slot != PERM_ENCHANTMENT_SLOT)
+                continue;
+
+            if (enchant->requiredLevel && enchant->requiredLevel > level)
+                continue;
+
+            uint8 sp = 0, ap = 0, tank = 0;
+            for (int i = 0; i < 3; ++i)
+            {
+                if (enchant->type[i] != ITEM_ENCHANTMENT_TYPE_STAT)
+                    continue;
+
+                AddItemStats(enchant->spellid[i], sp, ap, tank);
+            }
+
+            if (!CheckItemStats(sp, ap, tank))
+                continue;
+
+            if (enchant->EnchantmentCondition && !bot->EnchantmentFitsRequirements(enchant->EnchantmentCondition, -1))
+                continue;
+
+            if (!item->IsFitToSpellRequirements(entry))
+                continue;
+
+            ids.push_back(enchant_id);
+        }
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no enchantments found for item %d", bot->GetName().c_str(), item->GetTemplate()->ItemId);
+        return;
+    }
+
+    int index = urand(0, ids.size() - 1);
+    uint32 id = ids[index];
+
+    SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(id);
+    if (!enchant)
+        return;
+
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, id, 0, 0);
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+}
+
+bool PlayerbotFactory::CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item)
+{
+    dest = 0;
+    Item *pItem = Item::CreateItem(item, 1, bot);
+    if (pItem)
+    {
+        InventoryResult result = bot->CanEquipItem(slot, dest, pItem, true, false);
+        pItem->RemoveFromUpdateQueueOf(bot);
+        delete pItem;
+        return result == EQUIP_ERR_OK;
+    }
+
+    return false;
+}
+
+void PlayerbotFactory::InitTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+
+    vector<uint32> firstSkills;
+    vector<uint32> secondSkills;
+    switch (bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        firstSkills.push_back(SKILL_MINING);
+        secondSkills.push_back(SKILL_BLACKSMITHING);
+        secondSkills.push_back(SKILL_ENGINEERING);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_DRUID:
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        firstSkills.push_back(SKILL_SKINNING);
+        secondSkills.push_back(SKILL_LEATHERWORKING);
+        break;
+    default:
+        firstSkills.push_back(SKILL_TAILORING);
+        secondSkills.push_back(SKILL_ENCHANTING);
+    }
+
+    SetRandomSkill(SKILL_FIRST_AID);
+    SetRandomSkill(SKILL_FISHING);
+    SetRandomSkill(SKILL_COOKING);
+
+    switch (urand(0, 3))
+    {
+    case 0:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_ALCHEMY);
+        break;
+    case 1:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_INSCRIPTION);
+        break;
+    case 2:
+        SetRandomSkill(SKILL_MINING);
+        SetRandomSkill(SKILL_JEWELCRAFTING);
+        break;
+    case 3:
+        SetRandomSkill(firstSkills[urand(0, firstSkills.size() - 1)]);
+        SetRandomSkill(secondSkills[urand(0, secondSkills.size() - 1)]);
+        break;
+    }
+}
+
+void PlayerbotFactory::UpdateTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        if (bot->GetSkillValue(tradeSkills[i]) == 1)
+            bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+}
+
+void PlayerbotFactory::InitSkills()
+{
+    uint32 maxValue = level * 5;
+    SetRandomSkill(SKILL_DEFENSE);
+    SetRandomSkill(SKILL_SWORDS);
+    SetRandomSkill(SKILL_AXES);
+    SetRandomSkill(SKILL_BOWS);
+    SetRandomSkill(SKILL_GUNS);
+    SetRandomSkill(SKILL_MACES);
+    SetRandomSkill(SKILL_2H_SWORDS);
+    SetRandomSkill(SKILL_STAVES);
+    SetRandomSkill(SKILL_2H_MACES);
+    SetRandomSkill(SKILL_2H_AXES);
+    SetRandomSkill(SKILL_DAGGERS);
+    SetRandomSkill(SKILL_THROWN);
+    SetRandomSkill(SKILL_CROSSBOWS);
+    SetRandomSkill(SKILL_WANDS);
+    SetRandomSkill(SKILL_POLEARMS);
+    SetRandomSkill(SKILL_FIST_WEAPONS);
+
+    if (bot->getLevel() >= 70)
+        bot->SetSkill(SKILL_RIDING, 0, 300, 300);
+    else if (bot->getLevel() >= 60)
+        bot->SetSkill(SKILL_RIDING, 0, 225, 225);
+    else if (bot->getLevel() >= 40)
+        bot->SetSkill(SKILL_RIDING, 0, 150, 150);
+    else if (bot->getLevel() >= 20)
+        bot->SetSkill(SKILL_RIDING, 0, 75, 75);
+    else
+        bot->SetSkill(SKILL_RIDING, 0, 0, 0);
+
+    uint32 skillLevel = bot->getLevel() < 40 ? 0 : 1;
+    switch (bot->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        bot->SetSkill(SKILL_PLATE_MAIL, 0, skillLevel, skillLevel);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_HUNTER:
+        bot->SetSkill(SKILL_MAIL, 0, skillLevel, skillLevel);
+    }
+}
+
+void PlayerbotFactory::SetRandomSkill(uint16 id)
+{
+    uint32 maxValue = level * 5;
+    uint32 curValue = urand(maxValue - level, maxValue);
+    bot->SetSkill(id, 0, curValue, maxValue);
+
+}
+
+void PlayerbotFactory::InitAvailableSpells()
+{
+    bot->LearnDefaultSkills();
+
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.trainer_type != TRAINER_TYPE_TRADESKILLS && co.trainer_type != TRAINER_TYPE_CLASS)
+            continue;
+
+        if (co.trainer_type == TRAINER_TYPE_CLASS && co.trainer_class != bot->getClass())
+            continue;
+
+		uint32 trainerId = co.Entry;
+
+		TrainerSpellData const* trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+        if (!trainer_spells)
+            trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+
+        if (!trainer_spells)
+            continue;
+
+        for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+        {
+            TrainerSpell const* tSpell = &itr->second;
+
+            if (!tSpell)
+                continue;
+
+            if (!tSpell->learnedSpell[0] && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                continue;
+
+            TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+            if (state != TRAINER_SPELL_GREEN)
+                continue;
+
+            if (tSpell->learnedSpell)
+                bot->LearnSpell(tSpell->learnedSpell[0], false);
+            else
+                ai->CastSpell(tSpell->spell, bot);
+        }
+    }
+}
+
+void PlayerbotFactory::InitSpecialSpells()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotSpellIds.begin(); i != sPlayerbotAIConfig.randomBotSpellIds.end(); ++i)
+    {
+        uint32 spellId = *i;
+        bot->LearnSpell(spellId, false);
+    }
+}
+
+void PlayerbotFactory::InitTalents(uint32 specNo)
+{
+    uint32 classMask = bot->getClassMask();
+
+    map<uint32, vector<TalentEntry const*> > spells;
+    for (uint32 i = 0; i < sTalentStore.GetNumRows(); ++i)
+    {
+        TalentEntry const *talentInfo = sTalentStore.LookupEntry(i);
+        if(!talentInfo)
+            continue;
+
+        TalentTabEntry const *talentTabInfo = sTalentTabStore.LookupEntry( talentInfo->TalentTab );
+        if(!talentTabInfo || talentTabInfo->tabpage != specNo)
+            continue;
+
+        if( (classMask & talentTabInfo->ClassMask) == 0 )
+            continue;
+
+        spells[talentInfo->Row].push_back(talentInfo);
+    }
+
+    uint32 freePoints = bot->GetFreeTalentPoints();
+    for (map<uint32, vector<TalentEntry const*> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        vector<TalentEntry const*> &spells = i->second;
+        if (spells.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: No spells for talent row %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        int attemptCount = 0;
+        while (!spells.empty() && (int)freePoints - (int)bot->GetFreeTalentPoints() < 5 && attemptCount++ < 3 && bot->GetFreeTalentPoints())
+        {
+            int index = urand(0, spells.size() - 1);
+            TalentEntry const *talentInfo = spells[index];
+            int maxRank = 0;
+            for (int rank = 0; rank < min((uint32)MAX_TALENT_RANK, bot->GetFreeTalentPoints()); ++rank)
+            {
+                uint32 spellId = talentInfo->RankID[rank];
+                if (!spellId)
+                    continue;
+
+                maxRank = rank;
+            }
+
+            bot->LearnTalent(talentInfo->TalentID, maxRank);
+			spells.erase(spells.begin() + index);
+        }
+
+        freePoints = bot->GetFreeTalentPoints();
+    }
+
+    for (uint32 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        for (PlayerTalentMap::iterator itr = bot->GetTalentMap(i).begin(); itr != bot->GetTalentMap(i).end(); ++itr)
+        {
+            if (itr->second->state != PLAYERSPELL_REMOVED)
+                itr->second->state = PLAYERSPELL_CHANGED;
+        }
+    }
+}
+
+ObjectGuid PlayerbotFactory::GetRandomBot()
+{
+    vector<ObjectGuid> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, fields[0].GetUInt32());
+            if (!sObjectMgr->GetPlayerByLowGUID(guid))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+    if (guids.empty())
+        return ObjectGuid();
+
+    int index = urand(0, guids.size() - 1);
+    return guids[index];
+}
+
+void PlayerbotFactory::InitQuests()
+{
+    QueryResult results = WorldDatabase.PQuery("SELECT Id, RequiredClasses, RequiredRaces FROM quest_template where Level = -1 and MinLevel <= '%u'",
+            bot->getLevel());
+
+    list<uint32> ids;
+    do
+    {
+        Field* fields = results->Fetch();
+        uint32 questId = fields[0].GetUInt32();
+        uint16 requiredClasses = fields[1].GetUInt16();
+        uint16 requiredRaces = fields[2].GetUInt16();
+        if ((requiredClasses & bot->getClassMask()) && (requiredRaces & bot->getRaceMask()))
+            ids.push_back(questId);
+    } while (results->NextRow());
+
+    for (int i = 0; i < 15; i++)
+    {
+        for (list<uint32>::iterator i = ids.begin(); i != ids.end(); ++i)
+        {
+			uint32 questId = *i;
+            Quest const *quest = sObjectMgr->GetQuestTemplate(questId);
+
+            bot->SetQuestStatus(questId, QUEST_STATUS_NONE);
+
+            if (!bot->SatisfyQuestClass(quest, false) ||
+                    !bot->SatisfyQuestRace(quest, false) ||
+                    !bot->SatisfyQuestStatus(quest, false))
+                continue;
+
+            if (quest->IsDailyOrWeekly() || quest->IsRepeatable() || quest->IsMonthly())
+                continue;
+
+            bot->SetQuestStatus(questId, QUEST_STATUS_COMPLETE);
+            bot->RewardQuest(quest, 0, bot, false);
+            ClearInventory();
+        }
+    }
+}
+
+void PlayerbotFactory::ClearInventory()
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor);
+}
+
+void PlayerbotFactory::InitAmmo()
+{
+    if (bot->getClass() != CLASS_HUNTER && bot->getClass() != CLASS_ROGUE && bot->getClass() != CLASS_WARRIOR)
+        return;
+
+    Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+    if (!pItem)
+        return;
+
+    uint32 subClass = 0;
+    switch (pItem->GetTemplate()->SubClass)
+    {
+    case ITEM_SUBCLASS_WEAPON_GUN:
+        subClass = ITEM_SUBCLASS_BULLET;
+        break;
+    case ITEM_SUBCLASS_WEAPON_BOW:
+    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+        subClass = ITEM_SUBCLASS_ARROW;
+        break;
+    }
+
+    if (!subClass)
+        return;
+
+    QueryResult results = WorldDatabase.PQuery("select max(entry), max(RequiredLevel) from item_template where class = '%u' and subclass = '%u' and RequiredLevel <= '%u'",
+            ITEM_CLASS_PROJECTILE, subClass, bot->getLevel());
+
+    Field* fields = results->Fetch();
+    if (fields)
+    {
+        uint32 entry = fields[0].GetUInt32();
+        for (int i = 0; i < 5; i++)
+        {
+            bot->StoreNewItemInBestSlots(entry, 1000);
+        }
+        bot->SetAmmo(entry);
+    }
+}
+
+void PlayerbotFactory::InitMounts()
+{
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); ++spellId)
+    {
+        SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if (spellInfo->GetDuration() != -1)
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < 50)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    for (uint32 type = 0; type < 2; ++type)
+    {
+        map<int32, vector<uint32> >& spells = allSpells[type];
+        for (map<int32, vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+        {
+            int32 effect = i->first;
+            vector<uint32>& ids = i->second;
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            bot->LearnSpell(ids[index], false);
+        }
+    }
+}
+
+void PlayerbotFactory::InitPotions()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_POTION ||
+            proto->Spells[0].SpellCategory != 4 ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+        {
+            const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+            if (!spellInfo)
+                continue;
+
+            for (int i = 0 ; i < 3; i++)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_HEAL || spellInfo->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                {
+                    items[spellInfo->Effects[i].Effect].push_back(itemId);
+                    break;
+                }
+            }
+        }
+    }
+
+    uint32 effects[] = { SPELL_EFFECT_HEAL, SPELL_EFFECT_ENERGIZE };
+    for (int i = 0; i < sizeof(effects) / sizeof(uint32); ++i)
+    {
+        uint32 effect = effects[i];
+        vector<uint32>& ids = items[effect];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+void PlayerbotFactory::InitFood()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_FOOD ||
+            (proto->Spells[0].SpellCategory != 11 && proto->Spells[0].SpellCategory != 59) ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        items[proto->Spells[0].SpellCategory].push_back(itemId);
+    }
+
+    uint32 categories[] = { 11, 59 };
+    for (int i = 0; i < sizeof(categories) / sizeof(uint32); ++i)
+    {
+        uint32 category = categories[i];
+        vector<uint32>& ids = items[category];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+
+void PlayerbotFactory::CancelAuras()
+{
+    bot->RemoveAllAuras();
+}
+
+void PlayerbotFactory::InitInventory()
+{
+    InitInventoryTrade();
+    InitInventoryEquip();
+    InitInventorySkill();
+}
+
+void PlayerbotFactory::InitInventorySkill()
+{
+    if (bot->HasSkill(SKILL_MINING)) {
+        StoreItem(2901, 1); // Mining Pick
+    }
+    if (bot->HasSkill(SKILL_JEWELCRAFTING)) {
+        StoreItem(20815, 1); // Jeweler's Kit
+        StoreItem(20824, 1); // Simple Grinder
+    }
+    if (bot->HasSkill(SKILL_BLACKSMITHING) || bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(5956, 1); // Blacksmith Hammer
+    }
+    if (bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(6219, 1); // Arclight Spanner
+    }
+    if (bot->HasSkill(SKILL_ENCHANTING)) {
+        StoreItem(44452, 1); // Runed Titanium Rod
+    }
+    if (bot->HasSkill(SKILL_INSCRIPTION)) {
+        StoreItem(39505, 1); // Virtuoso Inking Set
+    }
+    if (bot->HasSkill(SKILL_SKINNING)) {
+        StoreItem(7005, 1); // Skinning Knife
+    }
+}
+
+Item* PlayerbotFactory::StoreItem(uint32 itemId, uint32 count)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    ItemPosCountVec sDest;
+    InventoryResult msg = bot->CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, itemId, count);
+    if (msg != EQUIP_ERR_OK)
+        return NULL;
+
+    return bot->StoreNewItem(sDest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+}
+
+void PlayerbotFactory::InitInventoryTrade()
+{
+    vector<uint32> ids;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_TRADE_GOODS || proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->ItemLevel < bot->getLevel())
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No trade items available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+        return;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    if (index >= ids.size())
+        return;
+
+    uint32 itemId = ids[index];
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    uint32 count = 1, stacks = 1;
+    switch (proto->Quality)
+    {
+    case ITEM_QUALITY_NORMAL:
+        count = proto->GetMaxStackSize();
+        stacks = urand(1, 7) / auctionbot.GetRarityPriceMultiplier(proto);
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        stacks = 1;
+        count = urand(1, proto->GetMaxStackSize());
+        break;
+    case ITEM_QUALITY_RARE:
+        stacks = 1;
+        count = urand(1, min(uint32(3), proto->GetMaxStackSize()));
+        break;
+    }
+
+    for (uint32 i = 0; i < stacks; i++)
+        StoreItem(itemId, count);
+}
+
+void PlayerbotFactory::InitInventoryEquip()
+{
+    vector<uint32> ids;
+
+    uint32 desiredQuality = itemQuality;
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_WEAPON || (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_WHEN_USE))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_ARMOR && !CanEquipArmor(proto))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+            continue;
+
+        if (!CanEquipItem(proto, desiredQuality))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    int maxCount = urand(0, 3);
+    int count = 0;
+    for (int attempts = 0; attempts < 15; attempts++)
+    {
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        if (StoreItem(itemId, 1) && count++ >= maxCount)
+            break;
+   }
+}
+
+void PlayerbotFactory::InitGlyphs()
+{
+    bot->InitGlyphsForLevel();
+
+    for (uint32 slotIndex = 0; slotIndex < MAX_GLYPH_SLOT_INDEX; ++slotIndex)
+    {
+        bot->SetGlyph(slotIndex, 0);
+    }
+
+    uint32 level = bot->getLevel();
+    uint32 maxSlot = 0;
+    if (level >= 15)
+        maxSlot = 2;
+    if (level >= 30)
+        maxSlot = 3;
+    if (level >= 50)
+        maxSlot = 4;
+    if (level >= 70)
+        maxSlot = 5;
+    if (level >= 80)
+        maxSlot = 6;
+
+    if (!maxSlot)
+        return;
+
+    list<uint32> glyphs;
+    for (uint32 itemId = 0; itemId < sItemStore.GetNumRows(); ++itemId)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_GLYPH)
+            continue;
+
+        if ((proto->AllowableClass & bot->getClassMask()) == 0 || (proto->AllowableRace & bot->getRaceMask()) == 0)
+            continue;
+
+        for (uint32 spell = 0; spell < MAX_ITEM_PROTO_SPELLS; spell++)
+        {
+            uint32 spellId = proto->Spells[spell].SpellId;
+            SpellInfo const *entry = sSpellMgr->GetSpellInfo(spellId);
+            if (!entry)
+                continue;
+
+            for (uint32 effect = 0; effect <= EFFECT_2; ++effect)
+            {
+                if (entry->Effects[effect].Effect != SPELL_EFFECT_APPLY_GLYPH)
+                    continue;
+
+                uint32 glyph = entry->Effects[effect].MiscValue;
+                glyphs.push_back(glyph);
+            }
+        }
+    }
+
+    if (glyphs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    set<uint32> chosen;
+    for (uint32 slotIndex = 0; slotIndex < maxSlot; ++slotIndex)
+    {
+        uint32 slot = bot->GetGlyphSlot(slotIndex);
+        GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(slot);
+        if (!gs)
+            continue;
+
+        vector<uint32> ids;
+        for (list<uint32>::iterator i = glyphs.begin(); i != glyphs.end(); ++i)
+        {
+            uint32 id = *i;
+            GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(id);
+            if (!gp || gp->TypeFlags != gs->TypeFlags)
+                continue;
+
+            ids.push_back(id);
+        }
+
+        int maxCount = urand(0, 3);
+        int count = 0;
+        bool found = false;
+        for (int attempts = 0; attempts < 15; ++attempts)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            uint32 id = ids[index];
+            if (chosen.find(id) != chosen.end())
+                continue;
+
+            chosen.insert(id);
+
+            bot->SetGlyph(slotIndex, id);
+            found = true;
+            break;
+        }
+        if (!found)
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s index %d slot %d", bot->GetName().c_str(), slotIndex, slot);
+    }
+}
diff --git a/src/plugins/playerbot/PlayerbotFactory.h b/src/plugins/playerbot/PlayerbotFactory.h
new file mode 100644
index 0000000..d4bc848
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.h
@@ -0,0 +1,67 @@
+#pragma once
+
+#include "strategy/actions/InventoryAction.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using ai::InventoryAction;
+
+class PlayerbotFactory : public InventoryAction
+{
+public:
+    PlayerbotFactory(Player* bot, uint32 level, uint32 itemQuality = 0) :
+        bot(bot), level(level), itemQuality(itemQuality), InventoryAction(bot->GetPlayerbotAI(), "factory") {}
+
+    static ObjectGuid GetRandomBot();
+    void CleanRandomize();
+    void Randomize();
+    void Refresh();
+
+private:
+    void Randomize(bool incremental);
+    void Prepare();
+    void InitSecondEquipmentSet();
+    void InitEquipment(bool incremental);
+    bool CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality);
+    bool CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item);
+    void InitSkills();
+    void InitTradeSkills();
+    void UpdateTradeSkills();
+    void SetRandomSkill(uint16 id);
+    void InitSpells();
+    void ClearSpells();
+    void InitAvailableSpells();
+    void InitSpecialSpells();
+    void InitTalents();
+    void InitTalents(uint32 specNo);
+    void InitQuests();
+    void InitPet();
+    void ClearInventory();
+    void InitAmmo();
+    void InitMounts();
+    void InitPotions();
+    void InitFood();
+    bool CanEquipArmor(ItemTemplate const* proto);
+    bool CanEquipWeapon(ItemTemplate const* proto);
+    void EnchantItem(Item* item);
+    void AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank);
+    bool CheckItemStats(uint8 sp, uint8 ap, uint8 tank);
+    void CancelAuras();
+    bool IsDesiredReplacement(Item* item);
+    void InitBags();
+    void InitInventory();
+    void InitInventoryTrade();
+    void InitInventoryEquip();
+    void InitInventorySkill();
+    Item* StoreItem(uint32 itemId, uint32 count);
+    void InitGlyphs();
+
+private:
+    Player* bot;
+    uint32 level;
+    uint32 itemQuality;
+    static uint32 tradeSkills[];
+};
diff --git a/src/plugins/playerbot/PlayerbotMgr.cpp b/src/plugins/playerbot/PlayerbotMgr.cpp
new file mode 100644
index 0000000..27932fc
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.cpp
@@ -0,0 +1,467 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "RandomPlayerbotMgr.h"
+
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+PlayerbotHolder::PlayerbotHolder() : PlayerbotAIBase()
+{
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+        sSpellStore.LookupEntry(spellId);
+}
+
+PlayerbotHolder::~PlayerbotHolder()
+{
+    LogoutAllBots();
+}
+
+
+void PlayerbotHolder::UpdateAIInternal(uint32 elapsed)
+{
+}
+
+void PlayerbotHolder::UpdateSessions(uint32 elapsed)
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* const bot = itr->second;
+        if (bot->IsBeingTeleported())
+        {
+            bot->GetPlayerbotAI()->HandleTeleportAck();
+        }
+        else if (bot->IsInWorld())
+        {
+            bot->GetSession()->HandleBotPackets();
+        }
+    }
+}
+
+void PlayerbotHolder::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot= itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+void PlayerbotHolder::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        bot->GetPlayerbotAI()->TellMaster("Goodbye!");
+        //bot->SaveToDB();
+
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+Player* PlayerbotHolder::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = playerBots.find(playerGuid);
+    return (it == playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotHolder::OnBotLogin(Player * const bot)
+{
+	PlayerbotAI* ai = new PlayerbotAI(bot);
+	bot->SetPlayerbotAI(ai);
+	OnBotLoginInternal(bot);
+
+    playerBots[bot->GetGUID()] = bot;
+
+    Player* master = ai->GetMaster();
+    if (master)
+    {
+        ObjectGuid masterGuid = master->GetGUID();
+        if (master->GetGroup() &&
+            ! master->GetGroup()->IsLeader(masterGuid))
+            master->GetGroup()->ChangeLeader(masterGuid);
+    }
+
+    Group *group = bot->GetGroup();
+    if (group)
+    {
+        bool groupValid = false;
+        Group::MemberSlotList const& slots = group->GetMemberSlots();
+        for (Group::MemberSlotList::const_iterator i = slots.begin(); i != slots.end(); ++i)
+        {
+            ObjectGuid member = i->guid;
+            uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(member);
+            if (!sPlayerbotAIConfig.IsInRandomAccountList(account))
+            {
+                groupValid = true;
+                break;
+            }
+        }
+
+        if (!groupValid)
+        {
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+        }
+    }
+
+    ai->ResetStrategies();
+    ai->TellMaster("Hello!");
+}
+
+bool PlayerbotHolder::ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId)
+{
+    if (!sPlayerbotAIConfig.enabled || guid.IsEmpty())
+        return false;
+
+    uint32 botAccount = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    bool isRandomBot = sRandomPlayerbotMgr.IsRandomBot(guid);
+    bool isRandomAccount = sPlayerbotAIConfig.IsInRandomAccountList(botAccount);
+    bool isMasterAccount = (masterAccountId == botAccount);
+
+    if (isRandomAccount && !isRandomBot && !admin)
+    {
+        Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (bot->GetGuildId() != masterGuildId)
+            return false;
+    }
+
+    if (!isRandomAccount && !isMasterAccount && !admin)
+        return false;
+
+    if (cmd == "add" || cmd == "login")
+    {
+        if (sObjectMgr->GetPlayerByLowGUID(guid))
+            return false;
+
+        AddPlayerBot(guid.GetRawValue(), masterAccountId);
+        return true;
+    }
+    else if (cmd == "remove" || cmd == "logout" || cmd == "rm")
+    {
+        if (!GetPlayerBot(guid.GetRawValue()))
+            return false;
+
+        LogoutPlayerBot(guid.GetRawValue());
+        return true;
+    }
+
+    if (admin)
+    {
+        Player* bot = GetPlayerBot(guid.GetRawValue());
+        if (!bot)
+            return false;
+
+        Player* master = bot->GetPlayerbotAI()->GetMaster();
+        if (master)
+        {
+            if (cmd == "init=white" || cmd == "init=common")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_NORMAL);
+                factory.CleanRandomize();
+                return true;
+            }
+            else if (cmd == "init=green" || cmd == "init=uncommon")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_UNCOMMON);
+                factory.CleanRandomize();
+                return true;
+            }
+            else if (cmd == "init=blue" || cmd == "init=rare")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_RARE);
+                factory.CleanRandomize();
+                return true;
+            }
+            else if (cmd == "init=epic" || cmd == "init=purple")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_EPIC);
+                factory.CleanRandomize();
+                return true;
+            }
+        }
+
+        if (cmd == "update")
+        {
+            PlayerbotFactory factory(bot, bot->getLevel());
+            factory.Refresh();
+            return true;
+        }
+        else if (cmd == "random")
+        {
+            sRandomPlayerbotMgr.Randomize(bot);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+bool PlayerbotMgr::HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args)
+{
+	if (!sPlayerbotAIConfig.enabled)
+	{
+		handler->PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+		handler->SetSentErrorMessage(true);
+        return false;
+	}
+
+    WorldSession *m_session = handler->GetSession();
+
+    if (!m_session)
+    {
+        handler->PSendSysMessage("You may only add bots from an active session");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    Player* player = m_session->GetPlayer();
+    PlayerbotMgr* mgr = player->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        handler->PSendSysMessage("you cannot control bots yet");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    list<string> messages = mgr->HandlePlayerbotCommand(args, player);
+    if (messages.empty())
+        return true;
+
+    for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+    {
+        handler->PSendSysMessage(i->c_str());
+    }
+
+    handler->SetSentErrorMessage(true);
+    return false;
+}
+
+list<string> PlayerbotHolder::HandlePlayerbotCommand(char const* args, Player* master)
+{
+    list<string> messages;
+
+    if (!*args)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    set<string> bots;
+    if (charnameStr == "*" && master)
+    {
+        Group* group = master->GetGroup();
+        if (!group)
+        {
+            messages.push_back("you must be in group");
+            return messages;
+        }
+
+        Group::MemberSlotList slots = group->GetMemberSlots();
+        for (Group::member_citerator i = slots.begin(); i != slots.end(); i++)
+        {
+			ObjectGuid member = i->guid;
+
+			if (member == master->GetGUID())
+				continue;
+
+			string bot;
+			if (sObjectMgr->GetPlayerNameByGUID(member, bot))
+			    bots.insert(bot);
+        }
+    }
+
+    if (charnameStr == "!" && master && master->GetSession()->GetSecurity() > SEC_GAMEMASTER)
+    {
+        for (PlayerBotMap::const_iterator i = GetPlayerBotsBegin(); i != GetPlayerBotsEnd(); ++i)
+        {
+            Player* bot = i->second;
+            if (bot && bot->IsInWorld())
+                bots.insert(bot->GetName());
+        }
+    }
+
+    vector<string> chars = split(charnameStr, ',');
+    for (vector<string>::iterator i = chars.begin(); i != chars.end(); i++)
+    {
+        string s = *i;
+
+        uint32 accountId = GetAccountId(s);
+        if (!accountId)
+        {
+            bots.insert(s);
+            continue;
+        }
+
+        QueryResult results = CharacterDatabase.PQuery(
+            "SELECT name FROM characters WHERE account = '%u'",
+            accountId);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                string charName = fields[0].GetString();
+                bots.insert(charName);
+            } while (results->NextRow());
+        }
+	}
+
+    for (set<string>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        string bot = *i;
+        ostringstream out;
+        out << cmdStr << ": " << bot << " - ";
+
+        ObjectGuid member = sObjectMgr->GetPlayerGUIDByName(bot);
+        bool result = false;
+        if (master && member != master->GetGUID())
+        {
+            result = ProcessBotCommand(cmdStr, member,
+                    master->GetSession()->GetSecurity() >= SEC_GAMEMASTER,
+                    master->GetSession()->GetAccountId(),
+                    master->GetGuildId());
+        }
+        else if (!master)
+        {
+            result = ProcessBotCommand(cmdStr, member, true, -1, -1);
+        }
+
+        out << (result ? "ok" : "not allowed");
+        messages.push_back(out.str());
+    }
+
+    return messages;
+}
+
+uint32 PlayerbotHolder::GetAccountId(string name)
+{
+    uint32 accountId = 0;
+
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account WHERE username = '%s'", name.c_str());
+    if(results)
+    {
+        Field* fields = results->Fetch();
+        accountId = fields[0].GetUInt32();
+    }
+
+    return accountId;
+}
+
+
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : PlayerbotHolder(),  master(master)
+{
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+}
+
+void PlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.reactDelay);
+}
+
+void PlayerbotMgr::HandleCommand(uint32 type, const string& text)
+{
+    Player *master = GetMaster();
+    if (!master)
+        return;
+
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == master)
+            bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    switch (packet.GetOpcode())
+    {
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+    }
+}
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+}
+
+void PlayerbotMgr::SaveToDB()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->SaveToDB();
+    }
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->SaveToDB();
+    }
+}
+
+void PlayerbotMgr::OnBotLoginInternal(Player * const bot)
+{
+    bot->GetPlayerbotAI()->SetMaster(master);
+    bot->GetPlayerbotAI()->ResetStrategies();
+}
+
diff --git a/src/plugins/playerbot/PlayerbotMgr.h b/src/plugins/playerbot/PlayerbotMgr.h
new file mode 100644
index 0000000..c53cadd
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "../pchdef.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+typedef map<uint64, Player*> PlayerBotMap;
+
+class PlayerbotHolder : public PlayerbotAIBase
+{
+public:
+    PlayerbotHolder();
+    virtual ~PlayerbotHolder();
+
+    void AddPlayerBot(uint64 guid, uint32 masterAccountId);
+    void LogoutPlayerBot(uint64 guid);
+    Player* GetPlayerBot (uint64 guid) const;
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return playerBots.end();   }
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+    void UpdateSessions(uint32 elapsed);
+
+    void LogoutAllBots();
+    void OnBotLogin(Player * const bot);
+
+    list<string> HandlePlayerbotCommand(char const* args, Player* master = NULL);
+    bool ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId);
+    uint32 GetAccountId(string name);
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot) = 0;
+
+protected:
+    PlayerBotMap playerBots;
+};
+
+class PlayerbotMgr : public PlayerbotHolder
+{
+public:
+    PlayerbotMgr(Player* const master);
+    virtual ~PlayerbotMgr();
+
+    static bool HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+    void HandleCommand(uint32 type, const string& text);
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+
+    Player* GetMaster() const { return master; };
+
+    void SaveToDB();
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot);
+
+private:
+    Player* const master;
+};
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotSecurity.cpp b/src/plugins/playerbot/PlayerbotSecurity.cpp
new file mode 100644
index 0000000..4752731
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.cpp
@@ -0,0 +1,187 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "ChatHelper.h"
+
+PlayerbotSecurity::PlayerbotSecurity(Player* const bot) : bot(bot)
+{
+    if (bot)
+        account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+}
+
+PlayerbotSecurityLevel PlayerbotSecurity::LevelFor(Player* from, DenyReason* reason, bool ignoreGroup)
+{
+    if (from->GetSession()->GetSecurity() >= SEC_GAMEMASTER)
+        return PLAYERBOT_SECURITY_ALLOW_ALL;
+
+    if (from->GetPlayerbotAI())
+    {
+        if (reason) *reason = PLAYERBOT_DENY_IS_BOT;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (bot->GetPlayerbotAI()->IsOpposing(from))
+    {
+        if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account))
+    {
+        if (bot->GetPlayerbotAI()->IsOpposing(from))
+        {
+            if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+            return PLAYERBOT_SECURITY_DENY_ALL;
+        }
+
+        Group* group = from->GetGroup();
+        if (group)
+        {
+            for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+            {
+                Player* player = gref->GetSource();
+                if (player == bot && !ignoreGroup)
+                    return PLAYERBOT_SECURITY_ALLOW_ALL;
+            }
+        }
+
+        if ((int)bot->getLevel() - (int)from->getLevel() > 5)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_LOW_LEVEL;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->GetMapId() != from->GetMapId() || bot->GetDistance(from) > sPlayerbotAIConfig.whisperDistance)
+        {
+            if (!bot->GetGuildId() || bot->GetGuildId() != from->GetGuildId())
+            {
+                if (reason) *reason = PLAYERBOT_DENY_FAR;
+                return PLAYERBOT_SECURITY_TALK;
+            }
+        }
+
+        int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+        int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+        if (botGS && bot->getLevel() > 15 && (100 * (botGS - fromGS) / botGS) >= 20)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_GEARSCORE;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->isDead())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_DEAD;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        group = bot->GetGroup();
+        if (!group)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_INVITE;
+            return PLAYERBOT_SECURITY_INVITE;
+        }
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* player = gref->GetSource();
+            if (player == from)
+                return PLAYERBOT_SECURITY_ALLOW_ALL;
+        }
+
+        if (group->IsFull())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_FULL_GROUP;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (reason) *reason = PLAYERBOT_DENY_INVITE;
+        return PLAYERBOT_SECURITY_INVITE;
+    }
+
+    return PLAYERBOT_SECURITY_ALLOW_ALL;
+}
+
+bool PlayerbotSecurity::CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup)
+{
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel realLevel = LevelFor(from, &reason, ignoreGroup);
+    if (realLevel >= level)
+        return true;
+
+    if (silent || from->GetPlayerbotAI())
+        return false;
+
+    Player* master = bot->GetPlayerbotAI()->GetMaster();
+    if (master && bot->GetPlayerbotAI() && bot->GetPlayerbotAI()->IsOpposing(master) && master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+        return false;
+
+    ostringstream out;
+    switch (realLevel)
+    {
+    case PLAYERBOT_SECURITY_DENY_ALL:
+        out << "I'm kind of busy now";
+        break;
+    case PLAYERBOT_SECURITY_TALK:
+        switch (reason)
+        {
+        case PLAYERBOT_DENY_NONE:
+            out << "I'll do it later";
+            break;
+        case PLAYERBOT_DENY_LOW_LEVEL:
+            out << "You are too low level: |cffff0000" << (uint32)from->getLevel() << "|cffffffff/|cff00ff00" << (uint32)bot->getLevel();
+            break;
+        case PLAYERBOT_DENY_GEARSCORE:
+            {
+                int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+                int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+                out << "Your gearscore is too low: |cffff0000" << fromGS << "|cffffffff/|cff00ff00" << botGS;
+            }
+            break;
+        case PLAYERBOT_DENY_NOT_YOURS:
+            out << "I have a master already";
+            break;
+        case PLAYERBOT_DENY_IS_BOT:
+            out << "You are a bot";
+            break;
+        case PLAYERBOT_DENY_OPPOSING:
+            out << "You are the enemy";
+            break;
+        case PLAYERBOT_DENY_DEAD:
+            out << "I'm dead. Will do it later";
+            break;
+        case PLAYERBOT_DENY_INVITE:
+            out << "Invite me to your group first";
+            break;
+        case PLAYERBOT_DENY_FAR:
+            {
+                out << "I am too far away";
+
+                uint32 area = bot->GetAreaId();
+                if (area)
+                {
+                    const AreaTableEntry* entry = sAreaStore.LookupEntry(area);
+                    if (entry)
+                    {
+                        out << " |cffffffff(|cffff0000" << entry->area_name[0] << "|cffffffff)";
+                    }
+                }
+            }
+            break;
+        case PLAYERBOT_DENY_FULL_GROUP:
+            out << "I am in a full group. Will do it later";
+            break;
+        default:
+            out << "I can't do that";
+            break;
+        }
+        break;
+    case PLAYERBOT_SECURITY_INVITE:
+        out << "Invite me to your group first";
+        break;
+    }
+
+	bot->Whisper(out.str(), LANG_UNIVERSAL, from);
+    return false;
+}
diff --git a/src/plugins/playerbot/PlayerbotSecurity.h b/src/plugins/playerbot/PlayerbotSecurity.h
new file mode 100644
index 0000000..5349555
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.h
@@ -0,0 +1,42 @@
+#ifndef _PlayerbotSecurity_H
+#define _PlayerbotSecurity_H
+
+using namespace std;
+
+enum PlayerbotSecurityLevel
+{
+    PLAYERBOT_SECURITY_DENY_ALL = 0,
+    PLAYERBOT_SECURITY_TALK = 1,
+    PLAYERBOT_SECURITY_INVITE = 2,
+    PLAYERBOT_SECURITY_ALLOW_ALL = 3
+};
+
+enum DenyReason
+{
+    PLAYERBOT_DENY_NONE,
+    PLAYERBOT_DENY_LOW_LEVEL,
+    PLAYERBOT_DENY_GEARSCORE,
+    PLAYERBOT_DENY_NOT_YOURS,
+    PLAYERBOT_DENY_IS_BOT,
+    PLAYERBOT_DENY_OPPOSING,
+    PLAYERBOT_DENY_DEAD,
+    PLAYERBOT_DENY_FAR,
+    PLAYERBOT_DENY_INVITE,
+    PLAYERBOT_DENY_FULL_GROUP
+};
+
+class PlayerbotSecurity
+{
+    public:
+        PlayerbotSecurity(Player* const bot);
+
+	public:
+        PlayerbotSecurityLevel LevelFor(Player* from, DenyReason* reason = NULL, bool ignoreGroup = false);
+        bool CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup = false);
+
+    private:
+        Player* const bot;
+        uint32 account;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.cpp b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
new file mode 100644
index 0000000..870535b
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
@@ -0,0 +1,147 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../shared/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "../Entities/Player/Player.h"
+#include "RandomPlayerbotFactory.h"
+#include "SystemConfig.h"
+
+map<uint8, vector<uint8> > RandomPlayerbotFactory::availableRaces;
+
+RandomPlayerbotFactory::RandomPlayerbotFactory(uint32 accountId) : accountId(accountId)
+{
+    availableRaces[CLASS_WARRIOR].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DWARF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_ORC);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TAUREN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TROLL);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DRAENEI);
+
+    availableRaces[CLASS_PALADIN].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DWARF);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PALADIN].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_ROGUE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_ROGUE].push_back(RACE_DWARF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_GNOME);
+    availableRaces[CLASS_ROGUE].push_back(RACE_ORC);
+    availableRaces[CLASS_ROGUE].push_back(RACE_TROLL);
+    availableRaces[CLASS_ROGUE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_PRIEST].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DWARF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PRIEST].push_back(RACE_TROLL);
+    availableRaces[CLASS_PRIEST].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_PRIEST].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_MAGE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_MAGE].push_back(RACE_GNOME);
+    availableRaces[CLASS_MAGE].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_MAGE].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_MAGE].push_back(RACE_TROLL);
+    availableRaces[CLASS_MAGE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_WARLOCK].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_ORC);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_SHAMAN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_ORC);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TAUREN);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TROLL);
+
+    availableRaces[CLASS_HUNTER].push_back(RACE_DWARF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_HUNTER].push_back(RACE_ORC);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TAUREN);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TROLL);
+    availableRaces[CLASS_HUNTER].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_DRUID].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_DRUID].push_back(RACE_TAUREN);
+}
+
+bool RandomPlayerbotFactory::CreateRandomBot(uint8 cls)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Creating new random bot for class %d", cls);
+
+    uint8 gender = rand() % 2 ? GENDER_MALE : GENDER_FEMALE;
+
+    uint8 race = availableRaces[cls][urand(0, availableRaces[cls].size() - 1)];
+    string name = CreateRandomBotName();
+    if (name.empty())
+        return false;
+
+    uint8 skin = urand(0, 7);
+    uint8 face = urand(0, 7);
+    uint8 hairStyle = urand(0, 7);
+    uint8 hairColor = urand(0, 7);
+    uint8 facialHair = urand(0, 7);
+    uint8 outfitId = 0;
+
+    WorldSession* session = new WorldSession(accountId, NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+    if (!session)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Couldn't create session for random bot account %d", accountId);
+        delete session;
+        return false;
+    }
+
+    Player *player = new Player(session);
+    WorldPacket data;
+    CharacterCreateInfo cci(name, race, cls, gender, skin, face, hairStyle,hairColor, facialHair, outfitId, data);
+    if (!player->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_PLAYER), &cci))
+    {
+        player->DeleteFromDB(player->GetGUID(), accountId, true, true);
+        delete session;
+        delete player;
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Unable to create random bot for account %d - name: \"%s\"; race: %u; class: %u; gender: %u; skin: %u; face: %u; hairStyle: %u; hairColor: %u; facialHair: %u; outfitId: %u",
+                accountId, name.c_str(), race, cls, gender, skin, face, hairStyle, hairColor, facialHair, outfitId);
+        return false;
+    }
+
+    player->setCinematic(2);
+    player->SetAtLoginFlag(AT_LOGIN_NONE);
+    player->SaveToDB(true);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot created for account %d - name: \"%s\"; race: %u; class: %u; gender: %u; skin: %u; face: %u; hairStyle: %u; hairColor: %u; facialHair: %u; outfitId: %u",
+            accountId, name.c_str(), race, cls, gender, skin, face, hairStyle, hairColor, facialHair, outfitId);
+
+    return true;
+}
+
+string RandomPlayerbotFactory::CreateRandomBotName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_names");
+    if (!result)
+        return "";
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_names n "
+            "LEFT OUTER JOIN characters e ON e.name = n.name "
+            "WHERE e.guid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random bots");
+        return "";
+    }
+
+	fields = result->Fetch();
+    return fields[0].GetString();
+}
+
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.h b/src/plugins/playerbot/RandomPlayerbotFactory.h
new file mode 100644
index 0000000..29ef8ce
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.h
@@ -0,0 +1,32 @@
+#ifndef _RandomPlayerbotFactory_H
+#define _RandomPlayerbotFactory_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotFactory
+{
+    public:
+        RandomPlayerbotFactory(uint32 accountId);
+		virtual ~RandomPlayerbotFactory() {}
+
+	public:
+        bool CreateRandomBot(uint8 cls);
+
+	private:
+        string CreateRandomBotName();
+
+    private:
+        uint32 accountId;
+        static map<uint8, vector<uint8> > availableRaces;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.cpp b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
new file mode 100644
index 0000000..6115463
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
@@ -0,0 +1,839 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../shared/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "AiFactory.h"
+#include "../../game/Maps/MapManager.h"
+
+RandomPlayerbotMgr::RandomPlayerbotMgr() : PlayerbotHolder(), processTicks(0)
+{
+}
+
+RandomPlayerbotMgr::~RandomPlayerbotMgr()
+{
+}
+
+void RandomPlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.randomBotUpdateInterval * 1000);
+
+    if (!sPlayerbotAIConfig.randomBotAutologin || !sPlayerbotAIConfig.enabled)
+        return;
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Processing random bots...");
+
+    int maxAllowedBotCount = GetEventValue(0, "bot_count");
+    if (!maxAllowedBotCount)
+    {
+        maxAllowedBotCount = urand(sPlayerbotAIConfig.minRandomBots, sPlayerbotAIConfig.maxRandomBots);
+        SetEventValue(0, "bot_count", maxAllowedBotCount,
+                urand(sPlayerbotAIConfig.randomBotCountChangeMinInterval, sPlayerbotAIConfig.randomBotCountChangeMaxInterval));
+    }
+
+    list<uint32> bots = GetBots();
+    int botCount = bots.size();
+    int allianceNewBots = 0, hordeNewBots = 0;
+    int randomBotsPerInterval = (int)urand(sPlayerbotAIConfig.minRandomBotsPerInterval, sPlayerbotAIConfig.maxRandomBotsPerInterval);
+    if (!processTicks)
+    {
+        if (sPlayerbotAIConfig.randomBotLoginAtStartup)
+            randomBotsPerInterval = bots.size();
+    }
+
+    while (botCount++ < maxAllowedBotCount)
+    {
+        bool alliance = botCount % 2;
+        uint32 bot = AddRandomBot(alliance);
+        if (bot)
+        {
+            if (alliance)
+                allianceNewBots++;
+            else
+                hordeNewBots++;
+
+            bots.push_back(bot);
+        }
+        else
+            break;
+    }
+
+    int botProcessed = 0;
+    for (list<uint32>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        uint32 bot = *i;
+        if (ProcessBot(bot))
+            botProcessed++;
+
+        if (botProcessed >= randomBotsPerInterval)
+            break;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d bots processed. %d alliance and %d horde bots added. %d bots online. Next check in %d seconds",
+            botProcessed, allianceNewBots, hordeNewBots, playerBots.size(), sPlayerbotAIConfig.randomBotUpdateInterval);
+
+    if (processTicks++ == 1)
+        PrintStats();
+}
+
+uint32 RandomPlayerbotMgr::AddRandomBot(bool alliance)
+{
+    vector<uint32> bots = GetFreeBots(alliance);
+    if (bots.size() == 0)
+        return 0;
+
+    int index = urand(0, bots.size() - 1);
+    uint32 bot = bots[index];
+    SetEventValue(bot, "add", 1, urand(sPlayerbotAIConfig.minRandomBotInWorldTime, sPlayerbotAIConfig.maxRandomBotInWorldTime));
+    uint32 randomTime = 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3);
+    ScheduleRandomize(bot, randomTime);
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot %d added", bot);
+    return bot;
+}
+
+void RandomPlayerbotMgr::ScheduleRandomize(uint32 bot, uint32 time)
+{
+    SetEventValue(bot, "randomize", 1, time);
+    SetEventValue(bot, "logout", 1, time + 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+void RandomPlayerbotMgr::ScheduleTeleport(uint32 bot)
+{
+    SetEventValue(bot, "teleport", 1, 60 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+bool RandomPlayerbotMgr::ProcessBot(uint32 bot)
+{
+    uint32 isValid = GetEventValue(bot, "add");
+    if (!isValid)
+    {
+		Player* player = GetPlayerBot(bot);
+		if (!player || !player->GetGroup())
+		{
+			sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d expired", bot);
+			SetEventValue(bot, "add", 0, 0);
+		}
+        return true;
+    }
+
+    if (!GetPlayerBot(bot))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d logged in", bot);
+        AddPlayerBot(bot, 0);
+        if (!GetEventValue(bot, "online"))
+        {
+            SetEventValue(bot, "online", 1, sPlayerbotAIConfig.minRandomBotInWorldTime);
+        }
+        return true;
+    }
+
+    Player* player = GetPlayerBot(bot);
+    if (!player)
+        return false;
+
+    PlayerbotAI* ai = player->GetPlayerbotAI();
+    if (!ai)
+        return false;
+
+    if (player->GetGroup())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Skipping bot %d as it is in group", bot);
+        return false;
+    }
+
+    if (player->isDead())
+    {
+        if (!GetEventValue(bot, "dead"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Setting dead flag for bot %d", bot);
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotReviveTime, sPlayerbotAIConfig.maxRandomBotReviveTime);
+            SetEventValue(bot, "dead", 1, randomTime);
+            SetEventValue(bot, "revive", 1, randomTime - 60);
+            return false;
+        }
+
+        if (!GetEventValue(bot, "revive"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Reviving dead bot %d", bot);
+            SetEventValue(bot, "dead", 0, 0);
+            SetEventValue(bot, "revive", 0, 0);
+            RandomTeleport(player, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+            return true;
+        }
+
+        return false;
+    }
+
+    uint32 randomize = GetEventValue(bot, "randomize");
+    if (!randomize)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %d", bot);
+        Randomize(player);
+        uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+        ScheduleRandomize(bot, randomTime);
+        return true;
+    }
+
+    uint32 logout = GetEventValue(bot, "logout");
+    if (!logout)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Logging out bot %d", bot);
+        LogoutPlayerBot(bot);
+        SetEventValue(bot, "logout", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    uint32 teleport = GetEventValue(bot, "teleport");
+    if (!teleport)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %d", bot);
+        RandomTeleportForLevel(ai->GetBot());
+        SetEventValue(bot, "teleport", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, vector<WorldLocation> &locs)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (locs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+        return;
+    }
+
+    for (int attemtps = 0; attemtps < 10; ++attemtps)
+    {
+        int index = urand(0, locs.size() - 1);
+        WorldLocation loc = locs[index];
+        float x = loc.m_positionX + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float y = loc.m_positionY + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float z = loc.m_positionZ;
+
+        Map* map = sMapMgr->FindMap(loc.GetMapId(), 0);
+        if (!map)
+            continue;
+
+        if (!map->IsOutdoors(x, y, z) ||
+                map->IsInWater(x, y, z))
+            continue;
+
+        uint32 areaId = map->GetAreaId(x, y, z);
+        if (!areaId)
+            continue;
+
+        AreaTableEntry const* area = sAreaStore.LookupEntry(areaId);
+        if (!area)
+            continue;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s to %s %f,%f,%f", bot->GetName().c_str(), area->area_name[0], x, y, z);
+        float height = map->GetWaterOrGroundLevel(x, y, 0.05f + z);
+        if (height == INVALID_HEIGHT)
+            continue;
+
+        z = 0.05f + height;
+
+        bot->GetMotionMaster()->Clear();
+        bot->TeleportTo(loc.GetMapId(), x, y, z, 0);
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+}
+
+void RandomPlayerbotMgr::RandomTeleportForLevel(Player* bot)
+{
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select map, position_x, position_y, position_z "
+        "from (select map, position_x, position_y, position_z, avg(t.maxlevel), avg(t.minlevel), "
+        "(avg(t.maxlevel) + avg(t.minlevel)) / 2 - %u delta "
+        "from creature c inner join creature_template t on c.id = t.entry group by t.entry) q "
+        "where delta >= 0 and delta <= 1 and map in (%s)",
+        bot->getLevel(), sPlayerbotAIConfig.randomBotMapsAsString.c_str());
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint16 mapId = fields[0].GetUInt16();
+            float x = fields[1].GetFloat();
+            float y = fields[2].GetFloat();
+            float z = fields[3].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select position_x, position_y, position_z from creature where map = '%u' and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            float x = fields[0].GetFloat();
+            float y = fields[1].GetFloat();
+            float z = fields[2].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+    Refresh(bot);
+}
+
+void RandomPlayerbotMgr::Randomize(Player* bot)
+{
+    if (bot->getLevel() == 1)
+        RandomizeFirst(bot);
+    else
+        IncreaseLevel(bot);
+}
+
+void RandomPlayerbotMgr::IncreaseLevel(Player* bot)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    uint32 level = min((uint32)(bot->getLevel() + 1), maxLevel);
+    PlayerbotFactory factory(bot, level);
+    if (bot->GetGuildId())
+        factory.Refresh();
+    else
+        factory.Randomize();
+    RandomTeleportForLevel(bot);
+}
+
+void RandomPlayerbotMgr::RandomizeFirst(Player* bot)
+{
+    uint32 maxLevel = sPlayerbotAIConfig.randomBotMaxLevel;
+    if (maxLevel > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+    for (int attempt = 0; attempt < 100; ++attempt)
+    {
+        int index = urand(0, sPlayerbotAIConfig.randomBotMaps.size() - 1);
+        uint16 mapId = sPlayerbotAIConfig.randomBotMaps[index];
+
+        vector<GameTele const*> locs;
+        GameTeleContainer const & teleMap = sObjectMgr->GetGameTeleMap();
+        for(GameTeleContainer::const_iterator itr = teleMap.begin(); itr != teleMap.end(); ++itr)
+        {
+            GameTele const* tele = &itr->second;
+            if (tele->mapId == mapId)
+                locs.push_back(tele);
+        }
+
+        index = urand(0, locs.size() - 1);
+        GameTele const* tele = locs[index];
+        uint32 level = GetZoneLevel(tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        if (level > maxLevel + 5)
+            continue;
+
+        level = min(level, maxLevel);
+        if (!level) level = 1;
+
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomBotMaxLevelChance)
+            level = maxLevel;
+
+        if (level < sPlayerbotAIConfig.randomBotMinLevel)
+            continue;
+
+        PlayerbotFactory factory(bot, level);
+        factory.CleanRandomize();
+        RandomTeleport(bot, tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        break;
+    }
+}
+
+uint32 RandomPlayerbotMgr::GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+	uint32 level;
+    QueryResult results = WorldDatabase.PQuery("select avg(t.minlevel) minlevel, avg(t.maxlevel) maxlevel from creature c "
+            "inner join creature_template t on c.id = t.entry "
+            "where map = '%u' and minlevel > 1 and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint8 minLevel = fields[0].GetUInt8();
+        uint8 maxLevel = fields[1].GetUInt8();
+        level = urand(minLevel, maxLevel);
+        if (level > maxLevel)
+            level = maxLevel;
+    }
+    else
+    {
+        level = urand(1, maxLevel);
+    }
+
+    return level;
+}
+
+void RandomPlayerbotMgr::Refresh(Player* bot)
+{
+    if (bot->isDead())
+    {
+        bot->ResurrectPlayer(1.0f);
+        bot->SpawnCorpseBones();
+        bot->SaveToDB();
+        bot->GetPlayerbotAI()->ResetStrategies();
+    }
+
+    bot->GetPlayerbotAI()->Reset();
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        unit->RemoveAllAttackers();
+        unit->ClearInCombat();
+
+        ref = ref->next();
+    }
+
+    bot->RemoveAllAttackers();
+    bot->ClearInCombat();
+
+    bot->DurabilityRepairAll(false, 1.0f, false);
+    bot->SetFullHealth();
+    bot->SetPvP(true);
+
+    if (bot->GetMaxPower(POWER_MANA) > 0)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA));
+
+    if (bot->GetMaxPower(POWER_ENERGY) > 0)
+        bot->SetPower(POWER_ENERGY, bot->GetMaxPower(POWER_ENERGY));
+}
+
+
+bool RandomPlayerbotMgr::IsRandomBot(Player* bot)
+{
+    return IsRandomBot(bot->GetGUID());
+}
+
+bool RandomPlayerbotMgr::IsRandomBot(uint32 bot)
+{
+    return GetEventValue(bot, "add");
+}
+
+list<uint32> RandomPlayerbotMgr::GetBots()
+{
+    list<uint32> bots;
+
+    QueryResult results = CharacterDatabase.Query(
+            "select bot from ai_playerbot_random_bots where owner = 0 and event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.push_back(bot);
+        } while (results->NextRow());
+    }
+
+    return bots;
+}
+
+vector<uint32> RandomPlayerbotMgr::GetFreeBots(bool alliance)
+{
+    set<uint32> bots;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `bot` from ai_playerbot_random_bots where event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.insert(bot);
+        } while (results->NextRow());
+    }
+
+    vector<uint32> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            if (bots.find(guid) == bots.end() &&
+                    ((alliance && IsAlliance(race)) || ((!alliance && !IsAlliance(race))
+            )))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+
+    return guids;
+}
+
+uint32 RandomPlayerbotMgr::GetEventValue(uint32 bot, string event)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+uint32 RandomPlayerbotMgr::SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_random_bots (owner, bot, `time`, validIn, event, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                0, bot, (uint32)time(0), validIn, event.c_str(), value);
+    }
+
+    return value;
+}
+
+bool RandomPlayerbotMgr::HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Playerbot system is currently disabled!");
+        return false;
+    }
+
+    if (!args || !*args)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Usage: rndbot stats/update/reset/init/refresh/add/remove");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bots were reset for all players");
+        return true;
+    }
+    else if (cmd == "stats")
+    {
+        sRandomPlayerbotMgr.PrintStats();
+        return true;
+    }
+    else if (cmd == "update")
+    {
+        sRandomPlayerbotMgr.UpdateAIInternal(0);
+        return true;
+    }
+    else if (cmd == "init" || cmd == "refresh" || cmd == "teleport")
+    {
+		sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bots for %d accounts", sPlayerbotAIConfig.randomBotAccounts.size());
+        for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); ++i)
+        {
+            uint32 account = *i;
+            if (QueryResult results = CharacterDatabase.PQuery("SELECT guid FROM characters where account = '%u'", account))
+            {
+                do
+                {
+                    Field* fields = results->Fetch();
+                    ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, fields[0].GetUInt32());
+                    Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+                    if (!bot)
+                        continue;
+
+                    if (cmd == "init")
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %s for account %u", bot->GetName().c_str(), account);
+                        sRandomPlayerbotMgr.RandomizeFirst(bot);
+                    }
+                    else if (cmd == "teleport")
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s for account %u", bot->GetName().c_str(), account);
+                        sRandomPlayerbotMgr.RandomTeleportForLevel(bot);
+                    }
+                    else
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Refreshing bot %s for account %u", bot->GetName().c_str(), account);
+                        bot->SetLevel(bot->getLevel() - 1);
+                        sRandomPlayerbotMgr.IncreaseLevel(bot);
+                    }
+                    uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+                    CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'randomize' and bot = '%u'",
+                            randomTime, bot->GetGUIDLow());
+                    CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'logout' and bot = '%u'",
+                            sPlayerbotAIConfig.maxRandomBotInWorldTime, bot->GetGUIDLow());
+                } while (results->NextRow());
+            }
+        }
+        return true;
+    }
+    else
+    {
+        list<string> messages = sRandomPlayerbotMgr.HandlePlayerbotCommand(args, NULL);
+        for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, i->c_str());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, fromPlayer);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogout(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        PlayerbotAI* ai = bot->GetPlayerbotAI();
+        if (player == ai->GetMaster())
+        {
+            ai->SetMaster(NULL);
+            ai->ResetStrategies();
+        }
+    }
+
+    if (!player->GetPlayerbotAI())
+    {
+        vector<Player*>::iterator i = find(players.begin(), players.end(), player);
+        if (i != players.end())
+            players.erase(i);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogin(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (player == bot || player->GetPlayerbotAI())
+            continue;
+
+        Group* group = bot->GetGroup();
+        if (!group)
+            continue;
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member == player && (!ai->GetMaster() || ai->GetMaster()->GetPlayerbotAI()))
+            {
+                ai->SetMaster(player);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+
+    if (!player->GetPlayerbotAI())
+        players.push_back(player);
+}
+
+Player* RandomPlayerbotMgr::GetRandomPlayer()
+{
+    if (players.empty())
+        return NULL;
+
+    uint32 index = urand(0, players.size() - 1);
+    return players[index];
+}
+
+void RandomPlayerbotMgr::PrintStats()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d Random Bots online", playerBots.size());
+
+    map<uint32, int> alliance, horde;
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        alliance[i] = 0;
+        horde[i] = 0;
+    }
+
+    map<uint8, int> perRace, perClass;
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        perRace[race] = 0;
+    }
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        perClass[cls] = 0;
+    }
+
+    int dps = 0, heal = 0, tank = 0;
+    for (PlayerBotMap::iterator i = playerBots.begin(); i != playerBots.end(); ++i)
+    {
+        Player* bot = i->second;
+        if (IsAlliance(bot->getRace()))
+            alliance[bot->getLevel() / 10]++;
+        else
+            horde[bot->getLevel() / 10]++;
+
+        perRace[bot->getRace()]++;
+        perClass[bot->getClass()]++;
+
+        int spec = AiFactory::GetPlayerSpecTab(bot);
+        switch (bot->getClass())
+        {
+        case CLASS_DRUID:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PALADIN:
+            if (spec == 1)
+                tank++;
+            else if (spec == 0)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PRIEST:
+            if (spec != 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_SHAMAN:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_WARRIOR:
+            if (spec == 2)
+                tank++;
+            else
+                dps++;
+            break;
+        default:
+            dps++;
+            break;
+        }
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per level:");
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        if (!alliance[i] && !horde[i])
+            continue;
+
+        uint32 from = i*10;
+        uint32 to = min(from + 9, maxLevel);
+        if (!from) from = 1;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %d..%d: %d alliance, %d horde", from, to, alliance[i], horde[i]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per race:");
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        if (perRace[race])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatRace(race).c_str(), perRace[race]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per class:");
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        if (perClass[cls])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatClass(cls).c_str(), perClass[cls]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per role:");
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    tank: %d", tank);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    heal: %d", heal);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    dps: %d", dps);
+}
+
+double RandomPlayerbotMgr::GetBuyMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "buymultiplier");
+    if (!value)
+    {
+        value = urand(1, 120);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "buymultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+double RandomPlayerbotMgr::GetSellMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "sellmultiplier");
+    if (!value)
+    {
+        value = urand(80, 250);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "sellmultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+uint32 RandomPlayerbotMgr::GetLootAmount(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    return GetEventValue(id, "lootamount");
+}
+
+void RandomPlayerbotMgr::SetLootAmount(Player* bot, uint32 value)
+{
+    uint32 id = bot->GetGUID();
+    SetEventValue(id, "lootamount", value, 24 * 3600);
+}
+
+uint32 RandomPlayerbotMgr::GetTradeDiscount(Player* bot)
+{
+    Group* group = bot->GetGroup();
+    return GetLootAmount(bot) / (group ? group->GetMembersCount() : 10);
+}
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.h b/src/plugins/playerbot/RandomPlayerbotMgr.h
new file mode 100644
index 0000000..ac1f5f7
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.h
@@ -0,0 +1,72 @@
+#ifndef _RandomPlayerbotMgr_H
+#define _RandomPlayerbotMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotMgr : public PlayerbotHolder
+{
+    public:
+        RandomPlayerbotMgr();
+        virtual ~RandomPlayerbotMgr();
+        static RandomPlayerbotMgr& instance()
+        {
+            static RandomPlayerbotMgr instance;
+            return instance;
+        }
+
+        virtual void UpdateAIInternal(uint32 elapsed);
+
+	public:
+        static bool HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsRandomBot(Player* bot);
+        bool IsRandomBot(uint32 bot);
+        void Randomize(Player* bot);
+        void RandomizeFirst(Player* bot);
+        void IncreaseLevel(Player* bot);
+        void ScheduleTeleport(uint32 bot);
+        void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+        void OnPlayerLogout(Player* player);
+        void OnPlayerLogin(Player* player);
+        Player* GetRandomPlayer();
+        void PrintStats();
+        double GetBuyMultiplier(Player* bot);
+        double GetSellMultiplier(Player* bot);
+        uint32 GetLootAmount(Player* bot);
+        void SetLootAmount(Player* bot, uint32 value);
+        uint32 GetTradeDiscount(Player* bot);
+        void Refresh(Player* bot);
+        void RandomTeleportForLevel(Player* bot);
+
+	protected:
+	    virtual void OnBotLoginInternal(Player * const bot) {}
+
+    private:
+        uint32 GetEventValue(uint32 bot, string event);
+        uint32 SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn);
+        list<uint32> GetBots();
+        vector<uint32> GetFreeBots(bool alliance);
+        uint32 AddRandomBot(bool alliance);
+        bool ProcessBot(uint32 bot);
+        void ScheduleRandomize(uint32 bot, uint32 time);
+        void RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ);
+        void RandomTeleport(Player* bot, vector<WorldLocation> &locs);
+        uint32 GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ);
+
+    private:
+        vector<Player*> players;
+        int processTicks;
+};
+
+#define sRandomPlayerbotMgr RandomPlayerbotMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/aiplayerbot.conf.dist.in b/src/plugins/playerbot/aiplayerbot.conf.dist.in
new file mode 100644
index 0000000..070674d
--- /dev/null
+++ b/src/plugins/playerbot/aiplayerbot.conf.dist.in
@@ -0,0 +1,159 @@
+##########################################
+# MANGOS Ai Playerbot Configuration file #
+##########################################
+
+[AiPlayerbotConf]
+ConfVersion=2010102201
+
+# Enable or disable AI Playerbot
+AiPlayerbot.Enabled = 1
+
+# Warrior
+AiPlayerbot.RandomClassSpecProbability.1.0 = 20
+AiPlayerbot.RandomClassSpecProbability.1.1 = 30
+AiPlayerbot.RandomClassSpecProbability.1.2 = 50
+# Paladin
+AiPlayerbot.RandomClassSpecProbability.2.0 = 20
+AiPlayerbot.RandomClassSpecProbability.2.1 = 50
+AiPlayerbot.RandomClassSpecProbability.2.2 = 30
+# Hunter
+AiPlayerbot.RandomClassSpecProbability.3.0 = 25
+AiPlayerbot.RandomClassSpecProbability.3.1 = 50
+AiPlayerbot.RandomClassSpecProbability.3.2 = 25
+# Rogue
+AiPlayerbot.RandomClassSpecProbability.4.0 = 40
+AiPlayerbot.RandomClassSpecProbability.4.1 = 50
+AiPlayerbot.RandomClassSpecProbability.4.2 = 10
+# Priest
+AiPlayerbot.RandomClassSpecProbability.5.0 = 40
+AiPlayerbot.RandomClassSpecProbability.5.1 = 40
+AiPlayerbot.RandomClassSpecProbability.5.2 = 20
+# Shaman
+AiPlayerbot.RandomClassSpecProbability.7.0 = 10
+AiPlayerbot.RandomClassSpecProbability.7.1 = 45
+AiPlayerbot.RandomClassSpecProbability.7.2 = 45
+# Mage
+AiPlayerbot.RandomClassSpecProbability.8.0 = 20
+AiPlayerbot.RandomClassSpecProbability.8.1 = 10
+AiPlayerbot.RandomClassSpecProbability.8.2 = 70
+# Warlock
+AiPlayerbot.RandomClassSpecProbability.9.0 = 33
+AiPlayerbot.RandomClassSpecProbability.9.1 = 33
+AiPlayerbot.RandomClassSpecProbability.9.2 = 33
+# Druid
+AiPlayerbot.RandomClassSpecProbability.11.0 = 10
+AiPlayerbot.RandomClassSpecProbability.11.1 = 45
+AiPlayerbot.RandomClassSpecProbability.11.2 = 45
+
+#
+# All other parameters are optional but can be changed by uncommenting them here
+#
+
+# Prefix for bot chat commands (e.g. follow, stay)
+AiPlayerbot.CommandPrefix =
+
+# Max AI iterations per tick
+#AiPlayerbot.IterationsPerTick = 10
+
+# Allow/deny bots from your guild
+#AiPlayerbot.AllowGuildBots = 1
+
+# Delay between two short-time spells cast
+#AiPlayerbot.GlobalCooldown = 500
+
+# Max wait time when moving
+#AiPlayerbot.MaxWaitForMove = 5000
+
+# Delay between two bot actions
+#AiPlayerbot.ReactDelay = 100
+
+# Distances
+#AiPlayerbot.SightDistance = 75.0
+#AiPlayerbot.SpellDistance = 30.0
+#AiPlayerbot.ReactDistance = 150.0
+#AiPlayerbot.GrindDistance = 100.0
+#AiPlayerbot.LootDistance = 20.0
+#AiPlayerbot.FleeDistance = 20.0
+#AiPlayerbot.TooCloseDistance = 7.0
+#AiPlayerbot.MeleeDistance = 1.0
+#AiPlayerbot.FollowDistance = 1.5
+#AiPlayerbot.WhisperDistance = 6000.0
+#AiPlayerbot.ContactDistance = 0.5
+
+# Bot can flee for enemy
+#AiPlayerbot.FleeingEnabled = 1
+
+# Health/Mana levels
+#AiPlayerbot.CriticalHealth = 25
+#AiPlayerbot.LowHealth = 45
+#AiPlayerbot.MediumHealth = 65
+#AiPlayerbot.AlmostFullHealth = 85
+#AiPlayerbot.LowMana = 15
+#AiPlayerbot.MediumMana = 40
+
+# Enable random bot system
+#AiPlayerbot.RandomBotAutologin = 1
+
+# Random bot default strategies (applied after defaults)
+#AiPlayerbot.RandomBotCombatStrategies = +dps,+attack weak
+#AiPlayerbot.RandomBotNonCombatStrategies = +grind,+move random,+loot
+
+# Create random bot characters automatically
+#AiPlayerbot.RandomBotAutoCreate = 1
+
+# Random bot count
+#AiPlayerbot.MinRandomBots = 50
+#AiPlayerbot.MaxRandomBots = 200
+#AiPlayerbot.RandomBotMinLevel = 1
+#AiPlayerbot.RandomBotMaxLevel = 255 (ignored if more than MaxPlayerLevel mangosd.conf value)
+
+# Accounts to create for random bots
+#AiPlayerbot.RandomBotAccountPrefix = rndbot
+#AiPlayerbot.RandomBotAccountCount = 50
+
+# Delete all random bot accounts
+#AiPlayerbot.DeleteRandomBotAccounts = 0
+
+# Maps to teleport random bots
+#AiPlayerbot.RandomBotMaps = 0,1,530,571
+
+# Change random bot has lower gear
+#AiPlayerbot.RandomGearLoweringChance = 0.15
+
+# Chance random bot has max level on first randomize
+#AiPlayerbot.RandomBotMaxLevelChance = 0.4
+
+# Quest items to leave (do not destroy)
+#AiPlayerbot.RandomBotQuestItems = 6948,5175,5176,5177,5178
+
+# Spells every random bot will learn on randomize (54197 - cold weather flying)
+#AiPlayerbot.RandomBotSpellIds = 54197
+
+# Enable LFG for random bots
+#AiPlayerbot.RandomBotJoinLfg = 1
+
+# Intervals
+#AiPlayerbot.RandomBotUpdateInterval = 60
+#AiPlayerbot.RandomBotCountChangeMinInterval = 86400
+#AiPlayerbot.RandomBotCountChangeMaxInterval = 259200
+#AiPlayerbot.MinRandomBotInWorldTime = 7200
+#AiPlayerbot.MaxRandomBotInWorldTime = 1209600
+#AiPlayerbot.MinRandomBotRandomizeTime = 7200
+#AiPlayerbot.MaxRandomRandomizeTime = 1209600
+#AiPlayerbot.MinRandomBotsPerInterval = 50
+#AiPlayerbot.MaxRandomBotsPerInterval = 100
+#AiPlayerbot.MinRandomBotsPriceChangeInterval = 7200
+#AiPlayerbot.MaxRandomBotsPriceChangeInterval = 172800
+
+# Log on all random bots on start
+#AiPlayerbot.RandomBotLoginAtStartup = 1
+
+# How far random bots are teleported after death
+#AiPlayerbot.RandomBotTeleportDistance = 1000
+
+# Debug switches
+#AiPlayerbot.SpellDump = 0
+#AiPlayerbot.LogInGroupOnly = 1
+#AiPlayerbot.LogValuesPerTick = 0
+#AiPlayerbot.RandomChangeMultiplier = 1
+
diff --git a/src/plugins/playerbot/playerbot.h b/src/plugins/playerbot/playerbot.h
new file mode 100644
index 0000000..a22cc30
--- /dev/null
+++ b/src/plugins/playerbot/playerbot.h
@@ -0,0 +1,31 @@
+#pragma once
+
+std::vector<std::string> split(const std::string &s, char delim);
+#ifndef WIN32
+int strcmpi(std::string s1, std::string s2);
+#endif
+
+#include "../Spell.h"
+#include "../../shared/Packets/WorldPacket.h"
+#include "../Loot/LootMgr.h"
+#include "../Entities/Creature/GossipDef.h"
+#include "../Chat/Chat.h"
+#include "../../shared/Common.h"
+#include "../World/World.h"
+#include "../Spells/SpellMgr.h"
+#include "../Globals/ObjectMgr.h"
+#include "../Entities/Unit/Unit.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../Movement/MotionMaster.h"
+#include "../Spells/Auras/SpellAuras.h"
+#include "../Guilds/Guild.h"
+#include "../Groups/Group.h"
+#include "../../game/Accounts/AccountMgr.h"
+#include "../../game/Globals/ObjectMgr.h"
+
+#include "playerbotDefs.h"
+#include "PlayerbotAIAware.h"
+#include "PlayerbotMgr.h"
+#include "RandomPlayerbotMgr.h"
+#include "ChatHelper.h"
+#include "PlayerbotAI.h"
diff --git a/src/plugins/playerbot/playerbotDefs.h b/src/plugins/playerbot/playerbotDefs.h
new file mode 100644
index 0000000..3f59c93
--- /dev/null
+++ b/src/plugins/playerbot/playerbotDefs.h
@@ -0,0 +1,2 @@
+#pragma once
+
diff --git a/src/plugins/playerbot/strategy/Action.cpp b/src/plugins/playerbot/strategy/Action.cpp
new file mode 100644
index 0000000..75e3301
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.cpp
@@ -0,0 +1,93 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "Action.h"
+
+using namespace ai;
+
+int NextAction::size(NextAction** actions)
+{
+    if (!actions)
+        return 0;
+
+    int size;
+    for (size=0; size<10 && actions[size]; ) 
+        size++;
+    return size;
+}
+
+NextAction** NextAction::clone(NextAction** actions)
+{
+    if (!actions)
+        return NULL;
+
+    int size = NextAction::size(actions);
+
+    NextAction** res = new NextAction*[size + 1];
+    for (int i=0; i<size; i++)
+        res[i] = new NextAction(*actions[i]);
+    res[size] = NULL;
+    return res;
+}
+
+NextAction** NextAction::merge(NextAction** left, NextAction** right)
+{
+    int leftSize = NextAction::size(left);
+    int rightSize = NextAction::size(right);
+
+    NextAction** res = new NextAction*[leftSize + rightSize + 1];
+    for (int i=0; i<leftSize; i++)
+        res[i] = new NextAction(*left[i]);
+    for (int i=0; i<rightSize; i++)
+        res[leftSize + i] = new NextAction(*right[i]);
+    res[leftSize + rightSize] = NULL;
+
+    NextAction::destroy(left);
+    NextAction::destroy(right);
+
+    return res;
+}
+
+NextAction** NextAction::array(uint8 nil, ...)
+{
+    va_list vl;
+    va_start(vl, nil);
+    
+    int size = 0;
+    NextAction* cur = NULL;
+    do 
+    {
+        cur = va_arg(vl, NextAction*);
+        size++;
+    }
+    while (cur);
+
+    va_end(vl);
+
+    NextAction** res = new NextAction*[size];
+    va_start(vl, nil);
+    for (int i=0; i<size; i++)
+        res[i] = va_arg(vl, NextAction*);
+    va_end(vl);
+
+    return res;
+}
+
+void NextAction::destroy(NextAction** actions)
+{
+    if (!actions)
+        return;
+
+    for (int i=0; i<10 && actions[i]; i++)
+        delete actions[i];
+}
+
+Value<Unit*>* Action::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Action::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Action.h b/src/plugins/playerbot/strategy/Action.h
new file mode 100644
index 0000000..b8d2a1c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.h
@@ -0,0 +1,138 @@
+#pragma once
+#include "Event.h"
+#include "Value.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class NextAction
+    {
+    public:
+        NextAction(string name, float relevance = 0.0f)
+        {
+            this->name = name;
+            this->relevance = relevance;
+        }
+        NextAction(const NextAction& o)
+        {
+            this->name = o.name;
+            this->relevance = o.relevance;
+        }
+
+    public:
+        string getName() { return name; }
+        float getRelevance() {return relevance;}
+
+    public:
+        static int size(NextAction** actions);
+        static NextAction** clone(NextAction** actions);
+        static NextAction** merge(NextAction** what, NextAction** with);
+        static NextAction** array(uint8 nil,...);
+        static void destroy(NextAction** actions);
+
+    private:
+        float relevance;
+        std::string name;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class ActionBasket;
+
+    enum ActionThreatType
+    {
+        ACTION_THREAT_NONE = 0,
+        ACTION_THREAT_SINGLE= 1,
+        ACTION_THREAT_AOE = 2
+    };
+
+    class Action : public AiNamedObject
+	{
+	public:
+        Action(PlayerbotAI* ai, string name = "action") : verbose(false), AiNamedObject(ai, name) { }
+        virtual ~Action(void) {}
+
+    public:
+        virtual bool Execute(Event event) { return true; }
+        virtual bool isPossible() { return true; }
+        virtual bool isUseful() { return true; }
+        virtual NextAction** getPrerequisites() { return NULL; }
+        virtual NextAction** getAlternatives() { return NULL; }
+        virtual NextAction** getContinuers() { return NULL; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+        void Update() {}
+        void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+        void MakeVerbose() { verbose = true; }
+
+    protected:
+        bool verbose;
+	};
+
+    class ActionNode
+    {
+    public:
+        ActionNode(string name, NextAction** prerequisites = NULL, NextAction** alternatives = NULL, NextAction** continuers = NULL)
+        {
+            this->action = NULL;
+            this->name = name;
+            this->prerequisites = prerequisites;
+            this->alternatives = alternatives;
+            this->continuers = continuers;
+        }
+        virtual ~ActionNode()
+        {
+            NextAction::destroy(prerequisites);
+            NextAction::destroy(alternatives);
+            NextAction::destroy(continuers);
+        }
+
+    public:
+        Action* getAction() { return action; }
+        void setAction(Action* action) { this->action = action; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getContinuers() { return NextAction::merge(NextAction::clone(continuers), action->getContinuers()); }
+        NextAction** getAlternatives() { return NextAction::merge(NextAction::clone(alternatives), action->getAlternatives()); }
+        NextAction** getPrerequisites() { return NextAction::merge(NextAction::clone(prerequisites), action->getPrerequisites()); }
+
+    private:
+        string name;
+        Action* action;
+        NextAction** continuers;
+        NextAction** alternatives;
+        NextAction** prerequisites;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+	class ActionBasket
+	{
+	public:
+        ActionBasket(ActionNode* action, float relevance, bool skipPrerequisites, Event event) :
+          action(action), relevance(relevance), skipPrerequisites(skipPrerequisites), event(event) {}
+        virtual ~ActionBasket(void) {}
+	public:
+		float getRelevance() {return relevance;}
+		ActionNode* getAction() {return action;}
+        Event getEvent() { return event; }
+        bool isSkipPrerequisites() { return skipPrerequisites; }
+        void AmendRelevance(float k) {relevance *= k; }
+        void setRelevance(float relevance) { this->relevance = relevance; }
+	private:
+		ActionNode* action;
+		float relevance;
+        bool skipPrerequisites;
+        Event event;
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+
+}
+
+#define AI_VALUE(type, name) context->GetValue<type>(name)->Get()
+#define AI_VALUE2(type, name, param) context->GetValue<type>(name, param)->Get()
diff --git a/src/plugins/playerbot/strategy/ActionBasket.cpp b/src/plugins/playerbot/strategy/ActionBasket.cpp
new file mode 100644
index 0000000..ef8e4b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.cpp
@@ -0,0 +1,4 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "ActionBasket.h"
+
diff --git a/src/plugins/playerbot/strategy/ActionBasket.h b/src/plugins/playerbot/strategy/ActionBasket.h
new file mode 100644
index 0000000..d85293b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.h
@@ -0,0 +1,5 @@
+#pragma once
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/AiObject.cpp b/src/plugins/playerbot/strategy/AiObject.cpp
new file mode 100644
index 0000000..3b807e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.cpp
@@ -0,0 +1,16 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObject.h"
+
+AiObject::AiObject(PlayerbotAI* ai) :
+    PlayerbotAIAware(ai),
+    bot(ai->GetBot()),
+    context(ai->GetAiObjectContext()),
+    chat(ai->GetChatHelper())
+{
+}
+
+Player* AiObject::GetMaster()
+{
+    return ai->GetMaster();
+}
diff --git a/src/plugins/playerbot/strategy/AiObject.h b/src/plugins/playerbot/strategy/AiObject.h
new file mode 100644
index 0000000..0b4f214
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.h
@@ -0,0 +1,33 @@
+#pragma once
+
+class PlayerbotAI;
+
+namespace ai
+{
+    class AiObjectContext;
+    class ChatHelper;
+
+    class AiObject : public PlayerbotAIAware
+	{
+	public:
+        AiObject(PlayerbotAI* ai);
+
+    protected:
+        Player* bot;
+        Player* GetMaster();
+        AiObjectContext* context;
+        ChatHelper* chat;
+	};
+
+    class AiNamedObject : public AiObject
+    {
+    public:
+        AiNamedObject(PlayerbotAI* ai, string name) : AiObject(ai), name(name) {}
+
+    public:
+        virtual string getName() { return name; }
+
+    protected:
+        string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.cpp b/src/plugins/playerbot/strategy/AiObjectContext.cpp
new file mode 100644
index 0000000..3c75542
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.cpp
@@ -0,0 +1,48 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "NamedObjectContext.h"
+#include "StrategyContext.h"
+#include "triggers/TriggerContext.h"
+#include "actions/ActionContext.h"
+#include "triggers/ChatTriggerContext.h"
+#include "actions/ChatActionContext.h"
+#include "triggers/WorldPacketTriggerContext.h"
+#include "actions/WorldPacketActionContext.h"
+#include "values/ValueContext.h"
+
+using namespace ai;
+
+AiObjectContext::AiObjectContext(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    strategyContexts.Add(new StrategyContext());
+    strategyContexts.Add(new MovementStrategyContext());
+    strategyContexts.Add(new AssistStrategyContext());
+    strategyContexts.Add(new QuestStrategyContext());
+
+    actionContexts.Add(new ActionContext());
+    actionContexts.Add(new ChatActionContext());
+    actionContexts.Add(new WorldPacketActionContext());
+
+    triggerContexts.Add(new TriggerContext());
+    triggerContexts.Add(new ChatTriggerContext());
+    triggerContexts.Add(new WorldPacketTriggerContext());
+
+    valueContexts.Add(new ValueContext());
+}
+
+void AiObjectContext::Update()
+{
+    strategyContexts.Update();
+    triggerContexts.Update();
+    actionContexts.Update();
+    valueContexts.Update();
+}
+
+void AiObjectContext::Reset()
+{
+    strategyContexts.Reset();
+    triggerContexts.Reset();
+    actionContexts.Reset();
+    valueContexts.Reset();
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.h b/src/plugins/playerbot/strategy/AiObjectContext.h
new file mode 100644
index 0000000..f9313bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include "../PlayerbotAIAware.h"
+#include "Action.h"
+#include "Value.h"
+#include "NamedObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class AiObjectContext : public PlayerbotAIAware
+    {
+    public:
+        AiObjectContext(PlayerbotAI* ai);
+        virtual ~AiObjectContext() {}
+
+    public:
+        virtual Strategy* GetStrategy(string name) { return strategyContexts.GetObject(name, ai); }
+        virtual set<string> GetSiblingStrategy(string name) { return strategyContexts.GetSiblings(name); }
+        virtual Trigger* GetTrigger(string name) { return triggerContexts.GetObject(name, ai); }
+        virtual Action* GetAction(string name) { return actionContexts.GetObject(name, ai); }
+        virtual UntypedValue* GetUntypedValue(string name) { return valueContexts.GetObject(name, ai); }
+
+        template<class T>
+        Value<T>* GetValue(string name)
+        {
+            return dynamic_cast<Value<T>*>(GetUntypedValue(name));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, string param)
+        {
+            return GetValue<T>((string(name) + "::" + param));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, uint32 param)
+        {
+        	ostringstream out; out << param;
+            return GetValue<T>(name, out.str());
+        }
+
+        set<string> GetSupportedStrategies()
+        {
+            return strategyContexts.supports();
+        }
+
+        string FormatValues()
+        {
+            ostringstream out;
+            set<string> names = valueContexts.GetCreated();
+            for (set<string>::iterator i = names.begin(); i != names.end(); ++i)
+            {
+                UntypedValue* value = GetUntypedValue(*i);
+                if (!value)
+                    continue;
+
+                string text = value->Format();
+                if (text == "?")
+                    continue;
+
+                out << "{" << *i << "=" << text << "} ";
+            }
+            return out.str();
+        }
+
+    public:
+        virtual void Update();
+        virtual void Reset();
+        virtual void AddShared(NamedObjectContext<UntypedValue>* sharedValues)
+        {
+            valueContexts.Add(sharedValues);
+        }
+
+    protected:
+        NamedObjectContextList<Strategy> strategyContexts;
+        NamedObjectContextList<Action> actionContexts;
+        NamedObjectContextList<Trigger> triggerContexts;
+        NamedObjectContextList<UntypedValue> valueContexts;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Engine.cpp b/src/plugins/playerbot/strategy/Engine.cpp
new file mode 100644
index 0000000..7c6df69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.cpp
@@ -0,0 +1,522 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+
+#include "Engine.h"
+#include "../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Engine::Engine(PlayerbotAI* ai, AiObjectContext *factory) : PlayerbotAIAware(ai), aiObjectContext(factory)
+{
+    lastRelevance = 0.0f;
+    testMode = false;
+}
+
+bool ActionExecutionListeners::Before(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->Before(action, event);
+    }
+    return result;
+}
+
+void ActionExecutionListeners::After(Action* action, bool executed, Event event)
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        (*i)->After(action, executed, event);
+    }
+}
+
+bool ActionExecutionListeners::OverrideResult(Action* action, bool executed, Event event)
+{
+    bool result = executed;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result = (*i)->OverrideResult(action, result, event);
+    }
+    return result;
+}
+
+bool ActionExecutionListeners::AllowExecution(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->AllowExecution(action, event);
+    }
+    return result;
+}
+
+ActionExecutionListeners::~ActionExecutionListeners()
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        delete *i;
+    }
+    listeners.clear();
+}
+
+
+Engine::~Engine(void)
+{
+    Reset();
+
+    strategies.clear();
+}
+
+void Engine::Reset()
+{
+    ActionNode* action = NULL;
+    do
+    {
+        action = queue.Pop();
+    } while (action);
+
+    triggers.clear();
+
+    for (list<Multiplier*>::iterator i = multipliers.begin(); i != multipliers.end(); i++)
+    {
+        Multiplier* multiplier = *i;
+        delete multiplier;
+    }
+    multipliers.clear();
+}
+
+void Engine::Init()
+{
+    Reset();
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        strategy->InitMultipliers(multipliers);
+        strategy->InitTriggers(triggers);
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+
+	if (testMode)
+	{
+        FILE* file = fopen("test.log", "w");
+        fprintf(file, "\n");
+        fclose(file);
+	}
+}
+
+
+bool Engine::DoNextAction(Unit* unit, int depth)
+{
+    LogAction("--- AI Tick ---");
+    if (sPlayerbotAIConfig.logValuesPerTick)
+        LogValues();
+
+    bool actionExecuted = false;
+    ActionBasket* basket = NULL;
+
+    time_t currentTime = time(0);
+    aiObjectContext->Update();
+    ProcessTriggers();
+
+    int iterations = 0;
+    int iterationsPerTick = queue.Size() * sPlayerbotAIConfig.iterationsPerTick;
+    do {
+        basket = queue.Peek();
+        if (basket) {
+            if (++iterations > iterationsPerTick)
+                break;
+
+            float relevance = basket->getRelevance(); // just for reference
+            bool skipPrerequisites = basket->isSkipPrerequisites();
+            Event event = basket->getEvent();
+            // NOTE: queue.Pop() deletes basket
+            ActionNode* actionNode = queue.Pop();
+            Action* action = InitializeAction(actionNode);
+
+            if (!action)
+            {
+                LogAction("A:%s - UNKNOWN", actionNode->getName().c_str());
+            }
+            else if (action->isUseful())
+            {
+                for (list<Multiplier*>::iterator i = multipliers.begin(); i!= multipliers.end(); i++)
+                {
+                    Multiplier* multiplier = *i;
+                    relevance *= multiplier->GetValue(action);
+                    if (!relevance)
+                    {
+                        LogAction("Multiplier %s made action %s useless", multiplier->getName().c_str(), action->getName().c_str());
+                        break;
+                    }
+                }
+
+                if (action->isPossible() && relevance)
+                {
+                    if ((!skipPrerequisites || lastRelevance-relevance > 0.04) &&
+                            MultiplyAndPush(actionNode->getPrerequisites(), relevance + 0.02, false, event))
+                    {
+                        PushAgain(actionNode, relevance + 0.01, event);
+                        continue;
+                    }
+
+                    actionExecuted = ListenAndExecute(action, event);
+
+                    if (actionExecuted)
+                    {
+                        LogAction("A:%s - OK", action->getName().c_str());
+                        MultiplyAndPush(actionNode->getContinuers(), 0, false, event);
+                        lastRelevance = relevance;
+                        delete actionNode;
+                        break;
+                    }
+                    else
+                    {
+                        MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                        LogAction("A:%s - FAILED", action->getName().c_str());
+                    }
+                }
+                else
+                {
+                    MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                    LogAction("A:%s - IMPOSSIBLE", action->getName().c_str());
+                }
+            }
+            else
+            {
+                lastRelevance = relevance;
+                LogAction("A:%s - USELESS", action->getName().c_str());
+            }
+            delete actionNode;
+        }
+    }
+    while (basket);
+
+    if (!basket)
+    {
+        lastRelevance = 0.0f;
+        PushDefaultActions();
+        if (queue.Peek() && depth < 2)
+            return DoNextAction(unit, depth + 1);
+    }
+
+    if (time(0) - currentTime > 1) {
+        LogAction("too long execution");
+    }
+
+    if (!actionExecuted)
+        LogAction("no actions executed");
+
+    return actionExecuted;
+}
+
+ActionNode* Engine::CreateActionNode(string name)
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        ActionNode* node = strategy->GetAction(name);
+        if (node)
+            return node;
+    }
+    return new ActionNode (name,
+        /*P*/ NULL,
+        /*A*/ NULL,
+        /*C*/ NULL);
+}
+
+bool Engine::MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event)
+{
+    bool pushed = false;
+    if (actions)
+    {
+        for (int j=0; j<10; j++) // TODO: remove 10
+        {
+            NextAction* nextAction = actions[j];
+            if (nextAction)
+            {
+                ActionNode* action = CreateActionNode(nextAction->getName());
+                InitializeAction(action);
+
+                float k = nextAction->getRelevance();
+                if (forceRelevance > 0.0f)
+                {
+                    k = forceRelevance;
+                }
+
+                if (k > 0)
+                {
+                    LogAction("PUSH:%s %f", action->getName().c_str(), k);
+                    queue.Push(new ActionBasket(action, k, skipPrerequisites, event));
+                    pushed = true;
+                }
+
+                delete nextAction;
+            }
+            else
+                break;
+        }
+        delete actions;
+    }
+    return pushed;
+}
+
+ActionResult Engine::ExecuteAction(string name)
+{
+	bool result = false;
+
+    ActionNode *actionNode = CreateActionNode(name);
+    if (!actionNode)
+        return ACTION_RESULT_UNKNOWN;
+
+    Action* action = InitializeAction(actionNode);
+    if (!action)
+        return ACTION_RESULT_UNKNOWN;
+
+    if (!action->isPossible())
+        return ACTION_RESULT_IMPOSSIBLE;
+
+    if (!action->isUseful())
+        return ACTION_RESULT_USELESS;
+
+    action->MakeVerbose();
+    Event emptyEvent;
+    result = ListenAndExecute(action, emptyEvent);
+    MultiplyAndPush(action->getContinuers(), 0.0f, false, emptyEvent);
+	return result ? ACTION_RESULT_OK : ACTION_RESULT_FAILED;
+}
+
+void Engine::addStrategy(string name)
+{
+    removeStrategy(name);
+
+    Strategy* strategy = aiObjectContext->GetStrategy(name);
+    if (strategy)
+    {
+        set<string> siblings = aiObjectContext->GetSiblingStrategy(name);
+        for (set<string>::iterator i = siblings.begin(); i != siblings.end(); i++)
+            removeStrategy(*i);
+
+        LogAction("S:+%s", strategy->getName().c_str());
+        strategies[strategy->getName()] = strategy;
+    }
+    Init();
+}
+
+void Engine::addStrategies(string first, ...)
+{
+	addStrategy(first);
+
+	va_list vl;
+	va_start(vl, first);
+
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			addStrategy(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+bool Engine::removeStrategy(string name)
+{
+    map<string, Strategy*>::iterator i = strategies.find(name);
+    if (i == strategies.end())
+        return false;
+
+    LogAction("S:-%s", name.c_str());
+    strategies.erase(i);
+    Init();
+    return true;
+}
+
+void Engine::removeAllStrategies()
+{
+    strategies.clear();
+    Init();
+}
+
+void Engine::toggleStrategy(string name)
+{
+    if (!removeStrategy(name))
+        addStrategy(name);
+}
+
+bool Engine::HasStrategy(string name)
+{
+    return strategies.find(name) != strategies.end();
+}
+
+void Engine::ProcessTriggers()
+{
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* node = *i;
+        if (!node)
+            continue;
+
+        Trigger* trigger = node->getTrigger();
+        if (!trigger)
+        {
+            trigger = aiObjectContext->GetTrigger(node->getName());
+            node->setTrigger(trigger);
+        }
+
+        if (!trigger)
+            continue;
+
+        if (testMode || trigger->needCheck())
+        {
+            Event event = trigger->Check();
+            if (!event)
+                continue;
+
+            LogAction("T:%s", trigger->getName().c_str());
+            MultiplyAndPush(node->getHandlers(), 0.0f, false, event);
+        }
+    }
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        Trigger* trigger = (*i)->getTrigger();
+        if (trigger) trigger->Reset();
+    }
+}
+
+void Engine::PushDefaultActions()
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+}
+
+string Engine::ListStrategies()
+{
+    string s = "Strategies: ";
+
+    if (strategies.empty())
+        return s;
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        s.append(i->first);
+        s.append(", ");
+    }
+    return s.substr(0, s.length() - 2);
+}
+
+void Engine::PushAgain(ActionNode* actionNode, float relevance, Event event)
+{
+    NextAction** nextAction = new NextAction*[2];
+    nextAction[0] = new NextAction(actionNode->getName(), relevance);
+    nextAction[1] = NULL;
+    MultiplyAndPush(nextAction, relevance, true, event);
+    delete actionNode;
+}
+
+bool Engine::ContainsStrategy(StrategyType type)
+{
+	for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+	{
+		Strategy* strategy = i->second;
+		if (strategy->GetType() & type)
+			return true;
+	}
+	return false;
+}
+
+Action* Engine::InitializeAction(ActionNode* actionNode)
+{
+    Action* action = actionNode->getAction();
+    if (!action)
+    {
+        action = aiObjectContext->GetAction(actionNode->getName());
+        actionNode->setAction(action);
+    }
+    return action;
+}
+
+bool Engine::ListenAndExecute(Action* action, Event event)
+{
+    bool actionExecuted = false;
+
+    if (actionExecutionListeners.Before(action, event))
+    {
+        actionExecuted = actionExecutionListeners.AllowExecution(action, event) ? action->Execute(event) : true;
+    }
+
+    actionExecuted = actionExecutionListeners.OverrideResult(action, actionExecuted, event);
+    actionExecutionListeners.After(action, actionExecuted, event);
+    return actionExecuted;
+}
+
+void Engine::LogAction(const char* format, ...)
+{
+    char buf[1024];
+
+    va_list ap;
+    va_start(ap, format);
+    vsprintf(buf, format, ap);
+    va_end(ap);
+
+    if (testMode)
+    {
+        FILE* file = fopen("test.log", "a");
+        fprintf(file, buf);
+        fprintf(file, "\n");
+        fclose(file);
+    }
+    else
+    {
+        Player* bot = ai->GetBot();
+        if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+            return;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "%s %s", bot->GetName().c_str(), buf);
+    }
+}
+
+void Engine::ChangeStrategy(string names)
+{
+    vector<string> splitted = split(names, ',');
+    for (vector<string>::iterator i = splitted.begin(); i != splitted.end(); i++)
+    {
+        const char* name = i->c_str();
+        switch (name[0])
+        {
+        case '+':
+            addStrategy(name+1);
+            break;
+        case '-':
+            removeStrategy(name+1);
+            break;
+        case '~':
+            toggleStrategy(name+1);
+            break;
+        case '?':
+            ai->TellMaster(ListStrategies());
+            break;
+        }
+    }
+}
+
+void Engine::LogValues()
+{
+    if (testMode)
+        return;
+
+    Player* bot = ai->GetBot();
+    if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+        return;
+
+    string text = ai->GetAiObjectContext()->FormatValues();
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Values for %s: %s", bot->GetName().c_str(), text.c_str());
+}
diff --git a/src/plugins/playerbot/strategy/Engine.h b/src/plugins/playerbot/strategy/Engine.h
new file mode 100644
index 0000000..364dcbb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.h
@@ -0,0 +1,121 @@
+#pragma once
+
+#include "Action.h"
+#include "Queue.h"
+#include "Trigger.h"
+#include "Multiplier.h"
+#include "AiObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class ActionExecutionListener
+    {
+    public:
+        virtual bool Before(Action* action, Event event) = 0;
+        virtual bool AllowExecution(Action* action, Event event) = 0;
+        virtual void After(Action* action, bool executed, Event event) = 0;
+        virtual bool OverrideResult(Action* action, bool executed, Event event) = 0;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    class ActionExecutionListeners : public ActionExecutionListener
+    {
+    public:
+        virtual ~ActionExecutionListeners();
+
+    // ActionExecutionListener
+    public:
+        virtual bool Before(Action* action, Event event);
+        virtual bool AllowExecution(Action* action, Event event);
+        virtual void After(Action* action, bool executed, Event event);
+        virtual bool OverrideResult(Action* action, bool executed, Event event);
+
+    public:
+        void Add(ActionExecutionListener* listener)
+        {
+            listeners.push_back(listener);
+        }
+        void Remove(ActionExecutionListener* listener)
+        {
+            listeners.remove(listener);
+        }
+
+    private:
+        std::list<ActionExecutionListener*> listeners;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    enum ActionResult
+    {
+        ACTION_RESULT_UNKNOWN,
+        ACTION_RESULT_OK,
+        ACTION_RESULT_IMPOSSIBLE,
+        ACTION_RESULT_USELESS,
+        ACTION_RESULT_FAILED
+    };
+
+    class Engine : public PlayerbotAIAware
+    {
+    public:
+        Engine(PlayerbotAI* ai, AiObjectContext *factory);
+
+	    void Init();
+        void addStrategy(string name);
+		void addStrategies(string first, ...);
+        bool removeStrategy(string name);
+        bool HasStrategy(string name);
+        void removeAllStrategies();
+        void toggleStrategy(string name);
+        std::string ListStrategies();
+		bool ContainsStrategy(StrategyType type);
+		void ChangeStrategy(string names);
+
+    public:
+	    virtual bool DoNextAction(Unit*, int depth = 0);
+	    ActionResult ExecuteAction(string name);
+
+    public:
+        void AddActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Add(listener);
+        }
+        void removeActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Remove(listener);
+        }
+
+    public:
+	    virtual ~Engine(void);
+
+    private:
+        bool MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event);
+        void Reset();
+        void ProcessTriggers();
+        void PushDefaultActions();
+        void PushAgain(ActionNode* actionNode, float relevance, Event event);
+        ActionNode* CreateActionNode(string name);
+        Action* InitializeAction(ActionNode* actionNode);
+        bool ListenAndExecute(Action* action, Event event);
+
+    private:
+        void LogAction(const char* format, ...);
+        void LogValues();
+
+    protected:
+	    Queue queue;
+	    std::list<TriggerNode*> triggers;
+        std::list<Multiplier*> multipliers;
+        AiObjectContext* aiObjectContext;
+        std::map<string, Strategy*> strategies;
+        float lastRelevance;
+
+    public:
+		bool testMode;
+
+    private:
+        ActionExecutionListeners actionExecutionListeners;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Event.cpp b/src/plugins/playerbot/strategy/Event.cpp
new file mode 100644
index 0000000..1a0f28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.cpp
@@ -0,0 +1,20 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Event.h"
+
+
+using namespace ai;
+
+ObjectGuid Event::getObject()
+{
+    if (packet.empty())
+        return ObjectGuid();
+
+    WorldPacket p(packet);
+    p.rpos(0);
+    
+    ObjectGuid guid;
+    p >> guid;
+
+    return guid;
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Event.h b/src/plugins/playerbot/strategy/Event.h
new file mode 100644
index 0000000..86ea279
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.h
@@ -0,0 +1,36 @@
+#pragma once
+
+namespace ai
+{
+    class Event
+	{
+	public:
+        Event(Event const& other)
+        {
+            source = other.source;
+            param = other.param;
+            packet = other.packet;
+            owner = other.owner;
+        }
+        Event() {}
+        Event(string source) : source(source) {}
+        Event(string source, string param, Player* owner = NULL) : source(source), param(param), owner(owner) {}
+        Event(string source, WorldPacket &packet, Player* owner = NULL) : source(source), packet(packet), owner(owner) {}
+        virtual ~Event() {}
+
+	public:
+        string getSource() { return source; }
+        string getParam() { return param; }
+        WorldPacket& getPacket() { return packet; }
+        ObjectGuid getObject();
+        Player* getOwner() { return owner; }
+        bool operator! () const { return source.empty(); }
+
+    protected:
+        string source;
+        string param;
+        WorldPacket packet;
+        ObjectGuid object;
+        Player* owner;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/ExternalEventHelper.h b/src/plugins/playerbot/strategy/ExternalEventHelper.h
new file mode 100644
index 0000000..a25154e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ExternalEventHelper.h
@@ -0,0 +1,69 @@
+#pragma once
+
+#include "Trigger.h"
+
+namespace ai
+{
+    class ExternalEventHelper {
+    public:
+        ExternalEventHelper(AiObjectContext* aiObjectContext) : aiObjectContext(aiObjectContext) {}
+
+        bool ParseChatCommand(string command, Player* owner = NULL)
+        {
+            if (HandleCommand(command, "", owner))
+                return true;
+
+            size_t i = string::npos;
+            while (true)
+            {
+                size_t found = command.rfind(" ", i);
+                if (found == string::npos || !found)
+                    break;
+
+                string name = command.substr(0, found);
+                string param = command.substr(found + 1);
+
+                i = found - 1;
+
+                if (HandleCommand(name, param, owner))
+                    return true;
+            }
+
+            if (!ChatHelper::parseable(command))
+                return false;
+
+            HandleCommand("q", command, owner);
+            HandleCommand("c", command, owner);
+            HandleCommand("t", command, owner);
+            return true;
+        }
+
+        void HandlePacket(map<uint16, string> &handlers, const WorldPacket &packet, Player* owner = NULL)
+        {
+            uint16 opcode = packet.GetOpcode();
+            string name = handlers[opcode];
+            if (name.empty())
+                return;
+
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return;
+
+            WorldPacket p(packet);
+            trigger->ExternalEvent(p, owner);
+        }
+
+        bool HandleCommand(string name, string param, Player* owner = NULL)
+        {
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return false;
+
+            trigger->ExternalEvent(param, owner);
+            return true;
+        }
+
+    private:
+        AiObjectContext* aiObjectContext;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/ItemVisitors.h b/src/plugins/playerbot/strategy/ItemVisitors.h
new file mode 100644
index 0000000..88003f1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ItemVisitors.h
@@ -0,0 +1,258 @@
+#pragma once
+
+char * strstri (const char* str1, const char* str2);
+
+namespace ai
+{
+    class IterateItemsVisitor
+    {
+    public:
+        IterateItemsVisitor() {}
+
+        virtual bool Visit(Item* item) = 0;
+    };
+
+    class FindItemVisitor : public IterateItemsVisitor {
+    public:
+        FindItemVisitor() : IterateItemsVisitor(), result(0) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (!Accept(item->GetTemplate()))
+                return true;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult() { return result; }
+
+    protected:
+        virtual bool Accept(const ItemTemplate* proto) = 0;
+
+    private:
+        list<Item*> result;
+    };
+
+    enum IterateItemsMask
+    {
+        ITERATE_ITEMS_IN_BAGS = 1,
+        ITERATE_ITEMS_IN_EQUIP = 2,
+        ITERATE_ALL_ITEMS = 255
+    };
+
+    class FindUsableItemVisitor : public FindItemVisitor {
+    public:
+        FindUsableItemVisitor(Player* bot) : FindItemVisitor()
+        {
+            this->bot = bot;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (bot->CanUseItem(item->GetTemplate()) == EQUIP_ERR_OK)
+                return FindItemVisitor::Visit(item);
+
+            return true;
+        }
+
+    private:
+        Player* bot;
+    };
+
+
+    class FindItemsByQualityVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsByQualityVisitor(uint32 quality, int count) : IterateItemsVisitor()
+        {
+            this->quality = quality;
+            this->count = count;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->Quality != quality)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 quality;
+        int count;
+        list<Item*> result;
+    };
+
+    class FindItemsToTradeByQualityVisitor : public FindItemsByQualityVisitor
+    {
+    public:
+        FindItemsToTradeByQualityVisitor(uint32 quality, int count) : FindItemsByQualityVisitor(quality, count) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            return FindItemsByQualityVisitor::Visit(item);
+        }
+    };
+
+    class FindItemsToTradeByClassVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsToTradeByClassVisitor(uint32 itemClass, uint32 itemSubClass, int count)
+            : IterateItemsVisitor(), count(count), itemClass(itemClass), itemSubClass(itemSubClass) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            if (item->GetTemplate()->Class != itemClass || item->GetTemplate()->SubClass != itemSubClass)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 itemClass;
+        uint32 itemSubClass;
+        int count;
+        list<Item*> result;
+    };
+
+    class QueryItemCountVisitor : public IterateItemsVisitor
+    {
+    public:
+        QueryItemCountVisitor(uint32 itemId)
+        {
+            count = 0;
+            this->itemId = itemId;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->ItemId == itemId)
+                count += item->GetCount();
+
+            return true;
+        }
+
+        int GetCount() { return count; }
+
+    protected:
+        int count;
+        uint32 itemId;
+    };
+
+
+    class QueryNamedItemCountVisitor : public QueryItemCountVisitor
+    {
+    public:
+        QueryNamedItemCountVisitor(string name) : QueryItemCountVisitor(0)
+        {
+            this->name = name;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            const ItemTemplate* proto = item->GetTemplate();
+            if (proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str()))
+                count += item->GetCount();
+
+            return true;
+        }
+
+    private:
+        string name;
+    };
+
+    class FindUsableNamedItemVisitor : public FindUsableItemVisitor {
+    public:
+        FindUsableNamedItemVisitor(Player* bot, string name) : FindUsableItemVisitor(bot)
+        {
+            this->name = name;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str());
+        }
+
+    private:
+        string name;
+    };
+
+    class FindItemByIdVisitor : public FindItemVisitor {
+    public:
+        FindItemByIdVisitor(uint32 id) : FindItemVisitor()
+        {
+            this->id = id;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto->ItemId == id;
+        }
+
+    private:
+        uint32 id;
+    };
+
+    class ListItemsVisitor : public IterateItemsVisitor
+    {
+    public:
+        ListItemsVisitor() : IterateItemsVisitor() {}
+
+        map<uint32, int> items;
+
+        virtual bool Visit(Item* item)
+        {
+            uint32 id = item->GetTemplate()->ItemId;
+
+            if (items.find(id) == items.end())
+                items[id] = 0;
+
+            items[id] += item->GetCount();
+            return true;
+        }
+    };
+
+    class ItemCountByQuality : public IterateItemsVisitor
+    {
+    public:
+        ItemCountByQuality() : IterateItemsVisitor()
+        {
+            for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i)
+                count[i] = 0;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            count[item->GetTemplate()->Quality]++;
+            return true;
+        }
+
+    public:
+        map<uint32, int> count;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Multiplier.cpp b/src/plugins/playerbot/strategy/Multiplier.cpp
new file mode 100644
index 0000000..893d7f3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Multiplier.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Multiplier.h b/src/plugins/playerbot/strategy/Multiplier.h
new file mode 100644
index 0000000..e86fa05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "Action.h"
+
+namespace ai
+{
+    class Multiplier : public AiNamedObject
+    {
+    public:
+        Multiplier(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual ~Multiplier() {}
+
+    public:
+        virtual float GetValue(Action* action) { return 1.0f; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/NamedObjectContext.h b/src/plugins/playerbot/strategy/NamedObjectContext.h
new file mode 100644
index 0000000..2ccb68c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/NamedObjectContext.h
@@ -0,0 +1,249 @@
+#pragma once
+
+namespace ai
+{
+    using namespace std;
+
+    class Qualified
+    {
+    public:
+        Qualified() {};
+
+    public:
+        void Qualify(string qualifier) { this->qualifier = qualifier; }
+
+    protected:
+        string qualifier;
+    };
+
+    template <class T> class NamedObjectFactory
+    {
+    protected:
+        typedef T* (*ActionCreator) (PlayerbotAI* ai);
+        map<string, ActionCreator> creators;
+
+    public:
+        T* create(string name, PlayerbotAI* ai)
+        {
+            size_t found = name.find("::");
+            string qualifier;
+            if (found != string::npos)
+            {
+                qualifier = name.substr(found + 2);
+                name = name.substr(0, found);
+            }
+
+            if (creators.find(name) == creators.end())
+                return NULL;
+
+            ActionCreator creator = creators[name];
+            if (!creator)
+                return NULL;
+
+            T *object = (*creator)(ai);
+            Qualified *q = dynamic_cast<Qualified *>(object);
+            if (q)
+                q->Qualify(qualifier);
+
+            return object;
+        }
+
+        set<string> supports()
+        {
+            set<string> keys;
+            for (typename map<string, ActionCreator>::iterator it = creators.begin(); it != creators.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+    };
+
+
+    template <class T> class NamedObjectContext : public NamedObjectFactory<T>
+    {
+    public:
+        NamedObjectContext(bool shared = false, bool supportsSiblings = false) :
+            NamedObjectFactory<T>(), shared(shared), supportsSiblings(supportsSiblings) {}
+
+        T* create(string name, PlayerbotAI* ai)
+        {
+            if (created.find(name) == created.end())
+                return created[name] = NamedObjectFactory<T>::create(name, ai);
+
+            return created[name];
+        }
+
+        virtual ~NamedObjectContext()
+        {
+            Clear();
+        }
+
+        void Clear()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    delete i->second;
+            }
+
+            created.clear();
+        }
+
+        void Update()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Reset();
+            }
+        }
+
+        bool IsShared() { return shared; }
+        bool IsSupportsSiblings() { return supportsSiblings; }
+
+        set<string> GetCreated()
+        {
+            set<string> keys;
+            for (typename map<string, T*>::iterator it = created.begin(); it != created.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+
+    protected:
+        map<string, T*> created;
+        bool shared;
+        bool supportsSiblings;
+    };
+
+    template <class T> class NamedObjectContextList
+    {
+    public:
+        virtual ~NamedObjectContextList()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                NamedObjectContext<T>* context = *i;
+                if (!context->IsShared())
+                    delete context;
+            }
+        }
+
+        void Add(NamedObjectContext<T>* context)
+        {
+            contexts.push_back(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+        void Update()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsShared())
+                    (*i)->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                (*i)->Reset();
+            }
+        }
+
+        set<string> GetSiblings(string name)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsSupportsSiblings())
+                    continue;
+
+                set<string> supported = (*i)->supports();
+                set<string>::iterator found = supported.find(name);
+                if (found == supported.end())
+                    continue;
+
+                supported.erase(found);
+                return supported;
+            }
+
+            return set<string>();
+        }
+
+        set<string> supports()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> supported = (*i)->supports();
+
+                for (set<string>::iterator j = supported.begin(); j != supported.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+        set<string> GetCreated()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> createdKeys = (*i)->GetCreated();
+
+                for (set<string>::iterator j = createdKeys.begin(); j != createdKeys.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+    private:
+        list<NamedObjectContext<T>*> contexts;
+    };
+
+    template <class T> class NamedObjectFactoryList
+    {
+    public:
+        virtual ~NamedObjectFactoryList()
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+                delete *i;
+        }
+
+        void Add(NamedObjectFactory<T>* context)
+        {
+            factories.push_front(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+    private:
+        list<NamedObjectFactory<T>*> factories;
+    };
+};
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.cpp b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
new file mode 100644
index 0000000..f987438
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
@@ -0,0 +1,47 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "PassiveMultiplier.h"
+
+using namespace ai;
+
+list<string> PassiveMultiplier::allowedActions;
+list<string> PassiveMultiplier::allowedParts;
+
+PassiveMultiplier::PassiveMultiplier(PlayerbotAI* ai) : Multiplier(ai, "passive")
+{
+    if (allowedActions.empty())
+    {
+        allowedActions.push_back("co");
+        allowedActions.push_back("nc");
+        allowedActions.push_back("reset ai");
+        allowedActions.push_back("check mount state");
+    }
+
+    if (allowedParts.empty())
+    {
+        allowedParts.push_back("follow");
+        allowedParts.push_back("stay");
+        allowedParts.push_back("chat shortcut");
+    }
+}
+
+float PassiveMultiplier::GetValue(Action* action) {
+    if (!action)
+		return 1.0f;
+
+    string name = action->getName();
+
+    for (list<string>::iterator i = allowedActions.begin(); i != allowedActions.end(); i++)
+    {
+        if (name == *i)
+            return 1.0f;
+    }
+
+    for (list<string>::iterator i = allowedParts.begin(); i != allowedParts.end(); i++)
+    {
+        if (name.find(*i) != string::npos)
+            return 1.0f;
+    }
+
+    return 0;
+}
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.h b/src/plugins/playerbot/strategy/PassiveMultiplier.h
new file mode 100644
index 0000000..37985a0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+
+namespace ai
+{
+    class PassiveMultiplier : public Multiplier
+    {
+    public:
+        PassiveMultiplier(PlayerbotAI* ai);
+
+    public:
+        virtual float GetValue(Action* action);
+
+    private:
+        static list<string> allowedActions;
+        static list<string> allowedParts;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/Queue.cpp b/src/plugins/playerbot/strategy/Queue.cpp
new file mode 100644
index 0000000..8553b44
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.cpp
@@ -0,0 +1,81 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Action.h"
+#include "Queue.h"
+
+using namespace ai;
+
+
+void Queue::Push(ActionBasket *action)
+{
+	if (action)
+    {
+        for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+        {
+            ActionBasket* basket = *iter;
+            if (action->getAction()->getName() == basket->getAction()->getName())
+            {
+				if (basket->getRelevance() < action->getRelevance())
+					basket->setRelevance(action->getRelevance());
+                delete action;
+                return;
+            }
+        }
+		actions.push_back(action);
+    }
+}
+
+void Queue::Push(ActionBasket **actions)
+{
+	if (actions)
+	{
+		for (int i=0; i<sizeof(actions)/sizeof(ActionBasket*); i++)
+		{
+			Push(actions[i]);
+		}
+	}
+}
+
+ActionNode* Queue::Pop()
+{
+	float max = -1;
+	ActionBasket* selection = NULL;
+	for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+	{
+		ActionBasket* basket = *iter;
+		if (basket->getRelevance() > max)
+		{
+			max = basket->getRelevance();
+			selection = basket;
+		}
+	}
+	if (selection != NULL)
+	{
+		ActionNode* action = selection->getAction();
+		actions.remove(selection);
+		delete selection;
+		return action;
+	}
+	return NULL;
+}
+
+ActionBasket* Queue::Peek()
+{
+    float max = -1;
+    ActionBasket* selection = NULL;
+    for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+    {
+        ActionBasket* basket = *iter;
+        if (basket->getRelevance() > max)
+        {
+            max = basket->getRelevance();
+            selection = basket;
+        }
+    }
+    return selection;
+}
+
+int Queue::Size()
+{
+	return actions.size();
+}
diff --git a/src/plugins/playerbot/strategy/Queue.h b/src/plugins/playerbot/strategy/Queue.h
new file mode 100644
index 0000000..b70a526
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.h
@@ -0,0 +1,21 @@
+#include "ActionBasket.h"
+
+#pragma once
+namespace ai
+{
+class Queue
+{
+public:
+    Queue(void) {}
+public:
+    ~Queue(void) {}
+public:
+	void Push(ActionBasket *action);
+	void Push(ActionBasket **actions);
+	ActionNode* Pop();
+    ActionBasket* Peek();
+	int Size();
+private:
+	std::list<ActionBasket*> actions;
+};
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Strategy.cpp b/src/plugins/playerbot/strategy/Strategy.cpp
new file mode 100644
index 0000000..5275ae0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.cpp
@@ -0,0 +1,117 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Strategy.h"
+#include "NamedObjectContext.h"
+
+using namespace ai;
+using namespace std;
+
+
+class ActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ActionNodeFactoryInternal()
+    {
+        creators["melee"] = &melee;
+        creators["healthstone"] = &healthstone;
+        creators["be near"] = &follow_master_random;
+        creators["attack anything"] = &attack_anything;
+        creators["move random"] = &move_random;
+        creators["move to loot"] = &move_to_loot;
+        creators["food"] = &food;
+        creators["drink"] = &drink;
+        creators["mana potion"] = &mana_potion;
+        creators["healing potion"] = &healing_potion;
+        creators["flee"] = &flee;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* healthstone(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healthstone",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* follow_master_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("be near",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("follow"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* attack_anything(PlayerbotAI* ai)
+    {
+        return new ActionNode ("attack anything",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* move_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move random",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("stay line"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* move_to_loot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move to loot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* food(PlayerbotAI* ai)
+    {
+        return new ActionNode ("food",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* drink(PlayerbotAI* ai)
+    {
+        return new ActionNode ("drink",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* healing_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healing potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("food"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+Strategy::Strategy(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    actionNodeFactories.Add(new ActionNodeFactoryInternal());
+}
+
+ActionNode* Strategy::GetAction(string name)
+{
+    return actionNodeFactories.GetObject(name, ai);
+}
+
diff --git a/src/plugins/playerbot/strategy/Strategy.h b/src/plugins/playerbot/strategy/Strategy.h
new file mode 100644
index 0000000..12e98eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+#include "Trigger.h"
+#include "NamedObjectContext.h"
+
+namespace ai
+{
+	enum StrategyType
+	{
+		STRATEGY_TYPE_GENERIC = 0,
+		STRATEGY_TYPE_COMBAT = 1,
+		STRATEGY_TYPE_NONCOMBAT = 2,
+		STRATEGY_TYPE_TANK = 4,
+		STRATEGY_TYPE_DPS = 8,
+		STRATEGY_TYPE_HEAL = 16,
+		STRATEGY_TYPE_RANGED = 32,
+		STRATEGY_TYPE_MELEE = 64
+	};
+
+	enum ActionPriority
+	{
+	    ACTION_IDLE = 0,
+	    ACTION_NORMAL = 10,
+	    ACTION_HIGH = 20,
+	    ACTION_MOVE = 30,
+	    ACTION_INTERRUPT = 40,
+	    ACTION_DISPEL = 50,
+	    ACTION_LIGHT_HEAL = 60,
+	    ACTION_MEDIUM_HEAL = 70,
+	    ACTION_CRITICAL_HEAL = 80,
+	    ACTION_EMERGENCY = 90
+	};
+
+    class Strategy : public PlayerbotAIAware
+    {
+    public:
+        Strategy(PlayerbotAI* ai);
+        virtual ~Strategy() {}
+
+    public:
+        virtual NextAction** getDefaultActions() { return NULL; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers) {}
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers) {}
+        virtual string getName() = 0;
+		virtual int GetType() { return STRATEGY_TYPE_GENERIC; }
+        virtual ActionNode* GetAction(string name);
+        void Update() {}
+        void Reset() {}
+
+    protected:
+        NamedObjectFactoryList<ActionNode> actionNodeFactories;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/StrategyContext.h b/src/plugins/playerbot/strategy/StrategyContext.h
new file mode 100644
index 0000000..cec87dc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/StrategyContext.h
@@ -0,0 +1,141 @@
+#pragma once
+
+#include "generic/NonCombatStrategy.h"
+#include "generic/RacialsStrategy.h"
+#include "generic/ChatCommandHandlerStrategy.h"
+#include "generic/WorldPacketHandlerStrategy.h"
+#include "generic/DeadStrategy.h"
+#include "generic/QuestStrategies.h"
+#include "generic/LootNonCombatStrategy.h"
+#include "generic/DuelStrategy.h"
+#include "generic/KiteStrategy.h"
+#include "generic/FleeStrategy.h"
+#include "generic/FollowMasterStrategy.h"
+#include "generic/RunawayStrategy.h"
+#include "generic/StayStrategy.h"
+#include "generic/UseFoodStrategy.h"
+#include "generic/ConserveManaStrategy.h"
+#include "generic/EmoteStrategy.h"
+#include "generic/AttackRtiStrategy.h"
+#include "generic/AttackWeakStrategy.h"
+#include "generic/TankAoeStrategy.h"
+#include "generic/TankAssistStrategy.h"
+#include "generic/DpsAoeStrategy.h"
+#include "generic/DpsAssistStrategy.h"
+#include "generic/PassiveStrategy.h"
+#include "generic/GrindingStrategy.h"
+#include "generic/UsePotionsStrategy.h"
+#include "generic/GuardStrategy.h"
+#include "generic/CastTimeStrategy.h"
+#include "generic/ThreatStrategy.h"
+#include "generic/TellTargetStrategy.h"
+#include "generic/AttackEnemyPlayersStrategy.h"
+
+namespace ai
+{
+    class StrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        StrategyContext()
+        {
+            creators["racials"] = &StrategyContext::racials;
+            creators["loot"] = &StrategyContext::loot;
+            creators["gather"] = &StrategyContext::gather;
+            creators["emote"] = &StrategyContext::emote;
+            creators["passive"] = &StrategyContext::passive;
+            creators["conserve mana"] = &StrategyContext::conserve_mana;
+            creators["food"] = &StrategyContext::food;
+            creators["chat"] = &StrategyContext::chat;
+            creators["default"] = &StrategyContext::world_packet;
+            creators["ready check"] = &StrategyContext::ready_check;
+            creators["dead"] = &StrategyContext::dead;
+            creators["flee"] = &StrategyContext::flee;
+            creators["duel"] = &StrategyContext::duel;
+            creators["kite"] = &StrategyContext::kite;
+            creators["potions"] = &StrategyContext::potions;
+            creators["cast time"] = &StrategyContext::cast_time;
+            creators["threat"] = &StrategyContext::threat;
+            creators["tell target"] = &StrategyContext::tell_target;
+            creators["pvp"] = &StrategyContext::pvp;
+        }
+
+    private:
+        static Strategy* tell_target(PlayerbotAI* ai) { return new TellTargetStrategy(ai); }
+        static Strategy* threat(PlayerbotAI* ai) { return new ThreatStrategy(ai); }
+        static Strategy* cast_time(PlayerbotAI* ai) { return new CastTimeStrategy(ai); }
+        static Strategy* potions(PlayerbotAI* ai) { return new UsePotionsStrategy(ai); }
+        static Strategy* kite(PlayerbotAI* ai) { return new KiteStrategy(ai); }
+        static Strategy* duel(PlayerbotAI* ai) { return new DuelStrategy(ai); }
+        static Strategy* flee(PlayerbotAI* ai) { return new FleeStrategy(ai); }
+        static Strategy* dead(PlayerbotAI* ai) { return new DeadStrategy(ai); }
+        static Strategy* racials(PlayerbotAI* ai) { return new RacialsStrategy(ai); }
+        static Strategy* loot(PlayerbotAI* ai) { return new LootNonCombatStrategy(ai); }
+        static Strategy* gather(PlayerbotAI* ai) { return new GatherStrategy(ai); }
+        static Strategy* emote(PlayerbotAI* ai) { return new EmoteStrategy(ai); }
+        static Strategy* passive(PlayerbotAI* ai) { return new PassiveStrategy(ai); }
+        static Strategy* conserve_mana(PlayerbotAI* ai) { return new ConserveManaStrategy(ai); }
+        static Strategy* food(PlayerbotAI* ai) { return new UseFoodStrategy(ai); }
+        static Strategy* chat(PlayerbotAI* ai) { return new ChatCommandHandlerStrategy(ai); }
+        static Strategy* world_packet(PlayerbotAI* ai) { return new WorldPacketHandlerStrategy(ai); }
+        static Strategy* ready_check(PlayerbotAI* ai) { return new ReadyCheckStrategy(ai); }
+        static Strategy* pvp(PlayerbotAI* ai) { return new AttackEnemyPlayersStrategy(ai); }
+    };
+
+    class MovementStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        MovementStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["follow"] = &MovementStrategyContext::follow_master;
+            creators["stay"] = &MovementStrategyContext::stay;
+            creators["runaway"] = &MovementStrategyContext::runaway;
+            creators["flee from adds"] = &MovementStrategyContext::flee_from_adds;
+            creators["guard"] = &MovementStrategyContext::guard;
+        }
+
+    private:
+        static Strategy* guard(PlayerbotAI* ai) { return new GuardStrategy(ai); }
+        static Strategy* follow_master(PlayerbotAI* ai) { return new FollowMasterStrategy(ai); }
+        static Strategy* stay(PlayerbotAI* ai) { return new StayStrategy(ai); }
+        static Strategy* runaway(PlayerbotAI* ai) { return new RunawayStrategy(ai); }
+        static Strategy* flee_from_adds(PlayerbotAI* ai) { return new FleeFromAddsStrategy(ai); }
+    };
+
+    class AssistStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        AssistStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["dps assist"] = &AssistStrategyContext::dps_assist;
+            creators["dps aoe"] = &AssistStrategyContext::dps_aoe;
+            creators["tank assist"] = &AssistStrategyContext::tank_assist;
+            creators["tank aoe"] = &AssistStrategyContext::tank_aoe;
+            creators["attack weak"] = &AssistStrategyContext::attack_weak;
+            creators["grind"] = &AssistStrategyContext::grind;
+            creators["attack rti"] = &AssistStrategyContext::attack_rti;
+        }
+
+    private:
+        static Strategy* dps_assist(PlayerbotAI* ai) { return new DpsAssistStrategy(ai); }
+        static Strategy* dps_aoe(PlayerbotAI* ai) { return new DpsAoeStrategy(ai); }
+        static Strategy* tank_assist(PlayerbotAI* ai) { return new TankAssistStrategy(ai); }
+        static Strategy* tank_aoe(PlayerbotAI* ai) { return new TankAoeStrategy(ai); }
+        static Strategy* attack_weak(PlayerbotAI* ai) { return new AttackWeakStrategy(ai); }
+        static Strategy* grind(PlayerbotAI* ai) { return new GrindingStrategy(ai); }
+        static Strategy* attack_rti(PlayerbotAI* ai) { return new AttackRtiStrategy(ai); }
+    };
+
+    class QuestStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        QuestStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["quest"] = &QuestStrategyContext::quest;
+            creators["accept all quests"] = &QuestStrategyContext::accept_all_quests;
+        }
+
+    private:
+        static Strategy* quest(PlayerbotAI* ai) { return new DefaultQuestStrategy(ai); }
+        static Strategy* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsStrategy(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/Trigger.cpp b/src/plugins/playerbot/strategy/Trigger.cpp
new file mode 100644
index 0000000..7487f33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.cpp
@@ -0,0 +1,27 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Trigger.h"
+#include "Action.h"
+
+using namespace ai;
+
+Event Trigger::Check()
+{
+	if (IsActive())
+	{
+		Event event(getName());
+		return event;
+	}
+	Event event;
+	return event;
+}
+
+Value<Unit*>* Trigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Trigger::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Trigger.h b/src/plugins/playerbot/strategy/Trigger.h
new file mode 100644
index 0000000..2ae7276
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.h
@@ -0,0 +1,84 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+
+#define NEXT_TRIGGERS(name, relevance) \
+    virtual NextAction* getNextAction() { return new NextAction(name, relevance); }
+
+#define BEGIN_TRIGGER(clazz, super) \
+class clazz : public super \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : super(ai) {} \
+    public: \
+        virtual bool IsActive();
+
+#define END_TRIGGER() \
+    };
+
+namespace ai
+{
+    class Trigger : public AiNamedObject
+	{
+	public:
+        Trigger(PlayerbotAI* ai, string name = "trigger", int checkInterval = 1) : AiNamedObject(ai, name) {
+			this->checkInterval = checkInterval;
+			ticksElapsed = 0;
+        }
+        virtual ~Trigger() {}
+
+	public:
+        virtual Event Check();
+        virtual void ExternalEvent(string param, Player* owner = NULL) {}
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL) {}
+        virtual bool IsActive() { return false; }
+        virtual NextAction** getHandlers() { return NULL; }
+        void Update() {}
+        virtual void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+
+		bool needCheck() {
+			if (++ticksElapsed >= checkInterval) {
+				ticksElapsed = 0;
+				return true;
+			}
+			return false;
+		}
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+	};
+
+
+    class TriggerNode
+    {
+    public:
+        TriggerNode(string name, NextAction** handlers = NULL)
+        {
+            this->name = name;
+            this->handlers = handlers;
+            this->trigger = NULL;
+        }
+        virtual ~TriggerNode()
+        {
+            NextAction::destroy(handlers);
+        }
+
+    public:
+        Trigger* getTrigger() { return trigger; }
+        void setTrigger(Trigger* trigger) { this->trigger = trigger; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getHandlers() { return NextAction::merge(NextAction::clone(handlers), trigger->getHandlers()); }
+
+    private:
+        Trigger* trigger;
+        NextAction** handlers;
+        std::string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Value.cpp b/src/plugins/playerbot/strategy/Value.cpp
new file mode 100644
index 0000000..8b87c26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Value.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/Value.h b/src/plugins/playerbot/strategy/Value.h
new file mode 100644
index 0000000..930e3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.h
@@ -0,0 +1,177 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class UntypedValue : public AiNamedObject
+    {
+    public:
+        UntypedValue(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual void Update() {}
+        virtual void Reset() {}
+        virtual string Format() { return "?"; }
+    };
+
+    template<class T>
+    class Value
+    {
+    public:
+        virtual T Get() = 0;
+        virtual void Set(T value) = 0;
+        operator T() { return Get(); }
+    };
+
+    template<class T>
+    class CalculatedValue : public UntypedValue, public Value<T>
+	{
+	public:
+        CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) : UntypedValue(ai, name),
+            checkInterval(checkInterval), ticksElapsed(checkInterval)
+        { }
+        virtual ~CalculatedValue() {}
+
+	public:
+        virtual T Get()
+        {
+            if (ticksElapsed >= checkInterval) {
+                ticksElapsed = 0;
+                value = Calculate();
+            }
+            return value;
+        }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update()
+        {
+            if (ticksElapsed < checkInterval) {
+                ticksElapsed++;
+            }
+        }
+
+    protected:
+        virtual T Calculate() = 0;
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+        T value;
+	};
+
+    class Uint8CalculatedValue : public CalculatedValue<uint8>
+    {
+    public:
+        Uint8CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint8>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class Uint32CalculatedValue : public CalculatedValue<uint32>
+    {
+    public:
+        Uint32CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint32>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class FloatCalculatedValue : public CalculatedValue<float>
+    {
+    public:
+        FloatCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<float>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << Calculate();
+            return out.str();
+        }
+    };
+
+    class BoolCalculatedValue : public CalculatedValue<bool>
+    {
+    public:
+        BoolCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<bool>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            return Calculate() ? "true" : "false";
+        }
+    };
+
+    class UnitCalculatedValue : public CalculatedValue<Unit*>
+    {
+    public:
+        UnitCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<Unit*>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Calculate();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+
+    class ObjectGuidListCalculatedValue : public CalculatedValue<list<ObjectGuid> >
+    {
+    public:
+        ObjectGuidListCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<list<ObjectGuid> >(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << "{";
+            list<ObjectGuid> guids = Calculate();
+            for (list<ObjectGuid>::iterator i = guids.begin(); i != guids.end(); ++i)
+            {
+                ObjectGuid guid = *i;
+                out << guid.GetRawValue() << ",";
+            }
+            out << "}";
+            return out.str();
+        }
+    };
+
+    template<class T>
+    class ManualSetValue : public UntypedValue, public Value<T>
+    {
+    public:
+        ManualSetValue(PlayerbotAI* ai, T defaultValue, string name = "value") :
+            UntypedValue(ai, name), value(defaultValue), defaultValue(defaultValue) {}
+        virtual ~ManualSetValue() {}
+
+    public:
+        virtual T Get() { return value; }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update() { }
+        virtual void Reset() { value = defaultValue; }
+
+    protected:
+        T value;
+        T defaultValue;
+    };
+
+    class UnitManualSetValue : public ManualSetValue<Unit*>
+    {
+    public:
+        UnitManualSetValue(PlayerbotAI* ai, Unit* defaultValue, string name = "value") :
+            ManualSetValue<Unit*>(ai, defaultValue, name) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Get();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
new file mode 100644
index 0000000..fb8db06
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptDuelAction : public Action
+    {
+    public:
+        AcceptDuelAction(PlayerbotAI* ai) : Action(ai, "accept duel")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket p(event.getPacket());
+
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+            *packet << flagGuid;
+            bot->GetSession()->QueuePacket(packet);
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
new file mode 100644
index 0000000..096fb84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Globals/ObjectMgr.h"
+
+namespace ai
+{
+    class AcceptInvitationAction : public Action {
+    public:
+        AcceptInvitationAction(PlayerbotAI* ai) : Action(ai, "accept invitation") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+
+            Group* grp = bot->GetGroupInvite();
+            if (!grp)
+                return false;
+
+            Player* inviter = sObjectMgr->GetPlayerByLowGUID(grp->GetLeaderGUID());
+            if (!inviter)
+                return false;
+
+			if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, inviter))
+            {
+                WorldPacket data(SMSG_GROUP_DECLINE, 10);
+                data << bot->GetName();
+                inviter->GetSession()->SendPacket(&data);
+                bot->UninviteFromGroup();
+                return false;
+            }
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << roles_mask;
+            bot->GetSession()->HandleGroupAcceptOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+                bot->GetPlayerbotAI()->SetMaster(inviter);
+
+            ai->ResetStrategies();
+            ai->TellMaster("Hello");
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
new file mode 100644
index 0000000..af63f76
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
@@ -0,0 +1,102 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AcceptQuestAction.h"
+
+using namespace ai;
+
+void AcceptAllQuestsAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    AcceptQuest(quest, questGiver->GetGUID());
+}
+
+bool AcceptQuestAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Player *bot = ai->GetBot();
+    uint64 guid;
+    uint32 quest;
+
+    string text = event.getParam();
+    PlayerbotChatHandler ch(master);
+    quest = ch.extractQuestId(text);
+    if (quest)
+    {
+        Unit* npc = master->GetSelectedUnit();
+        if (!npc)
+        {
+            ai->TellMaster("Please select quest giver NPC");
+            return false;
+        }
+    }
+    else if (!event.getPacket().empty())
+    {
+        WorldPacket& p = event.getPacket();
+        p.rpos(0);
+        p >> guid >> quest;
+    }
+    else if (text == "*")
+    {
+        return QuestAction::Execute(event);
+    }
+    else
+        return false;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+    if (!qInfo)
+        return false;
+
+    return AcceptQuest(qInfo, guid);
+}
+
+bool AcceptQuestShareAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    Player *bot = ai->GetBot();
+
+    WorldPacket& p = event.getPacket();
+    p.rpos(0);
+    uint32 quest;
+    p >> quest;
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+
+    if (!qInfo || !bot->GetDivider())
+        return false;
+
+    quest = qInfo->GetQuestId();
+    if( !bot->CanTakeQuest( qInfo, false ) )
+    {
+        // can't take quest
+        bot->SetDivider( ObjectGuid() );
+        ai->TellMaster("I can't take this quest");
+
+        return false;
+    }
+
+    // send msg to quest giving player
+    master->SendPushToPartyResponse( bot, QUEST_PARTY_MSG_ACCEPT_QUEST );
+    bot->SetDivider( ObjectGuid() );
+
+    if( bot->CanAddQuest( qInfo, false ) )
+    {
+        bot->AddQuest( qInfo, master );
+
+        if( bot->CanCompleteQuest( quest ) )
+            bot->CompleteQuest( quest );
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if( qInfo->GetSrcSpell() > 0 )
+            bot->CastSpell( bot, qInfo->GetSrcSpell(), true );
+
+        ai->TellMaster("Quest accepted");
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
new file mode 100644
index 0000000..856c697
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class AcceptAllQuestsAction : public QuestAction {
+    public:
+        AcceptAllQuestsAction(PlayerbotAI* ai, string name = "accept all quests") : QuestAction(ai, name) {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+    };
+
+    class AcceptQuestAction : public AcceptAllQuestsAction {
+    public:
+        AcceptQuestAction(PlayerbotAI* ai) : AcceptAllQuestsAction(ai, "accept quest") {}
+        virtual bool Execute(Event event);
+    };
+
+    class AcceptQuestShareAction : public Action {
+    public:
+        AcceptQuestShareAction(PlayerbotAI* ai) : Action(ai, "accept quest share") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
new file mode 100644
index 0000000..77dd0dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptResurrectAction : public Action {
+    public:
+        AcceptResurrectAction(PlayerbotAI* ai) : Action(ai, "accept resurrect") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive())
+                return false;
+
+            WorldPacket p(event.getPacket());
+            p.rpos(0);
+            ObjectGuid guid;
+            p >> guid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8+1);
+            *packet << guid;
+            *packet << uint8(1);                        // accept
+            bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ActionContext.h b/src/plugins/playerbot/strategy/actions/ActionContext.h
new file mode 100644
index 0000000..52da65c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ActionContext.h
@@ -0,0 +1,107 @@
+#pragma once
+
+#include "GenericActions.h"
+#include "NonCombatActions.h"
+#include "EmoteAction.h"
+#include "AddLootAction.h"
+#include "LootAction.h"
+#include "AddLootAction.h"
+#include "StayActions.h"
+#include "FollowActions.h"
+#include "ChangeStrategyAction.h"
+#include "ChooseTargetActions.h"
+#include "SuggestWhatToDoAction.h"
+#include "PositionAction.h"
+#include "AttackAction.h"
+
+namespace ai
+{
+    class ActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ActionContext()
+        {
+            creators["attack"] = &ActionContext::melee;
+            creators["melee"] = &ActionContext::melee;
+            creators["reach spell"] = &ActionContext::ReachSpell;
+            creators["reach melee"] = &ActionContext::ReachMelee;
+            creators["flee"] = &ActionContext::flee;
+            creators["gift of the naaru"] = &ActionContext::gift_of_the_naaru;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["lifeblood"] = &ActionContext::lifeblood;
+            creators["arcane torrent"] = &ActionContext::arcane_torrent;
+            creators["end pull"] = &ActionContext::end_pull;
+            creators["healthstone"] = &ActionContext::healthstone;
+            creators["healing potion"] = &ActionContext::healing_potion;
+            creators["mana potion"] = &ActionContext::mana_potion;
+            creators["food"] = &ActionContext::food;
+            creators["drink"] = &ActionContext::drink;
+            creators["tank assist"] = &ActionContext::tank_assist;
+            creators["dps assist"] = &ActionContext::dps_assist;
+            creators["attack rti target"] = &ActionContext::attack_rti_target;
+            creators["loot"] = &ActionContext::loot;
+            creators["add loot"] = &ActionContext::add_loot;
+            creators["add gathering loot"] = &ActionContext::add_gathering_loot;
+            creators["add all loot"] = &ActionContext::add_all_loot;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["follow"] = &ActionContext::follow;
+            creators["follow"] = &ActionContext::follow;
+            creators["runaway"] = &ActionContext::runaway;
+            creators["stay"] = &ActionContext::stay;
+            creators["attack anything"] = &ActionContext::attack_anything;
+            creators["attack least hp target"] = &ActionContext::attack_least_hp_target;
+            creators["attack enemy player"] = &ActionContext::enemy_player_target;
+            creators["emote"] = &ActionContext::emote;
+            creators["suggest what to do"] = &ActionContext::suggest_what_to_do;
+            creators["move random"] = &ActionContext::move_random;
+            creators["move to loot"] = &ActionContext::move_to_loot;
+            creators["open loot"] = &ActionContext::open_loot;
+            creators["guard"] = &ActionContext::guard;
+            creators["move out of enemy contact"] = &ActionContext::move_out_of_enemy_contact;
+            creators["set facing"] = &ActionContext::set_facing;
+            creators["attack duel opponent"] = &ActionContext::attack_duel_opponent;
+            creators["drop target"] = &ActionContext::drop_target;
+        }
+
+    private:
+        static Action* drop_target(PlayerbotAI* ai) { return new DropTargetAction(ai); }
+        static Action* attack_duel_opponent(PlayerbotAI* ai) { return new AttackDuelOpponentAction(ai); }
+        static Action* guard(PlayerbotAI* ai) { return new GuardAction(ai); }
+        static Action* open_loot(PlayerbotAI* ai) { return new OpenLootAction(ai); }
+        static Action* move_to_loot(PlayerbotAI* ai) { return new MoveToLootAction(ai); }
+        static Action* move_random(PlayerbotAI* ai) { return new MoveRandomAction(ai); }
+        static Action* shoot(PlayerbotAI* ai) { return new CastShootAction(ai); }
+        static Action* melee(PlayerbotAI* ai) { return new MeleeAction(ai); }
+        static Action* ReachSpell(PlayerbotAI* ai) { return new ReachSpellAction(ai); }
+        static Action* ReachMelee(PlayerbotAI* ai) { return new ReachMeleeAction(ai); }
+        static Action* flee(PlayerbotAI* ai) { return new FleeAction(ai); }
+        static Action* gift_of_the_naaru(PlayerbotAI* ai) { return new CastGiftOfTheNaaruAction(ai); }
+        static Action* lifeblood(PlayerbotAI* ai) { return new CastLifeBloodAction(ai); }
+        static Action* arcane_torrent(PlayerbotAI* ai) { return new CastArcaneTorrentAction(ai); }
+        static Action* end_pull(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai, "-pull"); }
+
+        static Action* emote(PlayerbotAI* ai) { return new EmoteAction(ai); }
+        static Action* suggest_what_to_do(PlayerbotAI* ai) { return new SuggestWhatToDoAction(ai); }
+        static Action* attack_anything(PlayerbotAI* ai) { return new AttackAnythingAction(ai); }
+        static Action* attack_least_hp_target(PlayerbotAI* ai) { return new AttackLeastHpTargetAction(ai); }
+        static Action* enemy_player_target(PlayerbotAI* ai) { return new AttackEnemyPlayerAction(ai); }
+        static Action* stay(PlayerbotAI* ai) { return new StayAction(ai); }
+        static Action* runaway(PlayerbotAI* ai) { return new RunAwayAction(ai); }
+        static Action* follow(PlayerbotAI* ai) { return new FollowAction(ai); }
+        static Action* add_gathering_loot(PlayerbotAI* ai) { return new AddGatheringLootAction(ai); }
+        static Action* add_loot(PlayerbotAI* ai) { return new AddLootAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* loot(PlayerbotAI* ai) { return new LootAction(ai); }
+        static Action* dps_assist(PlayerbotAI* ai) { return new DpsAssistAction(ai); }
+        static Action* attack_rti_target(PlayerbotAI* ai) { return new AttackRtiTargetAction(ai); }
+        static Action* tank_assist(PlayerbotAI* ai) { return new TankAssistAction(ai); }
+        static Action* drink(PlayerbotAI* ai) { return new DrinkAction(ai); }
+        static Action* food(PlayerbotAI* ai) { return new EatAction(ai); }
+        static Action* mana_potion(PlayerbotAI* ai) { return new UseManaPotion(ai); }
+        static Action* healing_potion(PlayerbotAI* ai) { return new UseHealingPotion(ai); }
+        static Action* healthstone(PlayerbotAI* ai) { return new UseItemAction(ai, "healthstone"); }
+        static Action* move_out_of_enemy_contact(PlayerbotAI* ai) { return new MoveOutOfEnemyContactAction(ai); }
+        static Action* set_facing(PlayerbotAI* ai) { return new SetFacingTargetAction(ai); }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.cpp b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
new file mode 100644
index 0000000..4d2c3ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AddLootAction.h"
+
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AddLootAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+    if (!guid)
+        return false;
+
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddAllLootAction::Execute(Event event)
+{
+    bool added = false;
+
+    list<ObjectGuid> gos = context->GetValue<list<ObjectGuid> >("nearest game objects")->Get();
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        added |= AddLoot(*i);
+
+    list<ObjectGuid> corpses = context->GetValue<list<ObjectGuid> >("nearest corpses")->Get();
+    for (list<ObjectGuid>::iterator i = corpses.begin(); i != corpses.end(); i++)
+        added |= AddLoot(*i);
+
+    return added;
+}
+
+bool AddLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::AddLoot(ObjectGuid guid)
+{
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddGatheringLootAction::AddLoot(ObjectGuid guid)
+{
+    LootObject loot(bot, guid);
+
+    if (loot.IsEmpty() || !loot.GetWorldObject(bot))
+        return false;
+
+    if (loot.skillId == SKILL_NONE)
+        return false;
+
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return AddAllLootAction::AddLoot(guid);
+}
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.h b/src/plugins/playerbot/strategy/actions/AddLootAction.h
new file mode 100644
index 0000000..402c50a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AddLootAction : public Action {
+    public:
+        AddLootAction(PlayerbotAI* ai) : Action(ai, "add loot") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class AddAllLootAction : public Action {
+    public:
+        AddAllLootAction(PlayerbotAI* ai, string name = "add all loot") : Action(ai, name) {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+    class AddGatheringLootAction : public AddAllLootAction {
+    public:
+        AddGatheringLootAction(PlayerbotAI* ai) : AddAllLootAction(ai, "add gathering loot") {}
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
new file mode 100644
index 0000000..45518b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
@@ -0,0 +1,80 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AreaTriggerAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool ReachAreaTriggerAction::Execute(Event event)
+{
+    uint32 triggerId;
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    p >> triggerId;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+    {
+        WorldPacket p1(CMSG_AREATRIGGER);
+        p1 << triggerId;
+        p1.rpos(0);
+        bot->GetSession()->HandleAreaTriggerOpcode(p1);
+
+        return true;
+    }
+
+    if (bot->GetMapId() != atEntry->mapid || bot->GetDistance(atEntry->x, atEntry->y, atEntry->z) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I won't follow: too far away");
+        return true;
+    }
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+	mm.MovePoint(atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
+    float distance = bot->GetDistance(atEntry->x, atEntry->y, atEntry->z);
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+    ai->TellMaster("Wait for me");
+    ai->SetNextCheckDelay(delay);
+    context->GetValue<LastMovement&>("last movement")->Get().lastAreaTrigger = triggerId;
+
+    return true;
+}
+
+
+
+bool AreaTriggerAction::Execute(Event event)
+{
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    uint32 triggerId = movement.lastAreaTrigger;
+    movement.lastAreaTrigger = 0;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+        return true;
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+
+    WorldPacket p(CMSG_AREATRIGGER);
+    p << triggerId;
+    p.rpos(0);
+    bot->GetSession()->HandleAreaTriggerOpcode(p);
+
+    ai->TellMaster("Hello");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
new file mode 100644
index 0000000..de2b63a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class ReachAreaTriggerAction : public MovementAction {
+    public:
+        ReachAreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "reach area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class AreaTriggerAction : public MovementAction {
+    public:
+        AreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.cpp b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
new file mode 100644
index 0000000..ded8aab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
@@ -0,0 +1,104 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackAction.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../../game/AI/CreatureAI.h"
+#include "../../../Entities/Pet/Pet.h"
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AttackAction::Execute(Event event)
+{
+    Unit* target = GetTarget();
+
+    if (!target)
+        return false;
+
+    return Attack(target);
+}
+
+bool AttackMyTargetAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("You have no target");
+        return false;
+    }
+
+    return Attack(target);
+}
+
+bool AttackAction::Attack(Unit* target)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (bot->IsFlying())
+    {
+        if (verbose) ai->TellMaster("I cannot attack in flight");
+        return false;
+    }
+
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("I have no target");
+        return false;
+    }
+
+    ostringstream msg;
+    msg << target->GetName();
+    if (bot->IsFriendlyTo(target))
+    {
+        msg << " is friendly to me";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+    if (!bot->IsWithinLOSInMap(target))
+    {
+        msg << " is not on my sight";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+
+    if (bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+
+    ObjectGuid guid = target->GetGUID();
+    bot->SetSelection(target->GetGUID());
+
+    Unit* oldTarget = context->GetValue<Unit*>("current target")->Get();
+    context->GetValue<Unit*>("old target")->Set(oldTarget);
+
+    context->GetValue<Unit*>("current target")->Set(target);
+    context->GetValue<LootObjectStack*>("available loot")->Get()->Add(guid);
+
+    Pet* pet = bot->GetPet();
+    if (pet)
+    {
+        pet->SetTarget(target->GetGUID());
+        pet->AI()->EnterCombat(target);
+		pet->GetCharmInfo()->SetIsCommandAttack(true);
+		pet->AI()->AttackStart(target);
+    }
+
+    bot->Attack(target, true);
+    ai->ChangeEngine(BOT_STATE_COMBAT);
+    return true;
+}
+
+bool AttackDuelOpponentAction::isUseful()
+{
+    return AI_VALUE(Unit*, "duel target");
+}
+
+bool AttackDuelOpponentAction::Execute(Event event)
+{
+    return Attack(AI_VALUE(Unit*, "duel target"));
+}
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.h b/src/plugins/playerbot/strategy/actions/AttackAction.h
new file mode 100644
index 0000000..ede665d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class AttackAction : public MovementAction
+	{
+	public:
+		AttackAction(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Attack(Unit* target);
+    };
+
+    class AttackMyTargetAction : public AttackAction
+    {
+    public:
+        AttackMyTargetAction(PlayerbotAI* ai, string name = "attack my target") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class AttackDuelOpponentAction : public AttackAction
+    {
+    public:
+        AttackDuelOpponentAction(PlayerbotAI* ai, string name = "attack duel opponent") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.cpp b/src/plugins/playerbot/strategy/actions/BankAction.cpp
new file mode 100644
index 0000000..c7254be
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.cpp
@@ -0,0 +1,168 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BankAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace std;
+using namespace ai;
+
+bool BankAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (!npc || !bot->GetNPCIfCanInteractWith(npc->GetGUID(), UNIT_NPC_FLAG_BANKER))
+            continue;
+
+        return Execute(text, npc);
+    }
+
+    ai->TellMaster("Cannot find banker nearby");
+    return false;
+}
+
+bool BankAction::Execute(string text, Unit* bank)
+{
+    if (text.empty() || text == "?")
+    {
+        ListItems();
+        return true;
+    }
+
+    bool result = false;
+    if (text[0] == '-')
+    {
+        ItemIds found = chat->parseItems(text);
+        for (ItemIds::iterator i = found.begin(); i != found.end(); i++)
+        {
+            uint32 itemId = *i;
+            result &= Withdraw(itemId);
+        }
+    }
+    else
+    {
+        list<Item*> found = parseItems(text);
+        if (found.empty())
+            return false;
+
+        for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        {
+            Item* item = *i;
+            if (!item)
+                continue;
+
+            result &= Deposit(item);
+        }
+    }
+
+    return result;
+}
+
+bool BankAction::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (!pItem)
+        return false;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->StoreItem(dest, pItem, true);
+
+    std::ostringstream out;
+    out << "got " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " from bank";
+    ai->TellMaster(out.str());
+    return true;
+}
+
+bool BankAction::Deposit(Item* pItem)
+{
+    std::ostringstream out;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->BankItem(dest, pItem, true);
+
+    out << "put " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " to bank";
+    ai->TellMaster(out.str());
+	return true;
+}
+
+void BankAction::ListItems()
+{
+    ai->TellMaster("=== Bank ===");
+
+    map<uint32, int> items;
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = static_cast<Bag *>(bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = bot->GetItemByPos(bag, slot);
+                if (item)
+                    items[item->GetTemplate()->ItemId] = item->GetCount();
+            }
+        }
+    }
+
+    TellItems(items);
+}
+
+Item* BankAction::FindItemInBank(uint32 ItemId)
+{
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.h b/src/plugins/playerbot/strategy/actions/BankAction.h
new file mode 100644
index 0000000..6b22095
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BankAction : public InventoryAction {
+    public:
+        BankAction(PlayerbotAI* ai) : InventoryAction(ai, "bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, Unit* bank);
+        void ListItems();
+        bool Withdraw(const uint32 itemid);
+        bool Deposit(Item* pItem);
+        Item* FindItemInBank(uint32 ItemId);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.cpp b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
new file mode 100644
index 0000000..0675f2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuffAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+class FindBuffVisitor : public IterateItemsVisitor {
+public:
+    FindBuffVisitor(Player* bot) : IterateItemsVisitor(), bot(bot)
+    {
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        if (bot->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+            return true;
+
+        const ItemTemplate* proto = item->GetTemplate();
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        if (proto->SubClass != ITEM_SUBCLASS_ELIXIR && 
+            proto->SubClass != ITEM_SUBCLASS_FLASK &&
+            proto->SubClass != ITEM_SUBCLASS_SCROLL && 
+            proto->SubClass != ITEM_SUBCLASS_FOOD &&
+            proto->SubClass != ITEM_SUBCLASS_CONSUMABLE_OTHER &&
+            proto->SubClass != ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+            return true;
+
+        for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+        {
+            uint32 spellId = proto->Spells[i].SpellId;
+            if (!spellId)
+                continue;
+
+            if (bot->HasAura(spellId))
+                return true;
+
+            Item* itemForSpell = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<Item*>("item for spell", spellId);
+            if (itemForSpell && itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                return true;
+        
+            if (items.find(proto->SubClass) == items.end())
+                items[proto->SubClass] = list<Item*>();
+
+            items[proto->SubClass].push_back(item);
+            break;
+        }
+
+        return true;
+    }
+
+public:
+    map<uint32, list<Item*> > items;
+
+private:
+    Player* bot;
+};
+
+void BuffAction::TellHeader(uint32 subClass)
+{
+    switch (subClass)
+    {
+    case ITEM_SUBCLASS_ELIXIR:
+        ai->TellMaster("--- Elixir ---");
+        return;
+    case ITEM_SUBCLASS_FLASK:
+        ai->TellMaster("--- Flask ---");
+        return;
+    case ITEM_SUBCLASS_SCROLL:
+        ai->TellMaster("--- Scroll ---");
+        return;
+    case ITEM_SUBCLASS_FOOD:
+        ai->TellMaster("--- Food ---");
+        return;
+    case ITEM_SUBCLASS_GENERIC:
+        ai->TellMaster("--- Other ---");
+        return;
+    case ITEM_SUBCLASS_ITEM_ENHANCEMENT:
+        ai->TellMaster("--- Enchant ---");
+        return;
+    }
+}
+
+
+bool BuffAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    FindBuffVisitor visitor(bot);
+    IterateItems(&visitor);
+
+    uint32 oldSubClass = -1;
+    for (map<uint32, list<Item*> >::iterator i = visitor.items.begin(); i != visitor.items.end(); ++i)
+    {
+        list<Item*> items = i->second;
+
+        uint32 subClass = i->first;
+        if (oldSubClass != subClass)
+        {
+            if (!items.empty())
+                TellHeader(subClass);
+            oldSubClass = subClass;
+        }
+        for (list<Item*>::iterator j = items.begin(); j != items.end(); ++j)
+        {
+            Item* item = *j;
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate(), item->GetCount());
+            ai->TellMaster(out);
+        }
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.h b/src/plugins/playerbot/strategy/actions/BuffAction.h
new file mode 100644
index 0000000..da8b6a6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuffAction : public InventoryAction {
+    public:
+        BuffAction(PlayerbotAI* ai) : InventoryAction(ai, "buff") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellHeader(uint32 subClass);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.cpp b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
new file mode 100644
index 0000000..20d9cea
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuyAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool BuyAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(vendor->GetGUID(), UNIT_NPC_FLAG_VENDOR);
+    if (!pCreature)
+    {
+        ai->TellMaster("Cannot talk to vendor");
+        return false;
+    }
+
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+    if (!tItems)
+    {
+        ai->TellMaster("This vendor has no items");
+        return false;
+    }
+
+    for (ItemIds::iterator i = itemIds.begin(); i != itemIds.end(); i++)
+    {
+        for (uint32 slot = 0; slot < tItems->GetItemCount(); slot++)
+        {
+            if (tItems->GetItem(slot)->item == *i)
+            {
+                bot->BuyItemFromVendorSlot(vendor->GetGUID(), slot, *i, 1, NULL_BAG, NULL_SLOT);
+                ai->TellMaster("Bought item");
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.h b/src/plugins/playerbot/strategy/actions/BuyAction.h
new file mode 100644
index 0000000..2e0822c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuyAction : public InventoryAction {
+    public:
+        BuyAction(PlayerbotAI* ai) : InventoryAction(ai, "buy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(FindItemVisitor *visitor, int8 slot);
+        bool TradeItem(const Item& item, int8 slot);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
new file mode 100644
index 0000000..1edde62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
@@ -0,0 +1,41 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastCustomSpellAction.h"
+
+using namespace ai;
+
+bool CastCustomSpellAction::Execute(Event event)
+{
+    Unit* target = NULL;
+
+    Player* master = GetMaster();
+    if (master)
+        target = master->GetSelectedUnit();
+
+    if (!target)
+        target = bot;
+
+    string text = event.getParam();
+
+    uint32 spell = chat->parseSpell(text);
+
+    bool result = false;
+    if (spell)
+        result = ai->CastSpell(spell, target);
+    else
+        ai->CastSpell(text, target);
+
+    ostringstream msg;
+    if (result)
+    {
+        msg << "Casting " << text << " on " << target->GetName();
+        ai->TellMasterNoFacing(msg.str());
+    }
+    else
+    {
+        msg << "Cast " << text << " on " << target->GetName() << " is failed";
+        ai->TellMaster(msg.str());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
new file mode 100644
index 0000000..976a9e4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CastCustomSpellAction : public Action
+    {
+    public:
+        CastCustomSpellAction(PlayerbotAI* ai) : Action(ai, "cast custom spell") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
new file mode 100644
index 0000000..32328db
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeChatAction.h"
+
+
+using namespace ai;
+
+
+bool ChangeChatAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ChatMsg parsed = chat->parseChat(text);
+    if (parsed == CHAT_MSG_SYSTEM)
+    {
+        ostringstream out; out << "Current chat is " << chat->formatChat(*context->GetValue<ChatMsg>("chat"));
+        ai->TellMaster(out);
+    }
+    else
+    {
+        context->GetValue<ChatMsg>("chat")->Set(parsed);
+        ostringstream out; out << "Chat set to " << chat->formatChat(parsed);
+        ai->TellMaster(out);
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.h b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
new file mode 100644
index 0000000..450a81a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ChangeChatAction : public Action {
+    public:
+        ChangeChatAction(PlayerbotAI* ai) : Action(ai, "chat") {}
+        virtual bool Execute(Event event);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
new file mode 100644
index 0000000..64538cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeStrategyAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ChangeCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text.empty() ? getName() : text, BOT_STATE_COMBAT);
+    return true;
+}
+
+bool ChangeNonCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        if (text.find("loot") != string::npos || text.find("gather") != string::npos)
+        {
+            ai->TellMaster("You can change any strategy except loot and gather");
+            return false;
+        }
+    }
+
+    ai->ChangeStrategy(text, BOT_STATE_NON_COMBAT);
+    return true;
+}
+
+bool ChangeDeadStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text, BOT_STATE_DEAD);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
new file mode 100644
index 0000000..9c3f4c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeCombatStrategyAction : public Action {
+	public:
+		ChangeCombatStrategyAction(PlayerbotAI* ai, string name = "co") : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeNonCombatStrategyAction : public Action {
+    public:
+        ChangeNonCombatStrategyAction(PlayerbotAI* ai) : Action(ai, "nc") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeDeadStrategyAction : public Action {
+    public:
+        ChangeDeadStrategyAction(PlayerbotAI* ai) : Action(ai, "dead") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
new file mode 100644
index 0000000..3a7dc71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeTalentsAction.h"
+
+using namespace ai;
+
+bool ChangeTalentsAction::Execute(Event event)
+{
+    
+
+    string text = event.getParam();
+    if (text == "1" || text == "primary")
+    {
+        bot->ActivateSpec(0);
+        ai->TellMaster("Primary talents activated");
+    }
+    else if (text == "2" || text == "secondary")
+    {
+        bot->ActivateSpec(1);
+        ai->TellMaster("Secondary talents activated");
+    }
+    else
+    {
+        ostringstream out; 
+        switch (bot->GetActiveSpec())
+        {
+        case 0: out << "Primary";
+            break;
+        default: out << "Secondary";
+            break;
+        }
+        out << " talents are active";
+        ai->TellMaster(out);
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
new file mode 100644
index 0000000..dd9941a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeTalentsAction : public Action {
+	public:
+		ChangeTalentsAction(PlayerbotAI* ai) : Action(ai, "talents") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChatActionContext.h b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
new file mode 100644
index 0000000..6a0ab6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
@@ -0,0 +1,184 @@
+#pragma once
+
+#include "ListQuestsActions.h"
+#include "StatsAction.h"
+#include "LeaveGroupAction.h"
+#include "TellReputationAction.h"
+#include "LogLevelAction.h"
+#include "TellLosAction.h"
+#include "DropQuestAction.h"
+#include "QueryQuestAction.h"
+#include "QueryItemUsageAction.h"
+#include "LootStrategyAction.h"
+#include "AddLootAction.h"
+#include "ReleaseSpiritAction.h"
+#include "TeleportAction.h"
+#include "TaxiAction.h"
+#include "RepairAllAction.h"
+#include "UseItemAction.h"
+#include "TellItemCountAction.h"
+#include "RewardAction.h"
+#include "BuyAction.h"
+#include "SellAction.h"
+#include "UnequipAction.h"
+#include "EquipAction.h"
+#include "TradeAction.h"
+#include "ChangeTalentsAction.h"
+#include "ListSpellsAction.h"
+#include "ChangeStrategyAction.h"
+#include "TrainerAction.h"
+#include "ChangeChatAction.h"
+#include "SetHomeAction.h"
+#include "ResetAiAction.h"
+#include "DestroyItemAction.h"
+#include "BuffAction.h"
+#include "AttackAction.h"
+#include "HelpAction.h"
+#include "GuildBankAction.h"
+#include "ChatShortcutActions.h"
+#include "GossipHelloAction.h"
+#include "CastCustomSpellAction.h"
+#include "InviteToGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "RtiAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "BankAction.h"
+#include "PositionAction.h"
+#include "TellTargetAction.h"
+#include "UseMeetingStoneAction.h"
+#include "WhoAction.h"
+#include "SaveManaAction.h"
+#include "../values/Formations.h"
+
+namespace ai
+{
+    class ChatActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ChatActionContext()
+        {
+            creators["stats"] = &ChatActionContext::stats;
+            creators["quests"] = &ChatActionContext::quests;
+            creators["leave"] = &ChatActionContext::leave;
+            creators["reputation"] = &ChatActionContext::reputation;
+            creators["log"] = &ChatActionContext::log;
+            creators["los"] = &ChatActionContext::los;
+            creators["drop"] = &ChatActionContext::drop;
+            creators["query quest"] = &ChatActionContext::query_quest;
+            creators["query item usage"] = &ChatActionContext::query_item_usage;
+            creators["ll"] = &ChatActionContext::ll;
+            creators["add all loot"] = &ChatActionContext::add_all_loot;
+            creators["release"] = &ChatActionContext::release;
+            creators["teleport"] = &ChatActionContext::teleport;
+            creators["taxi"] = &ChatActionContext::taxi;
+            creators["repair"] = &ChatActionContext::repair;
+            creators["use"] = &ChatActionContext::use;
+            creators["item count"] = &ChatActionContext::item_count;
+            creators["equip"] = &ChatActionContext::equip;
+            creators["unequip"] = &ChatActionContext::unequip;
+            creators["sell"] = &ChatActionContext::sell;
+            creators["buy"] = &ChatActionContext::buy;
+            creators["reward"] = &ChatActionContext::reward;
+            creators["trade"] = &ChatActionContext::trade;
+            creators["talents"] = &ChatActionContext::talents;
+            creators["spells"] = &ChatActionContext::spells;
+            creators["co"] = &ChatActionContext::co;
+            creators["nc"] = &ChatActionContext::nc;
+            creators["dead"] = &ChatActionContext::dead;
+            creators["trainer"] = &ChatActionContext::trainer;
+            creators["attack my target"] = &ChatActionContext::attack_my_target;
+            creators["chat"] = &ChatActionContext::chat;
+            creators["home"] = &ChatActionContext::home;
+            creators["destroy"] = &ChatActionContext::destroy;
+            creators["reset ai"] = &ChatActionContext::reset_ai;
+            creators["buff"] = &ChatActionContext::buff;
+            creators["help"] = &ChatActionContext::help;
+            creators["gb"] = &ChatActionContext::gb;
+            creators["bank"] = &ChatActionContext::bank;
+            creators["follow chat shortcut"] = &ChatActionContext::follow_chat_shortcut;
+            creators["stay chat shortcut"] = &ChatActionContext::stay_chat_shortcut;
+            creators["flee chat shortcut"] = &ChatActionContext::flee_chat_shortcut;
+            creators["runaway chat shortcut"] = &ChatActionContext::runaway_chat_shortcut;
+            creators["grind chat shortcut"] = &ChatActionContext::grind_chat_shortcut;
+            creators["tank attack chat shortcut"] = &ChatActionContext::tank_attack_chat_shortcut;
+            creators["gossip hello"] = &ChatActionContext::gossip_hello;
+            creators["cast custom spell"] = &ChatActionContext::cast_custom_spell;
+            creators["invite"] = &ChatActionContext::invite;
+            creators["spell"] = &ChatActionContext::spell;
+            creators["rti"] = &ChatActionContext::rti;
+            creators["spirit healer"] = &ChatActionContext::spirit_healer;
+            creators["position"] = &ChatActionContext::position;
+            creators["tell target"] = &ChatActionContext::tell_target;
+            creators["summon"] = &ChatActionContext::summon;
+            creators["who"] = &ChatActionContext::who;
+            creators["save mana"] = &ChatActionContext::save_mana;
+            creators["max dps chat shortcut"] = &ChatActionContext::max_dps_chat_shortcut;
+            creators["tell attackers"] = &ChatActionContext::tell_attackers;
+            creators["formation"] = &ChatActionContext::formation;
+        }
+
+    private:
+        static Action* formation(PlayerbotAI* ai) { return new SetFormationAction(ai); }
+        static Action* tell_attackers(PlayerbotAI* ai) { return new TellAttackersAction(ai); }
+        static Action* max_dps_chat_shortcut(PlayerbotAI* ai) { return new MaxDpsChatShortcutAction(ai); }
+        static Action* save_mana(PlayerbotAI* ai) { return new SaveManaAction(ai); }
+        static Action* who(PlayerbotAI* ai) { return new WhoAction(ai); }
+        static Action* summon(PlayerbotAI* ai) { return new SummonAction(ai); }
+        static Action* tell_target(PlayerbotAI* ai) { return new TellTargetAction(ai); }
+        static Action* position(PlayerbotAI* ai) { return new PositionAction(ai); }
+        static Action* spirit_healer(PlayerbotAI* ai) { return new SpiritHealerAction(ai); }
+        static Action* rti(PlayerbotAI* ai) { return new RtiAction(ai); }
+        static Action* invite(PlayerbotAI* ai) { return new InviteToGroupAction(ai); }
+        static Action* spell(PlayerbotAI* ai) { return new TellSpellAction(ai); }
+        static Action* cast_custom_spell(PlayerbotAI* ai) { return new CastCustomSpellAction(ai); }
+        static Action* tank_attack_chat_shortcut(PlayerbotAI* ai) { return new TankAttackChatShortcutAction(ai); }
+        static Action* grind_chat_shortcut(PlayerbotAI* ai) { return new GrindChatShortcutAction(ai); }
+        static Action* flee_chat_shortcut(PlayerbotAI* ai) { return new FleeChatShortcutAction(ai); }
+        static Action* runaway_chat_shortcut(PlayerbotAI* ai) { return new GoawayChatShortcutAction(ai); }
+        static Action* stay_chat_shortcut(PlayerbotAI* ai) { return new StayChatShortcutAction(ai); }
+        static Action* follow_chat_shortcut(PlayerbotAI* ai) { return new FollowChatShortcutAction(ai); }
+        static Action* gb(PlayerbotAI* ai) { return new GuildBankAction(ai); }
+        static Action* bank(PlayerbotAI* ai) { return new BankAction(ai); }
+        static Action* help(PlayerbotAI* ai) { return new HelpAction(ai); }
+        static Action* buff(PlayerbotAI* ai) { return new BuffAction(ai); }
+        static Action* destroy(PlayerbotAI* ai) { return new DestroyItemAction(ai); }
+        static Action* home(PlayerbotAI* ai) { return new SetHomeAction(ai); }
+        static Action* chat(PlayerbotAI* ai) { return new ChangeChatAction(ai); }
+        static Action* attack_my_target(PlayerbotAI* ai) { return new AttackMyTargetAction(ai); }
+        static Action* trainer(PlayerbotAI* ai) { return new TrainerAction(ai); }
+        static Action* co(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai); }
+        static Action* nc(PlayerbotAI* ai) { return new ChangeNonCombatStrategyAction(ai); }
+        static Action* dead(PlayerbotAI* ai) { return new ChangeDeadStrategyAction(ai); }
+        static Action* spells(PlayerbotAI* ai) { return new ListSpellsAction(ai); }
+        static Action* talents(PlayerbotAI* ai) { return new ChangeTalentsAction(ai); }
+
+        static Action* equip(PlayerbotAI* ai) { return new EquipAction(ai); }
+        static Action* unequip(PlayerbotAI* ai) { return new UnequipAction(ai); }
+        static Action* sell(PlayerbotAI* ai) { return new SellAction(ai); }
+        static Action* buy(PlayerbotAI* ai) { return new BuyAction(ai); }
+        static Action* reward(PlayerbotAI* ai) { return new RewardAction(ai); }
+        static Action* trade(PlayerbotAI* ai) { return new TradeAction(ai); }
+
+        static Action* item_count(PlayerbotAI* ai) { return new TellItemCountAction(ai); }
+        static Action* use(PlayerbotAI* ai) { return new UseItemAction(ai); }
+        static Action* repair(PlayerbotAI* ai) { return new RepairAllAction(ai); }
+        static Action* taxi(PlayerbotAI* ai) { return new TaxiAction(ai); }
+        static Action* teleport(PlayerbotAI* ai) { return new TeleportAction(ai); }
+        static Action* release(PlayerbotAI* ai) { return new ReleaseSpiritAction(ai); }
+        static Action* query_item_usage(PlayerbotAI* ai) { return new QueryItemUsageAction(ai); }
+        static Action* query_quest(PlayerbotAI* ai) { return new QueryQuestAction(ai); }
+        static Action* drop(PlayerbotAI* ai) { return new DropQuestAction(ai); }
+        static Action* stats(PlayerbotAI* ai) { return new StatsAction(ai); }
+        static Action* quests(PlayerbotAI* ai) { return new ListQuestsAction(ai); }
+        static Action* leave(PlayerbotAI* ai) { return new LeaveGroupAction(ai); }
+        static Action* reputation(PlayerbotAI* ai) { return new TellReputationAction(ai); }
+        static Action* log(PlayerbotAI* ai) { return new LogLevelAction(ai); }
+        static Action* los(PlayerbotAI* ai) { return new TellLosAction(ai); }
+        static Action* ll(PlayerbotAI* ai) { return new LootStrategyAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* reset_ai(PlayerbotAI* ai) { return new ResetAiAction(ai); }
+        static Action* gossip_hello(PlayerbotAI* ai) { return new GossipHelloAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
new file mode 100644
index 0000000..e0c3f12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
@@ -0,0 +1,108 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatShortcutActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool FollowChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not follow you - too far away");
+        return true;
+    }
+    ai->TellMaster("Following");
+    return true;
+}
+
+bool StayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+stay,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Staying");
+    return true;
+}
+
+bool FleeChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not flee with you - too far away");
+        return true;
+    }
+    ai->TellMaster("Fleeing");
+    return true;
+}
+
+bool GoawayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+runaway", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+runaway", BOT_STATE_COMBAT);
+    ai->TellMaster("Running away");
+    return true;
+}
+
+bool GrindChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+grind,-passive", BOT_STATE_NON_COMBAT);
+    ai->TellMaster("Grinding");
+    return true;
+}
+
+bool TankAttackChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!ai->IsTank(bot))
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Attacking");
+    return true;
+}
+
+bool MaxDpsChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-threat,-conserve mana,-cast time,+dps debuff", BOT_STATE_COMBAT);
+    ai->TellMaster("Max DPS");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
new file mode 100644
index 0000000..de9a86a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class FollowChatShortcutAction : public Action
+    {
+    public:
+        FollowChatShortcutAction(PlayerbotAI* ai) : Action(ai, "follow chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class StayChatShortcutAction : public Action
+    {
+    public:
+        StayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "stay chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class FleeChatShortcutAction : public Action
+    {
+    public:
+        FleeChatShortcutAction(PlayerbotAI* ai) : Action(ai, "flee chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GoawayChatShortcutAction : public Action
+    {
+    public:
+        GoawayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "runaway chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GrindChatShortcutAction : public Action
+    {
+    public:
+        GrindChatShortcutAction(PlayerbotAI* ai) : Action(ai, "grind chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TankAttackChatShortcutAction : public Action
+    {
+    public:
+        TankAttackChatShortcutAction(PlayerbotAI* ai) : Action(ai, "tank attack chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MaxDpsChatShortcutAction : public Action
+    {
+    public:
+        MaxDpsChatShortcutAction(PlayerbotAI* ai) : Action(ai, "max dps chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
new file mode 100644
index 0000000..3c94f97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
@@ -0,0 +1,79 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../../Spells/Auras/SpellAuraEffects.h"
+#include "CheckMountStateAction.h"
+
+using namespace ai;
+
+uint64 extractGuid(WorldPacket& packet);
+
+bool CheckMountStateAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!bot->GetGroup() || !master)
+        return false;
+
+    if (bot->IsFlying())
+        return false;
+
+    if (master->IsMounted() && !bot->IsMounted())
+    {
+        return Mount();
+    }
+    else if (!master->IsMounted() && bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+        return true;
+    }
+    return false;
+}
+
+
+bool CheckMountStateAction::Mount()
+{
+    Player* master = GetMaster();
+    ai->RemoveShapeshift();
+
+    Unit::AuraEffectList const& auras = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    const SpellInfo* masterSpell = auras.front()->GetSpellInfo();
+    int32 masterSpeed = max(masterSpell->Effects[1].BasePoints, masterSpell->Effects[2].BasePoints);
+
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < masterSpeed)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    int masterMountType = (masterSpell->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+            masterSpell->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+
+    map<int32, vector<uint32> >& spells = allSpells[masterMountType];
+    for (map<int32,vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+		vector<uint32>& ids = i->second;
+        int index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        ai->CastSpell(ids[index], bot);
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
new file mode 100644
index 0000000..c5b087e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class CheckMountStateAction : public Action {
+    public:
+        CheckMountStateAction(PlayerbotAI* ai) : Action(ai, "check mount state") {}
+
+        virtual bool Execute(Event event);
+
+    private:
+        bool Mount();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
new file mode 100644
index 0000000..62b64b1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
@@ -0,0 +1,78 @@
+#pragma once
+
+#include "../Action.h"
+#include "AttackAction.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+
+namespace ai
+{
+    class DpsAssistAction : public AttackAction
+    {
+    public:
+        DpsAssistAction(PlayerbotAI* ai) : AttackAction(ai, "dps assist") {}
+
+        virtual string GetTargetName() { return "dps target"; }
+    };
+
+    class TankAssistAction : public AttackAction
+    {
+    public:
+        TankAssistAction(PlayerbotAI* ai) : AttackAction(ai, "tank assist") {}
+        virtual string GetTargetName() { return "tank target"; }
+    };
+
+    class AttackAnythingAction : public AttackAction
+    {
+    public:
+        AttackAnythingAction(PlayerbotAI* ai) : AttackAction(ai, "attack anything") {}
+        virtual string GetTargetName() { return "grind target"; }
+        virtual bool Execute(Event event)
+        {
+            return AttackAction::Execute(event);
+        }
+        virtual bool isUseful() { return GetTarget(); }
+        virtual bool isPossible()
+        {
+            return AttackAction::isPossible() && GetTarget() &&
+                    AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                    (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana);
+        }
+    };
+
+    class AttackLeastHpTargetAction : public AttackAction
+    {
+    public:
+        AttackLeastHpTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack least hp target") {}
+        virtual string GetTargetName() { return "least hp target"; }
+    };
+
+    class AttackEnemyPlayerAction : public AttackAction
+    {
+    public:
+        AttackEnemyPlayerAction(PlayerbotAI* ai) : AttackAction(ai, "attack enemy player") {}
+        virtual string GetTargetName() { return "enemy player target"; }
+    };
+
+    class AttackRtiTargetAction : public AttackAction
+    {
+    public:
+        AttackRtiTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack rti target") {}
+        virtual string GetTargetName() { return "rti target"; }
+    };
+
+    class DropTargetAction : public Action
+    {
+    public:
+        DropTargetAction(PlayerbotAI* ai) : Action(ai, "drop target") {}
+
+        virtual bool Execute(Event event)
+        {
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid());
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            ai->InterruptSpell();
+			return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
new file mode 100644
index 0000000..9167182
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DestroyItemAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool DestroyItemAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        DestroyItem(&visitor);
+    }
+
+    return true;
+}
+
+void DestroyItemAction::DestroyItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+		Item* item = *i;
+        bot->DestroyItem(item->GetBagSlot(),item->GetSlot(), true);
+        ostringstream out; out << chat->formatItem(item->GetTemplate()) << " destroyed";
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.h b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
new file mode 100644
index 0000000..ad1ab05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class DestroyItemAction : public InventoryAction {
+    public:
+        DestroyItemAction(PlayerbotAI* ai) : InventoryAction(ai, "destroy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void DestroyItem(FindItemVisitor* visitor);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
new file mode 100644
index 0000000..e94e779
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DropQuestAction.h"
+
+
+using namespace ai;
+
+bool DropQuestAction::Execute(Event event)
+{
+    string link = event.getParam();
+    if (!GetMaster())
+        return false;
+
+    PlayerbotChatHandler handler(GetMaster());
+    uint32 entry = handler.extractQuestId(link);
+    if (!entry)
+        return false;
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+    if (!quest)
+        return false;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 logQuest = bot->GetQuestSlotQuestId(slot);
+        if (logQuest == entry)
+        {
+            bot->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            bot->TakeQuestSourceItem(logQuest, false);
+
+            if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
+            {
+                bot->pvpInfo.IsHostile = bot->pvpInfo.IsInHostileArea || bot->HasPvPForcingQuest();
+                bot->UpdatePvPState();
+            }
+        }
+    }
+
+    bot->RemoveActiveQuest(entry, false);
+    bot->RemoveRewardedQuest(entry);
+
+    ai->TellMaster("Quest removed");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.h b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
new file mode 100644
index 0000000..af5d4ca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class DropQuestAction : public Action {
+    public:
+        DropQuestAction(PlayerbotAI* ai) : Action(ai, "drop quest") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.cpp b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
new file mode 100644
index 0000000..b609032
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteAction.h"
+
+using namespace ai;
+
+map<string, uint32> EmoteAction::emotes;
+
+bool EmoteAction::Execute(Event event)
+{
+    if (emotes.empty())
+        InitEmotes();
+
+    uint32 emote = 0;
+
+    string param = event.getParam();
+	if (param.empty() || emotes.find(param) == emotes.end())
+    {
+        int index = rand() % emotes.size();
+		for (map<string, uint32>::iterator i = emotes.begin(); i != emotes.end() && index; ++i, --index)
+			emote = i->second;
+    }
+    else
+    {
+        emote = emotes[param];
+    }
+
+	bot->CastStop();
+	ai->InterruptSpell();
+	bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Player* master = GetMaster();
+	if (master)
+	{
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            Unit* oldSelection = bot->GetSelectedUnit();
+            bot->SetSelection(masterSelection->GetGUID());
+            bot->HandleEmoteCommand(emote);
+            if (oldSelection)
+                bot->SetSelection(oldSelection->GetGUID());
+            return true;
+        }
+	}
+
+    bot->HandleEmoteCommand(emote);
+    return true;
+}
+
+void EmoteAction::InitEmotes()
+{
+    emotes["cower"] = EMOTE_ONESHOT_COWER;
+    emotes["dance"] = EMOTE_ONESHOT_DANCE;
+    emotes["drown"] = EMOTE_ONESHOT_DROWN;
+    emotes["emerge"] = EMOTE_ONESHOT_EMERGE;
+    emotes["land"] = EMOTE_ONESHOT_LAND;
+    emotes["laugh_nosheathe"] = EMOTE_ONESHOT_LAUGH_NO_SHEATHE;
+    emotes["liftoff"] = EMOTE_ONESHOT_LIFTOFF;
+    emotes["loot"] = EMOTE_ONESHOT_LOOT;
+    emotes["no"] = EMOTE_ONESHOT_NO;
+    emotes["one_shot_stun"] = EMOTE_ONESHOT_STUN;
+    emotes["point_nosheathe"] = EMOTE_ONESHOT_POINT_NO_SHEATHE;
+    emotes["roar"] = EMOTE_STATE_ROAR;
+    emotes["salute"] = EMOTE_ONESHOT_SALUTE;
+    emotes["stomp"] = EMOTE_ONESHOT_STOMP;
+    emotes["train"] = EMOTE_ONESHOT_TRAIN;
+    emotes["yes"] = EMOTE_ONESHOT_YES;
+    emotes["applaud"] = EMOTE_ONESHOT_APPLAUD;
+    emotes["battleroar"] = EMOTE_ONESHOT_BATTLE_ROAR;
+    emotes["beg"] = EMOTE_ONESHOT_BEG;
+    emotes["bow"] = EMOTE_ONESHOT_BOW;
+    emotes["cheer"] = EMOTE_ONESHOT_CHEER;
+    emotes["chicken"] = EMOTE_ONESHOT_CHICKEN;
+    emotes["cry"] = EMOTE_ONESHOT_CRY;
+    emotes["dance"] = EMOTE_STATE_DANCE;
+    emotes["eat"] = EMOTE_ONESHOT_EAT;
+    emotes["exclamation"] = EMOTE_ONESHOT_EXCLAMATION;
+    emotes["flex"] = EMOTE_ONESHOT_FLEX;
+    emotes["kick"] = EMOTE_ONESHOT_KICK;
+    emotes["kiss"] = EMOTE_ONESHOT_KISS;
+    emotes["kneel"] = EMOTE_ONESHOT_KNEEL;
+    emotes["laugh"] = EMOTE_ONESHOT_LAUGH;
+    emotes["parryshield"] = EMOTE_ONESHOT_PARRY_SHIELD;
+    emotes["parryunarmed"] = EMOTE_ONESHOT_PARRY_UNARMED;
+    emotes["point"] = EMOTE_ONESHOT_POINT;
+    emotes["question"] = EMOTE_ONESHOT_QUESTION;
+    emotes["ready1h"] = EMOTE_ONESHOT_READY1H;
+    emotes["readybow"] = EMOTE_ONESHOT_READY_BOW;
+    emotes["readyunarmed"] = EMOTE_ONESHOT_READY_UNARMED;
+    emotes["roar"] = EMOTE_ONESHOT_ROAR;
+    emotes["rude"] = EMOTE_ONESHOT_RUDE;
+    emotes["shout"] = EMOTE_ONESHOT_SHOUT;
+    emotes["shy"] = EMOTE_ONESHOT_SHY;
+    emotes["sleep"] = EMOTE_STATE_SLEEP;
+    emotes["talk"] = EMOTE_ONESHOT_TALK;
+    emotes["wave"] = EMOTE_ONESHOT_WAVE;
+    emotes["woundcritical"] = EMOTE_ONESHOT_WOUND_CRITICAL;
+    emotes["wound"] = EMOTE_ONESHOT_WOUND;
+}
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.h b/src/plugins/playerbot/strategy/actions/EmoteAction.h
new file mode 100644
index 0000000..8aa8fda
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class EmoteAction : public Action
+    {
+    public:
+        EmoteAction(PlayerbotAI* ai) : Action(ai, "emote") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void InitEmotes();
+        static map<string, uint32> emotes;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.cpp b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
new file mode 100644
index 0000000..139e2e8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
@@ -0,0 +1,105 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EquipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool EquipAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text == "?")
+    {
+        TellEquipmentSets();
+        return true;
+    }
+
+    if (UseEquipmentSet(text))
+        return true;
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        EquipItem(&visitor);
+    }
+
+    return true;
+}
+
+bool EquipAction::UseEquipmentSet(string& name)
+{
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state == EQUIPMENT_SET_DELETED || i->second.Name != name)
+            continue;
+
+        UseEquipmentSet(i->second);
+
+        ostringstream out; out << name << " set equipped";
+        ai->TellMaster(out);
+        return true;
+    }
+    return false;
+}
+
+bool EquipAction::UseEquipmentSet(EquipmentSet& set)
+{
+    WorldPacket* p = new WorldPacket(CMSG_EQUIPMENT_SET_USE);
+    uint8 srcbag = 0;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        ObjectGuid guid;
+        uint32 itemId = set.Items[slot];
+        if (set.IgnoreMask & (1 << slot))
+            p->appendPackGUID((uint64(1)));
+        else
+            p->appendPackGUID(itemId);
+        *p << srcbag << slot;
+    }
+    bot->GetSession()->QueuePacket(p);
+    return true;
+}
+
+void EquipAction::TellEquipmentSets()
+{
+    ai->TellMaster("=== Equipment sets ===");
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state != EQUIPMENT_SET_DELETED)
+            ai->TellMaster(i->second.Name);
+    }
+}
+
+void EquipAction::EquipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) EquipItem(**items.begin());
+}
+
+
+void EquipAction::EquipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint32 itemId = item.GetTemplate()->ItemId;
+
+    if (item.GetTemplate()->InventoryType == INVTYPE_AMMO)
+    {
+        bot->SetAmmo(itemId);
+    }
+    else
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+            *packet << bagIndex << slot;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    ostringstream out; out << "equipping " << chat->formatItem(item.GetTemplate());
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.h b/src/plugins/playerbot/strategy/actions/EquipAction.h
new file mode 100644
index 0000000..d23223c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class EquipAction : public InventoryAction {
+    public:
+        EquipAction(PlayerbotAI* ai) : InventoryAction(ai, "equip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void EquipItem(FindItemVisitor* visitor);
+        void EquipItem(Item& item);
+        void TellEquipmentSets();
+        bool UseEquipmentSet(string& name);
+        bool UseEquipmentSet(EquipmentSet& set);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.cpp b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
new file mode 100644
index 0000000..dfa115f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowActions.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../values/Formations.h"
+
+using namespace ai;
+
+bool FollowAction::Execute(Event event)
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    string target = formation->GetTargetName();
+    if (!target.empty())
+    {
+        return Follow(AI_VALUE(Unit*, target));
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || loc.GetMapId() == -1)
+            return false;
+
+        return MoveTo(loc.GetMapId(), loc.m_positionX, loc.m_positionY, loc.m_positionZ);
+    }
+}
+
+bool FollowAction::isUseful()
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    float distance = 0;
+    string target = formation->GetTargetName();
+
+    if (!target.empty())
+    {
+        distance = AI_VALUE2(float, "distance", target);
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || bot->GetMapId() != loc.GetMapId())
+            return false;
+
+        distance = bot->GetDistance(loc);
+    }
+
+    return distance > formation->GetMaxDistance() &&
+            !AI_VALUE(bool, "can loot");
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.h b/src/plugins/playerbot/strategy/actions/FollowActions.h
new file mode 100644
index 0000000..971ca99
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class FollowAction : public MovementAction {
+	public:
+		FollowAction(PlayerbotAI* ai) : MovementAction(ai, "follow") {}
+		virtual bool Execute(Event event);
+        virtual bool isUseful();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.cpp b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
new file mode 100644
index 0000000..22285f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.h b/src/plugins/playerbot/strategy/actions/GenericActions.h
new file mode 100644
index 0000000..b32a8e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "GenericSpellActions.h"
+#include "ReachTargetActions.h"
+#include "ChooseTargetActions.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class MeleeAction : public AttackAction 
+    {
+    public:
+        MeleeAction(PlayerbotAI* ai) : AttackAction(ai, "melee") {}
+
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
new file mode 100644
index 0000000..0ffeccc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
+
+bool CastSpellAction::Execute(Event event) 
+{
+	return ai->CastSpell(spell, GetTarget()); 
+}
+
+bool CastSpellAction::isPossible() 
+{
+    if (AI_VALUE2(float, "distance", GetTargetName()) > range)
+        return false;
+
+	return ai->CanCastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isUseful() 
+{
+	return GetTarget() && AI_VALUE2(bool, "spell cast useful", spell);
+}
+
+bool CastAuraSpellAction::isUseful() 
+{
+	return CastSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+}
+
+bool CastEnchantItemAction::isUseful()
+{
+    if (!CastSpellAction::isUseful())
+        return false;
+
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+bool CastHealingSpellAction::isUseful() 
+{
+	return CastAuraSpellAction::isUseful() && AI_VALUE2(uint8, "health", GetTargetName()) < (100 - estAmount);
+}
+
+bool CastAoeHealSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && AI_VALUE2(uint8, "aoe heal", "medium") > 0;
+}
+
+
+Value<Unit*>* CurePartyMemberAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
+
+Value<Unit*>* BuffOnPartyAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member without aura", spell);
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.h b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
new file mode 100644
index 0000000..e286a17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
@@ -0,0 +1,271 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BEGIN_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+
+#define END_SPELL_ACTION() \
+    };
+
+#define BEGIN_DEBUFF_ACTION(clazz, name) \
+class clazz : public CastDebuffSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastDebuffSpellAction(ai, name) {} \
+
+#define BEGIN_RANGED_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+#define BEGIN_MELEE_SPELL_ACTION(clazz, name) \
+class clazz : public CastMeleeSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastMeleeSpellAction(ai, name) {} \
+
+
+#define END_RANGED_SPELL_ACTION() \
+    };
+
+
+#define BEGIN_BUFF_ON_PARTY_ACTION(clazz, name) \
+class clazz : public BuffOnPartyAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyAction(ai, name) {}
+
+namespace ai
+{
+    class CastSpellAction : public Action
+    {
+    public:
+        CastSpellAction(PlayerbotAI* ai, string spell) : Action(ai, spell),
+			range(sPlayerbotAIConfig.spellDistance)
+        {
+            this->spell = spell;
+        }
+
+		virtual string GetTargetName() { return "current target"; };
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+		virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_SINGLE; }
+
+		virtual NextAction** getPrerequisites()
+		{
+			if (range > sPlayerbotAIConfig.spellDistance)
+				return NULL;
+			else if (range > ATTACK_DISTANCE)
+				return NextAction::merge( NextAction::array(0, new NextAction("reach spell"), NULL), Action::getPrerequisites());
+			else
+				return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), Action::getPrerequisites());
+		}
+
+    protected:
+        string spell;
+		float range;
+    };
+
+	//---------------------------------------------------------------------------------------------------------------------
+	class CastAuraSpellAction : public CastSpellAction
+	{
+	public:
+		CastAuraSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual bool isUseful();
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastMeleeSpellAction : public CastSpellAction
+    {
+    public:
+        CastMeleeSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {
+			range = ATTACK_DISTANCE;
+		}
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastDebuffSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+    };
+
+    class CastDebuffSpellOnAttackerAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellOnAttackerAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("attacker without aura", spell);
+        }
+        virtual string getName() { return spell + " on attacker"; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+    };
+
+	class CastBuffSpellAction : public CastAuraSpellAction
+	{
+	public:
+		CastBuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastEnchantItemAction : public CastSpellAction
+	{
+	public:
+	    CastEnchantItemAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual bool isUseful();
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastHealingSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastHealingSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastAuraSpellAction(ai, spell)
+		{
+            this->estAmount = estAmount;
+			range = sPlayerbotAIConfig.spellDistance;
+        }
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+
+    protected:
+        uint8 estAmount;
+    };
+
+    class CastAoeHealSpellAction : public CastHealingSpellAction
+    {
+    public:
+    	CastAoeHealSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastHealingSpellAction(ai, spell, estAmount) {}
+		virtual string GetTargetName() { return "party member to heal"; }
+        virtual bool isUseful();
+    };
+
+	class CastCureSpellAction : public CastSpellAction
+	{
+	public:
+		CastCureSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class PartyMemberActionNameSupport {
+	public:
+		PartyMemberActionNameSupport(string spell)
+		{
+			name = string(spell) + " on party";
+		}
+
+		virtual string getName() { return name; }
+
+	private:
+		string name;
+	};
+
+    class HealPartyMemberAction : public CastHealingSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        HealPartyMemberAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) :
+			CastHealingSpellAction(ai, spell, estAmount), PartyMemberActionNameSupport(spell) {}
+
+		virtual string GetTargetName() { return "party member to heal"; }
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+	class ResurrectPartyMemberAction : public CastSpellAction
+	{
+	public:
+		ResurrectPartyMemberAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual string GetTargetName() { return "party member to resurrect"; }
+	};
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CurePartyMemberAction : public CastSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        CurePartyMemberAction(PlayerbotAI* ai, string spell, uint32 dispelType) :
+			CastSpellAction(ai, spell), PartyMemberActionNameSupport(spell)
+        {
+            this->dispelType = dispelType;
+        }
+
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+
+    protected:
+        uint32 dispelType;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class BuffOnPartyAction : public CastBuffSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        BuffOnPartyAction(PlayerbotAI* ai, string spell) :
+			CastBuffSpellAction(ai, spell), PartyMemberActionNameSupport(spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastShootAction : public CastSpellAction
+    {
+    public:
+        CastShootAction(PlayerbotAI* ai) : CastSpellAction(ai, "shoot") {}
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+    };
+
+	class CastLifeBloodAction : public CastHealingSpellAction
+	{
+	public:
+		CastLifeBloodAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lifeblood") {}
+	};
+
+	class CastGiftOfTheNaaruAction : public CastHealingSpellAction
+	{
+	public:
+		CastGiftOfTheNaaruAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "gift of the naaru") {}
+	};
+
+    class CastArcaneTorrentAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneTorrentAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane torrent") {}
+    };
+
+    class CastSpellOnEnemyHealerAction : public CastSpellAction
+    {
+    public:
+        CastSpellOnEnemyHealerAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("enemy healer target", spell);
+        }
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
new file mode 100644
index 0000000..fb62d09
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GossipHelloAction.h"
+
+
+using namespace ai;
+
+bool GossipHelloAction::Execute(Event event)
+{
+    ObjectGuid guid;
+
+    WorldPacket &p = event.getPacket();
+    if (p.empty())
+    {
+        Player* master = GetMaster();
+        if (master && master->GetSelectedUnit())
+            guid = master->GetSelectedUnit()->GetGUID();
+    }
+    else
+    {
+        p.rpos(0);
+        p >> guid;
+    }
+
+    if (!guid)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+    if (!pCreature)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %d not found or you can't interact with him.", guid.GetRawValue());
+        return false;
+    }
+
+    GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+    if (pMenuItemBounds.first == pMenuItemBounds.second)
+        return false;
+
+    WorldPacket p1;
+    p1 << guid;
+    bot->GetSession()->HandleGossipHelloOpcode(p1);
+    bot->SetFacingToObject(pCreature);
+
+    ostringstream out; out << "--- " << pCreature->GetName() << " ---";
+    ai->TellMasterNoFacing(out.str());
+
+    GossipMenu& menu = bot->PlayerTalkClass->GetGossipMenu();
+    int i = 0, loops = 0;
+    set<uint32> alreadyTalked;
+    while (i < menu.GetMenuItemCount() && loops++ < 100)
+    {
+        GossipMenuItem const* item = menu.GetItem(i);
+        ai->TellMasterNoFacing(item->Message);
+
+        if (item->OptionType < 1000 && item->OptionType != GOSSIP_OPTION_GOSSIP)
+        {
+            i++;
+            continue;
+        }
+
+        WorldPacket p1;
+        std::string code;
+        p1 << guid << menu.GetMenuId() << i << code;
+        bot->GetSession()->HandleGossipSelectOptionOpcode(p1);
+
+        i = 0;
+    }
+
+    bot->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.h b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
new file mode 100644
index 0000000..603737c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class GossipHelloAction : public Action {
+    public:
+        GossipHelloAction(PlayerbotAI* ai) : Action(ai, "gossip hello") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
new file mode 100644
index 0000000..49d71cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildAcceptAction.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildAcceptAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    bool accept = true;
+    uint32 guildId = master->GetGuildId();
+    if (!guildId)
+    {
+        ai->TellMaster("You are not in a guild");
+        accept = false;
+    }
+    else if (bot->GetGuildId())
+    {
+        ai->TellMaster("Sorry, I am in a guild already");
+        accept = false;
+    }
+    else if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, master, true))
+    {
+        accept = false;
+    }
+
+    WorldPacket packet;
+    if (accept)
+    {
+        bot->SetGuildIdInvited(guildId);
+        bot->GetSession()->HandleGuildAcceptOpcode(packet);
+    }
+    else
+    {
+        bot->GetSession()->HandleGuildDeclineOpcode(packet);
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
new file mode 100644
index 0000000..ab8910c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildAcceptAction : public Action {
+    public:
+        GuildAcceptAction(PlayerbotAI* ai) : Action(ai, "guild accept") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
new file mode 100644
index 0000000..849b1b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildBankAction.h"
+
+#include "../values/ItemCountValue.h"
+#include "../../../Guilds/Guild.h"
+#include "../../../Guilds/GuildMgr.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildBankAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text.empty())
+        return false;
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go || !bot->GetGameObjectIfCanInteractWith(go->GetGUID(), GAMEOBJECT_TYPE_GUILD_BANK))
+            continue;
+
+        return Execute(text, go);
+    }
+
+    ai->TellMaster("Cannot find the guild bank nearby");
+    return false;
+}
+
+bool GuildBankAction::Execute(string text, GameObject* bank)
+{
+    bool result = true;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+    {
+        Item* item = *i;
+        if (item)
+            result &= MoveFromCharToBank(item, bank);
+    }
+
+    return result;
+}
+
+bool GuildBankAction::MoveFromCharToBank(Item* item, GameObject* bank)
+{
+    uint32 playerSlot = item->GetSlot();
+    uint32 playerBag = item->GetBagSlot();
+
+    Guild* guild = sGuildMgr->GetGuildById(bot->GetGuildId());
+    guild->SwapItems(bot, 0, playerSlot, 0, INVENTORY_SLOT_BAG_0, 0);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " put to guild bank";
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.h b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
new file mode 100644
index 0000000..374fc0f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildBankAction : public InventoryAction {
+    public:
+        GuildBankAction(PlayerbotAI* ai) : InventoryAction(ai, "guild bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, GameObject* bank);
+        bool MoveFromCharToBank(Item* item, GameObject* bank);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.cpp b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
new file mode 100644
index 0000000..6e7b776
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HelpAction.h"
+#include "ChatActionContext.h"
+
+using namespace ai;
+
+HelpAction::HelpAction(PlayerbotAI* ai) : Action(ai, "help")
+{
+    chatContext = new ChatActionContext();
+}
+
+HelpAction::~HelpAction()
+{
+    delete chatContext;
+}
+
+bool HelpAction::Execute(Event event)
+{
+    TellChatCommands();
+    TellStrategies();
+    return true;
+}
+
+void HelpAction::TellChatCommands()
+{
+    ostringstream out;
+    out << "Whisper any of: ";
+    out << CombineSupported(chatContext->supports());
+    out << ", [item], [quest] or [object] link";
+    ai->TellMaster(out);
+}
+
+void HelpAction::TellStrategies()
+{
+    ostringstream out;
+    out << "Possible strategies (co/nc/dead commands): ";
+    out << CombineSupported(ai->GetAiObjectContext()->GetSupportedStrategies());
+    ai->TellMaster(out);
+}
+
+string HelpAction::CombineSupported(set<string> commands)
+{
+    ostringstream out;
+
+    for (set<string>::iterator i = commands.begin(); i != commands.end(); )
+	{
+        out << *i;
+		if (++i != commands.end())
+			out << ", ";
+	}
+
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.h b/src/plugins/playerbot/strategy/actions/HelpAction.h
new file mode 100644
index 0000000..c0bc5e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class HelpAction : public Action {
+    public:
+        HelpAction(PlayerbotAI* ai);
+        virtual ~HelpAction();
+        virtual bool Execute(Event event);
+
+    private:
+        void TellChatCommands();
+        void TellStrategies();
+        string CombineSupported(set<string> commands);
+
+    private:
+        NamedObjectContext<Action>* chatContext;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
new file mode 100644
index 0000000..896466c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
@@ -0,0 +1,288 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+
+class FindPotionVisitor : public FindUsableItemVisitor
+{
+public:
+    FindPotionVisitor(Player* bot, uint32 effectId) : FindUsableItemVisitor(bot), effectId(effectId) {}
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        if (proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_POTION &&
+            proto->Spells[0].SpellCategory == 4)
+        {
+            for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+            {
+                const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+                if (!spellInfo)
+                    return false;
+
+                for (int i = 0 ; i < 3; i++)
+                {
+                    if (spellInfo->Effects[i].Effect == effectId)
+                        return true;
+                }
+            }
+        }
+        return false;
+    }
+
+private:
+    uint32 effectId;
+};
+
+class FindFoodVisitor : public FindUsableItemVisitor
+{
+public:
+    FindFoodVisitor(Player* bot, uint32 spellCategory) : FindUsableItemVisitor(bot)
+    {
+        this->spellCategory = spellCategory;
+    }
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        return proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_FOOD &&
+            proto->Spells[0].SpellCategory == spellCategory;
+    }
+
+private:
+    uint32 spellCategory;
+};
+
+void InventoryAction::IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask)
+{
+    if (mask & ITERATE_ITEMS_IN_BAGS)
+        IterateItemsInBags(visitor);
+
+    if (mask & ITERATE_ITEMS_IN_EQUIP)
+        IterateItemsInEquip(visitor);
+}
+
+void InventoryAction::IterateItemsInBags(IterateItemsVisitor* visitor)
+{
+
+
+    for(int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag *pBag = (Bag*)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (!visitor->Visit(pItem))
+                        return;
+}
+
+void InventoryAction::IterateItemsInEquip(IterateItemsVisitor* visitor)
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        if (!visitor->Visit(pItem))
+            return;
+    }
+}
+
+bool compare_items(const ItemTemplate *proto1, const ItemTemplate *proto2)
+{
+    if (proto1->Class != proto2->Class)
+        return proto1->Class > proto2->Class;
+
+    if (proto1->SubClass != proto2->SubClass)
+        return proto1->SubClass < proto2->SubClass;
+
+    if (proto1->Quality != proto2->Quality)
+        return proto1->Quality < proto2->Quality;
+
+    if (proto1->ItemLevel != proto2->ItemLevel)
+        return proto1->ItemLevel > proto2->ItemLevel;
+
+    return false;
+}
+
+bool compare_items_by_level(const Item* item1, const Item* item2)
+{
+    return compare_items(item1->GetTemplate(), item2->GetTemplate());
+}
+
+void InventoryAction::TellItems(map<uint32, int> itemMap)
+{
+    list<ItemTemplate const*> items;
+    for (map<uint32, int>::iterator i = itemMap.begin(); i != itemMap.end(); i++)
+    {
+        items.push_back(sObjectMgr->GetItemTemplate(i->first));
+    }
+
+    items.sort(compare_items);
+
+    uint32 oldClass = -1;
+    for (list<ItemTemplate const*>::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *proto = *i;
+
+        if (proto->Class != oldClass)
+        {
+            oldClass = proto->Class;
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_CONSUMABLE:
+                ai->TellMaster("--- consumable ---");
+                break;
+            case ITEM_CLASS_CONTAINER:
+                ai->TellMaster("--- container ---");
+                break;
+            case ITEM_CLASS_WEAPON:
+                ai->TellMaster("--- weapon ---");
+                break;
+            case ITEM_CLASS_GEM:
+                ai->TellMaster("--- gem ---");
+                break;
+            case ITEM_CLASS_ARMOR:
+                ai->TellMaster("--- armor ---");
+                break;
+            case ITEM_CLASS_REAGENT:
+                ai->TellMaster("--- reagent ---");
+                break;
+            case ITEM_CLASS_PROJECTILE:
+                ai->TellMaster("--- projectile ---");
+                break;
+            case ITEM_CLASS_TRADE_GOODS:
+                ai->TellMaster("--- trade goods ---");
+                break;
+            case ITEM_CLASS_GENERIC:
+                ai->TellMaster("--- generic ---");
+                break;
+            case ITEM_CLASS_RECIPE:
+                ai->TellMaster("--- recipe ---");
+                break;
+            case ITEM_CLASS_MONEY:
+                ai->TellMaster("--- money ---");
+                break;
+            case ITEM_CLASS_QUIVER:
+                ai->TellMaster("--- quiver ---");
+                break;
+            case ITEM_CLASS_QUEST:
+                ai->TellMaster("--- quest items ---");
+                break;
+            case ITEM_CLASS_KEY:
+                ai->TellMaster("--- keys ---");
+                break;
+            case ITEM_CLASS_PERMANENT:
+                ai->TellMaster("--- permanent ---");
+                break;
+            case ITEM_CLASS_MISC:
+                ai->TellMaster("--- other ---");
+                break;
+            case ITEM_CLASS_GLYPH:
+                ai->TellMaster("--- glyph ---");
+                break;
+            }
+        }
+
+        TellItem(proto, itemMap[proto->ItemId]);
+    }
+}
+
+void InventoryAction::TellItem(ItemTemplate const * proto, int count)
+{
+    ai->TellMaster(chat->formatItem(proto, count));
+}
+
+list<Item*> InventoryAction::parseItems(string text)
+{
+    set<Item*> found;
+    size_t pos = text.find(" ");
+    int count = pos!=string::npos ? atoi(text.substr(pos + 1).c_str()) : TRADE_SLOT_TRADED_COUNT;
+    if (count < 1) count = 1;
+    else if (count > TRADE_SLOT_TRADED_COUNT) count = TRADE_SLOT_TRADED_COUNT;
+
+    if (text == "food")
+    {
+        FindFoodVisitor visitor(bot, 11);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "drink")
+    {
+        FindFoodVisitor visitor(bot, 59);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "mana potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_ENERGIZE);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "healing potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_HEAL);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    FindUsableNamedItemVisitor visitor(bot, text);
+    IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+    found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+
+    uint32 quality = chat->parseItemQuality(text);
+    if (quality != MAX_ITEM_QUALITY)
+    {
+        FindItemsToTradeByQualityVisitor visitor(quality, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 itemClass = MAX_ITEM_CLASS, itemSubClass = 0;
+    if (chat->parseItemClass(text, &itemClass, &itemSubClass))
+    {
+        FindItemsToTradeByClassVisitor visitor(itemClass, itemSubClass, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 fromSlot = chat->parseSlot(text);
+    if (fromSlot != EQUIPMENT_SLOT_END)
+    {
+        Item* item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, fromSlot);
+        if (item)
+            found.insert(item);
+    }
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        IterateItems(&visitor, ITERATE_ALL_ITEMS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    list<Item*> result;
+    for (set<Item*>::iterator i = found.begin(); i != found.end(); ++i)
+        result.push_back(*i);
+
+    result.sort(compare_items_by_level);
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.h b/src/plugins/playerbot/strategy/actions/InventoryAction.h
new file mode 100644
index 0000000..a1f1af7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "../ItemVisitors.h"
+
+namespace ai
+{
+
+
+    class InventoryAction : public Action {
+    public:
+        InventoryAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    protected:
+        void IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask = ITERATE_ITEMS_IN_BAGS);
+        void TellItems(map<uint32, int> items);
+        void TellItem(ItemTemplate const * proto, int count);
+        list<Item*> parseItems(string text);
+
+    private:
+        void IterateItemsInBags(IterateItemsVisitor* visitor);
+        void IterateItemsInEquip(IterateItemsVisitor* visitor);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
new file mode 100644
index 0000000..88285a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
@@ -0,0 +1,55 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryChangeFailureAction.h"
+
+
+using namespace ai;
+
+bool InventoryChangeFailureAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 err;
+    p >> err;
+    if (err == EQUIP_ERR_OK)
+        return false;
+
+    switch (err)
+    {
+    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+        ai->TellMaster("I can't carry anymore of those.");
+        break;
+    case EQUIP_ERR_MISSING_REAGENT:
+        ai->TellMaster("I'm missing some reagents for that.");
+        break;
+    case EQUIP_ERR_ITEM_LOCKED:
+        ai->TellMaster("That item is locked.");
+        break;
+    case EQUIP_ERR_ALREADY_LOOTED:
+        break;
+    case EQUIP_ERR_INVENTORY_FULL:
+        ai->TellMaster("My inventory is full.");
+        break;
+    case EQUIP_ERR_NOT_IN_COMBAT:
+        ai->TellMaster("I can't use that in combat.");
+        break;
+    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+        ai->TellMaster("I can't get that now.");
+        break;
+    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+        ai->TellMaster("I can only have one of those equipped.");
+        break;
+    case EQUIP_ERR_BANK_FULL:
+        ai->TellMaster("My bank is full.");
+        break;
+    case EQUIP_ERR_ITEM_NOT_FOUND:
+        ai->TellMaster("I can't find the item.");
+        break;
+    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+        ai->TellMaster("I'm too far from the bank.");
+        break;
+    default:
+        ai->TellMaster("I can't use that.");
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
new file mode 100644
index 0000000..4125cd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InventoryChangeFailureAction : public Action {
+    public:
+        InventoryChangeFailureAction(PlayerbotAI* ai) : Action(ai, "inventory change failure") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
new file mode 100644
index 0000000..d57ee50
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InviteToGroupAction : public Action
+    {
+    public:
+        InviteToGroupAction(PlayerbotAI* ai) : Action(ai, "invite") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = event.getOwner();
+            if (!master)
+                return false;
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << master->GetName();
+            p << roles_mask;
+            bot->GetSession()->HandleGroupInviteOpcode(p);
+
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
new file mode 100644
index 0000000..0ce2ee3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../RandomPlayerbotMgr.h"
+
+namespace ai
+{
+    class LeaveGroupAction : public Action {
+    public:
+        LeaveGroupAction(PlayerbotAI* ai, string name = "leave") : Action(ai, name) {}
+
+        virtual bool Execute(Event event)
+        {
+            if (!bot->GetGroup())
+                return false;
+
+            ai->TellMaster("Goodbye!", PLAYERBOT_SECURITY_TALK);
+
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                bot->GetPlayerbotAI()->SetMaster(NULL);
+                sRandomPlayerbotMgr.ScheduleTeleport(bot->GetGUIDLow());
+                sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+            }
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+    class PartyCommandAction : public LeaveGroupAction {
+    public:
+        PartyCommandAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            uint32 operation;
+            string member;
+
+            p >> operation >> member;
+
+            if (operation != PARTY_OP_LEAVE)
+                return false;
+
+            Player* master = GetMaster();
+            if (master && member == master->GetName())
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+    class UninviteAction : public LeaveGroupAction {
+    public:
+        UninviteAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (bot->GetGUID() == guid)
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.cpp b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
new file mode 100644
index 0000000..be0e47c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
@@ -0,0 +1,215 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LfgActions.h"
+#include "../../AiFactory.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../ItemVisitors.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+#include "../../../DungeonFinding/LFG.h"
+
+using namespace ai;
+using namespace lfg;
+
+bool LfgJoinAction::Execute(Event event)
+{
+    if (!sPlayerbotAIConfig.randomBotJoinLfg)
+        return false;
+
+    if (bot->isDead())
+        return false;
+
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return false;
+
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_NONE)
+        return false;
+
+    if (bot->IsBeingTeleported())
+        return false;
+
+    Map* map = bot->GetMap();
+    if (map && map->Instanceable())
+        return false;
+
+    return JoinProposal();
+}
+
+uint8 LfgJoinAction::GetRoles()
+{
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    switch (bot->getClass())
+    {
+    case CLASS_DRUID:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else if (spec == 1 && bot->getLevel() >= 40)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PALADIN:
+        if (spec == 1)
+            return PLAYER_ROLE_TANK;
+        else if (spec == 0)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PRIEST:
+        if (spec != 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_SHAMAN:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_WARRIOR:
+        if (spec == 2)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    default:
+        return PLAYER_ROLE_DAMAGE;
+        break;
+    }
+
+    return PLAYER_ROLE_DAMAGE;
+}
+
+bool LfgJoinAction::SetRoles()
+{
+    sLFGMgr->SetRoles(bot->GetGUID(), GetRoles());
+	return true;
+}
+
+bool LfgJoinAction::JoinProposal()
+{
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+	bool heroic = urand(0, 100) < 50 && (visitor.count[ITEM_QUALITY_EPIC] >= 3 || visitor.count[ITEM_QUALITY_RARE] >= 10) && bot->getLevel() >= 70;
+    bool random = urand(0, 100) < 25;
+    bool raid = !heroic && (urand(0, 100) < 50 && visitor.count[ITEM_QUALITY_EPIC] >= 5 && (bot->getLevel() == 60 || bot->getLevel() == 70 || bot->getLevel() == 80));
+
+    LfgDungeonSet list;
+    vector<uint32> idx;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(i);
+        if (!dungeon || (dungeon->type != LFG_TYPE_RANDOM && dungeon->type != LFG_TYPE_DUNGEON && dungeon->type != LFG_TYPE_HEROIC &&
+                dungeon->type != LFG_TYPE_RAID))
+            continue;
+
+        int botLevel = (int)bot->getLevel();
+        if (dungeon->minlevel && botLevel < (int)dungeon->minlevel)
+            continue;
+
+        if (dungeon->minlevel && botLevel > (int)dungeon->minlevel + 10)
+            continue;
+
+        if (dungeon->maxlevel && botLevel > (int)dungeon->maxlevel)
+            continue;
+
+        if (heroic && !dungeon->difficulty)
+            continue;
+
+        if (raid && dungeon->type != LFG_TYPE_RAID)
+            continue;
+
+        if (random && dungeon->type != LFG_TYPE_RANDOM)
+            continue;
+
+        if (!random && !raid && !heroic && dungeon->type != LFG_TYPE_DUNGEON)
+            continue;
+
+        if (!random)
+            list.insert(dungeon->ID);
+        else
+            idx.push_back(dungeon->ID);
+    }
+
+    if (list.empty())
+        return false;
+
+    uint8 roles = GetRoles();
+    if (random)
+	{
+        list.insert(idx[urand(0, idx.size() - 1)]);
+        sLFGMgr->JoinLfg(bot, roles, list, "bot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RANDOM as %d", bot->GetName().c_str(), (uint32)roles);
+		return true;
+	}
+    else if (heroic)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_HEROIC_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else if (raid)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RAID as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+
+    sLFGMgr->JoinLfg(bot, roles, list, "bot");
+    return true;
+}
+
+bool LfgRoleCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        sLFGMgr->UpdateRoleCheck(group->GetGUID(), bot->GetGUID(), GetRoles());
+        return true;
+    }
+
+    return false;
+}
+
+bool LfgAcceptAction::Execute(Event event)
+{
+    uint32 id = AI_VALUE(uint32, "lfg proposal");
+    if (id)
+    {
+        if (urand(0, 1 + 10 / sPlayerbotAIConfig.randomChangeMultiplier))
+            return false;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s updated proposal %d", bot->GetName().c_str(), id);
+        ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(0);
+        sLFGMgr->UpdateProposal(id, bot->GetGUID(), true);
+
+        ai->Reset();
+        if (sRandomPlayerbotMgr.IsRandomBot(bot) && !bot->GetGroup())
+        {
+            sRandomPlayerbotMgr.Refresh(bot);
+            ai->ResetStrategies();
+        }
+        return true;
+    }
+
+    WorldPacket p(event.getPacket());
+
+    uint32 dungeon;
+    uint8 state;
+    p >> dungeon >> state >> id;
+
+    ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(id);
+    return true;
+}
+
+bool LfgLeaveAction::Execute(Event event)
+{
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_QUEUED)
+        return false;
+
+    sLFGMgr->LeaveLfg(bot->GetGUID());
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.h b/src/plugins/playerbot/strategy/actions/LfgActions.h
new file mode 100644
index 0000000..dd8fc68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class LfgJoinAction : public InventoryAction {
+    public:
+        LfgJoinAction(PlayerbotAI* ai, string name = "lfg join") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool JoinProposal();
+        bool SetRoles();
+        uint8 GetRoles();
+    };
+
+    class LfgAcceptAction : public LfgJoinAction {
+    public:
+        LfgAcceptAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg accept") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgRoleCheckAction : public LfgJoinAction {
+    public:
+        LfgRoleCheckAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg role check") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgLeaveAction : public Action {
+    public:
+        LfgLeaveAction(PlayerbotAI* ai) : Action(ai, "lfg leave") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
new file mode 100644
index 0000000..d9249ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListQuestsActions.h"
+
+
+using namespace ai;
+
+bool ListQuestsAction::Execute(Event event)
+{
+    if (event.getParam() == "completed")
+    {
+        ListQuests(QUEST_LIST_FILTER_COMPLETED);
+    }
+    else if (event.getParam() == "incompleted")
+    {
+        ListQuests(QUEST_LIST_FILTER_INCOMPLETED);
+    }
+    else if (event.getParam() == "all")
+    {
+        ListQuests(QUEST_LIST_FILTER_ALL);
+    }
+    else
+    {
+        ListQuests(QUEST_LIST_FILTER_SUMMARY);
+    }
+    return true;
+}
+
+void ListQuestsAction::ListQuests(QuestListFilter filter)
+{
+    bool showIncompleted = filter & QUEST_LIST_FILTER_INCOMPLETED;
+    bool showCompleted = filter & QUEST_LIST_FILTER_COMPLETED;
+
+    if (showIncompleted)
+        ai->TellMaster("--- Incomplete quests ---");
+    int incompleteCount = ListQuests(false, !showIncompleted);
+
+    if (showCompleted)
+        ai->TellMaster("--- Complete quests ---");
+    int completeCount = ListQuests(true, !showCompleted);
+
+    ai->TellMaster("--- Summary ---");
+    std::ostringstream out;
+    out << "Total: " << (completeCount + incompleteCount) << " / 25 (incomplete: " << incompleteCount << ", complete: " << completeCount << ")";
+    ai->TellMaster(out);
+}
+
+int ListQuestsAction::ListQuests(bool completed, bool silent)
+{
+    int count = 0;
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+        bool isCompletedQuest = bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE;
+        if (completed != isCompletedQuest)
+            continue;
+
+        count++;
+
+        if (silent)
+            continue;
+
+        ai->TellMaster(chat->formatQuest(pQuest));
+    }
+
+    return count;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.h b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
new file mode 100644
index 0000000..961acb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    enum QuestListFilter {
+        QUEST_LIST_FILTER_SUMMARY = 0,
+        QUEST_LIST_FILTER_COMPLETED = 1,
+        QUEST_LIST_FILTER_INCOMPLETED = 2,
+        QUEST_LIST_FILTER_ALL = QUEST_LIST_FILTER_COMPLETED | QUEST_LIST_FILTER_INCOMPLETED
+    };
+
+    class ListQuestsAction : public Action {
+    public:
+        ListQuestsAction(PlayerbotAI* ai) : Action(ai, "quests") {}
+        virtual bool Execute(Event event);
+
+    private:
+        int ListQuests(bool completed, bool silent);
+        void ListQuests(QuestListFilter filter);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
new file mode 100644
index 0000000..4602fb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListSpellsAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool ListSpellsAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    string filter = event.getParam();
+
+    const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+    std::string alreadySeenList = ",";
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr) {
+        const uint32 spellId = itr->first;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        //|| name.find("Teleport") != -1
+
+        std::string comp = ",";
+        comp.append(pSpellInfo->SpellName[loc]);
+        comp.append(",");
+
+        if (!(ignoreList.find(comp) == std::string::npos && alreadySeenList.find(comp) == std::string::npos))
+            continue;
+
+        if (!filter.empty() && !strstri(pSpellInfo->SpellName[loc], filter.c_str()))
+            continue;
+
+        alreadySeenList += pSpellInfo->SpellName[loc];
+        alreadySeenList += ",";
+
+        if (pSpellInfo->IsPositive())
+            posOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+        else
+            negOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+    }
+
+    ai->TellMaster("here's my non-attack spells:");
+    ai->TellMaster(posOut);
+
+    ai->TellMaster("here's my attack spells:");
+    ai->TellMaster(negOut);
+
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.h b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
new file mode 100644
index 0000000..2447055
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+
+namespace ai
+{
+    class ListSpellsAction : public Action {
+    public:
+        ListSpellsAction(PlayerbotAI* ai) : Action(ai, "spells") {}
+
+        virtual bool Execute(Event event);
+  
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
new file mode 100644
index 0000000..92005a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
@@ -0,0 +1,43 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LogLevelAction.h"
+
+
+using namespace ai;
+
+bool LogLevelAction::Execute(Event event)
+{
+    string param = event.getParam();
+    Value<LogLevel> *value = ai->GetAiObjectContext()->GetValue<LogLevel>("log level");
+
+    ostringstream out;
+    if (param != "?")
+    {
+        value->Set(string2logLevel(param));
+        out << "My log level set to " << logLevel2string(value->Get());
+    }
+    else
+    {
+        out << "My log level is " << logLevel2string(value->Get());
+    }
+    ai->TellMaster(out);
+    return true;
+}
+
+string LogLevelAction::logLevel2string(LogLevel level)
+{
+    switch (level)
+    {
+    case LOG_LEVEL_INFO:
+        return "info";
+    default:
+        return "debug";
+    }
+}
+LogLevel LogLevelAction::string2logLevel(string level)
+{
+    if (level == "debug")
+        return LOG_LEVEL_DEBUG;
+    else
+        return LOG_LEVEL_INFO;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.h b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
new file mode 100644
index 0000000..4ad2a33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class LogLevelAction : public Action {
+    public:
+        LogLevelAction(PlayerbotAI* ai) : Action(ai, "log") {}
+        virtual bool Execute(Event event);
+
+    public:
+        static string logLevel2string(LogLevel level);
+        static LogLevel string2logLevel(string level);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.cpp b/src/plugins/playerbot/strategy/actions/LootAction.cpp
new file mode 100644
index 0000000..984f8ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.cpp
@@ -0,0 +1,400 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootAction.h"
+
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+bool LootAction::Execute(Event event)
+{
+    if (!AI_VALUE(bool, "has available loot"))
+        return false;
+
+    LootObject const& lootObject = AI_VALUE(LootObjectStack*, "available loot")->GetLoot(sPlayerbotAIConfig.lootDistance);
+    context->GetValue<LootObject>("loot target")->Set(lootObject);
+    return true;
+}
+
+enum ProfessionSpells
+{
+    ALCHEMY                      = 2259,
+    BLACKSMITHING                = 2018,
+    COOKING                      = 2550,
+    ENCHANTING                   = 7411,
+    ENGINEERING                  = 49383,
+    FIRST_AID                    = 3273,
+    FISHING                      = 7620,
+    HERB_GATHERING               = 2366,
+    INSCRIPTION                  = 45357,
+    JEWELCRAFTING                = 25229,
+    MINING                       = 2575,
+    SKINNING                     = 8613,
+    TAILORING                    = 3908
+};
+
+bool OpenLootAction::Execute(Event event)
+{
+    LootObject lootObject = AI_VALUE(LootObject, "loot target");
+    bool result = DoLoot(lootObject);
+    if (result)
+    {
+        AI_VALUE(LootObjectStack*, "available loot")->Remove(lootObject.guid);
+        context->GetValue<LootObject>("loot target")->Set(LootObject());
+    }
+    return result;
+}
+
+bool OpenLootAction::DoLoot(LootObject& lootObject)
+{
+    if (lootObject.IsEmpty())
+        return false;
+
+    Creature* creature = ai->GetCreature(lootObject.guid);
+    if (creature && bot->GetDistance(creature) > INTERACTION_DISTANCE)
+        return false;
+
+    if (creature && creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+    {
+        bot->GetMotionMaster()->Clear();
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+        *packet << lootObject.guid;
+        bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+
+    if (creature)
+    {
+        SkillType skill = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+        if (!CanOpenLock(skill, lootObject.reqSkillValue))
+            return false;
+
+        bot->GetMotionMaster()->Clear();
+        switch (skill)
+        {
+        case SKILL_ENGINEERING:
+            return bot->HasSkill(SKILL_ENGINEERING) ? ai->CastSpell(ENGINEERING, creature) : false;
+        case SKILL_HERBALISM:
+            return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(32605, creature) : false;
+        case SKILL_MINING:
+            return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(32606, creature) : false;
+        default:
+            return bot->HasSkill(SKILL_SKINNING) ? ai->CastSpell(SKINNING, creature) : false;
+        }
+    }
+
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && bot->GetDistance(go) > INTERACTION_DISTANCE)
+        return false;
+
+    bot->GetMotionMaster()->Clear();
+    if (lootObject.skillId == SKILL_MINING)
+        return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(MINING, bot) : false;
+
+    if (lootObject.skillId == SKILL_HERBALISM)
+        return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(HERB_GATHERING, bot) : false;
+
+    uint32 spellId = GetOpeningSpell(lootObject);
+    if (!spellId)
+        return false;
+
+    return ai->CastSpell(spellId, bot);
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject)
+{
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && go->isSpawned())
+        return GetOpeningSpell(lootObject, go);
+
+    return 0;
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject, GameObject* go)
+{
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+    {
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    return 0; //Spell 3365 = Opening?
+}
+
+bool OpenLootAction::CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go)
+{
+    for (int effIndex = 0; effIndex <= EFFECT_2; effIndex++)
+    {
+        if (pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_OPEN_LOCK && pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_SKINNING)
+            return false;
+
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        if (!lockId)
+            return false;
+
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return false;
+
+        bool reqKey = false;                                    // some locks not have reqs
+
+        for(int j = 0; j < 8; ++j)
+        {
+            switch(lockInfo->Type[j])
+            {
+            /*
+            case LOCK_KEY_ITEM:
+                return true;
+            */
+            case LOCK_KEY_SKILL:
+                {
+                    if(uint32(pSpellInfo->Effects[effIndex].MiscValue) != lockInfo->Index[j])
+                        continue;
+
+                    uint32 skillId = SkillByLockType(LockType(lockInfo->Index[j]));
+                    if (skillId == SKILL_NONE)
+                        return true;
+
+                    if (CanOpenLock(skillId, lockInfo->Skill[j]))
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool OpenLootAction::CanOpenLock(uint32 skillId, uint32 reqSkillValue)
+{
+    uint32 skillValue = bot->GetSkillValue(skillId);
+    return skillValue >= reqSkillValue || !reqSkillValue;
+}
+
+bool StoreLootAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket()); // (8+1+4+1+1+4+4+4+4+4+1)
+    ObjectGuid guid;
+    uint8 loot_type;
+    uint32 gold = 0;
+    uint8 items = 0;
+
+    p.rpos(0);
+    p >> guid;      // 8 corpse guid
+    p >> loot_type; // 1 loot type
+
+    if (p.size() > 10)
+    {
+        p >> gold;      // 4 money on corpse
+        p >> items;     // 1 number of items on corpse
+    }
+
+    if (gold > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    for (uint8 i = 0; i < items; ++i)
+    {
+        uint32 itemid;
+        uint32 itemcount;
+        uint8 lootslot_type;
+        uint8 itemindex;
+        bool grab = false;
+
+        p >> itemindex;
+        p >> itemid;
+        p >> itemcount;
+        p.read_skip<uint32>();  // display id
+        p.read_skip<uint32>();  // randomSuffix
+        p.read_skip<uint32>();  // randomPropertyId
+        p >> lootslot_type;     // 0 = can get, 1 = look only, 2 = master get
+
+        if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+            continue;
+
+        if (loot_type != LOOT_SKINNING && !IsLootAllowed(itemid))
+            continue;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot))
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+            if (proto)
+            {
+                uint32 price = itemcount * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) + gold;
+                uint32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                if (bot->GetGroup() && price)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, lootAmount + price);
+                }
+                else if (lootAmount)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+                }
+            }
+        }
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+        *packet << itemindex;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    AI_VALUE(LootObjectStack*, "available loot")->Remove(guid);
+
+    // release loot
+    WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+    *packet << guid;
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool StoreLootAction::IsLootAllowedBySkill(ItemTemplate const * proto)
+{
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_KEY:
+    case ITEM_CLASS_CONSUMABLE:
+        return true;
+    case ITEM_CLASS_GEM:
+        if (proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE && bot->HasSkill(SKILL_JEWELCRAFTING))
+            return true;
+        if (proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE)
+            return true;
+        break;
+    case ITEM_CLASS_TRADE_GOODS:
+        switch (proto->SubClass)
+        {
+        case ITEM_SUBCLASS_PARTS:
+        case ITEM_SUBCLASS_EXPLOSIVES:
+        case ITEM_SUBCLASS_DEVICES:
+            return bot->HasSkill(SKILL_ENGINEERING);
+        case ITEM_SUBCLASS_JEWELCRAFTING:
+            return bot->HasSkill(SKILL_JEWELCRAFTING);
+        case ITEM_SUBCLASS_CLOTH:
+            return bot->HasSkill(SKILL_TAILORING);
+        case ITEM_SUBCLASS_LEATHER:
+            return bot->HasSkill(SKILL_LEATHERWORKING) || bot->HasSkill(SKILL_SKINNING);
+        case ITEM_SUBCLASS_METAL_STONE:
+            return (bot->HasSkill(SKILL_BLACKSMITHING) ||
+                bot->HasSkill(SKILL_ENGINEERING) ||
+                bot->HasSkill(SKILL_MINING));
+        case ITEM_SUBCLASS_MEAT:
+            return bot->HasSkill(SKILL_COOKING);
+        case ITEM_SUBCLASS_HERB:
+            return (bot->HasSkill(SKILL_HERBALISM) ||
+                bot->HasSkill(SKILL_ALCHEMY) ||
+                bot->HasSkill(SKILL_INSCRIPTION));
+        case ITEM_SUBCLASS_ELEMENTAL:
+            return true;
+        case ITEM_SUBCLASS_ENCHANTING:
+            return bot->HasSkill(SKILL_ENCHANTING);
+        }
+        break;
+    case ITEM_CLASS_RECIPE:
+        {
+            if (bot->HasSpell(proto->Spells[2].SpellId))
+                break;
+
+            switch (proto->SubClass)
+            {
+            case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                return bot->HasSkill(SKILL_LEATHERWORKING);
+            case ITEM_SUBCLASS_TAILORING_PATTERN:
+                return bot->HasSkill(SKILL_TAILORING);
+            case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                return bot->HasSkill(SKILL_ENGINEERING);
+            case ITEM_SUBCLASS_BLACKSMITHING:
+                return bot->HasSkill(SKILL_BLACKSMITHING);
+            case ITEM_SUBCLASS_COOKING_RECIPE:
+                return bot->HasSkill(SKILL_COOKING);
+            case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                return bot->HasSkill(SKILL_ALCHEMY);
+            case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                return bot->HasSkill(SKILL_FIRST_AID);
+            case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                return bot->HasSkill(SKILL_ENCHANTING);
+            case ITEM_SUBCLASS_FISHING_MANUAL:
+                return bot->HasSkill(SKILL_FISHING);
+            case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                return bot->HasSkill(SKILL_JEWELCRAFTING);
+            }
+        }
+    }
+    return false;
+}
+
+
+bool StoreLootAction::IsLootAllowed(uint32 itemid)
+{
+    LootStrategy lootStrategy = AI_VALUE(LootStrategy, "loot strategy");
+
+    if (lootStrategy == LOOTSTRATEGY_ALL)
+        return true;
+
+    set<uint32>& lootItems = AI_VALUE(set<uint32>&, "always loot list");
+    if (lootItems.find(itemid) != lootItems.end())
+        return true;
+
+    ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+    if (!proto)
+        return false;
+
+    uint32 max = proto->MaxCount;
+    if (max > 0 && bot->HasItemCount(itemid, max, true))
+        return false;
+
+    if (proto->StartQuest ||
+        proto->Bonding == BIND_QUEST_ITEM ||
+        proto->Bonding == BIND_QUEST_ITEM1 ||
+        proto->Class == ITEM_CLASS_QUEST)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_QUEST)
+        return false;
+
+    if (IsLootAllowedBySkill(proto))
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_SKILL)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_MONEY || proto->Quality == ITEM_QUALITY_POOR)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_GRAY)
+        return true;
+
+    if (proto->Bonding == BIND_WHEN_PICKED_UP)
+        return false;
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.h b/src/plugins/playerbot/strategy/actions/LootAction.h
new file mode 100644
index 0000000..63ecca0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.h
@@ -0,0 +1,40 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class LootAction : public MovementAction
+    {
+    public:
+        LootAction(PlayerbotAI* ai) : MovementAction(ai, "loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class OpenLootAction : public MovementAction
+    {
+    public:
+        OpenLootAction(PlayerbotAI* ai) : MovementAction(ai, "open loot") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool DoLoot(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject, GameObject* go);
+        bool CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go);
+        bool CanOpenLock(uint32 skillId, uint32 reqSkillValue);
+    };
+
+    class StoreLootAction : public MovementAction
+    {
+    public:
+        StoreLootAction(PlayerbotAI* ai) : MovementAction(ai, "store loot") {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool IsLootAllowed(uint32 itemid);
+        bool IsLootAllowedBySkill(ItemTemplate const * proto);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.cpp b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
new file mode 100644
index 0000000..498cb42
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootRollAction.h"
+#include "../../../Groups/Group.h"
+
+
+using namespace ai;
+
+bool LootRollAction::Execute(Event event)
+{
+    Player *bot = QueryItemUsageAction::ai->GetBot();
+
+    WorldPacket p(event.getPacket()); //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+    ObjectGuid guid;
+    uint32 slot;
+    uint8 rollType;
+    p.rpos(0); //reset packet pointer
+    p >> guid; //guid of the item rolled
+    p >> slot; //number of players invited to roll
+    p >> rollType; //need,greed or pass on roll
+
+    Group* group = bot->GetGroup();
+    if(!group)
+        return false;
+
+    RollVote vote = PASS;
+    for (vector<Roll*>::iterator i = group->GetRolls()->begin(); i != group->GetRolls()->end(); ++i)
+    {
+        if ((*i)->isValid() && (*i)->itemGUID == guid && (*i)->itemSlot == slot)
+        {
+            uint32 itemId = (*i)->itemid;
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemId);
+            if (!proto)
+                continue;
+
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_WEAPON:
+            case ITEM_CLASS_ARMOR:
+                if (QueryItemUsage(proto))
+                    vote = NEED;
+                else if (bot->HasSkill(SKILL_ENCHANTING))
+                    vote = DISENCHANT;
+                break;
+            default:
+                if (IsLootAllowed(itemId))
+                    vote = NEED;
+                break;
+            }
+            break;
+        }
+    }
+
+    switch (group->GetLootMethod())
+    {
+    case MASTER_LOOT:
+    case FREE_FOR_ALL:
+        group->CountRollVote(bot->GetGUID(), guid, PASS);
+        break;
+    default:
+        group->CountRollVote(bot->GetGUID(), guid, vote);
+        break;
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.h b/src/plugins/playerbot/strategy/actions/LootRollAction.h
new file mode 100644
index 0000000..05651a4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "../Action.h"
+#include "QueryItemUsageAction.h"
+#include "LootAction.h"
+
+namespace ai
+{
+    class LootRollAction : public QueryItemUsageAction, public StoreLootAction {
+    public:
+        LootRollAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "loot roll"), StoreLootAction(ai) {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
new file mode 100644
index 0000000..633429e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootStrategyAction.h"
+
+
+using namespace ai;
+
+
+bool LootStrategyAction::Execute(Event event)
+{
+    string strategy = event.getParam();
+
+    LootObjectStack* lootItems = AI_VALUE(LootObjectStack*, "available loot");
+    set<uint32>& alwaysLootItems = AI_VALUE(set<uint32>&, "always loot list");
+    Value<LootStrategy>* lootStrategy = context->GetValue<LootStrategy>("loot strategy");
+
+    if (strategy == "?")
+    {
+        ostringstream out;
+        out << "Loot strategy: ";
+        out << LootStrategy2string(lootStrategy->Get());
+        out << ", always loot items: ";
+
+        for (set<uint32>::iterator i = alwaysLootItems.begin(); i != alwaysLootItems.end(); i++)
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(*i);
+            if (!proto)
+                continue;
+
+            out << chat->formatItem(proto);
+        }
+        ai->TellMaster(out);
+    }
+    else
+    {
+        ItemIds items = chat->parseItems(strategy);
+
+        if (items.size() == 0)
+        {
+            lootStrategy->Set(String2LootStrategy(strategy));
+            ostringstream out;
+            out << "Loot strategy set to " << LootStrategy2string(lootStrategy->Get());
+            ai->TellMaster(out);
+            return true;
+        }
+
+        bool remove = strategy.size() > 1 && strategy.substr(0, 1) == "-";
+        for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+        {
+            uint32 itemid = *i;
+            if (remove)
+            {
+                set<uint32>::iterator j = alwaysLootItems.find(itemid);
+                if (j != alwaysLootItems.end())
+                    alwaysLootItems.erase(j);
+
+                ai->TellMaster("Item(s) removed from always loot list");
+            }
+            else
+            {
+                alwaysLootItems.insert(itemid);
+                ai->TellMaster("Item(s) added to always loot list");
+            }
+        }
+    }
+
+    return true;
+}
+
+
+LootStrategy LootStrategyAction::String2LootStrategy(string strategy)
+{
+    if (strategy == "*" || strategy == "all")
+        return LOOTSTRATEGY_ALL;
+    else if (strategy == "q" || strategy == "quest")
+        return LOOTSTRATEGY_QUEST;
+    else if (strategy == "s" || strategy == "skill")
+        return LOOTSTRATEGY_SKILL;
+    else if (strategy == "g" || strategy == "gray")
+        return LOOTSTRATEGY_GRAY;
+    else
+        return LOOTSTRATEGY_NORMAL;
+}
+
+string LootStrategyAction::LootStrategy2string(LootStrategy lootStrategy)
+{
+    switch (lootStrategy)
+    {
+    case LOOTSTRATEGY_ALL:
+        return "all";
+    case LOOTSTRATEGY_QUEST:
+        return "quest";
+    case LOOTSTRATEGY_SKILL:
+        return "skill";
+    case LOOTSTRATEGY_GRAY:
+        return "gray";
+    default:
+        return "normal";
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.h b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
new file mode 100644
index 0000000..51e1f23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class LootStrategyAction : public Action {
+    public:
+        LootStrategyAction(PlayerbotAI* ai) : Action(ai, "ll") {}
+        virtual bool Execute(Event event);
+
+    private:
+        static LootStrategy String2LootStrategy(string strategy);
+        static string LootStrategy2string(LootStrategy lootStrategy);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.cpp b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
new file mode 100644
index 0000000..36a4797
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
@@ -0,0 +1,373 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../values/LastMovementValue.h"
+#include "MovementActions.h"
+#include "../../../Movement/MotionMaster.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../FleeManager.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool MovementAction::MoveNear(uint32 mapId, float x, float y, float z, float distance)
+{
+    float angle = GetFollowAngle();
+    return MoveTo(mapId, x + cos(angle) * distance, y + sin(angle) * distance, z);
+}
+
+bool MovementAction::MoveNear(WorldObject* target, float distance)
+{
+    if (!target)
+        return false;
+
+    distance += target->GetObjectSize() / 2.0f;
+
+    float followAngle = GetFollowAngle();
+    for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+    {
+        bool moved = MoveTo(target->GetMapId(),
+            target->GetPositionX() + cos(angle) * distance,
+            target->GetPositionY()+ sin(angle) * distance,
+            target->GetPositionZ());
+        if (moved)
+            return true;
+    }
+    return false;
+}
+
+bool MovementAction::MoveTo(uint32 mapId, float x, float y, float z)
+{
+    bot->UpdateGroundPositionZ(x, y, z);
+    if (!IsMovingAllowed(mapId, x, y, z))
+        return false;
+
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.contactDistance)
+    {
+        WaitForReach(distance);
+
+        if (bot->IsSitState())
+            bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (bot->IsNonMeleeSpellCast(true))
+        {
+            bot->CastStop();
+            ai->InterruptSpell();
+        }
+
+        bool generatePath = bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) &&
+                !bot->IsFlying() && !bot->IsUnderWater();
+        MotionMaster &mm = *bot->GetMotionMaster();
+        mm.Clear();
+
+        float botZ = bot->GetPositionZ();
+        if (z - botZ > 0.5f)
+        {
+            float speed = bot->GetSpeed(MOVE_RUN);
+            mm.MoveJump(x, y, botZ + 0.5f, speed, speed, 1);
+        }
+        else
+            mm.MovePoint(mapId, x, y, z, generatePath);
+    }
+
+    AI_VALUE(LastMovement&, "last movement").Set(x, y, z, bot->GetOrientation());
+    return true;
+}
+
+bool MovementAction::MoveTo(Unit* target, float distance)
+{
+    if (!IsMovingAllowed(target))
+        return false;
+
+    float bx = bot->GetPositionX();
+    float by = bot->GetPositionY();
+    float bz = bot->GetPositionZ();
+
+    float tx = target->GetPositionX();
+    float ty = target->GetPositionY();
+    float tz = target->GetPositionZ();
+
+    float distanceToTarget = bot->GetDistance(target);
+    float angle = bot->GetAngle(target);
+    float needToGo = distanceToTarget - distance;
+
+    float maxDistance = sPlayerbotAIConfig.spellDistance;
+    if (needToGo > 0 && needToGo > maxDistance)
+        needToGo = maxDistance;
+    else if (needToGo < 0 && needToGo < -maxDistance)
+        needToGo = -maxDistance;
+
+    float dx = cos(angle) * needToGo + bx;
+    float dy = sin(angle) * needToGo + by;
+
+    return MoveTo(target->GetMapId(), dx, dy, tz);
+}
+
+float MovementAction::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+bool MovementAction::IsMovingAllowed(Unit* target)
+{
+    if (!target)
+        return false;
+
+    if (bot->GetMapId() != target->GetMapId())
+        return false;
+
+    float distance = bot->GetDistance(target);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed(uint32 mapId, float x, float y, float z)
+{
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed()
+{
+    if (bot->isFrozen() || bot->IsPolymorphed() ||
+            (bot->isDead() && !bot->GetCorpse()) ||
+            bot->IsBeingTeleported() ||
+            bot->isInRoots() ||
+            bot->HasAuraType(SPELL_AURA_MOD_CONFUSE) || bot->IsCharmed() ||
+            bot->HasAuraType(SPELL_AURA_MOD_STUN) || bot->IsFlying())
+        return false;
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    return mm.GetCurrentMovementGeneratorType() != FLIGHT_MOTION_TYPE;
+}
+
+bool MovementAction::Follow(Unit* target, float distance)
+{
+    return Follow(target, distance, GetFollowAngle());
+}
+
+bool MovementAction::Follow(Unit* target, float distance, float angle)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (!target)
+        return false;
+
+    if (bot->GetDistance2d(target->GetPositionX(), target->GetPositionY()) <= sPlayerbotAIConfig.sightDistance &&
+            abs(bot->GetPositionZ() - target->GetPositionZ()) >= sPlayerbotAIConfig.spellDistance)
+    {
+        mm.Clear();
+        float x = bot->GetPositionX(), y = bot->GetPositionY(), z = target->GetPositionZ();
+        if (target->GetMapId() && bot->GetMapId() != target->GetMapId())
+        {
+            bot->TeleportTo(target->GetMapId(), x, y, z, bot->GetOrientation());
+        }
+        else
+        {
+            bot->Relocate(x, y, z, bot->GetOrientation());
+        }
+        AI_VALUE(LastMovement&, "last movement").Set(target);
+        return true;
+    }
+
+    if (!IsMovingAllowed(target))
+        return false;
+
+    if (target->IsFriendlyTo(bot) && bot->IsMounted() && AI_VALUE(list<ObjectGuid>, "possible targets").empty())
+        distance += angle;
+
+    if (bot->GetDistance(target) <= sPlayerbotAIConfig.followDistance)
+        return false;
+
+    if (bot->IsSitState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (bot->IsNonMeleeSpellCast(true))
+    {
+        bot->CastStop();
+        ai->InterruptSpell();
+    }
+
+    mm.MoveFollow(target, distance, angle);
+
+    AI_VALUE(LastMovement&, "last movement").Set(target);
+    return true;
+}
+
+void MovementAction::WaitForReach(float distance)
+{
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+
+    if (delay > sPlayerbotAIConfig.maxWaitForMove)
+        delay = sPlayerbotAIConfig.maxWaitForMove;
+
+    Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+    Unit* player = *ai->GetAiObjectContext()->GetValue<Unit*>("enemy player target");
+    if ((player || target) && delay > sPlayerbotAIConfig.globalCoolDown)
+        delay = sPlayerbotAIConfig.globalCoolDown;
+
+    ai->SetNextCheckDelay((uint32)delay);
+}
+
+bool MovementAction::Flee(Unit *target)
+{
+    Player* master = GetMaster();
+    if (!target)
+        target = master;
+
+    if (!target)
+        return false;
+
+    if (!sPlayerbotAIConfig.fleeingEnabled)
+        return false;
+
+    if (!IsMovingAllowed())
+        return false;
+
+    FleeManager manager(bot, sPlayerbotAIConfig.fleeDistance, GetFollowAngle());
+
+    float rx, ry, rz;
+    if (!manager.CalculateDestination(&rx, &ry, &rz))
+        return false;
+
+    return MoveTo(target->GetMapId(), rx, ry, rz);
+}
+
+bool FleeAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "current target"));
+}
+
+bool FleeAction::isUseful()
+{
+    return AI_VALUE(uint8, "attacker count") > 0 &&
+            AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool RunAwayAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "master target"));
+}
+
+bool MoveRandomAction::Execute(Event event)
+{
+    WorldObject* target = NULL;
+
+    if (!(rand() % 3))
+    {
+        list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+        for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+        {
+            target = ai->GetUnit(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    if (!target || !(rand() % 3))
+    {
+        list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+        for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        {
+            target = ai->GetGameObject(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    float distance = sPlayerbotAIConfig.tooCloseDistance + sPlayerbotAIConfig.grindDistance * urand(3, 10) / 10.0f;
+
+    Map* map = bot->GetMap();
+    if (target)
+    {
+        float x = target->GetPositionX();
+        float y = target->GetPositionY();
+        float z = target->GetPositionZ();
+        if (!map->IsInWater(x, y, z))
+        {
+            return MoveNear(target);
+        }
+    }
+
+    for (int i = 0; i < 10; ++i)
+    {
+        float x = bot->GetPositionX();
+        float y = bot->GetPositionY();
+        float z = bot->GetPositionZ();
+        x += urand(0, distance) - distance / 2;
+        y += urand(0, distance) - distance / 2;
+        bot->UpdateGroundPositionZ(x, y, z);
+
+        if (map->IsInWater(x, y, z))
+            continue;
+
+        bool moved = MoveNear(bot->GetMapId(), x, y, z);
+        if (moved)
+            return true;
+    }
+
+    return false;
+}
+
+bool MoveToLootAction::Execute(Event event)
+{
+    LootObject loot = AI_VALUE(LootObject, "loot target");
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return MoveNear(loot.GetWorldObject(bot));
+}
+
+bool MoveOutOfEnemyContactAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    return MoveNear(target, sPlayerbotAIConfig.meleeDistance);
+}
+
+bool MoveOutOfEnemyContactAction::isUseful()
+{
+    return AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+}
+
+bool SetFacingTargetAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    bot->SetFacingTo(bot->GetAngle(target));
+    ai->SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+    return true;
+}
+
+bool SetFacingTargetAction::isUseful()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.h b/src/plugins/playerbot/strategy/actions/MovementActions.h
new file mode 100644
index 0000000..dc27b92
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.h
@@ -0,0 +1,92 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class MovementAction : public Action {
+    public:
+        MovementAction(PlayerbotAI* ai, string name) : Action(ai, name)
+        {
+            bot = ai->GetBot();
+        }
+
+    protected:
+        bool MoveNear(uint32 mapId, float x, float y, float z, float distance = sPlayerbotAIConfig.followDistance);
+        bool MoveTo(uint32 mapId, float x, float y, float z);
+        bool MoveTo(Unit* target, float distance = 0.0f);
+        bool MoveNear(WorldObject* target, float distance = sPlayerbotAIConfig.followDistance);
+        float GetFollowAngle();
+        bool Follow(Unit* target, float distance = sPlayerbotAIConfig.followDistance);
+        bool Follow(Unit* target, float distance, float angle);
+        void WaitForReach(float distance);
+        bool IsMovingAllowed(Unit* target);
+        bool IsMovingAllowed(uint32 mapId, float x, float y, float z);
+        bool IsMovingAllowed();
+        bool Flee(Unit *target);
+
+    protected:
+        Player* bot;
+    };
+
+    class FleeAction : public MovementAction
+    {
+    public:
+        FleeAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : MovementAction(ai, "flee")
+        {
+			this->distance = distance;
+		}
+
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+	private:
+		float distance;
+    };
+
+
+    class RunAwayAction : public MovementAction
+    {
+    public:
+        RunAwayAction(PlayerbotAI* ai) : MovementAction(ai, "runaway") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveRandomAction : public MovementAction
+    {
+    public:
+        MoveRandomAction(PlayerbotAI* ai) : MovementAction(ai, "move random") {}
+        virtual bool Execute(Event event);
+        virtual bool isPossible()
+        {
+            return MovementAction::isPossible() &&
+                    AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                    (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana);
+        }
+    };
+
+    class MoveToLootAction : public MovementAction
+    {
+    public:
+        MoveToLootAction(PlayerbotAI* ai) : MovementAction(ai, "move to loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveOutOfEnemyContactAction : public MovementAction
+    {
+    public:
+        MoveOutOfEnemyContactAction(PlayerbotAI* ai) : MovementAction(ai, "move out of enemy contact") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class SetFacingTargetAction : public MovementAction
+    {
+    public:
+        SetFacingTargetAction(PlayerbotAI* ai) : MovementAction(ai, "set facing") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
new file mode 100644
index 0000000..56961c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.h b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
new file mode 100644
index 0000000..d66e92c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "UseItemAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class DrinkAction : public UseItemAction
+    {
+    public:
+        DrinkAction(PlayerbotAI* ai) : UseItemAction(ai, "drink") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+        }
+    };
+
+    class EatAction : public UseItemAction
+    {
+    public:
+        EatAction(PlayerbotAI* ai) : UseItemAction(ai, "food") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.lowHealth;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
new file mode 100644
index 0000000..fb558df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class PassLeadershipToMasterAction : public Action {
+    public:
+        PassLeadershipToMasterAction(PlayerbotAI* ai) : Action(ai, "leader") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+            if (master && bot->GetGroup() && bot->GetGroup()->IsMember(master->GetGUID()))
+            {
+                WorldPacket p(SMSG_GROUP_SET_LEADER, 8);
+                p << master->GetGUID();
+                bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                return true;
+            }
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.cpp b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
new file mode 100644
index 0000000..242c7fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionAction.h"
+#include "../values/PositionValue.h"
+
+using namespace ai;
+
+bool PositionAction::Execute(Event event)
+{
+	string qualifier = event.getParam();
+	if (qualifier.empty())
+		return false;
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    pos.Set( master->GetPositionX(), master->GetPositionY(), master->GetPositionZ());
+
+    ostringstream out; out << "Position " << qualifier << " is set";
+    ai->TellMaster(out);
+    return true;
+}
+
+bool MoveToPositionAction::Execute(Event event)
+{
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    if (!pos.isSet())
+    {
+        ostringstream out; out << "Position " << qualifier << " is not set";
+        ai->TellMaster(out);
+        return false;
+    }
+
+    return MoveTo(bot->GetMapId(), pos.x, pos.y, pos.z);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.h b/src/plugins/playerbot/strategy/actions/PositionAction.h
new file mode 100644
index 0000000..f96553b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class PositionAction : public Action
+    {
+    public:
+        PositionAction(PlayerbotAI* ai) : Action(ai, "position")
+        {}
+
+        virtual bool Execute(Event event);
+
+    };
+
+    class MoveToPositionAction : public MovementAction
+    {
+    public:
+        MoveToPositionAction(PlayerbotAI* ai, string qualifier) : MovementAction(ai, "move to position"), qualifier(qualifier)
+        {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        string qualifier;
+    };
+
+    class GuardAction : public MoveToPositionAction
+    {
+    public:
+        GuardAction(PlayerbotAI* ai) : MoveToPositionAction(ai, "guard")
+        {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
new file mode 100644
index 0000000..95087bf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
@@ -0,0 +1,195 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryItemUsageAction.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+
+using namespace ai;
+
+
+bool QueryItemUsageAction::Execute(Event event)
+{
+    WorldPacket& data = event.getPacket();
+    if (!data.empty())
+    {
+        data.rpos(0);
+
+        ObjectGuid guid;
+        data >> guid;
+        if (guid.GetRawValue() != bot->GetGUID())
+            return false;
+
+        uint32 received, created, isShowChatMessage, notUsed, itemId,
+            suffixFactor, itemRandomPropertyId, count, invCount;
+        uint8 bagSlot;
+
+        data >> received;                               // 0=looted, 1=from npc
+        data >> created;                                // 0=received, 1=created
+        data >> isShowChatMessage;                                      // IsShowChatMessage
+        data >> bagSlot;
+                                                                // item slot, but when added to stack: 0xFFFFFFFF
+        data >> notUsed;
+        data >> itemId;
+        data >> suffixFactor;
+        data >> itemRandomPropertyId;
+        data >> count;
+        data >> invCount;
+
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(itemId);
+        if (!item)
+            return false;
+
+        ostringstream out; out << chat->formatItem(item, count);
+        if (created)
+            out << " created";
+        else if (received)
+            out << " received";
+        ai->TellMaster(out);
+
+        QueryItemUsage(item);
+        QueryQuestItem(itemId);
+        return true;
+    }
+
+    string text = event.getParam();
+
+    ItemIds items = chat->parseItems(text);
+    QueryItemsUsage(items);
+    return true;
+}
+
+bool QueryItemUsageAction::QueryItemUsage(ItemTemplate const *item)
+{
+    Player *bot = ai->GetBot();
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return false;
+
+    if (item->InventoryType == INVTYPE_NON_EQUIP)
+        return false;
+
+    Item *pItem = Item::CreateItem(item->ItemId, 1, bot);
+    if (!pItem)
+        return false;
+
+    uint16 dest;
+    InventoryResult result = bot->CanEquipItem(NULL_SLOT, dest, pItem, true, false);
+    pItem->RemoveFromUpdateQueueOf(bot);
+    delete pItem;
+
+    if( result != EQUIP_ERR_OK )
+        return false;
+
+    Item* existingItem = bot->GetItemByPos(dest);
+    if (!existingItem)
+    {
+        ai->TellMaster("Equip");
+        return true;
+    }
+
+    bool equip = false;
+    const ItemTemplate* oldItem = existingItem->GetTemplate();
+    if (oldItem->ItemLevel < item->ItemLevel && oldItem->ItemId != item->ItemId)
+    {
+        switch (item->Class)
+        {
+        case ITEM_CLASS_ARMOR:
+            equip = (oldItem->SubClass <= item->SubClass);
+            break;
+        default:
+            equip = true;
+        }
+    }
+
+    if (equip)
+    {
+        ostringstream out;
+        out << "Replace +";
+        out << (item->ItemLevel - oldItem->ItemLevel);
+        out << " lvl";
+        ai->TellMaster(out.str());
+        return true;
+    }
+
+    return false;
+}
+
+void QueryItemUsageAction::QueryItemPrice(ItemTemplate const *item)
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    if (item->Bonding == BIND_WHEN_PICKED_UP)
+        return;
+
+    list<Item*> items = InventoryAction::parseItems(item->Name1);
+    if (!items.empty())
+    {
+        for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        {
+            Item* sell = *i;
+            int32 sellPrice = sell->GetCount() * auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+            ostringstream out;
+            out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+            ai->TellMaster(out.str());
+        }
+    }
+
+    int32 buyPrice = auctionbot.GetBuyPrice(item) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+    if (buyPrice)
+    {
+        ostringstream out;
+        out << "Will buy for " << chat->formatMoney(buyPrice);
+        ai->TellMaster(out.str());
+    }
+}
+
+void QueryItemUsageAction::QueryItemsUsage(ItemIds items)
+{
+    for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(*i);
+        QueryItemUsage(item);
+        QueryQuestItem(*i);
+        QueryItemPrice(item);
+    }
+}
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId)
+{
+    Player *bot = ai->GetBot();
+    QuestStatusMap const& questMap = bot->getQuestStatusMap();
+    for (QuestStatusMap::const_iterator i = questMap.begin(); i != questMap.end(); i++)
+    {
+        const Quest *questTemplate = sObjectMgr->GetQuestTemplate( i->first );
+        if( !questTemplate )
+            continue;
+
+        uint32 questId = questTemplate->GetQuestId();
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || (status == QUEST_STATE_COMPLETE && !bot->GetQuestRewardStatus(questId)))
+        {
+            QuestStatusData const& questStatus = i->second;
+            QueryQuestItem(itemId, questTemplate, &questStatus);
+        }
+    }
+}
+
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus)
+{
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (questTemplate->RequiredItemId[i] != itemId)
+            continue;
+
+        int required = questTemplate->RequiredItemCount[i];
+        int available = questStatus->ItemCount[i];
+
+        if (!required)
+            continue;
+
+        ai->TellMaster(chat->formatQuestObjective(chat->formatQuest(questTemplate), available, required));
+    }
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
new file mode 100644
index 0000000..643ae96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class QueryItemUsageAction : public InventoryAction {
+    public:
+        QueryItemUsageAction(PlayerbotAI* ai, string name = "query item usage") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        void QueryItemsUsage(ItemIds items);
+        bool QueryItemUsage(ItemTemplate const *item);
+        void QueryItemPrice(ItemTemplate const *item);
+        void QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus);
+        void QueryQuestItem(uint32 itemId);
+
+    private:
+        ostringstream out;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
new file mode 100644
index 0000000..33eddca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
@@ -0,0 +1,89 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryQuestAction.h"
+
+
+using namespace ai;
+
+void QueryQuestAction::TellObjective(string name, int available, int required)
+{
+    ai->TellMaster(chat->formatQuestObjective(name, available, required));
+}
+
+
+bool QueryQuestAction::Execute(Event event)
+{
+
+    Player *bot = ai->GetBot();
+    string text = event.getParam();
+
+    PlayerbotChatHandler ch(bot);
+    uint32 questId = ch.extractQuestId(text);
+    if (!questId)
+        return false;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        if(questId != bot->GetQuestSlotQuestId(slot))
+            continue;
+
+        ostringstream out;
+        out << "--- " << chat->formatQuest(sObjectMgr->GetQuestTemplate(questId)) << " ";
+        if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        {
+            out << "|c0000FF00completed|r ---";
+            ai->TellMaster(out);
+        }
+        else
+        {
+            out << "|c00FF0000not completed|r ---";
+            ai->TellMaster(out);
+            TellObjectives(questId);
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+void QueryQuestAction::TellObjectives(uint32 questId)
+{
+    Quest const* questTemplate = sObjectMgr->GetQuestTemplate(questId);
+    QuestStatusMap &questMap = bot->getQuestStatusMap();
+    QuestStatusData questStatus = questMap[questId];
+
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (!questTemplate->ObjectiveText[i].empty())
+            ai->TellMaster(questTemplate->ObjectiveText[i]);
+
+        if (questTemplate->RequiredItemId[i])
+        {
+            int required = questTemplate->RequiredItemCount[i];
+            int available = questStatus.ItemCount[i];
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(questTemplate->RequiredItemId[i]);
+            TellObjective(chat->formatItem(proto), available, required);
+        }
+
+        if (questTemplate->RequiredNpcOrGo[i])
+        {
+            int required = questTemplate->RequiredNpcOrGoCount[i];
+            int available = questStatus.CreatureOrGOCount[i];
+
+            if (questTemplate->RequiredNpcOrGo[i] < 0)
+            {
+                GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->name, available, required);
+            }
+            else
+            {
+
+                CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->Name, available, required);
+            }
+        }
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.h b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
new file mode 100644
index 0000000..1822293
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class QueryQuestAction : public Action {
+    public:
+        QueryQuestAction(PlayerbotAI* ai) : Action(ai, "query quest") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellObjectives(uint32 questId);
+        void TellObjective(string name, int available, int required);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.cpp b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
new file mode 100644
index 0000000..2b1cfbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool QuestAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!guid)
+    {
+        Unit* target = master->GetSelectedUnit();
+        if (target)
+            guid = target->GetGUID();
+    }
+
+    if (!guid)
+        return false;
+
+    return ProcessQuests(guid);
+}
+
+bool QuestAction::ProcessQuests(ObjectGuid questGiver)
+{
+    GameObject *gameObject = ai->GetGameObject(questGiver);
+    if (gameObject && gameObject->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+        return ProcessQuests(gameObject);
+
+    Creature* creature = ai->GetCreature(questGiver);
+    if (creature)
+        return ProcessQuests(creature);
+
+    return false;
+}
+
+bool QuestAction::ProcessQuests(WorldObject* questGiver)
+{
+    ObjectGuid guid = questGiver->GetGUID();
+
+    if (bot->GetDistance(questGiver) > INTERACTION_DISTANCE)
+    {
+        ai->TellMaster("Cannot talk to quest giver");
+        return false;
+    }
+
+    if (!bot->isInFront(questGiver, M_PI / 2))
+        bot->SetFacingTo(bot->GetAngle(questGiver));
+
+    bot->SetSelection(guid);
+    bot->PrepareQuestMenu(guid);
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 i = 0; i < questMenu.GetMenuItemCount(); ++i)
+    {
+        QuestMenuItem const& menuItem = questMenu.GetItem(i);
+        uint32 questID = menuItem.QuestId;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(questID);
+        if (!quest)
+            continue;
+
+        ProcessQuest(quest, questGiver);
+    }
+
+    return true;
+}
+
+bool QuestAction::AcceptQuest(Quest const* quest, uint64 questGiver)
+{
+    std::ostringstream out;
+
+    uint32 questId = quest->GetQuestId();
+
+    if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        out << "Already completed";
+    else if (! bot->CanTakeQuest(quest, false))
+    {
+        if (! bot->SatisfyQuestStatus(quest, false))
+            out << "Already on";
+        else
+            out << "Can't take";
+    }
+    else if (! bot->SatisfyQuestLog(false))
+        out << "Quest log is full";
+    else if (! bot->CanAddQuest(quest, false))
+        out << "Bags are full";
+
+    else
+    {
+        WorldPacket p(CMSG_QUESTGIVER_ACCEPT_QUEST);
+        uint32 unk1 = 0;
+        p << questGiver << questId << unk1;
+        p.rpos(0);
+        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+
+        if (bot->GetQuestStatus(questId) != QUEST_STATUS_NONE)
+        {
+            out << "Accepted " << chat->formatQuest(quest);
+            ai->TellMaster(out);
+            return true;
+        }
+    }
+
+    out << " " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+    return false;
+}
+
+bool QuestObjectiveCompletedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    uint32 entry, questId, available, required;
+    ObjectGuid guid;
+    p >> questId >> entry >> available >> required >> guid;
+
+    if (entry & 0x80000000)
+    {
+        entry &= 0x7FFFFFFF;
+        GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->name, available, required));
+    }
+    else
+    {
+        CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->Name, available, required));
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.h b/src/plugins/playerbot/strategy/actions/QuestAction.h
new file mode 100644
index 0000000..97010ed
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Quests/QuestDef.h"
+
+namespace ai
+{
+    class QuestAction : public Action
+    {
+    public:
+        QuestAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver) = 0;
+
+    protected:
+        bool AcceptQuest(Quest const* quest, uint64 questGiver);
+        bool ProcessQuests(ObjectGuid questGiver);
+        bool ProcessQuests(WorldObject* questGiver);
+    };
+
+    class QuestObjectiveCompletedAction : public Action
+    {
+    public:
+        QuestObjectiveCompletedAction(PlayerbotAI* ai) : Action(ai, "quest objective completed") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReachTargetActions.h b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
new file mode 100644
index 0000000..c988365
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ReachTargetAction : public MovementAction
+    {
+    public:
+        ReachTargetAction(PlayerbotAI* ai, string name, float distance) : MovementAction(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool Execute(Event event)
+		{
+			return MoveTo(AI_VALUE(Unit*, "current target"), distance);
+        }
+        virtual bool isUseful()
+		{
+            return AI_VALUE2(float, "distance", "current target") > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class CastReachTargetSpellAction : public CastSpellAction
+    {
+    public:
+        CastReachTargetSpellAction(PlayerbotAI* ai, string spell, float distance) : CastSpellAction(ai, spell)
+		{
+            this->distance = distance;
+        }
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(float, "distance", "current target") > distance;
+		}
+
+    protected:
+        float distance;
+    };
+
+    class ReachMeleeAction : public ReachTargetAction
+	{
+    public:
+        ReachMeleeAction(PlayerbotAI* ai) : ReachTargetAction(ai, "reach melee", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class ReachSpellAction : public ReachTargetAction
+	{
+    public:
+        ReachSpellAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : ReachTargetAction(ai, "reach spell", distance) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
new file mode 100644
index 0000000..98f8c4b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
@@ -0,0 +1,84 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReadyCheckAction.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+bool ReadyCheckAction::Execute(Event event)
+{
+    WorldPacket &p = event.getPacket();
+	ObjectGuid player;
+	p.rpos(0);
+    if (!p.empty())
+        p >> player;
+
+	if (player.GetRawValue() == bot->GetGUID())
+        return false;
+
+	return ReadyCheck();
+}
+
+bool ReadyCheckAction::ReadyCheck()
+{
+    bool health = AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.almostFullHealth;
+    if (!health)
+    {
+        ai->TellMaster("Low health!");
+        return false;
+    }
+
+    bool mana = !AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumHealth;
+    if (!mana)
+    {
+        ai->TellMaster("Low mana!");
+        return false;
+    }
+
+    Player* master = GetMaster();
+    if (master)
+    {
+        bool distance = bot->GetDistance(master) <= sPlayerbotAIConfig.sightDistance;
+        if (!distance)
+        {
+            ai->TellMaster("Too far away!");
+            return false;
+        }
+    }
+
+    if (bot->getClass() == CLASS_HUNTER)
+    {
+        if (!bot->GetUInt32Value(PLAYER_AMMO_ID))
+        {
+            ai->TellMaster("Out of ammo!");
+            return false;
+        }
+
+        if (!bot->GetPet())
+        {
+            ai->TellMaster("No pet!");
+            return false;
+        }
+
+        if (bot->GetPet()->GetHappinessState() == UNHAPPY)
+        {
+            ai->TellMaster("Pet is unhappy!");
+            return false;
+        }
+    }
+
+    WorldPacket* const packet = new WorldPacket(MSG_RAID_READY_CHECK);
+    *packet << bot->GetGUID();
+    *packet << uint8(1);
+    bot->GetSession()->QueuePacket(packet);
+
+    ai->ChangeStrategy("-ready check", BOT_STATE_NON_COMBAT);
+
+    return true;
+}
+
+bool FinishReadyCheckAction::Execute(Event event)
+{
+    return ReadyCheck();
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
new file mode 100644
index 0000000..0e26b61
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ReadyCheckAction : public Action
+    {
+    public:
+        ReadyCheckAction(PlayerbotAI* ai, string name = "ready check") : Action(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool ReadyCheck();
+    };
+
+    class FinishReadyCheckAction : public ReadyCheckAction
+    {
+    public:
+        FinishReadyCheckAction(PlayerbotAI* ai) : ReadyCheckAction(ai, "finish ready check") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
new file mode 100644
index 0000000..47ce1e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+	class ReleaseSpiritAction : public Action {
+	public:
+		ReleaseSpiritAction(PlayerbotAI* ai) : Action(ai, "release") {}
+
+    public:
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive() || bot->GetCorpse())
+                return false;
+
+            ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+            bot->SetBotDeathTimer();
+            bot->BuildPlayerRepop();
+
+            bot->RepopAtGraveyard();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
new file mode 100644
index 0000000..7b17096
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RememberTaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool RememberTaxiAction::Execute(Event event)
+{
+    
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    switch (p.GetOpcode())
+    {
+    case CMSG_ACTIVATETAXI:
+        {
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            movement.taxiNodes.resize(2);
+
+            p >> movement.taxiMaster >> movement.taxiNodes[0] >> movement.taxiNodes[1];
+            return true;
+        }
+    case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            ObjectGuid guid;
+            uint32 node_count;
+            p >> guid >> node_count;
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                movement.taxiNodes.push_back(node);
+            }
+
+            return true;
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
new file mode 100644
index 0000000..16c1f07
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class RememberTaxiAction : public Action {
+	public:
+		RememberTaxiAction(PlayerbotAI* ai) : Action(ai, "remember taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
new file mode 100644
index 0000000..7104792
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RepairAllAction.h"
+
+
+using namespace ai;
+
+bool RepairAllAction::Execute(Event event)
+{
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_REPAIR);
+        if (!unit)
+            continue;
+
+        bot->SetFacingToObject(unit);
+        float discountMod = bot->GetReputationPriceDiscount(unit);
+        uint32 totalCost = bot->DurabilityRepairAll(true, discountMod, false);
+
+        ostringstream out;
+        out << "Repair: " << chat->formatMoney(totalCost) << " (" << unit->GetName() << ")";
+        ai->TellMasterNoFacing(out.str());
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any npc to repair at");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.h b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
new file mode 100644
index 0000000..33c7abf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RepairAllAction : public Action 
+    {
+    public:
+        RepairAllAction(PlayerbotAI* ai) : Action(ai, "repair") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
new file mode 100644
index 0000000..995f241
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ResetAiAction.h"
+
+using namespace ai;
+
+bool ResetAiAction::Execute(Event event)
+{
+    ai->ResetStrategies();
+    ai->TellMaster("AI was reset to defaults");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.h b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
new file mode 100644
index 0000000..929abcb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class ResetAiAction : public Action {
+    public:
+        ResetAiAction(PlayerbotAI* ai) : Action(ai, "reset ai") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
new file mode 100644
index 0000000..88e4a23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReviveFromCorpseAction.h"
+#include "../../PlayerbotFactory.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ReviveFromCorpseAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    time_t reclaimTime = corpse->GetGhostTime() + bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP );
+    if (reclaimTime > time(0) || corpse->GetDistance(bot) > sPlayerbotAIConfig.spellDistance)
+        return false;
+
+    bot->ResurrectPlayer(0.5f);
+    bot->SpawnCorpseBones();
+    bot->SaveToDB();
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    bot->SetSelection(ObjectGuid::Empty);
+    return true;
+}
+
+bool SpiritHealerAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit && unit->IsSpiritHealer())
+        {
+            PlayerbotChatHandler ch(bot);
+            bot->ResurrectPlayer(0.5f);
+            bot->SpawnCorpseBones();
+            bot->SaveToDB();
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid::Empty);
+            return true;
+        }
+    }
+
+    ai->TellMaster("Cannot find any spirit healer nearby");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
new file mode 100644
index 0000000..0e3a8cb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+	class ReviveFromCorpseAction : public Action {
+	public:
+		ReviveFromCorpseAction(PlayerbotAI* ai) : Action(ai, "revive") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+	class SpiritHealerAction : public Action {
+	public:
+	    SpiritHealerAction(PlayerbotAI* ai) : Action(ai, "spirit healer") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.cpp b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
new file mode 100644
index 0000000..c85db71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RewardAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool RewardAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    uint32 itemId = *itemIds.begin();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (npc && Reward(itemId, npc))
+            return true;
+    }
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go && Reward(itemId, go))
+            return true;
+    }
+
+    ai->TellMaster("Cannot talk to quest giver");
+    return false;
+}
+
+bool RewardAction::Reward(uint32 itemId, Object* questGiver)
+{
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+        QuestStatus status = bot->GetQuestStatus(questID);
+
+        // if quest is complete, turn it in
+        if (status == QUEST_STATUS_COMPLETE &&
+            ! bot->GetQuestRewardStatus(questID) &&
+            pQuest->GetRewChoiceItemsCount() > 1 &&
+            bot->CanRewardQuest(pQuest, false))
+        {
+            for (uint8 rewardIdx=0; rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+            {
+                ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                if (itemId == pRewardItem->ItemId)
+                {
+                    bot->RewardQuest(pQuest, rewardIdx, questGiver, false);
+
+                    string questTitle  = pQuest->GetTitle();
+                    string itemName = pRewardItem->Name1;
+
+                    ostringstream out; out << chat->formatItem(pRewardItem) << " rewarded";
+                    ai->TellMaster(out);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.h b/src/plugins/playerbot/strategy/actions/RewardAction.h
new file mode 100644
index 0000000..f4eda13
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class RewardAction : public InventoryAction {
+    public:
+        RewardAction(PlayerbotAI* ai) : InventoryAction(ai, "reward") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Reward(uint32 itemId, Object* pNpc);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RtiAction.h b/src/plugins/playerbot/strategy/actions/RtiAction.h
new file mode 100644
index 0000000..f0cca94
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RtiAction.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RtiAction : public Action
+    {
+    public:
+        RtiAction(PlayerbotAI* ai) : Action(ai, "rti")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            string text = event.getParam();
+            if (text.empty() || text == "?")
+            {
+                ostringstream out; out << "RTI: ";
+                AppendRti(out);
+                ai->TellMaster(out);
+                return true;
+            }
+
+            context->GetValue<string>("rti")->Set(text);
+            ostringstream out; out << "RTI set to: ";
+            AppendRti(out);
+            ai->TellMaster(out);
+            return true;
+        }
+
+    private:
+        void AppendRti(ostringstream & out)
+        {
+            out << AI_VALUE(string, "rti");
+
+            Unit* target = AI_VALUE(Unit*, "rti target");
+            if(target)
+                out << " (" << target->GetName() << ")";
+
+        }
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
new file mode 100644
index 0000000..c5d56a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SaveManaAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool SaveManaAction::Execute(Event event)
+{
+    string text = event.getParam();
+    double value = AI_VALUE(double, "mana save level");
+
+    if (text == "?")
+    {
+        ostringstream out; out << "Mana save level: " << format(value);
+        ai->TellMaster(out);
+        return true;
+    }
+
+    if (text == "*")
+    {
+        switch (bot->getClass())
+        {
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+        case CLASS_DRUID:
+            value = 5.0;
+            break;
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_WARLOCK:
+            value = 2.0;
+            break;
+        default:
+            value = 3.0;
+        }
+    }
+    else if (text.empty())
+    {
+        value = 1.0;
+    }
+    else
+    {
+        value = atof(text.c_str());
+    }
+
+    value = min(10.0, value);
+    value = max(1.0, value);
+    value = floor(value * 100 + 0.5) / 100.0;
+
+    ai->GetAiObjectContext()->GetValue<double>("mana save level")->Set(value);
+
+    ostringstream out; out << "Mana save level set: " << format(value);
+    ai->TellMaster(out);
+
+    return true;
+}
+
+string SaveManaAction::format(double value)
+{
+    ostringstream out;
+    if (value <= 1.0)
+        out << "|cFF808080";
+    else if (value <= 5.0)
+        out << "|cFF00FF00";
+    else if (value <= 7.0)
+        out << "|cFFFFFF00";
+    else
+        out << "|cFFFF0000";
+    out << value << "|cffffffff";
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.h b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
new file mode 100644
index 0000000..3d9b3e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SaveManaAction : public Action
+    {
+    public:
+        SaveManaAction(PlayerbotAI* ai) : Action(ai, "save mana") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        string format(double value);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
new file mode 100644
index 0000000..891b03c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "SecurityCheckAction.h"
+#include "../../../Groups/Group.h"
+
+using namespace ai;
+
+
+bool SecurityCheckAction::isUseful()
+{
+    return sRandomPlayerbotMgr.IsRandomBot(bot) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER;
+}
+
+bool SecurityCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        LootMethod method = group->GetLootMethod();
+        ItemQualities threshold = group->GetLootThreshold();
+        if (method == MASTER_LOOT || method == FREE_FOR_ALL || threshold > ITEM_QUALITY_UNCOMMON)
+        {
+            ai->TellMaster("I won't do anything until you change loot type to group loot with green threshold");
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_NON_COMBAT);
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_COMBAT);
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
new file mode 100644
index 0000000..4ae38f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class SecurityCheckAction : public Action
+    {
+    public:
+        SecurityCheckAction(PlayerbotAI* ai) : Action(ai, "security check") {}
+        virtual bool isUseful();
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.cpp b/src/plugins/playerbot/strategy/actions/SellAction.cpp
new file mode 100644
index 0000000..1af725c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.cpp
@@ -0,0 +1,95 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SellAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+class SellItemsVisitor : public IterateItemsVisitor
+{
+public:
+    SellItemsVisitor(SellAction* action) : IterateItemsVisitor()
+    {
+        this->action = action;
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        action->Sell(item);
+        return true;
+    }
+
+private:
+    SellAction* action;
+};
+
+class SellGrayItemsVisitor : public SellItemsVisitor
+{
+public:
+    SellGrayItemsVisitor(SellAction* action) : SellItemsVisitor(action) {}
+
+    virtual bool Visit(Item* item)
+    {
+        if (item->GetTemplate()->Quality != ITEM_QUALITY_POOR)
+            return true;
+
+        return SellItemsVisitor::Visit(item);
+    }
+};
+
+
+bool SellAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    string text = event.getParam();
+
+    if (text == "gray" || text == "*")
+    {
+        SellGrayItemsVisitor visitor(this);
+        IterateItems(&visitor);
+        return true;
+    }
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        Sell(&visitor);
+    }
+
+    return true;
+}
+
+
+void SellAction::Sell(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        Sell(*i);
+}
+
+void SellAction::Sell(Item* item)
+{
+    Player* master = GetMaster();
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+    {
+        ai->TellMaster("Select a vendor first");
+        return;
+    }
+
+    ObjectGuid itemguid = item->GetGUID();
+    uint32 count = item->GetCount();
+
+    WorldPacket p;
+    p << vendor->GetGUID() << itemguid << count;
+    bot->GetSession()->HandleSellItemOpcode(p);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " sold";
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.h b/src/plugins/playerbot/strategy/actions/SellAction.h
new file mode 100644
index 0000000..c1f0915
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SellAction : public InventoryAction {
+    public:
+        SellAction(PlayerbotAI* ai) : InventoryAction(ai, "sell") {}
+        virtual bool Execute(Event event);
+
+        void Sell(FindItemVisitor* visitor);
+        void Sell(Item* item);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
new file mode 100644
index 0000000..1b2d22f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SetHomeAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool SetHomeAction::Execute(Event event)
+{
+    Player* master = ai->GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (unit && unit->IsInnkeeper())
+    {
+        float angle = GetFollowAngle();
+        float x = unit->GetPositionX() + sPlayerbotAIConfig.followDistance * cos(angle);
+        float y = unit->GetPositionY() + sPlayerbotAIConfig.followDistance * sin(angle);
+        float z = unit->GetPositionZ();
+        WorldLocation loc(unit->GetMapId(), x, y, z);
+        bot->SetHomebind(loc, unit->GetAreaId());
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_INNKEEPER);
+        if (!unit)
+            continue;
+
+        bot->GetSession()->SendBindPoint(unit);
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    ai->TellMaster("Can't find any innkeeper around");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.h b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
new file mode 100644
index 0000000..b98a5b5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SetHomeAction : public MovementAction {
+    public:
+        SetHomeAction(PlayerbotAI* ai) : MovementAction(ai, "home") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.cpp b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
new file mode 100644
index 0000000..50f6669
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
@@ -0,0 +1,145 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsAction.h"
+
+
+using namespace ai;
+
+bool StatsAction::Execute(Event event)
+{
+    ostringstream out;
+
+    ListGold(out);
+
+    out << ", ";
+    ListBagSlots(out);
+
+    out << ", ";
+    ListRepairCost(out);
+
+    if (bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP))
+    {
+        out << ", ";
+        ListXP(out);
+    }
+
+    ai->TellMaster(out);
+    return true;
+}
+
+void StatsAction::ListGold(ostringstream &out)
+{
+    out << chat->formatMoney(bot->GetMoney());
+}
+
+void StatsAction::ListBagSlots(ostringstream &out)
+{
+    uint32 totalused = 0, total = 16;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+	string color = "ff00ff00";
+	if (totalfree < total / 2)
+		color = "ffffff00";
+	if (totalfree < total / 4)
+		color = "ffff0000";
+    out << "|h|c" << color << (total - totalfree) << "/" << total << "|h|cffffffff Bag";
+}
+
+void StatsAction::ListXP( ostringstream &out )
+{
+    uint32 curXP = bot->GetUInt32Value(PLAYER_XP);
+    uint32 nextLevelXP = bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 xpPercent = 0;
+    if (nextLevelXP)
+        xpPercent = 100 * curXP / nextLevelXP;
+
+    out << "|r|cff00ff00" << xpPercent << "|r|cffffd333%" << "|h|cffffffff XP";
+}
+
+void StatsAction::ListRepairCost(ostringstream &out)
+{
+    out << chat->formatMoney(EstRepairAll()) << " Repair";
+}
+
+uint32 StatsAction::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(( (INVENTORY_SLOT_BAG_0 << 8) | i ));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for(int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for(int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(( (j << 8) | i ));
+    return TotalCost;
+}
+
+uint32 StatsAction::EstRepair(uint16 pos)
+{
+    Item* item = bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if(!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if(!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if(LostDurability>0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if(!dcost)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if(!dQualitymodEntry)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class,ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+        if (costs==0)                                   //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.h b/src/plugins/playerbot/strategy/actions/StatsAction.h
new file mode 100644
index 0000000..e30558c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class StatsAction : public Action {
+    public:
+        StatsAction(PlayerbotAI* ai) : Action(ai, "stats") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListBagSlots(ostringstream &out);
+        void ListXP(ostringstream &out);
+        void ListRepairCost(ostringstream &out);
+        void ListGold(ostringstream &out);
+        uint32 EstRepairAll();
+        uint32 EstRepair(uint16 pos);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.cpp b/src/plugins/playerbot/strategy/actions/StayActions.cpp
new file mode 100644
index 0000000..32ebd0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayActions.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+void StayActionBase::Stay()
+{
+    AI_VALUE(LastMovement&, "last movement").Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (mm.GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE || bot->IsFlying())
+        return;
+
+    mm.Clear();
+    mm.MoveIdle();
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    if (!bot->IsStandState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+bool StayAction::Execute(Event event)
+{
+    Stay();
+
+    return true;
+}
+
+bool StayAction::isUseful()
+{
+    return !AI_VALUE2(bool, "moving", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.h b/src/plugins/playerbot/strategy/actions/StayActions.h
new file mode 100644
index 0000000..ccbe2e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class StayActionBase : public MovementAction {
+    public:
+        StayActionBase(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    protected:
+        void Stay();
+    };
+
+    class StayAction : public StayActionBase {
+    public:
+        StayAction(PlayerbotAI* ai) : StayActionBase(ai, "stay") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
new file mode 100644
index 0000000..3f46f77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
@@ -0,0 +1,255 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SuggestWhatToDoAction.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+SuggestWhatToDoAction::SuggestWhatToDoAction(PlayerbotAI* ai) : InventoryAction(ai, "suggest what to do"), suggested(false)
+{
+    suggestions.push_back(&SuggestWhatToDoAction::instance);
+    suggestions.push_back(&SuggestWhatToDoAction::specificQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::newQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::grindMaterials);
+    suggestions.push_back(&SuggestWhatToDoAction::trade);
+    suggestions.push_back(&SuggestWhatToDoAction::grindReputation);
+    suggestions.push_back(&SuggestWhatToDoAction::nothing);
+    suggestions.push_back(&SuggestWhatToDoAction::relax);
+    suggestions.push_back(&SuggestWhatToDoAction::achievement);
+}
+
+bool SuggestWhatToDoAction::Execute(Event event)
+{
+    if (suggested)
+    {
+        trade();
+        return true;
+    }
+
+    if (bot->GetInstanceId() || suggested)
+        return false;
+
+    int index = rand() % suggestions.size();
+    (this->*suggestions[index])();
+
+    return suggested = true;
+}
+
+void SuggestWhatToDoAction::instance()
+{
+    uint32 level = bot->getLevel();
+    if (level > 15)
+    {
+        switch (urand(0, 5))
+        {
+        case 0:
+            spam("Need a tank for an instance run");
+            break;
+        case 1:
+            spam("Need a healer for an instance run");
+            break;
+        case 2:
+            spam("I would like to do an instance run. Would you like to join me?");
+            break;
+        case 3:
+            spam("Need better equipment. Why not do an instance run?");
+            break;
+        case 4:
+            spam("Have dungeon quests? Can join your group!");
+            break;
+        case 5:
+            spam("Have group quests? Invite me!");
+            break;
+        default:
+            spam("Hey, why not join Dungeon Finder?");
+        }
+    }
+}
+
+vector<uint32> SuggestWhatToDoAction::GetIncompletedQuests()
+{
+    vector<uint32> result;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || status == QUEST_STATUS_NONE)
+            result.push_back(questId);
+    }
+
+    return result;
+}
+
+void SuggestWhatToDoAction::specificQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.empty())
+        return;
+
+    int index = rand() % quests.size();
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(quests[index]);
+    ostringstream out; out << "We could do some quest, for instance " << chat->formatQuest(quest);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::newQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.size() < MAX_QUEST_LOG_SIZE - 5)
+        spam("I would like to pick up and do a new quest. Just invite me!");
+}
+
+void SuggestWhatToDoAction::grindMaterials()
+{
+    if (bot->getLevel() <= 5)
+        return;
+
+    switch (urand(0, 5))
+    {
+    case 0:
+        spam("Need help for tradeskill?");
+        break;
+    case 1:
+        spam("Can we have some trade material grinding?");
+        break;
+    case 2:
+        spam("I have some trade materials for sell");
+        break;
+    default:
+        spam("I am going to grind some trade materials. Would you like to join me?");
+    }
+}
+
+void SuggestWhatToDoAction::grindReputation()
+{
+    if (bot->getLevel() > 15)
+        ai->TellMasterNoFacing("I think we should do something to improve our reputation", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::nothing()
+{
+    ai->TellMasterNoFacing("I don't want to do anything", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::relax()
+{
+    ai->TellMasterNoFacing("It is so boring... We could relax a bit", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::achievement()
+{
+    if (bot->getLevel() > 15)
+        spam("I would like to get some achievement. Would you like to join me?");
+}
+
+class FindTradeItemsVisitor : public IterateItemsVisitor
+{
+public:
+    FindTradeItemsVisitor(uint32 quality) : quality(quality), IterateItemsVisitor() {}
+
+    virtual bool Visit(Item* item)
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (proto->Quality != quality)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS && proto->Bonding == NO_BIND)
+        {
+            if(proto->Quality == ITEM_QUALITY_NORMAL && item->GetCount() > 1 && item->GetCount() == item->GetMaxStackCount())
+                stacks.push_back(proto->ItemId);
+
+            items.push_back(proto->ItemId);
+            count[proto->ItemId] += item->GetCount();
+        }
+
+        return true;
+    }
+
+    map<uint32, int > count;
+    vector<uint32> stacks;
+    vector<uint32> items;
+
+private:
+    uint32 quality;
+};
+
+
+void SuggestWhatToDoAction::trade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    uint32 quality = urand(0, 100);
+    if (quality > 90)
+        quality = ITEM_QUALITY_EPIC;
+    else if (quality >75)
+        quality = ITEM_QUALITY_RARE;
+    else if (quality > 50)
+        quality = ITEM_QUALITY_UNCOMMON;
+    else
+        quality = ITEM_QUALITY_NORMAL;
+
+    uint32 item = 0, count = 0;
+    while (quality-- > ITEM_QUALITY_POOR)
+    {
+        FindTradeItemsVisitor visitor(quality);
+        IterateItems(&visitor);
+        if (!visitor.stacks.empty())
+        {
+            int index = urand(0, visitor.stacks.size() - 1);
+            item = visitor.stacks[index];
+        }
+
+        if (!item)
+        {
+            if (!visitor.items.empty())
+            {
+                int index = urand(0, visitor.items.size() - 1);
+                item = visitor.items[index];
+            }
+        }
+
+        if (item)
+        {
+            count = visitor.count[item];
+            break;
+        }
+    }
+
+    if (!item || !count)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item);
+    if (!proto)
+        return;
+
+    uint32 price = auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * count;
+    if (!price)
+        return;
+
+    ostringstream out; out << "Selling " << chat->formatItem(proto, count) << " for " << chat->formatMoney(price);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::spam(string msg)
+{
+    Player* player = sRandomPlayerbotMgr.GetRandomPlayer();
+    if (!player || !player->IsInWorld())
+        return;
+
+    if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_TALK, true, player))
+        return;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            player->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != player->GetMapId() || bot->GetDistance(player) > sPlayerbotAIConfig.whisperDistance))
+        return;
+
+    bot->Whisper(msg, LANG_UNIVERSAL, player);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
new file mode 100644
index 0000000..750bb08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SuggestWhatToDoAction : public InventoryAction
+    {
+    public:
+        SuggestWhatToDoAction(PlayerbotAI* ai);
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (SuggestWhatToDoAction::*Suggestion) ();
+        vector<Suggestion> suggestions;
+
+    private:
+        void instance();
+        void specificQuest();
+        void newQuest();
+        void grindMaterials();
+        void grindReputation();
+        void nothing();
+        void relax();
+        void achievement();
+        void trade();
+        void spam(string msg);
+
+        vector<uint32> GetIncompletedQuests();
+
+    private:
+        bool suggested;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
new file mode 100644
index 0000000..747abb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TalkToQuestGiverAction.h"
+
+
+using namespace ai;
+
+void TalkToQuestGiverAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    std::ostringstream out; out << "Quest ";
+
+    QuestStatus status = bot->GetQuestStatus(quest->GetQuestId());
+    switch (status)
+    {
+    case QUEST_STATUS_COMPLETE:
+        TurnInQuest(quest, questGiver, out);
+        break;
+    case QUEST_STATUS_INCOMPLETE:
+        out << "|cffff0000Incompleted|r";
+        break;
+    case QUEST_STATUS_NONE:
+        out << "|cff00ff00Available|r";
+        break;
+    case QUEST_STATUS_FAILED:
+        out << "|cffff0000Failed|r";
+        break;
+    }
+
+    out << ": " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+}
+
+void TalkToQuestGiverAction::TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    uint32 questID = quest->GetQuestId();
+
+    if (bot->GetQuestRewardStatus(questID))
+        return;
+
+    if (quest->GetRewChoiceItemsCount() == 0)
+        RewardNoItem(quest, questGiver, out);
+    else if (quest->GetRewChoiceItemsCount() == 1)
+        RewardSingleItem(quest, questGiver, out);
+    else {
+        AskToSelectReward(quest, out);
+    }
+}
+
+void TalkToQuestGiverAction::RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    if (bot->CanRewardQuest(quest, false))
+    {
+        bot->RewardQuest(quest, 0, questGiver, false);
+        out << "Completed";
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in|r";
+    }
+}
+
+void TalkToQuestGiverAction::RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    int index = 0;
+    ItemTemplate const *item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[index]);
+    if (bot->CanRewardQuest(quest, index, false))
+    {
+        bot->RewardQuest(quest, index, questGiver, true);
+
+        out << "Rewarded " << chat->formatItem(item);
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in:|r, reward: " << chat->formatItem(item);
+    }
+}
+
+void TalkToQuestGiverAction::AskToSelectReward(Quest const* quest, ostringstream& out)
+{
+    ostringstream msg;
+    msg << "Choose reward: ";
+    for (uint8 i=0; i < quest->GetRewChoiceItemsCount(); ++i)
+    {
+        ItemTemplate const* item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[i]);
+        msg << chat->formatItem(item);
+    }
+    ai->TellMaster(msg);
+
+    out << "Reward pending";
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
new file mode 100644
index 0000000..374dc69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class TalkToQuestGiverAction : public QuestAction {
+    public:
+        TalkToQuestGiverAction(PlayerbotAI* ai) : QuestAction(ai, "talk to quest giver") {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+
+    private:
+        void TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void AskToSelectReward(Quest const* quest, ostringstream& out);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.cpp b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
new file mode 100644
index 0000000..8037679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TaxiAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    WorldPacket& p = event.getPacket();
+	if (!p.empty() && p.GetOpcode() == CMSG_MOVE_SPLINE_DONE)
+    {
+        WorldPacket p1(p);
+        p1.rpos(0);
+        bot->GetSession()->HandleMoveSplineDoneOpcode(p1);
+        movement.taxiNodes.clear();
+        movement.Set(NULL);
+        return true;
+    }
+
+    list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Creature *npc = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_FLIGHTMASTER);
+        if (!npc)
+            continue;
+
+        if (movement.taxiNodes.empty())
+        {
+            ostringstream out;
+            out << "I will order the taxi from " << npc->GetName() << ". Please start flying, then instruct me again";
+            ai->TellMaster(out);
+            return true;
+        }
+
+        if (!bot->ActivateTaxiPathTo(movement.taxiNodes, npc))
+        {
+            ai->TellMaster("I can't fly with you");
+            return false;
+        }
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any flightmaster to talk");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.h b/src/plugins/playerbot/strategy/actions/TaxiAction.h
new file mode 100644
index 0000000..84bbe4d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class TaxiAction : public Action {
+	public:
+		TaxiAction(PlayerbotAI* ai) : Action(ai, "taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.cpp b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
new file mode 100644
index 0000000..68a0b9a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TeleportAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TeleportAction::Execute(Event event)
+{
+    list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go)
+            continue;
+
+        GameObjectTemplate const *goInfo = go->GetGOInfo();
+        if (goInfo->type != GAMEOBJECT_TYPE_SPELLCASTER)
+            continue;
+
+        uint32 spellId = goInfo->spellcaster.spellId;
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Effects[0].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[1].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[2].Effect != SPELL_EFFECT_TELEPORT_UNITS)
+            continue;
+
+        ostringstream out; out << "Teleporting using " << goInfo->name;
+        ai->TellMasterNoFacing(out.str());
+
+        ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        SpellCastTargets targets;
+        targets.SetUnitTarget(bot);
+        spell->prepare(&targets, false);
+        spell->cast(true);
+        return true;
+    }
+
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+    if (movement.lastAreaTrigger)
+    {
+        WorldPacket p(CMSG_AREATRIGGER);
+        p << movement.lastAreaTrigger;
+        p.rpos(0);
+
+        bot->GetSession()->HandleAreaTriggerOpcode(p);
+        movement.lastAreaTrigger = 0;
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any portal to teleport");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.h b/src/plugins/playerbot/strategy/actions/TeleportAction.h
new file mode 100644
index 0000000..96b5973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class TeleportAction : public Action {
+	public:
+		TeleportAction(PlayerbotAI* ai) : Action(ai, "teleport") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
new file mode 100644
index 0000000..1e841dc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellCastFailedAction.h"
+
+
+using namespace ai;
+
+bool TellCastFailedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 castCount, result;
+    uint32 spellId;
+    p >> castCount >> spellId >> result;
+    ai->SpellInterrupted(spellId);
+
+    if (result == SPELL_CAST_OK)
+        return false;
+
+    const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+    ostringstream out; out << chat->formatSpell(pSpellInfo) << ": ";
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_READY:
+        out << "not ready";
+        break;
+    case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
+        out << "requires spell focus";
+        break;
+    case SPELL_FAILED_REQUIRES_AREA:
+        out << "cannot cast here";
+        break;
+    case SPELL_FAILED_TOTEMS:
+    case SPELL_FAILED_TOTEM_CATEGORY:
+        out << "requires totem";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
+        out << "requires item";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND:
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND:
+        out << "requires weapon";
+        break;
+    case SPELL_FAILED_PREVENTED_BY_MECHANIC:
+        out << "interrupted";
+        break;
+    default:
+        out << "cannot cast";
+    }
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    int32 castTime = spell->GetCastTime();
+    delete spell;
+
+    if (castTime >= 2000)
+        ai->TellMasterNoFacing(out.str());
+
+    return true;
+}
+
+
+bool TellSpellAction::Execute(Event event)
+{
+    string spell = event.getParam();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    if (!spellId)
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId );
+    if (!spellInfo)
+        return false;
+
+    ostringstream out; out << chat->formatSpell(spellInfo);
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
new file mode 100644
index 0000000..e454596
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellSpellAction : public Action
+    {
+    public:
+        TellSpellAction(PlayerbotAI* ai) : Action(ai, "spell") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class TellCastFailedAction : public Action 
+    {
+    public:
+        TellCastFailedAction(PlayerbotAI* ai) : Action(ai, "tell cast failed") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
new file mode 100644
index 0000000..fdbe0d3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellItemCountAction.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TellItemCountAction::Execute(Event event)
+{
+    string text = event.getParam();
+    list<Item*> found = parseItems(text);
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TellItem((*i)->GetTemplate(), (*i)->GetCount());
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.h b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
new file mode 100644
index 0000000..093b0e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TellItemCountAction : public InventoryAction {
+    public:
+        TellItemCountAction(PlayerbotAI* ai) : InventoryAction(ai, "c") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.cpp b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
new file mode 100644
index 0000000..02227f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellLosAction.h"
+
+
+using namespace ai;
+
+bool TellLosAction::Execute(Event event)
+{
+    string param = event.getParam();
+
+    if (param.empty() || param == "targets")
+    {
+        list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+        ListUnits("--- Targets ---", targets);
+    }
+
+    if (param.empty() || param == "npcs")
+    {
+        list<ObjectGuid> npcs = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+        ListUnits("--- NPCs ---", npcs);
+    }
+
+    if (param.empty() || param == "corpses")
+    {
+        list<ObjectGuid> corpses = *context->GetValue<list<ObjectGuid> >("nearest corpses");
+        ListUnits("--- Corpses ---", corpses);
+    }
+
+    if (param.empty() || param == "gos" || param == "game objects")
+    {
+        list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+        ListGameObjects("--- Game objects ---", gos);
+    }
+
+    return true;
+}
+
+void TellLosAction::ListUnits(string title, list<ObjectGuid> units)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit)
+            ai->TellMaster(unit->GetName());
+    }
+
+}
+void TellLosAction::ListGameObjects(string title, list<ObjectGuid> gos)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go)
+            ai->TellMaster(chat->formatGameobject(go));
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.h b/src/plugins/playerbot/strategy/actions/TellLosAction.h
new file mode 100644
index 0000000..15d83fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellLosAction : public Action {
+    public:
+        TellLosAction(PlayerbotAI* ai) : Action(ai, "los") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListUnits(string title, list<ObjectGuid> units);
+        void ListGameObjects(string title, list<ObjectGuid> gos);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellMasterAction.h b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
new file mode 100644
index 0000000..4174708
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellMasterAction : public Action {
+    public:
+        TellMasterAction(PlayerbotAI* ai, string text) : Action(ai, "tell master"), text(text) {}
+
+        virtual bool Execute(Event event)
+        {
+            ai->TellMaster(text);
+            return true;
+        }
+
+    private:
+        string text;
+    };
+
+    class OutOfReactRangeAction : public MovementAction {
+    public:
+        OutOfReactRangeAction(PlayerbotAI* ai) : MovementAction(ai, "tell out of react range") {}
+
+        virtual bool Execute(Event event)
+        {
+            bool canFollow = Follow(AI_VALUE(Unit*, "master target"));
+            if (!canFollow)
+            {
+                ai->SetNextCheckDelay(5000);
+                return false;
+            }
+
+            ai->TellMaster("Wait for me!");
+            return true;
+        }
+   };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
new file mode 100644
index 0000000..f1bd104
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
@@ -0,0 +1,68 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellReputationAction.h"
+#include "../../../Reputation/ReputationMgr.h"
+
+
+using namespace ai;
+
+bool TellReputationAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (!unit)
+        return false;
+
+    const FactionTemplateEntry *factionTemplate = unit->GetFactionTemplateEntry();
+    uint32 faction = factionTemplate->faction;
+    const FactionEntry* entry = sFactionStore.LookupEntry(faction);
+    int32 reputation = bot->GetReputationMgr().GetReputation(faction);
+
+    ostringstream out;
+    out << entry->name[0] << ": ";
+    out << "|cff";
+    ReputationRank rank = bot->GetReputationMgr().GetRank(entry);
+    switch (rank) {
+        case REP_HATED:
+            out << "cc2222hated";
+            break;
+        case REP_HOSTILE:
+            out << "ff0000hostile";
+            break;
+        case REP_UNFRIENDLY:
+            out << "ee6622unfriendly";
+            break;
+        case REP_NEUTRAL:
+            out << "ffff00neutral";
+            break;
+        case REP_FRIENDLY:
+            out << "00ff00friendly";
+            break;
+        case REP_HONORED:
+            out << "00ff88honored";
+            break;
+        case REP_REVERED:
+            out << "00ffccrevered";
+            break;
+        case REP_EXALTED:
+            out << "00ffffexalted";
+            break;
+        default:
+            out << "808080unknown";
+            break;
+    }
+
+    out << "|cffffffff";
+
+    int32 base = ReputationMgr::Reputation_Cap + 1;
+    for (int i = MAX_REPUTATION_RANK - 1; i >= rank; --i)
+        base -= ReputationMgr::PointsInRank[i];
+
+    out << " (" << (reputation - base) << "/" << ReputationMgr::PointsInRank[rank] << ")";
+    ai->TellMaster(out);
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.h b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
new file mode 100644
index 0000000..449e67f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellReputationAction : public Action {
+    public:
+        TellReputationAction(PlayerbotAI* ai) : Action(ai, "reputation") {}
+        virtual bool Execute(Event event);
+
+    private:
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
new file mode 100644
index 0000000..a302772
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetAction.h"
+
+
+using namespace ai;
+
+bool TellTargetAction::Execute(Event event)
+{
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    if (target)
+    {
+        ostringstream out;
+		out << "Attacking " << target->GetName();
+        ai->TellMaster(out);
+
+        context->GetValue<Unit*>("old target")->Set(target);
+    }
+    return true;
+}
+
+bool TellAttackersAction::Execute(Event event)
+{
+    ai->TellMaster("--- Attackers ---");
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        ai->TellMaster(unit->GetName());
+    }
+
+    ai->TellMaster("--- Threat ---");
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        ostringstream out; out << unit->GetName() << " (" << threat << ")";
+        ai->TellMaster(out);
+
+        ref = ref->next();
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.h b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
new file mode 100644
index 0000000..7995100
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellTargetAction : public Action
+    {
+    public:
+        TellTargetAction(PlayerbotAI* ai) : Action(ai, "tell target") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TellAttackersAction : public Action
+    {
+    public:
+        TellAttackersAction(PlayerbotAI* ai) : Action(ai, "tell attackers") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.cpp b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
new file mode 100644
index 0000000..62f1c45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TradeAction::Execute(Event event)
+{
+    string text = event.getParam();
+    uint32 copper = chat->parseMoney(text);
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    int8 slot = -1;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TradeItem(**i, slot);
+
+    return true;
+}
+
+bool TradeAction::TradeItem(const Item& item, int8 slot)
+{
+    if (!bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    if (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED)
+        slot = TRADE_SLOT_NONTRADED;
+
+    int8 tradeSlot = -1;
+    Item* itemPtr = const_cast<Item*>(&item);
+
+    TradeData* pTrade = bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+
+    if (slot == TRADE_SLOT_NONTRADED)
+        pTrade->SetItem(TRADE_SLOT_NONTRADED, itemPtr);
+    else
+    {
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == itemPtr)
+            {
+                tradeSlot = i;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_CLEAR_TRADE_ITEM, 1);
+                *packet << (uint8) tradeSlot;
+                bot->GetSession()->QueuePacket(packet);
+                pTrade->SetItem(TradeSlots(i), NULL);
+                return true;
+            }
+        }
+
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                pTrade->SetItem(TradeSlots(i), itemPtr);
+                tradeSlot = i;
+            }
+        }
+    }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+        << (uint8) item.GetSlot();
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.h b/src/plugins/playerbot/strategy/actions/TradeAction.h
new file mode 100644
index 0000000..050a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TradeAction : public InventoryAction {
+    public:
+        TradeAction(PlayerbotAI* ai) : InventoryAction(ai, "trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(const Item& item, int8 slot);
+
+        static map<string, uint32> slots;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
new file mode 100644
index 0000000..05516a3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
@@ -0,0 +1,171 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeStatusAction.h"
+
+#include "../ItemVisitors.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+
+
+bool TradeStatusAction::Execute(Event event)
+{
+    Player* trader = bot->GetTrader();
+    Player* master = GetMaster();
+    if (!trader)
+        return false;
+
+    if (trader != master)
+    {
+		bot->Whisper("I'm kind of busy now", LANG_UNIVERSAL, trader);
+    }
+
+    if (trader != master || !ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, true, master))
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+        bot->GetSession()->HandleCancelTradeOpcode(p);
+        return false;
+    }
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint32 status;
+    p >> status;
+
+    if (status == TRADE_STATUS_TRADE_ACCEPT)
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+
+        if (CheckTrade())
+        {
+            int32 botMoney = CalculateCost(bot->GetTradeData(), true);
+
+            bot->GetSession()->HandleAcceptTradeOpcode(p);
+            if (bot->GetTradeData())
+                return false;
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                int32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                sRandomPlayerbotMgr.SetLootAmount(bot, max(0, lootAmount - botMoney * 10));
+            }
+            return true;
+        }
+    }
+    else if (status == TRADE_STATUS_BEGIN_TRADE)
+    {
+        if (!bot->isInFront(trader, M_PI / 2))
+            bot->SetFacingToObject(trader);
+        BeginTrade();
+        return true;
+    }
+
+    return false;
+}
+
+
+void TradeStatusAction::BeginTrade()
+{
+    WorldPacket p;
+    bot->GetSession()->HandleBeginTradeOpcode(p);
+
+    ListItemsVisitor visitor;
+    IterateItems(&visitor);
+
+    ai->TellMaster("=== Trade ===");
+    TellItems(visitor.items);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(bot))
+    {
+        uint32 discount = sRandomPlayerbotMgr.GetTradeDiscount(bot);
+        if (discount)
+        {
+            ostringstream out; out << "Free trade: " << chat->formatMoney(discount);
+            ai->TellMaster(out);
+        }
+    }
+}
+
+bool TradeStatusAction::CheckTrade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return true;
+
+    Player* master = GetMaster();
+    if (!bot->GetTradeData() || !master->GetTradeData())
+        return false;
+
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = bot->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item && !auctionbot.GetSellPrice(item->GetTemplate()))
+        {
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate()) << " - This is not for sale";
+            ai->TellMaster(out);
+            return false;
+        }
+
+        item = master->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item && !auctionbot.GetBuyPrice(item->GetTemplate()))
+        {
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate()) << " - I don't need this";
+            ai->TellMaster(out);
+            return false;
+        }
+    }
+
+    int32 botMoney = CalculateCost(bot->GetTradeData(), true);
+    int32 playerMoney = CalculateCost(master->GetTradeData(), false);
+
+    int32 discount = sRandomPlayerbotMgr.GetTradeDiscount(bot);
+    botMoney = max(0, botMoney - discount);
+
+    if (playerMoney >= botMoney)
+        return true;
+
+    ostringstream out;
+    out << "I want " << chat->formatMoney(botMoney - playerMoney) << " for this";
+    ai->TellMaster(out);
+    return false;
+}
+
+int32 TradeStatusAction::CalculateCost(TradeData* data, bool sell)
+{
+    if (!data)
+        return 0;
+
+    uint32 sum = data->GetMoney();
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = data->GetItem((TradeSlots)slot);
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        if (proto->Quality < ITEM_QUALITY_NORMAL)
+            return 0;
+
+        if (sell)
+        {
+            sum += item->GetCount() * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+        }
+        else
+        {
+            sum += item->GetCount() * auctionbot.GetBuyPrice(proto) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+        }
+    }
+
+    return sum;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.h b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
new file mode 100644
index 0000000..8298ca2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TradeStatusAction : public InventoryAction
+    {
+    public:
+        TradeStatusAction(PlayerbotAI* ai) : InventoryAction(ai, "accept trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void BeginTrade();
+        bool CheckTrade();
+        int32 CalculateCost(TradeData* data, bool sell);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.cpp b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
new file mode 100644
index 0000000..dd32207
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
@@ -0,0 +1,114 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TrainerAction.h"
+
+using namespace ai;
+
+void TrainerAction::Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg)
+{
+    if (bot->GetMoney() < cost)
+        return;
+
+    bot->ModifyMoney(-int32(cost));
+    if (tSpell->IsCastable())
+        bot->CastSpell(bot, tSpell->spell, true);
+    else
+        bot->LearnSpell(tSpell->learnedSpell[0], false, false);
+
+    msg << " - learned";
+}
+
+void TrainerAction::List(Creature* creature, TrainerSpellAction action, SpellIds& spells)
+{
+    TellHeader(creature);
+
+    TrainerSpellData const* trainer_spells = creature->GetTrainerSpells();
+    float fDiscountMod =  bot->GetReputationPriceDiscount(creature);
+    uint32 totalCost = 0;
+
+    for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        if (!tSpell)
+            continue;
+
+        if (!tSpell->learnedSpell && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+            continue;
+
+        TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+        if (state != TRAINER_SPELL_GREEN)
+            continue;
+
+        uint32 spellId = tSpell->spell;
+        const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+        totalCost += cost;
+
+        ostringstream out;
+        out << chat->formatSpell(pSpellInfo) << chat->formatMoney(cost);
+
+        if (action && (spells.empty() || spells.find(tSpell->spell) != spells.end() || spells.find(tSpell->learnedSpell[0]) != spells.end()))
+            (this->*action)(cost, tSpell, out);
+
+        ai->TellMaster(out);
+    }
+
+    TellFooter(totalCost);
+}
+
+
+bool TrainerAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+        return false;
+
+    Creature *creature = ai->GetCreature(target->GetGUID());
+    if (!creature)
+        return false;
+
+    // check present spell in trainer spell list
+    TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+    if (!cSpells)
+    {
+        ai->TellMaster("No spells can be learned from this trainer");
+        return false;
+    }
+
+    uint32 spell = chat->parseSpell(text);
+    SpellIds spells;
+    if (spell)
+        spells.insert(spell);
+
+    if (text == "learn")
+        List(creature, &TrainerAction::Learn, spells);
+    else
+        List(creature, NULL, spells);
+
+    return true;
+}
+
+void TrainerAction::TellHeader(Creature* creature)
+{
+    ostringstream out; out << "--- can learn from " << creature->GetName() << " ---";
+    ai->TellMaster(out);
+}
+
+void TrainerAction::TellFooter(uint32 totalCost)
+{
+    if (totalCost)
+    {
+        ostringstream out; out << "Total cost: " << chat->formatMoney(totalCost);
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.h b/src/plugins/playerbot/strategy/actions/TrainerAction.h
new file mode 100644
index 0000000..3dbe18f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class TrainerAction : public Action {
+	public:
+		TrainerAction(PlayerbotAI* ai) : Action(ai, "trainer") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (TrainerAction::*TrainerSpellAction)(uint32, TrainerSpell const*, ostringstream& msg);
+        void List(Creature* creature, TrainerSpellAction action, SpellIds& spells);
+        void Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg);
+        void TellHeader(Creature* creature);
+        void TellFooter(uint32 totalCost);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.cpp b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
new file mode 100644
index 0000000..cf70f80
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UnequipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool UnequipAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        UnequipItem(&visitor);
+    }
+
+    return true;
+}
+
+
+void UnequipAction::UnequipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor, ITERATE_ALL_ITEMS);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) UnequipItem(**items.begin());
+}
+
+void UnequipAction::UnequipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 dstBag = NULL_BAG;
+
+
+    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_BAG_ITEM, 3);
+    *packet << bagIndex << slot << dstBag;
+    bot->GetSession()->QueuePacket(packet);
+
+    ostringstream out; out << chat->formatItem(item.GetTemplate()) << " unequipped";
+    ai->TellMaster(out);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.h b/src/plugins/playerbot/strategy/actions/UnequipAction.h
new file mode 100644
index 0000000..fdf7ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class UnequipAction : public InventoryAction {
+    public:
+        UnequipAction(PlayerbotAI* ai) : InventoryAction(ai, "unequip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void UnequipItem(Item& item);
+        void UnequipItem(FindItemVisitor* visitor);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.cpp b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
new file mode 100644
index 0000000..fcbdacc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
@@ -0,0 +1,302 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseItemAction.h"
+
+using namespace ai;
+
+bool UseItemAction::Execute(Event event)
+{
+    string name = event.getParam();
+    if (name.empty())
+        name = getName();
+
+    list<Item*> items = AI_VALUE2(list<Item*>, "inventory items", name);
+    list<ObjectGuid> gos = chat->parseGameobjects(name);
+
+    if (gos.empty())
+    {
+        if (items.size() > 1)
+        {
+            list<Item*>::iterator i = items.begin();
+            Item* itemTarget = *i++;
+            Item* item = *i;
+            return UseItemOnItem(item, itemTarget);
+        }
+        else if (!items.empty())
+            return UseItemAuto(*items.begin());
+    }
+    else
+    {
+        if (items.empty())
+            return UseGameObject(*gos.begin());
+        else
+            return UseItemOnGameObject(*items.begin(), *gos.begin());
+    }
+
+    ai->TellMaster("No items (or game objects) available");
+    return false;
+}
+
+bool UseItemAction::UseGameObject(ObjectGuid guid)
+{
+    GameObject* go = ai->GetGameObject(guid);
+    if (!go || !go->isSpawned())
+        return false;
+
+    go->Use(bot);
+    ostringstream out; out << "Using " << chat->formatGameobject(go);
+    ai->TellMasterNoFacing(out.str());
+    return true;
+}
+
+bool UseItemAction::UseItemAuto(Item* item)
+{
+    return UseItem(item, ObjectGuid(), NULL);
+}
+
+bool UseItemAction::UseItemOnGameObject(Item* item, ObjectGuid go)
+{
+    return UseItem(item, go, NULL);
+}
+
+bool UseItemAction::UseItemOnItem(Item* item, Item* itemTarget)
+{
+    return UseItem(item, ObjectGuid(), itemTarget);
+}
+
+bool UseItemAction::UseItem(Item* item, ObjectGuid goGuid, Item* itemTarget)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return false;
+
+    if (bot->IsNonMeleeSpellCast(true))
+        return false;
+
+    if (bot->IsInCombat() && item->IsPotion() && bot->GetLastPotionId())
+        return false;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 8 + 1);
+    *packet << bagIndex << slot << cast_count << uint32(0) << item_guid
+        << glyphIndex << unk_flags;
+
+    bool targetSelected = false;
+    ostringstream out; out << "Using " << chat->formatItem(item->GetTemplate());
+    if (item->GetTemplate()->Stackable)
+    {
+        uint32 count = item->GetCount();
+        if (count > 1)
+            out << " (" << count << " available) ";
+        else
+            out << " (the last one!)";
+    }
+
+    if (goGuid)
+    {
+        GameObject* go = ai->GetGameObject(goGuid);
+        if (go && go->isSpawned())
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT_ENEMY;
+            *packet << targetFlag;
+            packet->appendPackGUID(goGuid.GetRawValue());
+            out << " on " << chat->formatGameobject(go);
+            targetSelected = true;
+        }
+    }
+
+    if (itemTarget)
+    {
+        if (item->GetTemplate()->Class == ITEM_CLASS_GEM)
+        {
+            bool fit = SocketItem(itemTarget, item) || SocketItem(itemTarget, item, true);
+            if (!fit)
+                ai->TellMaster("Socket does not fit");
+            return fit;
+        }
+        else
+        {
+            uint32 targetFlag = TARGET_FLAG_ITEM;
+            *packet << targetFlag;
+            packet->appendPackGUID(itemTarget->GetGUID());
+            out << " on " << chat->formatItem(itemTarget->GetTemplate());
+            targetSelected = true;
+        }
+    }
+
+    Player* master = GetMaster();
+    if (!targetSelected && item->GetTemplate()->Class != ITEM_CLASS_CONSUMABLE && master)
+    {
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT;
+            *packet << targetFlag;
+            packet->appendPackGUID(masterSelection->GetGUID());
+            out << " on " << masterSelection->GetName();
+            targetSelected = true;
+        }
+    }
+
+    if(uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8+4+4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            ostringstream out; out << "Got quest " << chat->formatQuest(qInfo);
+            ai->TellMasterNoFacing(out.str());
+            return true;
+        }
+    }
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+    bot->ClearUnitState( UNIT_STATE_CHASE );
+    bot->ClearUnitState( UNIT_STATE_FOLLOW );
+
+    if (bot->isMoving())
+        return false;
+
+    for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+    {
+        uint32 spellId = item->GetTemplate()->Spells[i].SpellId;
+        if (!spellId)
+            continue;
+
+        if (!ai->CanCastSpell(spellId, bot, false))
+            continue;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+        {
+            Item* itemForSpell = AI_VALUE2(Item*, "item for spell", spellId);
+            if (!itemForSpell)
+                continue;
+
+            if (itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                continue;
+
+            if (bot->GetTrader())
+            {
+                if (selfOnly)
+                    return false;
+
+                *packet << TARGET_FLAG_TRADE_ITEM << (uint8)1 << (uint64)TRADE_SLOT_NONTRADED;
+                targetSelected = true;
+                out << " on traded item";
+            }
+            else
+            {
+                *packet << TARGET_FLAG_ITEM;
+                packet->appendPackGUID(itemForSpell->GetGUID());
+                targetSelected = true;
+                out << " on "<< chat->formatItem(itemForSpell->GetTemplate());
+            }
+
+            Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE, ObjectGuid::Empty, true);
+            ai->WaitForSpellCast(spell);
+            delete spell;
+        }
+        else
+        {
+            *packet << TARGET_FLAG_NONE;
+            targetSelected = true;
+            out << " on self";
+        }
+        break;
+    }
+
+    if (!targetSelected)
+        return false;
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        if (bot->IsInCombat())
+            return false;
+
+        ai->InterruptSpell();
+        ai->SetNextCheckDelay(30000);
+    }
+
+    ai->TellMasterNoFacing(out.str());
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool UseItemAction::SocketItem(Item* item, Item* gem, bool replace)
+{
+    WorldPacket* const packet = new WorldPacket(CMSG_SOCKET_GEMS);
+    *packet << item->GetGUID();
+
+    bool fits = false;
+    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
+    {
+        uint8 SocketColor = item->GetTemplate()->Socket[enchant_slot-SOCK_ENCHANTMENT_SLOT].Color;
+        GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gem->GetTemplate()->GemProperties);
+        if (gemProperty && (gemProperty->color & SocketColor))
+        {
+            if (fits)
+            {
+                *packet << ObjectGuid();
+                continue;
+            }
+
+            uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry || !enchantEntry->GemID)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+			if (replace && enchantEntry->GemID != gem->GetTemplate()->ItemId)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+        }
+
+        *packet << ObjectGuid();
+    }
+
+    if (fits)
+    {
+        ostringstream out; out << "Socketing " << chat->formatItem(item->GetTemplate());
+        out << " with "<< chat->formatItem(gem->GetTemplate());
+        ai->TellMasterNoFacing(out.str());
+
+        bot->GetSession()->QueuePacket(packet);
+    }
+    return fits;
+}
+
+
+bool UseItemAction::isPossible()
+{
+    return getName() == "use" || AI_VALUE2(uint8, "item count", getName()) > 0;
+}
+
+bool UseSpellItemAction::isUseful()
+{
+    return AI_VALUE2(bool, "spell cast useful", getName());
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.h b/src/plugins/playerbot/strategy/actions/UseItemAction.h
new file mode 100644
index 0000000..ef65561
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class UseItemAction : public Action {
+	public:
+		UseItemAction(PlayerbotAI* ai, string name = "use", bool selfOnly = false) : Action(ai, name), selfOnly(selfOnly) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+
+    private:
+        bool UseItemAuto(Item* item);
+        bool UseItemOnGameObject(Item* item, ObjectGuid go);
+        bool UseItemOnItem(Item* item, Item* itemTarget);
+        bool UseItem(Item* item, ObjectGuid go, Item* itemTarget);
+        bool UseGameObject(ObjectGuid guid);
+        bool SocketItem(Item* item, Item* gem, bool replace = false);
+
+    private:
+        bool selfOnly;
+    };
+
+    class UseSpellItemAction : public UseItemAction {
+    public:
+        UseSpellItemAction(PlayerbotAI* ai, string name, bool selfOnly = false) : UseItemAction(ai, name, selfOnly) {}
+
+    public:
+        virtual bool isUseful();
+    };
+
+    class UseHealingPotion : public UseItemAction {
+    public:
+        UseHealingPotion(PlayerbotAI* ai) : UseItemAction(ai, "healing potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+
+    class UseManaPotion : public UseItemAction
+    {
+    public:
+        UseManaPotion(PlayerbotAI* ai) : UseItemAction(ai, "mana potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
new file mode 100644
index 0000000..fd42c37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
@@ -0,0 +1,81 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseMeetingStoneAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+bool UseMeetingStoneAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    ObjectGuid guid;
+    p >> guid;
+
+    if (master->GetSelectedPlayer() && master->GetSelectedPlayer() != bot)
+        return false;
+
+    if (!master->GetSelectedPlayer() && master->GetGroup() != bot->GetGroup())
+        return false;
+
+    if (master->IsBeingTeleported())
+        return false;
+
+    if (bot->IsInCombat())
+    {
+        ai->TellMasterNoFacing("I am in combat");
+        return false;
+    }
+
+    GameObject *gameObject = ai->GetGameObject(guid);
+    if (!gameObject)
+        return false;
+
+    const GameObjectTemplate* goInfo = gameObject->GetGOInfo();
+    if (!goInfo || goInfo->type != GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+        return false;
+
+    return Teleport();
+}
+
+
+bool SummonAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        ai->TellMasterNoFacing("You cannot summon me");
+        return false;
+    }
+
+    return Teleport();
+}
+
+bool SummonAction::Teleport()
+{
+    Player* master = GetMaster();
+    if (!master->IsBeingTeleported())
+    {
+        float followAngle = GetFollowAngle();
+        for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+        {
+            uint32 mapId = master->GetMapId();
+            float x = master->GetPositionX() + cos(angle) * sPlayerbotAIConfig.followDistance;
+            float y = master->GetPositionY()+ sin(angle) * sPlayerbotAIConfig.followDistance;
+            float z = master->GetPositionZ();
+            if (master->IsWithinLOS(x, y, z))
+            {
+                bot->GetMotionMaster()->Clear();
+                bot->TeleportTo(mapId, x, y, z, 0);
+                return true;
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
new file mode 100644
index 0000000..e787d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SummonAction : public MovementAction
+    {
+    public:
+        SummonAction(PlayerbotAI* ai, string name = "summon") : MovementAction(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Teleport();
+    };
+
+    class UseMeetingStoneAction : public SummonAction
+    {
+    public:
+        UseMeetingStoneAction(PlayerbotAI* ai) : SummonAction(ai, "use meeting stone") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.cpp b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
new file mode 100644
index 0000000..9dd7f95
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
@@ -0,0 +1,160 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WhoAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+map<uint32, string> WhoAction::skills;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool WhoAction::Execute(Event event)
+{
+    Player* owner = event.getOwner();
+    if (!owner)
+        return false;
+
+    string tell = "";
+    string text = event.getParam();
+    if (!text.empty())
+    {
+        if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+            return false;
+
+        tell = QuerySkill(text);
+        if (tell.empty())
+        {
+            tell = QueryTrade(text);
+        }
+    }
+    else
+    {
+        tell = QuerySpec(text);
+    }
+
+    if (tell.empty())
+        return false;
+
+    // ignore random bot chat filter
+	bot->Whisper(tell, LANG_UNIVERSAL, owner);
+    return true;
+}
+
+
+string WhoAction::QueryTrade(string text)
+{
+    ostringstream out;
+
+    list<Item*> items = InventoryAction::parseItems(text);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* sell = *i;
+        int32 sellPrice = auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * sell->GetCount();
+        if (!sellPrice)
+            continue;
+
+        out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+        return out.str();
+    }
+
+    return "";
+}
+
+string WhoAction::QuerySkill(string text)
+{
+    ostringstream out;
+    InitSkills();
+
+    for (map<uint32, string>::iterator i = skills.begin(); i != skills.end(); ++i)
+    {
+        string name = i->second;
+        uint16 skill = i->first;
+        if (!strcmpi(text.c_str(), name.c_str()) && bot->HasSkill(skill))
+        {
+            string skillName = i->second;
+            uint32 spellId = AI_VALUE2(uint32, "spell id", skillName);
+            uint16 value = bot->GetSkillValue(skill);
+            uint16 maxSkill = bot->GetMaxSkillValue(skill);
+            ObjectGuid guid = bot->GetGUID();
+            string data = "0";
+            out << "|cFFFFFF00|Htrade:" << spellId << ":" << value << ":" << maxSkill << ":"
+                    << std::hex << std::uppercase << guid.GetRawValue()
+                    << std::nouppercase << std::dec << ":" << data
+                    << "|h[" << skills[skill] << "]|h|r"
+                    << " |h|cff00ff00" << value << "|h|cffffffff/"
+                    << "|h|cff00ff00" << maxSkill << "|h|cffffffff ";
+        }
+    }
+
+    return out.str();
+}
+
+string WhoAction::QuerySpec(string text)
+{
+    ostringstream out;
+
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    out << "|h|cffffffff" << chat->formatClass(bot, spec);
+    out << " (|h|cff00ff00" << (uint32)bot->getLevel() << "|h|cffffffff lvl), ";
+    out << "|h|cff00ff00" << ai->GetEquipGearScore(bot, false, false) << "|h|cffffffff GS (";
+
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+
+    bool needSlash = false;
+    if (visitor.count[ITEM_QUALITY_EPIC])
+    {
+        out << "|h|cffff00ff" << visitor.count[ITEM_QUALITY_EPIC] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_RARE])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff8080ff" << visitor.count[ITEM_QUALITY_RARE] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_UNCOMMON])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff00ff00" << visitor.count[ITEM_QUALITY_UNCOMMON] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    out << ")";
+
+    return out.str();
+}
+
+
+void WhoAction::InitSkills()
+{
+    if (!skills.empty())
+        return;
+
+    skills[SKILL_ALCHEMY] = "Alchemy";
+    skills[SKILL_ENCHANTING] = "Enchanting";
+    skills[SKILL_SKINNING] = "Skinning";
+    skills[SKILL_JEWELCRAFTING] = "Jewelcrafting";
+    skills[SKILL_INSCRIPTION] = "Inscription";
+    skills[SKILL_TAILORING] = "Tailoring";
+    skills[SKILL_LEATHERWORKING] = "Leatherworking";
+    skills[SKILL_ENGINEERING] = "Engineering";
+    skills[SKILL_HERBALISM] = "Herbalism";
+    skills[SKILL_MINING] = "Mining";
+    skills[SKILL_BLACKSMITHING] = "Blacksmithing";
+    skills[SKILL_COOKING] = "Cooking";
+    skills[SKILL_FIRST_AID] = "First Aid";
+    skills[SKILL_FISHING] = "Fishing";
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.h b/src/plugins/playerbot/strategy/actions/WhoAction.h
new file mode 100644
index 0000000..92ed834
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class WhoAction : public InventoryAction {
+    public:
+        WhoAction(PlayerbotAI* ai) : InventoryAction(ai, "who") {}
+
+    public:
+        virtual bool Execute(Event event);
+        static map<uint32, string> skills;
+
+    private:
+        void InitSkills();
+        string QueryTrade(string text);
+        string QuerySkill(string text);
+        string QuerySpec(string text);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
new file mode 100644
index 0000000..7ae25e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
@@ -0,0 +1,106 @@
+#pragma once
+
+#include "AcceptInvitationAction.h"
+#include "PassLeadershipToMasterAction.h"
+#include "TellMasterAction.h"
+#include "TalkToQuestGiverAction.h"
+#include "AcceptQuestAction.h"
+#include "LootRollAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "AcceptResurrectAction.h"
+#include "UseMeetingStoneAction.h"
+#include "AreaTriggerAction.h"
+#include "CheckMountStateAction.h"
+#include "RememberTaxiAction.h"
+#include "TradeStatusAction.h"
+#include "InventoryChangeFailureAction.h"
+#include "LootAction.h"
+#include "QuestAction.h"
+#include "LeaveGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "AcceptDuelAction.h"
+#include "ReadyCheckAction.h"
+#include "LfgActions.h"
+#include "SecurityCheckAction.h"
+#include "GuildAcceptAction.h"
+
+namespace ai
+{
+    class WorldPacketActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        WorldPacketActionContext()
+        {
+            creators["accept invitation"] = &WorldPacketActionContext::accept_invitation;
+            creators["leader"] = &WorldPacketActionContext::pass_leadership_to_master;
+            creators["tell not enough money"] = &WorldPacketActionContext::tell_not_enough_money;
+            creators["tell not enough reputation"] = &WorldPacketActionContext::tell_not_enough_reputation;
+            creators["tell cannot equip"] = &WorldPacketActionContext::tell_cannot_equip;
+            creators["talk to quest giver"] = &WorldPacketActionContext::turn_in_quest;
+            creators["accept quest"] = &WorldPacketActionContext::accept_quest;
+            creators["accept all quests"] = &WorldPacketActionContext::accept_all_quests;
+            creators["accept quest share"] = &WorldPacketActionContext::accept_quest_share;
+            creators["loot roll"] = &WorldPacketActionContext::loot_roll;
+            creators["revive from corpse"] = &WorldPacketActionContext::revive_from_corpse;
+            creators["accept resurrect"] = &WorldPacketActionContext::accept_resurrect;
+            creators["use meeting stone"] = &WorldPacketActionContext::use_meeting_stone;
+            creators["area trigger"] = &WorldPacketActionContext::area_trigger;
+            creators["reach area trigger"] = &WorldPacketActionContext::reach_area_trigger;
+            creators["check mount state"] = &WorldPacketActionContext::check_mount_state;
+            creators["remember taxi"] = &WorldPacketActionContext::remember_taxi;
+            creators["accept trade"] = &WorldPacketActionContext::accept_trade;
+            creators["store loot"] = &WorldPacketActionContext::store_loot;
+            creators["tell out of react range"] = &WorldPacketActionContext::tell_out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketActionContext::quest_objective_completed;
+            creators["party command"] = &WorldPacketActionContext::party_command;
+            creators["tell cast failed"] = &WorldPacketActionContext::tell_cast_failed;
+            creators["accept duel"] = &WorldPacketActionContext::accept_duel;
+            creators["ready check"] = &WorldPacketActionContext::ready_check;
+            creators["ready check finished"] = &WorldPacketActionContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketActionContext::uninvite;
+            creators["lfg join"] = &WorldPacketActionContext::lfg_join;
+            creators["lfg accept"] = &WorldPacketActionContext::lfg_accept;
+            creators["lfg role check"] = &WorldPacketActionContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketActionContext::lfg_leave;
+            creators["security check"] = &WorldPacketActionContext::security_check;
+            creators["guild accept"] = &WorldPacketActionContext::guild_accept;
+        }
+
+    private:
+        static Action* guild_accept(PlayerbotAI* ai) { return new GuildAcceptAction(ai); }
+        static Action* security_check(PlayerbotAI* ai) { return new SecurityCheckAction(ai); }
+        static Action* lfg_leave(PlayerbotAI* ai) { return new LfgLeaveAction(ai); }
+        static Action* lfg_accept(PlayerbotAI* ai) { return new LfgAcceptAction(ai); }
+        static Action* lfg_role_check(PlayerbotAI* ai) { return new LfgRoleCheckAction(ai); }
+        static Action* lfg_join(PlayerbotAI* ai) { return new LfgJoinAction(ai); }
+        static Action* uninvite(PlayerbotAI* ai) { return new UninviteAction(ai); }
+        static Action* ready_check_finished(PlayerbotAI* ai) { return new FinishReadyCheckAction(ai); }
+        static Action* ready_check(PlayerbotAI* ai) { return new ReadyCheckAction(ai); }
+        static Action* accept_duel(PlayerbotAI* ai) { return new AcceptDuelAction(ai); }
+        static Action* tell_cast_failed(PlayerbotAI* ai) { return new TellCastFailedAction(ai); }
+        static Action* party_command(PlayerbotAI* ai) { return new PartyCommandAction(ai); }
+        static Action* quest_objective_completed(PlayerbotAI* ai) { return new QuestObjectiveCompletedAction(ai); }
+        static Action* store_loot(PlayerbotAI* ai) { return new StoreLootAction(ai); }
+        static Action* tell_out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeAction(ai); }
+        static Action* accept_trade(PlayerbotAI* ai) { return new TradeStatusAction(ai); }
+        static Action* remember_taxi(PlayerbotAI* ai) { return new RememberTaxiAction(ai); }
+        static Action* check_mount_state(PlayerbotAI* ai) { return new CheckMountStateAction(ai); }
+        static Action* area_trigger(PlayerbotAI* ai) { return new AreaTriggerAction(ai); }
+        static Action* reach_area_trigger(PlayerbotAI* ai) { return new ReachAreaTriggerAction(ai); }
+        static Action* use_meeting_stone(PlayerbotAI* ai) { return new UseMeetingStoneAction(ai); }
+        static Action* accept_resurrect(PlayerbotAI* ai) { return new AcceptResurrectAction(ai); }
+        static Action* revive_from_corpse(PlayerbotAI* ai) { return new ReviveFromCorpseAction(ai); }
+        static Action* accept_invitation(PlayerbotAI* ai) { return new AcceptInvitationAction(ai); }
+        static Action* pass_leadership_to_master(PlayerbotAI* ai) { return new PassLeadershipToMasterAction(ai); }
+        static Action* tell_not_enough_money(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough money"); }
+        static Action* tell_not_enough_reputation(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough reputation"); }
+        static Action* tell_cannot_equip(PlayerbotAI* ai) { return new InventoryChangeFailureAction(ai); }
+        static Action* turn_in_quest(PlayerbotAI* ai) { return new TalkToQuestGiverAction(ai); }
+        static Action* accept_quest(PlayerbotAI* ai) { return new AcceptQuestAction(ai); }
+        static Action* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsAction(ai); }
+        static Action* accept_quest_share(PlayerbotAI* ai) { return new AcceptQuestShareAction(ai); }
+        static Action* loot_roll(PlayerbotAI* ai) { return (QueryItemUsageAction*)new LootRollAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
new file mode 100644
index 0000000..fa86bb1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
@@ -0,0 +1,171 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "BearTankDruidStrategy.h"
+
+using namespace ai;
+
+class BearTankDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    BearTankDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["feral charge - bear"] = &feral_charge_bear;
+        creators["swipe (bear)"] = &swipe_bear;
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["bear form"] = &bear_form;
+        creators["dire bear form"] = &dire_bear_form;
+        creators["mangle (bear)"] = &mangle_bear;
+        creators["maul"] = &maul;
+        creators["bash"] = &bash;
+        creators["swipe"] = &swipe;
+        creators["lacerate"] = &lacerate;
+        creators["demoralizing roar"] = &demoralizing_roar;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - bear",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe (bear)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bear form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* dire_bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dire bear form",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("bear form"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (bear)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lacerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* maul(PlayerbotAI* ai)
+    {
+        return new ActionNode ("maul",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lacerate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lacerate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("maul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* growl(PlayerbotAI* ai)
+    {
+        return new ActionNode ("growl",
+            /*P*/ NextAction::array(0, new NextAction("reach spell"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* demoralizing_roar(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demoralizing roar",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+BearTankDruidStrategy::BearTankDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new BearTankDruidStrategyActionNodeFactory());
+}
+
+NextAction** BearTankDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0,
+            new NextAction("lacerate", ACTION_NORMAL + 4),
+            new NextAction("mangle (bear)", ACTION_NORMAL + 3),
+            new NextAction("maul", ACTION_NORMAL + 2),
+            new NextAction("faerie fire (feral)", ACTION_NORMAL + 1),
+            NULL);
+}
+
+void BearTankDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "thorns",
+        NextAction::array(0, new NextAction("thorns", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bear form",
+        NextAction::array(0, new NextAction("dire bear form", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("growl", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("demoralizing roar", ACTION_HIGH + 6), new NextAction("swipe (bear)", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("swipe (bear)", ACTION_HIGH + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash",
+        NextAction::array(0, new NextAction("bash", ACTION_INTERRUPT + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash on enemy healer",
+        NextAction::array(0, new NextAction("bash on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
new file mode 100644
index 0000000..1e8a3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+
+namespace ai
+{
+    class BearTankDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        BearTankDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bear"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
new file mode 100644
index 0000000..bb07940
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CasterDruidStrategy.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class CasterDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire"] = &faerie_fire;
+        creators["hibernate"] = &hibernate;
+        creators["entangling roots"] = &entangling_roots;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["wrath"] = &wrath;
+        creators["starfall"] = &starfall;
+        creators["insect swarm"] = &insect_swarm;
+        creators["moonfire"] = &moonfire;
+        creators["starfire"] = &starfire;
+        creators["nature's grasp"] = &natures_grasp;
+    }
+private:
+    static ActionNode* faerie_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* hibernate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hibernate",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("entangling roots"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* wrath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("wrath",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfall",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("hurricane"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* insect_swarm(PlayerbotAI* ai)
+    {
+        return new ActionNode ("insect swarm",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* moonfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("moonfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* natures_grasp(PlayerbotAI* ai)
+    {
+        return new ActionNode ("nature's grasp",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CasterDruidStrategy::CasterDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+NextAction** CasterDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 2), new NextAction("wrath", ACTION_NORMAL + 1), NULL);
+}
+
+void CasterDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_MOVE), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+
+	triggers.push_back(new TriggerNode(
+		"insect swarm",
+		NextAction::array(0, new NextAction("insect swarm", ACTION_NORMAL + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"moonfire",
+		NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (solar)",
+        NextAction::array(0, new NextAction("wrath", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (lunar)",
+        NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "moonfire",
+        NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+
+
+	triggers.push_back(new TriggerNode(
+		"nature's grasp",
+		NextAction::array(0, new NextAction("nature's grasp", ACTION_EMERGENCY), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 2), NULL)));
+}
+
+void CasterDruidAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("starfall", ACTION_HIGH + 1), NULL)));
+}
+
+void CasterDruidDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "faerie fire",
+        NextAction::array(0, new NextAction("faerie fire", ACTION_HIGH), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
new file mode 100644
index 0000000..66ac838
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CasterDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        CasterDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterDruidAoeStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+
+    class CasterDruidDebuffStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
new file mode 100644
index 0000000..67515b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
@@ -0,0 +1,139 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CatDpsDruidStrategy.h"
+
+using namespace ai;
+
+class CatDpsDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CatDpsDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["melee"] = &melee;
+        creators["feral charge - cat"] = &feral_charge_cat;
+        creators["cat form"] = &cat_form;
+        creators["claw"] = &claw;
+        creators["mangle (cat)"] = &mangle_cat;
+        creators["rake"] = &rake;
+        creators["ferocious bite"] = &ferocious_bite;
+        creators["rip"] = &rip;
+    }
+private:
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - cat"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - cat",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* cat_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cat form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* claw(PlayerbotAI* ai)
+    {
+        return new ActionNode ("claw",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (cat)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("claw"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rake(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rake",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* ferocious_bite(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ferocious bite",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rip"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rip(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rip",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CatDpsDruidStrategy::CatDpsDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CatDpsDruidStrategyActionNodeFactory());
+}
+
+NextAction** CatDpsDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mangle (cat)", ACTION_NORMAL + 1), NULL);
+}
+
+void CatDpsDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "cat form",
+        NextAction::array(0, new NextAction("cat form", ACTION_MOVE + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rake",
+        NextAction::array(0, new NextAction("rake", ACTION_NORMAL + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("ferocious bite", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("cower", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"tiger's fury",
+		NextAction::array(0, new NextAction("tiger's fury", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+
+}
+
+void CatAoeDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("swipe (cat)", ACTION_HIGH + 2), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
new file mode 100644
index 0000000..397f0b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CatDpsDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        CatDpsDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+    class CatAoeDruidStrategy : public CombatStrategy
+    {
+    public:
+        CatAoeDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.cpp b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
new file mode 100644
index 0000000..fc49e68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
+bool CastCasterFormAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+    return true;
+}
+
+NextAction** CastAbolishPoisonAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison"), NULL), CastSpellAction::getPrerequisites());
+}
+
+NextAction** CastAbolishPoisonOnPartyAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison on party"), NULL), CastSpellAction::getPrerequisites());
+}
+
+Value<Unit*>* CastEntanglingRootsCcAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "entangling roots");
+}
+
+bool CastEntanglingRootsCcAction::Execute(Event event)
+{
+    return ai->CastSpell("entangling roots", GetTarget()); 
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.h b/src/plugins/playerbot/strategy/druid/DruidActions.h
new file mode 100644
index 0000000..965f454
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "DruidShapeshiftActions.h"
+#include "DruidBearActions.h"
+#include "DruidCatActions.h"
+
+namespace ai
+{
+	class CastFaerieFireAction : public CastSpellAction
+	{
+	public:
+		CastFaerieFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire") {}
+	};
+
+    class CastFaerieFireFeralAction : public CastSpellAction
+    {
+    public:
+        CastFaerieFireFeralAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire (feral)") {}
+    };
+
+	class CastRejuvenationAction : public CastHealingSpellAction {
+	public:
+		CastRejuvenationAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "rejuvenation") {}
+	};
+
+	class CastRegrowthAction : public CastHealingSpellAction {
+	public:
+		CastRegrowthAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "regrowth") {}
+
+	};
+
+    class CastHealingTouchAction : public CastHealingSpellAction {
+    public:
+        CastHealingTouchAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing touch") {}
+
+    };
+
+    class CastRejuvenationOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRejuvenationOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "rejuvenation") {}
+    };
+
+    class CastRegrowthOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRegrowthOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "regrowth") {}
+    };
+
+    class CastHealingTouchOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingTouchOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing touch") {}
+    };
+
+	class CastReviveAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastReviveAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "revive") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastRebirthAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRebirthAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "rebirth") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastMarkOfTheWildAction : public CastBuffSpellAction {
+	public:
+		CastMarkOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mark of the wild") {}
+	};
+
+	class CastMarkOfTheWildOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastMarkOfTheWildOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "mark of the wild") {}
+	};
+
+	class CastSurvivalInstinctsAction : public CastBuffSpellAction {
+	public:
+		CastSurvivalInstinctsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "survival instincts") {}
+	};
+
+	class CastThornsAction : public CastBuffSpellAction {
+	public:
+		CastThornsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "thorns") {}
+	};
+
+	class CastWrathAction : public CastSpellAction
+	{
+	public:
+		CastWrathAction(PlayerbotAI* ai) : CastSpellAction(ai, "wrath") {}
+	};
+
+	class CastStarfallAction : public CastSpellAction
+	{
+	public:
+		CastStarfallAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfall") {}
+	};
+
+	class CastHurricaneAction : public CastSpellAction
+	{
+	public:
+	    CastHurricaneAction(PlayerbotAI* ai) : CastSpellAction(ai, "hurricane") {}
+	};
+
+	class CastMoonfireAction : public CastDebuffSpellAction
+	{
+	public:
+		CastMoonfireAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "moonfire") {}
+	};
+
+	class CastInsectSwarmAction : public CastDebuffSpellAction
+	{
+	public:
+		CastInsectSwarmAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "insect swarm") {}
+	};
+
+	class CastStarfireAction : public CastSpellAction
+	{
+	public:
+		CastStarfireAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfire") {}
+	};
+
+	class CastEntanglingRootsAction : public CastSpellAction
+	{
+	public:
+		CastEntanglingRootsAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots") {}
+	};
+
+    class CastEntanglingRootsCcAction : public CastSpellAction
+    {
+    public:
+        CastEntanglingRootsCcAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots on cc") {}
+        virtual Value<Unit*>* GetTargetValue();
+        virtual bool Execute(Event event);
+    };
+
+	class CastNaturesGraspAction : public CastBuffSpellAction
+	{
+	public:
+		CastNaturesGraspAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "nature's grasp") {}
+	};
+
+	class CastHibernateAction : public CastSpellAction
+	{
+	public:
+		CastHibernateAction(PlayerbotAI* ai) : CastSpellAction(ai, "hibernate") {}
+	};
+
+	class CastCurePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCurePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure poison") {}
+	};
+
+    class CastCurePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCurePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+	class CastAbolishPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastAbolishPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish poison") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish poison", DISPEL_POISON) {}
+
+        virtual NextAction** getAlternatives();
+    };
+
+    class CastBarskinAction : public CastBuffSpellAction
+    {
+    public:
+        CastBarskinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "barskin") {}
+    };
+
+    class CastInnervateAction : public CastSpellAction
+    {
+    public:
+        CastInnervateAction(PlayerbotAI* ai) : CastSpellAction(ai, "innervate") {}
+
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastTranquilityAction : public CastAoeHealSpellAction
+    {
+    public:
+        CastTranquilityAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "tranquility") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
new file mode 100644
index 0000000..65c9fc9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
@@ -0,0 +1,258 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+#include "DruidAiObjectContext.h"
+#include "BearTankDruidStrategy.h"
+#include "CatDpsDruidStrategy.h"
+#include "CasterDruidStrategy.h"
+#include "GenericDruidNonCombatStrategy.h"
+#include "../NamedObjectContext.h"
+#include "DruidTriggers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &druid::StrategyFactoryInternal::nc;
+                creators["cat aoe"] = &druid::StrategyFactoryInternal::cat_aoe;
+                creators["caster aoe"] = &druid::StrategyFactoryInternal::caster_aoe;
+                creators["caster debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+                creators["dps debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericDruidNonCombatStrategy(ai); }
+            static Strategy* cat_aoe(PlayerbotAI* ai) { return new CatAoeDruidStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterDruidAoeStrategy(ai); }
+            static Strategy* caster_debuff(PlayerbotAI* ai) { return new CasterDruidDebuffStrategy(ai); }
+        };
+
+        class DruidStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            DruidStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bear"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["tank"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["cat"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["caster"] = &druid::DruidStrategyFactoryInternal::caster;
+                creators["dps"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["heal"] = &druid::DruidStrategyFactoryInternal::heal;
+            }
+
+        private:
+            static Strategy* bear(PlayerbotAI* ai) { return new BearTankDruidStrategy(ai); }
+            static Strategy* cat(PlayerbotAI* ai) { return new CatDpsDruidStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterDruidStrategy(ai); }
+            static Strategy* heal(PlayerbotAI* ai) { return new HealDruidStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["thorns"] = &TriggerFactoryInternal::Thorns;
+                creators["bash"] = &TriggerFactoryInternal::bash;
+                creators["faerie fire (feral)"] = &TriggerFactoryInternal::faerie_fire_feral;
+                creators["faerie fire"] = &TriggerFactoryInternal::faerie_fire;
+                creators["insect swarm"] = &TriggerFactoryInternal::insect_swarm;
+                creators["moonfire"] = &TriggerFactoryInternal::moonfire;
+                creators["nature's grasp"] = &TriggerFactoryInternal::natures_grasp;
+                creators["tiger's fury"] = &TriggerFactoryInternal::tigers_fury;
+                creators["rake"] = &TriggerFactoryInternal::rake;
+                creators["mark of the wild"] = &TriggerFactoryInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &TriggerFactoryInternal::mark_of_the_wild_on_party;
+                creators["cure poison"] = &TriggerFactoryInternal::cure_poison;
+                creators["party member cure poison"] = &TriggerFactoryInternal::party_member_cure_poison;
+                creators["entangling roots"] = &TriggerFactoryInternal::entangling_roots;
+                creators["bear form"] = &TriggerFactoryInternal::bear_form;
+                creators["cat form"] = &TriggerFactoryInternal::cat_form;
+                creators["tree form"] = &TriggerFactoryInternal::tree_form;
+                creators["eclipse (solar)"] = &TriggerFactoryInternal::eclipse_solar;
+                creators["eclipse (lunar)"] = &TriggerFactoryInternal::eclipse_lunar;
+                creators["bash on enemy healer"] = &TriggerFactoryInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* eclipse_solar(PlayerbotAI* ai) { return new EclipseSolarTrigger(ai); }
+            static Trigger* eclipse_lunar(PlayerbotAI* ai) { return new EclipseLunarTrigger(ai); }
+            static Trigger* Thorns(PlayerbotAI* ai) { return new ThornsTrigger(ai); }
+            static Trigger* bash(PlayerbotAI* ai) { return new BashInterruptSpellTrigger(ai); }
+            static Trigger* faerie_fire_feral(PlayerbotAI* ai) { return new FaerieFireFeralTrigger(ai); }
+            static Trigger* insect_swarm(PlayerbotAI* ai) { return new InsectSwarmTrigger(ai); }
+            static Trigger* moonfire(PlayerbotAI* ai) { return new MoonfireTrigger(ai); }
+            static Trigger* faerie_fire(PlayerbotAI* ai) { return new FaerieFireTrigger(ai); }
+            static Trigger* natures_grasp(PlayerbotAI* ai) { return new NaturesGraspTrigger(ai); }
+            static Trigger* tigers_fury(PlayerbotAI* ai) { return new TigersFuryTrigger(ai); }
+            static Trigger* rake(PlayerbotAI* ai) { return new RakeTrigger(ai); }
+            static Trigger* mark_of_the_wild(PlayerbotAI* ai) { return new MarkOfTheWildTrigger(ai); }
+            static Trigger* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new MarkOfTheWildOnPartyTrigger(ai); }
+            static Trigger* cure_poison(PlayerbotAI* ai) { return new CurePoisonTrigger(ai); }
+            static Trigger* party_member_cure_poison(PlayerbotAI* ai) { return new PartyMemberCurePoisonTrigger(ai); }
+            static Trigger* entangling_roots(PlayerbotAI* ai) { return new EntanglingRootsTrigger(ai); }
+            static Trigger* bear_form(PlayerbotAI* ai) { return new BearFormTrigger(ai); }
+            static Trigger* cat_form(PlayerbotAI* ai) { return new CatFormTrigger(ai); }
+            static Trigger* tree_form(PlayerbotAI* ai) { return new TreeFormTrigger(ai); }
+            static Trigger* bash_on_enemy_healer(PlayerbotAI* ai) { return new BashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["feral charge - bear"] = &AiObjectContextInternal::feral_charge_bear;
+                creators["feral charge - cat"] = &AiObjectContextInternal::feral_charge_cat;
+                creators["swipe (bear)"] = &AiObjectContextInternal::swipe_bear;
+                creators["faerie fire (feral)"] = &AiObjectContextInternal::faerie_fire_feral;
+                creators["faerie fire"] = &AiObjectContextInternal::faerie_fire;
+                creators["bear form"] = &AiObjectContextInternal::bear_form;
+                creators["dire bear form"] = &AiObjectContextInternal::dire_bear_form;
+                creators["moonkin form"] = &AiObjectContextInternal::moonkin_form;
+                creators["cat form"] = &AiObjectContextInternal::cat_form;
+                creators["tree form"] = &AiObjectContextInternal::tree_form;
+                creators["caster form"] = &AiObjectContextInternal::caster_form;
+                creators["mangle (bear)"] = &AiObjectContextInternal::mangle_bear;
+                creators["maul"] = &AiObjectContextInternal::maul;
+                creators["bash"] = &AiObjectContextInternal::bash;
+                creators["swipe"] = &AiObjectContextInternal::swipe;
+                creators["growl"] = &AiObjectContextInternal::growl;
+                creators["demoralizing roar"] = &AiObjectContextInternal::demoralizing_roar;
+                creators["hibernate"] = &AiObjectContextInternal::hibernate;
+                creators["entangling roots"] = &AiObjectContextInternal::entangling_roots;
+                creators["entangling roots on cc"] = &AiObjectContextInternal::entangling_roots_on_cc;
+                creators["wrath"] = &AiObjectContextInternal::wrath;
+                creators["starfall"] = &AiObjectContextInternal::starfall;
+                creators["insect swarm"] = &AiObjectContextInternal::insect_swarm;
+                creators["moonfire"] = &AiObjectContextInternal::moonfire;
+                creators["starfire"] = &AiObjectContextInternal::starfire;
+                creators["nature's grasp"] = &AiObjectContextInternal::natures_grasp;
+                creators["claw"] = &AiObjectContextInternal::claw;
+                creators["mangle (cat)"] = &AiObjectContextInternal::mangle_cat;
+                creators["swipe (cat)"] = &AiObjectContextInternal::swipe_cat;
+                creators["rake"] = &AiObjectContextInternal::rake;
+                creators["ferocious bite"] = &AiObjectContextInternal::ferocious_bite;
+                creators["rip"] = &AiObjectContextInternal::rip;
+                creators["cower"] = &AiObjectContextInternal::cower;
+                creators["survival instincts"] = &AiObjectContextInternal::survival_instincts;
+                creators["thorns"] = &AiObjectContextInternal::thorns;
+                creators["cure poison"] = &AiObjectContextInternal::cure_poison;
+                creators["cure poison on party"] = &AiObjectContextInternal::cure_poison_on_party;
+                creators["abolish poison"] = &AiObjectContextInternal::abolish_poison;
+                creators["abolish poison on party"] = &AiObjectContextInternal::abolish_poison_on_party;
+                creators["berserk"] = &AiObjectContextInternal::berserk;
+                creators["tiger's fury"] = &AiObjectContextInternal::tigers_fury;
+                creators["mark of the wild"] = &AiObjectContextInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &AiObjectContextInternal::mark_of_the_wild_on_party;
+                creators["regrowth"] = &AiObjectContextInternal::regrowth;
+                creators["rejuvenation"] = &AiObjectContextInternal::rejuvenation;
+                creators["healing touch"] = &AiObjectContextInternal::healing_touch;
+                creators["regrowth on party"] = &AiObjectContextInternal::regrowth_on_party;
+                creators["rejuvenation on party"] = &AiObjectContextInternal::rejuvenation_on_party;
+                creators["healing touch on party"] = &AiObjectContextInternal::healing_touch_on_party;
+                creators["rebirth"] = &AiObjectContextInternal::rebirth;
+                creators["revive"] = &AiObjectContextInternal::revive;
+                creators["barskin"] = &AiObjectContextInternal::barskin;
+                creators["lacerate"] = &AiObjectContextInternal::lacerate;
+                creators["hurricane"] = &AiObjectContextInternal::hurricane;
+                creators["innervate"] = &AiObjectContextInternal::innervate;
+                creators["tranquility"] = &AiObjectContextInternal::tranquility;
+                creators["bash on enemy healer"] = &AiObjectContextInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* tranquility(PlayerbotAI* ai) { return new CastTranquilityAction(ai); }
+            static Action* feral_charge_bear(PlayerbotAI* ai) { return new CastFeralChargeBearAction(ai); }
+            static Action* feral_charge_cat(PlayerbotAI* ai) { return new CastFeralChargeCatAction(ai); }
+            static Action* swipe_bear(PlayerbotAI* ai) { return new CastSwipeBearAction(ai); }
+            static Action* faerie_fire_feral(PlayerbotAI* ai) { return new CastFaerieFireFeralAction(ai); }
+            static Action* faerie_fire(PlayerbotAI* ai) { return new CastFaerieFireAction(ai); }
+            static Action* bear_form(PlayerbotAI* ai) { return new CastBearFormAction(ai); }
+            static Action* dire_bear_form(PlayerbotAI* ai) { return new CastDireBearFormAction(ai); }
+            static Action* cat_form(PlayerbotAI* ai) { return new CastCatFormAction(ai); }
+            static Action* tree_form(PlayerbotAI* ai) { return new CastTreeFormAction(ai); }
+            static Action* caster_form(PlayerbotAI* ai) { return new CastCasterFormAction(ai); }
+            static Action* mangle_bear(PlayerbotAI* ai) { return new CastMangleBearAction(ai); }
+            static Action* maul(PlayerbotAI* ai) { return new CastMaulAction(ai); }
+            static Action* bash(PlayerbotAI* ai) { return new CastBashAction(ai); }
+            static Action* swipe(PlayerbotAI* ai) { return new CastSwipeAction(ai); }
+            static Action* growl(PlayerbotAI* ai) { return new CastGrowlAction(ai); }
+            static Action* demoralizing_roar(PlayerbotAI* ai) { return new CastDemoralizingRoarAction(ai); }
+            static Action* moonkin_form(PlayerbotAI* ai) { return new CastMoonkinFormAction(ai); }
+            static Action* hibernate(PlayerbotAI* ai) { return new CastHibernateAction(ai); }
+            static Action* entangling_roots(PlayerbotAI* ai) { return new CastEntanglingRootsAction(ai); }
+            static Action* entangling_roots_on_cc(PlayerbotAI* ai) { return new CastEntanglingRootsCcAction(ai); }
+            static Action* wrath(PlayerbotAI* ai) { return new CastWrathAction(ai); }
+            static Action* starfall(PlayerbotAI* ai) { return new CastStarfallAction(ai); }
+            static Action* insect_swarm(PlayerbotAI* ai) { return new CastInsectSwarmAction(ai); }
+            static Action* moonfire(PlayerbotAI* ai) { return new CastMoonfireAction(ai); }
+            static Action* starfire(PlayerbotAI* ai) { return new CastStarfireAction(ai); }
+            static Action* natures_grasp(PlayerbotAI* ai) { return new CastNaturesGraspAction(ai); }
+            static Action* claw(PlayerbotAI* ai) { return new CastClawAction(ai); }
+            static Action* mangle_cat(PlayerbotAI* ai) { return new CastMangleCatAction(ai); }
+            static Action* swipe_cat(PlayerbotAI* ai) { return new CastSwipeCatAction(ai); }
+            static Action* rake(PlayerbotAI* ai) { return new CastRakeAction(ai); }
+            static Action* ferocious_bite(PlayerbotAI* ai) { return new CastFerociousBiteAction(ai); }
+            static Action* rip(PlayerbotAI* ai) { return new CastRipAction(ai); }
+            static Action* cower(PlayerbotAI* ai) { return new CastCowerAction(ai); }
+            static Action* survival_instincts(PlayerbotAI* ai) { return new CastSurvivalInstinctsAction(ai); }
+            static Action* thorns(PlayerbotAI* ai) { return new CastThornsAction(ai); }
+            static Action* cure_poison(PlayerbotAI* ai) { return new CastCurePoisonAction(ai); }
+            static Action* cure_poison_on_party(PlayerbotAI* ai) { return new CastCurePoisonOnPartyAction(ai); }
+            static Action* abolish_poison(PlayerbotAI* ai) { return new CastAbolishPoisonAction(ai); }
+            static Action* abolish_poison_on_party(PlayerbotAI* ai) { return new CastAbolishPoisonOnPartyAction(ai); }
+            static Action* berserk(PlayerbotAI* ai) { return new CastBerserkAction(ai); }
+            static Action* tigers_fury(PlayerbotAI* ai) { return new CastTigersFuryAction(ai); }
+            static Action* mark_of_the_wild(PlayerbotAI* ai) { return new CastMarkOfTheWildAction(ai); }
+            static Action* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new CastMarkOfTheWildOnPartyAction(ai); }
+            static Action* regrowth(PlayerbotAI* ai) { return new CastRegrowthAction(ai); }
+            static Action* rejuvenation(PlayerbotAI* ai) { return new CastRejuvenationAction(ai); }
+            static Action* healing_touch(PlayerbotAI* ai) { return new CastHealingTouchAction(ai); }
+            static Action* regrowth_on_party(PlayerbotAI* ai) { return new CastRegrowthOnPartyAction(ai); }
+            static Action* rejuvenation_on_party(PlayerbotAI* ai) { return new CastRejuvenationOnPartyAction(ai); }
+            static Action* healing_touch_on_party(PlayerbotAI* ai) { return new CastHealingTouchOnPartyAction(ai); }
+            static Action* rebirth(PlayerbotAI* ai) { return new CastRebirthAction(ai); }
+            static Action* revive(PlayerbotAI* ai) { return new CastReviveAction(ai); }
+            static Action* barskin(PlayerbotAI* ai) { return new CastBarskinAction(ai); }
+            static Action* lacerate(PlayerbotAI* ai) { return new CastLacerateAction(ai); }
+            static Action* hurricane(PlayerbotAI* ai) { return new CastHurricaneAction(ai); }
+            static Action* innervate(PlayerbotAI* ai) { return new CastInnervateAction(ai); }
+            static Action* bash_on_enemy_healer(PlayerbotAI* ai) { return new CastBashOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+DruidAiObjectContext::DruidAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::druid::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::druid::DruidStrategyFactoryInternal());
+    actionContexts.Add(new ai::druid::AiObjectContextInternal());
+    triggerContexts.Add(new ai::druid::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
new file mode 100644
index 0000000..b5d7a2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class DruidAiObjectContext : public AiObjectContext
+    {
+    public:
+        DruidAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidBearActions.h b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
new file mode 100644
index 0000000..81bc8ab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
@@ -0,0 +1,64 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeBearAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeBearAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - bear", 1.5f) {}
+	};
+
+	class CastGrowlAction : public CastSpellAction
+	{
+	public:
+		CastGrowlAction(PlayerbotAI* ai) : CastSpellAction(ai, "growl") {}
+	};
+
+	class CastMaulAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMaulAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "maul") {}
+		virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "rage", "self target") >= 45; }
+	};
+
+	class CastBashAction : public CastMeleeSpellAction
+	{
+	public:
+		CastBashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bash") {}
+	};
+
+	class CastSwipeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe") {}
+	};
+
+	class CastDemoralizingRoarAction : public CastDebuffSpellAction
+	{
+	public:
+		CastDemoralizingRoarAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing roar") {}
+	};
+
+	class CastMangleBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMangleBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (bear)") {}
+	};
+
+	class CastSwipeBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (bear)") {}
+	};
+
+    class CastLacerateAction : public CastMeleeSpellAction
+    {
+    public:
+        CastLacerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lacerate") {}
+    };
+
+    class CastBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidCatActions.h b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
new file mode 100644
index 0000000..90f50c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
@@ -0,0 +1,69 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeCatAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeCatAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - cat", 1.5f) {}
+	};
+
+	class CastCowerAction : public CastBuffSpellAction
+	{
+	public:
+		CastCowerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cower") {}
+	};
+
+
+	class CastBerserkAction : public CastBuffSpellAction
+	{
+	public:
+		CastBerserkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserk") {}
+	};
+
+	class CastTigersFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastTigersFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tiger's fury") {}
+	};
+
+	class CastRakeAction : public CastDebuffSpellAction
+	{
+	public:
+		CastRakeAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "rake") {}
+
+        virtual NextAction** getPrerequisites()
+        {
+            return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+        }
+	};
+
+
+	class CastClawAction : public CastMeleeSpellAction {
+	public:
+		CastClawAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "claw") {}
+	};
+
+	class CastMangleCatAction : public CastMeleeSpellAction {
+	public:
+		CastMangleCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (cat)") {}
+	};
+
+	class CastSwipeCatAction : public CastMeleeSpellAction {
+	public:
+		CastSwipeCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (cat)") {}
+	};
+
+	class CastFerociousBiteAction : public CastMeleeSpellAction {
+	public:
+		CastFerociousBiteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "ferocious bite") {}
+	};
+
+
+	class CastRipAction : public CastMeleeSpellAction {
+	public:
+		CastRipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rip") {}
+	};
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
new file mode 100644
index 0000000..d273c7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "DruidActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.h b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
new file mode 100644
index 0000000..746c635
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
@@ -0,0 +1,53 @@
+#pragma once
+
+namespace ai {
+	class CastBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bear form") {} 
+
+        virtual bool isPossible() {
+			return CastBuffSpellAction::isPossible() && !ai->HasAura("dire bear form", GetTarget());
+		}
+        virtual bool isUseful() {
+			return CastBuffSpellAction::isUseful() && !ai->HasAura("dire bear form", GetTarget());
+		}
+	};
+
+	class CastDireBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastDireBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "dire bear form") {} 
+        
+        virtual NextAction** getAlternatives() {
+			return NextAction::merge(NextAction::array(0, new NextAction("bear form"), NULL), CastSpellAction::getAlternatives());
+		}
+	};
+
+	class CastCatFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCatFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cat form") {} 
+	};
+
+	class CastTreeFormAction : public CastBuffSpellAction {
+	public:
+		CastTreeFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tree of life") {}
+	};
+
+	class CastMoonkinFormAction : public CastBuffSpellAction { 
+	public: 
+		CastMoonkinFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "moonkin form") {} 
+	};
+
+	class CastCasterFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCasterFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "caster form") {} 
+
+		virtual bool isUseful() {
+			return ai->HasAnyAuraOf(GetTarget(), "dire bear form", "bear form", "cat form", "travel form", "aquatic form", 
+				"flight form", "swift flight form", "moonkin form", "tree of life", NULL);
+		}
+		virtual bool isPossible() { return true; }
+		
+		virtual bool Execute(Event event);
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
new file mode 100644
index 0000000..963c9fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidTriggers.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.h b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
new file mode 100644
index 0000000..1c0d4d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
@@ -0,0 +1,127 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai {
+    class MarkOfTheWildOnPartyTrigger : public BuffOnPartyTrigger
+    {
+    public:
+        MarkOfTheWildOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "mark of the wild") {}
+    };
+
+    class MarkOfTheWildTrigger : public BuffTrigger
+    {
+    public:
+        MarkOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mark of the wild") {}
+    };
+
+    class ThornsTrigger : public BuffTrigger
+    {
+    public:
+        ThornsTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "thorns") {}
+    };
+
+    class RakeTrigger : public DebuffTrigger
+    {
+    public:
+        RakeTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rake") {}
+    };
+
+    class InsectSwarmTrigger : public DebuffTrigger
+    {
+    public:
+        InsectSwarmTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "insect swarm") {}
+    };
+
+    class MoonfireTrigger : public DebuffTrigger
+    {
+    public:
+        MoonfireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "moonfire") {}
+    };
+
+    class FaerieFireTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire") {}
+    };
+
+    class FaerieFireFeralTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireFeralTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire (feral)") {}
+    };
+
+    class BashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        BashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "bash") {}
+    };
+
+    class TigersFuryTrigger : public BoostTrigger
+    {
+    public:
+        TigersFuryTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "tiger's fury") {}
+    };
+
+    class NaturesGraspTrigger : public BoostTrigger
+    {
+    public:
+        NaturesGraspTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "nature's grasp") {}
+    };
+
+    class EntanglingRootsTrigger : public HasCcTargetTrigger
+    {
+    public:
+        EntanglingRootsTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "entangling roots") {}
+    };
+
+    class CurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCurePoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCurePoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class BearFormTrigger : public BuffTrigger
+    {
+    public:
+        BearFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "bear form") {}
+        virtual bool IsActive() { return !ai->HasAnyAuraOf(bot, "bear form", "dire bear form", NULL); }
+    };
+
+    class TreeFormTrigger : public BuffTrigger
+    {
+    public:
+        TreeFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "tree of life") {}
+        virtual bool IsActive() { return !ai->HasAura("tree of life", bot); }
+    };
+
+    class CatFormTrigger : public BuffTrigger
+    {
+    public:
+        CatFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "cat form") {}
+        virtual bool IsActive() { return !ai->HasAura("cat form", bot); }
+    };
+
+    class EclipseSolarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseSolarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (solar)") {}
+    };
+
+    class EclipseLunarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseLunarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (lunar)") {}
+    };
+
+    class BashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        BashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
new file mode 100644
index 0000000..1956573
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class FeralDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    FeralDruidStrategyActionNodeFactory()
+    {
+        creators["survival instincts"] = &survival_instincts;
+        creators["thorns"] = &thorns;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+    }
+private:
+    static ActionNode* survival_instincts(PlayerbotAI* ai)
+    {
+        return new ActionNode ("survival instincts",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("barskin"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* thorns(PlayerbotAI* ai)
+    {
+        return new ActionNode ("thorns",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+FeralDruidStrategy::FeralDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new FeralDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+void FeralDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("survival instincts", ACTION_EMERGENCY + 1), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
new file mode 100644
index 0000000..0ee4a8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
@@ -0,0 +1,75 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+namespace ai
+{
+    class ShapeshiftDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShapeshiftDruidStrategyActionNodeFactory()
+        {
+            creators["rejuvenation"] = &rejuvenation;
+            creators["regrowth"] = &regrowth;
+            creators["healing touch"] = &healing_touch;
+            creators["rejuvenation on party"] = &rejuvenation_on_party;
+            creators["regrowth on party"] = &regrowth_on_party;
+            creators["healing touch on party"] = &healing_touch_on_party;
+        }
+    private:
+        static ActionNode* regrowth(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* regrowth_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch on party"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+    };
+
+    class FeralDruidStrategy : public GenericDruidStrategy
+    {
+    protected:
+        FeralDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
new file mode 100644
index 0000000..e6377da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "GenericDruidNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericDruidNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidNonCombatStrategyActionNodeFactory()
+    {
+        creators["mark of the wild"] = &mark_of_the_wild;
+        creators["mark of the wild on party"] = &mark_of_the_wild_on_party;
+        creators["innervate"] = &innervate;
+    }
+private:
+    static ActionNode* mark_of_the_wild(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mark_of_the_wild_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidNonCombatStrategy::GenericDruidNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidNonCombatStrategyActionNodeFactory());
+}
+
+void GenericDruidNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild",
+        NextAction::array(0, new NextAction("mark of the wild", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild on party",
+        NextAction::array(0, new NextAction("mark of the wild on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("revive", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
new file mode 100644
index 0000000..82cba15
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericDruidNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericDruidNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
new file mode 100644
index 0000000..e4f1921
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
@@ -0,0 +1,132 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["caster form"] = &caster_form;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+        creators["rebirth"] = &rebirth;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["innervate"] = &innervate;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* caster_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("caster form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rebirth(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rebirth",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidStrategy::GenericDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidStrategyActionNodeFactory());
+}
+
+void GenericDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_CRITICAL_HEAL + 2), new NextAction("healing touch", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0,  new NextAction("regrowth on party", ACTION_CRITICAL_HEAL + 1), new NextAction("healing touch on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("rebirth", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
new file mode 100644
index 0000000..dc12a85
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericDruidStrategy : public CombatStrategy
+    {
+    protected:
+        GenericDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
new file mode 100644
index 0000000..5b1cfb3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
@@ -0,0 +1,57 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+class HealDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealDruidStrategyActionNodeFactory()
+    {
+    }
+private:
+};
+
+HealDruidStrategy::HealDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new HealDruidStrategyActionNodeFactory());
+}
+
+void HealDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tree form",
+        NextAction::array(0, new NextAction("tree form", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("tranquility", ACTION_MEDIUM_HEAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
new file mode 100644
index 0000000..a0440ba
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+
+namespace ai
+{
+    class HealDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        HealDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+        virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
new file mode 100644
index 0000000..43db065
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackEnemyPlayersStrategy.h"
+
+using namespace ai;
+
+void AttackEnemyPlayersStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy player is attacking",
+        NextAction::array(0, new NextAction("attack enemy player", 61.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
new file mode 100644
index 0000000..cd9ce7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackEnemyPlayersStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackEnemyPlayersStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "pvp"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
new file mode 100644
index 0000000..d33bb74
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackRtiStrategy.h"
+
+using namespace ai;
+
+
+void AttackRtiStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack rti target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
new file mode 100644
index 0000000..ad9662a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackRtiStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackRtiStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack rti"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
new file mode 100644
index 0000000..d3a832a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackWeakStrategy.h"
+
+using namespace ai;
+
+void AttackWeakStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "not least hp target active",
+        NextAction::array(0, new NextAction("attack least hp target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
new file mode 100644
index 0000000..c6c20c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackWeakStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackWeakStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack weak"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
new file mode 100644
index 0000000..7d1a483
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastTimeStrategy.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float CastTimeMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    string name = action->getName();
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastSpellAction*>(action))
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", name);
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            return 1.0f;
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        int32 castTime = spell->GetCastTime();
+        delete spell;
+
+        if (spellId && castTime >= 3000)
+            return 0.0f;
+        else if (spellId && castTime >= 1500)
+            return 0.5f;
+    }
+
+    return 1.0f;
+}
+
+
+void CastTimeStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new CastTimeMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
new file mode 100644
index 0000000..a483fc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+
+    class CastTimeMultiplier : public Multiplier
+    {
+    public:
+        CastTimeMultiplier(PlayerbotAI* ai) : Multiplier(ai, "cast time") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class CastTimeStrategy : public Strategy
+    {
+    public:
+        CastTimeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "cast time"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
new file mode 100644
index 0000000..991551e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+class ChatCommandActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ChatCommandActionNodeFactoryInternal()
+    {
+        creators["tank attack chat shortcut"] = &tank_attack_chat_shortcut;
+    }
+
+private:
+    static ActionNode* tank_attack_chat_shortcut(PlayerbotAI* ai)
+    {
+        return new ActionNode ("tank attack chat shortcut",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("attack my target", 100.0f), NULL));
+    }
+};
+
+void ChatCommandHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "rep",
+        NextAction::array(0, new NextAction("reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "q",
+        NextAction::array(0,
+            new NextAction("query quest", relevance),
+            new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "add all loot",
+        NextAction::array(0, new NextAction("add all loot", relevance), new NextAction("loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "u",
+        NextAction::array(0, new NextAction("use", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "c",
+        NextAction::array(0, new NextAction("item count", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "e",
+        NextAction::array(0, new NextAction("equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ue",
+        NextAction::array(0, new NextAction("unequip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "t",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "nt",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "s",
+        NextAction::array(0, new NextAction("sell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "b",
+        NextAction::array(0, new NextAction("buy", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "r",
+        NextAction::array(0, new NextAction("reward", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attack",
+        NextAction::array(0, new NextAction("attack my target", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "accept",
+        NextAction::array(0, new NextAction("accept quest", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "follow",
+        NextAction::array(0, new NextAction("follow chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "stay",
+        NextAction::array(0, new NextAction("stay chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flee",
+        NextAction::array(0, new NextAction("flee chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tank attack",
+        NextAction::array(0, new NextAction("tank attack chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "grind",
+        NextAction::array(0, new NextAction("grind chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "talk",
+        NextAction::array(0, new NextAction("gossip hello", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cast",
+        NextAction::array(0, new NextAction("cast custom spell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "revive",
+        NextAction::array(0, new NextAction("spirit healer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "runaway",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "warning",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "max dps",
+        NextAction::array(0, new NextAction("max dps chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attackers",
+        NextAction::array(0, new NextAction("tell attackers", relevance), NULL)));
+}
+
+
+
+ChatCommandHandlerStrategy::ChatCommandHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    actionNodeFactories.Add(new ChatCommandActionNodeFactoryInternal());
+
+    supported.push_back("quests");
+    supported.push_back("stats");
+    supported.push_back("leave");
+    supported.push_back("reputation");
+    supported.push_back("log");
+    supported.push_back("los");
+    supported.push_back("drop");
+    supported.push_back("ll");
+    supported.push_back("release");
+    supported.push_back("teleport");
+    supported.push_back("taxi");
+    supported.push_back("repair");
+    supported.push_back("talents");
+    supported.push_back("spells");
+    supported.push_back("co");
+    supported.push_back("nc");
+    supported.push_back("dead");
+    supported.push_back("trainer");
+    supported.push_back("chat");
+    supported.push_back("home");
+    supported.push_back("destroy");
+    supported.push_back("reset ai");
+    supported.push_back("emote");
+    supported.push_back("buff");
+    supported.push_back("help");
+    supported.push_back("gb");
+    supported.push_back("bank");
+    supported.push_back("invite");
+    supported.push_back("spell");
+    supported.push_back("rti");
+    supported.push_back("position");
+    supported.push_back("summon");
+    supported.push_back("who");
+    supported.push_back("save mana");
+    supported.push_back("formation");
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
new file mode 100644
index 0000000..c8c93b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class ChatCommandHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        ChatCommandHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "chat"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
new file mode 100644
index 0000000..4ef95b1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CombatStrategy.h"
+
+using namespace ai;
+
+void CombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "invalid target",
+        NextAction::array(0, new NextAction("drop target", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.h b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
new file mode 100644
index 0000000..475922f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class CombatStrategy : public Strategy
+    {
+    public:
+        CombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
new file mode 100644
index 0000000..b1c13fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ConserveManaStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+#include "../values/LastSpellCastValue.h"
+
+using namespace ai;
+
+float ConserveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 health = AI_VALUE2(uint8, "health", "self target");
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    uint8 mana = AI_VALUE2(uint8, "mana", "self target");
+    bool hasMana = AI_VALUE2(bool, "has mana", "self target");
+    bool mediumMana = hasMana && mana < sPlayerbotAIConfig.mediumMana;
+
+    string name = action->getName();
+
+    if (health < sPlayerbotAIConfig.lowHealth)
+        return 1.0f;
+
+    if (name == "melee" || name == "reach melee" || name == "reach spell")
+        return 1.0f;
+
+    if (mediumMana && dynamic_cast<CastBuffSpellAction*>(action))
+        return 0.0f;
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (AI_VALUE(uint8, "balance") <= 50)
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    if (mediumMana && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+float SaveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL)
+        return 1.0f;
+
+    double saveLevel = AI_VALUE(double, "mana save level");
+    if (saveLevel <= 1.0)
+        return 1.0f;
+
+    CastSpellAction* spellAction = dynamic_cast<CastSpellAction*>(action);
+    if (!spellAction)
+        return 1.0f;
+
+    string spell = spellAction->getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo || spellInfo->PowerType != POWER_MANA)
+        return 1.0f;
+
+    int32 cost = spellInfo->ManaCost;
+    if (spellInfo->ManaCostPercentage)
+        cost += spellInfo->ManaCostPercentage * bot->GetCreateMana() / 100;
+
+    uint32 mana = bot->GetMaxPower(POWER_MANA);
+    double percent = (double)cost / (double)mana * 100.0f;
+
+    time_t lastCastTime = AI_VALUE2(time_t, "last spell cast time", spell);
+    if (!lastCastTime)
+        return 1.0f;
+
+    time_t elapsed = time(0) - lastCastTime;
+    if ((double)elapsed < 10 + pow(saveLevel, sqrt(percent)))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+
+void ConserveManaStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ConserveManaMultiplier(ai));
+    multipliers.push_back(new SaveManaMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
new file mode 100644
index 0000000..a206934
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
@@ -0,0 +1,32 @@
+#pragma once
+
+namespace ai
+{
+    class ConserveManaMultiplier : public Multiplier
+    {
+    public:
+        ConserveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "conserve mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class SaveManaMultiplier : public Multiplier
+    {
+    public:
+        SaveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "save mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ConserveManaStrategy : public Strategy
+    {
+    public:
+        ConserveManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "conserve mana"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
new file mode 100644
index 0000000..1c31adb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "DeadStrategy.h"
+
+using namespace ai;
+
+void DeadStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "dead",
+        NextAction::array(0, new NextAction("revive from corpse", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "resurrect request",
+        NextAction::array(0, new NextAction("accept resurrect", relevance), NULL)));
+}
+
+DeadStrategy::DeadStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.h b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
new file mode 100644
index 0000000..4008570
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DeadStrategy : public PassTroughStrategy
+    {
+    public:
+        DeadStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dead"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
new file mode 100644
index 0000000..40fa703
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAoeStrategy.h"
+
+using namespace ai;
+
+void DpsAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
new file mode 100644
index 0000000..61ac9b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
new file mode 100644
index 0000000..c38860d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAssistStrategy.h"
+
+using namespace ai;
+
+void DpsAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
+
+
+
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
new file mode 100644
index 0000000..4368d7b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps assist"; }
+		virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
new file mode 100644
index 0000000..92e9049
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
@@ -0,0 +1,24 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelStrategy.h"
+
+using namespace ai;
+
+void DuelStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "duel requested",
+        NextAction::array(0, new NextAction("accept duel", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack duel opponent", 70.0f), NULL)));
+}
+
+
+
+DuelStrategy::DuelStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.h b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
new file mode 100644
index 0000000..5828406
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DuelStrategy : public PassTroughStrategy
+    {
+    public:
+        DuelStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "duel"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
new file mode 100644
index 0000000..408ecd1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteStrategy.h"
+
+using namespace ai;
+
+
+void EmoteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("emote", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("suggest what to do", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.h b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
new file mode 100644
index 0000000..7acbc70
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class EmoteStrategy : public Strategy
+    {
+    public:
+        EmoteStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "emote"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
new file mode 100644
index 0000000..4b16bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FleeStrategy.h"
+
+using namespace ai;
+
+void FleeStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "panic",
+        NextAction::array(0, new NextAction("flee", ACTION_EMERGENCY + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+       "critical health",
+       NextAction::array(0, new NextAction("flee", ACTION_MOVE + 9), NULL)));
+
+   triggers.push_back(new TriggerNode(
+       "low mana",
+       NextAction::array(0,  new NextAction("flee", ACTION_MOVE + 9), NULL)));}
+
+void FleeFromAddsStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has nearest adds",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.h b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
new file mode 100644
index 0000000..4aa96b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class FleeStrategy : public Strategy
+    {
+    public:
+        FleeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee"; };
+    };
+
+    class FleeFromAddsStrategy : public Strategy
+    {
+    public:
+        FleeFromAddsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee from adds"; };
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
new file mode 100644
index 0000000..753811b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowMasterStrategy.h"
+
+using namespace ai;
+
+NextAction** FollowMasterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("follow", 1.0f), NULL);
+}
+
+void FollowMasterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "out of react range",
+        NextAction::array(0, new NextAction("tell out of react range", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
new file mode 100644
index 0000000..a43e330
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class FollowMasterStrategy : public NonCombatStrategy
+    {
+    public:
+        FollowMasterStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "follow"; }
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
new file mode 100644
index 0000000..259cc96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindingStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GrindingStrategy::getDefaultActions()
+{
+    return NULL;
+}
+
+void GrindingStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no target",
+        NextAction::array(0,
+        new NextAction("attack anything", 5.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.h b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
new file mode 100644
index 0000000..ce42140
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
@@ -0,0 +1,20 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GrindingStrategy : public NonCombatStrategy
+    {
+    public:
+        GrindingStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "grind"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
new file mode 100644
index 0000000..301322c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuardStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GuardStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("guard", 4.0f), NULL);
+}
+
+void GuardStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.h b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
new file mode 100644
index 0000000..8705ba3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
@@ -0,0 +1,19 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GuardStrategy : public NonCombatStrategy
+    {
+    public:
+        GuardStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "guard"; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
new file mode 100644
index 0000000..e329162
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "KiteStrategy.h"
+
+using namespace ai;
+
+KiteStrategy::KiteStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+}
+
+void KiteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has aggro",
+        NextAction::array(0, new NextAction("runaway", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.h b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
new file mode 100644
index 0000000..2436a3d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class KiteStrategy : public Strategy
+    {
+    public:
+        KiteStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "kite"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
new file mode 100644
index 0000000..0701cf5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootNonCombatStrategy.h"
+
+using namespace ai;
+
+void LootNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "loot available",
+        NextAction::array(0, new NextAction("loot", 6.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "far from loot target",
+        NextAction::array(0, new NextAction("move to loot", 7.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "can loot",
+        NextAction::array(0, new NextAction("open loot", 8.0f), NULL)));
+}
+
+void GatherStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("add gathering loot", 2.0f), NULL)));
+}
+
+
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
new file mode 100644
index 0000000..5eecd63
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+    class LootNonCombatStrategy : public Strategy
+    {
+    public:
+        LootNonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "loot"; }
+    };
+
+    class GatherStrategy : public Strategy
+    {
+    public:
+        GatherStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "gather"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
new file mode 100644
index 0000000..6bc8267
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MeleeCombatStrategy.h"
+
+using namespace ai;
+
+
+void MeleeCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
new file mode 100644
index 0000000..eeeb90a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
@@ -0,0 +1,16 @@
+#include "CombatStrategy.h"
+#include "../generic/CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MeleeCombatStrategy : public CombatStrategy
+    {
+    public:
+        MeleeCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
new file mode 100644
index 0000000..5a874b8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatStrategy.h"
+
+using namespace ai;
+
+void NonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("check mount state", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
new file mode 100644
index 0000000..bab0b7d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
@@ -0,0 +1,12 @@
+#pragma once
+
+namespace ai
+{
+    class NonCombatStrategy : public Strategy
+    {
+    public:
+        NonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
new file mode 100644
index 0000000..eddb031
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+    class PassTroughStrategy : public Strategy
+    {
+    public:
+        PassTroughStrategy(PlayerbotAI* ai, float relevance = 100.0f) : Strategy(ai), relevance(relevance) {}
+
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+        {
+            for (list<string>::iterator i = supported.begin(); i != supported.end(); i++)
+            {
+                string s = i->c_str();
+
+                triggers.push_back(new TriggerNode(
+                    s, 
+                    NextAction::array(0, new NextAction(s, relevance), NULL)));
+            }
+        }
+
+    protected:
+        list<string> supported;
+        float relevance;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
new file mode 100644
index 0000000..a4bb3fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PassiveStrategy.h"
+#include "../PassiveMultiplier.h"
+
+using namespace ai;
+
+
+void PassiveStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new PassiveMultiplier(ai));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.h b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
new file mode 100644
index 0000000..8e96388
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class PassiveStrategy : public Strategy
+    {
+    public:
+        PassiveStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "passive"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.cpp b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
new file mode 100644
index 0000000..5d82db3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
@@ -0,0 +1,52 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../PassiveMultiplier.h"
+#include "PullStrategy.h"
+
+using namespace ai;
+
+class MagePullMultiplier : public PassiveMultiplier
+{
+public:
+    MagePullMultiplier(PlayerbotAI* ai, string action) : PassiveMultiplier(ai)
+    {
+        this->action = action;
+    }
+
+public:
+    virtual float GetValue(Action* action);
+
+private:
+    string action;
+};
+
+float MagePullMultiplier::GetValue(Action* action) 
+{
+    if (!action) 
+        return 1.0f;
+
+    string name = action->getName();
+    if (this->action == name ||
+        name == "reach spell" ||
+        name == "change strategy")
+        return 1.0f;
+
+    return PassiveMultiplier::GetValue(action);
+}
+
+NextAction** PullStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction(action, 105.0f), new NextAction("follow", 104.0f), new NextAction("end pull", 103.0f), NULL);
+}
+
+void PullStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+}
+
+void PullStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new MagePullMultiplier(ai, action));
+    RangedCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.h b/src/plugins/playerbot/strategy/generic/PullStrategy.h
new file mode 100644
index 0000000..b19210a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "RangedCombatStrategy.h"
+
+namespace ai
+{
+    class PullStrategy : public RangedCombatStrategy
+    {
+    public:
+        PullStrategy(PlayerbotAI* ai, string action) : RangedCombatStrategy(ai) 
+        {
+            this->action = action;
+        }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "pull"; }
+        virtual NextAction** getDefaultActions();
+
+    private:
+        string action;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
new file mode 100644
index 0000000..62b3e43
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
@@ -0,0 +1,69 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestStrategies.h"
+
+using namespace ai;
+
+QuestStrategy::QuestStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("accept quest");
+}
+
+void QuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "quest share",
+        NextAction::array(0, new NextAction("accept quest share", relevance), NULL)));
+}
+
+
+void DefaultQuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, new NextAction("talk to quest giver", relevance), NULL)));
+}
+
+DefaultQuestStrategy::DefaultQuestStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
+
+
+
+void AcceptAllQuestsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, 
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+}
+
+AcceptAllQuestsStrategy::AcceptAllQuestsStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.h b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
new file mode 100644
index 0000000..08423dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class QuestStrategy : public PassTroughStrategy
+    {
+    public:
+        QuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class DefaultQuestStrategy : public QuestStrategy
+    {
+    public:
+        DefaultQuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "quest"; }
+    };
+
+    class AcceptAllQuestsStrategy : public QuestStrategy
+    {
+    public:
+        AcceptAllQuestsStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "accept all quests"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
new file mode 100644
index 0000000..58fa904
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
@@ -0,0 +1,39 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RacialsStrategy.h"
+
+using namespace ai;
+
+
+class RacialsStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    RacialsStrategyActionNodeFactory()
+    {
+        creators["lifeblood"] = &lifeblood;
+    }
+private:
+    static ActionNode* lifeblood(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lifeblood",  
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("gift of the naaru"), NULL), 
+            /*C*/ NULL);
+    }
+};
+
+void RacialsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"low health", 
+		NextAction::array(0, new NextAction("lifeblood", 71.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana", 
+        NextAction::array(0, new NextAction("arcane torrent", ACTION_EMERGENCY + 6), NULL)));
+}
+
+RacialsStrategy::RacialsStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+    actionNodeFactories.Add(new RacialsStrategyActionNodeFactory());
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.h b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
new file mode 100644
index 0000000..6802178
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class RacialsStrategy : public Strategy
+    {
+    public:
+        RacialsStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "racials"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
new file mode 100644
index 0000000..9fd6ad9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RangedCombatStrategy.h"
+
+using namespace ai;
+
+
+void RangedCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
new file mode 100644
index 0000000..a00cbc1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
@@ -0,0 +1,15 @@
+#include "CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RangedCombatStrategy : public CombatStrategy
+    {
+    public:
+        RangedCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_RANGED; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
new file mode 100644
index 0000000..5ac877b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RunawayStrategy.h"
+
+using namespace ai;
+
+
+NextAction** RunawayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("runaway", 50.0f), NULL);
+}
+
+void RunawayStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.h b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
new file mode 100644
index 0000000..d1c3ef5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RunawayStrategy : public NonCombatStrategy
+       {
+       public:
+           RunawayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+           virtual string getName() { return "runaway"; }
+           virtual NextAction** getDefaultActions();
+           virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+       };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.cpp b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
new file mode 100644
index 0000000..f8cbf96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayStrategy.h"
+
+using namespace ai;
+
+NextAction** StayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stay", 1.0f), NULL);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.h b/src/plugins/playerbot/strategy/generic/StayStrategy.h
new file mode 100644
index 0000000..d9f4229
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.h
@@ -0,0 +1,14 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class StayStrategy : public NonCombatStrategy
+    {
+    public:
+        StayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "stay"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
new file mode 100644
index 0000000..29afdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAoeStrategy.h"
+
+using namespace ai;
+
+void TankAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "tank aoe",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
new file mode 100644
index 0000000..f9ed2fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
new file mode 100644
index 0000000..d54b8ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAssistStrategy.h"
+
+using namespace ai;
+
+
+void TankAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
new file mode 100644
index 0000000..3ecbbb9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
@@ -0,0 +1,17 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank assist"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
new file mode 100644
index 0000000..ce1340d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetStrategy.h"
+
+using namespace ai;
+
+
+void TellTargetStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "target changed",
+        NextAction::array(0, new NextAction("tell target", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
new file mode 100644
index 0000000..22b2e2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class TellTargetStrategy : public Strategy
+    {
+    public:
+        TellTargetStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "TellTarget"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
new file mode 100644
index 0000000..155dc24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float ThreatMultiplier::GetValue(Action* action)
+{
+    if (action == NULL || action->getThreatType() == ACTION_THREAT_NONE)
+        return 1.0f;
+
+    if (action->getThreatType() == ACTION_THREAT_AOE)
+    {
+        uint8 threat = AI_VALUE2(uint8, "threat", "aoe");
+        if (threat >= 90)
+            return 0.0f;
+    }
+
+    uint8 threat = AI_VALUE2(uint8, "threat", "current target");
+
+    if (threat >= 90)
+        return 0.0f;
+
+    return 1.0f;
+}
+
+void ThreatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ThreatMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.h b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
new file mode 100644
index 0000000..406f433
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+
+namespace ai
+{
+    class ThreatMultiplier : public Multiplier
+    {
+    public:
+        ThreatMultiplier(PlayerbotAI* ai) : Multiplier(ai, "threat") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ThreatStrategy : public Strategy
+    {
+    public:
+        ThreatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "threat"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
new file mode 100644
index 0000000..b141a46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseFoodStrategy.h"
+
+using namespace ai;
+
+void UseFoodStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("food", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("drink", 2.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
new file mode 100644
index 0000000..b68ab35
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UseFoodStrategy : public Strategy
+    {
+    public:
+        UseFoodStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "food"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
new file mode 100644
index 0000000..09616bb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UsePotionsStrategy.h"
+
+using namespace ai;
+
+void UsePotionsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing potion", ACTION_MEDIUM_HEAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0,  new NextAction("mana potion", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
new file mode 100644
index 0000000..b48f89f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UsePotionsStrategy : public Strategy
+    {
+    public:
+        UsePotionsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "potions"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
new file mode 100644
index 0000000..83fbb52
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
@@ -0,0 +1,116 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WorldPacketHandlerStrategy.h"
+
+using namespace ai;
+
+void WorldPacketHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "group invite",
+        NextAction::array(0, new NextAction("accept invitation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "group set leader",
+        NextAction::array(0, new NextAction("leader", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough money",
+        NextAction::array(0, new NextAction("tell not enough money", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough reputation",
+        NextAction::array(0, new NextAction("tell not enough reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cannot equip",
+        NextAction::array(0, new NextAction("tell cannot equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("add loot", relevance),
+            new NextAction("use meeting stone", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("trainer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "activate taxi",
+        NextAction::array(0, new NextAction("remember taxi", relevance), new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "taxi done",
+        NextAction::array(0, new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "trade status",
+        NextAction::array(0, new NextAction("accept trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "area trigger",
+        NextAction::array(0, new NextAction("reach area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "within area trigger",
+        NextAction::array(0, new NextAction("area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "loot response",
+        NextAction::array(0, new NextAction("store loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "item push result",
+        NextAction::array(0, new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ready check finished",
+        NextAction::array(0, new NextAction("finish ready check", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("lfg join", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("lfg leave", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal",
+        NextAction::array(0, new NextAction("lfg accept", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal active",
+        NextAction::array(0, new NextAction("lfg accept", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "often",
+        NextAction::array(0, new NextAction("security check", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "guild invite",
+        NextAction::array(0, new NextAction("guild accept", relevance), NULL)));
+}
+
+WorldPacketHandlerStrategy::WorldPacketHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("loot roll");
+    supported.push_back("check mount state");
+    supported.push_back("quest objective completed");
+    supported.push_back("party command");
+    supported.push_back("ready check");
+    supported.push_back("uninvite");
+    supported.push_back("lfg role check");
+}
+
+
+void ReadyCheckStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("ready check", relevance), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
new file mode 100644
index 0000000..6a5a44d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class WorldPacketHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        WorldPacketHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "default"; }
+    };
+
+    class ReadyCheckStrategy : public PassTroughStrategy
+    {
+    public:
+        ReadyCheckStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "ready check"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
new file mode 100644
index 0000000..bb6c477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+
+#include "HunterMultipliers.h"
+#include "DpsHunterStrategy.h"
+
+using namespace ai;
+
+class DpsHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsHunterStrategyActionNodeFactory()
+    {
+        creators["aimed shot"] = &aimed_shot;
+        creators["chimera shot"] = &chimera_shot;
+        creators["explosive shot"] = &explosive_shot;
+        creators["concussive shot"] = &concussive_shot;
+        creators["viper sting"] = &viper_sting;
+    }
+private:
+    static ActionNode* viper_sting(PlayerbotAI* ai)
+    {
+        return new ActionNode ("viper sting",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aimed_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aimed shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("chimera shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chimera_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chimera shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* explosive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("explosive shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aimed shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* concussive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("concussive shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("wyvern sting", 11.0f), NULL));
+    }
+
+};
+
+DpsHunterStrategy::DpsHunterStrategy(PlayerbotAI* ai) : GenericHunterStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsHunterStrategyActionNodeFactory());
+}
+
+NextAction** DpsHunterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("explosive shot", 11.0f), new NextAction("auto shot", 10.0f), NULL);
+}
+
+void DpsHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericHunterStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "black arrow",
+        NextAction::array(0, new NextAction("black arrow", 51.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("viper sting", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunter's mark",
+        NextAction::array(0, new NextAction("hunter's mark", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "freezing trap",
+        NextAction::array(0, new NextAction("freezing trap", 83.0f), NULL)));
+}
+
+void DpsAoeHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("multi-shot", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("volley", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"serpent sting on attacker",
+		NextAction::array(0, new NextAction("serpent sting on attacker", 49.0f), NULL)));
+}
+
+void DpsHunterDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no stings",
+        NextAction::array(0, new NextAction("serpent sting", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
new file mode 100644
index 0000000..4992e0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsHunterStrategy : public GenericHunterStrategy
+    {
+    public:
+        DpsHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+
+    };
+
+    class DpsAoeHunterStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeHunterStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsHunterDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsHunterDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
new file mode 100644
index 0000000..6fab572
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "GenericHunterNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericHunterNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterNonCombatStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterNonCombatStrategy::GenericHunterNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterNonCombatStrategyActionNodeFactory());
+}
+
+void GenericHunterNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "trueshot aura",
+        NextAction::array(0, new NextAction("trueshot aura", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet dead",
+        NextAction::array(0, new NextAction("revive pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
new file mode 100644
index 0000000..d01486d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericHunterNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericHunterNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
new file mode 100644
index 0000000..e4c5d45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericHunterStrategy.h"
+#include "HunterAiObjectContext.h"
+
+using namespace ai;
+
+class GenericHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+        creators["feign death"] = &feign_death;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* feign_death(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feign death",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterStrategy::GenericHunterStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterStrategyActionNodeFactory());
+}
+
+void GenericHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("wing clip", 50.0f), new NextAction("flee",49.0f), new NextAction("concussive shot", 48.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("feign death", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rapid fire",
+        NextAction::array(0, new NextAction("rapid fire", 55.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
new file mode 100644
index 0000000..f2db28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericHunterStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "hunter"; }
+    };
+}
+
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.cpp b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
new file mode 100644
index 0000000..bdf6761
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../actions/GenericActions.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool CastSerpentStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "health", "current target") > 50;
+}
+
+bool CastViperStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "mana", "self target") < 50 && AI_VALUE2(uint8, "mana", "current target") >= 30;
+}
+
+bool CastAspectOfTheCheetahAction::isUseful() 
+{
+    return !ai->HasAnyAuraOf(GetTarget(), "aspect of the cheetah", "aspect of the pack", NULL);
+}
+
+Value<Unit*>* CastFreezingTrap::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "freezing trap");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.h b/src/plugins/playerbot/strategy/hunter/HunterActions.h
new file mode 100644
index 0000000..74611ce
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.h
@@ -0,0 +1,154 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    BEGIN_RANGED_SPELL_ACTION(CastHuntersMarkAction, "hunter's mark")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastAutoShotAction, "auto shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastArcaneShotAction, "arcane shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastExplosiveShotAction, "explosive shot")
+    END_SPELL_ACTION()
+
+
+    BEGIN_RANGED_SPELL_ACTION(CastAimedShotAction, "aimed shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastChimeraShotAction, "chimera shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastConcussiveShotAction, "concussive shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastDistractingShotAction, "distracting shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMultiShotAction, "multi-shot")
+    END_SPELL_ACTION()
+
+	BEGIN_RANGED_SPELL_ACTION(CastVolleyAction, "volley")
+	END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSerpentStingAction, "serpent sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastWyvernStingAction, "wyvern sting")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastViperStingAction, "viper sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastScorpidStingAction, "scorpid sting")
+    END_SPELL_ACTION()
+
+	class CastAspectOfTheHawkAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheHawkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the hawk") {}
+	};
+
+	class CastAspectOfTheWildAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the wild") {}
+	};
+
+	class CastAspectOfTheCheetahAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheCheetahAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the cheetah") {}
+		virtual bool isUseful();
+	};
+
+	class CastAspectOfThePackAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfThePackAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the pack") {}
+	};
+
+	class CastAspectOfTheViperAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheViperAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the viper") {}
+	};
+
+	class CastCallPetAction : public CastBuffSpellAction
+	{
+	public:
+		CastCallPetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "call pet") {}
+	};
+
+	class CastMendPetAction : public CastAuraSpellAction
+	{
+	public:
+		CastMendPetAction(PlayerbotAI* ai) : CastAuraSpellAction(ai, "mend pet") {}
+		virtual string GetTargetName() { return "pet target"; }
+	};
+
+	class CastRevivePetAction : public CastBuffSpellAction
+	{
+	public:
+		CastRevivePetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "revive pet") {}
+	};
+
+    class CastTrueshotAuraAction : public CastBuffSpellAction
+    {
+    public:
+        CastTrueshotAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "trueshot aura") {}
+    };
+
+    class CastFeignDeathAction : public CastBuffSpellAction
+    {
+    public:
+        CastFeignDeathAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feign death") {}
+    };
+
+	class CastRapidFireAction : public CastBuffSpellAction
+	{
+	public:
+		CastRapidFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "rapid fire") {}
+	};
+
+	class CastReadinessAction : public CastBuffSpellAction
+	{
+	public:
+		CastReadinessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "readiness") {}
+	};
+
+	class CastBlackArrow : public CastDebuffSpellAction
+	{
+	public:
+		CastBlackArrow(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "black arrow") {}
+	};
+
+    class CastFreezingTrap : public CastDebuffSpellAction
+    {
+    public:
+        CastFreezingTrap(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "freezing trap") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+    class CastWingClipAction : public CastMeleeSpellAction
+    {
+    public:
+        CastWingClipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "wing clip") {}
+        virtual bool isUseful()
+        {
+            return CastMeleeSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class CastSerpentStingOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastSerpentStingOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
new file mode 100644
index 0000000..dd62523
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
@@ -0,0 +1,191 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterActions.h"
+#include "HunterTriggers.h"
+#include "HunterAiObjectContext.h"
+#include "DpsHunterStrategy.h"
+#include "GenericHunterNonCombatStrategy.h"
+#include "HunterBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &hunter::StrategyFactoryInternal::dps;
+                creators["nc"] = &hunter::StrategyFactoryInternal::nc;
+                creators["aoe"] = &hunter::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &hunter::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeHunterStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsHunterStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericHunterNonCombatStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsHunterDebuffStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bspeed"] = &hunter::BuffStrategyFactoryInternal::bspeed;
+                creators["bdps"] = &hunter::BuffStrategyFactoryInternal::bdps;
+                creators["bmana"] = &hunter::BuffStrategyFactoryInternal::bmana;
+                creators["rnature"] = &hunter::BuffStrategyFactoryInternal::rnature;
+            }
+
+        private:
+            static Strategy* bspeed(PlayerbotAI* ai) { return new HunterBuffSpeedStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new HunterBuffDpsStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new HunterBuffManaStrategy(ai); }
+            static Strategy* rnature(PlayerbotAI* ai) { return new HunterNatureResistanceStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["black arrow"] = &TriggerFactoryInternal::black_arrow;
+                creators["no stings"] = &TriggerFactoryInternal::NoStings;
+                creators["hunters pet dead"] = &TriggerFactoryInternal::hunters_pet_dead;
+                creators["hunters pet low health"] = &TriggerFactoryInternal::hunters_pet_low_health;
+                creators["hunter's mark"] = &TriggerFactoryInternal::hunters_mark;
+                creators["freezing trap"] = &TriggerFactoryInternal::freezing_trap;
+                creators["aspect of the pack"] = &TriggerFactoryInternal::aspect_of_the_pack;
+                creators["rapid fire"] = &TriggerFactoryInternal::rapid_fire;
+                creators["aspect of the hawk"] = &TriggerFactoryInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &TriggerFactoryInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["trueshot aura"] = &TriggerFactoryInternal::trueshot_aura;
+                creators["serpent sting on attacker"] = &TriggerFactoryInternal::serpent_sting_on_attacker;
+            }
+
+        private:
+            static Trigger* serpent_sting_on_attacker(PlayerbotAI* ai) { return new SerpentStingOnAttackerTrigger(ai); }
+            static Trigger* trueshot_aura(PlayerbotAI* ai) { return new TrueshotAuraTrigger(ai); }
+            static Trigger* aspect_of_the_viper(PlayerbotAI* ai) { return new HunterAspectOfTheViperTrigger(ai); }
+            static Trigger* black_arrow(PlayerbotAI* ai) { return new BlackArrowTrigger(ai); }
+            static Trigger* NoStings(PlayerbotAI* ai) { return new HunterNoStingsActiveTrigger(ai); }
+            static Trigger* hunters_pet_dead(PlayerbotAI* ai) { return new HuntersPetDeadTrigger(ai); }
+            static Trigger* hunters_pet_low_health(PlayerbotAI* ai) { return new HuntersPetLowHealthTrigger(ai); }
+            static Trigger* hunters_mark(PlayerbotAI* ai) { return new HuntersMarkTrigger(ai); }
+            static Trigger* freezing_trap(PlayerbotAI* ai) { return new FreezingTrapTrigger(ai); }
+            static Trigger* aspect_of_the_pack(PlayerbotAI* ai) { return new HunterAspectOfThePackTrigger(ai); }
+            static Trigger* rapid_fire(PlayerbotAI* ai) { return new RapidFireTrigger(ai); }
+            static Trigger* aspect_of_the_hawk(PlayerbotAI* ai) { return new HunterAspectOfTheHawkTrigger(ai); }
+            static Trigger* aspect_of_the_wild(PlayerbotAI* ai) { return new HunterAspectOfTheWildTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["auto shot"] = &AiObjectContextInternal::auto_shot;
+                creators["aimed shot"] = &AiObjectContextInternal::aimed_shot;
+                creators["chimera shot"] = &AiObjectContextInternal::chimera_shot;
+                creators["explosive shot"] = &AiObjectContextInternal::explosive_shot;
+                creators["arcane shot"] = &AiObjectContextInternal::arcane_shot;
+                creators["concussive shot"] = &AiObjectContextInternal::concussive_shot;
+                creators["distracting shot"] = &AiObjectContextInternal::distracting_shot;
+                creators["multi-shot"] = &AiObjectContextInternal::multi_shot;
+                creators["volley"] = &AiObjectContextInternal::volley;
+                creators["serpent sting"] = &AiObjectContextInternal::serpent_sting;
+                creators["serpent sting on attacker"] = &AiObjectContextInternal::serpent_sting_on_attacker;
+                creators["wyvern sting"] = &AiObjectContextInternal::wyvern_sting;
+                creators["viper sting"] = &AiObjectContextInternal::viper_sting;
+                creators["scorpid sting"] = &AiObjectContextInternal::scorpid_sting;
+                creators["hunter's mark"] = &AiObjectContextInternal::hunters_mark;
+                creators["mend pet"] = &AiObjectContextInternal::mend_pet;
+                creators["revive pet"] = &AiObjectContextInternal::revive_pet;
+                creators["call pet"] = &AiObjectContextInternal::call_pet;
+                creators["black arrow"] = &AiObjectContextInternal::black_arrow;
+                creators["freezing trap"] = &AiObjectContextInternal::freezing_trap;
+                creators["rapid fire"] = &AiObjectContextInternal::rapid_fire;
+                creators["boost"] = &AiObjectContextInternal::rapid_fire;
+                creators["readiness"] = &AiObjectContextInternal::readiness;
+                creators["aspect of the hawk"] = &AiObjectContextInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &AiObjectContextInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &AiObjectContextInternal::aspect_of_the_viper;
+                creators["aspect of the pack"] = &AiObjectContextInternal::aspect_of_the_pack;
+                creators["aspect of the cheetah"] = &AiObjectContextInternal::aspect_of_the_cheetah;
+                creators["trueshot aura"] = &AiObjectContextInternal::trueshot_aura;
+                creators["feign death"] = &AiObjectContextInternal::feign_death;
+                creators["wing clip"] = &AiObjectContextInternal::wing_clip;
+            }
+
+        private:
+            static Action* feign_death(PlayerbotAI* ai) { return new CastFeignDeathAction(ai); }
+            static Action* trueshot_aura(PlayerbotAI* ai) { return new CastTrueshotAuraAction(ai); }
+            static Action* auto_shot(PlayerbotAI* ai) { return new CastAutoShotAction(ai); }
+            static Action* aimed_shot(PlayerbotAI* ai) { return new CastAimedShotAction(ai); }
+            static Action* chimera_shot(PlayerbotAI* ai) { return new CastChimeraShotAction(ai); }
+            static Action* explosive_shot(PlayerbotAI* ai) { return new CastExplosiveShotAction(ai); }
+            static Action* arcane_shot(PlayerbotAI* ai) { return new CastArcaneShotAction(ai); }
+            static Action* concussive_shot(PlayerbotAI* ai) { return new CastConcussiveShotAction(ai); }
+            static Action* distracting_shot(PlayerbotAI* ai) { return new CastDistractingShotAction(ai); }
+            static Action* multi_shot(PlayerbotAI* ai) { return new CastMultiShotAction(ai); }
+            static Action* volley(PlayerbotAI* ai) { return new CastVolleyAction(ai); }
+            static Action* serpent_sting(PlayerbotAI* ai) { return new CastSerpentStingAction(ai); }
+            static Action* serpent_sting_on_attacker(PlayerbotAI* ai) { return new CastSerpentStingOnAttackerAction(ai); }
+            static Action* wyvern_sting(PlayerbotAI* ai) { return new CastWyvernStingAction(ai); }
+            static Action* viper_sting(PlayerbotAI* ai) { return new CastViperStingAction(ai); }
+            static Action* scorpid_sting(PlayerbotAI* ai) { return new CastScorpidStingAction(ai); }
+            static Action* hunters_mark(PlayerbotAI* ai) { return new CastHuntersMarkAction(ai); }
+            static Action* mend_pet(PlayerbotAI* ai) { return new CastMendPetAction(ai); }
+            static Action* revive_pet(PlayerbotAI* ai) { return new CastRevivePetAction(ai); }
+            static Action* call_pet(PlayerbotAI* ai) { return new CastCallPetAction(ai); }
+            static Action* black_arrow(PlayerbotAI* ai) { return new CastBlackArrow(ai); }
+            static Action* freezing_trap(PlayerbotAI* ai) { return new CastFreezingTrap(ai); }
+            static Action* rapid_fire(PlayerbotAI* ai) { return new CastRapidFireAction(ai); }
+            static Action* readiness(PlayerbotAI* ai) { return new CastReadinessAction(ai); }
+            static Action* aspect_of_the_hawk(PlayerbotAI* ai) { return new CastAspectOfTheHawkAction(ai); }
+            static Action* aspect_of_the_wild(PlayerbotAI* ai) { return new CastAspectOfTheWildAction(ai); }
+            static Action* aspect_of_the_viper(PlayerbotAI* ai) { return new CastAspectOfTheViperAction(ai); }
+            static Action* aspect_of_the_pack(PlayerbotAI* ai) { return new CastAspectOfThePackAction(ai); }
+            static Action* aspect_of_the_cheetah(PlayerbotAI* ai) { return new CastAspectOfTheCheetahAction(ai); }
+            static Action* wing_clip(PlayerbotAI* ai) { return new CastWingClipAction(ai); }
+        };
+    };
+};
+
+HunterAiObjectContext::HunterAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::hunter::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::hunter::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::hunter::AiObjectContextInternal());
+    triggerContexts.Add(new ai::hunter::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
new file mode 100644
index 0000000..8891a54
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class HunterAiObjectContext : public AiObjectContext
+    {
+    public:
+        HunterAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
new file mode 100644
index 0000000..33f7612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "HunterBuffStrategies.h"
+
+using namespace ai;
+
+void HunterBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the hawk", 
+		NextAction::array(0, new NextAction("aspect of the hawk", 90.0f), NULL)));
+}
+
+void HunterNatureResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the wild", 
+		NextAction::array(0, new NextAction("aspect of the wild", 90.0f), NULL)));
+}
+
+
+void HunterBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the pack",
+        NextAction::array(0, new NextAction("aspect of the pack", 10.0f), NULL)));
+}
+
+void HunterBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the viper",
+        NextAction::array(0, new NextAction("aspect of the viper", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
new file mode 100644
index 0000000..d59f245
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class HunterBuffSpeedStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffSpeedStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bspeed"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class HunterBuffManaStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffManaStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bmana"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+	class HunterBuffDpsStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterBuffDpsStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "bdps"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+
+	class HunterNatureResistanceStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterNatureResistanceStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "rnature"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
new file mode 100644
index 0000000..9d0bdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
new file mode 100644
index 0000000..c356a0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterTriggers.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool HunterNoStingsActiveTrigger::IsActive()
+{
+	Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(uint8, "health", "current target") > 40 &&
+        !ai->HasAura("serpent sting", target) &&
+        !ai->HasAura("scorpid sting", target) &&
+        !ai->HasAura("viper sting", target);
+}
+
+bool HuntersPetDeadTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
+
+
+bool HuntersPetLowHealthTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(uint8, "health", "pet target") < 40 &&
+        !AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.h b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
new file mode 100644
index 0000000..9466218
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BEGIN_TRIGGER(HunterNoStingsActiveTrigger, Trigger)
+    END_TRIGGER()
+
+    class HunterAspectOfTheHawkTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheHawkTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the hawk") {
+			checkInterval = 1;
+		}
+    };
+
+	class HunterAspectOfTheWildTrigger : public BuffTrigger
+	{
+	public:
+		HunterAspectOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the wild") {
+			checkInterval = 1;
+		}
+	};
+
+    class HunterAspectOfTheViperTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheViperTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the viper") {}
+        virtual bool IsActive()
+        {
+            return SpellTrigger::IsActive() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class HunterAspectOfThePackTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfThePackTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the pack") {}
+        virtual bool IsActive() {
+			return BuffTrigger::IsActive() && !ai->HasAura("aspect of the cheetah", GetTarget());
+        };
+    };
+
+    BEGIN_TRIGGER(HuntersPetDeadTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(HuntersPetLowHealthTrigger, Trigger)
+    END_TRIGGER()
+
+    class BlackArrowTrigger : public DebuffTrigger
+    {
+    public:
+        BlackArrowTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "black arrow") {}
+    };
+
+    class HuntersMarkTrigger : public DebuffTrigger
+    {
+    public:
+        HuntersMarkTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "hunter's mark") {}
+    };
+
+    class FreezingTrapTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FreezingTrapTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "freezing trap") {}
+    };
+
+    class RapidFireTrigger : public BoostTrigger
+    {
+    public:
+        RapidFireTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "rapid fire") {}
+    };
+
+    class TrueshotAuraTrigger : public BuffTrigger
+    {
+    public:
+        TrueshotAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "trueshot aura") {}
+    };
+
+    class SerpentStingOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        SerpentStingOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
new file mode 100644
index 0000000..0779477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
@@ -0,0 +1,64 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "ArcaneMageStrategy.h"
+
+using namespace ai;
+
+class ArcaneMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    ArcaneMageStrategyActionNodeFactory()
+    {
+        creators["arcane blast"] = &arcane_blast;
+        creators["arcane barrage"] = &arcane_barrage;
+        creators["arcane missiles"] = &arcane_missiles;
+    }
+private:
+    static ActionNode* arcane_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_barrage(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane barrage",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_missiles(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane missiles",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+ArcaneMageStrategy::ArcaneMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+    actionNodeFactories.Add(new ArcaneMageStrategyActionNodeFactory());
+}
+
+NextAction** ArcaneMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("arcane barrage", 10.0f), NULL);
+}
+
+void ArcaneMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane blast",
+        NextAction::array(0, new NextAction("arcane blast", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "missile barrage",
+        NextAction::array(0, new NextAction("arcane missiles", 15.0f), NULL)));
+
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
new file mode 100644
index 0000000..ac053a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+
+namespace ai
+{
+    class ArcaneMageStrategy : public GenericMageStrategy
+    {
+    public:
+        ArcaneMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "arcane"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
new file mode 100644
index 0000000..47c4bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FireMageStrategy.h"
+
+using namespace ai;
+
+NextAction** FireMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("scorch", 7.0f), new NextAction("fireball", 6.0f), new NextAction("fire blast", 5.0f), NULL);
+}
+
+void FireMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "pyroblast",
+        NextAction::array(0, new NextAction("pyroblast", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hot streak",
+        NextAction::array(0, new NextAction("pyroblast", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combustion",
+        NextAction::array(0, new NextAction("combustion", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("dragon's breath", 70.0f), NULL)));
+}
+
+void FireMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flamestrike", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "living bomb",
+        NextAction::array(0, new NextAction("living bomb", 25.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.h b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
new file mode 100644
index 0000000..fc0cd7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FireMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FireMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FireMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FireMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
new file mode 100644
index 0000000..e6fb861
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FrostMageStrategy.h"
+
+using namespace ai;
+
+
+FrostMageStrategy::FrostMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+}
+
+NextAction** FrostMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("frostbolt", 7.0f), NULL);
+}
+
+void FrostMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "icy veins",
+        NextAction::array(0, new NextAction("icy veins", 50.0f), NULL)));
+}
+
+void FrostMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("blizzard", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
new file mode 100644
index 0000000..15fac2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FrostMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FrostMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FrostMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FrostMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
new file mode 100644
index 0000000..f4111de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
@@ -0,0 +1,87 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericMageNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageNonCombatStrategyActionNodeFactory()
+    {
+        creators["molten armor"] = &molten_armor;
+        creators["mage armor"] = &mage_armor;
+        creators["ice armor"] = &ice_armor;
+    }
+private:
+    static ActionNode* molten_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("molten armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mage armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mage_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mage armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("ice armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* ice_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ice armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost armor"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericMageNonCombatStrategy::GenericMageNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageNonCombatStrategyActionNodeFactory());
+}
+
+void GenericMageNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect",
+        NextAction::array(0, new NextAction("arcane intellect", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect on party",
+        NextAction::array(0, new NextAction("arcane intellect on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no drink",
+		NextAction::array(0, new NextAction("conjure water", 16.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no food",
+		NextAction::array(0, new NextAction("conjure food", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+}
+
+void MageBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("mage armor", 19.0f), NULL)));
+}
+
+void MageBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("molten armor", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
new file mode 100644
index 0000000..5319bf9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericMageNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class MageBuffManaStrategy : public Strategy
+    {
+    public:
+        MageBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class MageBuffDpsStrategy : public Strategy
+    {
+    public:
+        MageBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
new file mode 100644
index 0000000..7f137c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageStrategy.h"
+
+using namespace ai;
+
+class GenericMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageStrategyActionNodeFactory()
+    {
+        creators["frostbolt"] = &frostbolt;
+        creators["fire blast"] = &fire_blast;
+        creators["scorch"] = &scorch;
+        creators["frost nova"] = &frost_nova;
+        creators["icy veins"] = &icy_veins;
+        creators["combustion"] = &combustion;
+        creators["evocation"] = &evocation;
+        creators["dragon's breath"] = &dragons_breath;
+        creators["blast wave"] = &blast_wave;
+    }
+private:
+    static ActionNode* frostbolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* fire_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fire blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("scorch"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* scorch(PlayerbotAI* ai)
+    {
+        return new ActionNode ("scorch",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frost_nova(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frost nova",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee"), NULL));
+    }
+    static ActionNode* icy_veins(PlayerbotAI* ai)
+    {
+        return new ActionNode ("icy veins",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* combustion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("combustion",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* evocation(PlayerbotAI* ai)
+    {
+        return new ActionNode ("evocation",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* dragons_breath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dragon's breath",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blast wave"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+    static ActionNode* blast_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blast wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost nova"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+};
+
+GenericMageStrategy::GenericMageStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageStrategyActionNodeFactory());
+}
+
+void GenericMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("frost nova", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell",
+        NextAction::array(0, new NextAction("counterspell", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell on enemy healer",
+        NextAction::array(0, new NextAction("counterspell on enemy healer", 40.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("ice block", 80.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "polymorph",
+        NextAction::array(0, new NextAction("polymorph", 30.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"spellsteal",
+		NextAction::array(0, new NextAction("spellsteal", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("invisibility", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("evocation", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
new file mode 100644
index 0000000..4dcb9d9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericMageStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "mage"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.cpp b/src/plugins/playerbot/strategy/mage/MageActions.cpp
new file mode 100644
index 0000000..ee4d6fc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+Value<Unit*>* CastPolymorphAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", getName());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.h b/src/plugins/playerbot/strategy/mage/MageActions.h
new file mode 100644
index 0000000..ea541a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastFireballAction : public CastSpellAction
+    {
+    public:
+        CastFireballAction(PlayerbotAI* ai) : CastSpellAction(ai, "fireball") {}
+    };
+
+    class CastScorchAction : public CastSpellAction
+    {
+    public:
+        CastScorchAction(PlayerbotAI* ai) : CastSpellAction(ai, "scorch") {}
+    };
+
+    class CastFireBlastAction : public CastSpellAction
+    {
+    public:
+        CastFireBlastAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire blast") {}
+    };
+
+    class CastArcaneBlastAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneBlastAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane blast") {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class CastArcaneBarrageAction : public CastSpellAction
+    {
+    public:
+        CastArcaneBarrageAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane barrage") {}
+    };
+
+    class CastArcaneMissilesAction : public CastSpellAction
+    {
+    public:
+        CastArcaneMissilesAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane missiles") {}
+    };
+
+    class CastPyroblastAction : public CastSpellAction
+    {
+    public:
+        CastPyroblastAction(PlayerbotAI* ai) : CastSpellAction(ai, "pyroblast") {}
+    };
+
+    class CastFlamestrikeAction : public CastSpellAction
+    {
+    public:
+        CastFlamestrikeAction(PlayerbotAI* ai) : CastSpellAction(ai, "flamestrike") {}
+    };
+
+    class CastFrostNovaAction : public CastSpellAction
+    {
+    public:
+        CastFrostNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "frost nova") {}
+        virtual bool isUseful() { return AI_VALUE2(float, "distance", GetTargetName()) <= sPlayerbotAIConfig.tooCloseDistance; }
+    };
+
+	class CastFrostboltAction : public CastSpellAction
+	{
+	public:
+		CastFrostboltAction(PlayerbotAI* ai) : CastSpellAction(ai, "frostbolt") {}
+	};
+
+	class CastBlizzardAction : public CastSpellAction
+	{
+	public:
+		CastBlizzardAction(PlayerbotAI* ai) : CastSpellAction(ai, "blizzard") {}
+	};
+
+	class CastArcaneIntellectAction : public CastBuffSpellAction
+    {
+	public:
+		CastArcaneIntellectAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane intellect") {}
+	};
+
+	class CastArcaneIntellectOnPartyAction : public BuffOnPartyAction
+    {
+	public:
+		CastArcaneIntellectOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "arcane intellect") {}
+	};
+
+	class CastRemoveCurseAction : public CastCureSpellAction
+    {
+	public:
+		CastRemoveCurseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "remove curse") {}
+	};
+
+	class CastIcyVeinsAction : public CastBuffSpellAction
+    {
+	public:
+		CastIcyVeinsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "icy veins") {}
+	};
+
+	class CastCombustionAction : public CastBuffSpellAction
+    {
+	public:
+		CastCombustionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "combustion") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastCounterspellAction, "counterspell")
+    END_SPELL_ACTION()
+
+    class CastRemoveCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastRemoveCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+	class CastConjureFoodAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureFoodAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure food") {}
+	};
+
+	class CastConjureWaterAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureWaterAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure water") {}
+	};
+
+	class CastIceBlockAction : public CastBuffSpellAction
+    {
+	public:
+		CastIceBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice block") {}
+	};
+
+    class CastMoltenArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMoltenArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "molten armor") {}
+    };
+
+    class CastMageArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMageArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mage armor") {}
+    };
+
+    class CastIceArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastIceArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice armor") {}
+    };
+
+    class CastFrostArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastFrostArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost armor") {}
+    };
+
+    class CastPolymorphAction : public CastBuffSpellAction
+    {
+    public:
+        CastPolymorphAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "polymorph") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+	class CastSpellstealAction : public CastSpellAction
+	{
+	public:
+		CastSpellstealAction(PlayerbotAI* ai) : CastSpellAction(ai, "spellsteal") {}
+	};
+
+	class CastLivingBombAction : public CastDebuffSpellAction
+	{
+	public:
+	    CastLivingBombAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "living bomb") {}
+	};
+
+	class CastDragonsBreathAction : public CastSpellAction
+	{
+	public:
+	    CastDragonsBreathAction(PlayerbotAI* ai) : CastSpellAction(ai, "dragon's breath") {}
+	};
+
+	class CastBlastWaveAction : public CastSpellAction
+	{
+	public:
+	    CastBlastWaveAction(PlayerbotAI* ai) : CastSpellAction(ai, "blast wave") {}
+	};
+
+	class CastInvisibilityAction : public CastBuffSpellAction
+	{
+	public:
+	    CastInvisibilityAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "invisibility") {}
+	};
+
+	class CastEvocationAction : public CastSpellAction
+	{
+	public:
+	    CastEvocationAction(PlayerbotAI* ai) : CastSpellAction(ai, "evocation") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+    class CastCounterspellOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+	    CastCounterspellOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
new file mode 100644
index 0000000..366ef77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
@@ -0,0 +1,221 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "MageActions.h"
+#include "MageAiObjectContext.h"
+#include "FrostMageStrategy.h"
+#include "ArcaneMageStrategy.h"
+#include "GenericMageNonCombatStrategy.h"
+#include "FireMageStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "MageTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &mage::StrategyFactoryInternal::nc;
+                creators["pull"] = &mage::StrategyFactoryInternal::pull;
+                creators["fire aoe"] = &mage::StrategyFactoryInternal::fire_aoe;
+                creators["frost aoe"] = &mage::StrategyFactoryInternal::frost_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericMageNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* fire_aoe(PlayerbotAI* ai) { return new FireMageAoeStrategy(ai); }
+            static Strategy* frost_aoe(PlayerbotAI* ai) { return new FrostMageAoeStrategy(ai); }
+        };
+
+        class MageStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["frost"] = &mage::MageStrategyFactoryInternal::frost;
+                creators["fire"] = &mage::MageStrategyFactoryInternal::fire;
+                creators["arcane"] = &mage::MageStrategyFactoryInternal::arcane;
+            }
+
+        private:
+            static Strategy* frost(PlayerbotAI* ai) { return new FrostMageStrategy(ai); }
+            static Strategy* fire(PlayerbotAI* ai) { return new FireMageStrategy(ai); }
+            static Strategy* arcane(PlayerbotAI* ai) { return new ArcaneMageStrategy(ai); }
+        };
+
+        class MageBuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageBuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &mage::MageBuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &mage::MageBuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new MageBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new MageBuffDpsStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["fireball"] = &TriggerFactoryInternal::fireball;
+                creators["pyroblast"] = &TriggerFactoryInternal::pyroblast;
+                creators["combustion"] = &TriggerFactoryInternal::combustion;
+                creators["icy veins"] = &TriggerFactoryInternal::icy_veins;
+                creators["arcane intellect"] = &TriggerFactoryInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &TriggerFactoryInternal::arcane_intellect_on_party;
+                creators["mage armor"] = &TriggerFactoryInternal::mage_armor;
+                creators["remove curse"] = &TriggerFactoryInternal::remove_curse;
+                creators["remove curse on party"] = &TriggerFactoryInternal::remove_curse_on_party;
+                creators["counterspell"] = &TriggerFactoryInternal::counterspell;
+                creators["polymorph"] = &TriggerFactoryInternal::polymorph;
+                creators["spellsteal"] = &TriggerFactoryInternal::spellsteal;
+                creators["hot streak"] = &TriggerFactoryInternal::hot_streak;
+                creators["living bomb"] = &TriggerFactoryInternal::living_bomb;
+                creators["missile barrage"] = &TriggerFactoryInternal::missile_barrage;
+                creators["arcane blast"] = &TriggerFactoryInternal::arcane_blast;
+                creators["counterspell on enemy healer"] = &TriggerFactoryInternal::counterspell_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hot_streak(PlayerbotAI* ai) { return new HotStreakTrigger(ai); }
+            static Trigger* fireball(PlayerbotAI* ai) { return new FireballTrigger(ai); }
+            static Trigger* pyroblast(PlayerbotAI* ai) { return new PyroblastTrigger(ai); }
+            static Trigger* combustion(PlayerbotAI* ai) { return new CombustionTrigger(ai); }
+            static Trigger* icy_veins(PlayerbotAI* ai) { return new IcyVeinsTrigger(ai); }
+            static Trigger* arcane_intellect(PlayerbotAI* ai) { return new ArcaneIntellectTrigger(ai); }
+            static Trigger* arcane_intellect_on_party(PlayerbotAI* ai) { return new ArcaneIntellectOnPartyTrigger(ai); }
+            static Trigger* mage_armor(PlayerbotAI* ai) { return new MageArmorTrigger(ai); }
+            static Trigger* remove_curse(PlayerbotAI* ai) { return new RemoveCurseTrigger(ai); }
+            static Trigger* remove_curse_on_party(PlayerbotAI* ai) { return new PartyMemberRemoveCurseTrigger(ai); }
+            static Trigger* counterspell(PlayerbotAI* ai) { return new CounterspellInterruptSpellTrigger(ai); }
+            static Trigger* polymorph(PlayerbotAI* ai) { return new PolymorphTrigger(ai); }
+            static Trigger* spellsteal(PlayerbotAI* ai) { return new SpellstealTrigger(ai); }
+            static Trigger* living_bomb(PlayerbotAI* ai) { return new LivingBombTrigger(ai); }
+            static Trigger* missile_barrage(PlayerbotAI* ai) { return new MissileBarrageTrigger(ai); }
+            static Trigger* arcane_blast(PlayerbotAI* ai) { return new ArcaneBlastTrigger(ai); }
+            static Trigger* counterspell_enemy_healer(PlayerbotAI* ai) { return new CounterspellEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["frostbolt"] = &AiObjectContextInternal::frostbolt;
+                creators["blizzard"] = &AiObjectContextInternal::blizzard;
+                creators["frost nova"] = &AiObjectContextInternal::frost_nova;
+                creators["arcane intellect"] = &AiObjectContextInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &AiObjectContextInternal::arcane_intellect_on_party;
+                creators["conjure water"] = &AiObjectContextInternal::conjure_water;
+                creators["conjure food"] = &AiObjectContextInternal::conjure_food;
+                creators["molten armor"] = &AiObjectContextInternal::molten_armor;
+                creators["mage armor"] = &AiObjectContextInternal::mage_armor;
+                creators["ice armor"] = &AiObjectContextInternal::ice_armor;
+                creators["frost armor"] = &AiObjectContextInternal::frost_armor;
+                creators["fireball"] = &AiObjectContextInternal::fireball;
+                creators["pyroblast"] = &AiObjectContextInternal::pyroblast;
+                creators["flamestrike"] = &AiObjectContextInternal::flamestrike;
+                creators["fire blast"] = &AiObjectContextInternal::fire_blast;
+                creators["scorch"] = &AiObjectContextInternal::scorch;
+                creators["counterspell"] = &AiObjectContextInternal::counterspell;
+                creators["remove curse"] = &AiObjectContextInternal::remove_curse;
+                creators["remove curse on party"] = &AiObjectContextInternal::remove_curse_on_party;
+                creators["icy veins"] = &AiObjectContextInternal::icy_veins;
+                creators["combustion"] = &AiObjectContextInternal::combustion;
+                creators["ice block"] = &AiObjectContextInternal::ice_block;
+                creators["polymorph"] = &AiObjectContextInternal::polymorph;
+                creators["spellsteal"] = &AiObjectContextInternal::spellsteal;
+                creators["living bomb"] = &AiObjectContextInternal::living_bomb;
+                creators["dragon's breath"] = &AiObjectContextInternal::dragons_breath;
+                creators["blast wave"] = &AiObjectContextInternal::blast_wave;
+                creators["invisibility"] = &AiObjectContextInternal::invisibility;
+                creators["evocation"] = &AiObjectContextInternal::evocation;
+                creators["arcane blast"] = &AiObjectContextInternal::arcane_blast;
+                creators["arcane barrage"] = &AiObjectContextInternal::arcane_barrage;
+                creators["arcane missiles"] = &AiObjectContextInternal::arcane_missiles;
+                creators["counterspell on enemy healer"] = &AiObjectContextInternal::counterspell_on_enemy_healer;
+            }
+
+        private:
+            static Action* arcane_missiles(PlayerbotAI* ai) { return new CastArcaneMissilesAction(ai); }
+            static Action* arcane_barrage(PlayerbotAI* ai) { return new CastArcaneBarrageAction(ai); }
+            static Action* arcane_blast(PlayerbotAI* ai) { return new CastArcaneBlastAction(ai); }
+            static Action* frostbolt(PlayerbotAI* ai) { return new CastFrostboltAction(ai); }
+            static Action* blizzard(PlayerbotAI* ai) { return new CastBlizzardAction(ai); }
+            static Action* frost_nova(PlayerbotAI* ai) { return new CastFrostNovaAction(ai); }
+            static Action* arcane_intellect(PlayerbotAI* ai) { return new CastArcaneIntellectAction(ai); }
+            static Action* arcane_intellect_on_party(PlayerbotAI* ai) { return new CastArcaneIntellectOnPartyAction(ai); }
+            static Action* conjure_water(PlayerbotAI* ai) { return new CastConjureWaterAction(ai); }
+            static Action* conjure_food(PlayerbotAI* ai) { return new CastConjureFoodAction(ai); }
+            static Action* molten_armor(PlayerbotAI* ai) { return new CastMoltenArmorAction(ai); }
+            static Action* mage_armor(PlayerbotAI* ai) { return new CastMageArmorAction(ai); }
+            static Action* ice_armor(PlayerbotAI* ai) { return new CastIceArmorAction(ai); }
+            static Action* frost_armor(PlayerbotAI* ai) { return new CastFrostArmorAction(ai); }
+            static Action* fireball(PlayerbotAI* ai) { return new CastFireballAction(ai); }
+            static Action* pyroblast(PlayerbotAI* ai) { return new CastPyroblastAction(ai); }
+            static Action* flamestrike(PlayerbotAI* ai) { return new CastFlamestrikeAction(ai); }
+            static Action* fire_blast(PlayerbotAI* ai) { return new CastFireBlastAction(ai); }
+            static Action* scorch(PlayerbotAI* ai) { return new CastScorchAction(ai); }
+            static Action* counterspell(PlayerbotAI* ai) { return new CastCounterspellAction(ai); }
+            static Action* remove_curse(PlayerbotAI* ai) { return new CastRemoveCurseAction(ai); }
+            static Action* remove_curse_on_party(PlayerbotAI* ai) { return new CastRemoveCurseOnPartyAction(ai); }
+            static Action* icy_veins(PlayerbotAI* ai) { return new CastIcyVeinsAction(ai); }
+            static Action* combustion(PlayerbotAI* ai) { return new CastCombustionAction(ai); }
+            static Action* ice_block(PlayerbotAI* ai) { return new CastIceBlockAction(ai); }
+            static Action* polymorph(PlayerbotAI* ai) { return new CastPolymorphAction(ai); }
+            static Action* spellsteal(PlayerbotAI* ai) { return new CastSpellstealAction(ai); }
+            static Action* living_bomb(PlayerbotAI* ai) { return new CastLivingBombAction(ai); }
+            static Action* dragons_breath(PlayerbotAI* ai) { return new CastDragonsBreathAction(ai); }
+            static Action* blast_wave(PlayerbotAI* ai) { return new CastBlastWaveAction(ai); }
+            static Action* invisibility(PlayerbotAI* ai) { return new CastInvisibilityAction(ai); }
+            static Action* evocation(PlayerbotAI* ai) { return new CastEvocationAction(ai); }
+            static Action* counterspell_on_enemy_healer(PlayerbotAI* ai) { return new CastCounterspellOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+MageAiObjectContext::MageAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::mage::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageStrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageBuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::mage::AiObjectContextInternal());
+    triggerContexts.Add(new ai::mage::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
new file mode 100644
index 0000000..0fe90e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class MageAiObjectContext : public AiObjectContext
+    {
+    public:
+        MageAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
new file mode 100644
index 0000000..8ebe45f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "MageActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.h b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.cpp b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
new file mode 100644
index 0000000..48750fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageTriggers.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+bool MageArmorTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+    return !ai->HasAura("ice armor", target) &&
+        !ai->HasAura("frost armor", target) &&
+        !ai->HasAura("molten armor", target) &&
+        !ai->HasAura("mage armor", target);
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.h b/src/plugins/playerbot/strategy/mage/MageTriggers.h
new file mode 100644
index 0000000..a07b4f2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.h
@@ -0,0 +1,92 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(ArcaneIntellectOnPartyTrigger, "arcane intellect", "arcane intellect on party")
+    BUFF_TRIGGER(ArcaneIntellectTrigger, "arcane intellect", "arcane intellect")
+
+    class MageArmorTrigger : public BuffTrigger {
+    public:
+        MageArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mage armor") {}
+        virtual bool IsActive();
+    };
+
+    class LivingBombTrigger : public DebuffTrigger {
+    public:
+        LivingBombTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "living bomb") {}
+	};
+
+    class FireballTrigger : public DebuffTrigger {
+    public:
+        FireballTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "fireball") {}
+	};
+
+    class PyroblastTrigger : public DebuffTrigger {
+    public:
+        PyroblastTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "pyroblast") {}
+    };
+
+    class HotStreakTrigger : public HasAuraTrigger {
+    public:
+        HotStreakTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "hot streak") {}
+    };
+
+    class MissileBarrageTrigger : public HasAuraTrigger {
+    public:
+        MissileBarrageTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "missile barrage") {}
+    };
+
+    class ArcaneBlastTrigger : public BuffTrigger {
+    public:
+        ArcaneBlastTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "arcane blast") {}
+    };
+
+    class CounterspellInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        CounterspellInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "counterspell") {}
+    };
+
+    class CombustionTrigger : public BoostTrigger
+    {
+    public:
+        CombustionTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "combustion") {}
+    };
+
+    class IcyVeinsTrigger : public BoostTrigger
+    {
+    public:
+        IcyVeinsTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "icy veins") {}
+    };
+
+    class PolymorphTrigger : public HasCcTargetTrigger
+    {
+    public:
+        PolymorphTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "polymorph") {}
+    };
+
+    class RemoveCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        RemoveCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberRemoveCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberRemoveCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class SpellstealTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        SpellstealTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "spellsteal", DISPEL_MAGIC) {}
+    };
+
+    class CounterspellEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        CounterspellEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
new file mode 100644
index 0000000..02c4a57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "DpsPaladinStrategy.h"
+
+using namespace ai;
+
+class DpsPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsPaladinStrategyActionNodeFactory()
+    {
+        creators["seal of vengeance"] = &seal_of_vengeance;
+        creators["seal of command"] = &seal_of_command;
+        creators["blessing of might"] = &blessing_of_might;
+        creators["crusader strike"] = &crusader_strike;
+    }
+
+private:
+    static ActionNode* seal_of_vengeance(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of vengeance",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of command"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* seal_of_command(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of command",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of wisdom"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* blessing_of_might(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of might",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* crusader_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("crusader strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsPaladinStrategy::DpsPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsPaladinStrategyActionNodeFactory());
+}
+
+NextAction** DpsPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("crusader strike", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+    
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine shield", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "judgement of wisdom",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of might", ACTION_HIGH + 8), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("divine storm", ACTION_HIGH + 1), new NextAction("consecration", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"art of war",
+		NextAction::array(0, new NextAction("exorcism", ACTION_HIGH + 2), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
new file mode 100644
index 0000000..cff5fd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class DpsPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        DpsPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
new file mode 100644
index 0000000..fda1619
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPaladinNonCombatStrategy::GenericPaladinNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "blessing of kings on party",
+        NextAction::array(0, new NextAction("blessing of kings on party", 11.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("redemption", 30.0f), NULL)));
+
+	 triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("holy light", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure magic",
+        NextAction::array(0, new NextAction("cleanse magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure magic",
+        NextAction::array(0, new NextAction("cleanse magic on party", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
new file mode 100644
index 0000000..cf03f6d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericPaladinNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+   };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
new file mode 100644
index 0000000..d218be1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
@@ -0,0 +1,77 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericPaladinStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+
+GenericPaladinStrategy::GenericPaladinStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine protection", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice interrupt",
+		NextAction::array(0, new NextAction("hammer of justice", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice on enemy healer",
+		NextAction::array(0, new NextAction("hammer of justice on enemy healer", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("lay on hands", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member critical health",
+		NextAction::array(0, new NextAction("lay on hands on party", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("hammer of wrath", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", ACTION_DISPEL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse cure magic",
+		NextAction::array(0, new NextAction("cleanse magic", ACTION_DISPEL + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse party member cure magic",
+		NextAction::array(0, new NextAction("cleanse magic on party", ACTION_DISPEL + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
new file mode 100644
index 0000000..000f785
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "PaladinAiObjectContext.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "paladin"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
new file mode 100644
index 0000000..f077301
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
@@ -0,0 +1,142 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPaladinStrategyActionNodeFactory()
+        {
+            creators["seal of light"] = &seal_of_light;
+            creators["cleanse poison"] = &cleanse_poison;
+            creators["cleanse disease"] = &cleanse_disease;
+            creators["cleanse magic"] = &cleanse_magic;
+            creators["cleanse poison on party"] = &cleanse_poison_on_party;
+            creators["cleanse disease on party"] = &cleanse_disease_on_party;
+            creators["seal of wisdom"] = &seal_of_wisdom;
+            creators["seal of justice"] = &seal_of_justice;
+            creators["hand of reckoning"] = &hand_of_reckoning;
+            creators["judgement of wisdom"] = &judgement_of_wisdom;
+            creators["divine shield"] = &divine_shield;
+            creators["flash of light"] = &flash_of_light;
+            creators["flash of light on party"] = &flash_of_light_on_party;
+            creators["holy wrath"] = &holy_wrath;
+            creators["lay on hands"] = &lay_on_hands;
+            creators["lay on hands on party"] = &lay_on_hands_on_party;
+        }
+    private:
+        static ActionNode* lay_on_hands(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine shield"), new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lay_on_hands_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_magic(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse magic",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_justice(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of justice",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of righteousness"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* hand_of_reckoning(PlayerbotAI* ai)
+        {
+            return new ActionNode ("hand of reckoning",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* judgement_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("judgement of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine protection"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_wrath(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy wrath",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("consecration"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
new file mode 100644
index 0000000..47def40
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.h b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
new file mode 100644
index 0000000..78f782c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
@@ -0,0 +1,365 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastJudgementOfLightAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfLightAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of light") {}
+    };
+
+    class CastJudgementOfWisdomAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfWisdomAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of wisdom") {}
+    };
+
+    class CastJudgementOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of justice") {}
+    };
+
+	class CastRighteousFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastRighteousFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "righteous fury") {}
+	};
+
+	class CastDevotionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastDevotionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "devotion aura") {}
+	};
+
+	class CastRetributionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastRetributionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "retribution aura") {}
+	};
+
+	class CastConcentrationAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastConcentrationAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "concentration aura") {}
+	};
+
+	class CastDivineStormAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineStormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine storm") {}
+	};
+
+	class CastCrusaderStrikeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastCrusaderStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "crusader strike") {}
+	};
+
+	class CastShadowResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastShadowResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadow resistance aura") {}
+	};
+
+	class CastFrostResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFrostResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost resistance aura") {}
+	};
+
+	class CastFireResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFireResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fire resistance aura") {}
+	};
+
+	class CastCrusaderAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastCrusaderAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "crusader aura") {}
+	};
+
+	class CastSealOfRighteousnessAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfRighteousnessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of righteousness") {}
+	};
+
+	class CastSealOfJusticeAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfJusticeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of justice") {}
+	};
+
+
+	class CastSealOfLightAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfLightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of light") {}
+	};
+
+	class CastSealOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of wisdom") {}
+	};
+
+	class CastSealOfCommandAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfCommandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of command") {}
+	};
+
+	class CastSealOfVengeanceAction : public CastBuffSpellAction
+	{
+	public:
+	    CastSealOfVengeanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of vengeance") {}
+	};
+
+
+	class CastBlessingOfMightAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfMightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of might") {}
+	};
+
+	class CastBlessingOfMightOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfMightOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of might") {}
+        virtual string getName() { return "blessing of might on party";}
+	};
+
+	class CastBlessingOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of wisdom") {}
+	};
+
+	class CastBlessingOfWisdomOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfWisdomOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of wisdom") {}
+        virtual string getName() { return "blessing of wisdom on party";}
+	};
+
+	class CastBlessingOfKingsAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfKingsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of kings") {}
+	};
+
+	class CastBlessingOfKingsOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfKingsOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of kings") {}
+        virtual string getName() { return "blessing of kings on party";}
+	};
+
+	class CastBlessingOfSanctuaryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfSanctuaryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of sanctuary") {}
+	};
+
+	class CastBlessingOfSanctuaryOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfSanctuaryOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of sanctuary") {}
+        virtual string getName() { return "blessing of sanctuary on party";}
+	};
+
+    class CastHolyLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastHolyLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "holy light") {}
+    };
+
+    class CastHolyLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHolyLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "holy light") {}
+
+        virtual string getName() { return "holy light on party"; }
+    };
+
+    class CastFlashOfLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastFlashOfLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash of light") {}
+    };
+
+    class CastFlashOfLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashOfLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash of light") {}
+
+        virtual string getName() { return "flash of light on party"; }
+    };
+
+    class CastLayOnHandsAction : public CastHealingSpellAction
+    {
+    public:
+        CastLayOnHandsAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lay on hands") {}
+    };
+
+    class CastLayOnHandsOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLayOnHandsOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lay on hands") {}
+
+        virtual string getName() { return "lay on hands on party"; }
+    };
+
+	class CastDivineProtectionAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineProtectionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine protection") {}
+	};
+
+    class CastDivineProtectionOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastDivineProtectionOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "divine protection") {}
+
+        virtual string getName() { return "divine protection on party"; }
+    };
+
+	class CastDivineShieldAction: public CastBuffSpellAction
+	{
+	public:
+		CastDivineShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine shield") {}
+	};
+
+    class CastConsecrationAction : public CastMeleeSpellAction
+    {
+    public:
+	    CastConsecrationAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "consecration") {}
+    };
+
+    class CastHolyWrathAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHolyWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "holy wrath") {}
+    };
+
+    class CastHammerOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHammerOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of justice") {}
+    };
+
+	class CastHammerOfWrathAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of wrath") {}
+	};
+
+	class CastHammerOfTheRighteousAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfTheRighteousAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of the righteous") {}
+	};
+
+	class CastPurifyPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+	class CastPurifyDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+    class CastPurifyPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastPurifyPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_POISON) {}
+
+        virtual string getName() { return "purify poison on party"; }
+    };
+
+	class CastPurifyDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastPurifyDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "purify disease on party"; }
+	};
+
+	class CastHandOfReckoningAction : public CastSpellAction
+	{
+	public:
+		CastHandOfReckoningAction(PlayerbotAI* ai) : CastSpellAction(ai, "hand of reckoning") {}
+	};
+
+	class CastCleansePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCleansePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseMagicAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+    class CastCleansePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleansePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse poison on party"; }
+    };
+
+	class CastCleanseDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "cleanse disease on party"; }
+	};
+
+	class CastCleanseMagicOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_MAGIC) {}
+
+		virtual string getName() { return "cleanse magic on party"; }
+	};
+
+    BEGIN_SPELL_ACTION(CastAvengersShieldAction, "avenger's shield")
+    END_SPELL_ACTION()
+
+	BEGIN_SPELL_ACTION(CastExorcismAction, "exorcism")
+	END_SPELL_ACTION()
+
+	class CastHolyShieldAction : public CastBuffSpellAction
+	{
+	public:
+		CastHolyShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "holy shield") {}
+	};
+
+	class CastRedemptionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRedemptionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "redemption") {}
+	};
+
+    class CastHammerOfJusticeOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastHammerOfJusticeOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
new file mode 100644
index 0000000..37c7468
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
@@ -0,0 +1,279 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+#include "PaladinTriggers.h"
+#include "PaladinAiObjectContext.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "TankPaladinStrategy.h"
+#include "DpsPaladinStrategy.h"
+#include "PaladinBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &paladin::StrategyFactoryInternal::nc;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericPaladinNonCombatStrategy(ai); }
+        };
+
+        class ResistanceStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            ResistanceStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["rshadow"] = &paladin::ResistanceStrategyFactoryInternal::rshadow;
+                creators["rfrost"] = &paladin::ResistanceStrategyFactoryInternal::rfrost;
+                creators["rfire"] = &paladin::ResistanceStrategyFactoryInternal::rfire;
+            }
+
+        private:
+            static Strategy* rshadow(PlayerbotAI* ai) { return new PaladinShadowResistanceStrategy(ai); }
+            static Strategy* rfrost(PlayerbotAI* ai) { return new PaladinFrostResistanceStrategy(ai); }
+            static Strategy* rfire(PlayerbotAI* ai) { return new PaladinFireResistanceStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bhealth"] = &paladin::BuffStrategyFactoryInternal::bhealth;
+                creators["bmana"] = &paladin::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &paladin::BuffStrategyFactoryInternal::bdps;
+                creators["barmor"] = &paladin::BuffStrategyFactoryInternal::barmor;
+                creators["bspeed"] = &paladin::BuffStrategyFactoryInternal::bspeed;
+            }
+
+        private:
+            static Strategy* bhealth(PlayerbotAI* ai) { return new PaladinBuffHealthStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new PaladinBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new PaladinBuffDpsStrategy(ai); }
+            static Strategy* barmor(PlayerbotAI* ai) { return new PaladinBuffArmorStrategy(ai); }
+            static Strategy* bspeed(PlayerbotAI* ai) { return new PaladinBuffSpeedStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &paladin::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &paladin::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankPaladinStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsPaladinStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["judgement of wisdom"] = &TriggerFactoryInternal::judgement_of_wisdom;
+                creators["judgement of light"] = &TriggerFactoryInternal::judgement_of_light;
+                creators["blessing"] = &TriggerFactoryInternal::blessing;
+                creators["seal"] = &TriggerFactoryInternal::seal;
+                creators["art of war"] = &TriggerFactoryInternal::art_of_war;
+                creators["blessing of kings on party"] = &TriggerFactoryInternal::blessing_of_kings_on_party;
+                creators["crusader aura"] = &TriggerFactoryInternal::crusader_aura;
+                creators["retribution aura"] = &TriggerFactoryInternal::retribution_aura;
+                creators["devotion aura"] = &TriggerFactoryInternal::devotion_aura;
+                creators["shadow resistance aura"] = &TriggerFactoryInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &TriggerFactoryInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &TriggerFactoryInternal::fire_resistance_aura;
+                creators["hammer of justice snare"] = &TriggerFactoryInternal::hammer_of_justice_snare;
+                creators["hammer of justice interrupt"] = &TriggerFactoryInternal::hammer_of_justice_interrupt;
+                creators["cleanse cure disease"] = &TriggerFactoryInternal::CleanseCureDisease;
+                creators["cleanse party member cure disease"] = &TriggerFactoryInternal::CleanseCurePartyMemberDisease;
+                creators["cleanse cure poison"] = &TriggerFactoryInternal::CleanseCurePoison;
+                creators["cleanse party member cure poison"] = &TriggerFactoryInternal::CleanseCurePartyMemberPoison;
+                creators["cleanse cure magic"] = &TriggerFactoryInternal::CleanseCureMagic;
+                creators["cleanse party member cure magic"] = &TriggerFactoryInternal::CleanseCurePartyMemberMagic;
+                creators["righteous fury"] = &TriggerFactoryInternal::righteous_fury;
+                creators["holy shield"] = &TriggerFactoryInternal::holy_shield;
+                creators["hammer of justice on enemy healer"] = &TriggerFactoryInternal::hammer_of_justice_on_enemy_target;
+            }
+
+        private:
+            static Trigger* holy_shield(PlayerbotAI* ai) { return new HolyShieldTrigger(ai); }
+            static Trigger* righteous_fury(PlayerbotAI* ai) { return new RighteousFuryTrigger(ai); }
+            static Trigger* judgement_of_wisdom(PlayerbotAI* ai) { return new JudgementOfWisdomTrigger(ai); }
+            static Trigger* judgement_of_light(PlayerbotAI* ai) { return new JudgementOfLightTrigger(ai); }
+            static Trigger* blessing(PlayerbotAI* ai) { return new BlessingTrigger(ai); }
+            static Trigger* seal(PlayerbotAI* ai) { return new SealTrigger(ai); }
+            static Trigger* art_of_war(PlayerbotAI* ai) { return new ArtOfWarTrigger(ai); }
+            static Trigger* blessing_of_kings_on_party(PlayerbotAI* ai) { return new BlessingOfKingsOnPartyTrigger(ai); }
+            static Trigger* crusader_aura(PlayerbotAI* ai) { return new CrusaderAuraTrigger(ai); }
+            static Trigger* retribution_aura(PlayerbotAI* ai) { return new RetributionAuraTrigger(ai); }
+            static Trigger* devotion_aura(PlayerbotAI* ai) { return new DevotionAuraTrigger(ai); }
+            static Trigger* shadow_resistance_aura(PlayerbotAI* ai) { return new ShadowResistanceAuraTrigger(ai); }
+            static Trigger* frost_resistance_aura(PlayerbotAI* ai) { return new FrostResistanceAuraTrigger(ai); }
+            static Trigger* fire_resistance_aura(PlayerbotAI* ai) { return new FireResistanceAuraTrigger(ai); }
+            static Trigger* hammer_of_justice_snare(PlayerbotAI* ai) { return new HammerOfJusticeSnareTrigger(ai); }
+            static Trigger* hammer_of_justice_interrupt(PlayerbotAI* ai) { return new HammerOfJusticeInterruptSpellTrigger(ai); }
+            static Trigger* CleanseCureDisease(PlayerbotAI* ai) { return new CleanseCureDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberDisease(PlayerbotAI* ai) { return new CleanseCurePartyMemberDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePoison(PlayerbotAI* ai) { return new CleanseCurePoisonTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberPoison(PlayerbotAI* ai) { return new CleanseCurePartyMemberPoisonTrigger(ai); }
+            static Trigger* CleanseCureMagic(PlayerbotAI* ai) { return new CleanseCureMagicTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberMagic(PlayerbotAI* ai) { return new CleanseCurePartyMemberMagicTrigger(ai); }
+            static Trigger* hammer_of_justice_on_enemy_target(PlayerbotAI* ai) { return new HammerOfJusticeEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["seal of command"] = &AiObjectContextInternal::seal_of_command;
+                creators["seal of vengeance"] = &AiObjectContextInternal::seal_of_vengeance;
+                creators["blessing of might"] = &AiObjectContextInternal::blessing_of_might;
+                creators["divine storm"] = &AiObjectContextInternal::divine_storm;
+                creators["blessing of kings on party"] = &AiObjectContextInternal::blessing_of_kings_on_party;
+                creators["redemption"] = &AiObjectContextInternal::redemption;
+                creators["crusader strike"] = &AiObjectContextInternal::crusader_strike;
+                creators["crusader aura"] = &AiObjectContextInternal::crusader_aura;
+                creators["seal of light"] = &AiObjectContextInternal::seal_of_light;
+                creators["devotion aura"] = &AiObjectContextInternal::devotion_aura;
+                creators["holy wrath"] = &AiObjectContextInternal::holy_wrath;
+                creators["consecration"] = &AiObjectContextInternal::consecration;
+                creators["cleanse disease"] = &AiObjectContextInternal::cleanse_disease;
+                creators["cleanse poison"] = &AiObjectContextInternal::cleanse_poison;
+                creators["cleanse magic"] = &AiObjectContextInternal::cleanse_magic;
+                creators["purify disease"] = &AiObjectContextInternal::purify_disease;
+                creators["purify poison"] = &AiObjectContextInternal::purify_poison;
+                creators["cleanse poison on party"] = &AiObjectContextInternal::cleanse_poison_on_party;
+                creators["cleanse disease on party"] = &AiObjectContextInternal::cleanse_disease_on_party;
+                creators["cleanse magic on party"] = &AiObjectContextInternal::cleanse_magic_on_party;
+                creators["purify poison on party"] = &AiObjectContextInternal::purify_poison_on_party;
+                creators["purify disease on party"] = &AiObjectContextInternal::purify_disease_on_party;
+                creators["seal of wisdom"] = &AiObjectContextInternal::seal_of_wisdom;
+                creators["seal of justice"] = &AiObjectContextInternal::seal_of_justice;
+                creators["seal of righteousness"] = &AiObjectContextInternal::seal_of_righteousness;
+                creators["flash of light"] = &AiObjectContextInternal::flash_of_light;
+                creators["hand of reckoning"] = &AiObjectContextInternal::hand_of_reckoning;
+                creators["avenger's shield"] = &AiObjectContextInternal::avengers_shield;
+                creators["exorcism"] = &AiObjectContextInternal::exorcism;
+                creators["judgement of light"] = &AiObjectContextInternal::judgement_of_light;
+                creators["judgement of wisdom"] = &AiObjectContextInternal::judgement_of_wisdom;
+                creators["divine shield"] = &AiObjectContextInternal::divine_shield;
+                creators["divine protection"] = &AiObjectContextInternal::divine_protection;
+                creators["divine protection on party"] =&AiObjectContextInternal::divine_protection_on_party;
+                creators["hammer of justice"] = &AiObjectContextInternal::hammer_of_justice;
+                creators["flash of light on party"] = &AiObjectContextInternal::flash_of_light_on_party;
+                creators["holy light"] = &AiObjectContextInternal::holy_light;
+                creators["holy light on party"] = &AiObjectContextInternal::holy_light_on_party;
+                creators["lay on hands"] = &AiObjectContextInternal::lay_on_hands;
+                creators["lay on hands on party"] = &AiObjectContextInternal::lay_on_hands_on_party;
+                creators["judgement of justice"] = &AiObjectContextInternal::judgement_of_justice;
+                creators["hammer of wrath"] = &AiObjectContextInternal::hammer_of_wrath;
+                creators["holy shield"] = &AiObjectContextInternal::holy_shield;
+                creators["hammer of the righteous"] = &AiObjectContextInternal::hammer_of_the_righteous;
+                creators["blessing of kings"] = &AiObjectContextInternal::blessing_of_kings;
+                creators["retribution aura"] = &AiObjectContextInternal::retribution_aura;
+                creators["shadow resistance aura"] = &AiObjectContextInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &AiObjectContextInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &AiObjectContextInternal::fire_resistance_aura;
+                creators["righteous fury"] = &AiObjectContextInternal::righteous_fury;
+                creators["blessing of sanctuary"] = &AiObjectContextInternal::blessing_of_sanctuary;
+                creators["hammer of justice on enemy healer"] = &AiObjectContextInternal::hammer_of_justice_on_enemy_healer;
+            }
+
+        private:
+            static Action* righteous_fury(PlayerbotAI* ai) { return new CastRighteousFuryAction(ai); }
+            static Action* blessing_of_sanctuary(PlayerbotAI* ai) { return new CastBlessingOfSanctuaryAction(ai); }
+            static Action* seal_of_command(PlayerbotAI* ai) { return new CastSealOfCommandAction(ai); }
+            static Action* seal_of_vengeance(PlayerbotAI* ai) { return new CastSealOfVengeanceAction(ai); }
+            static Action* blessing_of_might(PlayerbotAI* ai) { return new CastBlessingOfMightAction(ai); }
+            static Action* divine_storm(PlayerbotAI* ai) { return new CastDivineStormAction(ai); }
+            static Action* blessing_of_kings_on_party(PlayerbotAI* ai) { return new CastBlessingOfKingsOnPartyAction(ai); }
+            static Action* redemption(PlayerbotAI* ai) { return new CastRedemptionAction(ai); }
+            static Action* crusader_strike(PlayerbotAI* ai) { return new CastCrusaderStrikeAction(ai); }
+            static Action* crusader_aura(PlayerbotAI* ai) { return new CastCrusaderAuraAction(ai); }
+            static Action* seal_of_light(PlayerbotAI* ai) { return new CastSealOfLightAction(ai); }
+            static Action* devotion_aura(PlayerbotAI* ai) { return new CastDevotionAuraAction(ai); }
+            static Action* holy_wrath(PlayerbotAI* ai) { return new CastHolyWrathAction(ai); }
+            static Action* consecration(PlayerbotAI* ai) { return new CastConsecrationAction(ai); }
+            static Action* cleanse_poison(PlayerbotAI* ai) { return new CastCleansePoisonAction(ai); }
+            static Action* cleanse_disease(PlayerbotAI* ai) { return new CastCleanseDiseaseAction(ai); }
+            static Action* cleanse_magic(PlayerbotAI* ai) { return new CastCleanseMagicAction(ai); }
+            static Action* purify_poison(PlayerbotAI* ai) { return new CastPurifyPoisonAction(ai); }
+            static Action* purify_disease(PlayerbotAI* ai) { return new CastPurifyDiseaseAction(ai); }
+            static Action* cleanse_poison_on_party(PlayerbotAI* ai) { return new CastCleansePoisonOnPartyAction(ai); }
+            static Action* cleanse_disease_on_party(PlayerbotAI* ai) { return new CastCleanseDiseaseOnPartyAction(ai); }
+            static Action* cleanse_magic_on_party(PlayerbotAI* ai) { return new CastCleanseMagicOnPartyAction(ai); }
+            static Action* purify_poison_on_party(PlayerbotAI* ai) { return new CastPurifyPoisonOnPartyAction(ai); }
+            static Action* purify_disease_on_party(PlayerbotAI* ai) { return new CastPurifyDiseaseOnPartyAction(ai); }
+            static Action* seal_of_wisdom(PlayerbotAI* ai) { return new CastSealOfWisdomAction(ai); }
+            static Action* seal_of_justice(PlayerbotAI* ai) { return new CastSealOfJusticeAction(ai); }
+            static Action* seal_of_righteousness(PlayerbotAI* ai) { return new CastSealOfRighteousnessAction(ai); }
+            static Action* flash_of_light(PlayerbotAI* ai) { return new CastFlashOfLightAction(ai); }
+            static Action* hand_of_reckoning(PlayerbotAI* ai) { return new CastHandOfReckoningAction(ai); }
+            static Action* avengers_shield(PlayerbotAI* ai) { return new CastAvengersShieldAction(ai); }
+            static Action* exorcism(PlayerbotAI* ai) { return new CastExorcismAction(ai); }
+            static Action* judgement_of_light(PlayerbotAI* ai) { return new CastJudgementOfLightAction(ai); }
+            static Action* judgement_of_wisdom(PlayerbotAI* ai) { return new CastJudgementOfWisdomAction(ai); }
+            static Action* divine_shield(PlayerbotAI* ai) { return new CastDivineShieldAction(ai); }
+            static Action* divine_protection(PlayerbotAI* ai) { return new CastDivineProtectionAction(ai); }
+            static Action* divine_protection_on_party(PlayerbotAI* ai) { return new CastDivineProtectionOnPartyAction(ai); }
+            static Action* hammer_of_justice(PlayerbotAI* ai) { return new CastHammerOfJusticeAction(ai); }
+            static Action* flash_of_light_on_party(PlayerbotAI* ai) { return new CastFlashOfLightOnPartyAction(ai); }
+            static Action* holy_light(PlayerbotAI* ai) { return new CastHolyLightAction(ai); }
+            static Action* holy_light_on_party(PlayerbotAI* ai) { return new CastHolyLightOnPartyAction(ai); }
+            static Action* lay_on_hands(PlayerbotAI* ai) { return new CastLayOnHandsAction(ai); }
+            static Action* lay_on_hands_on_party(PlayerbotAI* ai) { return new CastLayOnHandsOnPartyAction(ai); }
+            static Action* judgement_of_justice(PlayerbotAI* ai) { return new CastJudgementOfJusticeAction(ai); }
+            static Action* hammer_of_wrath(PlayerbotAI* ai) { return new CastHammerOfWrathAction(ai); }
+            static Action* holy_shield(PlayerbotAI* ai) { return new CastHolyShieldAction(ai); }
+            static Action* hammer_of_the_righteous(PlayerbotAI* ai) { return new CastHammerOfTheRighteousAction(ai); }
+            static Action* blessing_of_kings(PlayerbotAI* ai) { return new CastBlessingOfKingsAction(ai); }
+            static Action* retribution_aura(PlayerbotAI* ai) { return new CastRetributionAuraAction(ai); }
+            static Action* shadow_resistance_aura(PlayerbotAI* ai) { return new CastShadowResistanceAuraAction(ai); }
+            static Action* frost_resistance_aura(PlayerbotAI* ai) { return new CastFrostResistanceAuraAction(ai); }
+            static Action* fire_resistance_aura(PlayerbotAI* ai) { return new CastFireResistanceAuraAction(ai); }
+            static Action* hammer_of_justice_on_enemy_healer(PlayerbotAI* ai) { return new CastHammerOfJusticeOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+PaladinAiObjectContext::PaladinAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::paladin::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::BuffStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::ResistanceStrategyFactoryInternal());
+    actionContexts.Add(new ai::paladin::AiObjectContextInternal());
+    triggerContexts.Add(new ai::paladin::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
new file mode 100644
index 0000000..1af3343
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PaladinAiObjectContext : public AiObjectContext
+    {
+    public:
+        PaladinAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
new file mode 100644
index 0000000..5124024
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
@@ -0,0 +1,72 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinBuffStrategies.h"
+
+using namespace ai;
+
+void PaladinBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of wisdom", 90.0f), NULL)));
+}
+
+void PaladinBuffHealthStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 90.0f), NULL)));
+}
+
+void PaladinBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "crusader aura",
+        NextAction::array(0, new NextAction("crusader aura", 40.0f), NULL)));
+}
+
+void PaladinBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of vengeance", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"retribution aura",
+		NextAction::array(0, new NextAction("retribution aura", 90.0f), NULL)));
+}
+
+void PaladinShadowResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"shadow resistance aura",
+		NextAction::array(0, new NextAction("shadow resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFrostResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"frost resistance aura",
+		NextAction::array(0, new NextAction("frost resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFireResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"fire resistance aura",
+		NextAction::array(0, new NextAction("fire resistance aura", 90.0f), NULL)));
+}
+
+
+void PaladinBuffArmorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"devotion aura",
+		NextAction::array(0, new NextAction("devotion aura", 90.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
new file mode 100644
index 0000000..e5051a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class PaladinBuffManaStrategy : public Strategy
+    {
+    public:
+        PaladinBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class PaladinBuffHealthStrategy : public Strategy
+    {
+    public:
+        PaladinBuffHealthStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bhealth"; }
+    };
+
+    class PaladinBuffDpsStrategy : public Strategy
+    {
+    public:
+        PaladinBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+
+	class PaladinBuffArmorStrategy : public Strategy
+	{
+	public:
+		PaladinBuffArmorStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "barmor"; }
+	};
+
+	class PaladinBuffSpeedStrategy : public Strategy
+	{
+	public:
+		PaladinBuffSpeedStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "bspeed"; }
+	};
+
+	class PaladinShadowResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinShadowResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rshadow"; }
+	};
+
+	class PaladinFrostResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFrostResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfrost"; }
+	};
+
+	class PaladinFireResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFireResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfire"; }
+	};
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
new file mode 100644
index 0000000..3082abb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
new file mode 100644
index 0000000..1948441
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinTriggers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
+bool SealTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("seal of justice", target) &&
+        !ai->HasAura("seal of command", target) &&
+        !ai->HasAura("seal of vengeance", target) &&
+		!ai->HasAura("seal of righteousness", target) &&
+		!ai->HasAura("seal of light", target) &&
+		!ai->HasAura("seal of wisdom", target);
+}
+
+bool CrusaderAuraTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return AI_VALUE2(bool, "mounted", "self target") && !ai->HasAura("crusader aura", target);
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
new file mode 100644
index 0000000..3f53b4e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
@@ -0,0 +1,114 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	BUFF_TRIGGER(HolyShieldTrigger, "holy shield", "holy shield")
+    BUFF_TRIGGER(RighteousFuryTrigger, "righteous fury", "righteous fury")
+
+    BUFF_TRIGGER(RetributionAuraTrigger, "retribution aura", "retribution aura")
+
+	class CrusaderAuraTrigger : public BuffTrigger
+	{
+	public:
+		CrusaderAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "crusader aura") {}
+		virtual bool IsActive();
+	};
+
+	class SealTrigger : public BuffTrigger
+	{
+	public:
+		SealTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "seal of justice") {}
+		virtual bool IsActive();
+	};
+
+    DEBUFF_TRIGGER(JudgementOfLightTrigger, "judgement of light", "judgement of light")
+    DEBUFF_TRIGGER(JudgementOfWisdomTrigger, "judgement of wisdom", "judgement of wisdom")
+
+    BUFF_ON_PARTY_TRIGGER(BlessingOfKingsOnPartyTrigger, "blessing of kings", "blessing of kings on party")
+    BUFF_TRIGGER(BlessingTrigger, "blessing of sanctuary", "blessing of sanctuary")
+
+    class HammerOfJusticeInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        HammerOfJusticeInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "hammer of justice") {}
+    };
+
+    class HammerOfJusticeSnareTrigger : public SnareTargetTrigger
+    {
+    public:
+        HammerOfJusticeSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hammer of justice") {}
+    };
+
+    class ArtOfWarTrigger : public HasAuraTrigger
+    {
+    public:
+        ArtOfWarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "the art of war") {}
+    };
+
+    class ShadowResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        ShadowResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadow resistance aura") {}
+    };
+
+    class FrostResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FrostResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "frost resistance aura") {}
+    };
+
+    class FireResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FireResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "fire resistance aura") {}
+    };
+
+    class DevotionAuraTrigger : public BuffTrigger
+    {
+    public:
+        DevotionAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "devotion aura") {}
+    };
+
+    class CleanseCureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePartyMemberDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCurePartyMemberPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCureMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class CleanseCurePartyMemberMagicTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberMagicTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class HammerOfJusticeEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        HammerOfJusticeEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
new file mode 100644
index 0000000..6e6b51f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "TankPaladinStrategy.h"
+
+using namespace ai;
+
+class TankPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankPaladinStrategyActionNodeFactory()
+    {
+        creators["blessing of sanctuary"] = &blessing_of_sanctuary;
+    }
+private:
+    static ActionNode* blessing_of_sanctuary(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of sanctuary",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankPaladinStrategy::TankPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new TankPaladinStrategyActionNodeFactory());
+}
+
+NextAction** TankPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("melee", ACTION_NORMAL), NULL);
+}
+
+void TankPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "judgement of light",
+        NextAction::array(0, new NextAction("judgement of light", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium mana",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "righteous fury",
+        NextAction::array(0, new NextAction("righteous fury", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("hammer of the righteous", ACTION_HIGH + 6), new NextAction("avenger's shield", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("consecration", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("hand of reckoning", ACTION_HIGH + 7), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"holy shield",
+		NextAction::array(0, new NextAction("holy shield", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of sanctuary", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
new file mode 100644
index 0000000..d5cf955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class TankPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        TankPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
new file mode 100644
index 0000000..19103da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
@@ -0,0 +1,67 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+#include "GenericPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPriestStrategy::GenericPriestStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPriestStrategyActionNodeFactory());
+}
+
+void GenericPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash heal", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("flash heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("flash heal on party", 60.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("power word: shield", 60.0f), new NextAction("greater heal", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("power word: shield on party", 50.0f), new NextAction("greater heal on party", 50.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("psychic scream", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
new file mode 100644
index 0000000..4633e8d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericPriestStrategy : public CombatStrategy
+    {
+    public:
+        GenericPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..d835366
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
@@ -0,0 +1,173 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPriestStrategyActionNodeFactory()
+        {
+            creators["inner fire"] = &inner_fire;
+            creators["holy nova"] = &holy_nova;
+            creators["power word: fortitude"] = &power_word_fortitude;
+            creators["power word: fortitude on party"] = &power_word_fortitude_on_party;
+            creators["divine spirit"] = &divine_spirit;
+            creators["divine spirit on party"] = &divine_spirit_on_party;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["psychic scream"] = &psychic_scream;
+            creators["fade"] = &fade;
+        }
+    private:
+        static ActionNode* inner_fire(PlayerbotAI* ai)
+        {
+            return new ActionNode ("inner fire",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* psychic_scream(PlayerbotAI* ai)
+        {
+            return new ActionNode ("psychic scream",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("fade"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* fade(PlayerbotAI* ai)
+        {
+            return new ActionNode ("fade",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
new file mode 100644
index 0000000..68e6f37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+
+using namespace ai;
+
+NextAction** HealPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void HealPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("renew", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("renew on party", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("fade", 50.0f), new NextAction("flee", 49.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
new file mode 100644
index 0000000..7f5603f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPriestStrategy.h"
+
+namespace ai
+{
+    class HealPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        HealPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
new file mode 100644
index 0000000..abeea31
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HolyPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        HolyPriestStrategyActionNodeFactory()
+        {
+            creators["smite"] = &smite;
+        }
+    private:
+        static ActionNode* smite(PlayerbotAI* ai)
+        {
+            return new ActionNode ("smite",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
+
+using namespace ai;
+
+HolyPriestStrategy::HolyPriestStrategy(PlayerbotAI* ai) : HealPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new HolyPriestStrategyActionNodeFactory());
+}
+
+NextAction** HolyPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("holy fire", 10.0f), new NextAction("smite", 10.0f), NULL);
+}
+
+void HolyPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    HealPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
new file mode 100644
index 0000000..c21bcf1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategy : public HealPriestStrategy
+    {
+    public:
+        HolyPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "holy"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.cpp b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
new file mode 100644
index 0000000..8760005
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
+
+NextAction** CastAbolishDiseaseAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease"), NULL), CastSpellAction::getAlternatives());
+}
+
+NextAction** CastAbolishDiseaseOnPartyAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease on party"), NULL), CastSpellAction::getAlternatives());
+}
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.h b/src/plugins/playerbot/strategy/priest/PriestActions.h
new file mode 100644
index 0000000..bf2ea2d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.h
@@ -0,0 +1,246 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastGreaterHealAction : public CastHealingSpellAction {
+    public:
+        CastGreaterHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "greater heal") {}
+    };
+
+    class CastGreaterHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastGreaterHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "greater heal") {}
+
+        virtual string getName() { return "greater heal on party"; }
+    };
+
+    class CastLesserHealAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser heal") {}
+    };
+
+    class CastLesserHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser heal") {}
+
+        virtual string getName() { return "lesser heal on party"; }
+    };
+
+    class CastFlashHealAction : public CastHealingSpellAction {
+    public:
+        CastFlashHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash heal") {}
+    };
+
+    class CastFlashHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash heal") {}
+
+        virtual string getName() { return "flash heal on party"; }
+    };
+
+    class CastHealAction : public CastHealingSpellAction {
+    public:
+        CastHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "heal") {}
+    };
+
+    class CastHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "heal") {}
+
+        virtual string getName() { return "heal on party"; }
+    };
+
+    class CastRenewAction : public CastHealingSpellAction {
+    public:
+        CastRenewAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "renew") {}
+    };
+
+    class CastRenewOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRenewOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "renew") {}
+
+        virtual string getName() { return "renew on party"; }
+    };
+
+    class CastFadeAction : public CastBuffSpellAction {
+    public:
+        CastFadeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fade") {}
+    };
+
+    class CastShadowformAction : public CastBuffSpellAction {
+    public:
+        CastShadowformAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadowform") {}
+    };
+
+    class CastRemoveShadowformAction : public Action {
+    public:
+        CastRemoveShadowformAction(PlayerbotAI* ai) : Action(ai, "remove shadowform") {}
+        virtual bool isUseful() { return ai->HasAura("shadowform", AI_VALUE(Unit*, "self target")); }
+        virtual bool isPossible() { return true; }
+        virtual bool Execute(Event event) {
+            ai->RemoveAura("shadowform");
+            return true;
+        }
+    };
+
+	class CastVampiricEmbraceAction : public CastBuffSpellAction {
+	public:
+		CastVampiricEmbraceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vampiric embrace") {}
+	};
+
+	class CastPowerWordShieldAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: shield") {}
+	};
+
+    class CastPowerWordShieldOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastPowerWordShieldOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "power word: shield") {}
+
+        virtual string getName() { return "power word: shield on party"; }
+    };
+
+	class CastPowerWordFortitudeAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordFortitudeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritAction : public CastBuffSpellAction {
+	public:
+		CastDivineSpiritAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine spirit") {}
+	};
+
+	class CastInnerFireAction : public CastBuffSpellAction {
+	public:
+		CastInnerFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "inner fire") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastHolyNovaAction, "holy nova")
+    virtual bool isUseful() {
+        return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+    }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastHolyFireAction, "holy fire")
+        virtual bool isUseful() {
+            return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSmiteAction, "smite")
+        virtual bool isUseful() {
+			return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+	class CastPowerWordFortitudeOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastPowerWordFortitudeOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastDivineSpiritOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "divine spirit") {}
+	};
+
+	class CastPowerWordPainAction : public CastDebuffSpellAction
+	{
+    public:
+	    CastPowerWordPainAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "shadow word: pain") {}
+	};
+
+	class CastPowerWordPainOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+    public:
+	    CastPowerWordPainOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "shadow word: pain") {}
+	};
+
+    BEGIN_DEBUFF_ACTION(CastDevouringPlagueAction, "devouring plague")
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastVampiricTouchAction, "vampiric touch")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindBlastAction, "mind blast")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindFlayAction, "mind flay")
+    END_SPELL_ACTION()
+
+	class CastCureDiseaseAction : public CastCureSpellAction {
+	public:
+		CastCureDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure disease") {}
+	};
+
+    class CastCureDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCureDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "cure disease on party"; }
+    };
+
+	class CastAbolishDiseaseAction : public CastCureSpellAction {
+	public:
+		CastAbolishDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish disease") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "abolish disease on party"; }
+        virtual NextAction** getAlternatives();
+    };
+
+	class CastDispelMagicAction : public CastCureSpellAction {
+	public:
+		CastDispelMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "dispel magic") {}
+	};
+
+    class CastDispelMagicOnTargetAction : public CastSpellAction {
+    public:
+        CastDispelMagicOnTargetAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispel magic") {}
+    };
+
+    class CastDispelMagicOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastDispelMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "dispel magic", DISPEL_MAGIC) {}
+        virtual string getName() { return "dispel magic on party"; }
+    };
+
+	class CastResurrectionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastResurrectionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "resurrection") {}
+	};
+
+	class CastCircleOfHealingAction : public CastAoeHealSpellAction
+	{
+	public:
+		CastCircleOfHealingAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "circle of healing") {}
+	};
+
+	class CastPsychicScreamAction : public CastSpellAction
+	{
+	public:
+	    CastPsychicScreamAction(PlayerbotAI* ai) : CastSpellAction(ai, "psychic scream") {}
+	};
+
+	class CastDispersionAction : public CastSpellAction
+	{
+	public:
+	    CastDispersionAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispersion") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
new file mode 100644
index 0000000..8a40b2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
@@ -0,0 +1,217 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+#include "PriestAiObjectContext.h"
+#include "PriestNonCombatStrategy.h"
+#include "ShadowPriestStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "PriestTriggers.h"
+#include "../NamedObjectContext.h"
+#include "HolyPriestStrategy.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &priest::StrategyFactoryInternal::nc;
+                creators["pull"] = &priest::StrategyFactoryInternal::pull;
+                creators["aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["shadow aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["dps debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+                creators["shadow debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new PriestNonCombatStrategy(ai); }
+            static Strategy* shadow_aoe(PlayerbotAI* ai) { return new ShadowPriestAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* shadow_debuff(PlayerbotAI* ai) { return new ShadowPriestDebuffStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &priest::CombatStrategyFactoryInternal::heal;
+                creators["shadow"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["holy"] = &priest::CombatStrategyFactoryInternal::holy;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealPriestStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new ShadowPriestStrategy(ai); }
+            static Strategy* holy(PlayerbotAI* ai) { return new HolyPriestStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["devouring plague"] = &TriggerFactoryInternal::devouring_plague;
+                creators["shadow word: pain"] = &TriggerFactoryInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &TriggerFactoryInternal::shadow_word_pain_on_attacker;
+                creators["dispel magic"] = &TriggerFactoryInternal::dispel_magic;
+                creators["dispel magic on party"] = &TriggerFactoryInternal::dispel_magic_party_member;
+                creators["cure disease"] = &TriggerFactoryInternal::cure_disease;
+                creators["party member cure disease"] = &TriggerFactoryInternal::party_member_cure_disease;
+                creators["power word: fortitude"] = &TriggerFactoryInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &TriggerFactoryInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &TriggerFactoryInternal::divine_spirit;
+                creators["divine spirit on party"] = &TriggerFactoryInternal::divine_spirit_on_party;
+                creators["inner fire"] = &TriggerFactoryInternal::inner_fire;
+                creators["vampiric touch"] = &TriggerFactoryInternal::vampiric_touch;
+                creators["shadowform"] = &TriggerFactoryInternal::shadowform;
+                creators["vampiric embrace"] = &TriggerFactoryInternal::vampiric_embrace;
+
+            }
+
+        private:
+            static Trigger* vampiric_embrace(PlayerbotAI* ai) { return new VampiricEmbraceTrigger(ai); }
+            static Trigger* shadowform(PlayerbotAI* ai) { return new ShadowformTrigger(ai); }
+            static Trigger* vampiric_touch(PlayerbotAI* ai) { return new VampiricTouchTrigger(ai); }
+            static Trigger* devouring_plague(PlayerbotAI* ai) { return new DevouringPlagueTrigger(ai); }
+            static Trigger* shadow_word_pain(PlayerbotAI* ai) { return new PowerWordPainTrigger(ai); }
+            static Trigger* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new PowerWordPainOnAttackerTrigger(ai); }
+            static Trigger* dispel_magic(PlayerbotAI* ai) { return new DispelMagicTrigger(ai); }
+            static Trigger* dispel_magic_party_member(PlayerbotAI* ai) { return new DispelMagicPartyMemberTrigger(ai); }
+            static Trigger* cure_disease(PlayerbotAI* ai) { return new CureDiseaseTrigger(ai); }
+            static Trigger* party_member_cure_disease(PlayerbotAI* ai) { return new PartyMemberCureDiseaseTrigger(ai); }
+            static Trigger* power_word_fortitude(PlayerbotAI* ai) { return new PowerWordFortitudeTrigger(ai); }
+            static Trigger* power_word_fortitude_on_party(PlayerbotAI* ai) { return new PowerWordFortitudeOnPartyTrigger(ai); }
+            static Trigger* divine_spirit(PlayerbotAI* ai) { return new DivineSpiritTrigger(ai); }
+            static Trigger* divine_spirit_on_party(PlayerbotAI* ai) { return new DivineSpiritOnPartyTrigger(ai); }
+            static Trigger* inner_fire(PlayerbotAI* ai) { return new InnerFireTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["shadow word: pain"] = &AiObjectContextInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &AiObjectContextInternal::shadow_word_pain_on_attacker;
+                creators["devouring plague"] = &AiObjectContextInternal::devouring_plague;
+                creators["mind flay"] = &AiObjectContextInternal::mind_flay;
+                creators["holy fire"] = &AiObjectContextInternal::holy_fire;
+                creators["smite"] = &AiObjectContextInternal::smite;
+                creators["mind blast"] = &AiObjectContextInternal::mind_blast;
+                creators["shadowform"] = &AiObjectContextInternal::shadowform;
+                creators["remove shadowform"] = &AiObjectContextInternal::remove_shadowform;
+                creators["holy nova"] = &AiObjectContextInternal::holy_nova;
+                creators["power word: fortitude"] = &AiObjectContextInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &AiObjectContextInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &AiObjectContextInternal::divine_spirit;
+                creators["divine spirit on party"] = &AiObjectContextInternal::divine_spirit_on_party;
+                creators["power word: shield"] = &AiObjectContextInternal::power_word_shield;
+                creators["power word: shield on party"] = &AiObjectContextInternal::power_word_shield_on_party;
+                creators["renew"] = &AiObjectContextInternal::renew;
+                creators["renew on party"] = &AiObjectContextInternal::renew_on_party;
+                creators["greater heal"] = &AiObjectContextInternal::greater_heal;
+                creators["greater heal on party"] = &AiObjectContextInternal::greater_heal_on_party;
+                creators["heal"] = &AiObjectContextInternal::heal;
+                creators["heal on party"] = &AiObjectContextInternal::heal_on_party;
+                creators["lesser heal"] = &AiObjectContextInternal::lesser_heal;
+                creators["lesser heal on party"] = &AiObjectContextInternal::lesser_heal_on_party;
+                creators["flash heal"] = &AiObjectContextInternal::flash_heal;
+                creators["flash heal on party"] = &AiObjectContextInternal::flash_heal_on_party;
+                creators["dispel magic"] = &AiObjectContextInternal::dispel_magic;
+                creators["dispel magic on party"] = &AiObjectContextInternal::dispel_magic_on_party;
+                creators["dispel magic on target"] = &AiObjectContextInternal::dispel_magic_on_target;
+                creators["cure disease"] = &AiObjectContextInternal::cure_disease;
+                creators["cure disease on party"] = &AiObjectContextInternal::cure_disease_on_party;
+                creators["abolish disease"] = &AiObjectContextInternal::abolish_disease;
+                creators["abolish disease on party"] = &AiObjectContextInternal::abolish_disease_on_party;
+                creators["fade"] = &AiObjectContextInternal::fade;
+                creators["inner fire"] = &AiObjectContextInternal::inner_fire;
+                creators["resurrection"] = &AiObjectContextInternal::resurrection;
+                creators["circle of healing"] = &AiObjectContextInternal::circle_of_healing;
+                creators["psychic scream"] = &AiObjectContextInternal::psychic_scream;
+                creators["vampiric touch"] = &AiObjectContextInternal::vampiric_touch;
+                creators["vampiric embrace"] = &AiObjectContextInternal::vampiric_embrace;
+                creators["dispersion"] = &AiObjectContextInternal::dispersion;
+            }
+
+        private:
+            static Action* dispersion(PlayerbotAI* ai) { return new CastDispersionAction(ai); }
+            static Action* vampiric_embrace(PlayerbotAI* ai) { return new CastVampiricEmbraceAction(ai); }
+            static Action* vampiric_touch(PlayerbotAI* ai) { return new CastVampiricTouchAction(ai); }
+            static Action* psychic_scream(PlayerbotAI* ai) { return new CastPsychicScreamAction(ai); }
+            static Action* circle_of_healing(PlayerbotAI* ai) { return new CastCircleOfHealingAction(ai); }
+            static Action* resurrection(PlayerbotAI* ai) { return new CastResurrectionAction(ai); }
+            static Action* shadow_word_pain(PlayerbotAI* ai) { return new CastPowerWordPainAction(ai); }
+            static Action* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new CastPowerWordPainOnAttackerAction(ai); }
+            static Action* devouring_plague(PlayerbotAI* ai) { return new CastDevouringPlagueAction(ai); }
+            static Action* mind_flay(PlayerbotAI* ai) { return new CastMindFlayAction(ai); }
+            static Action* holy_fire(PlayerbotAI* ai) { return new CastHolyFireAction(ai); }
+            static Action* smite(PlayerbotAI* ai) { return new CastSmiteAction(ai); }
+            static Action* mind_blast(PlayerbotAI* ai) { return new CastMindBlastAction(ai); }
+            static Action* shadowform(PlayerbotAI* ai) { return new CastShadowformAction(ai); }
+            static Action* remove_shadowform(PlayerbotAI* ai) { return new CastRemoveShadowformAction(ai); }
+            static Action* holy_nova(PlayerbotAI* ai) { return new CastHolyNovaAction(ai); }
+            static Action* power_word_fortitude(PlayerbotAI* ai) { return new CastPowerWordFortitudeAction(ai); }
+            static Action* power_word_fortitude_on_party(PlayerbotAI* ai) { return new CastPowerWordFortitudeOnPartyAction(ai); }
+            static Action* divine_spirit(PlayerbotAI* ai) { return new CastDivineSpiritAction(ai); }
+            static Action* divine_spirit_on_party(PlayerbotAI* ai) { return new CastDivineSpiritOnPartyAction(ai); }
+            static Action* power_word_shield(PlayerbotAI* ai) { return new CastPowerWordShieldAction(ai); }
+            static Action* power_word_shield_on_party(PlayerbotAI* ai) { return new CastPowerWordShieldOnPartyAction(ai); }
+            static Action* renew(PlayerbotAI* ai) { return new CastRenewAction(ai); }
+            static Action* renew_on_party(PlayerbotAI* ai) { return new CastRenewOnPartyAction(ai); }
+            static Action* greater_heal(PlayerbotAI* ai) { return new CastGreaterHealAction(ai); }
+            static Action* greater_heal_on_party(PlayerbotAI* ai) { return new CastGreaterHealOnPartyAction(ai); }
+            static Action* heal(PlayerbotAI* ai) { return new CastHealAction(ai); }
+            static Action* heal_on_party(PlayerbotAI* ai) { return new CastHealOnPartyAction(ai); }
+            static Action* lesser_heal(PlayerbotAI* ai) { return new CastLesserHealAction(ai); }
+            static Action* lesser_heal_on_party(PlayerbotAI* ai) { return new CastLesserHealOnPartyAction(ai); }
+            static Action* flash_heal(PlayerbotAI* ai) { return new CastFlashHealAction(ai); }
+            static Action* flash_heal_on_party(PlayerbotAI* ai) { return new CastFlashHealOnPartyAction(ai); }
+            static Action* dispel_magic(PlayerbotAI* ai) { return new CastDispelMagicAction(ai); }
+            static Action* dispel_magic_on_party(PlayerbotAI* ai) { return new CastDispelMagicOnPartyAction(ai); }
+            static Action* dispel_magic_on_target(PlayerbotAI* ai) { return new CastDispelMagicOnTargetAction(ai); }
+            static Action* cure_disease(PlayerbotAI* ai) { return new CastCureDiseaseAction(ai); }
+            static Action* cure_disease_on_party(PlayerbotAI* ai) { return new CastCureDiseaseOnPartyAction(ai); }
+            static Action* abolish_disease(PlayerbotAI* ai) { return new CastAbolishDiseaseAction(ai); }
+            static Action* abolish_disease_on_party(PlayerbotAI* ai) { return new CastAbolishDiseaseOnPartyAction(ai); }
+            static Action* fade(PlayerbotAI* ai) { return new CastFadeAction(ai); }
+            static Action* inner_fire(PlayerbotAI* ai) { return new CastInnerFireAction(ai); }
+        };
+    };
+};
+
+PriestAiObjectContext::PriestAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::priest::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::priest::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::priest::AiObjectContextInternal());
+    triggerContexts.Add(new ai::priest::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
new file mode 100644
index 0000000..315c335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PriestAiObjectContext : public AiObjectContext
+    {
+    public:
+        PriestAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
new file mode 100644
index 0000000..fced53e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.h b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
new file mode 100644
index 0000000..a4d846b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestNonCombatStrategy.h"
+#include "PriestNonCombatStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+PriestNonCombatStrategy::PriestNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new PriestNonCombatStrategyActionNodeFactory());
+}
+
+void PriestNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude",
+        NextAction::array(0, new NextAction("power word: fortitude", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude on party",
+        NextAction::array(0, new NextAction("power word: fortitude on party", 11.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit",
+        NextAction::array(0, new NextAction("divine spirit", 14.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit on party",
+        NextAction::array(0, new NextAction("divine spirit on party", 13.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "inner fire",
+        NextAction::array(0, new NextAction("inner fire", 10.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("greater heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("greater heal on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("flash heal", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("resurrection", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
new file mode 100644
index 0000000..da82e1a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class PriestNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        PriestNonCombatStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "nc"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
new file mode 100644
index 0000000..7af5e3d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
@@ -0,0 +1,126 @@
+#pragma once
+
+namespace ai
+{
+    class PriestNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        PriestNonCombatStrategyActionNodeFactory()
+        {
+            creators["holy nova"] = &holy_nova;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["circle of healing"] = &circle_of_healing;
+        }
+    private:
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* circle_of_healing(PlayerbotAI* ai)
+        {
+            return new ActionNode ("circle of healing",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("flash heal on party"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
new file mode 100644
index 0000000..941041c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestTriggers.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.h b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
new file mode 100644
index 0000000..83b43c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
@@ -0,0 +1,54 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(PowerWordFortitudeOnPartyTrigger, "power word: fortitude", "power word: fortitude on party")
+    BUFF_TRIGGER(PowerWordFortitudeTrigger, "power word: fortitude", "power word: fortitude")
+
+    BUFF_ON_PARTY_TRIGGER(DivineSpiritOnPartyTrigger, "divine spirit", "divine spirit on party")
+    BUFF_TRIGGER(DivineSpiritTrigger, "divine spirit", "divine spirit")
+    BUFF_TRIGGER(InnerFireTrigger, "inner fire", "inner fire")
+    BUFF_TRIGGER(VampiricEmbraceTrigger, "vampiric embrace", "vampiric embrace")
+
+    class PowerWordPainOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        PowerWordPainOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "shadow word: pain") {}
+    };
+
+    DEBUFF_TRIGGER(PowerWordPainTrigger, "shadow word: pain", "shadow word: pain")
+    DEBUFF_TRIGGER(DevouringPlagueTrigger, "devouring plague", "devouring plague")
+    DEBUFF_TRIGGER(VampiricTouchTrigger, "vampiric touch", "vampiric touch")
+
+    class DispelMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        DispelMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class DispelMagicPartyMemberTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        DispelMagicPartyMemberTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class CureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCureDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCureDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class ShadowformTrigger : public BuffTrigger {
+    public:
+        ShadowformTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadowform") {}
+        virtual bool IsActive() { return !ai->HasAura("shadowform", bot); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
new file mode 100644
index 0000000..718794c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "ShadowPriestStrategy.h"
+#include "ShadowPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+ShadowPriestStrategy::ShadowPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new ShadowPriestStrategyActionNodeFactory());
+}
+
+NextAction** ShadowPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mind blast", 10.0f), NULL);
+}
+
+void ShadowPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadowform",
+        NextAction::array(0, new NextAction("shadowform", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("dispersion", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric embrace",
+        NextAction::array(0, new NextAction("vampiric embrace", 16.0f), NULL)));
+}
+
+void ShadowPriestAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain on attacker",
+        NextAction::array(0, new NextAction("shadow word: pain on attacker", 11.0f), NULL)));
+}
+
+void ShadowPriestDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "devouring plague",
+        NextAction::array(0, new NextAction("devouring plague", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric touch",
+        NextAction::array(0, new NextAction("vampiric touch", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain",
+        NextAction::array(0, new NextAction("shadow word: pain", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
new file mode 100644
index 0000000..3097f4a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class ShadowPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        ShadowPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+
+    class ShadowPriestAoeStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow aoe"; }
+    };
+
+    class ShadowPriestDebuffStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..bae7d23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
@@ -0,0 +1,37 @@
+#pragma once
+
+namespace ai
+{
+    class ShadowPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShadowPriestStrategyActionNodeFactory()
+        {
+            creators["mind flay"] = &mind_flay;
+            creators["mind blast"] = &mind_blast;
+            creators["dispersion"] = &dispersion;
+        }
+    private:
+        static ActionNode* mind_flay(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind flay",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* mind_blast(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind blast",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mind flay"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* dispersion(PlayerbotAI* ai)
+        {
+            return new ActionNode ("dispersion",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
new file mode 100644
index 0000000..650ac60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
@@ -0,0 +1,110 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "DpsRogueStrategy.h"
+
+using namespace ai;
+
+class DpsRogueStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsRogueStrategyActionNodeFactory()
+    {
+        creators["riposte"] = &riposte;
+        creators["mutilate"] = &mutilate;
+        creators["sinister strike"] = &sinister_strike;
+        creators["kick"] = &kick;
+        creators["kidney shot"] = &kidney_shot;
+        creators["rupture"] = &rupture;
+        creators["backstab"] = &backstab;
+    }
+private:
+    static ActionNode* riposte(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riposte",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mutilate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mutilate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sinister strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* sinister_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("sinister strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kick(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kick",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("kidney shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kidney_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kidney shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rupture(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rupture",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("eviscerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* backstab(PlayerbotAI* ai)
+    {
+        return new ActionNode ("backstab",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsRogueStrategy::DpsRogueStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsRogueStrategyActionNodeFactory());
+}
+
+NextAction** DpsRogueStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("riposte", ACTION_NORMAL), NULL);
+}
+
+void DpsRogueStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("rupture", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium threat",
+		NextAction::array(0, new NextAction("vanish", ACTION_HIGH), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("evasion", ACTION_EMERGENCY), new NextAction("feint", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick",
+		NextAction::array(0, new NextAction("kick", ACTION_INTERRUPT + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick on enemy healer",
+		NextAction::array(0, new NextAction("kick on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "behind target",
+        NextAction::array(0, new NextAction("backstab", ACTION_NORMAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
new file mode 100644
index 0000000..77e2249
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class DpsRogueStrategy : public MeleeCombatStrategy
+    {
+    public:
+        DpsRogueStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
new file mode 100644
index 0000000..0afb767
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueMultipliers.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
+void GenericRogueNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+        
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
new file mode 100644
index 0000000..2d78612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericRogueNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericRogueNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.cpp b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
new file mode 100644
index 0000000..aba6061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.h b/src/plugins/playerbot/strategy/rogue/RogueActions.h
new file mode 100644
index 0000000..a7a78eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "RogueComboActions.h"
+#include "RogueOpeningActions.h"
+#include "RogueFinishingActions.h"
+
+namespace ai
+{
+	class CastEvasionAction : public CastBuffSpellAction
+	{
+	public:
+		CastEvasionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "evasion") {}
+	};
+
+	class CastSprintAction : public CastBuffSpellAction
+	{
+	public:
+		CastSprintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "sprint") {}
+	};
+
+	class CastKickAction : public CastSpellAction
+	{
+	public:
+		CastKickAction(PlayerbotAI* ai) : CastSpellAction(ai, "kick") {}
+	};
+
+	class CastFeintAction : public CastBuffSpellAction
+	{
+	public:
+		CastFeintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feint") {}
+	};
+
+	class CastDismantleAction : public CastSpellAction
+	{
+	public:
+		CastDismantleAction(PlayerbotAI* ai) : CastSpellAction(ai, "dismantle") {}
+	};
+
+	class CastDistractAction : public CastSpellAction
+	{
+	public:
+		CastDistractAction(PlayerbotAI* ai) : CastSpellAction(ai, "distract") {}
+	};
+
+	class CastVanishAction : public CastBuffSpellAction
+	{
+	public:
+		CastVanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vanish") {}
+	};
+
+	class CastBlindAction : public CastDebuffSpellAction
+	{
+	public:
+		CastBlindAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "blind") {}
+	};
+
+
+	class CastBladeFlurryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBladeFlurryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blade flurry") {}
+	};
+
+	class CastAdrenalineRushAction : public CastBuffSpellAction
+	{
+	public:
+		CastAdrenalineRushAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "adrenaline rush") {}
+	};
+
+	class CastKillingSpreeAction : public CastBuffSpellAction
+	{
+	public:
+		CastKillingSpreeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "killing spree") {}
+	};
+
+    class CastKickOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastKickOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
new file mode 100644
index 0000000..fdca0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
@@ -0,0 +1,119 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+#include "RogueTriggers.h"
+#include "RogueAiObjectContext.h"
+#include "DpsRogueStrategy.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &rogue::StrategyFactoryInternal::dps;
+                creators["nc"] = &rogue::StrategyFactoryInternal::nc;
+                creators["pull"] = &rogue::StrategyFactoryInternal::pull;
+            }
+
+        private:
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsRogueStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericRogueNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["kick"] = &TriggerFactoryInternal::kick;
+                creators["rupture"] = &TriggerFactoryInternal::rupture;
+                creators["slice and dice"] = &TriggerFactoryInternal::slice_and_dice;
+                creators["expose armor"] = &TriggerFactoryInternal::expose_armor;
+                creators["kick on enemy healer"] = &TriggerFactoryInternal::kick_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* kick(PlayerbotAI* ai) { return new KickInterruptSpellTrigger(ai); }
+            static Trigger* rupture(PlayerbotAI* ai) { return new RuptureTrigger(ai); }
+            static Trigger* slice_and_dice(PlayerbotAI* ai) { return new SliceAndDiceTrigger(ai); }
+            static Trigger* expose_armor(PlayerbotAI* ai) { return new ExposeArmorTrigger(ai); }
+            static Trigger* kick_on_enemy_healer(PlayerbotAI* ai) { return new KickInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["riposte"] = &AiObjectContextInternal::riposte;
+                creators["mutilate"] = &AiObjectContextInternal::mutilate;
+                creators["sinister strike"] = &AiObjectContextInternal::sinister_strike;
+                creators["kidney shot"] = &AiObjectContextInternal::kidney_shot;
+                creators["rupture"] = &AiObjectContextInternal::rupture;
+                creators["slice and dice"] = &AiObjectContextInternal::slice_and_dice;
+                creators["eviscerate"] = &AiObjectContextInternal::eviscerate;
+                creators["vanish"] = &AiObjectContextInternal::vanish;
+                creators["evasion"] = &AiObjectContextInternal::evasion;
+                creators["kick"] = &AiObjectContextInternal::kick;
+                creators["feint"] = &AiObjectContextInternal::feint;
+                creators["backstab"] = &AiObjectContextInternal::backstab;
+                creators["expose armor"] = &AiObjectContextInternal::expose_armor;
+                creators["kick on enemy healer"] = &AiObjectContextInternal::kick_on_enemy_healer;
+            }
+
+        private:
+            static Action* riposte(PlayerbotAI* ai) { return new CastRiposteAction(ai); }
+            static Action* mutilate(PlayerbotAI* ai) { return new CastMutilateAction(ai); }
+            static Action* sinister_strike(PlayerbotAI* ai) { return new CastSinisterStrikeAction(ai); }
+            static Action* kidney_shot(PlayerbotAI* ai) { return new CastKidneyShotAction(ai); }
+            static Action* rupture(PlayerbotAI* ai) { return new CastRuptureAction(ai); }
+            static Action* slice_and_dice(PlayerbotAI* ai) { return new CastSliceAndDiceAction(ai); }
+            static Action* eviscerate(PlayerbotAI* ai) { return new CastEviscerateAction(ai); }
+            static Action* vanish(PlayerbotAI* ai) { return new CastVanishAction(ai); }
+            static Action* evasion(PlayerbotAI* ai) { return new CastEvasionAction(ai); }
+            static Action* kick(PlayerbotAI* ai) { return new CastKickAction(ai); }
+            static Action* feint(PlayerbotAI* ai) { return new CastFeintAction(ai); }
+            static Action* backstab(PlayerbotAI* ai) { return new CastBackstabAction(ai); }
+            static Action* expose_armor(PlayerbotAI* ai) { return new CastExposeArmorAction(ai); }
+            static Action* kick_on_enemy_healer(PlayerbotAI* ai) { return new CastKickOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+RogueAiObjectContext::RogueAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::rogue::StrategyFactoryInternal());
+    actionContexts.Add(new ai::rogue::AiObjectContextInternal());
+    triggerContexts.Add(new ai::rogue::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
new file mode 100644
index 0000000..ba34626
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class RogueAiObjectContext : public AiObjectContext
+    {
+    public:
+        RogueAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueComboActions.h b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
new file mode 100644
index 0000000..186e2eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
@@ -0,0 +1,45 @@
+#pragma once
+
+namespace ai
+{
+	class CastComboAction : public CastMeleeSpellAction
+	{
+	public:
+	    CastComboAction(PlayerbotAI* ai, string name) : CastMeleeSpellAction(ai, name) {}
+
+	    virtual bool isUseful()
+	    {
+	        return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "combo", "self target") < 5;
+	    }
+	};
+
+	class CastSinisterStrikeAction : public CastComboAction
+	{
+	public:
+		CastSinisterStrikeAction(PlayerbotAI* ai) : CastComboAction(ai, "sinister strike") {}
+	};
+
+    class CastMutilateAction : public CastComboAction
+    {
+    public:
+        CastMutilateAction(PlayerbotAI* ai) : CastComboAction(ai, "mutilate") {}
+    };
+
+    class CastRiposteAction : public CastComboAction
+    {
+    public:
+        CastRiposteAction(PlayerbotAI* ai) : CastComboAction(ai, "riposte") {}
+    };
+
+	class CastGougeAction : public CastComboAction
+	{
+	public:
+		CastGougeAction(PlayerbotAI* ai) : CastComboAction(ai, "gouge") {}
+	};
+
+    class CastBackstabAction : public CastComboAction
+    {
+    public:
+        CastBackstabAction(PlayerbotAI* ai) : CastComboAction(ai, "backstab") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
new file mode 100644
index 0000000..91a078b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
@@ -0,0 +1,35 @@
+#pragma once
+
+namespace ai
+{
+	class CastEviscerateAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastEviscerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "eviscerate") {} 
+	};
+
+	class CastSliceAndDiceAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastSliceAndDiceAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slice and dice") {} 
+	};
+
+	class CastExposeArmorAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastExposeArmorAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "expose armor") {} 
+	};
+
+	class CastRuptureAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastRuptureAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rupture") {} 
+	};
+	
+	class CastKidneyShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastKidneyShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "kidney shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
new file mode 100644
index 0000000..136fd0d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "RogueActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
new file mode 100644
index 0000000..35e0fc3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+	class CastSapAction : public CastMeleeSpellAction
+	{ 
+	public: 
+		CastSapAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "sap") {} 
+	};
+
+	class CastGarroteAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastGarroteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "garrote") {} 
+	};
+
+
+	class CastCheapShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastCheapShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cheap shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
new file mode 100644
index 0000000..8f57d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.h b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
new file mode 100644
index 0000000..8d20e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+
+    class KickInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        KickInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "kick") {}
+    };
+
+    class SliceAndDiceTrigger : public BuffTrigger
+    {
+    public:
+        SliceAndDiceTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "slice and dice") {}
+    };
+
+    class RuptureTrigger : public DebuffTrigger
+    {
+    public:
+        RuptureTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rupture") {}
+    };
+
+    class ExposeArmorTrigger : public DebuffTrigger
+    {
+    public:
+        ExposeArmorTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "expose armor") {}
+    };
+
+    class KickInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        KickInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
new file mode 100644
index 0000000..aa1b6a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+class CasterShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterShamanStrategyActionNodeFactory()
+    {
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+CasterShamanStrategy::CasterShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterShamanStrategyActionNodeFactory());
+}
+
+NextAction** CasterShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("lightning bolt", 10.0f), NULL);
+}
+
+void CasterShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("flametongue weapon", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "frost shock snare",
+        NextAction::array(0, new NextAction("frost shock", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flametongue totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void CasterAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeAoeShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("chain lightning", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("thunderstorm", 26.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
new file mode 100644
index 0000000..f9444c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+
+namespace ai
+{
+    class CasterShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        CasterShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "caster"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterAoeShamanStrategy : public MeleeAoeShamanStrategy
+    {
+    public:
+        CasterAoeShamanStrategy(PlayerbotAI* ai) : MeleeAoeShamanStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
new file mode 100644
index 0000000..18a9c3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
@@ -0,0 +1,159 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class GenericShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericShamanStrategyActionNodeFactory()
+    {
+        creators["flametongue weapon"] = &flametongue_weapon;
+        creators["frostbrand weapon"] = &frostbrand_weapon;
+        creators["windfury weapon"] = &windfury_weapon;
+        creators["lesser healing wave"] = &lesser_healing_wave;
+        creators["lesser healing wave on party"] = &lesser_healing_wave_on_party;
+        creators["chain heal"] = &chain_heal;
+        creators["riptide"] = &riptide;
+        creators["chain heal on party"] = &chain_heal_on_party;
+        creators["riptide on party"] = &riptide_on_party;
+        creators["earth shock"] = &earth_shock;
+    }
+private:
+    static ActionNode* earth_shock(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earth shock",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flame shock"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flametongue_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flametongue weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frostbrand weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frostbrand_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbrand weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* windfury_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("windfury weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericShamanStrategy::GenericShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericShamanStrategyActionNodeFactory());
+}
+
+void GenericShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "wind shear",
+        NextAction::array(0, new NextAction("wind shear", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "wind shear on enemy healer",
+        NextAction::array(0, new NextAction("wind shear on enemy healer", 23.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "purge",
+		NextAction::array(0, new NextAction("purge", 10.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member medium health",
+		NextAction::array(0, new NextAction("lesser healing wave on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member low health",
+		NextAction::array(0, new NextAction("riptide on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium health",
+		NextAction::array(0, new NextAction("lesser healing wave", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("riptide", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"heroism",
+		NextAction::array(0, new NextAction("heroism", 31.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"bloodlust",
+		NextAction::array(0, new NextAction("bloodlust", 30.0f), NULL)));
+}
+
+void ShamanBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "lightning shield",
+        NextAction::array(0, new NextAction("lightning shield", 22.0f), NULL)));
+}
+
+void ShamanBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "water shield",
+        NextAction::array(0, new NextAction("water shield", 22.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
new file mode 100644
index 0000000..fdac460
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericShamanStrategy : public CombatStrategy
+    {
+    public:
+        GenericShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+    class ShamanBuffDpsStrategy : public Strategy
+    {
+    public:
+        ShamanBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+
+    };
+
+    class ShamanBuffManaStrategy : public Strategy
+    {
+    public:
+        ShamanBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
new file mode 100644
index 0000000..0d05326
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class HealShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealShamanStrategyActionNodeFactory()
+    {
+        creators["earthliving weapon"] = &earthliving_weapon;
+        creators["mana tide totem"] = &mana_tide_totem;
+    }
+private:
+    static ActionNode* earthliving_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earthliving weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flametongue weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_tide_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana tide totem",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+
+};
+
+HealShamanStrategy::HealShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new HealShamanStrategyActionNodeFactory());
+}
+
+void HealShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("earthliving weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("mana tide totem", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit poison on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit curse on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit disease on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("healing stream totem", ACTION_LIGHT_HEAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
new file mode 100644
index 0000000..e5d4ff1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class HealShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        HealShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
new file mode 100644
index 0000000..34eab8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
@@ -0,0 +1,93 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "MeleeShamanStrategy.h"
+
+using namespace ai;
+
+class MeleeShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    MeleeShamanStrategyActionNodeFactory()
+    {
+        creators["stormstrike"] = &stormstrike;
+        creators["lava lash"] = &lava_lash;
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* stormstrike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("stormstrike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lava lash"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lava_lash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lava lash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+MeleeShamanStrategy::MeleeShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new MeleeShamanStrategyActionNodeFactory());
+}
+
+NextAction** MeleeShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stormstrike", 10.0f), NULL);
+}
+
+void MeleeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("windfury weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("strength of earth totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void MeleeAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "magma totem",
+        NextAction::array(0, new NextAction("magma totem", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("fire nova", 25.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
new file mode 100644
index 0000000..6c18fb6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class MeleeShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        MeleeShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "melee"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class MeleeAoeShamanStrategy : public CombatStrategy
+    {
+    public:
+        MeleeAoeShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "melee aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
new file mode 100644
index 0000000..ab8b070
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.h b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
new file mode 100644
index 0000000..478d08a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
@@ -0,0 +1,304 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastLesserHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser healing wave") {}
+    };
+
+    class CastLesserHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser healing wave") {}
+    };
+
+
+    class CastHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing wave") {}
+    };
+
+    class CastHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing wave") {}
+    };
+
+    class CastChainHealAction : public CastAoeHealSpellAction {
+    public:
+        CastChainHealAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "chain heal") {}
+    };
+
+    class CastRiptideAction : public CastHealingSpellAction {
+    public:
+        CastRiptideAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "riptide") {}
+    };
+
+    class CastRiptideOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRiptideOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "riptide") {}
+    };
+
+
+    class CastEarthShieldAction : public CastBuffSpellAction {
+    public:
+        CastEarthShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "earth shield") {}
+    };
+
+    class CastEarthShieldOnPartyAction : public BuffOnPartyAction
+    {
+    public:
+        CastEarthShieldOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "earth shield") {}
+    };
+
+    class CastWaterShieldAction : public CastBuffSpellAction {
+    public:
+        CastWaterShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water shield") {}
+    };
+
+	class CastLightningShieldAction : public CastBuffSpellAction {
+	public:
+		CastLightningShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "lightning shield") {}
+	};
+
+    class CastEarthlivingWeaponAction : public CastEnchantItemAction {
+    public:
+        CastEarthlivingWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "earthliving weapon") {}
+    };
+
+    class CastRockbiterWeaponAction : public CastEnchantItemAction {
+    public:
+        CastRockbiterWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "rockbiter weapon") {}
+    };
+
+    class CastFlametongueWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFlametongueWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "flametongue weapon") {}
+    };
+
+    class CastFrostbrandWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFrostbrandWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "frostbrand weapon") {}
+    };
+
+    class CastWindfuryWeaponAction : public CastEnchantItemAction {
+    public:
+        CastWindfuryWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "windfury weapon") {}
+    };
+
+    class CastTotemAction : public CastBuffSpellAction
+    {
+    public:
+        CastTotemAction(PlayerbotAI* ai, string spell) : CastBuffSpellAction(ai, spell) {}
+        virtual bool isUseful() { return CastBuffSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastStoneskinTotemAction : public CastTotemAction
+    {
+    public:
+        CastStoneskinTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "stoneskin totem") {}
+    };
+
+    class CastEarthbindTotemAction : public CastTotemAction
+    {
+    public:
+        CastEarthbindTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "earthbind totem") {}
+    };
+
+    class CastStrengthOfEarthTotemAction : public CastTotemAction
+    {
+    public:
+        CastStrengthOfEarthTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "strength of earth totem") {}
+    };
+
+    class CastManaSpringTotemAction : public CastTotemAction
+    {
+    public:
+        CastManaSpringTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana spring totem") {}
+    };
+
+	class CastManaTideTotemAction : public CastTotemAction
+	{
+	public:
+		CastManaTideTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana tide totem") {}
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastHealingStreamTotemAction : public CastTotemAction
+	{
+	public:
+		CastHealingStreamTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "healing stream totem") {}
+	};
+
+    class CastCleansingTotemAction : public CastTotemAction
+    {
+    public:
+        CastCleansingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "cleansing totem") {}
+    };
+
+    class CastFlametongueTotemAction : public CastTotemAction
+    {
+    public:
+        CastFlametongueTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "flametongue totem") {}
+    };
+
+    class CastWindfuryTotemAction : public CastTotemAction
+    {
+    public:
+        CastWindfuryTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "windfury totem") {}
+    };
+
+    class CastSearingTotemAction : public CastTotemAction
+    {
+    public:
+        CastSearingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "searing totem") {}
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastMagmaTotemAction : public CastMeleeSpellAction
+    {
+    public:
+        CastMagmaTotemAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "magma totem") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastFireNovaAction : public CastSpellAction {
+    public:
+        CastFireNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire nova") {}
+    };
+
+    class CastWindShearAction : public CastSpellAction {
+    public:
+        CastWindShearAction(PlayerbotAI* ai) : CastSpellAction(ai, "wind shear") {}
+    };
+
+	class CastAncestralSpiritAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastAncestralSpiritAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "ancestral spirit") {}
+	};
+
+
+	class CastPurgeAction : public CastSpellAction
+	{
+	public:
+		CastPurgeAction(PlayerbotAI* ai) : CastSpellAction(ai, "purge") {}
+	};
+
+	class CastStormstrikeAction : public CastMeleeSpellAction {
+	public:
+		CastStormstrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "stormstrike") {}
+	};
+
+	class CastLavaLashAction : public CastMeleeSpellAction {
+	public:
+		CastLavaLashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lava lash") {}
+	};
+
+    class CastWaterBreathingAction : public CastBuffSpellAction {
+    public:
+        CastWaterBreathingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingAction : public CastBuffSpellAction {
+    public:
+        CastWaterWalkingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water walking") {}
+    };
+
+    class CastWaterBreathingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterBreathingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterWalkingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water walking") {}
+    };
+
+
+    class CastCleanseSpiritAction : public CastCureSpellAction {
+    public:
+        CastCleanseSpiritAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse spirit") {}
+    };
+
+    class CastCleanseSpiritPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse spirit poison on party"; }
+    };
+    class CastCleanseSpiritCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_CURSE) {}
+
+        virtual string getName() { return "cleanse spirit curse on party"; }
+    };
+    class CastCleanseSpiritDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_DISEASE) {}
+
+        virtual string getName() { return "cleanse spirit disease on party"; }
+    };
+
+    class CastFlameShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFlameShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "flame shock") {}
+    };
+
+    class CastEarthShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastEarthShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "earth shock") {}
+    };
+
+    class CastFrostShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFrostShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "frost shock") {}
+    };
+
+    class CastChainLightningAction : public CastSpellAction
+    {
+    public:
+        CastChainLightningAction(PlayerbotAI* ai) : CastSpellAction(ai, "chain lightning") {}
+    };
+
+    class CastLightningBoltAction : public CastSpellAction
+    {
+    public:
+        CastLightningBoltAction(PlayerbotAI* ai) : CastSpellAction(ai, "lightning bolt") {}
+    };
+
+    class CastThunderstormAction : public CastMeleeSpellAction
+    {
+    public:
+        CastThunderstormAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "thunderstorm") {}
+    };
+
+    class CastHeroismAction : public CastBuffSpellAction
+    {
+    public:
+        CastHeroismAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "heroism") {}
+    };
+
+    class CastBloodlustAction : public CastBuffSpellAction
+    {
+    public:
+        CastBloodlustAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodlust") {}
+    };
+
+    class CastWindShearOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastWindShearOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
new file mode 100644
index 0000000..cbd8ec3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
@@ -0,0 +1,268 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+#include "ShamanAiObjectContext.h"
+#include "ShamanNonCombatStrategy.h"
+#include "HealShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+#include "ShamanTriggers.h"
+#include "../NamedObjectContext.h"
+#include "TotemsShamanStrategy.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &shaman::StrategyFactoryInternal::nc;
+                creators["totems"] = &shaman::StrategyFactoryInternal::totems;
+                creators["melee aoe"] = &shaman::StrategyFactoryInternal::melee_aoe;
+                creators["caster aoe"] = &shaman::StrategyFactoryInternal::caster_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new ShamanNonCombatStrategy(ai); }
+            static Strategy* totems(PlayerbotAI* ai) { return new TotemsShamanStrategy(ai); }
+            static Strategy* melee_aoe(PlayerbotAI* ai) { return new MeleeAoeShamanStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterAoeShamanStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &shaman::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &shaman::BuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new ShamanBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new ShamanBuffDpsStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &shaman::CombatStrategyFactoryInternal::heal;
+                creators["melee"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["caster"] = &shaman::CombatStrategyFactoryInternal::caster;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealShamanStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new MeleeShamanStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterShamanStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["windfury totem"] = &TriggerFactoryInternal::windfury_totem;
+                creators["mana spring totem"] = &TriggerFactoryInternal::mana_spring_totem;
+                creators["flametongue totem"] = &TriggerFactoryInternal::flametongue_totem;
+                creators["strength of earth totem"] = &TriggerFactoryInternal::strength_of_earth_totem;
+                creators["magma totem"] = &TriggerFactoryInternal::magma_totem;
+                creators["searing totem"] = &TriggerFactoryInternal::searing_totem;
+                creators["wind shear"] = &TriggerFactoryInternal::wind_shear;
+                creators["purge"] = &TriggerFactoryInternal::purge;
+                creators["shaman weapon"] = &TriggerFactoryInternal::shaman_weapon;
+                creators["water shield"] = &TriggerFactoryInternal::water_shield;
+                creators["lightning shield"] = &TriggerFactoryInternal::lightning_shield;
+                creators["water breathing"] = &TriggerFactoryInternal::water_breathing;
+                creators["water walking"] = &TriggerFactoryInternal::water_walking;
+                creators["water breathing on party"] = &TriggerFactoryInternal::water_breathing_on_party;
+                creators["water walking on party"] = &TriggerFactoryInternal::water_walking_on_party;
+                creators["cleanse spirit poison"] = &TriggerFactoryInternal::cleanse_poison;
+                creators["cleanse spirit curse"] = &TriggerFactoryInternal::cleanse_curse;
+                creators["cleanse spirit disease"] = &TriggerFactoryInternal::cleanse_disease;
+                creators["party member cleanse spirit poison"] = &TriggerFactoryInternal::party_member_cleanse_poison;
+                creators["party member cleanse spirit curse"] = &TriggerFactoryInternal::party_member_cleanse_curse;
+                creators["party member cleanse spirit disease"] = &TriggerFactoryInternal::party_member_cleanse_disease;
+                creators["shock"] = &TriggerFactoryInternal::shock;
+                creators["frost shock snare"] = &TriggerFactoryInternal::frost_shock_snare;
+                creators["heroism"] = &TriggerFactoryInternal::heroism;
+                creators["bloodlust"] = &TriggerFactoryInternal::bloodlust;
+                creators["maelstrom weapon"] = &TriggerFactoryInternal::maelstrom_weapon;
+                creators["wind shear on enemy healer"] = &TriggerFactoryInternal::wind_shear_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* maelstrom_weapon(PlayerbotAI* ai) { return new MaelstromWeaponTrigger(ai); }
+            static Trigger* heroism(PlayerbotAI* ai) { return new HeroismTrigger(ai); }
+            static Trigger* bloodlust(PlayerbotAI* ai) { return new BloodlustTrigger(ai); }
+            static Trigger* party_member_cleanse_disease(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* party_member_cleanse_curse(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritCurseTrigger(ai); }
+            static Trigger* party_member_cleanse_poison(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritPoisonTrigger(ai); }
+            static Trigger* cleanse_disease(PlayerbotAI* ai) { return new CleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* cleanse_curse(PlayerbotAI* ai) { return new CleanseSpiritCurseTrigger(ai); }
+            static Trigger* cleanse_poison(PlayerbotAI* ai) { return new CleanseSpiritPoisonTrigger(ai); }
+            static Trigger* water_breathing(PlayerbotAI* ai) { return new WaterBreathingTrigger(ai); }
+            static Trigger* water_walking(PlayerbotAI* ai) { return new WaterWalkingTrigger(ai); }
+            static Trigger* water_breathing_on_party(PlayerbotAI* ai) { return new WaterBreathingOnPartyTrigger(ai); }
+            static Trigger* water_walking_on_party(PlayerbotAI* ai) { return new WaterWalkingOnPartyTrigger(ai); }
+            static Trigger* windfury_totem(PlayerbotAI* ai) { return new WindfuryTotemTrigger(ai); }
+            static Trigger* mana_spring_totem(PlayerbotAI* ai) { return new ManaSpringTotemTrigger(ai); }
+            static Trigger* flametongue_totem(PlayerbotAI* ai) { return new FlametongueTotemTrigger(ai); }
+            static Trigger* strength_of_earth_totem(PlayerbotAI* ai) { return new StrengthOfEarthTotemTrigger(ai); }
+            static Trigger* magma_totem(PlayerbotAI* ai) { return new MagmaTotemTrigger(ai); }
+            static Trigger* searing_totem(PlayerbotAI* ai) { return new SearingTotemTrigger(ai); }
+            static Trigger* wind_shear(PlayerbotAI* ai) { return new WindShearInterruptSpellTrigger(ai); }
+            static Trigger* purge(PlayerbotAI* ai) { return new PurgeTrigger(ai); }
+            static Trigger* shaman_weapon(PlayerbotAI* ai) { return new ShamanWeaponTrigger(ai); }
+            static Trigger* water_shield(PlayerbotAI* ai) { return new WaterShieldTrigger(ai); }
+            static Trigger* lightning_shield(PlayerbotAI* ai) { return new LightningShieldTrigger(ai); }
+            static Trigger* shock(PlayerbotAI* ai) { return new ShockTrigger(ai); }
+            static Trigger* frost_shock_snare(PlayerbotAI* ai) { return new FrostShockSnareTrigger(ai); }
+            static Trigger* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new WindShearInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["water shield"] = &AiObjectContextInternal::water_shield;
+                creators["lightning shield"] = &AiObjectContextInternal::lightning_shield;
+                creators["strength of earth totem"] = &AiObjectContextInternal::strength_of_earth_totem;
+                creators["flametongue totem"] = &AiObjectContextInternal::flametongue_totem;
+                creators["searing totem"] = &AiObjectContextInternal::searing_totem;
+                creators["magma totem"] = &AiObjectContextInternal::magma_totem;
+                creators["windfury totem"] = &AiObjectContextInternal::windfury_totem;
+                creators["mana spring totem"] = &AiObjectContextInternal::mana_spring_totem;
+                creators["mana tide totem"] = &AiObjectContextInternal::mana_tide_totem;
+                creators["healing stream totem"] = &AiObjectContextInternal::healing_stream_totem;
+                creators["wind shear"] = &AiObjectContextInternal::wind_shear;
+                creators["wind shear on enemy healer"] = &AiObjectContextInternal::wind_shear_on_enemy_healer;
+                creators["rockbiter weapon"] = &AiObjectContextInternal::rockbiter_weapon;
+                creators["flametongue weapon"] = &AiObjectContextInternal::flametongue_weapon;
+                creators["frostbrand weapon"] = &AiObjectContextInternal::frostbrand_weapon;
+                creators["windfury weapon"] = &AiObjectContextInternal::windfury_weapon;
+                creators["earthliving weapon"] = &AiObjectContextInternal::earthliving_weapon;
+                creators["purge"] = &AiObjectContextInternal::purge;
+                creators["healing wave"] = &AiObjectContextInternal::healing_wave;
+                creators["lesser healing wave"] = &AiObjectContextInternal::lesser_healing_wave;
+                creators["healing wave on party"] = &AiObjectContextInternal::healing_wave_on_party;
+                creators["lesser healing wave on party"] = &AiObjectContextInternal::lesser_healing_wave_on_party;
+                creators["earth shield"] = &AiObjectContextInternal::earth_shield;
+                creators["earth shield on party"] = &AiObjectContextInternal::earth_shield_on_party;
+                creators["chain heal"] = &AiObjectContextInternal::chain_heal;
+                creators["riptide"] = &AiObjectContextInternal::riptide;
+                creators["riptide on party"] = &AiObjectContextInternal::riptide_on_party;
+                creators["stormstrike"] = &AiObjectContextInternal::stormstrike;
+                creators["lava lash"] = &AiObjectContextInternal::lava_lash;
+                creators["fire nova"] = &AiObjectContextInternal::fire_nova;
+                creators["ancestral spirit"] = &AiObjectContextInternal::ancestral_spirit;
+                creators["water walking"] = &AiObjectContextInternal::water_walking;
+                creators["water breathing"] = &AiObjectContextInternal::water_breathing;
+                creators["water walking on party"] = &AiObjectContextInternal::water_walking_on_party;
+                creators["water breathing on party"] = &AiObjectContextInternal::water_breathing_on_party;
+                creators["cleanse spirit"] = &AiObjectContextInternal::cleanse_spirit;
+                creators["cleanse spirit poison on party"] = &AiObjectContextInternal::cleanse_spirit_poison_on_party;
+                creators["cleanse spirit disease on party"] = &AiObjectContextInternal::cleanse_spirit_disease_on_party;
+                creators["cleanse spirit curse on party"] = &AiObjectContextInternal::cleanse_spirit_curse_on_party;
+                creators["flame shock"] = &AiObjectContextInternal::flame_shock;
+                creators["earth shock"] = &AiObjectContextInternal::earth_shock;
+                creators["frost shock"] = &AiObjectContextInternal::frost_shock;
+                creators["chain lightning"] = &AiObjectContextInternal::chain_lightning;
+                creators["lightning bolt"] = &AiObjectContextInternal::lightning_bolt;
+                creators["thunderstorm"] = &AiObjectContextInternal::thunderstorm;
+                creators["heroism"] = &AiObjectContextInternal::heroism;
+                creators["bloodlust"] = &AiObjectContextInternal::bloodlust;
+            }
+
+        private:
+            static Action* heroism(PlayerbotAI* ai) { return new CastHeroismAction(ai); }
+            static Action* bloodlust(PlayerbotAI* ai) { return new CastBloodlustAction(ai); }
+            static Action* thunderstorm(PlayerbotAI* ai) { return new CastThunderstormAction(ai); }
+            static Action* lightning_bolt(PlayerbotAI* ai) { return new CastLightningBoltAction(ai); }
+            static Action* chain_lightning(PlayerbotAI* ai) { return new CastChainLightningAction(ai); }
+            static Action* frost_shock(PlayerbotAI* ai) { return new CastFrostShockAction(ai); }
+            static Action* earth_shock(PlayerbotAI* ai) { return new CastEarthShockAction(ai); }
+            static Action* flame_shock(PlayerbotAI* ai) { return new CastFlameShockAction(ai); }
+            static Action* cleanse_spirit_poison_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritPoisonOnPartyAction(ai); }
+            static Action* cleanse_spirit_disease_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritDiseaseOnPartyAction(ai); }
+            static Action* cleanse_spirit_curse_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritCurseOnPartyAction(ai); }
+            static Action* cleanse_spirit(PlayerbotAI* ai) { return new CastCleanseSpiritAction(ai); }
+            static Action* water_walking(PlayerbotAI* ai) { return new CastWaterWalkingAction(ai); }
+            static Action* water_breathing(PlayerbotAI* ai) { return new CastWaterBreathingAction(ai); }
+            static Action* water_walking_on_party(PlayerbotAI* ai) { return new CastWaterWalkingOnPartyAction(ai); }
+            static Action* water_breathing_on_party(PlayerbotAI* ai) { return new CastWaterBreathingOnPartyAction(ai); }
+            static Action* water_shield(PlayerbotAI* ai) { return new CastWaterShieldAction(ai); }
+            static Action* lightning_shield(PlayerbotAI* ai) { return new CastLightningShieldAction(ai); }
+            static Action* strength_of_earth_totem(PlayerbotAI* ai) { return new CastStrengthOfEarthTotemAction(ai); }
+            static Action* flametongue_totem(PlayerbotAI* ai) { return new CastFlametongueTotemAction(ai); }
+            static Action* magma_totem(PlayerbotAI* ai) { return new CastMagmaTotemAction(ai); }
+            static Action* searing_totem(PlayerbotAI* ai) { return new CastSearingTotemAction(ai); }
+            static Action* fire_nova(PlayerbotAI* ai) { return new CastFireNovaAction(ai); }
+            static Action* windfury_totem(PlayerbotAI* ai) { return new CastWindfuryTotemAction(ai); }
+            static Action* mana_spring_totem(PlayerbotAI* ai) { return new CastManaSpringTotemAction(ai); }
+            static Action* mana_tide_totem(PlayerbotAI* ai) { return new CastManaTideTotemAction(ai); }
+            static Action* healing_stream_totem(PlayerbotAI* ai) { return new CastHealingStreamTotemAction(ai); }
+            static Action* wind_shear(PlayerbotAI* ai) { return new CastWindShearAction(ai); }
+            static Action* rockbiter_weapon(PlayerbotAI* ai) { return new CastRockbiterWeaponAction(ai); }
+            static Action* flametongue_weapon(PlayerbotAI* ai) { return new CastFlametongueWeaponAction(ai); }
+            static Action* frostbrand_weapon(PlayerbotAI* ai) { return new CastFrostbrandWeaponAction(ai); }
+            static Action* windfury_weapon(PlayerbotAI* ai) { return new CastWindfuryWeaponAction(ai); }
+            static Action* earthliving_weapon(PlayerbotAI* ai) { return new CastEarthlivingWeaponAction(ai); }
+            static Action* purge(PlayerbotAI* ai) { return new CastPurgeAction(ai); }
+            static Action* healing_wave(PlayerbotAI* ai) { return new CastHealingWaveAction(ai); }
+            static Action* lesser_healing_wave(PlayerbotAI* ai) { return new CastLesserHealingWaveAction(ai); }
+            static Action* healing_wave_on_party(PlayerbotAI* ai) { return new CastHealingWaveOnPartyAction(ai); }
+            static Action* lesser_healing_wave_on_party(PlayerbotAI* ai) { return new CastLesserHealingWaveOnPartyAction(ai); }
+            static Action* earth_shield(PlayerbotAI* ai) { return new CastEarthShieldAction(ai); }
+            static Action* earth_shield_on_party(PlayerbotAI* ai) { return new CastEarthShieldOnPartyAction(ai); }
+            static Action* chain_heal(PlayerbotAI* ai) { return new CastChainHealAction(ai); }
+            static Action* riptide(PlayerbotAI* ai) { return new CastRiptideAction(ai); }
+            static Action* riptide_on_party(PlayerbotAI* ai) { return new CastRiptideOnPartyAction(ai); }
+            static Action* stormstrike(PlayerbotAI* ai) { return new CastStormstrikeAction(ai); }
+            static Action* lava_lash(PlayerbotAI* ai) { return new CastLavaLashAction(ai); }
+            static Action* ancestral_spirit(PlayerbotAI* ai) { return new CastAncestralSpiritAction(ai); }
+            static Action* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new CastWindShearOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+ShamanAiObjectContext::ShamanAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::shaman::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::shaman::AiObjectContextInternal());
+    triggerContexts.Add(new ai::shaman::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
new file mode 100644
index 0000000..718084a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class ShamanAiObjectContext : public AiObjectContext
+    {
+    public:
+        ShamanAiObjectContext(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
new file mode 100644
index 0000000..6c72f20
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
new file mode 100644
index 0000000..044c6bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanNonCombatStrategy.h"
+
+using namespace ai;
+
+void ShamanNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("ancestral spirit", 33.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water breathing",
+		NextAction::array(0, new NextAction("water breathing", 12.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water walking",
+		NextAction::array(0, new NextAction("water walking", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water breathing on party",
+        NextAction::array(0, new NextAction("water breathing on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water walking on party",
+        NextAction::array(0, new NextAction("water walking on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing wave", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("healing wave on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+}
+
+void ShamanNonCombatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    NonCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
new file mode 100644
index 0000000..a6859ee
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class ShamanNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        ShamanNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "nc"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
new file mode 100644
index 0000000..2a6c51e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanTriggers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
+list<string> ShamanWeaponTrigger::spells;
+
+bool ShamanWeaponTrigger::IsActive()
+{
+    if (spells.empty())
+    {
+        spells.push_back("frostbrand weapon");
+        spells.push_back("rockbiter weapon");
+        spells.push_back("flametongue weapon");
+        spells.push_back("earthliving weapon");
+        spells.push_back("windfury weapon");
+    }
+
+    for (list<string>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+        if (!spellId)
+            continue;
+
+        if (AI_VALUE2(Item*, "item for spell", spellId))
+            return true;
+    }
+
+    return false;
+}
+
+bool ShockTrigger::IsActive()
+{
+    return SpellTrigger::IsActive()
+            && !ai->HasAnyAuraOf(GetTarget(), "frost shock", "earth shock", "flame shock", NULL);
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
new file mode 100644
index 0000000..afa6d62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
@@ -0,0 +1,197 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    class ShamanWeaponTrigger : public BuffTrigger {
+    public:
+        ShamanWeaponTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "rockbiter weapon") {}
+        virtual bool IsActive();
+    private:
+        static list<string> spells;
+    };
+
+    class TotemTrigger : public Trigger {
+    public:
+        TotemTrigger(PlayerbotAI* ai, string spell, int attackerCount = 0) : Trigger(ai, spell), attackerCount(attackerCount) {}
+
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= attackerCount && !AI_VALUE2(bool, "has totem", name);
+        }
+
+    protected:
+        int attackerCount;
+    };
+
+    class WindfuryTotemTrigger : public TotemTrigger {
+    public:
+        WindfuryTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "windfury totem") {}
+    };
+
+    class ManaSpringTotemTrigger : public TotemTrigger {
+    public:
+        ManaSpringTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "mana spring totem") {}
+        virtual bool IsActive()
+        {
+            return AI_VALUE(uint8, "attacker count") >= attackerCount &&
+                    !AI_VALUE2(bool, "has totem", "mana tide totem") &&
+                    !AI_VALUE2(bool, "has totem", name);
+        }
+    };
+
+    class FlametongueTotemTrigger : public TotemTrigger {
+    public:
+        FlametongueTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "flametongue totem") {}
+    };
+
+    class StrengthOfEarthTotemTrigger : public TotemTrigger {
+    public:
+        StrengthOfEarthTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "strength of earth totem") {}
+    };
+
+    class MagmaTotemTrigger : public TotemTrigger {
+    public:
+        MagmaTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "magma totem", 3) {}
+    };
+
+    class SearingTotemTrigger : public TotemTrigger {
+    public:
+        SearingTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "searing totem", 1) {}
+    };
+
+    class WindShearInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        WindShearInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "wind shear") {}
+    };
+
+    class WaterShieldTrigger : public BuffTrigger
+    {
+    public:
+        WaterShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water shield") {}
+    };
+
+    class LightningShieldTrigger : public BuffTrigger
+    {
+    public:
+        LightningShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "lightning shield") {}
+    };
+
+    class PurgeTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        PurgeTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "purge", DISPEL_MAGIC) {}
+    };
+
+    class WaterWalkingTrigger : public BuffTrigger {
+    public:
+        WaterWalkingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water walking") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingTrigger : public BuffTrigger {
+    public:
+        WaterBreathingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water breathing") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterWalkingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterWalkingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water walking on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterBreathingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water breathing on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class CleanseSpiritPoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritPoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCleanseSpiritPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class CleanseSpiritCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberCleanseSpiritCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class CleanseSpiritDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCleanseSpiritDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class ShockTrigger : public DebuffTrigger {
+    public:
+        ShockTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "earth shock") {}
+        virtual bool IsActive();
+    };
+
+    class FrostShockSnareTrigger : public SnareTargetTrigger {
+    public:
+        FrostShockSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "frost shock") {}
+    };
+
+    class HeroismTrigger : public BoostTrigger
+    {
+    public:
+        HeroismTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "heroism") {}
+    };
+
+    class BloodlustTrigger : public BoostTrigger
+    {
+    public:
+        BloodlustTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "bloodlust") {}
+    };
+
+    class MaelstromWeaponTrigger : public HasAuraTrigger
+    {
+    public:
+        MaelstromWeaponTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "maelstrom weapon") {}
+    };
+
+    class WindShearInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        WindShearInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
new file mode 100644
index 0000000..e23c97d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "TotemsShamanStrategy.h"
+
+using namespace ai;
+
+TotemsShamanStrategy::TotemsShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+}
+
+void TotemsShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "windfury totem",
+        NextAction::array(0, new NextAction("windfury totem", 16.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mana spring totem",
+        NextAction::array(0, new NextAction("mana spring totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "strength of earth totem",
+        NextAction::array(0, new NextAction("strength of earth totem", 18.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flametongue totem",
+        NextAction::array(0, new NextAction("flametongue totem", 17.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
new file mode 100644
index 0000000..978fa26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class TotemsShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        TotemsShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "totems"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
new file mode 100644
index 0000000..0e43d16
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class ChatCommandTrigger : public Trigger {
+    public:
+        ChatCommandTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(string param, Player* owner = NULL)
+        {
+            this->param = param;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), param, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+   private:
+        string param;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
new file mode 100644
index 0000000..239e0ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
@@ -0,0 +1,140 @@
+#pragma once
+
+#include "ChatCommandTrigger.h"
+
+namespace ai
+{
+    class ChatTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        ChatTriggerContext()
+        {
+            creators["quests"] = &ChatTriggerContext::quests;
+            creators["stats"] = &ChatTriggerContext::stats;
+            creators["leave"] = &ChatTriggerContext::leave;
+            creators["rep"] = &ChatTriggerContext::reputation;
+            creators["reputation"] = &ChatTriggerContext::reputation;
+            creators["log"] = &ChatTriggerContext::log;
+            creators["los"] = &ChatTriggerContext::los;
+            creators["drop"] = &ChatTriggerContext::drop;
+            creators["q"] = &ChatTriggerContext::q;
+            creators["ll"] = &ChatTriggerContext::ll;
+            creators["loot all"] = &ChatTriggerContext::loot_all;
+            creators["add all loot"] = &ChatTriggerContext::loot_all;
+            creators["release"] = &ChatTriggerContext::release;
+            creators["teleport"] = &ChatTriggerContext::teleport;
+            creators["taxi"] = &ChatTriggerContext::taxi;
+            creators["repair"] = &ChatTriggerContext::repair;
+            creators["u"] = &ChatTriggerContext::use;
+            creators["use"] = &ChatTriggerContext::use;
+            creators["c"] = &ChatTriggerContext::item_count;
+            creators["e"] = &ChatTriggerContext::equip;
+            creators["ue"] = &ChatTriggerContext::uneqip;
+            creators["s"] = &ChatTriggerContext::sell;
+            creators["b"] = &ChatTriggerContext::buy;
+            creators["r"] = &ChatTriggerContext::reward;
+            creators["t"] = &ChatTriggerContext::trade;
+            creators["nt"] = &ChatTriggerContext::nontrade;
+            creators["talents"] = &ChatTriggerContext::talents;
+            creators["spells"] = &ChatTriggerContext::spells;
+            creators["co"] = &ChatTriggerContext::co;
+            creators["nc"] = &ChatTriggerContext::nc;
+            creators["dead"] = &ChatTriggerContext::dead;
+            creators["trainer"] = &ChatTriggerContext::trainer;
+            creators["attack"] = &ChatTriggerContext::attack;
+            creators["chat"] = &ChatTriggerContext::chat;
+            creators["accept"] = &ChatTriggerContext::accept;
+            creators["home"] = &ChatTriggerContext::home;
+            creators["reset ai"] = &ChatTriggerContext::reset_ai;
+            creators["destroy"] = &ChatTriggerContext::destroy;
+            creators["emote"] = &ChatTriggerContext::emote;
+            creators["buff"] = &ChatTriggerContext::buff;
+            creators["help"] = &ChatTriggerContext::help;
+            creators["gb"] = &ChatTriggerContext::gb;
+            creators["bank"] = &ChatTriggerContext::bank;
+            creators["follow"] = &ChatTriggerContext::follow;
+            creators["stay"] = &ChatTriggerContext::stay;
+            creators["flee"] = &ChatTriggerContext::flee;
+            creators["grind"] = &ChatTriggerContext::grind;
+            creators["tank attack"] = &ChatTriggerContext::tank_attack;
+            creators["talk"] = &ChatTriggerContext::talk;
+            creators["cast"] = &ChatTriggerContext::talk;
+            creators["invite"] = &ChatTriggerContext::invite;
+            creators["spell"] = &ChatTriggerContext::spell;
+            creators["rti"] = &ChatTriggerContext::rti;
+            creators["revive"] = &ChatTriggerContext::revive;
+            creators["runaway"] = &ChatTriggerContext::runaway;
+            creators["warning"] = &ChatTriggerContext::warning;
+            creators["position"] = &ChatTriggerContext::position;
+            creators["summon"] = &ChatTriggerContext::summon;
+            creators["who"] = &ChatTriggerContext::who;
+            creators["save mana"] = &ChatTriggerContext::save_mana;
+            creators["max dps"] = &ChatTriggerContext::max_dps;
+            creators["attackers"] = &ChatTriggerContext::attackers;
+            creators["formation"] = &ChatTriggerContext::formation;
+        }
+
+    private:
+        static Trigger* formation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "formation"); }
+        static Trigger* attackers(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attackers"); }
+        static Trigger* max_dps(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "max dps"); }
+        static Trigger* save_mana(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "save mana"); }
+        static Trigger* who(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "who"); }
+        static Trigger* summon(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "summon"); }
+        static Trigger* position(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "position"); }
+        static Trigger* runaway(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "runaway"); }
+        static Trigger* warning(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "warning"); }
+        static Trigger* revive(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "revive"); }
+        static Trigger* rti(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "rti"); }
+        static Trigger* invite(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "invite"); }
+        static Trigger* cast(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "cast"); }
+        static Trigger* talk(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talk"); }
+        static Trigger* flee(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "flee"); }
+        static Trigger* grind(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "grind"); }
+        static Trigger* tank_attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "tank attack"); }
+        static Trigger* stay(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stay"); }
+        static Trigger* follow(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "follow"); }
+        static Trigger* gb(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "gb"); }
+        static Trigger* bank(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "bank"); }
+        static Trigger* help(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "help"); }
+        static Trigger* buff(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "buff"); }
+        static Trigger* emote(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "emote"); }
+        static Trigger* destroy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "destroy"); }
+        static Trigger* home(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "home"); }
+        static Trigger* accept(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "accept"); }
+        static Trigger* chat(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "chat"); }
+        static Trigger* attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attack"); }
+        static Trigger* trainer(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "trainer"); }
+        static Trigger* co(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "co"); }
+        static Trigger* nc(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nc"); }
+        static Trigger* dead(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "dead"); }
+        static Trigger* spells(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spells"); }
+        static Trigger* talents(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talents"); }
+        static Trigger* equip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "e"); }
+        static Trigger* uneqip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ue"); }
+        static Trigger* sell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "s"); }
+        static Trigger* buy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "b"); }
+        static Trigger* reward(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "r"); }
+        static Trigger* trade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "t"); }
+        static Trigger* nontrade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nt"); }
+
+        static Trigger* item_count(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "c"); }
+        static Trigger* use(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "use"); }
+        static Trigger* repair(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "repair"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "taxi"); }
+        static Trigger* teleport(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "teleport"); }
+        static Trigger* q(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "q"); }
+        static Trigger* ll(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ll"); }
+        static Trigger* drop(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "drop"); }
+        static Trigger* quests(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "quests"); }
+        static Trigger* stats(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stats"); }
+        static Trigger* leave(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "leave"); }
+        static Trigger* reputation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reputation"); }
+        static Trigger* log(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "log"); }
+        static Trigger* los(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "los"); }
+        static Trigger* loot_all(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "add all loot"); }
+        static Trigger* release(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "release"); }
+        static Trigger* reset_ai(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reset ai"); }
+        static Trigger* spell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spell"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
new file mode 100644
index 0000000..0be6ff6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "CureTriggers.h"
+
+using namespace ai;
+
+bool NeedCureTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return target && ai->HasAuraToDispel(target, dispelType);
+}
+
+Value<Unit*>* PartyMemberNeedCureTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.h b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
new file mode 100644
index 0000000..2321953
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Trigger.h"
+
+namespace ai
+{
+	class SpellTrigger;
+
+    class NeedCureTrigger : public SpellTrigger {
+    public:
+        NeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : SpellTrigger(ai, spell) 
+  	    {
+			this->dispelType = dispelType;
+        }
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+
+    protected:
+        uint32 dispelType;
+    };
+
+    class TargetAuraDispelTrigger : public NeedCureTrigger {
+    public:
+        TargetAuraDispelTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+			NeedCureTrigger(ai, spell, dispelType) {}
+		virtual string GetTargetName() { return "current target"; }
+    };
+
+    class PartyMemberNeedCureTrigger : public NeedCureTrigger {
+    public:
+        PartyMemberNeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+            NeedCureTrigger(ai, spell, dispelType) {}
+
+		virtual Value<Unit*>* GetTargetValue();
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
new file mode 100644
index 0000000..ebd6dbf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
@@ -0,0 +1,242 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool LowManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+}
+
+bool MediumManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.mediumMana;
+}
+
+
+bool RageAvailable::IsActive()
+{
+    return AI_VALUE2(uint8, "rage", "self target") >= amount;
+}
+
+bool EnergyAvailable::IsActive()
+{
+	return AI_VALUE2(uint8, "energy", "self target") >= amount;
+}
+
+bool ComboPointsAvailableTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "combo", "current target") >= amount;
+}
+
+bool LoseAggroTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool HasAggroTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool PanicTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.criticalHealth &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana);
+}
+
+bool BuffTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+	return SpellTrigger::IsActive() &&
+		!ai->HasAura(spell, target) &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.lowMana);
+}
+
+Value<Unit*>* BuffOnPartyTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member without aura", spell);
+}
+
+Value<Unit*>* DebuffOnAttackerTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("attacker without aura", spell);
+}
+
+bool NoAttackersTrigger::IsActive()
+{
+    return !AI_VALUE(Unit*, "current target") && AI_VALUE(uint8, "attacker count") > 0;
+}
+
+bool InvalidTargetTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "invalid target", "current target");
+}
+
+bool NoTargetTrigger::IsActive()
+{
+	return !AI_VALUE(Unit*, "current target");
+}
+
+bool MyAttackerCountTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "my attacker count") >= amount;
+}
+
+bool AoeTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") >= amount;
+}
+
+bool DebuffTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE2(uint8, "health", "current target") > 25;
+}
+
+bool SpellTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool SpellCanBeCastTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return target && ai->CanCastSpell(spell, target);
+}
+
+bool RandomTrigger::IsActive()
+{
+    int vl  = rand() % (int)(1 + probability * 10 / sPlayerbotAIConfig.randomChangeMultiplier);
+    return vl == 0;
+}
+
+bool AndTrigger::IsActive()
+{
+    return ls->IsActive() && rs->IsActive();
+}
+
+string AndTrigger::getName()
+{
+    std::string name(ls->getName());
+    name = name + " and ";
+    name = name + rs->getName();
+    return name;
+}
+
+bool BoostTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE(uint8, "balance") <= balance;
+}
+
+bool SnareTargetTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return DebuffTrigger::IsActive() && AI_VALUE2(bool, "moving", "current target") && !ai->HasAura(spell, target);
+}
+
+bool ItemCountTrigger::IsActive()
+{
+	return AI_VALUE2(uint8, "item count", item) < count;
+}
+
+bool InterruptSpellTrigger::IsActive()
+{
+	return SpellTrigger::IsActive() && ai->IsInterruptableSpellCasting(GetTarget(), getName());
+}
+
+bool HasAuraTrigger::IsActive()
+{
+	return ai->HasAura(getName(), GetTarget());
+}
+
+bool TankAoeTrigger::IsActive()
+{
+    if (!AI_VALUE(uint8, "attacker count"))
+        return false;
+
+    Unit* currentTarget = AI_VALUE(Unit*, "current target");
+    if (!currentTarget)
+        return true;
+
+    Unit* tankTarget = AI_VALUE(Unit*, "tank target");
+    if (!tankTarget || currentTarget == tankTarget)
+        return false;
+
+    return currentTarget->GetVictim() == AI_VALUE(Unit*, "self target");
+}
+
+bool IsBehindTargetTrigger::IsActive()
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(bool, "behind", "current target");
+}
+
+bool IsNotFacingTargetTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
+
+bool HasCcTargetTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") > 2 && AI_VALUE2(Unit*, "cc target", getName()) &&
+        !AI_VALUE2(Unit*, "current cc target", getName());
+}
+
+bool NoMovementTrigger::IsActive()
+{
+	return !AI_VALUE2(bool, "moving", "self target");
+}
+
+bool NoPossibleTargetsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "possible targets");
+    return !targets.size();
+}
+
+bool NotLeastHpTargetActiveTrigger::IsActive()
+{
+    Unit* leastHp = AI_VALUE(Unit*, "least hp target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return leastHp && target != leastHp;
+}
+
+bool EnemyPlayerIsAttacking::IsActive()
+{
+    Unit* enemyPlayer = AI_VALUE(Unit*, "enemy player target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return enemyPlayer && target != enemyPlayer;
+}
+
+bool IsSwimmingTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "swimming", "self target");
+}
+
+bool HasNearestAddsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "nearest adds");
+    return targets.size();
+}
+
+bool HasItemForSpellTrigger::IsActive()
+{
+	string spell = getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+
+bool TargetChangedTrigger::IsActive()
+{
+    Unit* oldTarget = context->GetValue<Unit*>("old target")->Get();
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    return target && oldTarget != target;
+}
+
+Value<Unit*>* InterruptEnemyHealerTrigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>("enemy healer target", spell);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.h b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
new file mode 100644
index 0000000..f176429
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
@@ -0,0 +1,540 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffTrigger(ai, spell) {} \
+    };
+
+#define BUFF_ON_PARTY_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffOnPartyTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, spell) {}  \
+    };
+
+#define DEBUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public DebuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : DebuffTrigger(ai, spell) {} \
+    };
+
+namespace ai
+{
+	class StatAvailable : public Trigger
+	{
+	public:
+		StatAvailable(PlayerbotAI* ai, int amount, string name = "stat available") : Trigger(ai, name)
+		{
+			this->amount = amount;
+		}
+
+	protected:
+		int amount;
+	};
+
+	class RageAvailable : public StatAvailable
+    {
+    public:
+        RageAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "rage available") {}
+        virtual bool IsActive();
+    };
+
+    class LightRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        LightRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 20) {}
+    };
+
+    class MediumRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        MediumRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 40) {}
+    };
+
+    class HighRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        HighRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 60) {}
+    };
+
+	class EnergyAvailable : public StatAvailable
+	{
+	public:
+		EnergyAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "energy available") {}
+		virtual bool IsActive();
+	};
+
+    class LightEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        LightEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 20) {}
+    };
+
+    class MediumEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        MediumEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 40) {}
+    };
+
+    class HighEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        HighEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 60) {}
+    };
+
+	class ComboPointsAvailableTrigger : public StatAvailable
+	{
+	public:
+	    ComboPointsAvailableTrigger(PlayerbotAI* ai, int amount = 5) : StatAvailable(ai, amount, "combo points available") {}
+		virtual bool IsActive();
+	};
+
+	class LoseAggroTrigger : public Trigger {
+	public:
+		LoseAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "lose aggro") {}
+		virtual bool IsActive();
+	};
+
+	class HasAggroTrigger : public Trigger {
+	public:
+	    HasAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "have aggro") {}
+		virtual bool IsActive();
+	};
+
+	class SpellTrigger : public Trigger
+	{
+	public:
+		SpellTrigger(PlayerbotAI* ai, string spell, int checkInterval = 1) : Trigger(ai, spell, checkInterval)
+		{
+			this->spell = spell;
+		}
+
+		virtual string GetTargetName() { return "current target"; }
+		virtual string getName() { return spell; }
+		virtual bool IsActive();
+
+	protected:
+		string spell;
+	};
+
+	class SpellCanBeCastTrigger : public SpellTrigger
+	{
+	public:
+		SpellCanBeCastTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+		virtual bool IsActive();
+	};
+
+	// TODO: check other targets
+    class InterruptSpellTrigger : public SpellTrigger
+	{
+    public:
+        InterruptSpellTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+        virtual bool IsActive();
+    };
+
+
+    class AttackerCountTrigger : public Trigger
+    {
+    public:
+        AttackerCountTrigger(PlayerbotAI* ai, int amount, float distance = sPlayerbotAIConfig.sightDistance) : Trigger(ai)
+        {
+            this->amount = amount;
+            this->distance = distance;
+        }
+    public:
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= amount;
+        }
+        virtual string getName() { return "attacker count"; }
+
+    protected:
+        int amount;
+        float distance;
+    };
+
+    class HasAttackersTrigger : public AttackerCountTrigger
+    {
+    public:
+        HasAttackersTrigger(PlayerbotAI* ai) : AttackerCountTrigger(ai, 1) {}
+    };
+
+    class MyAttackerCountTrigger : public AttackerCountTrigger
+    {
+    public:
+        MyAttackerCountTrigger(PlayerbotAI* ai, int amount) : AttackerCountTrigger(ai, amount) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "my attacker count"; }
+    };
+
+    class MediumThreatTrigger : public MyAttackerCountTrigger
+    {
+    public:
+        MediumThreatTrigger(PlayerbotAI* ai) : MyAttackerCountTrigger(ai, 2) {}
+    };
+
+    class AoeTrigger : public AttackerCountTrigger
+    {
+    public:
+        AoeTrigger(PlayerbotAI* ai, int amount = 3, float range = 15.0f) : AttackerCountTrigger(ai, amount)
+        {
+            this->range = range;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "aoe"; }
+
+    private:
+        float range;
+    };
+
+    class NoFoodTrigger : public Trigger {
+    public:
+        NoFoodTrigger(PlayerbotAI* ai) : Trigger(ai, "no food trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "food").empty(); }
+    };
+
+    class NoDrinkTrigger : public Trigger {
+    public:
+        NoDrinkTrigger(PlayerbotAI* ai) : Trigger(ai, "no drink trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "drink").empty(); }
+    };
+
+    class LightAoeTrigger : public AoeTrigger
+    {
+    public:
+        LightAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 2, 15.0f) {}
+    };
+
+    class MediumAoeTrigger : public AoeTrigger
+    {
+    public:
+        MediumAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 3, 17.0f) {}
+    };
+
+    class HighAoeTrigger : public AoeTrigger
+    {
+    public:
+        HighAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 4, 20.0f) {}
+    };
+
+    class BuffTrigger : public SpellTrigger
+    {
+    public:
+        BuffTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell, 5) {}
+    public:
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class BuffOnPartyTrigger : public BuffTrigger
+    {
+    public:
+        BuffOnPartyTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+    };
+
+    BEGIN_TRIGGER(NoAttackersTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(NoTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(InvalidTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    class TargetInSightTrigger : public Trigger {
+    public:
+        TargetInSightTrigger(PlayerbotAI* ai) : Trigger(ai, "target in sight") {}
+        virtual bool IsActive() { return AI_VALUE(Unit*, "grind target"); }
+    };
+
+    class DebuffTrigger : public BuffTrigger
+    {
+    public:
+        DebuffTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {
+			checkInterval = 1;
+		}
+    public:
+		virtual string GetTargetName() { return "current target"; }
+        virtual bool IsActive();
+    };
+
+    class DebuffOnAttackerTrigger : public DebuffTrigger
+    {
+    public:
+        DebuffOnAttackerTrigger(PlayerbotAI* ai, string spell) : DebuffTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on attacker"; }
+    };
+
+	class BoostTrigger : public BuffTrigger
+	{
+	public:
+		BoostTrigger(PlayerbotAI* ai, string spell, float balance = 50) : BuffTrigger(ai, spell)
+		{
+			this->balance = balance;
+		}
+	public:
+		virtual bool IsActive();
+
+	protected:
+		float balance;
+	};
+
+    class RandomTrigger : public Trigger
+    {
+    public:
+        RandomTrigger(PlayerbotAI* ai, int probability = 200) : Trigger(ai)
+        {
+            this->probability = probability;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "random"; }
+
+    protected:
+        int probability;
+    };
+
+    class SeldomTrigger : public RandomTrigger
+    {
+    public:
+        SeldomTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 9000) {}
+        virtual string getName() { return "seldom"; }
+    };
+
+    class OftenTrigger : public RandomTrigger
+    {
+    public:
+        OftenTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 50) {}
+        virtual string getName() { return "often"; }
+    };
+
+    class AndTrigger : public Trigger
+    {
+    public:
+        AndTrigger(PlayerbotAI* ai, Trigger* ls, Trigger* rs) : Trigger(ai)
+        {
+            this->ls = ls;
+            this->rs = rs;
+        }
+        virtual ~AndTrigger()
+        {
+            delete ls;
+            delete rs;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName();
+
+    protected:
+        Trigger* ls;
+        Trigger* rs;
+    };
+
+    class SnareTargetTrigger : public DebuffTrigger
+    {
+    public:
+        SnareTargetTrigger(PlayerbotAI* ai, string aura) : DebuffTrigger(ai, aura) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "target is moving"; }
+    };
+
+	class LowManaTrigger : public Trigger
+	{
+	public:
+		LowManaTrigger(PlayerbotAI* ai) : Trigger(ai, "low mana") {}
+
+		virtual bool IsActive();
+	};
+
+	class MediumManaTrigger : public Trigger
+	{
+	public:
+		MediumManaTrigger(PlayerbotAI* ai) : Trigger(ai, "medium mana") {}
+
+		virtual bool IsActive();
+	};
+
+    BEGIN_TRIGGER(PanicTrigger, Trigger)
+        virtual string getName() { return "panic"; }
+    END_TRIGGER()
+
+
+	class NoPetTrigger : public Trigger
+	{
+	public:
+		NoPetTrigger(PlayerbotAI* ai) : Trigger(ai, "no pet", 5) {}
+
+		virtual bool IsActive() {
+			return !AI_VALUE(Unit*, "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+		}
+	};
+
+	class ItemCountTrigger : public Trigger {
+	public:
+		ItemCountTrigger(PlayerbotAI* ai, string item, int count) : Trigger(ai, item, 5) {
+			this->item = item;
+			this->count = count;
+		}
+	public:
+		virtual bool IsActive();
+		virtual string getName() { return "item count"; }
+
+	protected:
+		string item;
+		int count;
+	};
+
+	class HasAuraTrigger : public Trigger {
+	public:
+		HasAuraTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell, 5) {}
+
+		virtual string GetTargetName() { return "self target"; }
+		virtual bool IsActive();
+
+	};
+
+    class TimerTrigger : public Trigger
+    {
+    public:
+        TimerTrigger(PlayerbotAI* ai, int checkInterval = 5) : Trigger(ai, "timer", checkInterval) {}
+
+    public:
+        virtual bool IsActive() { return true; }
+    };
+
+	class TankAoeTrigger : public NoAttackersTrigger
+	{
+	public:
+		TankAoeTrigger(PlayerbotAI* ai) : NoAttackersTrigger(ai) {}
+
+	public:
+		virtual bool IsActive();
+
+	};
+
+    class IsBehindTargetTrigger : public Trigger
+    {
+    public:
+        IsBehindTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsNotFacingTargetTrigger : public Trigger
+    {
+    public:
+        IsNotFacingTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasCcTargetTrigger : public Trigger
+    {
+    public:
+        HasCcTargetTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+	class NoMovementTrigger : public Trigger
+	{
+	public:
+		NoMovementTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+	public:
+		virtual bool IsActive();
+	};
+
+
+    class NoPossibleTargetsTrigger : public Trigger
+    {
+    public:
+        NoPossibleTargetsTrigger(PlayerbotAI* ai) : Trigger(ai, "no possible targets") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class NotLeastHpTargetActiveTrigger : public Trigger
+    {
+    public:
+        NotLeastHpTargetActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "not least hp target active") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class EnemyPlayerIsAttacking : public Trigger
+    {
+    public:
+        EnemyPlayerIsAttacking(PlayerbotAI* ai) : Trigger(ai, "enemy player is attacking") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsSwimmingTrigger : public Trigger
+    {
+    public:
+        IsSwimmingTrigger(PlayerbotAI* ai) : Trigger(ai, "swimming") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasNearestAddsTrigger : public Trigger
+    {
+    public:
+        HasNearestAddsTrigger(PlayerbotAI* ai) : Trigger(ai, "has nearest adds") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasItemForSpellTrigger : public Trigger
+    {
+    public:
+        HasItemForSpellTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class TargetChangedTrigger : public Trigger
+    {
+    public:
+        TargetChangedTrigger(PlayerbotAI* ai) : Trigger(ai, "target changed") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class InterruptEnemyHealerTrigger : public SpellTrigger
+    {
+    public:
+        InterruptEnemyHealerTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+
+}
+
+#include "RangeTriggers.h"
+#include "HealthTriggers.h"
+#include "CureTriggers.h"
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
new file mode 100644
index 0000000..703f00c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HealthTriggers.h"
+
+using namespace ai;
+
+float HealthInRangeTrigger::GetValue()
+{
+    return AI_VALUE2(uint8, "health", GetTargetName());
+}
+
+bool PartyMemberDeadTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool DeadTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "dead", GetTargetName());
+}
+
+bool AoeHealTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "aoe heal", type) >= count;
+}
+
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.h b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
new file mode 100644
index 0000000..49dc17b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
@@ -0,0 +1,139 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ValueInRangeTrigger : public Trigger
+    {
+    public:
+        ValueInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue) : Trigger(ai, name) {
+            this->maxValue = maxValue;
+            this->minValue = minValue;
+        }
+    public:
+        virtual float GetValue() = 0;
+        virtual bool IsActive() {
+            float value = GetValue();
+            return value < maxValue && value >= minValue;
+        }
+
+    protected:
+        float maxValue, minValue;
+    };
+
+	class HealthInRangeTrigger : public ValueInRangeTrigger
+	{
+	public:
+		HealthInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue = 0) :
+		  ValueInRangeTrigger(ai, name, maxValue, minValue) {}
+
+		virtual bool IsActive()
+		{
+		    return ValueInRangeTrigger::IsActive() && !AI_VALUE2(bool, "dead", GetTargetName());
+		}
+
+		virtual float GetValue();
+	};
+
+    class LowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        LowHealthTrigger(PlayerbotAI* ai, string name = "low health",
+            float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+		virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CriticalHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        CriticalHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class MediumHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        MediumHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "medium health", sPlayerbotAIConfig.mediumHealth, sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class AlmostFullHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        AlmostFullHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "almost full health", sPlayerbotAIConfig.almostFullHealth, sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class PartyMemberLowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        PartyMemberLowHealthTrigger(PlayerbotAI* ai, string name = "party member low health", float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class PartyMemberCriticalHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberCriticalHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class PartyMemberMediumHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberMediumHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member medium health", sPlayerbotAIConfig.mediumHealth,sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class PartyMemberAlmostFullHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberAlmostFullHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member almost full health", sPlayerbotAIConfig.almostFullHealth,sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class TargetLowHealthTrigger : public HealthInRangeTrigger {
+    public:
+        TargetLowHealthTrigger(PlayerbotAI* ai, float value, float minValue = 0) :
+            HealthInRangeTrigger(ai, "target low health", value, minValue) {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class TargetCriticalHealthTrigger : public TargetLowHealthTrigger
+    {
+    public:
+        TargetCriticalHealthTrigger(PlayerbotAI* ai) : TargetLowHealthTrigger(ai, 20) {}
+    };
+
+	class PartyMemberDeadTrigger : public Trigger {
+	public:
+		PartyMemberDeadTrigger(PlayerbotAI* ai) : Trigger(ai, "resurrect", 10) {}
+        virtual string GetTargetName() { return "party member to resurrect"; }
+		virtual bool IsActive();
+	};
+
+    class DeadTrigger : public Trigger {
+    public:
+        DeadTrigger(PlayerbotAI* ai) : Trigger(ai, "dead", 10) {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class AoeHealTrigger : public Trigger {
+    public:
+    	AoeHealTrigger(PlayerbotAI* ai, string name, string type, int count) :
+    		Trigger(ai, name), type(type), count(count) {}
+    public:
+        virtual bool IsActive();
+
+    protected:
+        int count;
+        string type;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LfgTriggers.h b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
new file mode 100644
index 0000000..ec8133e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+class LfgProposalActiveTrigger : public Trigger
+{
+public:
+    LfgProposalActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "lfg proposal active", 5) {}
+
+    virtual bool IsActive()
+    {
+        return AI_VALUE(uint32, "lfg proposal");
+    }
+};
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
new file mode 100644
index 0000000..cac9b60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootTriggers.h"
+
+using namespace ai;
+
+bool LootAvailableTrigger::IsActive()
+{
+    return AI_VALUE(bool, "has available loot") && AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool FarFromCurrentLootTrigger::IsActive()
+{
+    return AI_VALUE2(float, "distance", "loot target") > INTERACTION_DISTANCE;
+}
+
+bool CanLootTrigger::IsActive()
+{
+    return AI_VALUE(bool, "can loot");
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.h b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
new file mode 100644
index 0000000..063456b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
@@ -0,0 +1,30 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class LootAvailableTrigger : public Trigger
+    {
+    public:
+        LootAvailableTrigger(PlayerbotAI* ai) : Trigger(ai, "loot available") {}
+
+        virtual bool IsActive();
+    };
+
+    class FarFromCurrentLootTrigger : public Trigger
+    {
+    public:
+        FarFromCurrentLootTrigger(PlayerbotAI* ai) : Trigger(ai, "far from current loot") {}
+
+        virtual bool IsActive();
+    };
+
+    class CanLootTrigger : public Trigger
+    {
+    public:
+        CanLootTrigger(PlayerbotAI* ai) : Trigger(ai, "can loot") {}
+
+        virtual bool IsActive();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/RangeTriggers.h b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
new file mode 100644
index 0000000..08aba8f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class EnemyTooCloseForSpellTrigger : public Trigger {
+    public:
+        EnemyTooCloseForSpellTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for spell") {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.spellDistance / 2;
+        }
+    };
+
+    class EnemyTooCloseForMeleeTrigger : public Trigger {
+    public:
+        EnemyTooCloseForMeleeTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for melee", 5) {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+        }
+    };
+
+    class OutOfRangeTrigger : public Trigger {
+    public:
+        OutOfRangeTrigger(PlayerbotAI* ai, string name, float distance) : Trigger(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, GetTargetName());
+			return target && AI_VALUE2(float, "distance", GetTargetName()) > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class EnemyOutOfMeleeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfMeleeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of melee range", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class EnemyOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of spell range", sPlayerbotAIConfig.spellDistance) {}
+    };
+
+    class PartyMemberToHealOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        PartyMemberToHealOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "party member to heal out of spell range", sPlayerbotAIConfig.spellDistance) {}
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class FarFromMasterTrigger : public Trigger {
+    public:
+        FarFromMasterTrigger(PlayerbotAI* ai, string name = "far from master", float distance = 12.0f, int checkInterval = 1) : Trigger(ai, name, checkInterval), distance(distance) {}
+
+        virtual bool IsActive()
+        {
+            return AI_VALUE2(float, "distance", "master target") > distance;
+        }
+
+    private:
+        float distance;
+    };
+
+    class OutOfReactRangeTrigger : public FarFromMasterTrigger
+    {
+    public:
+        OutOfReactRangeTrigger(PlayerbotAI* ai) : FarFromMasterTrigger(ai, "out of react range", sPlayerbotAIConfig.reactDistance / 2, 10) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/TriggerContext.h b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
new file mode 100644
index 0000000..9906cae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "HealthTriggers.h"
+#include "GenericTriggers.h"
+#include "LootTriggers.h"
+#include "../triggers/GenericTriggers.h"
+#include "LfgTriggers.h"
+
+namespace ai
+{
+
+    class TriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        TriggerContext()
+        {
+            creators["timer"] = &TriggerContext::Timer;
+            creators["random"] = &TriggerContext::Random;
+            creators["seldom"] = &TriggerContext::seldom;
+            creators["often"] = &TriggerContext::often;
+
+            creators["target critical health"] = &TriggerContext::TargetCriticalHealth;
+
+            creators["critical health"] = &TriggerContext::CriticalHealth;
+            creators["low health"] = &TriggerContext::LowHealth;
+            creators["medium health"] = &TriggerContext::MediumHealth;
+            creators["almost full health"] = &TriggerContext::AlmostFullHealth;
+
+            creators["low mana"] = &TriggerContext::LowMana;
+            creators["medium mana"] = &TriggerContext::MediumMana;
+
+            creators["party member critical health"] = &TriggerContext::PartyMemberCriticalHealth;
+            creators["party member low health"] = &TriggerContext::PartyMemberLowHealth;
+            creators["party member medium health"] = &TriggerContext::PartyMemberMediumHealth;
+            creators["party member almost full health"] = &TriggerContext::PartyMemberAlmostFullHealth;
+
+            creators["light rage available"] = &TriggerContext::LightRageAvailable;
+            creators["medium rage available"] = &TriggerContext::MediumRageAvailable;
+            creators["high rage available"] = &TriggerContext::HighRageAvailable;
+
+            creators["light energy available"] = &TriggerContext::LightEnergyAvailable;
+            creators["medium energy available"] = &TriggerContext::MediumEnergyAvailable;
+            creators["high energy available"] = &TriggerContext::HighEnergyAvailable;
+
+            creators["loot available"] = &TriggerContext::LootAvailable;
+            creators["no attackers"] = &TriggerContext::NoAttackers;
+            creators["no target"] = &TriggerContext::NoTarget;
+            creators["target in sight"] = &TriggerContext::TargetInSight;
+            creators["not least hp target active"] = &TriggerContext::not_least_hp_target_active;
+            creators["has nearest adds"] = &TriggerContext::has_nearest_adds;
+            creators["enemy player is attacking"] = &TriggerContext::enemy_player_is_attacking;
+
+            creators["tank aoe"] = &TriggerContext::TankAoe;
+            creators["lose aggro"] = &TriggerContext::LoseAggro;
+            creators["has aggro"] = &TriggerContext::HasAggro;
+
+            creators["light aoe"] = &TriggerContext::LightAoe;
+            creators["medium aoe"] = &TriggerContext::MediumAoe;
+            creators["high aoe"] = &TriggerContext::HighAoe;
+
+            creators["enemy out of melee"] = &TriggerContext::EnemyOutOfMelee;
+            creators["enemy out of spell"] = &TriggerContext::EnemyOutOfSpell;
+            creators["enemy too close for spell"] = &TriggerContext::enemy_too_close_for_spell;
+            creators["enemy too close for melee"] = &TriggerContext::enemy_too_close_for_melee;
+
+            creators["combo points available"] = &TriggerContext::ComboPointsAvailable;
+
+            creators["medium threat"] = &TriggerContext::MediumThreat;
+
+            creators["dead"] = &TriggerContext::Dead;
+            creators["party member dead"] = &TriggerContext::PartyMemberDead;
+            creators["no pet"] = &TriggerContext::no_pet;
+            creators["has attackers"] = &TriggerContext::has_attackers;
+            creators["no possible targets"] = &TriggerContext::no_possible_targets;
+
+            creators["no drink"] = &TriggerContext::no_drink;
+            creators["no food"] = &TriggerContext::no_food;
+
+            creators["panic"] = &TriggerContext::panic;
+            creators["behind target"] = &TriggerContext::behind_target;
+            creators["not facing target"] = &TriggerContext::not_facing_target;
+            creators["far from master"] = &TriggerContext::far_from_master;
+            creators["far from loot target"] = &TriggerContext::far_from_loot_target;
+            creators["can loot"] = &TriggerContext::can_loot;
+            creators["swimming"] = &TriggerContext::swimming;
+            creators["target changed"] = &TriggerContext::target_changed;
+
+            creators["critical aoe heal"] = &TriggerContext::critical_aoe_heal;
+            creators["low aoe heal"] = &TriggerContext::low_aoe_heal;
+            creators["medium aoe heal"] = &TriggerContext::medium_aoe_heal;
+            creators["invalid target"] = &TriggerContext::invalid_target;
+            creators["lfg proposal active"] = &TriggerContext::lfg_proposal_active;
+        }
+
+    private:
+        static Trigger* lfg_proposal_active(PlayerbotAI* ai) { return new LfgProposalActiveTrigger(ai); }
+        static Trigger* invalid_target(PlayerbotAI* ai) { return new InvalidTargetTrigger(ai); }
+        static Trigger* critical_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "critical aoe heal", "critical", 2); }
+        static Trigger* low_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "low aoe heal", "low", 2); }
+        static Trigger* medium_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "medium aoe heal", "medium", 2); }
+        static Trigger* target_changed(PlayerbotAI* ai) { return new TargetChangedTrigger(ai); }
+        static Trigger* swimming(PlayerbotAI* ai) { return new IsSwimmingTrigger(ai); }
+        static Trigger* no_possible_targets(PlayerbotAI* ai) { return new NoPossibleTargetsTrigger(ai); }
+        static Trigger* can_loot(PlayerbotAI* ai) { return new CanLootTrigger(ai); }
+        static Trigger* far_from_loot_target(PlayerbotAI* ai) { return new FarFromCurrentLootTrigger(ai); }
+        static Trigger* far_from_master(PlayerbotAI* ai) { return new FarFromMasterTrigger(ai); }
+        static Trigger* behind_target(PlayerbotAI* ai) { return new IsBehindTargetTrigger(ai); }
+        static Trigger* not_facing_target(PlayerbotAI* ai) { return new IsNotFacingTargetTrigger(ai); }
+        static Trigger* panic(PlayerbotAI* ai) { return new PanicTrigger(ai); }
+        static Trigger* no_drink(PlayerbotAI* ai) { return new NoDrinkTrigger(ai); }
+        static Trigger* no_food(PlayerbotAI* ai) { return new NoFoodTrigger(ai); }
+        static Trigger* LightAoe(PlayerbotAI* ai) { return new LightAoeTrigger(ai); }
+        static Trigger* MediumAoe(PlayerbotAI* ai) { return new MediumAoeTrigger(ai); }
+        static Trigger* HighAoe(PlayerbotAI* ai) { return new HighAoeTrigger(ai); }
+        static Trigger* LoseAggro(PlayerbotAI* ai) { return new LoseAggroTrigger(ai); }
+        static Trigger* HasAggro(PlayerbotAI* ai) { return new HasAggroTrigger(ai); }
+        static Trigger* LowHealth(PlayerbotAI* ai) { return new LowHealthTrigger(ai); }
+        static Trigger* MediumHealth(PlayerbotAI* ai) { return new MediumHealthTrigger(ai); }
+        static Trigger* AlmostFullHealth(PlayerbotAI* ai) { return new AlmostFullHealthTrigger(ai); }
+        static Trigger* CriticalHealth(PlayerbotAI* ai) { return new CriticalHealthTrigger(ai); }
+        static Trigger* TargetCriticalHealth(PlayerbotAI* ai) { return new TargetCriticalHealthTrigger(ai); }
+        static Trigger* LowMana(PlayerbotAI* ai) { return new LowManaTrigger(ai); }
+        static Trigger* MediumMana(PlayerbotAI* ai) { return new MediumManaTrigger(ai); }
+        static Trigger* LightRageAvailable(PlayerbotAI* ai) { return new LightRageAvailableTrigger(ai); }
+        static Trigger* MediumRageAvailable(PlayerbotAI* ai) { return new MediumRageAvailableTrigger(ai); }
+        static Trigger* HighRageAvailable(PlayerbotAI* ai) { return new HighRageAvailableTrigger(ai); }
+        static Trigger* LightEnergyAvailable(PlayerbotAI* ai) { return new LightEnergyAvailableTrigger(ai); }
+        static Trigger* MediumEnergyAvailable(PlayerbotAI* ai) { return new MediumEnergyAvailableTrigger(ai); }
+        static Trigger* HighEnergyAvailable(PlayerbotAI* ai) { return new HighEnergyAvailableTrigger(ai); }
+        static Trigger* LootAvailable(PlayerbotAI* ai) { return new LootAvailableTrigger(ai); }
+        static Trigger* NoAttackers(PlayerbotAI* ai) { return new NoAttackersTrigger(ai); }
+        static Trigger* TankAoe(PlayerbotAI* ai) { return new TankAoeTrigger(ai); }
+        static Trigger* Timer(PlayerbotAI* ai) { return new TimerTrigger(ai); }
+        static Trigger* NoTarget(PlayerbotAI* ai) { return new NoTargetTrigger(ai); }
+        static Trigger* TargetInSight(PlayerbotAI* ai) { return new TargetInSightTrigger(ai); }
+        static Trigger* not_least_hp_target_active(PlayerbotAI* ai) { return new NotLeastHpTargetActiveTrigger(ai); }
+        static Trigger* has_nearest_adds(PlayerbotAI* ai) { return new HasNearestAddsTrigger(ai); }
+        static Trigger* enemy_player_is_attacking(PlayerbotAI* ai) { return new EnemyPlayerIsAttacking(ai); }
+        static Trigger* Random(PlayerbotAI* ai) { return new RandomTrigger(ai); }
+        static Trigger* seldom(PlayerbotAI* ai) { return new SeldomTrigger(ai); }
+        static Trigger* often(PlayerbotAI* ai) { return new OftenTrigger(ai); }
+        static Trigger* EnemyOutOfMelee(PlayerbotAI* ai) { return new EnemyOutOfMeleeTrigger(ai); }
+        static Trigger* EnemyOutOfSpell(PlayerbotAI* ai) { return new EnemyOutOfSpellRangeTrigger(ai); }
+        static Trigger* enemy_too_close_for_spell(PlayerbotAI* ai) { return new EnemyTooCloseForSpellTrigger(ai); }
+        static Trigger* enemy_too_close_for_melee(PlayerbotAI* ai) { return new EnemyTooCloseForMeleeTrigger(ai); }
+        static Trigger* ComboPointsAvailable(PlayerbotAI* ai) { return new ComboPointsAvailableTrigger(ai); }
+        static Trigger* MediumThreat(PlayerbotAI* ai) { return new MediumThreatTrigger(ai); }
+        static Trigger* Dead(PlayerbotAI* ai) { return new DeadTrigger(ai); }
+        static Trigger* PartyMemberDead(PlayerbotAI* ai) { return new PartyMemberDeadTrigger(ai); }
+        static Trigger* PartyMemberLowHealth(PlayerbotAI* ai) { return new PartyMemberLowHealthTrigger(ai); }
+        static Trigger* PartyMemberMediumHealth(PlayerbotAI* ai) { return new PartyMemberMediumHealthTrigger(ai); }
+        static Trigger* PartyMemberAlmostFullHealth(PlayerbotAI* ai) { return new PartyMemberAlmostFullHealthTrigger(ai); }
+        static Trigger* PartyMemberCriticalHealth(PlayerbotAI* ai) { return new PartyMemberCriticalHealthTrigger(ai); }
+        static Trigger* no_pet(PlayerbotAI* ai) { return new NoPetTrigger(ai); }
+        static Trigger* has_attackers(PlayerbotAI* ai) { return new HasAttackersTrigger(ai); }
+
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
new file mode 100644
index 0000000..01c130a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
@@ -0,0 +1,76 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class WithinAreaTrigger : public Trigger {
+    public:
+        WithinAreaTrigger(PlayerbotAI* ai) : Trigger(ai, "within area trigger") {}
+
+        virtual bool IsActive()
+		{
+
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            if (!movement.lastAreaTrigger)
+                return false;
+
+            AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(movement.lastAreaTrigger);
+            if(!atEntry)
+                return false;
+
+            AreaTrigger const* at = sObjectMgr->GetAreaTrigger(movement.lastAreaTrigger);
+            if (!at)
+                return false;
+
+            return IsPointInAreaTriggerZone(atEntry, bot->GetMapId(), bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), 0.5f);
+        }
+
+    private:
+        bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, float x, float y, float z, float delta)
+        {
+            if (mapid != atEntry->mapid)
+                return false;
+
+            if (atEntry->radius > 0)
+            {
+                // if we have radius check it
+                float dist2 = (x - atEntry->x) * (x - atEntry->x) + (y - atEntry->y) * (y - atEntry->y) + (z - atEntry->z) * (z - atEntry->z);
+                if (dist2 > (atEntry->radius + delta) * (atEntry->radius + delta))
+                    return false;
+            }
+            else
+            {
+                // we have only extent
+
+                // rotate the players position instead of rotating the whole cube, that way we can make a simplified
+                // is-in-cube check and we have to calculate only one point instead of 4
+
+                // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
+                double rotation = 2 * M_PI - atEntry->box_orientation;
+                double sinVal = sin(rotation);
+                double cosVal = cos(rotation);
+
+                float playerBoxDistX = x - atEntry->x;
+                float playerBoxDistY = y - atEntry->y;
+
+                float rotPlayerX = float(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY * sinVal);
+                float rotPlayerY = float(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX * sinVal);
+
+                // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
+                float dz = z - atEntry->z;
+                float dx = rotPlayerX - atEntry->x;
+                float dy = rotPlayerY - atEntry->y;
+                if ((fabs(dx) > atEntry->box_x / 2 + delta) ||
+                        (fabs(dy) > atEntry->box_y / 2 + delta) ||
+                        (fabs(dz) > atEntry->box_z / 2 + delta))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
new file mode 100644
index 0000000..b0f8b87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class WorldPacketTrigger : public Trigger {
+    public:
+        WorldPacketTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL)
+        {
+            this->packet = packet;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), packet, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+    private:
+        WorldPacket packet;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
new file mode 100644
index 0000000..80a3376
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
@@ -0,0 +1,83 @@
+#pragma once
+
+#include "WorldPacketTrigger.h"
+#include "WithinAreaTrigger.h"
+
+namespace ai
+{
+    class WorldPacketTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        WorldPacketTriggerContext()
+        {
+            creators["gossip hello"] = &WorldPacketTriggerContext::gossip_hello;
+            creators["group invite"] = &WorldPacketTriggerContext::group_invite;
+            creators["group set leader"] = &WorldPacketTriggerContext::group_set_leader;
+            creators["not enough money"] = &WorldPacketTriggerContext::no_money;
+            creators["not enough reputation"] = &WorldPacketTriggerContext::no_reputation;
+            creators["cannot equip"] = &WorldPacketTriggerContext::cannot_equip;
+            creators["use game object"] = &WorldPacketTriggerContext::use_game_object;
+            creators["complete quest"] = &WorldPacketTriggerContext::complete_quest;
+            creators["accept quest"] = &WorldPacketTriggerContext::accept_quest;
+            creators["quest share"] = &WorldPacketTriggerContext::quest_share;
+            creators["loot roll"] = &WorldPacketTriggerContext::loot_roll;
+            creators["resurrect request"] = &WorldPacketTriggerContext::resurrect_request;
+            creators["area trigger"] = &WorldPacketTriggerContext::area_trigger;
+            creators["within area trigger"] = &WorldPacketTriggerContext::within_area_trigger;
+            creators["check mount state"] = &WorldPacketTriggerContext::check_mount_state;
+            creators["activate taxi"] = &WorldPacketTriggerContext::taxi;
+            creators["trade status"] = &WorldPacketTriggerContext::trade_status;
+            creators["loot response"] = &WorldPacketTriggerContext::loot_response;
+            creators["out of react range"] = &WorldPacketTriggerContext::out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketTriggerContext::quest_objective_completed;
+            creators["item push result"] = &WorldPacketTriggerContext::item_push_result;
+            creators["party command"] = &WorldPacketTriggerContext::party_command;
+            creators["taxi done"] = &WorldPacketTriggerContext::taxi_done;
+            creators["cast failed"] = &WorldPacketTriggerContext::cast_failed;
+            creators["duel requested"] = &WorldPacketTriggerContext::duel_requested;
+            creators["ready check"] = &WorldPacketTriggerContext::ready_check;
+            creators["ready check finished"] = &WorldPacketTriggerContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketTriggerContext::uninvite;
+            creators["lfg join"] = &WorldPacketTriggerContext::lfg_update;
+            creators["lfg proposal"] = &WorldPacketTriggerContext::lfg_proposal;
+            creators["lfg role check"] = &WorldPacketTriggerContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketTriggerContext::lfg_leave;
+            creators["guild invite"] = &WorldPacketTriggerContext::guild_invite;
+        }
+
+    private:
+        static Trigger* guild_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "guild invite"); }
+        static Trigger* lfg_leave(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg leave"); }
+        static Trigger* lfg_proposal(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg proposal"); }
+        static Trigger* lfg_role_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg role check"); }
+        static Trigger* lfg_update(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg join"); }
+        static Trigger* uninvite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "uninvite"); }
+        static Trigger* ready_check_finished(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check finished"); }
+        static Trigger* ready_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check"); }
+        static Trigger* duel_requested(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "duel requested"); }
+        static Trigger* cast_failed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cast failed"); }
+        static Trigger* taxi_done(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "taxi done"); }
+        static Trigger* party_command(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "party command"); }
+        static Trigger* item_push_result(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "item push result"); }
+        static Trigger* quest_objective_completed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest objective completed"); }
+        static Trigger* out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeTrigger(ai); }
+        static Trigger* loot_response(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot response"); }
+        static Trigger* trade_status(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "trade status"); }
+        static Trigger* cannot_equip(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cannot equip"); }
+        static Trigger* check_mount_state(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "check mount state"); }
+        static Trigger* area_trigger(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "area trigger"); }
+        static Trigger* within_area_trigger(PlayerbotAI* ai) { return new WithinAreaTrigger(ai); }
+        static Trigger* resurrect_request(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "resurrect request"); }
+        static Trigger* gossip_hello(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "gossip hello"); }
+        static Trigger* group_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group invite"); }
+        static Trigger* group_set_leader(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group set leader"); }
+        static Trigger* no_money(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough money"); }
+        static Trigger* no_reputation(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough reputation"); }
+        static Trigger* use_game_object(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "use game object"); }
+        static Trigger* complete_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "complete quest"); }
+        static Trigger* accept_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "accept quest"); }
+        static Trigger* quest_share(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest share"); }
+        static Trigger* loot_roll(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot roll"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "activate taxi"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
new file mode 100644
index 0000000..22c2f3a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AlwaysLootListValue : public ManualSetValue<set<uint32>&>
+	{
+	public:
+        AlwaysLootListValue(PlayerbotAI* ai) : ManualSetValue<set<uint32>&>(ai, list) {}
+
+    private:
+        set<uint32> list;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.cpp b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
new file mode 100644
index 0000000..14c50b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AoeHealValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 AoeHealValue::Calculate()
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+    	return 0;
+
+    float range = 0;
+    if (qualifier == "low")
+    	range = sPlayerbotAIConfig.lowHealth;
+    else if (qualifier == "medium")
+    	range = sPlayerbotAIConfig.mediumHealth;
+    else if (qualifier == "critical")
+    	range = sPlayerbotAIConfig.criticalHealth;
+
+    uint8 count = 0;
+	Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+	for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+	{
+		Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+		if( !player || !player->IsAlive())
+			continue;
+
+	    float percent = (static_cast<float> (player->GetHealth()) / player->GetMaxHealth()) * 100;
+	    if (percent <= range)
+	    	count++;
+	}
+
+	return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.h b/src/plugins/playerbot/strategy/values/AoeHealValues.h
new file mode 100644
index 0000000..d7d52c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AoeHealValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+    	AoeHealValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
new file mode 100644
index 0000000..a406a90
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
@@ -0,0 +1,107 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerCountValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 MyAttackerCountValue::Calculate()
+{
+    return bot->getAttackers().size();
+}
+
+bool HasAggroValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return true;
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true; // simulate as target is not atacking anybody yet
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == bot && target == attacker)
+            return true;
+        ref = ref->next();
+    }
+    return false;
+}
+
+uint8 AttackerCountValue::Calculate()
+{
+    int count = 0;
+    float range = sPlayerbotAIConfig.sightDistance;
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        float distance = bot->GetDistance(unit);
+        if (distance <= range)
+            count++;
+    }
+
+    return count;
+}
+
+uint8 BalancePercentValue::Calculate()
+{
+    float playerLevel = 0,
+        attackerLevel = 0;
+
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !player || !player->IsAlive())
+                continue;
+
+            playerLevel += player->getLevel();
+        }
+    }
+
+    list<ObjectGuid> v = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+
+    for (list<ObjectGuid>::iterator i = v.begin(); i!=v.end(); i++)
+    {
+        Creature* creature = ai->GetCreature((*i));
+        if (!creature || !creature->IsAlive())
+            continue;
+
+        uint32 level = creature->getLevel();
+
+        switch (creature->GetCreatureTemplate()->rank) {
+        case CREATURE_ELITE_RARE:
+            level *= 2;
+            break;
+        case CREATURE_ELITE_ELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_RAREELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_WORLDBOSS:
+            level *= 5;
+            break;
+        }
+        attackerLevel += level;
+    }
+
+    if (!attackerLevel)
+        return 100;
+
+    float percent = playerLevel * 100 / attackerLevel;
+    return percent <= 200 ? (uint8)percent : 200;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.h b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
new file mode 100644
index 0000000..9c77a3f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
@@ -0,0 +1,59 @@
+#pragma once
+#include "StatsValues.h"
+
+namespace ai
+{
+
+    class AttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        AttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class MyAttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        MyAttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasAggroValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasAggroValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class BalancePercentValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        BalancePercentValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
new file mode 100644
index 0000000..10da8d2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* AttackerWithoutAuraTargetValue::Calculate()
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->HasAura(qualifier, unit))
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
new file mode 100644
index 0000000..70a8983
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AttackerWithoutAuraTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        AttackerWithoutAuraTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "attacker without aura") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.cpp b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
new file mode 100644
index 0000000..3f452c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
@@ -0,0 +1,87 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackersValue.h"
+
+using namespace ai;
+
+list<ObjectGuid> AttackersValue::Calculate()
+{
+    set<Unit*> targets;
+
+    AddAttackersOf(bot, targets);
+
+    Group* group = bot->GetGroup();
+    if (group)
+        AddAttackersOf(group, targets);
+
+    RemoveNonThreating(targets);
+
+    list<ObjectGuid> result;
+	for (set<Unit*>::iterator i = targets.begin(); i != targets.end(); i++)
+		result.push_back((*i)->GetGUID());
+
+    if (bot->duel && bot->duel->opponent)
+        result.push_back(bot->duel->opponent->GetGUID());
+
+	return result;
+}
+
+void AttackersValue::AddAttackersOf(Group* group, set<Unit*>& targets)
+{
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if (!member || !member->IsAlive() || member == bot)
+            continue;
+
+        AddAttackersOf(member, targets);
+    }
+}
+
+void AttackersValue::AddAttackersOf(Player* player, set<Unit*>& targets)
+{
+    if (player->IsBeingTeleported())
+        return;
+
+    HostileReference *ref = player->getHostileRefManager().getFirst();
+    if (!ref)
+        return; // simulate as target is not atacking anybody yet
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == player)
+            targets.insert(attacker);
+        ref = ref->next();
+    }
+}
+
+void AttackersValue::RemoveNonThreating(set<Unit*>& targets)
+{
+    for(set<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        Unit* unit = *tIter;
+        if(!bot->IsWithinLOSInMap(unit) || bot->GetMapId() != unit->GetMapId() || !hasRealThreat(unit))
+        {
+            set<Unit *>::iterator tIter2 = tIter;
+            ++tIter;
+            targets.erase(tIter2);
+        }
+        else
+            ++tIter;
+    }
+}
+
+bool AttackersValue::hasRealThreat(Unit *attacker)
+{
+    return attacker &&
+        attacker->IsInWorld() &&
+        attacker->IsAlive() &&
+        !attacker->IsPolymorphed() &&
+        !attacker->isInRoots() &&
+        !attacker->IsFriendlyTo(bot) &&
+        (attacker->getThreatManager().getCurrentVictim() || dynamic_cast<Player*>(attacker));
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.h b/src/plugins/playerbot/strategy/values/AttackersValue.h
new file mode 100644
index 0000000..a7d9d6c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "NearestUnitsValue.h"
+
+namespace ai
+{
+    class AttackersValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        AttackersValue(PlayerbotAI* ai) : ObjectGuidListCalculatedValue(ai, "attackers", 5) {}
+        list<ObjectGuid> Calculate();
+
+	private:
+        void AddAttackersOf(Group* group, set<Unit*>& targets);
+        void AddAttackersOf(Player* player, set<Unit*>& targets);
+		void RemoveNonThreating(set<Unit*>& targets);
+		bool hasRealThreat(Unit* attacker);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AvailableLootValue.h b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
new file mode 100644
index 0000000..806f2ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
@@ -0,0 +1,40 @@
+#pragma once
+#include "../Value.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+   
+    class AvailableLootValue : public ManualSetValue<LootObjectStack*>
+	{
+	public:
+        AvailableLootValue(PlayerbotAI* ai) : ManualSetValue<LootObjectStack*>(ai, NULL) 
+        {
+            value = new LootObjectStack(ai->GetBot());
+        }
+
+        virtual ~AvailableLootValue()
+        {
+            if (value) 
+                delete value;
+        }
+    };
+
+    class LootTargetValue : public ManualSetValue<LootObject>
+    {
+    public:
+        LootTargetValue(PlayerbotAI* ai) : ManualSetValue<LootObject>(ai, LootObject()) {}
+    };
+
+    class CanLootValue : public BoolCalculatedValue
+    {
+    public:
+        CanLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            LootObject loot = AI_VALUE(LootObject, "loot target");
+            return !loot.IsEmpty() && loot.GetWorldObject(bot) && AI_VALUE2(float, "distance", "loot target") <= INTERACTION_DISTANCE;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
new file mode 100644
index 0000000..2660a81
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CcTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../Action.h"
+
+using namespace ai;
+
+class FindTargetForCcStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForCcStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+        maxDistance = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("current target") == creature)
+            return;
+
+        uint8 health = creature->GetHealthPct();
+        if (health < sPlayerbotAIConfig.mediumHealth)
+            return;
+
+        if (!ai->CanCastSpell(spell, creature))
+            return;
+
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("rti target") == creature)
+        {
+            result = creature;
+            return;
+        }
+
+        float minDistance = sPlayerbotAIConfig.spellDistance;
+        Group* group = bot->GetGroup();
+        if (!group)
+            return;
+
+        if (group->GetTargetIcon(4) == creature->GetGUID())
+        {
+            result = creature;
+            return;
+        }
+
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+        if (!tankCount || !dpsCount)
+        {
+            result = creature;
+            return;
+        }
+
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !member || !member->IsAlive() || member == bot)
+                continue;
+
+            if (!ai->IsTank(member))
+                continue;
+
+            float distance = member->GetDistance(creature);
+            if (distance < minDistance)
+                minDistance = distance;
+        }
+
+        if (!result || minDistance > maxDistance)
+        {
+            result = creature;
+            maxDistance = minDistance;
+        }
+    }
+
+private:
+    string spell;
+    float maxDistance;
+};
+
+Unit* CcTargetValue::Calculate()
+{
+    FindTargetForCcStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.h b/src/plugins/playerbot/strategy/values/CcTargetValue.h
new file mode 100644
index 0000000..a27f8c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ChatValue.h b/src/plugins/playerbot/strategy/values/ChatValue.h
new file mode 100644
index 0000000..b39a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ChatValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ChatValue : public ManualSetValue<ChatMsg>
+	{
+	public:
+        ChatValue(PlayerbotAI* ai) : ManualSetValue<ChatMsg>(ai, CHAT_MSG_WHISPER) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
new file mode 100644
index 0000000..932b0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentCcTargetValue.h"
+
+using namespace ai;
+
+class FindCurrentCcTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindCurrentCcTargetStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (ai->HasAura(spell, attacker))
+            result = attacker;
+    }
+
+private:
+    string spell;
+};
+
+
+Unit* CurrentCcTargetValue::Calculate()
+{
+    FindCurrentCcTargetStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
new file mode 100644
index 0000000..30646c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CurrentCcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CurrentCcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
new file mode 100644
index 0000000..14accb1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
@@ -0,0 +1,22 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentTargetValue.h"
+
+using namespace ai;
+
+Unit* CurrentTargetValue::Get()
+{
+    if (selection.IsEmpty())
+        return NULL;
+
+    Unit* unit = sObjectAccessor->GetUnit(*bot, selection);
+    if (unit && !bot->IsWithinLOSInMap(unit))
+        return NULL;
+
+    return unit;
+}
+
+void CurrentTargetValue::Set(Unit* target)
+{
+    selection = target ? target->GetGUID() : ObjectGuid::Empty;
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
new file mode 100644
index 0000000..6b9fb69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class CurrentTargetValue : public UnitManualSetValue
+	{
+	public:
+        CurrentTargetValue(PlayerbotAI* ai) : UnitManualSetValue(ai, NULL) {}
+
+        virtual Unit* Get();
+        virtual void Set(Unit* unit);
+
+    private:
+        ObjectGuid selection;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DistanceValue.h b/src/plugins/playerbot/strategy/values/DistanceValue.h
new file mode 100644
index 0000000..43277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DistanceValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class DistanceValue : public FloatCalculatedValue, public Qualified
+	{
+	public:
+        DistanceValue(PlayerbotAI* ai) : FloatCalculatedValue(ai) {}
+
+    public:
+        float Calculate()
+        {
+            if (qualifier == "loot target")
+            {
+                LootObject loot = AI_VALUE(LootObject, qualifier);
+                if (loot.IsEmpty())
+                    return 0.0f;
+
+                WorldObject* obj = loot.GetWorldObject(bot);
+                if (!obj)
+                    return 0.0f;
+
+                return ai->GetBot()->GetDistance(obj);
+            }
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target || !target->IsInWorld())
+                return 0.0f;
+
+            return ai->GetBot()->GetDistance(target);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
new file mode 100644
index 0000000..afcdcbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForDpsStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForDpsStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        maxTankCount = 0;
+        minDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        float threat = threatManager->getThreat(ai->GetBot());
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            minThreat >= threat && (maxTankCount <= tankCount || minDpsCount >= dpsCount))
+        {
+            minThreat = threat;
+            maxTankCount = tankCount;
+            minDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int maxTankCount;
+    int minDpsCount;
+};
+
+
+Unit* DpsTargetValue::Calculate()
+{
+    FindTargetForDpsStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.h b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
new file mode 100644
index 0000000..dcfcc8b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class DpsTargetValue : public TargetValue
+	{
+	public:
+        DpsTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
new file mode 100644
index 0000000..06c9bf3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelTargetValue.h"
+
+using namespace ai;
+
+Unit* DuelTargetValue::Calculate()
+{
+    return bot->duel ? bot->duel->opponent : NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.h b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
new file mode 100644
index 0000000..9e7d2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class DuelTargetValue : public TargetValue
+	{
+	public:
+        DuelTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
new file mode 100644
index 0000000..d4df967
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyHealerTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* EnemyHealerTargetValue::Calculate()
+{
+    string spell = qualifier;
+
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->IsInterruptableSpellCasting(unit, spell))
+            continue;
+
+        Spell* spell = unit->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+
+        spell = unit->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
new file mode 100644
index 0000000..bea36c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class EnemyHealerTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        EnemyHealerTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "enemy healer target") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
new file mode 100644
index 0000000..5576e75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyPlayerValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindEnemyPlayerStrategy : public FindTargetStrategy
+{
+public:
+    FindEnemyPlayerStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result)
+        {
+            Player* enemy = dynamic_cast<Player*>(attacker);
+            if (enemy && ai->IsOpposing(enemy) && enemy->IsOutdoorPvPActive())
+                result = attacker;
+        }
+    }
+
+};
+
+
+Unit* EnemyPlayerValue::Calculate()
+{
+    FindEnemyPlayerStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
new file mode 100644
index 0000000..ea50739
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class EnemyPlayerValue : public TargetValue
+	{
+	public:
+        EnemyPlayerValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.cpp b/src/plugins/playerbot/strategy/values/Formations.cpp
new file mode 100644
index 0000000..dce0fb7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.cpp
@@ -0,0 +1,333 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "Formations.h"
+#include "formations/Arrow.h"
+
+using namespace ai;
+
+WorldLocation Formation::NullLocation = WorldLocation();
+
+namespace ai
+{
+    class MeleeFormation : public FollowFormation
+    {
+    public:
+        MeleeFormation(PlayerbotAI* ai) : FollowFormation(ai, "melee") {}
+        virtual string GetTargetName() { return "master target"; }
+    };
+
+    class QueueFormation : public FollowFormation
+    {
+    public:
+        QueueFormation(PlayerbotAI* ai) : FollowFormation(ai, "queue") {}
+        virtual string GetTargetName() { return "line target"; }
+    };
+
+    class ChaosFormation : public MoveFormation
+    {
+    public:
+        ChaosFormation(PlayerbotAI* ai) : MoveFormation(ai, "chaos") {}
+        virtual WorldLocation GetLocation()
+        {
+            Player* master = GetMaster();
+            if (!master)
+                return WorldLocation();
+
+            float range = sPlayerbotAIConfig.lootDistance * (float)(rand() % 10) / 10;
+			float angle = GetFollowAngle();
+            float x = master->GetPositionX() + cos(angle) * range;
+            float y = master->GetPositionY() + sin(angle) * range;
+            float z = master->GetPositionZ();
+
+            return WorldLocation(master->GetMapId(), x, y, z);
+        }
+
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.lootDistance; }
+    };
+
+    class CircleFormation : public MoveFormation
+    {
+    public:
+        CircleFormation(PlayerbotAI* ai) : MoveFormation(ai, "circle") {}
+        virtual WorldLocation GetLocation()
+        {
+            float range = 2.0f;
+
+            Unit* target = AI_VALUE(Unit*, "current target");
+            Player* master = GetMaster();
+            if (!target)
+                target = master;
+
+            if (!target)
+				return Formation::NullLocation;
+
+            switch (bot->getClass())
+            {
+            case CLASS_HUNTER:
+            case CLASS_MAGE:
+            case CLASS_PRIEST:
+            case CLASS_WARLOCK:
+                range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_DRUID:
+                if (!ai->IsTank(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_SHAMAN:
+                if (ai->IsHeal(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            }
+
+            float x = target->GetPositionX();
+            float y = target->GetPositionY();
+            float z = target->GetPositionZ();
+            float angle = GetFollowAngle();
+
+            return WorldLocation(bot->GetMapId(), x + cos(angle) * range, y + sin(angle) * range, z);
+        }
+    };
+
+    class LineFormation : public MoveFormation
+    {
+    public:
+        LineFormation(PlayerbotAI* ai) : MoveFormation(ai, "line") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = 2.0f;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> players;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                    players.push_back(member);
+
+                gref = gref->next();
+            }
+
+            players.insert(players.begin() + group->GetMembersCount() / 2, master);
+
+            return MoveLine(players, 0.0f, x, y, z, orientation, range);
+        }
+    };
+
+    class ShieldFormation : public MoveFormation
+    {
+    public:
+        ShieldFormation(PlayerbotAI* ai) : MoveFormation(ai, "shield") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = sPlayerbotAIConfig.followDistance;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> tanks;
+            vector<Player*> dps;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                {
+                    if (ai->IsTank(member))
+                        tanks.push_back(member);
+                    else
+                        dps.push_back(member);
+                }
+
+                gref = gref->next();
+            }
+
+            if (ai->IsTank(master))
+                tanks.insert(tanks.begin() + (tanks.size() + 1) / 2, master);
+            else
+                dps.insert(dps.begin() + (dps.size() + 1) / 2, master);
+
+            if (ai->IsTank(bot) && ai->IsTank(master))
+            {
+                return MoveLine(tanks, 0.0f, x, y, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                return MoveLine(dps, 0.0f, x, y, z, orientation, range);
+            }
+            if (ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                float diff = tanks.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(tanks, diff, x + cos(orientation) * range, y + sin(orientation) * range, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && ai->IsTank(master))
+            {
+                float diff = dps.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(dps, diff, x - cos(orientation) * range, y - sin(orientation) * range, z, orientation, range);
+            }
+            return Formation::NullLocation;
+        }
+    };
+};
+
+float Formation::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+FormationValue::FormationValue(PlayerbotAI* ai) : ManualSetValue<Formation*>(ai, new MeleeFormation(ai), "formation")
+{
+}
+
+bool SetFormationAction::Execute(Event event)
+{
+    string formation = event.getParam();
+
+	Value<Formation*>* value = context->GetValue<Formation*>("formation");
+    if (formation == "?" || formation.empty())
+    {
+        ostringstream str; str << "Formation: |cff00ff00" << value->Get()->getName();
+        ai->TellMaster(str);
+        return true;
+    }
+
+    if (formation == "melee" || formation == "default")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new MeleeFormation(ai));
+    }
+    else if (formation == "queue")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new QueueFormation(ai));
+    }
+    else if (formation == "chaos")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ChaosFormation(ai));
+    }
+    else if (formation == "circle")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new CircleFormation(ai));
+    }
+    else if (formation == "line")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new LineFormation(ai));
+    }
+    else if (formation == "shield")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ShieldFormation(ai));
+    }
+    else if (formation == "arrow")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ArrowFormation(ai));
+    }
+    else
+    {
+        ostringstream str; str << "Invalid formation: |cffff0000" << formation;
+        ai->TellMaster(str);
+        ai->TellMaster("Please set to any of:|cffffffff melee (default), queue, chaos, circle, line, shield, arrow");
+        return false;
+    }
+
+    ostringstream str; str << "Formation set to: " << formation;
+    ai->TellMaster(str);
+    return true;
+}
+
+
+WorldLocation MoveFormation::MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    if (line.size() < 5)
+    {
+        return MoveSingleLine(line, diff, cx, cy, cz, orientation, range);
+    }
+
+    int lines = ceil((double)line.size() / 5.0);
+    for (int i = 0; i < lines; i++)
+    {
+        float radius = range * i;
+        float x = cx + cos(orientation) * radius;
+        float y = cy + sin(orientation) * radius;
+        vector<Player*> singleLine;
+        for (int j = 0; j < 5 && !line.empty(); j++)
+        {
+            singleLine.push_back(line[line.size() - 1]);
+            line.pop_back();
+        }
+
+        WorldLocation loc = MoveSingleLine(singleLine, diff, x, y,cz, orientation, range);
+        if (loc != Formation::NullLocation)
+            return loc;
+    }
+
+    return Formation::NullLocation;
+}
+
+WorldLocation MoveFormation::MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    float count = line.size();
+    float angle = orientation - M_PI / 2.0f;
+    float x = cx + cos(angle) * (range * floor(count / 2.0f) + diff);
+    float y = cy + sin(angle) * (range * floor(count / 2.0f) + diff);
+
+    int index = 0;
+    for (vector<Player*>::iterator i = line.begin(); i != line.end(); i++)
+    {
+        Player* member = *i;
+
+        if (member == bot)
+        {
+            float angle = orientation + M_PI / 2.0f;
+            float radius = range * index;
+
+            return WorldLocation(bot->GetMapId(), x + cos(angle) * radius, y + sin(angle) * radius, cz);
+        }
+
+        index++;
+    }
+
+    return Formation::NullLocation;
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.h b/src/plugins/playerbot/strategy/values/Formations.h
new file mode 100644
index 0000000..2589cd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.h
@@ -0,0 +1,52 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class Formation : public AiNamedObject
+    {
+    public:
+        Formation(PlayerbotAI* ai, string name) : AiNamedObject (ai, name) {}
+
+    public:
+        virtual string GetTargetName() { return ""; }
+        virtual WorldLocation GetLocation() { return NullLocation; }
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.followDistance; }
+        static WorldLocation NullLocation;
+
+    protected:
+        float GetFollowAngle();
+    };
+
+    class FollowFormation : public Formation
+    {
+    public:
+        FollowFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+    };
+
+    class MoveFormation : public Formation
+    {
+    public:
+        MoveFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+
+    protected:
+        WorldLocation MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+        WorldLocation MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+    };
+
+    class FormationValue : public ManualSetValue<Formation*>
+	{
+	public:
+        FormationValue(PlayerbotAI* ai);
+        ~FormationValue() { if (value) { delete value; value = NULL; } }
+    };
+
+    class SetFormationAction : public Action
+    {
+    public:
+        SetFormationAction(PlayerbotAI* ai) : Action(ai, "set formation") {}
+        virtual bool Execute(Event event);
+    };
+};
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
new file mode 100644
index 0000000..96448c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
@@ -0,0 +1,116 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+Unit* GrindTargetValue::Calculate()
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    if (group)
+        memberCount = group->GetMembersCount();
+
+    Unit* target = NULL;
+    uint32 assistCount = 0;
+    while (!target && assistCount < memberCount)
+    {
+        target = FindTargetForGrinding(assistCount++);
+    }
+
+    return target;
+}
+
+
+Unit* GrindTargetValue::FindTargetForGrinding(int assistCount)
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    Player* master = GetMaster();
+
+    list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+
+    if(targets.empty())
+        return NULL;
+
+    float distance = 0;
+    Unit* result = NULL;
+    for(list<ObjectGuid>::iterator tIter = targets.begin(); tIter != targets.end(); tIter++)
+    {
+        Unit* unit = ai->GetUnit(*tIter);
+        if (!unit)
+            continue;
+
+        if (abs(bot->GetPositionZ() - unit->GetPositionZ()) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (GetTargetingPlayerCount(unit) > assistCount)
+            continue;
+
+		if (master && master->GetDistance(unit) >= sPlayerbotAIConfig.grindDistance && !sRandomPlayerbotMgr.IsRandomBot(bot))
+            continue;
+
+		if ((int)unit->getLevel() - (int)bot->getLevel() > 3)
+		    continue;
+
+		Creature* creature = dynamic_cast<Creature*>(unit);
+		if (creature && creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->rank > CREATURE_ELITE_NORMAL)
+		    continue;
+
+        if (group)
+        {
+            Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                if( !member || !member->IsAlive())
+                    continue;
+
+                float d = member->GetDistance(unit);
+                if (!result || d < distance)
+                {
+                    distance = d;
+                    result = unit;
+                }
+            }
+        }
+        else
+        {
+            float d = bot->GetDistance(unit);
+            if (!result || d < distance)
+            {
+                distance = d;
+                result = unit;
+            }
+        }
+    }
+
+    return result;
+}
+
+
+int GrindTargetValue::GetTargetingPlayerCount( Unit* unit )
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    int count = 0;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !member || !member->IsAlive() || member == bot)
+            continue;
+
+        PlayerbotAI* ai = member->GetPlayerbotAI();
+        if ((ai && *ai->GetAiObjectContext()->GetValue<Unit*>("current target") == unit) ||
+            (!ai && member->GetSelectedUnit() == unit))
+            count++;
+    }
+
+    return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.h b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
new file mode 100644
index 0000000..f333297
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class GrindTargetValue : public TargetValue
+	{
+	public:
+        GrindTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+
+    private:
+        int GetTargetingPlayerCount(Unit* unit);
+        Unit* FindTargetForGrinding(int assistCount);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
new file mode 100644
index 0000000..3dac17f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class HasAvailableLootValue : public BoolCalculatedValue
+	{
+	public:
+        HasAvailableLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        virtual bool Calculate()
+        {
+            return !AI_VALUE(bool, "can loot") &&
+                    AI_VALUE(LootObjectStack*, "available loot")->CanLoot(sPlayerbotAIConfig.lootDistance) &&
+                    !bot->IsMounted();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasTotemValue.h b/src/plugins/playerbot/strategy/values/HasTotemValue.h
new file mode 100644
index 0000000..a65b3a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasTotemValue.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class HasTotemValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        HasTotemValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        bool Calculate()
+        {
+            list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+            for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+            {
+                Unit* unit = ai->GetUnit(*i);
+                if (!unit)
+                    continue;
+
+                Creature* creature = dynamic_cast<Creature*>(unit);
+                if (!creature || !creature->IsTotem())
+                    continue;
+
+                if (strstri(creature->GetName().c_str(), qualifier.c_str()) && bot->GetDistance(creature) <= sPlayerbotAIConfig.spellDistance)
+                    return true;
+            }
+
+            return false;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
new file mode 100644
index 0000000..41440c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InvalidTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool InvalidTargetValue::Calculate()
+{
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    if (qualifier == "current target")
+    {
+        return !target ||
+                target->GetMapId() != bot->GetMapId() ||
+                target->isDead() ||
+                target->IsPolymorphed() ||
+                target->IsCharmed() ||
+                target->isFeared() ||
+                target->HasUnitState(UNIT_STATE_ISOLATED) ||
+                target->IsFriendlyTo(bot) ||
+                !bot->IsWithinDistInMap(target, sPlayerbotAIConfig.sightDistance) ||
+                !bot->IsWithinLOSInMap(target);
+    }
+
+    return !target;
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.h b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
new file mode 100644
index 0000000..5d277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class InvalidTargetValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        InvalidTargetValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+	public:
+        virtual bool Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsBehindValue.h b/src/plugins/playerbot/strategy/values/IsBehindValue.h
new file mode 100644
index 0000000..da61670
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsBehindValue.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsBehindValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsBehindValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate() 
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            
+            float targetOrientation = target->GetOrientation();
+            float orientation = bot->GetOrientation();
+            float distance = bot->GetDistance(target);
+
+            return distance <= ATTACK_DISTANCE && abs(targetOrientation - orientation) < M_PI / 2;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsFacingValue.h b/src/plugins/playerbot/strategy/values/IsFacingValue.h
new file mode 100644
index 0000000..814014f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsFacingValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsFacingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsFacingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            return bot->isInFront(target, M_PI / 3.0f);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsMovingValue.h b/src/plugins/playerbot/strategy/values/IsMovingValue.h
new file mode 100644
index 0000000..bbee8bd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsMovingValue.h
@@ -0,0 +1,42 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsMovingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsMovingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            switch (target->GetMotionMaster()->GetCurrentMovementGeneratorType())
+            {
+            case IDLE_MOTION_TYPE:
+                return false;
+            }
+            return true;
+        }
+    };
+
+    class IsSwimmingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsSwimmingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            return target->IsUnderWater() || target->IsInWater();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.cpp b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
new file mode 100644
index 0000000..2b6c0a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemCountValue.h"
+
+using namespace ai;
+
+list<Item*> InventoryItemValueBase::Find(string qualifier)
+{
+    list<Item*> result;
+
+    Player* bot = InventoryAction::ai->GetBot();
+
+    list<Item*> items = InventoryAction::parseItems(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); i++)
+        result.push_back(*i);
+
+    return result;
+}
+
+
+uint8 ItemCountValue::Calculate()
+{
+    uint8 count = 0;
+    list<Item*> items = Find(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* item = *i;
+        count += item->GetCount();
+    }
+
+    return count;
+}
+
+list<Item*> InventoryItemValue::Calculate()
+{
+    return Find(qualifier);
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.h b/src/plugins/playerbot/strategy/values/ItemCountValue.h
new file mode 100644
index 0000000..f81d9b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "../ItemVisitors.h"
+#include "../actions/InventoryAction.h"
+
+namespace ai
+{
+    class InventoryItemValueBase : public InventoryAction
+    {
+    public:
+        InventoryItemValueBase(PlayerbotAI* ai) : InventoryAction(ai, "empty") {}
+        virtual bool Execute(Event event) { return false; }
+
+    protected:
+        list<Item*> Find(string qualifier);
+    };
+
+    class ItemCountValue : public Uint8CalculatedValue, public Qualified, InventoryItemValueBase
+	{
+	public:
+        ItemCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual uint8 Calculate();
+	};
+
+    class InventoryItemValue : public CalculatedValue<list<Item*> >, public Qualified, InventoryItemValueBase
+    {
+    public:
+        InventoryItemValue(PlayerbotAI* ai) : CalculatedValue<list<Item*> >(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual list<Item*> Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
new file mode 100644
index 0000000..671cd97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemForSpellValue.h"
+
+using namespace ai;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+Item* ItemForSpellValue::Calculate()
+{
+    uint32 spellid = atoi(qualifier.c_str());
+    if (!spellid)
+        return NULL;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+    if (!spellInfo)
+        return NULL;
+
+    Item* itemForSpell = NULL;
+    Player* trader = bot->GetTrader();
+    if (trader)
+    {
+        itemForSpell = trader->GetTradeData()->GetItem(TRADE_SLOT_NONTRADED);
+        if (itemForSpell && itemForSpell->IsFitToSpellRequirements(spellInfo))
+            return itemForSpell;
+    }
+
+    // Workaround as some spells have no item mask (e.g. shaman weapon enhancements)
+    if (!strcmpi(spellInfo->SpellName[0], "rockbiter weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "flametongue weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "earthliving weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "frostbrand weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "windfury weapon"))
+    {
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_MAINHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_OFFHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        return NULL;
+    }
+
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++ ) {
+        itemForSpell = GetItemFitsToSpellRequirements(slot, spellInfo);
+        if (itemForSpell)
+            return itemForSpell;
+    }
+    return NULL;
+}
+
+Item* ItemForSpellValue::GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo)
+{
+    Item* const itemForSpell = bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+    if (!itemForSpell || itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+        return NULL;
+
+    if (itemForSpell->IsFitToSpellRequirements(spellInfo))
+        return itemForSpell;
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.h b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
new file mode 100644
index 0000000..39ce6af
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class ItemForSpellValue : public CalculatedValue<Item*>, public Qualified
+	{
+	public:
+        ItemForSpellValue(PlayerbotAI* ai) : CalculatedValue<Item*>(ai) {}
+
+    public:
+        virtual Item* Calculate();
+
+    private:
+        Item* GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastMovementValue.h b/src/plugins/playerbot/strategy/values/LastMovementValue.h
new file mode 100644
index 0000000..0467833
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastMovementValue.h
@@ -0,0 +1,61 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastMovement
+    {
+    public:
+        LastMovement() 
+        {
+            lastMoveToX = 0;
+            lastMoveToY = 0;
+            lastMoveToZ = 0;
+            lastMoveToOri = 0;
+            lastFollow = NULL;
+        }
+
+        LastMovement(LastMovement& other)
+        {
+            taxiNodes = other.taxiNodes;
+            taxiMaster = other.taxiMaster;
+            lastFollow = other.lastFollow;
+            lastAreaTrigger = other.lastAreaTrigger;
+            lastMoveToX = other.lastMoveToX;
+            lastMoveToY = other.lastMoveToY;
+            lastMoveToZ = other.lastMoveToZ;
+            lastMoveToOri = other.lastMoveToOri;
+        }
+        
+        void Set(Unit* lastFollow)
+        {
+            Set(0.0f, 0.0f, 0.0f, 0.0f);
+            this->lastFollow = lastFollow;
+        }
+
+        void Set(float x, float y, float z, float ori)
+        {
+            lastMoveToX = x;
+            lastMoveToY = y;
+            lastMoveToZ = z;
+            lastMoveToOri = ori;
+            lastFollow = NULL;
+        }
+
+    public:
+        vector<uint32> taxiNodes;
+        ObjectGuid taxiMaster;
+        Unit* lastFollow;
+        uint32 lastAreaTrigger;
+        float lastMoveToX, lastMoveToY, lastMoveToZ, lastMoveToOri;
+    };
+
+    class LastMovementValue : public ManualSetValue<LastMovement&>
+	{
+	public:
+        LastMovementValue(PlayerbotAI* ai) : ManualSetValue<LastMovement&>(ai, data) {}
+
+    private:
+        LastMovement data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
new file mode 100644
index 0000000..bf0a17e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCastTimeValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastSpellCastTimeValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, 0), Qualified() {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
new file mode 100644
index 0000000..5d05541
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCast 
+    {
+    public:
+        LastSpellCast() : id(0),time(0) {}
+
+    public:
+        void Set(uint32 id, ObjectGuid target, time_t time)
+        {
+            this->id = id;
+            this->target = target;
+            this->time = time;
+        }
+        
+        void Reset()
+        {
+            id = 0;
+            target.Set(0);
+            time = 0;
+        }
+    public:
+        uint32 id;
+        ObjectGuid target;
+        time_t time;
+    };
+   
+    class LastSpellCastValue : public ManualSetValue<LastSpellCast&>
+	{
+	public:
+        LastSpellCastValue(PlayerbotAI* ai) : ManualSetValue<LastSpellCast&>(ai, data) {}
+
+    private:
+        LastSpellCast data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
new file mode 100644
index 0000000..39021c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LeastHpTargetValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindLeastHpTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindLeastHpTargetStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minHealth = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result || result->GetHealth() > attacker->GetHealth())
+            result = attacker;
+    }
+
+protected:
+    float minHealth;
+};
+
+
+Unit* LeastHpTargetValue::Calculate()
+{
+    FindLeastHpTargetStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
new file mode 100644
index 0000000..e748e7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class LeastHpTargetValue : public TargetValue
+	{
+	public:
+        LeastHpTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LfgValues.h b/src/plugins/playerbot/strategy/values/LfgValues.h
new file mode 100644
index 0000000..290a4c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LfgValues.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Value.h"
+
+namespace ai
+{
+class LfgProposalValue : public ManualSetValue<uint32>
+{
+public:
+    LfgProposalValue(PlayerbotAI* ai) : ManualSetValue<uint32>(ai, 0, "lfg proposal") {}
+};
+}
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.cpp b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
new file mode 100644
index 0000000..3546e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LineTargetValue.h"
+
+using namespace ai;
+
+Unit* LineTargetValue::Calculate()
+{
+    Player* master = GetMaster();
+    if (!master)
+        return NULL;
+
+    Group* group = master->GetGroup();
+    if (!group)
+        return NULL;
+
+    Player *prev = master;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == master)
+            continue;
+
+        if (player == bot)
+            return prev;
+
+        prev = player;
+    }
+
+    return master;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.h b/src/plugins/playerbot/strategy/values/LineTargetValue.h
new file mode 100644
index 0000000..57998fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LineTargetValue : public UnitCalculatedValue
+	{
+	public:
+        LineTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LogLevelValue.h b/src/plugins/playerbot/strategy/values/LogLevelValue.h
new file mode 100644
index 0000000..c5f9da9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LogLevelValue.h
@@ -0,0 +1,12 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LogLevelValue : public ManualSetValue<LogLevel>
+	{
+	public:
+        LogLevelValue(PlayerbotAI* ai) :
+            ManualSetValue<LogLevel>(ai, LOG_LEVEL_DEBUG) {}
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LootStrategyValue.h b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
new file mode 100644
index 0000000..210e518
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LootStrategyValue : public ManualSetValue<LootStrategy>
+	{
+	public:
+        LootStrategyValue(PlayerbotAI* ai) : ManualSetValue<LootStrategy>(ai, LOOTSTRATEGY_SKILL) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
new file mode 100644
index 0000000..6c29f1f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ManaSaveLevelValue : public ManualSetValue<double>
+	{
+	public:
+        ManaSaveLevelValue(PlayerbotAI* ai) : ManualSetValue<double>(ai, 1.0, "mana save level") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/MasterTargetValue.h b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
new file mode 100644
index 0000000..a137694
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class MasterTargetValue : public UnitCalculatedValue
+	{
+	public:
+        MasterTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetMaster(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
new file mode 100644
index 0000000..3370836
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestAdsValue.h"
+
+using namespace ai;
+
+bool NearestAdsValue::AcceptUnit(Unit* unit)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return unit != target;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.h b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
new file mode 100644
index 0000000..16e4a84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "PossibleTargetsValue.h"
+
+namespace ai
+{
+    class NearestAdsValue : public PossibleTargetsValue
+	{
+	public:
+        NearestAdsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.tooCloseDistance) :
+            PossibleTargetsValue(ai, range) {}
+
+    protected:
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
new file mode 100644
index 0000000..ad6e30a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestCorpsesValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyDeadUnitInObjectRangeCheck
+{
+public:
+    AnyDeadUnitInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(Unit* u)
+    {
+        return !u->IsAlive() && i_obj->IsWithinDistInMap(u, i_range);
+    }
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+void NearestCorpsesValue::FindUnits(list<Unit*> &targets)
+{
+    AnyDeadUnitInObjectRangeCheck u_check(bot, range);
+    UnitListSearcher<AnyDeadUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestCorpsesValue::AcceptUnit(Unit* unit)
+{
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
new file mode 100644
index 0000000..c23a5b8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestCorpsesValue : public NearestUnitsValue
+	{
+	public:
+        NearestCorpsesValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
new file mode 100644
index 0000000..405b1c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestGameObjects.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyGameObjectInObjectRangeCheck
+{
+public:
+    AnyGameObjectInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(GameObject* u)
+    {
+        if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo())
+            return true;
+
+        return false;
+    }
+
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+list<ObjectGuid> NearestGameObjects::Calculate()
+{
+    list<GameObject*> targets;
+
+    AnyGameObjectInObjectRangeCheck u_check(bot, range);
+    GameObjectListSearcher<AnyGameObjectInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+
+    list<ObjectGuid> result;
+    for(list<GameObject*>::iterator tIter = targets.begin(); tIter != targets.end(); ++tIter)
+    {
+		GameObject* go = *tIter;
+        if(bot->IsWithinLOSInMap(go))
+			result.push_back(go->GetGUID());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.h b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
new file mode 100644
index 0000000..78dcf57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestGameObjects : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestGameObjects(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai), range(range) {}
+
+    protected:
+        virtual list<ObjectGuid> Calculate();
+
+    private:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
new file mode 100644
index 0000000..9f82f10
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestNpcsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+
+using namespace ai;
+using namespace Trinity;
+
+void NearestNpcsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyFriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyFriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestNpcsValue::AcceptUnit(Unit* unit)
+{
+    return !dynamic_cast<Player*>(unit);
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.h b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
new file mode 100644
index 0000000..ebbbd75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestNpcsValue : public NearestUnitsValue
+	{
+	public:
+        NearestNpcsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestUnitsValue.h b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
new file mode 100644
index 0000000..c6d1ed5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestUnitsValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestUnitsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai, "nearest units", 5), range(range) {}
+
+	public:
+        list<ObjectGuid> Calculate()
+        {
+            list<Unit*> targets;
+            FindUnits(targets);
+
+            list<ObjectGuid> results;
+            for(list<Unit *>::iterator i = targets.begin(); i!= targets.end(); ++i)
+            {
+                Unit* unit = *i;
+                if(bot->IsWithinLOSInMap(unit) && AcceptUnit(unit))
+                    results.push_back(unit->GetGUID());
+            }
+            return results;
+        }
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets) = 0;
+        virtual bool AcceptUnit(Unit* unit) = 0;
+
+    protected:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
new file mode 100644
index 0000000..7689b2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToDispel.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PartyMemberToDispelPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PartyMemberToDispelPredicate(PlayerbotAI* ai, uint32 dispelType) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), dispelType(dispelType) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && ai->HasAuraToDispel(unit, dispelType);
+    }
+
+private:
+    uint32 dispelType;
+};
+
+Unit* PartyMemberToDispel::Calculate()
+{
+    uint32 dispelType = atoi(qualifier.c_str());
+
+    PartyMemberToDispelPredicate predicate(ai, dispelType);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
new file mode 100644
index 0000000..dfbc809
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToDispel : public PartyMemberValue, Qualified
+	{
+	public:
+        PartyMemberToDispel(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
new file mode 100644
index 0000000..2ef8e3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToHeal.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class IsTargetOfHealingSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell) {
+        for (int i=0; i<3; i++) {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_HEAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MAX_HEALTH ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MECHANICAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_PCT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+Unit* PartyMemberToHeal::Calculate()
+{
+
+    IsTargetOfHealingSpell predicate;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    bool isRaid = bot->GetGroup()->isRaidGroup();
+    MinValueCalculator calc(100);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (!Check(player) || !player->IsAlive())
+            continue;
+
+        uint8 health = player->GetHealthPct();
+        if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+            calc.probe(health, player);
+
+        Pet* pet = player->GetPet();
+        if (pet && CanHealPet(pet))
+        {
+            health = ((Unit*)pet)->GetHealthPct();
+            if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+                calc.probe(health, player);
+        }
+    }
+    return (Unit*)calc.param;
+}
+
+bool PartyMemberToHeal::CanHealPet(Pet* pet)
+{
+    return HUNTER_PET == pet->getPetType();
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
new file mode 100644
index 0000000..bbbc2f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToHeal : public PartyMemberValue
+	{
+	public:
+        PartyMemberToHeal(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+        bool CanHealPet(Pet* pet);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
new file mode 100644
index 0000000..58dd203
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToResurrect.h"
+
+using namespace ai;
+
+class IsTargetOfResurrectSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell)
+    {
+        for (int i=0; i<3; i++)
+        {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT ||
+                spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT_NEW ||
+                spell->Effects[i].Effect == SPELL_EFFECT_SELF_RESURRECT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+class FindDeadPlayer : public FindPlayerPredicate
+{
+public:
+    FindDeadPlayer(PartyMemberValue* value) : value(value) {}
+
+    virtual bool Check(Unit* unit)
+    {
+        Player* player = dynamic_cast<Player*>(unit);
+        return player && player->getDeathState() == CORPSE && !value->IsTargetOfSpellCast(player, predicate);
+    }
+
+private:
+    PartyMemberValue* value;
+    IsTargetOfResurrectSpell predicate;
+};
+
+Unit* PartyMemberToResurrect::Calculate()
+{
+	FindDeadPlayer finder(this);
+    return FindPartyMember(finder);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
new file mode 100644
index 0000000..36815f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToResurrect : public PartyMemberValue
+	{
+	public:
+        PartyMemberToResurrect(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
new file mode 100644
index 0000000..2f5bcc4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Unit* PartyMemberValue::FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate)
+{
+    for (list<Player*>::iterator i = party->begin(); i != party->end(); ++i)
+    {
+        Player* player = *i;
+
+        if (!player)
+            continue;
+
+        if (Check(player) && predicate.Check(player))
+            return player;
+
+        Pet* pet = player->GetPet();
+        if (!pet)
+            continue;
+
+        Unit* unit = (Unit*)pet;
+        if (unit && Check(unit) && predicate.Check(unit))
+            return unit;
+    }
+
+    return NULL;
+}
+
+Unit* PartyMemberValue::FindPartyMember(FindPlayerPredicate &predicate)
+{
+    Player* master = GetMaster();
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    list<Player*> healers, tanks, others, masters;
+    masters.push_back(master);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+
+        if (ai->IsHeal(player))
+            healers.push_back(player);
+        else if (ai->IsTank(player))
+            tanks.push_back(player);
+        else if (player != master)
+            others.push_back(player);
+    }
+
+    list<list<Player*>* > lists;
+    lists.push_back(&healers);
+    lists.push_back(&tanks);
+    lists.push_back(&masters);
+    lists.push_back(&others);
+
+    for (list<list<Player*>* >::iterator i = lists.begin(); i != lists.end(); ++i)
+    {
+        list<Player*>* party = *i;
+        Unit* target = FindPartyMember(party, predicate);
+        if (target)
+            return target;
+    }
+
+    return NULL;
+}
+
+bool PartyMemberValue::Check(Unit* player)
+{
+
+
+    return player && player != bot && player->GetMapId() == bot->GetMapId() &&
+        bot->GetDistance(player) < sPlayerbotAIConfig.spellDistance &&
+        bot->IsWithinLOS(player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+}
+
+bool PartyMemberValue::IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate)
+{
+
+    Group* group = bot->GetGroup();
+    ObjectGuid targetGuid = target ? target->GetGUID() : bot->GetGUID();
+    ObjectGuid corpseGuid = target && target->GetCorpse() ? target->GetCorpse()->GetGUID() : ObjectGuid();
+
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (player == bot)
+            continue;
+
+        if (player->IsNonMeleeSpellCast(true))
+        {
+            for (int type = CURRENT_GENERIC_SPELL; type < CURRENT_MAX_SPELL; type++) {
+                Spell* spell = player->GetCurrentSpell((CurrentSpellTypes)type);
+                if (spell && predicate.Check(spell->m_spellInfo)) {
+                    ObjectGuid unitTarget = spell->m_targets.GetUnitTargetGUID();
+                    if (unitTarget == targetGuid)
+                        return true;
+
+                    ObjectGuid corpseTarget = spell->m_targets.GetCorpseTargetGUID();
+                    if (corpseTarget == corpseGuid)
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.h b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
new file mode 100644
index 0000000..5229b46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
@@ -0,0 +1,31 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindPlayerPredicate
+    {
+    public:
+        virtual bool Check(Unit*) = 0;
+    };
+
+    class SpellEntryPredicate
+    {
+    public:
+        virtual bool Check(SpellInfo const*) = 0;
+    };
+
+    class PartyMemberValue : public UnitCalculatedValue
+	{
+	public:
+        PartyMemberValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        bool IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate);
+
+    protected:
+        Unit* FindPartyMember(FindPlayerPredicate &predicate);
+        Unit* FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate);
+        bool Check(Unit* player);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
new file mode 100644
index 0000000..57ccc48
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PlayerWithoutAuraPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PlayerWithoutAuraPredicate(PlayerbotAI* ai, string aura) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), aura(aura) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && !ai->HasAura(aura, unit);
+    }
+
+private:
+    string aura;
+};
+
+Unit* PartyMemberWithoutAuraValue::Calculate()
+{
+	PlayerWithoutAuraPredicate predicate(ai, qualifier);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
new file mode 100644
index 0000000..63961de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PartyMemberWithoutAuraValue : public PartyMemberValue, public Qualified
+	{
+	public:
+        PartyMemberWithoutAuraValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PetTargetValue.h b/src/plugins/playerbot/strategy/values/PetTargetValue.h
new file mode 100644
index 0000000..35705c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PetTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class PetTargetValue : public UnitCalculatedValue
+	{
+	public:
+        PetTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return (Unit*)(ai->GetBot()->GetPet()); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.cpp b/src/plugins/playerbot/strategy/values/PositionValue.cpp
new file mode 100644
index 0000000..70424b0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionValue.h"
+
+using namespace ai;
+
+PositionValue::PositionValue(PlayerbotAI* ai)
+    : ManualSetValue<ai::Position&>(ai, position), Qualified()
+{
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.h b/src/plugins/playerbot/strategy/values/PositionValue.h
new file mode 100644
index 0000000..4d453e1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.h
@@ -0,0 +1,26 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class Position
+    {
+    public:
+        Position() : valueSet(false) {}
+        void Set(double x, double y, double z) { this->x = x; this->y = y; this->z = z; this->valueSet = true; }
+        void Reset() { valueSet = false; }
+        bool isSet() { return valueSet; }
+
+        double x, y, z;
+        bool valueSet;
+    };
+
+    class PositionValue : public ManualSetValue<Position&>, public Qualified
+	{
+	public:
+        PositionValue(PlayerbotAI* ai);
+
+	private:
+        Position position;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
new file mode 100644
index 0000000..17e1c27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PossibleTargetsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+void PossibleTargetsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyUnfriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool PossibleTargetsValue::AcceptUnit(Unit* unit)
+{
+    return !unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
+            (unit->IsHostileTo(bot) || (unit->getLevel() > 1 && !unit->IsFriendlyTo(bot)));
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
new file mode 100644
index 0000000..5a97a71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PossibleTargetsValue : public NearestUnitsValue
+	{
+	public:
+        PossibleTargetsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets);
+        virtual bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiTargetValue.h b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
new file mode 100644
index 0000000..01aac86
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
@@ -0,0 +1,51 @@
+#pragma once
+#include "../Value.h"
+#include "../../../Groups/Group.h"
+
+namespace ai
+{
+    class RtiTargetValue : public UnitCalculatedValue
+    {
+    public:
+        RtiTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai)
+        {}
+
+    public:
+        static int GetRtiIndex(string rti)
+        {
+            int index = -1;
+            if(rti == "star") index = 0;
+            else if(rti == "circle") index = 1;
+            else if(rti == "diamond") index = 2;
+            else if(rti == "triangle") index = 3;
+            else if(rti == "moon") index = 4;
+            else if(rti == "square") index = 5;
+            else if(rti == "cross") index = 6;
+            else if(rti == "skull") index = 7;
+            return index;
+        }
+
+        Unit *Calculate()
+        {
+            Group *group = bot->GetGroup();
+            if(!group)
+                return NULL;
+
+            string rti = AI_VALUE(string, "rti");
+            int index = GetRtiIndex(rti);
+
+            if (index == -1)
+                return NULL;
+
+            uint64 guid = group->GetTargetIcon(index);
+            if (!guid)
+                return NULL;
+
+            Unit* unit = ai->GetUnit(ObjectGuid(guid));
+            if (!unit || unit->isDead())
+                return NULL;
+
+            return unit;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.cpp b/src/plugins/playerbot/strategy/values/RtiValue.cpp
new file mode 100644
index 0000000..3698212
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RtiValue.h"
+
+using namespace ai;
+
+RtiValue::RtiValue(PlayerbotAI* ai)
+    : ManualSetValue<string>(ai, "none")
+{
+    switch (ai->GetBot()->getClass())
+    {
+    case CLASS_DRUID:
+        value = "circle";
+        break;
+    case CLASS_ROGUE:
+        value = "star";
+        break;
+    case CLASS_SHAMAN:
+        value = "square";
+        break;
+    case CLASS_HUNTER:
+        value = "triangle";
+        break;
+    case CLASS_WARLOCK:
+    case CLASS_PALADIN:
+        value = "diamond";
+        break;
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+        value = "moon";
+        break;
+    default:
+        value = "skull";
+        break;
+    }
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.h b/src/plugins/playerbot/strategy/values/RtiValue.h
new file mode 100644
index 0000000..760485e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class RtiValue : public ManualSetValue<string>
+	{
+	public:
+        RtiValue(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SelfTargetValue.h b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
new file mode 100644
index 0000000..f64a0fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class SelfTargetValue : public UnitCalculatedValue
+	{
+	public:
+        SelfTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetBot(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
new file mode 100644
index 0000000..dec5e9f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+
+using namespace ai;
+
+bool SpellCastUsefulValue::Calculate()
+{
+    uint32 spellid = AI_VALUE2(uint32, "spell id", qualifier);
+	if (!spellid)
+		return true; // there can be known alternatives
+
+	SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+	if (!spellInfo)
+		return true; // there can be known alternatives
+
+	if (spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING ||
+		spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING_2)
+	{
+		Spell* spell = bot->GetCurrentSpell(CURRENT_MELEE_SPELL);
+		if (spell && spell->m_spellInfo->Id == spellid && spell->IsNextMeleeSwingSpell())
+			return false;
+	}
+
+    uint32 lastSpellId = AI_VALUE(LastSpellCast&, "last spell cast").id;
+    if (spellid == lastSpellId)
+    {
+        Spell* const pSpell = bot->FindCurrentSpellBySpellId(lastSpellId);
+        if (pSpell)
+            return false;
+    }
+
+    // TODO: workaround
+    if (qualifier == "windfury weapon" || qualifier == "flametongue weapon" || qualifier == "frostbrand weapon" ||
+            qualifier == "rockbiter weapon" || qualifier == "earthliving weapon" || qualifier == "spellstone")
+    {
+        Item *item = AI_VALUE2(Item*, "item for spell", spellid);
+        if (item && item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+            return false;
+    }
+
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
new file mode 100644
index 0000000..8fa9386
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class SpellCastUsefulValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        SpellCastUsefulValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+      
+    public:
+        virtual bool Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.cpp b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
new file mode 100644
index 0000000..61755b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellIdValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+SpellIdValue::SpellIdValue(PlayerbotAI* ai) :
+        CalculatedValue<uint32>(ai, "spell id", 5)
+{
+}
+
+uint32 SpellIdValue::Calculate()
+{
+    string namepart = qualifier;
+    wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+    char firstSymbol = tolower(qualifier[0]);
+    int spellLength = wnamepart.length();
+
+    int loc = bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+            continue;
+
+        char* spellName = pSpellInfo->SpellName[loc];
+        if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+            continue;
+
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0) {
+            if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell) {
+            foundSpellId = spellId;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    Pet* pet = bot->GetPet();
+    if (!foundSpellId && pet)
+    {
+        for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            if(itr->second.state == PETSPELL_REMOVED)
+                continue;
+
+            uint32 spellId = itr->first;
+            const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+                continue;
+
+            char* spellName = pSpellInfo->SpellName[loc];
+            if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+                continue;
+
+            foundSpellId = spellId;
+        }
+    }
+
+    return foundSpellId;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.h b/src/plugins/playerbot/strategy/values/SpellIdValue.h
new file mode 100644
index 0000000..1281b38
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class SpellIdValue : public CalculatedValue<uint32>, public Qualified
+	{
+	public:
+        SpellIdValue(PlayerbotAI* ai);
+
+    public:
+        virtual uint32 Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.cpp b/src/plugins/playerbot/strategy/values/StatsValues.cpp
new file mode 100644
index 0000000..5bbfc55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsValues.h"
+
+using namespace ai;
+
+uint8 HealthValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100;
+}
+
+bool IsDeadValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->getDeathState() != ALIVE;
+}
+
+
+uint8 RageValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_RAGE)));
+}
+
+uint8 EnergyValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_ENERGY)));
+}
+
+uint8 ManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetPower(POWER_MANA)) / target->GetMaxPower(POWER_MANA)) * 100;
+}
+
+bool HasManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->GetPower(POWER_MANA);
+}
+
+
+uint8 ComboPointsValue::Calculate()
+{
+    Unit *target = GetTarget();
+    if (!target || target->GetGUID() != bot->GetComboTarget())
+        return 0;
+
+    return bot->GetComboPoints();
+}
+
+bool IsMountedValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsMounted();
+}
+
+
+bool IsInCombatValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsInCombat();
+}
+
+uint8 BagSpaceValue::Calculate()
+{
+    uint32 totalused = 0, total = 16;
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        if (bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            totalused++;
+    }
+
+    uint32 totalfree = 16 - totalused;
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+    return (static_cast<float> (totalused) / total) * 100;
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.h b/src/plugins/playerbot/strategy/values/StatsValues.h
new file mode 100644
index 0000000..4fcdbaf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.h
@@ -0,0 +1,133 @@
+#pragma once
+#include "../Value.h"
+
+class Unit;
+
+namespace ai
+{
+    class HealthValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        HealthValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsDeadValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsDeadValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class RageValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        RageValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class EnergyValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        EnergyValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class ManaValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ManaValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasManaValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasManaValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class ComboPointsValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ComboPointsValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsMountedValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsMountedValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class IsInCombatValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsInCombatValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate() ;
+    };
+
+    class BagSpaceValue : public Uint8CalculatedValue
+    {
+    public:
+        BagSpaceValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.cpp b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
new file mode 100644
index 0000000..01967f8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForTankStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForTankStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        minTankCount = 0;
+        maxDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        float threat = threatManager->getThreat(bot);
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            (minThreat >= threat &&
+            (minTankCount >= tankCount || maxDpsCount <= dpsCount)))
+        {
+            minThreat = threat;
+            minTankCount = tankCount;
+            maxDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int minTankCount;
+    int maxDpsCount;
+};
+
+
+Unit* TankTargetValue::Calculate()
+{
+    FindTargetForTankStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.h b/src/plugins/playerbot/strategy/values/TankTargetValue.h
new file mode 100644
index 0000000..f297eb0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class TankTargetValue : public TargetValue
+	{
+	public:
+        TankTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.cpp b/src/plugins/playerbot/strategy/values/TargetValue.cpp
new file mode 100644
index 0000000..2586bad
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TargetValue.h"
+
+using namespace ai;
+
+Unit* TargetValue::FindTarget(FindTargetStrategy* strategy)
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit)
+            continue;
+
+        ThreatManager &threatManager = unit->getThreatManager();
+        strategy->CheckAttacker(unit, &threatManager);
+    }
+
+    return strategy->GetResult();
+}
+
+void FindTargetStrategy::GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount)
+{
+    Player* bot = ai->GetBot();
+    if (tankCountCache.find(creature) != tankCountCache.end())
+    {
+        *tankCount = tankCountCache[creature];
+        *dpsCount = dpsCountCache[creature];
+        return;
+    }
+
+    *tankCount = 0;
+    *dpsCount = 0;
+
+    for (HostileReference *ref = creature->getHostileRefManager().getFirst(); ref; ref = ref->next())
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        Player *player = dynamic_cast<Player*>(victim);
+
+        if (!player)
+            continue;
+
+        if (ai->IsTank(player))
+            (*tankCount)++;
+        else
+            (*dpsCount)++;
+    }
+
+    tankCountCache[creature] = *tankCount;
+    dpsCountCache[creature] = *dpsCount;
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.h b/src/plugins/playerbot/strategy/values/TargetValue.h
new file mode 100644
index 0000000..700d51d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindTargetStrategy
+    {
+    public:
+        FindTargetStrategy(PlayerbotAI* ai)
+        {
+            result = NULL;
+            this->ai = ai;
+        }
+
+    public:
+        Unit* GetResult() { return result; }
+
+    public:
+        virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager) = 0;
+        void GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount);
+
+    protected:
+        Unit* result;
+        PlayerbotAI* ai;
+
+    protected:
+        map<Unit*, int> tankCountCache;
+        map<Unit*, int> dpsCountCache;
+    };
+
+    class TargetValue : public UnitCalculatedValue
+	{
+	public:
+        TargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    protected:
+        Unit* FindTarget(FindTargetStrategy* strategy);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.cpp b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
new file mode 100644
index 0000000..b0e0a00
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatValues.h"
+
+using namespace ai;
+
+uint8 ThreatValue::Calculate()
+{
+    if (qualifier == "aoe")
+    {
+        uint8 maxThreat = 0;
+        list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+        for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+        {
+            Unit* unit = ai->GetUnit(*i);
+            if (!unit || !unit->IsAlive())
+                continue;
+
+            uint8 threat = Calculate(unit);
+            if (!maxThreat || threat > maxThreat)
+                maxThreat = threat;
+        }
+
+        return maxThreat;
+    }
+
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    return Calculate(target);
+}
+
+uint8 ThreatValue::Calculate(Unit* target)
+{
+    if (!target)
+        return 0;
+
+    if (dynamic_cast<Player*>(target))
+        return 0;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    float botThreat = target->getThreatManager().getThreat(bot);
+    float maxThreat = 0;
+
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == bot)
+            continue;
+
+        float threat = target->getThreatManager().getThreat(player);
+        if (maxThreat < threat)
+            maxThreat = threat;
+    }
+
+    if (maxThreat <= 0)
+        return 0;
+
+    return botThreat * 100 / maxThreat;
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.h b/src/plugins/playerbot/strategy/values/ThreatValues.h
new file mode 100644
index 0000000..7301f79
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ThreatValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+        ThreatValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+
+    protected:
+    	uint8 Calculate(Unit* target);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ValueContext.h b/src/plugins/playerbot/strategy/values/ValueContext.h
new file mode 100644
index 0000000..c2e9fdf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ValueContext.h
@@ -0,0 +1,222 @@
+#pragma once
+
+#include "NearestGameObjects.h"
+#include "LogLevelValue.h"
+#include "NearestNpcsValue.h"
+#include "PossibleTargetsValue.h"
+#include "NearestAdsValue.h"
+#include "NearestCorpsesValue.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "PartyMemberToHeal.h"
+#include "PartyMemberToResurrect.h"
+#include "CurrentTargetValue.h"
+#include "SelfTargetValue.h"
+#include "MasterTargetValue.h"
+#include "LineTargetValue.h"
+#include "TankTargetValue.h"
+#include "DpsTargetValue.h"
+#include "CcTargetValue.h"
+#include "CurrentCcTargetValue.h"
+#include "PetTargetValue.h"
+#include "GrindTargetValue.h"
+#include "RtiTargetValue.h"
+#include "PartyMemberToDispel.h"
+#include "StatsValues.h"
+#include "AttackerCountValues.h"
+#include "AttackersValue.h"
+#include "AvailableLootValue.h"
+#include "AlwaysLootListValue.h"
+#include "LootStrategyValue.h"
+#include "HasAvailableLootValue.h"
+#include "LastMovementValue.h"
+#include "DistanceValue.h"
+#include "IsMovingValue.h"
+#include "IsBehindValue.h"
+#include "IsFacingValue.h"
+#include "ItemCountValue.h"
+#include "SpellIdValue.h"
+#include "ItemForSpellValue.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+#include "ChatValue.h"
+#include "HasTotemValue.h"
+#include "LeastHpTargetValue.h"
+#include "AoeHealValues.h"
+#include "RtiValue.h"
+#include "PositionValue.h"
+#include "ThreatValues.h"
+#include "DuelTargetValue.h"
+#include "InvalidTargetValue.h"
+#include "EnemyPlayerValue.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "LastSpellCastTimeValue.h"
+#include "ManaSaveLevelValue.h"
+#include "LfgValues.h"
+#include "EnemyHealerTargetValue.h"
+#include "Formations.h"
+
+namespace ai
+{
+    class ValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        ValueContext()
+        {
+            creators["nearest game objects"] = &ValueContext::nearest_game_objects;
+            creators["nearest npcs"] = &ValueContext::nearest_npcs;
+            creators["possible targets"] = &ValueContext::possible_targets;
+            creators["nearest adds"] = &ValueContext::nearest_adds;
+            creators["nearest corpses"] = &ValueContext::nearest_corpses;
+            creators["log level"] = &ValueContext::log_level;
+            creators["party member without aura"] = &ValueContext::party_member_without_aura;
+            creators["attacker without aura"] = &ValueContext::attacker_without_aura;
+            creators["party member to heal"] = &ValueContext::party_member_to_heal;
+            creators["party member to resurrect"] = &ValueContext::party_member_to_resurrect;
+            creators["current target"] = &ValueContext::current_target;
+            creators["self target"] = &ValueContext::self_target;
+            creators["master target"] = &ValueContext::master;
+            creators["line target"] = &ValueContext::line_target;
+            creators["tank target"] = &ValueContext::tank_target;
+            creators["dps target"] = &ValueContext::dps_target;
+            creators["least hp target"] = &ValueContext::least_hp_target;
+            creators["enemy player target"] = &ValueContext::enemy_player_target;
+            creators["cc target"] = &ValueContext::cc_target;
+            creators["current cc target"] = &ValueContext::current_cc_target;
+            creators["pet target"] = &ValueContext::pet_target;
+            creators["old target"] = &ValueContext::old_target;
+            creators["grind target"] = &ValueContext::grind_target;
+            creators["rti target"] = &ValueContext::rti_target;
+            creators["duel target"] = &ValueContext::duel_target;
+            creators["party member to dispel"] = &ValueContext::party_member_to_dispel;
+            creators["health"] = &ValueContext::health;
+            creators["rage"] = &ValueContext::rage;
+            creators["energy"] = &ValueContext::energy;
+            creators["mana"] = &ValueContext::mana;
+            creators["combo"] = &ValueContext::combo;
+            creators["dead"] = &ValueContext::dead;
+            creators["has mana"] = &ValueContext::has_mana;
+            creators["attacker count"] = &ValueContext::attacker_count;
+            creators["my attacker count"] = &ValueContext::my_attacker_count;
+            creators["has aggro"] = &ValueContext::has_aggro;
+            creators["mounted"] = &ValueContext::mounted;
+
+            creators["can loot"] = &ValueContext::can_loot;
+            creators["loot target"] = &ValueContext::loot_target;
+            creators["available loot"] = &ValueContext::available_loot;
+            creators["has available loot"] = &ValueContext::has_available_loot;
+            creators["always loot list"] = &ValueContext::always_loot_list;
+            creators["loot strategy"] = &ValueContext::loot_strategy;
+            creators["last movement"] = &ValueContext::last_movement;
+            creators["distance"] = &ValueContext::distance;
+            creators["moving"] = &ValueContext::moving;
+            creators["swimming"] = &ValueContext::swimming;
+            creators["behind"] = &ValueContext::behind;
+            creators["facing"] = &ValueContext::facing;
+
+            creators["item count"] = &ValueContext::item_count;
+            creators["inventory items"] = &ValueContext::inventory_item;
+
+            creators["spell id"] = &ValueContext::spell_id;
+            creators["item for spell"] = &ValueContext::item_for_spell;
+            creators["spell cast useful"] = &ValueContext::spell_cast_useful;
+            creators["last spell cast"] = &ValueContext::last_spell_cast;
+            creators["last spell cast time"] = &ValueContext::last_spell_cast_time;
+            creators["chat"] = &ValueContext::chat;
+            creators["has totem"] = &ValueContext::has_totem;
+
+            creators["aoe heal"] = &ValueContext::aoe_heal;
+
+            creators["rti"] = &ValueContext::rti;
+            creators["position"] = &ValueContext::position;
+            creators["threat"] = &ValueContext::threat;
+
+            creators["balance"] = &ValueContext::balance;
+            creators["attackers"] = &ValueContext::attackers;
+            creators["invalid target"] = &ValueContext::invalid_target;
+            creators["mana save level"] = &ValueContext::mana_save_level;
+            creators["combat"] = &ValueContext::combat;
+            creators["lfg proposal"] = &ValueContext::lfg_proposal;
+            creators["bag space"] = &ValueContext::bag_space;
+            creators["enemy healer target"] = &ValueContext::enemy_healer_target;
+            creators["formation"] = &ValueContext::formation;
+        }
+
+    private:
+        static UntypedValue* formation(PlayerbotAI* ai) { return new FormationValue(ai); }
+        static UntypedValue* mana_save_level(PlayerbotAI* ai) { return new ManaSaveLevelValue(ai); }
+        static UntypedValue* invalid_target(PlayerbotAI* ai) { return new InvalidTargetValue(ai); }
+        static UntypedValue* balance(PlayerbotAI* ai) { return new BalancePercentValue(ai); }
+        static UntypedValue* attackers(PlayerbotAI* ai) { return new AttackersValue(ai); }
+
+        static UntypedValue* position(PlayerbotAI* ai) { return new PositionValue(ai); }
+        static UntypedValue* rti(PlayerbotAI* ai) { return new RtiValue(ai); }
+
+        static UntypedValue* aoe_heal(PlayerbotAI* ai) { return new AoeHealValue(ai); }
+
+        static UntypedValue* chat(PlayerbotAI* ai) { return new ChatValue(ai); }
+        static UntypedValue* last_spell_cast(PlayerbotAI* ai) { return new LastSpellCastValue(ai); }
+        static UntypedValue* last_spell_cast_time(PlayerbotAI* ai) { return new LastSpellCastTimeValue(ai); }
+        static UntypedValue* spell_cast_useful(PlayerbotAI* ai) { return new SpellCastUsefulValue(ai); }
+        static UntypedValue* item_for_spell(PlayerbotAI* ai) { return new ItemForSpellValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new SpellIdValue(ai); }
+        static UntypedValue* inventory_item(PlayerbotAI* ai) { return new InventoryItemValue(ai); }
+        static UntypedValue* item_count(PlayerbotAI* ai) { return new ItemCountValue(ai); }
+        static UntypedValue* behind(PlayerbotAI* ai) { return new IsBehindValue(ai); }
+        static UntypedValue* facing(PlayerbotAI* ai) { return new IsFacingValue(ai); }
+        static UntypedValue* moving(PlayerbotAI* ai) { return new IsMovingValue(ai); }
+        static UntypedValue* swimming(PlayerbotAI* ai) { return new IsSwimmingValue(ai); }
+        static UntypedValue* distance(PlayerbotAI* ai) { return new DistanceValue(ai); }
+        static UntypedValue* last_movement(PlayerbotAI* ai) { return new LastMovementValue(ai); }
+
+        static UntypedValue* can_loot(PlayerbotAI* ai) { return new CanLootValue(ai); }
+        static UntypedValue* available_loot(PlayerbotAI* ai) { return new AvailableLootValue(ai); }
+        static UntypedValue* loot_target(PlayerbotAI* ai) { return new LootTargetValue(ai); }
+        static UntypedValue* has_available_loot(PlayerbotAI* ai) { return new HasAvailableLootValue(ai); }
+        static UntypedValue* always_loot_list(PlayerbotAI* ai) { return new AlwaysLootListValue(ai); }
+        static UntypedValue* loot_strategy(PlayerbotAI* ai) { return new LootStrategyValue(ai); }
+
+        static UntypedValue* attacker_count(PlayerbotAI* ai) { return new AttackerCountValue(ai); }
+        static UntypedValue* my_attacker_count(PlayerbotAI* ai) { return new MyAttackerCountValue(ai); }
+        static UntypedValue* has_aggro(PlayerbotAI* ai) { return new HasAggroValue(ai); }
+        static UntypedValue* mounted(PlayerbotAI* ai) { return new IsMountedValue(ai); }
+        static UntypedValue* health(PlayerbotAI* ai) { return new HealthValue(ai); }
+        static UntypedValue* rage(PlayerbotAI* ai) { return new RageValue(ai); }
+        static UntypedValue* energy(PlayerbotAI* ai) { return new EnergyValue(ai); }
+        static UntypedValue* mana(PlayerbotAI* ai) { return new ManaValue(ai); }
+        static UntypedValue* combo(PlayerbotAI* ai) { return new ComboPointsValue(ai); }
+        static UntypedValue* dead(PlayerbotAI* ai) { return new IsDeadValue(ai); }
+        static UntypedValue* has_mana(PlayerbotAI* ai) { return new HasManaValue(ai); }
+        static UntypedValue* nearest_game_objects(PlayerbotAI* ai) { return new NearestGameObjects(ai); }
+        static UntypedValue* log_level(PlayerbotAI* ai) { return new LogLevelValue(ai); }
+        static UntypedValue* nearest_npcs(PlayerbotAI* ai) { return new NearestNpcsValue(ai); }
+        static UntypedValue* nearest_corpses(PlayerbotAI* ai) { return new NearestCorpsesValue(ai); }
+        static UntypedValue* possible_targets(PlayerbotAI* ai) { return new PossibleTargetsValue(ai); }
+        static UntypedValue* nearest_adds(PlayerbotAI* ai) { return new NearestAdsValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new PartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* attacker_without_aura(PlayerbotAI* ai) { return new AttackerWithoutAuraTargetValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new PartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_resurrect(PlayerbotAI* ai) { return new PartyMemberToResurrect(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new PartyMemberToDispel(ai); }
+        static UntypedValue* current_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* old_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* self_target(PlayerbotAI* ai) { return new SelfTargetValue(ai); }
+        static UntypedValue* master(PlayerbotAI* ai) { return new MasterTargetValue(ai); }
+        static UntypedValue* line_target(PlayerbotAI* ai) { return new LineTargetValue(ai); }
+        static UntypedValue* tank_target(PlayerbotAI* ai) { return new TankTargetValue(ai); }
+        static UntypedValue* dps_target(PlayerbotAI* ai) { return new DpsTargetValue(ai); }
+        static UntypedValue* least_hp_target(PlayerbotAI* ai) { return new LeastHpTargetValue(ai); }
+        static UntypedValue* enemy_player_target(PlayerbotAI* ai) { return new EnemyPlayerValue(ai); }
+        static UntypedValue* cc_target(PlayerbotAI* ai) { return new CcTargetValue(ai); }
+        static UntypedValue* current_cc_target(PlayerbotAI* ai) { return new CurrentCcTargetValue(ai); }
+        static UntypedValue* pet_target(PlayerbotAI* ai) { return new PetTargetValue(ai); }
+        static UntypedValue* grind_target(PlayerbotAI* ai) { return new GrindTargetValue(ai); }
+        static UntypedValue* rti_target(PlayerbotAI* ai) { return new RtiTargetValue(ai); }
+        static UntypedValue* duel_target(PlayerbotAI* ai) { return new DuelTargetValue(ai); }
+        static UntypedValue* has_totem(PlayerbotAI* ai) { return new HasTotemValue(ai); }
+        static UntypedValue* threat(PlayerbotAI* ai) { return new ThreatValue(ai); }
+        static UntypedValue* combat(PlayerbotAI* ai) { return new IsInCombatValue(ai); }
+        static UntypedValue* lfg_proposal(PlayerbotAI* ai) { return new LfgProposalValue(ai); }
+        static UntypedValue* bag_space(PlayerbotAI* ai) { return new BagSpaceValue(ai); }
+        static UntypedValue* enemy_healer_target(PlayerbotAI* ai) { return new EnemyHealerTargetValue(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.cpp b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
new file mode 100644
index 0000000..a11995a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
@@ -0,0 +1,157 @@
+#include "../../../../pchdef.h"
+#include "../../../playerbot.h"
+#include "../Formations.h"
+#include "Arrow.h"
+
+using namespace ai;
+
+WorldLocation ArrowFormation::GetLocation()
+{
+    Build();
+
+    int tankLines = 1 + tanks.Size() / 6;
+    int meleeLines = 1 + melee.Size() / 6;
+    int rangedLines = 1 + ranged.Size() / 6;
+    int healerLines = 1 + healers.Size() / 6;
+    float offset = 0;
+
+    Player* master = ai->GetMaster();
+    float orientation = master->GetOrientation();
+    MultiLineUnitPlacer placer(orientation);
+
+    tanks.PlaceUnits(&placer);
+
+    offset = tankLines * sPlayerbotAIConfig.followDistance;
+    melee.PlaceUnits(&placer);
+    melee.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += meleeLines * sPlayerbotAIConfig.followDistance + sPlayerbotAIConfig.tooCloseDistance;
+    ranged.PlaceUnits(&placer);
+    ranged.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += rangedLines * sPlayerbotAIConfig.followDistance;
+    healers.PlaceUnits(&placer);
+    healers.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    return WorldLocation(master->GetMapId(),
+            master->GetPositionX() - masterUnit->GetX() + botUnit->GetX(),
+            master->GetPositionY() - masterUnit->GetY() + botUnit->GetY(),
+            master->GetPositionZ());
+
+
+}
+
+void ArrowFormation::Build()
+{
+    if (built)
+        return;
+
+    FillSlotsExceptMaster();
+    AddMasterToSlot();
+
+    built = true;
+}
+
+FormationSlot* ArrowFormation::FindSlot(Player* member)
+{
+    if (ai->IsTank(member))
+        return &tanks;
+    else if (ai->IsHeal(member))
+        return &healers;
+    else if (ai->IsRanged(member))
+        return &ranged;
+    else
+        return &melee;
+}
+
+void ArrowFormation::FillSlotsExceptMaster()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == bot)
+            FindSlot(member)->AddLast(botUnit = new FormationUnit(index, false));
+        else if (member != ai->GetMaster())
+            FindSlot(member)->AddLast(new FormationUnit(index, false));
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void ArrowFormation::AddMasterToSlot()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == ai->GetMaster())
+        {
+            FindSlot(member)->InsertAtCenter(masterUnit = new FormationUnit(index, true));
+            break;
+        }
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void FormationSlot::PlaceUnits(UnitPlacer* placer)
+{
+    uint32 index = 0;
+    uint32 count = units.size();
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(placer->Place(unit, index, count));
+        index++;
+    }
+}
+
+UnitPosition MultiLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    SingleLineUnitPlacer placer(orientation);
+    if (count <= 6)
+        return placer.Place(unit, index, count);
+
+    int lineNo = index / 6;
+    int indexInLine = index % 6;
+    int lineSize = max(count - lineNo * 6, uint32(6));
+    float x = cos(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    float y = sin(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    return placer.Place(unit, indexInLine, lineSize);
+}
+
+UnitPosition SingleLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    float angle = orientation - M_PI / 2.0f;
+    float x = cos(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    float y = sin(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    return UnitPosition(x, y);
+}
+
+void FormationSlot::Move(float dx, float dy)
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(unit->GetX() + dx, unit->GetY() + dy);
+    }
+}
+
+FormationSlot::~FormationSlot()
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        delete unit;
+    }
+    units.clear();
+}
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.h b/src/plugins/playerbot/strategy/values/formations/Arrow.h
new file mode 100644
index 0000000..e302c87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.h
@@ -0,0 +1,109 @@
+#pragma once
+
+namespace ai
+{
+    class UnitPosition
+    {
+    public:
+        UnitPosition(float x, float y) : x(x), y(y) {}
+        UnitPosition(const UnitPosition& other) { x = other.x; y = other.y; }
+        float x, y;
+    };
+
+    class FormationUnit
+    {
+    public:
+        FormationUnit(uint32 groupIndex, bool master) : groupIndex(groupIndex), master(master), position(0, 0) {}
+        FormationUnit(const FormationUnit& other) : position(other.position.x, other.position.y)
+        {
+            groupIndex = other.groupIndex;
+            master = other.master;
+        }
+
+    public:
+        uint32 GetGroupIdex() { return groupIndex; }
+        void SetLocation(UnitPosition pos) { position = pos; }
+        void SetLocation(float x, float y) { position.x = x; position.y = y; }
+        float GetX() { return position.x; }
+        float GetY() { return position.y; }
+
+    private:
+        uint32 groupIndex;
+        bool master;
+        UnitPosition position;
+    };
+
+    class UnitPlacer
+    {
+    public:
+        UnitPlacer() {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count) = 0;
+    };
+
+    class FormationSlot
+    {
+    public:
+        FormationSlot() {}
+        virtual ~FormationSlot();
+
+    public:
+        void AddLast(FormationUnit* unit) { units.push_back(unit); }
+        void InsertAtCenter(FormationUnit* unit) { units.insert(units.begin() + (units.size() + 1) / 2, unit); }
+        void PlaceUnits(UnitPlacer* placer);
+        void Move(float dx, float dy);
+        int Size() { return units.size(); }
+
+    private:
+        WorldLocation center;
+        vector<FormationUnit*> units;
+    };
+
+
+    class MultiLineUnitPlacer : public UnitPlacer
+    {
+    public:
+        MultiLineUnitPlacer(float orientation) : UnitPlacer(), orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class SingleLineUnitPlacer
+    {
+    public:
+        SingleLineUnitPlacer(float orientation) : orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class ArrowFormation : public MoveFormation
+    {
+    public:
+        ArrowFormation(PlayerbotAI* ai) : MoveFormation(ai, "arrow"), built(false), masterUnit(NULL), botUnit(NULL) {}
+
+    public:
+        virtual WorldLocation GetLocation();
+
+    private:
+        void Build();
+        void FillSlotsExceptMaster();
+        void AddMasterToSlot();
+        FormationSlot* FindSlot(Player* member);
+
+    private:
+        FormationSlot tanks, melee, ranged, healers;
+        FormationUnit *masterUnit, *botUnit;
+        bool built;
+    };
+
+}
+
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
new file mode 100644
index 0000000..039fd53
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
@@ -0,0 +1,76 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockMultipliers.h"
+#include "DpsWarlockStrategy.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+class DpsWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarlockStrategyActionNodeFactory()
+    {
+        creators["shadow bolt"] = &shadow_bolt;
+    }
+private:
+    static ActionNode* shadow_bolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shadow bolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarlockStrategy::DpsWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarlockStrategyActionNodeFactory());
+}
+
+
+NextAction** DpsWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("incinirate", 10.0f), new NextAction("shadow bolt", 10.0f), NULL);
+}
+
+void DpsWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"shadow trance",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"backlash",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+}
+
+void DpsAoeWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("rain of fire", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("seed of corruption", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("shadowfury", 29.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "corruption on attacker",
+        NextAction::array(0, new NextAction("corruption on attacker", 28.0f), NULL)));
+
+}
+
+void DpsWarlockDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "corruption",
+        NextAction::array(0, new NextAction("corruption", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
new file mode 100644
index 0000000..846f9df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        DpsWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "dps"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+
+    class DpsAoeWarlockStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeWarlockStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsWarlockDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarlockDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
new file mode 100644
index 0000000..3dc73c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockNonCombatStrategyActionNodeFactory()
+    {
+        creators["fel armor"] = &fel_armor;
+        creators["demon armor"] = &demon_armor;
+    }
+private:
+    static ActionNode* fel_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fel armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* demon_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demon armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon skin"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockNonCombatStrategy::GenericWarlockNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockNonCombatStrategyActionNodeFactory());
+}
+
+void GenericWarlockNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "demon armor",
+        NextAction::array(0, new NextAction("fel armor", 21.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no healthstone",
+		NextAction::array(0, new NextAction("create healthstone", 15.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no firestone",
+		NextAction::array(0, new NextAction("create firestone", 14.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no spellstone",
+		NextAction::array(0, new NextAction("create spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "spellstone",
+        NextAction::array(0, new NextAction("spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon imp", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
new file mode 100644
index 0000000..c5e483f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarlockNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
new file mode 100644
index 0000000..e880061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
@@ -0,0 +1,74 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["banish"] = &banish;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* banish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("banish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("fear"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockStrategy::GenericWarlockStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** GenericWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void GenericWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "curse of agony",
+        NextAction::array(0, new NextAction("curse of agony", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("drain life", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("life tap", ACTION_EMERGENCY + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("drain soul", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "banish",
+        NextAction::array(0, new NextAction("banish", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "fear",
+        NextAction::array(0, new NextAction("fear on cc", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "immolate",
+        NextAction::array(0, new NextAction("immolate", 19.0f), new NextAction("conflagrate", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
new file mode 100644
index 0000000..473da59
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "warlock"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
new file mode 100644
index 0000000..cb4f5a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "TankWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["summon felguard"] = &summon_felguard;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* summon_felguard(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon felguard",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("summon voidwalker"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarlockStrategy::TankWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** TankWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void TankWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon felguard", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
new file mode 100644
index 0000000..9cdd6e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+
+namespace ai
+{
+    class TankWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        TankWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "tank"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
new file mode 100644
index 0000000..0a01ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.h b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
new file mode 100644
index 0000000..fb1689a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
@@ -0,0 +1,176 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+	class CastDemonSkinAction : public CastBuffSpellAction {
+	public:
+		CastDemonSkinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon skin") {}
+	};
+
+	class CastDemonArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastDemonArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon armor") {}
+	};
+
+	class CastFelArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastFelArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fel armor") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastShadowBoltAction, "shadow bolt")
+    END_SPELL_ACTION()
+
+	class CastDrainSoulAction : public CastSpellAction
+	{
+	public:
+		CastDrainSoulAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain soul") {}
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(uint8, "item count", "soul shard") < 2;
+		}
+	};
+
+	class CastDrainManaAction : public CastSpellAction
+	{
+	public:
+		CastDrainManaAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain mana") {}
+	};
+
+	class CastDrainLifeAction : public CastSpellAction
+	{
+	public:
+		CastDrainLifeAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain life") {}
+	};
+
+	class CastCurseOfAgonyAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfAgonyAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of agony") {}
+	};
+
+	class CastCurseOfWeaknessAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfWeaknessAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of weakness") {}
+	};
+
+	class CastCorruptionAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "corruption") {}
+	};
+
+	class CastCorruptionOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+	public:
+	    CastCorruptionOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "corruption") {}
+	};
+
+
+	class CastSummonVoidwalkerAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonVoidwalkerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon voidwalker") {}
+	};
+
+	class CastSummonFelguardAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonFelguardAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon felguard") {}
+	};
+
+	class CastSummonImpAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonImpAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon imp") {}
+	};
+
+	class CastCreateHealthstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateHealthstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create healthstone") {}
+	};
+
+	class CastCreateFirestoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateFirestoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create firestone") {}
+	};
+
+	class CastCreateSpellstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateSpellstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create spellstone") {}
+	};
+
+    class CastBanishAction : public CastBuffSpellAction
+    {
+    public:
+        CastBanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "banish on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "banish"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("banish", GetTarget()); }
+    };
+
+    class CastSeedOfCorruptionAction : public CastDebuffSpellAction
+    {
+    public:
+        CastSeedOfCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "seed of corruption") {}
+    };
+
+    class CastRainOfFireAction : public CastSpellAction
+    {
+    public:
+        CastRainOfFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "rain of fire") {}
+    };
+
+    class CastShadowfuryAction : public CastSpellAction
+    {
+    public:
+        CastShadowfuryAction(PlayerbotAI* ai) : CastSpellAction(ai, "shadowfury") {}
+    };
+
+    class CastImmolateAction : public CastDebuffSpellAction
+    {
+    public:
+        CastImmolateAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "immolate") {}
+    };
+
+    class CastConflagrateAction : public CastSpellAction
+    {
+    public:
+        CastConflagrateAction(PlayerbotAI* ai) : CastSpellAction(ai, "conflagrate") {}
+    };
+
+    class CastIncinirateAction : public CastSpellAction
+    {
+    public:
+        CastIncinirateAction(PlayerbotAI* ai) : CastSpellAction(ai, "incinirate") {}
+    };
+
+    class CastFearAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFearAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "fear") {}
+    };
+
+    class CastFearOnCcAction : public CastBuffSpellAction
+    {
+    public:
+        CastFearOnCcAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fear on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "fear"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("fear", GetTarget()); }
+    };
+
+    class CastLifeTapAction: public CastSpellAction
+    {
+    public:
+        CastLifeTapAction(PlayerbotAI* ai) : CastSpellAction(ai, "life tap") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.lowHealth; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
new file mode 100644
index 0000000..8c25fd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
@@ -0,0 +1,183 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+#include "WarlockAiObjectContext.h"
+#include "DpsWarlockStrategy.h"
+#include "GenericWarlockNonCombatStrategy.h"
+#include "TankWarlockStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarlockTriggers.h"
+#include "../NamedObjectContext.h"
+#include "../actions/UseItemAction.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warlock::StrategyFactoryInternal::nc;
+                creators["pull"] = &warlock::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warlock::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &warlock::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarlockNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeWarlockStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsWarlockDebuffStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["dps"] = &warlock::CombatStrategyFactoryInternal::dps;
+                creators["tank"] = &warlock::CombatStrategyFactoryInternal::tank;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarlockStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarlockStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["shadow trance"] = &TriggerFactoryInternal::shadow_trance;
+                creators["demon armor"] = &TriggerFactoryInternal::demon_armor;
+                creators["no healthstone"] = &TriggerFactoryInternal::HasHealthstone;
+                creators["no firestone"] = &TriggerFactoryInternal::HasFirestone;
+                creators["no spellstone"] = &TriggerFactoryInternal::HasSpellstone;
+                creators["corruption"] = &TriggerFactoryInternal::corruption;
+                creators["corruption on attacker"] = &TriggerFactoryInternal::corruption_on_attacker;
+                creators["curse of agony"] = &TriggerFactoryInternal::curse_of_agony;
+                creators["banish"] = &TriggerFactoryInternal::banish;
+                creators["spellstone"] = &TriggerFactoryInternal::spellstone;
+                creators["backlash"] = &TriggerFactoryInternal::backlash;
+                creators["fear"] = &TriggerFactoryInternal::fear;
+                creators["immolate"] = &TriggerFactoryInternal::immolate;
+
+
+            }
+
+        private:
+            static Trigger* shadow_trance(PlayerbotAI* ai) { return new ShadowTranceTrigger(ai); }
+            static Trigger* demon_armor(PlayerbotAI* ai) { return new DemonArmorTrigger(ai); }
+            static Trigger* HasHealthstone(PlayerbotAI* ai) { return new HasHealthstoneTrigger(ai); }
+            static Trigger* HasFirestone(PlayerbotAI* ai) { return new HasFirestoneTrigger(ai); }
+            static Trigger* HasSpellstone(PlayerbotAI* ai) { return new HasSpellstoneTrigger(ai); }
+            static Trigger* corruption(PlayerbotAI* ai) { return new CorruptionTrigger(ai); }
+            static Trigger* corruption_on_attacker(PlayerbotAI* ai) { return new CorruptionOnAttackerTrigger(ai); }
+            static Trigger* curse_of_agony(PlayerbotAI* ai) { return new CurseOfAgonyTrigger(ai); }
+            static Trigger* banish(PlayerbotAI* ai) { return new BanishTrigger(ai); }
+            static Trigger* spellstone(PlayerbotAI* ai) { return new SpellstoneTrigger(ai); }
+            static Trigger* backlash(PlayerbotAI* ai) { return new BacklashTrigger(ai); }
+            static Trigger* fear(PlayerbotAI* ai) { return new FearTrigger(ai); }
+            static Trigger* immolate(PlayerbotAI* ai) { return new ImmolateTrigger(ai); }
+
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["summon imp"] = &AiObjectContextInternal::summon_imp;
+                creators["fel armor"] = &AiObjectContextInternal::fel_armor;
+                creators["demon armor"] = &AiObjectContextInternal::demon_armor;
+                creators["demon skin"] = &AiObjectContextInternal::demon_skin;
+                creators["create healthstone"] = &AiObjectContextInternal::create_healthstone;
+                creators["create firestone"] = &AiObjectContextInternal::create_firestone;
+                creators["create spellstone"] = &AiObjectContextInternal::create_spellstone;
+                creators["spellstone"] = &AiObjectContextInternal::spellstone;
+                creators["summon voidwalker"] = &AiObjectContextInternal::summon_voidwalker;
+                creators["summon felguard"] = &AiObjectContextInternal::summon_felguard;
+                creators["immolate"] = &AiObjectContextInternal::immolate;
+                creators["corruption"] = &AiObjectContextInternal::corruption;
+                creators["corruption on attacker"] = &AiObjectContextInternal::corruption_on_attacker;
+                creators["curse of agony"] = &AiObjectContextInternal::curse_of_agony;
+                creators["shadow bolt"] = &AiObjectContextInternal::shadow_bolt;
+                creators["drain soul"] = &AiObjectContextInternal::drain_soul;
+                creators["drain mana"] = &AiObjectContextInternal::drain_mana;
+                creators["drain life"] = &AiObjectContextInternal::drain_life;
+                creators["banish"] = &AiObjectContextInternal::banish;
+                creators["seed of corruption"] = &AiObjectContextInternal::seed_of_corruption;
+                creators["rain of fire"] = &AiObjectContextInternal::rain_of_fire;
+                creators["shadowfury"] = &AiObjectContextInternal::shadowfury;
+                creators["life tap"] = &AiObjectContextInternal::life_tap;
+                creators["fear"] = &AiObjectContextInternal::fear;
+                creators["fear on cc"] = &AiObjectContextInternal::fear_on_cc;
+                creators["incinirate"] = &AiObjectContextInternal::incinirate;
+                creators["conflagrate"] = &AiObjectContextInternal::conflagrate;
+            }
+
+        private:
+            static Action* conflagrate(PlayerbotAI* ai) { return new CastConflagrateAction(ai); }
+            static Action* incinirate(PlayerbotAI* ai) { return new CastIncinirateAction(ai); }
+            static Action* fear_on_cc(PlayerbotAI* ai) { return new CastFearOnCcAction(ai); }
+            static Action* fear(PlayerbotAI* ai) { return new CastFearAction(ai); }
+            static Action* immolate(PlayerbotAI* ai) { return new CastImmolateAction(ai); }
+            static Action* summon_imp(PlayerbotAI* ai) { return new CastSummonImpAction(ai); }
+            static Action* fel_armor(PlayerbotAI* ai) { return new CastFelArmorAction(ai); }
+            static Action* demon_armor(PlayerbotAI* ai) { return new CastDemonArmorAction(ai); }
+            static Action* demon_skin(PlayerbotAI* ai) { return new CastDemonSkinAction(ai); }
+            static Action* create_healthstone(PlayerbotAI* ai) { return new CastCreateHealthstoneAction(ai); }
+            static Action* create_firestone(PlayerbotAI* ai) { return new CastCreateFirestoneAction(ai); }
+            static Action* create_spellstone(PlayerbotAI* ai) { return new CastCreateSpellstoneAction(ai); }
+            static Action* spellstone(PlayerbotAI* ai) { return new UseSpellItemAction(ai, "spellstone", true); }
+            static Action* summon_voidwalker(PlayerbotAI* ai) { return new CastSummonVoidwalkerAction(ai); }
+            static Action* summon_felguard(PlayerbotAI* ai) { return new CastSummonFelguardAction(ai); }
+            static Action* corruption(PlayerbotAI* ai) { return new CastCorruptionAction(ai); }
+            static Action* corruption_on_attacker(PlayerbotAI* ai) { return new CastCorruptionOnAttackerAction(ai); }
+            static Action* curse_of_agony(PlayerbotAI* ai) { return new CastCurseOfAgonyAction(ai); }
+            static Action* shadow_bolt(PlayerbotAI* ai) { return new CastShadowBoltAction(ai); }
+            static Action* drain_soul(PlayerbotAI* ai) { return new CastDrainSoulAction(ai); }
+            static Action* drain_mana(PlayerbotAI* ai) { return new CastDrainManaAction(ai); }
+            static Action* drain_life(PlayerbotAI* ai) { return new CastDrainLifeAction(ai); }
+            static Action* banish(PlayerbotAI* ai) { return new CastBanishAction(ai); }
+            static Action* seed_of_corruption(PlayerbotAI* ai) { return new CastSeedOfCorruptionAction(ai); }
+            static Action* rain_of_fire(PlayerbotAI* ai) { return new CastRainOfFireAction(ai); }
+            static Action* shadowfury(PlayerbotAI* ai) { return new CastShadowfuryAction(ai); }
+            static Action* life_tap(PlayerbotAI* ai) { return new CastLifeTapAction(ai); }
+
+        };
+    };
+};
+
+
+
+WarlockAiObjectContext::WarlockAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warlock::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warlock::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warlock::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warlock::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
new file mode 100644
index 0000000..0d3fa27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarlockAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarlockAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
new file mode 100644
index 0000000..a75926a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
new file mode 100644
index 0000000..660e584
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
@@ -0,0 +1,19 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+bool DemonArmorTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("demon skin", target) &&
+		!ai->HasAura("demon armor", target) &&
+		!ai->HasAura("fel armor", target);
+}
+
+bool SpellstoneTrigger::IsActive() 
+{
+    return BuffTrigger::IsActive() && AI_VALUE2(uint8, "item count", getName()) > 0;
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
new file mode 100644
index 0000000..796f884
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	class DemonArmorTrigger : public BuffTrigger
+	{
+	public:
+		DemonArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "demon armor") {}
+		virtual bool IsActive();
+	};
+
+    class SpellstoneTrigger : public BuffTrigger
+    {
+    public:
+        SpellstoneTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "spellstone") {}
+        virtual bool IsActive();
+    };
+
+    DEBUFF_TRIGGER(CurseOfAgonyTrigger, "curse of agony", "curse of agony");
+    DEBUFF_TRIGGER(CorruptionTrigger, "corruption", "corruption");
+
+    class CorruptionOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        CorruptionOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "corruption") {}
+    };
+
+    DEBUFF_TRIGGER(ImmolateTrigger, "immolate", "immolate");
+
+    class ShadowTranceTrigger : public HasAuraTrigger
+    {
+    public:
+        ShadowTranceTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "shadow trance") {}
+    };
+
+    class BacklashTrigger : public HasAuraTrigger
+    {
+    public:
+        BacklashTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "backlash") {}
+    };
+
+    class BanishTrigger : public HasCcTargetTrigger
+    {
+    public:
+        BanishTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "banish") {}
+    };
+
+    class WarlockConjuredItemTrigger : public ItemCountTrigger
+    {
+    public:
+        WarlockConjuredItemTrigger(PlayerbotAI* ai, string item) : ItemCountTrigger(ai, item, 1) {}
+
+        virtual bool IsActive() { return ItemCountTrigger::IsActive() && AI_VALUE2(uint8, "item count", "soul shard") > 0; }
+    };
+
+    class HasSpellstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasSpellstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "spellstone") {}
+    };
+
+    class HasFirestoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasFirestoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "firestone") {}
+    };
+
+    class HasHealthstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasHealthstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "healthstone") {}
+    };
+
+    class FearTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FearTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "fear") {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
new file mode 100644
index 0000000..7b13bec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
@@ -0,0 +1,130 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "DpsWarriorStrategy.h"
+
+using namespace ai;
+
+class DpsWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarriorStrategyActionNodeFactory()
+    {
+        creators["overpower"] = &overpower;
+        creators["melee"] = &melee;
+        creators["charge"] = &charge;
+        creators["bloodthirst"] = &bloodthirst;
+        creators["rend"] = &rend;
+        creators["mocking blow"] = &mocking_blow;
+        creators["death wish"] = &death_wish;
+        creators["execute"] = &execute;
+    }
+private:
+    static ActionNode* overpower(PlayerbotAI* ai)
+    {
+        return new ActionNode ("overpower",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("charge"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* charge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("charge",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bloodthirst(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bloodthirst",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mocking_blow(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mocking blow",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* death_wish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("death wish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("berserker rage"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* execute(PlayerbotAI* ai)
+    {
+        return new ActionNode ("execute",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarriorStrategy::DpsWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarriorStrategyActionNodeFactory());
+}
+
+NextAction** DpsWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("bloodthirst", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("charge", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "target critical health",
+        NextAction::array(0, new NextAction("execute", ACTION_HIGH + 4), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hamstring",
+		NextAction::array(0, new NextAction("hamstring", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"victory rush",
+		NextAction::array(0, new NextAction("victory rush", ACTION_HIGH + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "death wish",
+        NextAction::array(0, new NextAction("death wish", ACTION_HIGH + 2), NULL)));
+}
+
+
+void DpsWarrirorAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "rend on attacker",
+        NextAction::array(0, new NextAction("rend on attacker", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("cleave", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
new file mode 100644
index 0000000..3ef29c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class DpsWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        DpsWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class DpsWarrirorAoeStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarrirorAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
new file mode 100644
index 0000000..6bd7d08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "GenericWarriorNonCombatStrategy.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
new file mode 100644
index 0000000..1041a2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarriorNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarriorNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+   };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
new file mode 100644
index 0000000..4d7b851
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericWarriorStrategy.h"
+#include "WarriorAiObjectContext.h"
+
+using namespace ai;
+
+class GenericWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarriorStrategyActionNodeFactory()
+    {
+        creators["hamstring"] = &hamstring;
+        creators["heroic strike"] = &heroic_strike;
+        creators["battle shout"] = &battle_shout;
+    }
+private:
+    static ActionNode* hamstring(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hamstring",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* heroic_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("heroic strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* battle_shout(PlayerbotAI* ai)
+    {
+        return new ActionNode ("battle shout",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarriorStrategy::GenericWarriorStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarriorStrategyActionNodeFactory());
+}
+
+void GenericWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "battle shout",
+        NextAction::array(0, new NextAction("battle shout", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rend",
+        NextAction::array(0, new NextAction("rend", ACTION_NORMAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bloodrage",
+        NextAction::array(0, new NextAction("bloodrage", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash",
+        NextAction::array(0, new NextAction("shield bash", ACTION_INTERRUPT + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash on enemy healer",
+        NextAction::array(0, new NextAction("shield bash on enemy healer", ACTION_INTERRUPT + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("intimidating shout", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
new file mode 100644
index 0000000..0ef2dcf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericWarriorStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "warrior"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
new file mode 100644
index 0000000..5bf206c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "TankWarriorStrategy.h"
+
+using namespace ai;
+
+class TankWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankWarriorStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["shield wall"] = &shield_wall;
+        creators["rend"] = &rend;
+        creators["revenge"] = &revenge;
+        creators["devastate"] = &devastate;
+        creators["shockwave"] = &shockwave;
+        creators["taunt"] = &taunt;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* shield_wall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shield wall",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shield block"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* revenge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("revenge",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* devastate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("devastate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sunder armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* shockwave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shockwave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("cleave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* taunt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("taunt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mocking blow"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarriorStrategy::TankWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new TankWarriorStrategyActionNodeFactory());
+}
+
+NextAction** TankWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("devastate", ACTION_NORMAL + 1), new NextAction("revenge", ACTION_NORMAL + 1), NULL);
+}
+
+void TankWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium rage available",
+        NextAction::array(0, new NextAction("shield slam", ACTION_NORMAL + 2), new NextAction("heroic strike", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "disarm",
+        NextAction::array(0, new NextAction("disarm", ACTION_NORMAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("taunt", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("shield wall", ACTION_MEDIUM_HEAL), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("last stand", ACTION_EMERGENCY + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("shockwave", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2),  new NextAction("cleave", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("challenging shout", ACTION_HIGH + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"concussion blow",
+		NextAction::array(0, new NextAction("concussion blow", ACTION_INTERRUPT), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "sword and board",
+        NextAction::array(0, new NextAction("shield slam", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
new file mode 100644
index 0000000..0f98946
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class TankWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        TankWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
new file mode 100644
index 0000000..b6d44fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
+NextAction** CastRendAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRendOnAttackerAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellOnAttackerAction::getPrerequisites());
+}
+
+NextAction** CastDisarmAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), new NextAction("defensive stance"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastSunderArmorAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRevengeAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.h b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
new file mode 100644
index 0000000..65ac0ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
@@ -0,0 +1,210 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    // battle
+    class CastBattleMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastBattleMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("battle stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastDefensiveMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastDefensiveMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // all
+    class CastHeroicStrikeAction : public CastMeleeSpellAction {
+    public:
+        CastHeroicStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "heroic strike") {}
+    };
+
+    // all
+    class CastCleaveAction : public CastMeleeSpellAction {
+    public:
+        CastCleaveAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cleave") {}
+    };
+
+    // battle, berserker
+    class CastMockingBlowAction : public CastMeleeSpellAction {
+    public:
+        CastMockingBlowAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mocking blow") {}
+    };
+
+    class CastBloodthirstAction : public CastMeleeSpellAction {
+    public:
+        CastBloodthirstAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bloodthirst") {}
+    };
+
+    // battle, berserker
+    class CastExecuteAction : public CastMeleeSpellAction {
+    public:
+        CastExecuteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "execute") {}
+    };
+
+    // battle
+    class CastOverpowerAction : public CastBattleMeleeSpellAction {
+    public:
+        CastOverpowerAction(PlayerbotAI* ai) : CastBattleMeleeSpellAction(ai, "overpower") {}
+    };
+
+    // battle, berserker
+    class CastHamstringAction : public CastMeleeSpellAction {
+    public:
+        CastHamstringAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hamstring") {}
+    };
+
+    // defensive
+    class CastTauntAction : public CastSpellAction {
+    public:
+        CastTauntAction(PlayerbotAI* ai) : CastSpellAction(ai, "taunt") {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastShieldBlockAction : public CastBuffSpellAction {
+    public:
+        CastShieldBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shield block") {}
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+		}
+    };
+
+    // defensive
+    class CastShieldWallAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastShieldWallAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shield wall") {}
+    };
+
+    class CastBloodrageAction : public CastBuffSpellAction {
+    public:
+        CastBloodrageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodrage") {}
+    };
+
+    // defensive
+    class CastDevastateAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastDevastateAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "devastate") {}
+    };
+
+    // all
+    class CastSlamAction : public CastMeleeSpellAction {
+    public:
+        CastSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slam") {}
+    };
+
+	// all
+	class CastShieldSlamAction : public CastMeleeSpellAction {
+	public:
+		CastShieldSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "shield slam") {}
+	};
+
+    // after dodge
+    BEGIN_MELEE_SPELL_ACTION(CastRevengeAction, "revenge")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+
+    //debuffs
+    BEGIN_DEBUFF_ACTION(CastRendAction, "rend")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastRendOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastRendOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "rend") {}
+        virtual NextAction** getPrerequisites();
+    };
+
+    BEGIN_DEBUFF_ACTION(CastDisarmAction, "disarm")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastSunderArmorAction, "sunder armor") // 5 times
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastDemoralizingShoutAction : public CastDebuffSpellAction {
+    public:
+        CastDemoralizingShoutAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing shout") {}
+    };
+
+    BEGIN_MELEE_SPELL_ACTION(CastChallengingShoutAction, "challenging shout")
+    END_SPELL_ACTION()
+
+    // stuns
+    BEGIN_MELEE_SPELL_ACTION(CastShieldBashAction, "shield bash")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastIntimidatingShoutAction, "intimidating shout")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastThunderClapAction, "thunder clap")
+    END_SPELL_ACTION()
+
+    // buffs
+	class CastBattleShoutAction : public CastBuffSpellAction {
+	public:
+		CastBattleShoutAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle shout") {}
+	};
+
+	class CastDefensiveStanceAction : public CastBuffSpellAction {
+	public:
+		CastDefensiveStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "defensive stance") {}
+	};
+
+	class CastBattleStanceAction : public CastBuffSpellAction {
+	public:
+		CastBattleStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle stance") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastChargeAction, "charge")
+    END_SPELL_ACTION()
+
+	class CastDeathWishAction : public CastBuffSpellAction {
+	public:
+		CastDeathWishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "death wish") {}
+	};
+
+	class CastBerserkerRageAction : public CastBuffSpellAction {
+	public:
+		CastBerserkerRageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserker rage") {}
+	};
+
+	class CastLastStandAction : public CastBuffSpellAction {
+	public:
+		CastLastStandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "last stand") {}
+	};
+
+	// defensive
+	class CastShockwaveAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastShockwaveAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shockwave") {}
+	};
+
+	// defensive
+	class CastConcussionBlowAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastConcussionBlowAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "concussion blow") {}
+	};
+
+	BEGIN_MELEE_SPELL_ACTION(CastVictoryRushAction, "victory rush")
+	END_SPELL_ACTION()
+
+    class CastShieldBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastShieldBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "shield bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
new file mode 100644
index 0000000..bc74075
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
@@ -0,0 +1,192 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+#include "WarriorAiObjectContext.h"
+#include "GenericWarriorNonCombatStrategy.h"
+#include "TankWarriorStrategy.h"
+#include "DpsWarriorStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarriorTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warrior::StrategyFactoryInternal::nc;
+                creators["pull"] = &warrior::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warrior::StrategyFactoryInternal::aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarriorNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsWarrirorAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &warrior::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &warrior::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarriorStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarriorStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["hamstring"] = &TriggerFactoryInternal::hamstring;
+                creators["victory rush"] = &TriggerFactoryInternal::victory_rush;
+                creators["death wish"] = &TriggerFactoryInternal::death_wish;
+                creators["battle shout"] = &TriggerFactoryInternal::battle_shout;
+                creators["rend"] = &TriggerFactoryInternal::rend;
+                creators["rend on attacker"] = &TriggerFactoryInternal::rend_on_attacker;
+                creators["bloodrage"] = &TriggerFactoryInternal::bloodrage;
+                creators["shield bash"] = &TriggerFactoryInternal::shield_bash;
+                creators["disarm"] = &TriggerFactoryInternal::disarm;
+                creators["concussion blow"] = &TriggerFactoryInternal::concussion_blow;
+                creators["sword and board"] = &TriggerFactoryInternal::SwordAndBoard;
+                creators["shield bash on enemy healer"] = &TriggerFactoryInternal::shield_bash_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hamstring(PlayerbotAI* ai) { return new HamstringTrigger(ai); }
+            static Trigger* victory_rush(PlayerbotAI* ai) { return new VictoryRushTrigger(ai); }
+            static Trigger* death_wish(PlayerbotAI* ai) { return new DeathWishTrigger(ai); }
+            static Trigger* battle_shout(PlayerbotAI* ai) { return new BattleShoutTrigger(ai); }
+            static Trigger* rend(PlayerbotAI* ai) { return new RendDebuffTrigger(ai); }
+            static Trigger* rend_on_attacker(PlayerbotAI* ai) { return new RendDebuffOnAttackerTrigger(ai); }
+            static Trigger* bloodrage(PlayerbotAI* ai) { return new BloodrageDebuffTrigger(ai); }
+            static Trigger* shield_bash(PlayerbotAI* ai) { return new ShieldBashInterruptSpellTrigger(ai); }
+            static Trigger* disarm(PlayerbotAI* ai) { return new DisarmDebuffTrigger(ai); }
+            static Trigger* concussion_blow(PlayerbotAI* ai) { return new ConcussionBlowTrigger(ai); }
+            static Trigger* SwordAndBoard(PlayerbotAI* ai) { return new SwordAndBoardTrigger(ai); }
+            static Trigger* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new ShieldBashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["devastate"] = &AiObjectContextInternal::devastate;
+                creators["overpower"] = &AiObjectContextInternal::overpower;
+                creators["charge"] = &AiObjectContextInternal::charge;
+                creators["bloodthirst"] = &AiObjectContextInternal::bloodthirst;
+                creators["rend"] = &AiObjectContextInternal::rend;
+                creators["rend on attacker"] = &AiObjectContextInternal::rend_on_attacker;
+                creators["mocking blow"] = &AiObjectContextInternal::mocking_blow;
+                creators["death wish"] = &AiObjectContextInternal::death_wish;
+                creators["berserker rage"] = &AiObjectContextInternal::berserker_rage;
+                creators["victory rush"] = &AiObjectContextInternal::victory_rush;
+                creators["execute"] = &AiObjectContextInternal::execute;
+                creators["defensive stance"] = &AiObjectContextInternal::defensive_stance;
+                creators["hamstring"] = &AiObjectContextInternal::hamstring;
+                creators["shield bash"] = &AiObjectContextInternal::shield_bash;
+                creators["shield block"] = &AiObjectContextInternal::shield_block;
+                creators["bloodrage"] = &AiObjectContextInternal::bloodrage;
+                creators["battle stance"] = &AiObjectContextInternal::battle_stance;
+                creators["heroic strike"] = &AiObjectContextInternal::heroic_strike;
+                creators["intimidating shout"] = &AiObjectContextInternal::intimidating_shout;
+                creators["demoralizing shout"] = &AiObjectContextInternal::demoralizing_shout;
+                creators["challenging shout"] = &AiObjectContextInternal::challenging_shout;
+                creators["shield wall"] = &AiObjectContextInternal::shield_wall;
+                creators["battle shout"] = &AiObjectContextInternal::battle_shout;
+                creators["thunder clap"] = &AiObjectContextInternal::thunder_clap;
+                creators["taunt"] = &AiObjectContextInternal::taunt;
+                creators["revenge"] = &AiObjectContextInternal::revenge;
+                creators["slam"] = &AiObjectContextInternal::slam;
+                creators["shield slam"] = &AiObjectContextInternal::shield_slam;
+                creators["disarm"] = &AiObjectContextInternal::disarm;
+                creators["sunder armor"] = &AiObjectContextInternal::sunder_armor;
+                creators["last stand"] = &AiObjectContextInternal::last_stand;
+                creators["shockwave"] = &AiObjectContextInternal::shockwave;
+                creators["cleave"] = &AiObjectContextInternal::cleave;
+                creators["concussion blow"] = &AiObjectContextInternal::concussion_blow;
+                creators["shield bash on enemy healer"] = &AiObjectContextInternal::shield_bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* devastate(PlayerbotAI* ai) { return new CastDevastateAction(ai); }
+            static Action* last_stand(PlayerbotAI* ai) { return new CastLastStandAction(ai); }
+            static Action* shockwave(PlayerbotAI* ai) { return new CastShockwaveAction(ai); }
+            static Action* cleave(PlayerbotAI* ai) { return new CastCleaveAction(ai); }
+            static Action* concussion_blow(PlayerbotAI* ai) { return new CastConcussionBlowAction(ai); }
+            static Action* taunt(PlayerbotAI* ai) { return new CastTauntAction(ai); }
+            static Action* revenge(PlayerbotAI* ai) { return new CastRevengeAction(ai); }
+            static Action* slam(PlayerbotAI* ai) { return new CastSlamAction(ai); }
+            static Action* shield_slam(PlayerbotAI* ai) { return new CastShieldSlamAction(ai); }
+            static Action* disarm(PlayerbotAI* ai) { return new CastDisarmAction(ai); }
+            static Action* sunder_armor(PlayerbotAI* ai) { return new CastSunderArmorAction(ai); }
+            static Action* overpower(PlayerbotAI* ai) { return new CastOverpowerAction(ai); }
+            static Action* charge(PlayerbotAI* ai) { return new CastChargeAction(ai); }
+            static Action* bloodthirst(PlayerbotAI* ai) { return new CastBloodthirstAction(ai); }
+            static Action* rend(PlayerbotAI* ai) { return new CastRendAction(ai); }
+            static Action* rend_on_attacker(PlayerbotAI* ai) { return new CastRendOnAttackerAction(ai); }
+            static Action* mocking_blow(PlayerbotAI* ai) { return new CastMockingBlowAction(ai); }
+            static Action* death_wish(PlayerbotAI* ai) { return new CastDeathWishAction(ai); }
+            static Action* berserker_rage(PlayerbotAI* ai) { return new CastBerserkerRageAction(ai); }
+            static Action* victory_rush(PlayerbotAI* ai) { return new CastVictoryRushAction(ai); }
+            static Action* execute(PlayerbotAI* ai) { return new CastExecuteAction(ai); }
+            static Action* defensive_stance(PlayerbotAI* ai) { return new CastDefensiveStanceAction(ai); }
+            static Action* hamstring(PlayerbotAI* ai) { return new CastHamstringAction(ai); }
+            static Action* shield_bash(PlayerbotAI* ai) { return new CastShieldBashAction(ai); }
+            static Action* shield_block(PlayerbotAI* ai) { return new CastShieldBlockAction(ai); }
+            static Action* bloodrage(PlayerbotAI* ai) { return new CastBloodrageAction(ai); }
+            static Action* battle_stance(PlayerbotAI* ai) { return new CastBattleStanceAction(ai); }
+            static Action* heroic_strike(PlayerbotAI* ai) { return new CastHeroicStrikeAction(ai); }
+            static Action* intimidating_shout(PlayerbotAI* ai) { return new CastIntimidatingShoutAction(ai); }
+            static Action* demoralizing_shout(PlayerbotAI* ai) { return new CastDemoralizingShoutAction(ai); }
+            static Action* challenging_shout(PlayerbotAI* ai) { return new CastChallengingShoutAction(ai); }
+            static Action* shield_wall(PlayerbotAI* ai) { return new CastShieldWallAction(ai); }
+            static Action* battle_shout(PlayerbotAI* ai) { return new CastBattleShoutAction(ai); }
+            static Action* thunder_clap(PlayerbotAI* ai) { return new CastThunderClapAction(ai); }
+            static Action* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new CastShieldBashOnEnemyHealerAction(ai); }
+
+        };
+    };
+};
+
+WarriorAiObjectContext::WarriorAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warrior::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warrior::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warrior::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warrior::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
new file mode 100644
index 0000000..bc1b5d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarriorAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarriorAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
new file mode 100644
index 0000000..0698aa1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
new file mode 100644
index 0000000..0b8d183
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorTriggers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
new file mode 100644
index 0000000..72a1285
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
@@ -0,0 +1,78 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_TRIGGER(BattleShoutTrigger, "battle shout", "battle shout")
+
+    DEBUFF_TRIGGER(RendDebuffTrigger, "rend", "rend")
+    DEBUFF_TRIGGER(DisarmDebuffTrigger, "disarm", "disarm")
+    DEBUFF_TRIGGER(SunderArmorDebuffTrigger, "sunder armor", "sunder armor")
+
+    class RendDebuffOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        RendDebuffOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "rend") {}
+    };
+
+	class RevengeAvailableTrigger : public SpellCanBeCastTrigger
+	{
+	public:
+		RevengeAvailableTrigger(PlayerbotAI* ai) : SpellCanBeCastTrigger(ai, "revenge") {}
+	};
+
+    class BloodrageDebuffTrigger : public DebuffTrigger
+    {
+    public:
+        BloodrageDebuffTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "bloodrage") {}
+        virtual bool IsActive()
+        {
+            return DebuffTrigger::IsActive() &&
+                AI_VALUE2(uint8, "health", "self target") >= 75 &&
+                AI_VALUE2(uint8, "rage", "self target") < 20;
+        }
+    };
+
+    class ShieldBashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        ShieldBashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "shield bash") {}
+    };
+
+    class VictoryRushTrigger : public HasAuraTrigger
+    {
+    public:
+        VictoryRushTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "victory rush") {}
+    };
+
+    class SwordAndBoardTrigger : public HasAuraTrigger
+    {
+    public:
+        SwordAndBoardTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "sword and board") {}
+    };
+
+    class ConcussionBlowTrigger : public SnareTargetTrigger
+    {
+    public:
+        ConcussionBlowTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "concussion blow") {}
+    };
+
+    class HamstringTrigger : public SnareTargetTrigger
+    {
+    public:
+        HamstringTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hamstring") {}
+    };
+
+    class DeathWishTrigger : public BoostTrigger
+    {
+    public:
+        DeathWishTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "death wish") {}
+    };
+
+    class ShieldBashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        ShieldBashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "shield bash") {}
+    };
+
+}
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 015109e..5bd6edb 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -32,6 +32,8 @@
 #include "Log.h"
 #include <vector>
 
+#include "../../plugins/ahbot/AhBot.h"
+
 enum eAuctionHouse
 {
     AH_MINIMUM_DEPOSIT = 100
@@ -188,6 +190,9 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
             .AddMoney(profit)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, sWorld->getIntConfig(CONFIG_MAIL_DELIVERY_DELAY));
+
+        // ahbot mod
+        auctionbot.Won(auction);
     }
 }
 
@@ -211,6 +216,9 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
             .AddItem(pItem)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, 0);
+
+        // ahbot mod
+        auctionbot.Expired(auction);
     }
     else
     {
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index d748be4..667a6f3 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -211,7 +211,7 @@ add_library(game STATIC
   ${game_STAT_PCH_SRC}
 )
 
-add_dependencies(game revision.h)
+add_dependencies(game plugins revision.h)
 
 # Generate precompiled header
 if (USE_COREPCH)
diff --git a/src/server/game/DungeonFinding/LFGQueue.cpp b/src/server/game/DungeonFinding/LFGQueue.cpp
index f547aed..5a1530f 100644
--- a/src/server/game/DungeonFinding/LFGQueue.cpp
+++ b/src/server/game/DungeonFinding/LFGQueue.cpp
@@ -27,6 +27,7 @@
 #include "World.h"
 #include "GroupMgr.h"
 
+#include "../Entities/Player/Player.h"
 namespace lfg
 {
 
@@ -486,6 +487,20 @@ LfgCompatibility LFGQueue::CheckCompatibility(GuidList check)
         return LFG_COMPATIBLES_WITH_LESS_PLAYERS;
     }
 
+    // playerbot mod
+    bool nonBotFound = false;
+    for (GuidList::const_iterator it = check.begin(); it != check.end(); ++it)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(*it);
+        if (player && !player->GetPlayerbotAI())
+        {
+            nonBotFound = true;
+            break;
+        }
+    }
+    if (!nonBotFound)
+        return LFG_INCOMPATIBLES_HAS_IGNORES;
+    // end of playerbot mod
     ObjectGuid gguid = *check.begin();
     proposal.queues = check;
     proposal.isNew = numLfgGroups != 1 || sLFGMgr->GetOldState(gguid) != LFG_STATE_DUNGEON;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index f8f569d..5228395 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -81,6 +81,9 @@
 #include "GameObjectAI.h"
 #include "Config.h"
 
+// Playerbot mod:
+#include "../../plugins/playerbot/playerbot.h"
+
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
 #define PLAYER_SKILL_INDEX(x)       (PLAYER_SKILL_INFO_1_1 + ((x)*3))
@@ -908,6 +911,10 @@ Player::Player(WorldSession* session): Unit(true)
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    // playerbot mod
+    m_playerbotAI = NULL;
+    m_playerbotMgr = NULL;
 }
 
 Player::~Player()
@@ -1886,6 +1893,12 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    // Playerbot mod
+    if (m_playerbotAI)
+       m_playerbotAI->UpdateAI(p_time);
+    if (m_playerbotMgr)
+       m_playerbotMgr->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 8ed561b..e7fc450 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -53,6 +53,10 @@ class PlayerSocial;
 class SpellCastTargets;
 class UpdateMask;
 
+// Playerbot mod
+class PlayerbotAI;
+class PlayerbotMgr;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2335,6 +2339,18 @@ class Player : public Unit, public GridObject<Player>
 
         bool CanFly() const override { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        EquipmentSets& GetEquipmentSets() { return m_EquipmentSets; }
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        PlayerTalentMap& GetTalentMap(uint8 spec) { return *m_talents[spec]; }
+        bool MinimalLoadFromDB( QueryResult result, uint32 guid );
+
         //! Return collision height sent to client
         float GetCollisionHeight(bool mounted) const;
 
@@ -2673,6 +2689,10 @@ class Player : public Unit, public GridObject<Player>
         uint32 _pendingBindTimer;
 
         uint32 _activeCheats;
+
+        // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
 };
 
 void AddItemsSetItem(Player* player, Item* item);
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 519e073..9fa4f98 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -323,6 +323,11 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        // ai playerbot mod
+        ObjectGuid GetTargetIcon(int index) { return m_targetIcons[index]; }
+        Rolls* GetRolls() { return &RollId; }
+        // end
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index 56f4216..a9fc8c5 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -47,6 +47,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+// Playerbot mod:
+#include "../../plugins/playerbot/playerbot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -61,6 +64,76 @@ class LoginQueryHolder : public SQLQueryHolder
         bool Initialize();
 };
 
+class PlayerbotLoginQueryHolder : public LoginQueryHolder
+{
+private:
+    uint32 masterAccountId;
+    PlayerbotHolder* playerbotHolder;
+
+public:
+    PlayerbotLoginQueryHolder(PlayerbotHolder* playerbotHolder, uint32 masterAccount, uint32 accountId, uint64 guid)
+        : LoginQueryHolder(accountId, ObjectGuid(guid)), masterAccountId(masterAccount), playerbotHolder(playerbotHolder) { }
+
+public:
+    uint32 GetMasterAccountId() const { return masterAccountId; }
+    PlayerbotHolder* GetPlayerbotHolder() { return playerbotHolder; }
+};
+
+void PlayerbotHolder::AddPlayerBot(uint64 playerGuid, uint32 masterAccount)
+{
+    // has bot already been added?
+	Player* bot = sObjectMgr->GetPlayerByLowGUID(playerGuid);
+
+	if (bot && bot->IsInWorld())
+        return;
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(ObjectGuid(playerGuid));
+    if (accountId == 0)
+        return;
+
+    PlayerbotLoginQueryHolder *holder = new PlayerbotLoginQueryHolder(this, masterAccount, accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+
+    QueryResultHolderFuture future = CharacterDatabase.DelayQueryHolder(holder);
+    future.get();
+
+    WorldSession* masterSession = masterAccount ? sWorld->FindSession(masterAccount) : NULL;
+    uint32 botAccountId = holder->GetAccountId();
+    WorldSession *botSession = new WorldSession(botAccountId, NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+
+    botSession->HandlePlayerLogin(holder); // will delete lqh
+
+	bot = botSession->GetPlayer();
+	if (!bot)
+		return;
+
+	PlayerbotMgr *mgr = bot->GetPlayerbotMgr();
+	bot->SetPlayerbotMgr(NULL);
+	delete mgr;
+	sRandomPlayerbotMgr.OnPlayerLogout(bot);
+
+    bool allowed = false;
+    if (botAccountId == masterAccount)
+        allowed = true;
+    else if (masterSession && sPlayerbotAIConfig.allowGuildBots && bot->GetGuildId() == masterSession->GetPlayer()->GetGuildId())
+        allowed = true;
+    else if (sPlayerbotAIConfig.IsInRandomAccountList(botAccountId))
+        allowed = true;
+
+    if (allowed)
+        OnBotLogin(bot);
+    else if (masterSession)
+    {
+        ChatHandler ch(masterSession);
+        ch.PSendSysMessage("You are not allowed to control bot %s...", bot->GetName().c_str());
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -1040,6 +1113,14 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // Handle Login-Achievements (should be handled after loading)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
+    // playerbot mod
+    if (!_player->GetPlayerbotAI())
+    {
+        _player->SetPlayerbotMgr(new PlayerbotMgr(_player));
+        sRandomPlayerbotMgr.OnPlayerLogin(_player);
+    }
+    // end of playerbot mod
+
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
     // Prepatch by LordPsyan
     // 01
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index b33f236..039bb81 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -40,6 +40,9 @@
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 {
     uint32 type;
@@ -298,7 +301,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 (HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID())))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
-            GetPlayer()->Whisper(msg, Language(lang), receiver);
+            // Playerbot mod: handle whispered command to bot
+            if (receiver->GetPlayerbotAI())
+            {
+                receiver->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                receiver->m_speakTime = 0;
+                receiver->m_speakCount = 0;
+            }
+            else
+            {
+                GetPlayer()->Whisper(msg, Language(lang), receiver);
+            }
+            // END Playerbot mod
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -315,6 +329,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (type == CHAT_MSG_PARTY_LEADER && !group->IsLeader(sender->GetGUID()))
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -331,6 +358,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
+                // Playerbot mod: broadcast message to bot members
+                PlayerbotMgr *mgr = GetPlayer()->GetPlayerbotMgr();
+                if (mgr)
+                {
+                    for (PlayerBotMap::const_iterator it = mgr->GetPlayerBotsBegin(); it != mgr->GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        if (bot->GetGuildId() == GetPlayer()->GetGuildId())
+                            bot->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    }
+                }
+                // END Playerbot mod
             }
         } break;
         case CHAT_MSG_OFFICER:
@@ -356,6 +395,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -373,6 +425,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -385,6 +450,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())) || group->isBGGroup())
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI())
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -433,6 +511,13 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             {
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
+                    // Playerbot mod: broadcast message to bot members
+                    if (_player->GetPlayerbotMgr() && chn->GetFlags() & 0x18)
+                    {
+                        _player->GetPlayerbotMgr()->HandleCommand(type, msg);
+                    }
+                    sRandomPlayerbotMgr.HandleCommand(type, msg, *_player);
+                    // END Playerbot mod
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
                     chn->Say(sender->GetGUID(), msg.c_str(), lang);
                 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index 84bb906..894baa7 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -48,6 +48,9 @@
 #include "WardenMac.h"
 #include "MoveSpline.h"
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -190,6 +193,14 @@ uint32 WorldSession::GetGuidLow() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
     if (!m_Socket)
         return;
 
@@ -259,6 +270,8 @@ void WorldSession::LogUnprocessedTail(WorldPacket* packet)
 /// Update the WorldSession (triggered by World update)
 bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 {
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI()) return true;
+
     /// Update Timeout timer.
     UpdateTimeOutTime(diff);
 
@@ -325,6 +338,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             sScriptMgr->OnPacketReceive(this, *packet);
                             (this->*opHandle.handler)(*packet);
                             LogUnprocessedTail(packet);
+
+                            // playerbot mod
+                            if (_player && _player->GetPlayerbotMgr())
+                                _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                            // playerbot mod end
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -401,6 +419,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
             break;
     }
 
+    // playerbot mod
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr())
+        GetPlayer()->GetPlayerbotMgr()->UpdateSessions(0);
+    // end of playerbot mod
+
     if (m_Socket && m_Socket->IsOpen() && _warden)
         _warden->Update();
 
@@ -450,6 +473,11 @@ void WorldSession::LogoutPlayer(bool save)
         if (ObjectGuid lguid = _player->GetLootGUID())
             DoLootRelease(lguid);
 
+        // Playerbot mod: log out all player bots owned by this toon
+        if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->LogoutAllBots();
+        sRandomPlayerbotMgr.OnPlayerLogout(_player);
+
         ///- If the player just died before logging out, make him appear as a ghost
         if (_player->GetDeathTimer())
         {
@@ -525,7 +553,8 @@ void WorldSession::LogoutPlayer(bool save)
         _player->CleanupChannels();
 
         ///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
-        _player->UninviteFromGroup();
+        // playerbot mod
+        //_player->UninviteFromGroup();
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
@@ -1521,3 +1550,14 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
 
     return maxPacketCounterAllowed;
 }
+
+void WorldSession::HandleBotPackets()
+{
+    WorldPacket* packet;
+    while (_recvQueue.next(packet))
+    {
+        OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+        (this->*opHandle.handler)(*packet);
+        delete packet;
+    }
+}
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 789bd5a..52042cd 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -176,7 +176,8 @@ class CharacterCreateInfo
     friend class WorldSession;
     friend class Player;
 
-    protected:
+    // playerbot mod
+    public:
         CharacterCreateInfo(std::string const& name, uint8 race, uint8 cclass, uint8 gender, uint8 skin, uint8 face, uint8 hairStyle, uint8 hairColor, uint8 facialHair, uint8 outfitId,
         WorldPacket& data) : Name(name), Race(race), Class(cclass), Gender(gender), Skin(skin), Face(face), HairStyle(hairStyle), HairColor(hairColor), FacialHair(facialHair),
         OutfitId(outfitId), Data(std::move(data)), CharCount(0)
@@ -768,6 +769,10 @@ class WorldSession
         void HandleBattlemasterJoinArena(WorldPacket& recvData);
         void HandleReportPvPAFK(WorldPacket& recvData);
 
+        // playerbot mod
+        void HandleBotPackets();
+        // end of playerbot mod
+
         // Battlefield
         void SendBfInvitePlayerToWar(uint32 battleId, uint32 zoneId, uint32 time);
         void SendBfInvitePlayerToQueue(uint32 battleId);
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index d204f0c..a9c280e 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -65,6 +65,10 @@
 #include "WeatherMgr.h"
 #include "WorldSession.h"
 
+// playerbot mod
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/playerbot/RandomPlayerbotMgr.h"
 
 std::atomic<bool> World::m_stopEvent(false);
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -1856,6 +1860,11 @@ void World::SetInitialWorldSettings()
 
     if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
         sLog->SetRealmId(realmId);
+
+    TC_LOG_INFO("server.loading", "Initializing AuctionHouseBot...");
+    auctionbot.Init();
+
+    sPlayerbotAIConfig.Initialize();
 }
 
 void World::DetectDBCLang()
@@ -2029,14 +2038,22 @@ void World::Update(uint32 diff)
 
         ///- Handle expired auctions
         sAuctionMgr->Update();
+
+        // ahbot mod
+        auctionbot.Update();
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.UpdateAI(diff);
+    sRandomPlayerbotMgr.UpdateSessions(diff);
+
     /// <li> Handle AHBot operations
-    if (m_timers[WUPDATE_AHBOT].Passed())
-    {
-        sAuctionBot->Update();
-        m_timers[WUPDATE_AHBOT].Reset();
-    }
+    // if (m_timers[WUPDATE_AHBOT].Passed())
+    //{
+    //    sAuctionBot->Update();
+    //    m_timers[WUPDATE_AHBOT].Reset();
+    //}
+    // end of playerbot mod
 
     /// <li> Handle session updates when the timer has passed
     RecordTimeDiff(NULL);
@@ -2598,6 +2615,10 @@ void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode, const std:
         ShutdownMsg(true, nullptr, reason);
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.LogoutAllBots();
+    // end of playerbot mod
+
     sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
 }
 
diff --git a/src/server/scripts/Commands/cs_ahbot.cpp b/src/server/scripts/Commands/cs_ahbot.cpp
index 04647d5..598aca2 100644
--- a/src/server/scripts/Commands/cs_ahbot.cpp
+++ b/src/server/scripts/Commands/cs_ahbot.cpp
@@ -247,5 +247,6 @@ template bool ahbot_commandscript::HandleAHBotItemsRatioHouseCommand<AUCTION_HOU
 
 void AddSC_ahbot_commandscript()
 {
-    new ahbot_commandscript();
+    // playerbot mod
+    // new ahbot_commandscript();
 }
diff --git a/src/server/scripts/Commands/cs_misc.cpp b/src/server/scripts/Commands/cs_misc.cpp
index b4b9928..dd8af53 100644
--- a/src/server/scripts/Commands/cs_misc.cpp
+++ b/src/server/scripts/Commands/cs_misc.cpp
@@ -36,6 +36,9 @@
 #include "GroupMgr.h"
 #include "MMapFactory.h"
 
+#include "../../../plugins/ahbot/AhBot.h"
+#include "../../../plugins/playerbot/playerbot.h"
+
 class misc_commandscript : public CommandScript
 {
 public:
@@ -94,6 +97,10 @@ public:
             { "unstuck",          rbac::RBAC_PERM_COMMAND_UNSTUCK,           true, &HandleUnstuckCommand,          "", NULL },
             { "wchange",          rbac::RBAC_PERM_COMMAND_WCHANGE,          false, &HandleChangeWeather,           "", NULL },
             { "mailbox",          rbac::RBAC_PERM_COMMAND_MAILBOX,          false, &HandleMailBoxCommand,          "", NULL },
+            // playerbot mod
+            { "ahbot",            rbac::RBAC_PERM_COMMAND_GM       ,          true,  &ahbot::AhBot::HandleAhBotCommand,                      "", NULL },
+            { "rndbot",           rbac::RBAC_PERM_COMMAND_GM       ,          true,  &RandomPlayerbotMgr::HandlePlayerbotConsoleCommand,     "", NULL },
+            { "bot",              195                              ,          false, &PlayerbotMgr::HandlePlayerbotMgrCommand,               "", NULL },
             { NULL,               0,                                  false, NULL,                           "", NULL }
         };
         return commandTable;
diff --git a/src/server/shared/Configuration/Config.h b/src/server/shared/Configuration/Config.h
index ff0233b..1ce0bdd 100644
--- a/src/server/shared/Configuration/Config.h
+++ b/src/server/shared/Configuration/Config.h
@@ -26,6 +26,8 @@
 
 class ConfigMgr
 {
+// playerbot mod
+public:
     ConfigMgr() { }
     ~ConfigMgr() { }
 
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index a367714..7f94f7c 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -162,6 +162,7 @@ set_target_properties(worldserver PROPERTIES LINK_FLAGS "${worldserver_LINK_FLAG
 
 target_link_libraries(worldserver
   game
+  plugins
   shared
   scripts
   collision
-- 
2.1.0

