From ae01bd26afa1a139b490b2991421209dd74d950f Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Mon, 7 Sep 2015 07:41:08 -0500
Subject: [PATCH] ike3-Playerbots

---
 cmake/options.cmake                                |    1 +
 sql/ai_playerbot_guild_names.sql                   |  652 +++++
 sql/characters_ai_playerbot.sql                    |   34 +
 sql/characters_ai_playerbot_names.zip              |  Bin 0 -> 633604 bytes
 sql/characters_ai_playerbot_real_names.zip         |  Bin 0 -> 34800 bytes
 sql/characters_auctionhousebot.sql                 |   37 +
 src/CMakeLists.txt                                 |    5 +
 src/common/Configuration/Config.h                  |    2 +
 src/plugins/CMakeLists.txt                         |  190 ++
 src/plugins/ahbot/AhBot.cpp                        |  983 +++++++
 src/plugins/ahbot/AhBot.h                          |   93 +
 src/plugins/ahbot/AhBotConfig.cpp                  |   60 +
 src/plugins/ahbot/AhBotConfig.h                    |   93 +
 src/plugins/ahbot/Category.cpp                     |   76 +
 src/plugins/ahbot/Category.h                       |  354 +++
 src/plugins/ahbot/ConsumableCategory.cpp           |    5 +
 src/plugins/ahbot/ConsumableCategory.h             |   86 +
 src/plugins/ahbot/ItemBag.cpp                      |  184 ++
 src/plugins/ahbot/ItemBag.h                        |   82 +
 src/plugins/ahbot/PricingStrategy.cpp              |  220 ++
 src/plugins/ahbot/PricingStrategy.h                |   55 +
 src/plugins/ahbot/TradeCategory.cpp                |    4 +
 src/plugins/ahbot/TradeCategory.h                  |  183 ++
 src/plugins/ahbot/ahbot.conf.dist.in               |  209 ++
 src/plugins/pch/pch.cpp                            |    1 +
 src/plugins/pch/pch.h                              |   10 +
 src/plugins/pchdef.h                               |    4 +
 src/plugins/playerbot/AiFactory.cpp                |  229 ++
 src/plugins/playerbot/AiFactory.h                  |   20 +
 src/plugins/playerbot/ChatFilter.cpp               |  257 ++
 src/plugins/playerbot/ChatFilter.h                 |   24 +
 src/plugins/playerbot/ChatHelper.cpp               |  450 ++++
 src/plugins/playerbot/ChatHelper.h                 |   52 +
 src/plugins/playerbot/FleeManager.cpp              |  160 ++
 src/plugins/playerbot/FleeManager.h                |   83 +
 src/plugins/playerbot/GuildTaskMgr.cpp             |  697 +++++
 src/plugins/playerbot/GuildTaskMgr.h               |   45 +
 src/plugins/playerbot/Helpers.cpp                  |   90 +
 src/plugins/playerbot/LazyCalculatedValue.h        |   42 +
 src/plugins/playerbot/LootObjectStack.cpp          |  244 ++
 src/plugins/playerbot/LootObjectStack.h            |   76 +
 src/plugins/playerbot/PlayerbotAI.cpp              | 1395 ++++++++++
 src/plugins/playerbot/PlayerbotAI.h                |  186 ++
 src/plugins/playerbot/PlayerbotAIAware.h           |   13 +
 src/plugins/playerbot/PlayerbotAIBase.cpp          |   51 +
 src/plugins/playerbot/PlayerbotAIBase.h            |   24 +
 src/plugins/playerbot/PlayerbotAIConfig.cpp        |  230 ++
 src/plugins/playerbot/PlayerbotAIConfig.h          |   82 +
 src/plugins/playerbot/PlayerbotCommandServer.cpp   |   94 +
 src/plugins/playerbot/PlayerbotCommandServer.h     |   26 +
 src/plugins/playerbot/PlayerbotFactory.cpp         | 2818 ++++++++++++++++++++
 src/plugins/playerbot/PlayerbotFactory.h           |   74 +
 src/plugins/playerbot/PlayerbotMgr.cpp             |  479 ++++
 src/plugins/playerbot/PlayerbotMgr.h               |   69 +
 src/plugins/playerbot/PlayerbotSecurity.cpp        |  188 ++
 src/plugins/playerbot/PlayerbotSecurity.h          |   42 +
 src/plugins/playerbot/RandomItemMgr.cpp            |  154 ++
 src/plugins/playerbot/RandomItemMgr.h              |   50 +
 src/plugins/playerbot/RandomPlayerbotFactory.cpp   |  357 +++
 src/plugins/playerbot/RandomPlayerbotFactory.h     |   35 +
 src/plugins/playerbot/RandomPlayerbotMgr.cpp       |  893 +++++++
 src/plugins/playerbot/RandomPlayerbotMgr.h         |   73 +
 src/plugins/playerbot/aiplayerbot.conf.dist.in     |  183 ++
 src/plugins/playerbot/playerbot.h                  |   31 +
 src/plugins/playerbot/playerbotDefs.h              |    2 +
 src/plugins/playerbot/strategy/Action.cpp          |   93 +
 src/plugins/playerbot/strategy/Action.h            |  138 +
 src/plugins/playerbot/strategy/ActionBasket.cpp    |    4 +
 src/plugins/playerbot/strategy/ActionBasket.h      |    5 +
 src/plugins/playerbot/strategy/AiObject.cpp        |   16 +
 src/plugins/playerbot/strategy/AiObject.h          |   33 +
 src/plugins/playerbot/strategy/AiObjectContext.cpp |   48 +
 src/plugins/playerbot/strategy/AiObjectContext.h   |   81 +
 src/plugins/playerbot/strategy/Engine.cpp          |  536 ++++
 src/plugins/playerbot/strategy/Engine.h            |  123 +
 src/plugins/playerbot/strategy/Event.cpp           |   20 +
 src/plugins/playerbot/strategy/Event.h             |   36 +
 .../playerbot/strategy/ExternalEventHelper.h       |   69 +
 src/plugins/playerbot/strategy/ItemVisitors.h      |  258 ++
 src/plugins/playerbot/strategy/Multiplier.cpp      |    5 +
 src/plugins/playerbot/strategy/Multiplier.h        |   16 +
 .../playerbot/strategy/NamedObjectContext.h        |  249 ++
 .../playerbot/strategy/PassiveMultiplier.cpp       |   47 +
 src/plugins/playerbot/strategy/PassiveMultiplier.h |   20 +
 src/plugins/playerbot/strategy/Queue.cpp           |   81 +
 src/plugins/playerbot/strategy/Queue.h             |   21 +
 src/plugins/playerbot/strategy/Strategy.cpp        |  117 +
 src/plugins/playerbot/strategy/Strategy.h          |   55 +
 src/plugins/playerbot/strategy/StrategyContext.h   |  146 +
 src/plugins/playerbot/strategy/Trigger.cpp         |   27 +
 src/plugins/playerbot/strategy/Trigger.h           |   84 +
 src/plugins/playerbot/strategy/Value.cpp           |    5 +
 src/plugins/playerbot/strategy/Value.h             |  177 ++
 .../playerbot/strategy/actions/AcceptDuelAction.h  |   31 +
 .../strategy/actions/AcceptInvitationAction.h      |   47 +
 .../strategy/actions/AcceptQuestAction.cpp         |  102 +
 .../playerbot/strategy/actions/AcceptQuestAction.h |   27 +
 .../strategy/actions/AcceptResurrectAction.h       |   31 +
 .../playerbot/strategy/actions/ActionContext.h     |  110 +
 .../playerbot/strategy/actions/AddLootAction.cpp   |   62 +
 .../playerbot/strategy/actions/AddLootAction.h     |   32 +
 .../strategy/actions/AreaTriggerAction.cpp         |   80 +
 .../playerbot/strategy/actions/AreaTriggerAction.h |   23 +
 .../playerbot/strategy/actions/AttackAction.cpp    |  104 +
 .../playerbot/strategy/actions/AttackAction.h      |   38 +
 .../playerbot/strategy/actions/BankAction.cpp      |  168 ++
 .../playerbot/strategy/actions/BankAction.h        |   21 +
 .../playerbot/strategy/actions/BuffAction.cpp      |  118 +
 .../playerbot/strategy/actions/BuffAction.h        |   17 +
 .../playerbot/strategy/actions/BuyAction.cpp       |   53 +
 src/plugins/playerbot/strategy/actions/BuyAction.h |   19 +
 .../strategy/actions/CastCustomSpellAction.cpp     |   48 +
 .../strategy/actions/CastCustomSpellAction.h       |   14 +
 .../strategy/actions/ChangeChatAction.cpp          |   26 +
 .../playerbot/strategy/actions/ChangeChatAction.h  |   14 +
 .../strategy/actions/ChangeStrategyAction.cpp      |   38 +
 .../strategy/actions/ChangeStrategyAction.h        |   30 +
 .../strategy/actions/ChangeTalentsAction.cpp       |   37 +
 .../strategy/actions/ChangeTalentsAction.h         |   16 +
 .../playerbot/strategy/actions/ChatActionContext.h |  184 ++
 .../strategy/actions/ChatShortcutActions.cpp       |  108 +
 .../strategy/actions/ChatShortcutActions.h         |   57 +
 .../playerbot/strategy/actions/CheckMailAction.cpp |   66 +
 .../playerbot/strategy/actions/CheckMailAction.h   |   17 +
 .../strategy/actions/CheckMountStateAction.cpp     |   79 +
 .../strategy/actions/CheckMountStateAction.h       |   19 +
 .../strategy/actions/ChooseTargetActions.h         |   80 +
 .../strategy/actions/DestroyItemAction.cpp         |   34 +
 .../playerbot/strategy/actions/DestroyItemAction.h |   17 +
 .../playerbot/strategy/actions/DropQuestAction.cpp |   47 +
 .../playerbot/strategy/actions/DropQuestAction.h   |   13 +
 .../playerbot/strategy/actions/EmoteAction.cpp     |  104 +
 .../playerbot/strategy/actions/EmoteAction.h       |   18 +
 .../playerbot/strategy/actions/EquipAction.cpp     |  105 +
 .../playerbot/strategy/actions/EquipAction.h       |   21 +
 .../playerbot/strategy/actions/FollowActions.cpp   |   49 +
 .../playerbot/strategy/actions/FollowActions.h     |   14 +
 .../playerbot/strategy/actions/GenericActions.cpp  |    5 +
 .../playerbot/strategy/actions/GenericActions.h    |   19 +
 .../strategy/actions/GenericSpellActions.cpp       |   58 +
 .../strategy/actions/GenericSpellActions.h         |  271 ++
 .../strategy/actions/GossipHelloAction.cpp         |   71 +
 .../playerbot/strategy/actions/GossipHelloAction.h |   13 +
 .../strategy/actions/GuildAcceptAction.cpp         |   42 +
 .../playerbot/strategy/actions/GuildAcceptAction.h |   14 +
 .../playerbot/strategy/actions/GuildBankAction.cpp |   61 +
 .../playerbot/strategy/actions/GuildBankAction.h   |   18 +
 .../playerbot/strategy/actions/HelpAction.cpp      |   54 +
 .../playerbot/strategy/actions/HelpAction.h        |   22 +
 .../playerbot/strategy/actions/InventoryAction.cpp |  288 ++
 .../playerbot/strategy/actions/InventoryAction.h   |   24 +
 .../actions/InventoryChangeFailureAction.cpp       |   55 +
 .../actions/InventoryChangeFailureAction.h         |   12 +
 .../strategy/actions/InviteToGroupAction.h         |   28 +
 .../playerbot/strategy/actions/LeaveGroupAction.h  |   79 +
 .../playerbot/strategy/actions/LfgActions.cpp      |  258 ++
 .../playerbot/strategy/actions/LfgActions.h        |   48 +
 .../strategy/actions/ListQuestsActions.cpp         |   71 +
 .../playerbot/strategy/actions/ListQuestsActions.h |   25 +
 .../strategy/actions/ListSpellsAction.cpp          |   65 +
 .../playerbot/strategy/actions/ListSpellsAction.h  |   16 +
 .../playerbot/strategy/actions/LogLevelAction.cpp  |   43 +
 .../playerbot/strategy/actions/LogLevelAction.h    |   17 +
 .../playerbot/strategy/actions/LootAction.cpp      |  338 +++
 .../playerbot/strategy/actions/LootAction.h        |   39 +
 .../playerbot/strategy/actions/LootRollAction.cpp  |   66 +
 .../playerbot/strategy/actions/LootRollAction.h    |   15 +
 .../strategy/actions/LootStrategyAction.cpp        |  100 +
 .../strategy/actions/LootStrategyAction.h          |   19 +
 .../playerbot/strategy/actions/MovementActions.cpp |  373 +++
 .../playerbot/strategy/actions/MovementActions.h   |   92 +
 .../strategy/actions/NonCombatActions.cpp          |    6 +
 .../playerbot/strategy/actions/NonCombatActions.h  |   47 +
 .../actions/PassLeadershipToMasterAction.h         |   26 +
 .../playerbot/strategy/actions/PositionAction.cpp  |   38 +
 .../playerbot/strategy/actions/PositionAction.h    |   37 +
 .../strategy/actions/QueryItemUsageAction.cpp      |  172 ++
 .../strategy/actions/QueryItemUsageAction.h        |   24 +
 .../strategy/actions/QueryQuestAction.cpp          |   89 +
 .../playerbot/strategy/actions/QueryQuestAction.h  |   16 +
 .../playerbot/strategy/actions/QuestAction.cpp     |  137 +
 .../playerbot/strategy/actions/QuestAction.h       |   33 +
 .../strategy/actions/ReachTargetActions.h          |   57 +
 .../strategy/actions/ReadyCheckAction.cpp          |   84 +
 .../playerbot/strategy/actions/ReadyCheckAction.h  |   26 +
 .../strategy/actions/ReleaseSpiritAction.h         |   29 +
 .../strategy/actions/RememberTaxiAction.cpp        |   46 +
 .../strategy/actions/RememberTaxiAction.h          |   13 +
 .../playerbot/strategy/actions/RepairAllAction.cpp |   30 +
 .../playerbot/strategy/actions/RepairAllAction.h   |   13 +
 .../playerbot/strategy/actions/ResetAiAction.cpp   |   12 +
 .../playerbot/strategy/actions/ResetAiAction.h     |   14 +
 .../strategy/actions/ReviveFromCorpseAction.cpp    |   51 +
 .../strategy/actions/ReviveFromCorpseAction.h      |   21 +
 .../playerbot/strategy/actions/RewardAction.cpp    |   75 +
 .../playerbot/strategy/actions/RewardAction.h      |   17 +
 src/plugins/playerbot/strategy/actions/RtiAction.h |   44 +
 .../playerbot/strategy/actions/SaveManaAction.cpp  |   73 +
 .../playerbot/strategy/actions/SaveManaAction.h    |   20 +
 .../strategy/actions/SecurityCheckAction.cpp       |   31 +
 .../strategy/actions/SecurityCheckAction.h         |   14 +
 .../playerbot/strategy/actions/SellAction.cpp      |   95 +
 .../playerbot/strategy/actions/SellAction.h        |   18 +
 .../playerbot/strategy/actions/SetHomeAction.cpp   |   42 +
 .../playerbot/strategy/actions/SetHomeAction.h     |   12 +
 .../playerbot/strategy/actions/StatsAction.cpp     |  145 +
 .../playerbot/strategy/actions/StatsAction.h       |   22 +
 .../playerbot/strategy/actions/StayActions.cpp     |   34 +
 .../playerbot/strategy/actions/StayActions.h       |   23 +
 .../strategy/actions/SuggestWhatToDoAction.cpp     |  256 ++
 .../strategy/actions/SuggestWhatToDoAction.h       |   34 +
 .../strategy/actions/TalkToQuestGiverAction.cpp    |   90 +
 .../strategy/actions/TalkToQuestGiverAction.h      |   22 +
 .../playerbot/strategy/actions/TaxiAction.cpp      |   51 +
 .../playerbot/strategy/actions/TaxiAction.h        |   13 +
 .../playerbot/strategy/actions/TeleportAction.cpp  |   54 +
 .../playerbot/strategy/actions/TeleportAction.h    |   16 +
 .../strategy/actions/TellCastFailedAction.cpp      |   75 +
 .../strategy/actions/TellCastFailedAction.h        |   22 +
 .../strategy/actions/TellItemCountAction.cpp       |   16 +
 .../strategy/actions/TellItemCountAction.h         |   14 +
 .../playerbot/strategy/actions/TellLosAction.cpp   |   61 +
 .../playerbot/strategy/actions/TellLosAction.h     |   17 +
 .../playerbot/strategy/actions/TellMasterAction.h  |   38 +
 .../strategy/actions/TellReputationAction.cpp      |   68 +
 .../strategy/actions/TellReputationAction.h        |   16 +
 .../strategy/actions/TellTargetAction.cpp          |   53 +
 .../playerbot/strategy/actions/TellTargetAction.h  |   21 +
 .../playerbot/strategy/actions/TradeAction.cpp     |   83 +
 .../playerbot/strategy/actions/TradeAction.h       |   19 +
 .../strategy/actions/TradeStatusAction.cpp         |  216 ++
 .../playerbot/strategy/actions/TradeStatusAction.h |   20 +
 .../playerbot/strategy/actions/TrainerAction.cpp   |  114 +
 .../playerbot/strategy/actions/TrainerAction.h     |   22 +
 .../playerbot/strategy/actions/UnequipAction.cpp   |   45 +
 .../playerbot/strategy/actions/UnequipAction.h     |   18 +
 .../playerbot/strategy/actions/UseItemAction.cpp   |  302 +++
 .../playerbot/strategy/actions/UseItemAction.h     |   47 +
 .../strategy/actions/UseMeetingStoneAction.cpp     |   81 +
 .../strategy/actions/UseMeetingStoneAction.h       |   26 +
 .../playerbot/strategy/actions/WhoAction.cpp       |  160 ++
 src/plugins/playerbot/strategy/actions/WhoAction.h |   23 +
 .../strategy/actions/WorldPacketActionContext.h    |  108 +
 .../strategy/druid/BearTankDruidStrategy.cpp       |  171 ++
 .../strategy/druid/BearTankDruidStrategy.h         |   18 +
 .../strategy/druid/CasterDruidStrategy.cpp         |  177 ++
 .../playerbot/strategy/druid/CasterDruidStrategy.h |   39 +
 .../strategy/druid/CatDpsDruidStrategy.cpp         |  139 +
 .../playerbot/strategy/druid/CatDpsDruidStrategy.h |   29 +
 .../playerbot/strategy/druid/DruidActions.cpp      |   31 +
 .../playerbot/strategy/druid/DruidActions.h        |  205 ++
 .../strategy/druid/DruidAiObjectContext.cpp        |  258 ++
 .../strategy/druid/DruidAiObjectContext.h          |   12 +
 .../playerbot/strategy/druid/DruidBearActions.h    |   64 +
 .../playerbot/strategy/druid/DruidCatActions.h     |   69 +
 .../playerbot/strategy/druid/DruidMultipliers.cpp  |    6 +
 .../playerbot/strategy/druid/DruidMultipliers.h    |    6 +
 .../strategy/druid/DruidShapeshiftActions.h        |   53 +
 .../playerbot/strategy/druid/DruidTriggers.cpp     |    7 +
 .../playerbot/strategy/druid/DruidTriggers.h       |  127 +
 .../strategy/druid/FeralDruidStrategy.cpp          |   90 +
 .../playerbot/strategy/druid/FeralDruidStrategy.h  |   75 +
 .../druid/GenericDruidNonCombatStrategy.cpp        |   73 +
 .../strategy/druid/GenericDruidNonCombatStrategy.h |   16 +
 .../strategy/druid/GenericDruidStrategy.cpp        |  132 +
 .../strategy/druid/GenericDruidStrategy.h          |   18 +
 .../playerbot/strategy/druid/HealDruidStrategy.cpp |   57 +
 .../playerbot/strategy/druid/HealDruidStrategy.h   |   18 +
 .../generic/AttackEnemyPlayersStrategy.cpp         |   13 +
 .../strategy/generic/AttackEnemyPlayersStrategy.h  |   16 +
 .../strategy/generic/AttackRtiStrategy.cpp         |   14 +
 .../playerbot/strategy/generic/AttackRtiStrategy.h |   16 +
 .../strategy/generic/AttackWeakStrategy.cpp        |   13 +
 .../strategy/generic/AttackWeakStrategy.h          |   16 +
 .../strategy/generic/CastTimeStrategy.cpp          |   42 +
 .../playerbot/strategy/generic/CastTimeStrategy.h  |   26 +
 .../generic/ChatCommandHandlerStrategy.cpp         |  177 ++
 .../strategy/generic/ChatCommandHandlerStrategy.h  |   15 +
 .../playerbot/strategy/generic/CombatStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/CombatStrategy.h    |   13 +
 .../strategy/generic/ConserveManaStrategy.cpp      |   88 +
 .../strategy/generic/ConserveManaStrategy.h        |   32 +
 .../playerbot/strategy/generic/DeadStrategy.cpp    |   23 +
 .../playerbot/strategy/generic/DeadStrategy.h      |   15 +
 .../playerbot/strategy/generic/DpsAoeStrategy.cpp  |   12 +
 .../playerbot/strategy/generic/DpsAoeStrategy.h    |   18 +
 .../strategy/generic/DpsAssistStrategy.cpp         |   15 +
 .../playerbot/strategy/generic/DpsAssistStrategy.h |   16 +
 .../playerbot/strategy/generic/DuelStrategy.cpp    |   24 +
 .../playerbot/strategy/generic/DuelStrategy.h      |   15 +
 .../playerbot/strategy/generic/EmoteStrategy.cpp   |   17 +
 .../playerbot/strategy/generic/EmoteStrategy.h     |   16 +
 .../playerbot/strategy/generic/FleeStrategy.cpp    |   26 +
 .../playerbot/strategy/generic/FleeStrategy.h      |   21 +
 .../strategy/generic/FollowMasterStrategy.cpp      |   17 +
 .../strategy/generic/FollowMasterStrategy.h        |   16 +
 .../strategy/generic/GrindingStrategy.cpp          |   20 +
 .../playerbot/strategy/generic/GrindingStrategy.h  |   20 +
 .../playerbot/strategy/generic/GuardStrategy.cpp   |   16 +
 .../playerbot/strategy/generic/GuardStrategy.h     |   19 +
 .../playerbot/strategy/generic/KiteStrategy.cpp    |   16 +
 .../playerbot/strategy/generic/KiteStrategy.h      |   15 +
 .../strategy/generic/LootNonCombatStrategy.cpp     |   29 +
 .../strategy/generic/LootNonCombatStrategy.h       |   24 +
 .../strategy/generic/MeleeCombatStrategy.cpp       |   23 +
 .../strategy/generic/MeleeCombatStrategy.h         |   16 +
 .../strategy/generic/MoveRandomStrategy.cpp        |   13 +
 .../strategy/generic/MoveRandomStrategy.h          |   16 +
 .../strategy/generic/NonCombatStrategy.cpp         |   28 +
 .../playerbot/strategy/generic/NonCombatStrategy.h |   21 +
 .../strategy/generic/PassTroughStrategy.h          |   26 +
 .../playerbot/strategy/generic/PassiveStrategy.cpp |   13 +
 .../playerbot/strategy/generic/PassiveStrategy.h   |   16 +
 .../playerbot/strategy/generic/PullStrategy.cpp    |   52 +
 .../playerbot/strategy/generic/PullStrategy.h      |   24 +
 .../playerbot/strategy/generic/QuestStrategies.cpp |   69 +
 .../playerbot/strategy/generic/QuestStrategies.h   |   34 +
 .../playerbot/strategy/generic/RacialsStrategy.cpp |   39 +
 .../playerbot/strategy/generic/RacialsStrategy.h   |   15 +
 .../strategy/generic/RangedCombatStrategy.cpp      |   15 +
 .../strategy/generic/RangedCombatStrategy.h        |   15 +
 .../playerbot/strategy/generic/RunawayStrategy.cpp |   18 +
 .../playerbot/strategy/generic/RunawayStrategy.h   |   16 +
 .../playerbot/strategy/generic/StayStrategy.cpp    |   11 +
 .../playerbot/strategy/generic/StayStrategy.h      |   14 +
 .../playerbot/strategy/generic/TankAoeStrategy.cpp |   12 +
 .../playerbot/strategy/generic/TankAoeStrategy.h   |   18 +
 .../strategy/generic/TankAssistStrategy.cpp        |   13 +
 .../strategy/generic/TankAssistStrategy.h          |   17 +
 .../strategy/generic/TellTargetStrategy.cpp        |   13 +
 .../strategy/generic/TellTargetStrategy.h          |   16 +
 .../playerbot/strategy/generic/ThreatStrategy.cpp  |   32 +
 .../playerbot/strategy/generic/ThreatStrategy.h    |   25 +
 .../playerbot/strategy/generic/UseFoodStrategy.cpp |   18 +
 .../playerbot/strategy/generic/UseFoodStrategy.h   |   15 +
 .../strategy/generic/UsePotionsStrategy.cpp        |   18 +
 .../strategy/generic/UsePotionsStrategy.h          |   15 +
 .../generic/WorldPacketHandlerStrategy.cpp         |  107 +
 .../strategy/generic/WorldPacketHandlerStrategy.h  |   25 +
 .../strategy/hunter/DpsHunterStrategy.cpp          |  118 +
 .../playerbot/strategy/hunter/DpsHunterStrategy.h  |   39 +
 .../hunter/GenericHunterNonCombatStrategy.cpp      |   58 +
 .../hunter/GenericHunterNonCombatStrategy.h        |   17 +
 .../strategy/hunter/GenericHunterStrategy.cpp      |   66 +
 .../strategy/hunter/GenericHunterStrategy.h        |   20 +
 .../playerbot/strategy/hunter/HunterActions.cpp    |   26 +
 .../playerbot/strategy/hunter/HunterActions.h      |  154 ++
 .../strategy/hunter/HunterAiObjectContext.cpp      |  191 ++
 .../strategy/hunter/HunterAiObjectContext.h        |   12 +
 .../strategy/hunter/HunterBuffStrategies.cpp       |   35 +
 .../strategy/hunter/HunterBuffStrategies.h         |   47 +
 .../strategy/hunter/HunterMultipliers.cpp          |    5 +
 .../playerbot/strategy/hunter/HunterMultipliers.h  |    6 +
 .../playerbot/strategy/hunter/HunterTriggers.cpp   |   29 +
 .../playerbot/strategy/hunter/HunterTriggers.h     |   86 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.cpp |   64 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.h   |   18 +
 .../playerbot/strategy/mage/FireMageStrategy.cpp   |   44 +
 .../playerbot/strategy/mage/FireMageStrategy.h     |   28 +
 .../playerbot/strategy/mage/FrostMageStrategy.cpp  |   32 +
 .../playerbot/strategy/mage/FrostMageStrategy.h    |   28 +
 .../strategy/mage/GenericMageNonCombatStrategy.cpp |   87 +
 .../strategy/mage/GenericMageNonCombatStrategy.h   |   37 +
 .../strategy/mage/GenericMageStrategy.cpp          |  137 +
 .../playerbot/strategy/mage/GenericMageStrategy.h  |   17 +
 .../playerbot/strategy/mage/MageActions.cpp        |   10 +
 src/plugins/playerbot/strategy/mage/MageActions.h  |  205 ++
 .../strategy/mage/MageAiObjectContext.cpp          |  221 ++
 .../playerbot/strategy/mage/MageAiObjectContext.h  |   12 +
 .../playerbot/strategy/mage/MageMultipliers.cpp    |    6 +
 .../playerbot/strategy/mage/MageMultipliers.h      |    6 +
 .../playerbot/strategy/mage/MageTriggers.cpp       |   15 +
 src/plugins/playerbot/strategy/mage/MageTriggers.h |   92 +
 .../strategy/paladin/DpsPaladinStrategy.cpp        |   83 +
 .../strategy/paladin/DpsPaladinStrategy.h          |   18 +
 .../paladin/GenericPaladinNonCombatStrategy.cpp    |   65 +
 .../paladin/GenericPaladinNonCombatStrategy.h      |   16 +
 .../strategy/paladin/GenericPaladinStrategy.cpp    |   77 +
 .../strategy/paladin/GenericPaladinStrategy.h      |   18 +
 .../GenericPaladinStrategyActionNodeFactory.h      |  142 +
 .../playerbot/strategy/paladin/PaladinActions.cpp  |    6 +
 .../playerbot/strategy/paladin/PaladinActions.h    |  365 +++
 .../strategy/paladin/PaladinAiObjectContext.cpp    |  279 ++
 .../strategy/paladin/PaladinAiObjectContext.h      |   12 +
 .../strategy/paladin/PaladinBuffStrategies.cpp     |   72 +
 .../strategy/paladin/PaladinBuffStrategies.h       |   86 +
 .../strategy/paladin/PaladinMultipliers.cpp        |    6 +
 .../strategy/paladin/PaladinMultipliers.h          |    6 +
 .../playerbot/strategy/paladin/PaladinTriggers.cpp |   23 +
 .../playerbot/strategy/paladin/PaladinTriggers.h   |  114 +
 .../strategy/paladin/TankPaladinStrategy.cpp       |   70 +
 .../strategy/paladin/TankPaladinStrategy.h         |   18 +
 .../strategy/priest/GenericPriestStrategy.cpp      |   67 +
 .../strategy/priest/GenericPriestStrategy.h        |   17 +
 .../GenericPriestStrategyActionNodeFactory.h       |  173 ++
 .../strategy/priest/HealPriestStrategy.cpp         |   36 +
 .../playerbot/strategy/priest/HealPriestStrategy.h |   18 +
 .../strategy/priest/HolyPriestStrategy.cpp         |   46 +
 .../playerbot/strategy/priest/HolyPriestStrategy.h |   18 +
 .../playerbot/strategy/priest/PriestActions.cpp    |   17 +
 .../playerbot/strategy/priest/PriestActions.h      |  246 ++
 .../strategy/priest/PriestAiObjectContext.cpp      |  217 ++
 .../strategy/priest/PriestAiObjectContext.h        |   12 +
 .../strategy/priest/PriestMultipliers.cpp          |    6 +
 .../playerbot/strategy/priest/PriestMultipliers.h  |    6 +
 .../strategy/priest/PriestNonCombatStrategy.cpp    |   82 +
 .../strategy/priest/PriestNonCombatStrategy.h      |   17 +
 .../PriestNonCombatStrategyActionNodeFactory.h     |  126 +
 .../playerbot/strategy/priest/PriestTriggers.cpp   |    7 +
 .../playerbot/strategy/priest/PriestTriggers.h     |   54 +
 .../strategy/priest/ShadowPriestStrategy.cpp       |   60 +
 .../strategy/priest/ShadowPriestStrategy.h         |   38 +
 .../priest/ShadowPriestStrategyActionNodeFactory.h |   37 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.cpp  |  110 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.h    |   18 +
 .../rogue/GenericRogueNonCombatStrategy.cpp        |   14 +
 .../strategy/rogue/GenericRogueNonCombatStrategy.h |   16 +
 .../playerbot/strategy/rogue/RogueActions.cpp      |    5 +
 .../playerbot/strategy/rogue/RogueActions.h        |   82 +
 .../strategy/rogue/RogueAiObjectContext.cpp        |  119 +
 .../strategy/rogue/RogueAiObjectContext.h          |   12 +
 .../playerbot/strategy/rogue/RogueComboActions.h   |   45 +
 .../strategy/rogue/RogueFinishingActions.h         |   35 +
 .../playerbot/strategy/rogue/RogueMultipliers.cpp  |    6 +
 .../playerbot/strategy/rogue/RogueMultipliers.h    |    6 +
 .../playerbot/strategy/rogue/RogueOpeningActions.h |   24 +
 .../playerbot/strategy/rogue/RogueTriggers.cpp     |    7 +
 .../playerbot/strategy/rogue/RogueTriggers.h       |   36 +
 .../strategy/shaman/CasterShamanStrategy.cpp       |   75 +
 .../strategy/shaman/CasterShamanStrategy.h         |   29 +
 .../strategy/shaman/GenericShamanStrategy.cpp      |  159 ++
 .../strategy/shaman/GenericShamanStrategy.h        |   39 +
 .../strategy/shaman/HealShamanStrategy.cpp         |   82 +
 .../playerbot/strategy/shaman/HealShamanStrategy.h |   17 +
 .../strategy/shaman/MeleeShamanStrategy.cpp        |   93 +
 .../strategy/shaman/MeleeShamanStrategy.h          |   28 +
 .../playerbot/strategy/shaman/ShamanActions.cpp    |    6 +
 .../playerbot/strategy/shaman/ShamanActions.h      |  304 +++
 .../strategy/shaman/ShamanAiObjectContext.cpp      |  268 ++
 .../strategy/shaman/ShamanAiObjectContext.h        |   12 +
 .../strategy/shaman/ShamanMultipliers.cpp          |    6 +
 .../playerbot/strategy/shaman/ShamanMultipliers.h  |    6 +
 .../strategy/shaman/ShamanNonCombatStrategy.cpp    |   49 +
 .../strategy/shaman/ShamanNonCombatStrategy.h      |   19 +
 .../playerbot/strategy/shaman/ShamanTriggers.cpp   |   38 +
 .../playerbot/strategy/shaman/ShamanTriggers.h     |  197 ++
 .../strategy/shaman/TotemsShamanStrategy.cpp       |   31 +
 .../strategy/shaman/TotemsShamanStrategy.h         |   17 +
 .../strategy/triggers/ChatCommandTrigger.h         |   36 +
 .../strategy/triggers/ChatTriggerContext.h         |  140 +
 .../playerbot/strategy/triggers/CureTriggers.cpp   |   17 +
 .../playerbot/strategy/triggers/CureTriggers.h     |   35 +
 .../strategy/triggers/GenericTriggers.cpp          |  245 ++
 .../playerbot/strategy/triggers/GenericTriggers.h  |  540 ++++
 .../playerbot/strategy/triggers/HealthTriggers.cpp |   26 +
 .../playerbot/strategy/triggers/HealthTriggers.h   |  139 +
 .../playerbot/strategy/triggers/LfgTriggers.h      |   17 +
 .../playerbot/strategy/triggers/LootTriggers.cpp   |   20 +
 .../playerbot/strategy/triggers/LootTriggers.h     |   30 +
 .../playerbot/strategy/triggers/RangeTriggers.h    |   81 +
 .../playerbot/strategy/triggers/TriggerContext.h   |  158 ++
 .../strategy/triggers/WithinAreaTrigger.h          |   76 +
 .../strategy/triggers/WorldPacketTrigger.h         |   36 +
 .../strategy/triggers/WorldPacketTriggerContext.h  |   85 +
 .../strategy/values/AlwaysLootListValue.h          |   14 +
 .../playerbot/strategy/values/AoeHealValues.cpp    |   37 +
 .../playerbot/strategy/values/AoeHealValues.h      |   14 +
 .../strategy/values/AttackerCountValues.cpp        |  107 +
 .../strategy/values/AttackerCountValues.h          |   59 +
 .../values/AttackerWithoutAuraTargetValue.cpp      |   26 +
 .../values/AttackerWithoutAuraTargetValue.h        |   15 +
 .../playerbot/strategy/values/AttackersValue.cpp   |   94 +
 .../playerbot/strategy/values/AttackersValue.h     |   20 +
 .../playerbot/strategy/values/AvailableLootValue.h |   40 +
 .../playerbot/strategy/values/CcTargetValue.cpp    |   88 +
 .../playerbot/strategy/values/CcTargetValue.h      |   16 +
 src/plugins/playerbot/strategy/values/ChatValue.h  |   11 +
 .../strategy/values/CurrentCcTargetValue.cpp       |   31 +
 .../strategy/values/CurrentCcTargetValue.h         |   16 +
 .../strategy/values/CurrentTargetValue.cpp         |   22 +
 .../playerbot/strategy/values/CurrentTargetValue.h |   17 +
 .../playerbot/strategy/values/DistanceValue.h      |   35 +
 .../playerbot/strategy/values/DpsTargetValue.cpp   |   45 +
 .../playerbot/strategy/values/DpsTargetValue.h     |   16 +
 .../playerbot/strategy/values/DuelTargetValue.cpp  |   10 +
 .../playerbot/strategy/values/DuelTargetValue.h    |   15 +
 .../strategy/values/EnemyHealerTargetValue.cpp     |   36 +
 .../strategy/values/EnemyHealerTargetValue.h       |   15 +
 .../playerbot/strategy/values/EnemyPlayerValue.cpp |   34 +
 .../playerbot/strategy/values/EnemyPlayerValue.h   |   15 +
 .../playerbot/strategy/values/Formations.cpp       |  346 +++
 src/plugins/playerbot/strategy/values/Formations.h |   52 +
 .../playerbot/strategy/values/GrindTargetValue.cpp |  126 +
 .../playerbot/strategy/values/GrindTargetValue.h   |   20 +
 .../strategy/values/HasAvailableLootValue.h        |   20 +
 .../playerbot/strategy/values/HasTotemValue.h      |   34 +
 .../strategy/values/InvalidTargetValue.cpp         |   26 +
 .../playerbot/strategy/values/InvalidTargetValue.h |   14 +
 .../playerbot/strategy/values/IsBehindValue.h      |   25 +
 .../playerbot/strategy/values/IsFacingValue.h      |   20 +
 .../playerbot/strategy/values/IsMovingValue.h      |   42 +
 .../playerbot/strategy/values/ItemCountValue.cpp   |   37 +
 .../playerbot/strategy/values/ItemCountValue.h     |   35 +
 .../strategy/values/ItemForSpellValue.cpp          |   70 +
 .../playerbot/strategy/values/ItemForSpellValue.h  |   20 +
 .../playerbot/strategy/values/ItemUsageValue.cpp   |  146 +
 .../playerbot/strategy/values/ItemUsageValue.h     |   28 +
 .../playerbot/strategy/values/LastMovementValue.h  |   61 +
 .../strategy/values/LastSpellCastTimeValue.h       |   11 +
 .../playerbot/strategy/values/LastSpellCastValue.h |   39 +
 .../strategy/values/LeastHpTargetValue.cpp         |   33 +
 .../playerbot/strategy/values/LeastHpTargetValue.h |   15 +
 src/plugins/playerbot/strategy/values/LfgValues.h  |   12 +
 .../playerbot/strategy/values/LineTargetValue.cpp  |   33 +
 .../playerbot/strategy/values/LineTargetValue.h    |   14 +
 .../playerbot/strategy/values/LogLevelValue.h      |   12 +
 .../playerbot/strategy/values/LootStrategyValue.h  |   11 +
 .../playerbot/strategy/values/ManaSaveLevelValue.h |   11 +
 .../playerbot/strategy/values/MasterTargetValue.h  |   13 +
 .../playerbot/strategy/values/NearestAdsValue.cpp  |   11 +
 .../playerbot/strategy/values/NearestAdsValue.h    |   18 +
 .../strategy/values/NearestCorpsesValue.cpp        |   36 +
 .../strategy/values/NearestCorpsesValue.h          |   19 +
 .../strategy/values/NearestGameObjects.cpp         |   47 +
 .../playerbot/strategy/values/NearestGameObjects.h |   19 +
 .../playerbot/strategy/values/NearestNpcsValue.cpp |   23 +
 .../playerbot/strategy/values/NearestNpcsValue.h   |   18 +
 .../playerbot/strategy/values/NearestUnitsValue.h  |   36 +
 .../strategy/values/PartyMemberToDispel.cpp        |   37 +
 .../strategy/values/PartyMemberToDispel.h          |   16 +
 .../strategy/values/PartyMemberToHeal.cpp          |   60 +
 .../playerbot/strategy/values/PartyMemberToHeal.h  |   17 +
 .../strategy/values/PartyMemberToResurrect.cpp     |   44 +
 .../strategy/values/PartyMemberToResurrect.h       |   16 +
 .../playerbot/strategy/values/PartyMemberValue.cpp |  111 +
 .../playerbot/strategy/values/PartyMemberValue.h   |   31 +
 .../values/PartyMemberWithoutAuraValue.cpp         |   35 +
 .../strategy/values/PartyMemberWithoutAuraValue.h  |   17 +
 .../playerbot/strategy/values/PetTargetValue.h     |   13 +
 .../playerbot/strategy/values/PositionValue.cpp    |   10 +
 .../playerbot/strategy/values/PositionValue.h      |   26 +
 .../strategy/values/PossibleTargetsValue.cpp       |   23 +
 .../strategy/values/PossibleTargetsValue.h         |   19 +
 .../playerbot/strategy/values/RtiTargetValue.h     |   51 +
 src/plugins/playerbot/strategy/values/RtiValue.cpp |   36 +
 src/plugins/playerbot/strategy/values/RtiValue.h   |   11 +
 .../playerbot/strategy/values/SelfTargetValue.h    |   13 +
 .../strategy/values/SpellCastUsefulValue.cpp       |   44 +
 .../strategy/values/SpellCastUsefulValue.h         |   17 +
 .../playerbot/strategy/values/SpellIdValue.cpp     |   90 +
 .../playerbot/strategy/values/SpellIdValue.h       |   17 +
 .../playerbot/strategy/values/StatsValues.cpp      |  111 +
 .../playerbot/strategy/values/StatsValues.h        |  133 +
 .../playerbot/strategy/values/TankTargetValue.cpp  |   47 +
 .../playerbot/strategy/values/TankTargetValue.h    |   16 +
 .../playerbot/strategy/values/TargetValue.cpp      |   54 +
 .../playerbot/strategy/values/TargetValue.h        |   39 +
 .../playerbot/strategy/values/ThreatValues.cpp     |   62 +
 .../playerbot/strategy/values/ThreatValues.h       |   17 +
 .../playerbot/strategy/values/ValueContext.h       |  225 ++
 .../playerbot/strategy/values/formations/Arrow.cpp |  162 ++
 .../playerbot/strategy/values/formations/Arrow.h   |  109 +
 .../strategy/warlock/DpsWarlockStrategy.cpp        |   76 +
 .../strategy/warlock/DpsWarlockStrategy.h          |   39 +
 .../warlock/GenericWarlockNonCombatStrategy.cpp    |   65 +
 .../warlock/GenericWarlockNonCombatStrategy.h      |   16 +
 .../strategy/warlock/GenericWarlockStrategy.cpp    |   74 +
 .../strategy/warlock/GenericWarlockStrategy.h      |   18 +
 .../strategy/warlock/TankWarlockStrategy.cpp       |   51 +
 .../strategy/warlock/TankWarlockStrategy.h         |   17 +
 .../playerbot/strategy/warlock/WarlockActions.cpp  |    5 +
 .../playerbot/strategy/warlock/WarlockActions.h    |  176 ++
 .../strategy/warlock/WarlockAiObjectContext.cpp    |  183 ++
 .../strategy/warlock/WarlockAiObjectContext.h      |   12 +
 .../strategy/warlock/WarlockMultipliers.cpp        |    6 +
 .../strategy/warlock/WarlockMultipliers.h          |    6 +
 .../playerbot/strategy/warlock/WarlockTriggers.cpp |   19 +
 .../playerbot/strategy/warlock/WarlockTriggers.h   |   81 +
 .../strategy/warrior/DpsWarriorStrategy.cpp        |  130 +
 .../strategy/warrior/DpsWarriorStrategy.h          |   28 +
 .../warrior/GenericWarriorNonCombatStrategy.cpp    |    7 +
 .../warrior/GenericWarriorNonCombatStrategy.h      |   13 +
 .../strategy/warrior/GenericWarriorStrategy.cpp    |   73 +
 .../strategy/warrior/GenericWarriorStrategy.h      |   19 +
 .../strategy/warrior/TankWarriorStrategy.cpp       |  126 +
 .../strategy/warrior/TankWarriorStrategy.h         |   18 +
 .../playerbot/strategy/warrior/WarriorActions.cpp  |   30 +
 .../playerbot/strategy/warrior/WarriorActions.h    |  210 ++
 .../strategy/warrior/WarriorAiObjectContext.cpp    |  192 ++
 .../strategy/warrior/WarriorAiObjectContext.h      |   12 +
 .../strategy/warrior/WarriorMultipliers.cpp        |    6 +
 .../strategy/warrior/WarriorMultipliers.h          |    6 +
 .../playerbot/strategy/warrior/WarriorTriggers.cpp |    7 +
 .../playerbot/strategy/warrior/WarriorTriggers.h   |   78 +
 src/server/database/Database/DatabaseWorkerPool.h  |    4 +
 src/server/database/Database/Field.h               |    4 +
 src/server/database/Database/MySQLConnection.cpp   |    4 +
 src/server/database/Database/QueryResult.h         |    4 +
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |    8 +
 src/server/game/CMakeLists.txt                     |    1 +
 src/server/game/Chat/Chat.cpp                      |    3 +-
 src/server/game/DungeonFinding/LFGQueue.cpp        |   19 +
 src/server/game/Entities/Player/Player.cpp         |   22 +-
 src/server/game/Entities/Player/Player.h           |   20 +-
 src/server/game/Groups/Group.h                     |    5 +
 src/server/game/Handlers/CharacterHandler.cpp      |   81 +
 src/server/game/Handlers/ChatHandler.cpp           |   87 +-
 src/server/game/Server/WorldSession.cpp            |   42 +-
 src/server/game/Server/WorldSession.h              |    7 +-
 src/server/game/World/World.cpp                    |   32 +-
 src/server/scripts/Commands/cs_ahbot.cpp           |    3 +-
 src/server/scripts/Commands/cs_misc.cpp            |    9 +
 src/server/worldserver/CMakeLists.txt              |    1 +
 src/test/AcceptAllQuestStrategyTestCase.cpp        |   68 +
 src/test/AiObjectContextWrapper.h                  |  287 ++
 src/test/ArcaneMageTestCase.cpp                    |   48 +
 src/test/BearTankDruidTestCase.cpp                 |  215 ++
 src/test/CMakeLists.txt                            |  163 ++
 src/test/CasterDruidTestCase.cpp                   |  166 ++
 src/test/CasterShamanTestCase.cpp                  |   86 +
 src/test/CatDpsDruidTestCase.cpp                   |  133 +
 src/test/ChatCommandTestCase.cpp                   |  454 ++++
 src/test/ChatFilterTestCase.cpp                    |   32 +
 src/test/DpsHunterEngineTestCase.cpp               |  160 ++
 src/test/DpsPaladinTestCase.cpp                    |   73 +
 src/test/DpsPriestTestCase.cpp                     |   88 +
 src/test/DpsRogueTestCase.cpp                      |   74 +
 src/test/DpsWarlockTestCase.cpp                    |   93 +
 src/test/DpsWarriorTestCase.cpp                    |  127 +
 src/test/DruidNonCombatTestCase.cpp                |   70 +
 src/test/DuelTestCase.cpp                          |   44 +
 src/test/EngineTestBase.cpp                        |  479 ++++
 src/test/EngineTestBase.h                          |   88 +
 src/test/EngineTestCase.cpp                        |  321 +++
 src/test/EventTestCase.cpp                         |   59 +
 src/test/EverythingUnavailableAiManagerRegistry.h  |   15 +
 src/test/ExternalEventHelperTestCase.cpp           |   81 +
 src/test/FireMageTestCase.cpp                      |  103 +
 src/test/FrostMageTestCase.cpp                     |  138 +
 src/test/GenericTestCase.cpp                       |  139 +
 src/test/HealDruidTestCase.cpp                     |   91 +
 src/test/HealPriestTestCase.cpp                    |  195 ++
 src/test/HealShamanTestCase.cpp                    |  136 +
 src/test/HolyPriestTestCase.cpp                    |   56 +
 src/test/HunterNonCombatTestCase.cpp               |   75 +
 src/test/KiteTestCase.cpp                          |   39 +
 src/test/LootObjectStackTestCase.cpp               |   52 +
 src/test/MageNonCombatTestCase.cpp                 |   87 +
 src/test/MeleeShamanTestCase.cpp                   |  103 +
 src/test/MockAiObjectContext.cpp                   |  114 +
 src/test/MockAiObjectContext.h                     |   31 +
 src/test/MockPlayerbotAIBase.cpp                   |   79 +
 src/test/MockPlayerbotAIBase.h                     |   41 +
 src/test/MockedAiObjectContextTestCase.h           |   54 +
 src/test/MockedTargets.h                           |   65 +
 src/test/NextActionTestCase.cpp                    |   82 +
 src/test/NonCombatEngineTestCase.cpp               |  300 +++
 src/test/NonCombatEngineTestCase2.cpp              |   42 +
 src/test/PaladinNonCombatTestCase.cpp              |   97 +
 src/test/PerformanceTestCase.cpp                   |  177 ++
 src/test/PriestNonCombatTestCase.cpp               |  112 +
 src/test/QualifiedValueTestCase.cpp                |   84 +
 src/test/QuestStrategyTestCase.cpp                 |   73 +
 src/test/QueueTestCase.cpp                         |   40 +
 src/test/RacialsTestCase.cpp                       |   41 +
 src/test/RandomItemMgrTestCase.cpp                 |   84 +
 src/test/ShamanNonCombatTestCase.cpp               |   69 +
 src/test/TankPaladinTestCase.cpp                   |  224 ++
 src/test/TankWarlockTestCase.cpp                   |   51 +
 src/test/TankWarriorTestCase.cpp                   |  168 ++
 src/test/ValueTestCase.cpp                         |  121 +
 src/test/WarlockNonCombatTestCase.cpp              |   50 +
 src/test/WarrirorNonCombatTestCase.cpp             |   40 +
 src/test/WorldPacketHandlerTestCase.cpp            |  278 ++
 src/test/aitest.h                                  |   14 +
 src/test/cppunit/AdditionalMessage.cpp             |   41 +
 src/test/cppunit/AdditionalMessage.h               |   76 +
 src/test/cppunit/Asserter.cpp                      |  101 +
 src/test/cppunit/Asserter.h                        |  143 +
 src/test/cppunit/BeOsDynamicLibraryManager.cpp     |   49 +
 src/test/cppunit/BriefTestProgressListener.cpp     |   49 +
 src/test/cppunit/BriefTestProgressListener.h       |   43 +
 src/test/cppunit/CompilerOutputter.cpp             |  216 ++
 src/test/cppunit/CompilerOutputter.h               |  146 +
 src/test/cppunit/DefaultProtector.cpp              |   42 +
 src/test/cppunit/DefaultProtector.h                |   27 +
 src/test/cppunit/DllMain.cpp                       |   16 +
 src/test/cppunit/DynamicLibraryManager.cpp         |   77 +
 .../cppunit/DynamicLibraryManagerException.cpp     |   41 +
 src/test/cppunit/Exception.cpp                     |  126 +
 src/test/cppunit/Exception.h                       |   90 +
 src/test/cppunit/Makefile.am                       |   67 +
 src/test/cppunit/Makefile.in                       |  632 +++++
 src/test/cppunit/Message.cpp                       |  170 ++
 src/test/cppunit/Message.h                         |  156 ++
 src/test/cppunit/Outputter.h                       |   26 +
 src/test/cppunit/PlugInManager.cpp                 |  110 +
 src/test/cppunit/PlugInParameters.cpp              |   28 +
 src/test/cppunit/Portability.h                     |  177 ++
 src/test/cppunit/Protector.cpp                     |   86 +
 src/test/cppunit/Protector.h                       |   94 +
 src/test/cppunit/ProtectorChain.cpp                |   86 +
 src/test/cppunit/ProtectorChain.h                  |   51 +
 src/test/cppunit/ProtectorContext.h                |   38 +
 src/test/cppunit/RepeatedTest.cpp                  |   29 +
 src/test/cppunit/ShlDynamicLibraryManager.cpp      |   53 +
 src/test/cppunit/SourceLine.cpp                    |   81 +
 src/test/cppunit/SourceLine.h                      |   63 +
 src/test/cppunit/StringTools.cpp                   |   80 +
 src/test/cppunit/SynchronizedObject.cpp            |   32 +
 src/test/cppunit/SynchronizedObject.h              |   80 +
 src/test/cppunit/Test.cpp                          |   97 +
 src/test/cppunit/Test.h                            |  117 +
 src/test/cppunit/TestAssert.cpp                    |   46 +
 src/test/cppunit/TestAssert.h                      |  428 +++
 src/test/cppunit/TestCaller.h                      |  204 ++
 src/test/cppunit/TestCase.cpp                      |  137 +
 src/test/cppunit/TestCase.h                        |   55 +
 src/test/cppunit/TestCaseDecorator.cpp             |   47 +
 src/test/cppunit/TestComposite.cpp                 |   77 +
 src/test/cppunit/TestComposite.h                   |   45 +
 src/test/cppunit/TestDecorator.cpp                 |   53 +
 src/test/cppunit/TestFactoryRegistry.cpp           |  161 ++
 src/test/cppunit/TestFailure.cpp                   |   71 +
 src/test/cppunit/TestFailure.h                     |   58 +
 src/test/cppunit/TestFixture.h                     |   99 +
 src/test/cppunit/TestLeaf.cpp                      |   28 +
 src/test/cppunit/TestLeaf.h                        |   44 +
 src/test/cppunit/TestListener.h                    |  148 +
 src/test/cppunit/TestNamer.cpp                     |   44 +
 src/test/cppunit/TestPath.cpp                      |  254 ++
 src/test/cppunit/TestPath.h                        |  211 ++
 src/test/cppunit/TestPlugInDefaultImpl.cpp         |   63 +
 src/test/cppunit/TestResult.cpp                    |  196 ++
 src/test/cppunit/TestResult.h                      |  156 ++
 src/test/cppunit/TestResultCollector.cpp           |  117 +
 src/test/cppunit/TestResultCollector.h             |   87 +
 src/test/cppunit/TestRunner.cpp                    |  101 +
 src/test/cppunit/TestRunner.h                      |  135 +
 src/test/cppunit/TestSetUp.cpp                     |   32 +
 src/test/cppunit/TestSuccessListener.cpp           |   44 +
 src/test/cppunit/TestSuccessListener.h             |   39 +
 src/test/cppunit/TestSuite.cpp                     |   64 +
 src/test/cppunit/TestSuite.h                       |   80 +
 src/test/cppunit/TestSuiteBuilderContext.cpp       |   85 +
 src/test/cppunit/TextOutputter.cpp                 |  140 +
 src/test/cppunit/TextOutputter.h                   |   59 +
 src/test/cppunit/TextTestProgressListener.cpp      |   43 +
 src/test/cppunit/TextTestProgressListener.h        |   44 +
 src/test/cppunit/TextTestResult.cpp                |   50 +
 src/test/cppunit/TextTestResult.h                  |   39 +
 src/test/cppunit/TextTestRunner.cpp                |  144 +
 src/test/cppunit/TextTestRunner.h                  |    6 +
 src/test/cppunit/TypeInfoHelper.cpp                |   53 +
 src/test/cppunit/UnixDynamicLibraryManager.cpp     |   44 +
 src/test/cppunit/Win32DynamicLibraryManager.cpp    |   73 +
 src/test/cppunit/XmlDocument.cpp                   |  106 +
 src/test/cppunit/XmlElement.cpp                    |  226 ++
 src/test/cppunit/XmlOutputter.cpp                  |  205 ++
 src/test/cppunit/XmlOutputter.h                    |  167 ++
 src/test/cppunit/XmlOutputterHook.cpp              |   44 +
 src/test/cppunit/XmlOutputterHook.h                |  163 ++
 src/test/cppunit/config/CppUnitApi.h               |   33 +
 src/test/cppunit/config/Makefile.am                |   10 +
 src/test/cppunit/config/Makefile.in                |  438 +++
 src/test/cppunit/config/SelectDllLoader.h          |   76 +
 src/test/cppunit/config/SourcePrefix.h             |   14 +
 src/test/cppunit/config/config-bcb5.h              |   47 +
 src/test/cppunit/config/config-evc4.h              |   78 +
 src/test/cppunit/config/config-mac.h               |   58 +
 src/test/cppunit/config/config-msvc6.h             |   83 +
 src/test/cppunit/cppunit.dsp                       |  707 +++++
 src/test/cppunit/cppunit_dll.dsp                   |  682 +++++
 src/test/cppunit/extensions/AutoRegisterSuite.h    |   83 +
 .../extensions/ExceptionTestCaseDecorator.h        |  104 +
 src/test/cppunit/extensions/HelperMacros.h         |  541 ++++
 src/test/cppunit/extensions/Makefile.am            |   19 +
 src/test/cppunit/extensions/Makefile.in            |  446 ++++
 src/test/cppunit/extensions/Orthodox.h             |   95 +
 src/test/cppunit/extensions/RepeatedTest.h         |   43 +
 src/test/cppunit/extensions/TestCaseDecorator.h    |   40 +
 src/test/cppunit/extensions/TestDecorator.h        |   49 +
 src/test/cppunit/extensions/TestFactory.h          |   27 +
 src/test/cppunit/extensions/TestFactoryRegistry.h  |  182 ++
 src/test/cppunit/extensions/TestFixtureFactory.h   |   50 +
 src/test/cppunit/extensions/TestNamer.h            |   89 +
 src/test/cppunit/extensions/TestSetUp.h            |   34 +
 .../cppunit/extensions/TestSuiteBuilderContext.h   |  131 +
 src/test/cppunit/extensions/TestSuiteFactory.h     |   27 +
 src/test/cppunit/extensions/TypeInfoHelper.h       |   33 +
 src/test/cppunit/plugin/DynamicLibraryManager.h    |  121 +
 .../plugin/DynamicLibraryManagerException.h        |   53 +
 src/test/cppunit/plugin/Makefile.am                |    9 +
 src/test/cppunit/plugin/Makefile.in                |  437 +++
 src/test/cppunit/plugin/PlugInManager.h            |  113 +
 src/test/cppunit/plugin/PlugInParameters.h         |   36 +
 src/test/cppunit/plugin/TestPlugIn.h               |  200 ++
 src/test/cppunit/plugin/TestPlugInDefaultImpl.h    |   52 +
 src/test/cppunit/portability/CppUnitDeque.h        |   25 +
 src/test/cppunit/portability/CppUnitMap.h          |   29 +
 src/test/cppunit/portability/CppUnitSet.h          |   28 +
 src/test/cppunit/portability/CppUnitStack.h        |   26 +
 src/test/cppunit/portability/CppUnitVector.h       |   25 +
 src/test/cppunit/portability/FloatingPoint.h       |   54 +
 src/test/cppunit/portability/Makefile.am           |   10 +
 src/test/cppunit/portability/Makefile.in           |  438 +++
 src/test/cppunit/portability/Stream.h              |  347 +++
 src/test/cppunit/tools/Algorithm.h                 |   23 +
 src/test/cppunit/tools/Makefile.am                 |    7 +
 src/test/cppunit/tools/Makefile.in                 |  435 +++
 src/test/cppunit/tools/StringTools.h               |   34 +
 src/test/cppunit/tools/XmlDocument.h               |   86 +
 src/test/cppunit/tools/XmlElement.h                |  149 ++
 src/test/cppunit/ui/Makefile.am                    |    1 +
 src/test/cppunit/ui/Makefile.in                    |  511 ++++
 src/test/cppunit/ui/mfc/Makefile.am                |    5 +
 src/test/cppunit/ui/mfc/Makefile.in                |  433 +++
 src/test/cppunit/ui/mfc/MfcTestRunner.h            |   76 +
 src/test/cppunit/ui/mfc/TestRunner.h               |   21 +
 src/test/cppunit/ui/qt/Config.h                    |   21 +
 src/test/cppunit/ui/qt/Makefile.am                 |    6 +
 src/test/cppunit/ui/qt/Makefile.in                 |  434 +++
 src/test/cppunit/ui/qt/QtTestRunner.h              |   85 +
 src/test/cppunit/ui/qt/TestRunner.h                |   11 +
 src/test/cppunit/ui/text/Makefile.am               |    5 +
 src/test/cppunit/ui/text/Makefile.in               |  433 +++
 src/test/cppunit/ui/text/TestRunner.h              |   24 +
 src/test/cppunit/ui/text/TextTestRunner.h          |   97 +
 src/test/efficiency/AbstractEfficiencyTestCase.h   |   40 +
 src/test/efficiency/DruidEfficiencyTestCase.cpp    |   39 +
 .../EfficiencyActionExecutionListener.cpp          |   88 +
 .../efficiency/EfficiencyActionExecutionListener.h |   52 +
 src/test/efficiency/MageEfficiencyTestCase.cpp     |   55 +
 src/test/efficiency/PriestEfficiencyTestCase.cpp   |   43 +
 src/test/efficiency/ShamanEfficiencyTestCase.cpp   |   46 +
 src/test/efficiency/WarlockEfficiencyTestCase.cpp  |   43 +
 src/test/main.cpp                                  |   94 +
 src/test/pch.cpp                                   |    1 +
 src/test/pch.h                                     |   39 +
 839 files changed, 68931 insertions(+), 14 deletions(-)
 create mode 100644 sql/ai_playerbot_guild_names.sql
 create mode 100644 sql/characters_ai_playerbot.sql
 create mode 100644 sql/characters_ai_playerbot_names.zip
 create mode 100644 sql/characters_ai_playerbot_real_names.zip
 create mode 100644 sql/characters_auctionhousebot.sql
 create mode 100644 src/plugins/CMakeLists.txt
 create mode 100644 src/plugins/ahbot/AhBot.cpp
 create mode 100644 src/plugins/ahbot/AhBot.h
 create mode 100644 src/plugins/ahbot/AhBotConfig.cpp
 create mode 100644 src/plugins/ahbot/AhBotConfig.h
 create mode 100644 src/plugins/ahbot/Category.cpp
 create mode 100644 src/plugins/ahbot/Category.h
 create mode 100644 src/plugins/ahbot/ConsumableCategory.cpp
 create mode 100644 src/plugins/ahbot/ConsumableCategory.h
 create mode 100644 src/plugins/ahbot/ItemBag.cpp
 create mode 100644 src/plugins/ahbot/ItemBag.h
 create mode 100644 src/plugins/ahbot/PricingStrategy.cpp
 create mode 100644 src/plugins/ahbot/PricingStrategy.h
 create mode 100644 src/plugins/ahbot/TradeCategory.cpp
 create mode 100644 src/plugins/ahbot/TradeCategory.h
 create mode 100644 src/plugins/ahbot/ahbot.conf.dist.in
 create mode 100644 src/plugins/pch/pch.cpp
 create mode 100644 src/plugins/pch/pch.h
 create mode 100644 src/plugins/pchdef.h
 create mode 100644 src/plugins/playerbot/AiFactory.cpp
 create mode 100644 src/plugins/playerbot/AiFactory.h
 create mode 100644 src/plugins/playerbot/ChatFilter.cpp
 create mode 100644 src/plugins/playerbot/ChatFilter.h
 create mode 100644 src/plugins/playerbot/ChatHelper.cpp
 create mode 100644 src/plugins/playerbot/ChatHelper.h
 create mode 100644 src/plugins/playerbot/FleeManager.cpp
 create mode 100644 src/plugins/playerbot/FleeManager.h
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.cpp
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.h
 create mode 100644 src/plugins/playerbot/Helpers.cpp
 create mode 100644 src/plugins/playerbot/LazyCalculatedValue.h
 create mode 100644 src/plugins/playerbot/LootObjectStack.cpp
 create mode 100644 src/plugins/playerbot/LootObjectStack.h
 create mode 100644 src/plugins/playerbot/PlayerbotAI.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAI.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIAware.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.h
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.h
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.h
 create mode 100644 src/plugins/playerbot/RandomItemMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomItemMgr.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/aiplayerbot.conf.dist.in
 create mode 100644 src/plugins/playerbot/playerbot.h
 create mode 100644 src/plugins/playerbot/playerbotDefs.h
 create mode 100644 src/plugins/playerbot/strategy/Action.cpp
 create mode 100644 src/plugins/playerbot/strategy/Action.h
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.cpp
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.h
 create mode 100644 src/plugins/playerbot/strategy/AiObject.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObject.h
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/Engine.cpp
 create mode 100644 src/plugins/playerbot/strategy/Engine.h
 create mode 100644 src/plugins/playerbot/strategy/Event.cpp
 create mode 100644 src/plugins/playerbot/strategy/Event.h
 create mode 100644 src/plugins/playerbot/strategy/ExternalEventHelper.h
 create mode 100644 src/plugins/playerbot/strategy/ItemVisitors.h
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.h
 create mode 100644 src/plugins/playerbot/strategy/NamedObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.h
 create mode 100644 src/plugins/playerbot/strategy/Queue.cpp
 create mode 100644 src/plugins/playerbot/strategy/Queue.h
 create mode 100644 src/plugins/playerbot/strategy/Strategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/Strategy.h
 create mode 100644 src/plugins/playerbot/strategy/StrategyContext.h
 create mode 100644 src/plugins/playerbot/strategy/Trigger.cpp
 create mode 100644 src/plugins/playerbot/strategy/Trigger.h
 create mode 100644 src/plugins/playerbot/strategy/Value.cpp
 create mode 100644 src/plugins/playerbot/strategy/Value.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReachTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RtiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidBearActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidCatActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueComboActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LfgTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/RangeTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/TriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ChatValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DistanceValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.h
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasTotemValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsBehindValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsFacingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsMovingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastMovementValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LfgValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LogLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LootStrategyValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/MasterTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestUnitsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PetTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SelfTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/ValueContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
 create mode 100644 src/test/AcceptAllQuestStrategyTestCase.cpp
 create mode 100644 src/test/AiObjectContextWrapper.h
 create mode 100644 src/test/ArcaneMageTestCase.cpp
 create mode 100644 src/test/BearTankDruidTestCase.cpp
 create mode 100644 src/test/CMakeLists.txt
 create mode 100644 src/test/CasterDruidTestCase.cpp
 create mode 100644 src/test/CasterShamanTestCase.cpp
 create mode 100644 src/test/CatDpsDruidTestCase.cpp
 create mode 100644 src/test/ChatCommandTestCase.cpp
 create mode 100644 src/test/ChatFilterTestCase.cpp
 create mode 100644 src/test/DpsHunterEngineTestCase.cpp
 create mode 100644 src/test/DpsPaladinTestCase.cpp
 create mode 100644 src/test/DpsPriestTestCase.cpp
 create mode 100644 src/test/DpsRogueTestCase.cpp
 create mode 100644 src/test/DpsWarlockTestCase.cpp
 create mode 100644 src/test/DpsWarriorTestCase.cpp
 create mode 100644 src/test/DruidNonCombatTestCase.cpp
 create mode 100644 src/test/DuelTestCase.cpp
 create mode 100644 src/test/EngineTestBase.cpp
 create mode 100644 src/test/EngineTestBase.h
 create mode 100644 src/test/EngineTestCase.cpp
 create mode 100644 src/test/EventTestCase.cpp
 create mode 100644 src/test/EverythingUnavailableAiManagerRegistry.h
 create mode 100644 src/test/ExternalEventHelperTestCase.cpp
 create mode 100644 src/test/FireMageTestCase.cpp
 create mode 100644 src/test/FrostMageTestCase.cpp
 create mode 100644 src/test/GenericTestCase.cpp
 create mode 100644 src/test/HealDruidTestCase.cpp
 create mode 100644 src/test/HealPriestTestCase.cpp
 create mode 100644 src/test/HealShamanTestCase.cpp
 create mode 100644 src/test/HolyPriestTestCase.cpp
 create mode 100644 src/test/HunterNonCombatTestCase.cpp
 create mode 100644 src/test/KiteTestCase.cpp
 create mode 100644 src/test/LootObjectStackTestCase.cpp
 create mode 100644 src/test/MageNonCombatTestCase.cpp
 create mode 100644 src/test/MeleeShamanTestCase.cpp
 create mode 100644 src/test/MockAiObjectContext.cpp
 create mode 100644 src/test/MockAiObjectContext.h
 create mode 100644 src/test/MockPlayerbotAIBase.cpp
 create mode 100644 src/test/MockPlayerbotAIBase.h
 create mode 100644 src/test/MockedAiObjectContextTestCase.h
 create mode 100644 src/test/MockedTargets.h
 create mode 100644 src/test/NextActionTestCase.cpp
 create mode 100644 src/test/NonCombatEngineTestCase.cpp
 create mode 100644 src/test/NonCombatEngineTestCase2.cpp
 create mode 100644 src/test/PaladinNonCombatTestCase.cpp
 create mode 100644 src/test/PerformanceTestCase.cpp
 create mode 100644 src/test/PriestNonCombatTestCase.cpp
 create mode 100644 src/test/QualifiedValueTestCase.cpp
 create mode 100644 src/test/QuestStrategyTestCase.cpp
 create mode 100644 src/test/QueueTestCase.cpp
 create mode 100644 src/test/RacialsTestCase.cpp
 create mode 100644 src/test/RandomItemMgrTestCase.cpp
 create mode 100644 src/test/ShamanNonCombatTestCase.cpp
 create mode 100644 src/test/TankPaladinTestCase.cpp
 create mode 100644 src/test/TankWarlockTestCase.cpp
 create mode 100644 src/test/TankWarriorTestCase.cpp
 create mode 100644 src/test/ValueTestCase.cpp
 create mode 100644 src/test/WarlockNonCombatTestCase.cpp
 create mode 100644 src/test/WarrirorNonCombatTestCase.cpp
 create mode 100644 src/test/WorldPacketHandlerTestCase.cpp
 create mode 100644 src/test/aitest.h
 create mode 100644 src/test/cppunit/AdditionalMessage.cpp
 create mode 100644 src/test/cppunit/AdditionalMessage.h
 create mode 100644 src/test/cppunit/Asserter.cpp
 create mode 100644 src/test/cppunit/Asserter.h
 create mode 100644 src/test/cppunit/BeOsDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/BriefTestProgressListener.cpp
 create mode 100644 src/test/cppunit/BriefTestProgressListener.h
 create mode 100644 src/test/cppunit/CompilerOutputter.cpp
 create mode 100644 src/test/cppunit/CompilerOutputter.h
 create mode 100644 src/test/cppunit/DefaultProtector.cpp
 create mode 100644 src/test/cppunit/DefaultProtector.h
 create mode 100644 src/test/cppunit/DllMain.cpp
 create mode 100644 src/test/cppunit/DynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/DynamicLibraryManagerException.cpp
 create mode 100644 src/test/cppunit/Exception.cpp
 create mode 100644 src/test/cppunit/Exception.h
 create mode 100644 src/test/cppunit/Makefile.am
 create mode 100644 src/test/cppunit/Makefile.in
 create mode 100644 src/test/cppunit/Message.cpp
 create mode 100644 src/test/cppunit/Message.h
 create mode 100644 src/test/cppunit/Outputter.h
 create mode 100644 src/test/cppunit/PlugInManager.cpp
 create mode 100644 src/test/cppunit/PlugInParameters.cpp
 create mode 100644 src/test/cppunit/Portability.h
 create mode 100644 src/test/cppunit/Protector.cpp
 create mode 100644 src/test/cppunit/Protector.h
 create mode 100644 src/test/cppunit/ProtectorChain.cpp
 create mode 100644 src/test/cppunit/ProtectorChain.h
 create mode 100644 src/test/cppunit/ProtectorContext.h
 create mode 100644 src/test/cppunit/RepeatedTest.cpp
 create mode 100644 src/test/cppunit/ShlDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/SourceLine.cpp
 create mode 100644 src/test/cppunit/SourceLine.h
 create mode 100644 src/test/cppunit/StringTools.cpp
 create mode 100644 src/test/cppunit/SynchronizedObject.cpp
 create mode 100644 src/test/cppunit/SynchronizedObject.h
 create mode 100644 src/test/cppunit/Test.cpp
 create mode 100644 src/test/cppunit/Test.h
 create mode 100644 src/test/cppunit/TestAssert.cpp
 create mode 100644 src/test/cppunit/TestAssert.h
 create mode 100644 src/test/cppunit/TestCaller.h
 create mode 100644 src/test/cppunit/TestCase.cpp
 create mode 100644 src/test/cppunit/TestCase.h
 create mode 100644 src/test/cppunit/TestCaseDecorator.cpp
 create mode 100644 src/test/cppunit/TestComposite.cpp
 create mode 100644 src/test/cppunit/TestComposite.h
 create mode 100644 src/test/cppunit/TestDecorator.cpp
 create mode 100644 src/test/cppunit/TestFactoryRegistry.cpp
 create mode 100644 src/test/cppunit/TestFailure.cpp
 create mode 100644 src/test/cppunit/TestFailure.h
 create mode 100644 src/test/cppunit/TestFixture.h
 create mode 100644 src/test/cppunit/TestLeaf.cpp
 create mode 100644 src/test/cppunit/TestLeaf.h
 create mode 100644 src/test/cppunit/TestListener.h
 create mode 100644 src/test/cppunit/TestNamer.cpp
 create mode 100644 src/test/cppunit/TestPath.cpp
 create mode 100644 src/test/cppunit/TestPath.h
 create mode 100644 src/test/cppunit/TestPlugInDefaultImpl.cpp
 create mode 100644 src/test/cppunit/TestResult.cpp
 create mode 100644 src/test/cppunit/TestResult.h
 create mode 100644 src/test/cppunit/TestResultCollector.cpp
 create mode 100644 src/test/cppunit/TestResultCollector.h
 create mode 100644 src/test/cppunit/TestRunner.cpp
 create mode 100644 src/test/cppunit/TestRunner.h
 create mode 100644 src/test/cppunit/TestSetUp.cpp
 create mode 100644 src/test/cppunit/TestSuccessListener.cpp
 create mode 100644 src/test/cppunit/TestSuccessListener.h
 create mode 100644 src/test/cppunit/TestSuite.cpp
 create mode 100644 src/test/cppunit/TestSuite.h
 create mode 100644 src/test/cppunit/TestSuiteBuilderContext.cpp
 create mode 100644 src/test/cppunit/TextOutputter.cpp
 create mode 100644 src/test/cppunit/TextOutputter.h
 create mode 100644 src/test/cppunit/TextTestProgressListener.cpp
 create mode 100644 src/test/cppunit/TextTestProgressListener.h
 create mode 100644 src/test/cppunit/TextTestResult.cpp
 create mode 100644 src/test/cppunit/TextTestResult.h
 create mode 100644 src/test/cppunit/TextTestRunner.cpp
 create mode 100644 src/test/cppunit/TextTestRunner.h
 create mode 100644 src/test/cppunit/TypeInfoHelper.cpp
 create mode 100644 src/test/cppunit/UnixDynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/Win32DynamicLibraryManager.cpp
 create mode 100644 src/test/cppunit/XmlDocument.cpp
 create mode 100644 src/test/cppunit/XmlElement.cpp
 create mode 100644 src/test/cppunit/XmlOutputter.cpp
 create mode 100644 src/test/cppunit/XmlOutputter.h
 create mode 100644 src/test/cppunit/XmlOutputterHook.cpp
 create mode 100644 src/test/cppunit/XmlOutputterHook.h
 create mode 100644 src/test/cppunit/config/CppUnitApi.h
 create mode 100644 src/test/cppunit/config/Makefile.am
 create mode 100644 src/test/cppunit/config/Makefile.in
 create mode 100644 src/test/cppunit/config/SelectDllLoader.h
 create mode 100644 src/test/cppunit/config/SourcePrefix.h
 create mode 100644 src/test/cppunit/config/config-bcb5.h
 create mode 100644 src/test/cppunit/config/config-evc4.h
 create mode 100644 src/test/cppunit/config/config-mac.h
 create mode 100644 src/test/cppunit/config/config-msvc6.h
 create mode 100644 src/test/cppunit/cppunit.dsp
 create mode 100644 src/test/cppunit/cppunit_dll.dsp
 create mode 100644 src/test/cppunit/extensions/AutoRegisterSuite.h
 create mode 100644 src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
 create mode 100644 src/test/cppunit/extensions/HelperMacros.h
 create mode 100644 src/test/cppunit/extensions/Makefile.am
 create mode 100644 src/test/cppunit/extensions/Makefile.in
 create mode 100644 src/test/cppunit/extensions/Orthodox.h
 create mode 100644 src/test/cppunit/extensions/RepeatedTest.h
 create mode 100644 src/test/cppunit/extensions/TestCaseDecorator.h
 create mode 100644 src/test/cppunit/extensions/TestDecorator.h
 create mode 100644 src/test/cppunit/extensions/TestFactory.h
 create mode 100644 src/test/cppunit/extensions/TestFactoryRegistry.h
 create mode 100644 src/test/cppunit/extensions/TestFixtureFactory.h
 create mode 100644 src/test/cppunit/extensions/TestNamer.h
 create mode 100644 src/test/cppunit/extensions/TestSetUp.h
 create mode 100644 src/test/cppunit/extensions/TestSuiteBuilderContext.h
 create mode 100644 src/test/cppunit/extensions/TestSuiteFactory.h
 create mode 100644 src/test/cppunit/extensions/TypeInfoHelper.h
 create mode 100644 src/test/cppunit/plugin/DynamicLibraryManager.h
 create mode 100644 src/test/cppunit/plugin/DynamicLibraryManagerException.h
 create mode 100644 src/test/cppunit/plugin/Makefile.am
 create mode 100644 src/test/cppunit/plugin/Makefile.in
 create mode 100644 src/test/cppunit/plugin/PlugInManager.h
 create mode 100644 src/test/cppunit/plugin/PlugInParameters.h
 create mode 100644 src/test/cppunit/plugin/TestPlugIn.h
 create mode 100644 src/test/cppunit/plugin/TestPlugInDefaultImpl.h
 create mode 100644 src/test/cppunit/portability/CppUnitDeque.h
 create mode 100644 src/test/cppunit/portability/CppUnitMap.h
 create mode 100644 src/test/cppunit/portability/CppUnitSet.h
 create mode 100644 src/test/cppunit/portability/CppUnitStack.h
 create mode 100644 src/test/cppunit/portability/CppUnitVector.h
 create mode 100644 src/test/cppunit/portability/FloatingPoint.h
 create mode 100644 src/test/cppunit/portability/Makefile.am
 create mode 100644 src/test/cppunit/portability/Makefile.in
 create mode 100644 src/test/cppunit/portability/Stream.h
 create mode 100644 src/test/cppunit/tools/Algorithm.h
 create mode 100644 src/test/cppunit/tools/Makefile.am
 create mode 100644 src/test/cppunit/tools/Makefile.in
 create mode 100644 src/test/cppunit/tools/StringTools.h
 create mode 100644 src/test/cppunit/tools/XmlDocument.h
 create mode 100644 src/test/cppunit/tools/XmlElement.h
 create mode 100644 src/test/cppunit/ui/Makefile.am
 create mode 100644 src/test/cppunit/ui/Makefile.in
 create mode 100644 src/test/cppunit/ui/mfc/Makefile.am
 create mode 100644 src/test/cppunit/ui/mfc/Makefile.in
 create mode 100644 src/test/cppunit/ui/mfc/MfcTestRunner.h
 create mode 100644 src/test/cppunit/ui/mfc/TestRunner.h
 create mode 100644 src/test/cppunit/ui/qt/Config.h
 create mode 100644 src/test/cppunit/ui/qt/Makefile.am
 create mode 100644 src/test/cppunit/ui/qt/Makefile.in
 create mode 100644 src/test/cppunit/ui/qt/QtTestRunner.h
 create mode 100644 src/test/cppunit/ui/qt/TestRunner.h
 create mode 100644 src/test/cppunit/ui/text/Makefile.am
 create mode 100644 src/test/cppunit/ui/text/Makefile.in
 create mode 100644 src/test/cppunit/ui/text/TestRunner.h
 create mode 100644 src/test/cppunit/ui/text/TextTestRunner.h
 create mode 100644 src/test/efficiency/AbstractEfficiencyTestCase.h
 create mode 100644 src/test/efficiency/DruidEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/EfficiencyActionExecutionListener.cpp
 create mode 100644 src/test/efficiency/EfficiencyActionExecutionListener.h
 create mode 100644 src/test/efficiency/MageEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/PriestEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/ShamanEfficiencyTestCase.cpp
 create mode 100644 src/test/efficiency/WarlockEfficiencyTestCase.cpp
 create mode 100644 src/test/main.cpp
 create mode 100644 src/test/pch.cpp
 create mode 100644 src/test/pch.h

diff --git a/cmake/options.cmake b/cmake/options.cmake
index 486cc90..35bcf5f 100644
--- a/cmake/options.cmake
+++ b/cmake/options.cmake
@@ -18,3 +18,4 @@ option(WITH_COREDEBUG   "Include additional debug-code in core"
 set(WITH_SOURCE_TREE "no" CACHE STRING "Build the source tree for IDE's.")
 set_property(CACHE WITH_SOURCE_TREE PROPERTY STRINGS no flat hierarchical)
 option(WITHOUT_GIT      "Disable the GIT testing routines"                            0)
+option(TESTS            "Build cppunit tests"                                         0)
diff --git a/sql/ai_playerbot_guild_names.sql b/sql/ai_playerbot_guild_names.sql
new file mode 100644
index 0000000..8ea74de
--- /dev/null
+++ b/sql/ai_playerbot_guild_names.sql
@@ -0,0 +1,652 @@
+DROP TABLE IF EXISTS `ai_playerbot_guild_names`;
+CREATE TABLE `ai_playerbot_guild_names` (
+  `name_id` mediumint(8) NOT NULL AUTO_INCREMENT UNIQUE,
+  `name` varchar(24) NOT NULL UNIQUE,
+  PRIMARY KEY (`name_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='PlayerbotAI guild names';
+
+
+
+LOCK TABLES `ai_playerbot_guild_names` WRITE;
+INSERT INTO `ai_playerbot_guild_names` VALUES
+(NULL, 'Black Guard'),
+(NULL, 'Abyssal Kingdoms'),
+(NULL, 'Acid Evil'),
+(NULL, 'Addicts Muskateers'),
+(NULL, 'Adventurers War'),
+(NULL, 'Age of Red Water Clan'),
+(NULL, 'Alivso Reason'),
+(NULL, 'All Knights'),
+(NULL, 'Allegiance of the Vile'),
+(NULL, 'Alliance Clan'),
+(NULL, 'Alliance of Defectives'),
+(NULL, 'Alti Legions'),
+(NULL, 'Anarchie Shi'),
+(NULL, 'Anchors of the Nominal'),
+(NULL, 'Ancients of Part Times'),
+(NULL, 'Angelus Gods'),
+(NULL, 'Angry Party'),
+(NULL, 'Apocalyptic Lamont'),
+(NULL, 'Architects of Green'),
+(NULL, 'Army of Black Widows'),
+(NULL, 'Army of Orgrimmar Minds'),
+(NULL, 'Army of Three Horses'),
+(NULL, 'Arrows of Midlight'),
+(NULL, 'Artisans of Best Guild'),
+(NULL, 'Assasins of the Pyrewood'),
+(NULL, 'Assassins Bane'),
+(NULL, 'Avatars of Warsong Stuff'),
+(NULL, 'Axis of the Funky Night'),
+(NULL, 'Azeroth Souls'),
+(NULL, 'Azeroths Rabbits'),
+(NULL, 'Bad Sentinels'),
+(NULL, 'Banana Song'),
+(NULL, 'Band of Tarantula Attack'),
+(NULL, 'Band of the Dark Reveren'),
+(NULL, 'Barcode Praised'),
+(NULL, 'Basher Goats'),
+(NULL, 'Basic Order'),
+(NULL, 'Batman of Banished'),
+(NULL, 'Betrayers of Lucky Child'),
+(NULL, 'Blackwater Committee'),
+(NULL, 'Blades of Lich Kings'),
+(NULL, 'Blades of the Hive'),
+(NULL, 'Blades of the Total'),
+(NULL, 'Bleeding War'),
+(NULL, 'Blessed Lair'),
+(NULL, 'Blizzards of the Iron'),
+(NULL, 'Blood Chaos'),
+(NULL, 'Blood Intrigue'),
+(NULL, 'Blood Samurai'),
+(NULL, 'Bloodlust Good'),
+(NULL, 'Bonds of Reported Ignore'),
+(NULL, 'Booty Cry'),
+(NULL, 'Border Knights'),
+(NULL, 'Bossmans Targaryen'),
+(NULL, 'Braveheart Heaven'),
+(NULL, 'Brotherhood of Twilight'),
+(NULL, 'Bruised Pain'),
+(NULL, 'Burning Control'),
+(NULL, 'Burning Oblivion'),
+(NULL, 'Cabal of Kalimdor'),
+(NULL, 'Cake Crusade'),
+(NULL, 'Call of the Ironforge'),
+(NULL, 'Carebears Thunder'),
+(NULL, 'Carpe Heaven'),
+(NULL, 'Carpe Regiment'),
+(NULL, 'Children of Order'),
+(NULL, 'Children of the Gods'),
+(NULL, 'Circle of Amor E Bobby'),
+(NULL, 'Clan of the Elven Toys'),
+(NULL, 'Clan of the Strike Light'),
+(NULL, 'Coalition of Super Best'),
+(NULL, 'Collective Pimps'),
+(NULL, 'Companions of the Gnome'),
+(NULL, 'Company of the Vibe'),
+(NULL, 'Conclave of the Triad'),
+(NULL, 'Council of Final Demise'),
+(NULL, 'Council of Hard Core Ord'),
+(NULL, 'Craaweh Thrall'),
+(NULL, 'Cradle Scourge'),
+(NULL, 'Crimson Angels'),
+(NULL, 'Crimson Saints'),
+(NULL, 'Crusade of Oh'),
+(NULL, 'Crusaders of Undead'),
+(NULL, 'Cryptic Serenity'),
+(NULL, 'Csa Rigged'),
+(NULL, 'Cult of the Raging Raid'),
+(NULL, 'Dalaran Fair'),
+(NULL, 'Damage Inc'),
+(NULL, 'Dark Alliance'),
+(NULL, 'Dark Azeroth'),
+(NULL, 'Dark Damage'),
+(NULL, 'Dark Resistus'),
+(NULL, 'Dark Samurai'),
+(NULL, 'Dark Turtles'),
+(NULL, 'Darken Mercenaries'),
+(NULL, 'Darkened Malevolence'),
+(NULL, 'Darkness of Sword Coast'),
+(NULL, 'Dawn of Knights Society'),
+(NULL, 'Dawn of Mad Sentry'),
+(NULL, 'Dead Zug'),
+(NULL, 'Death Darkness'),
+(NULL, 'Death Knights'),
+(NULL, 'Deathlike Goods'),
+(NULL, 'Deaths Venoms'),
+(NULL, 'Decree of the Phumpers'),
+(NULL, 'Defenders of Da Raised'),
+(NULL, 'Defenders of Hyuuga Dark'),
+(NULL, 'Defenders of Sacred Harm'),
+(NULL, 'Deths Lords'),
+(NULL, 'Devil Circl'),
+(NULL, 'Devils Klng'),
+(NULL, 'Dharma Hand'),
+(NULL, 'Dharma Thorn'),
+(NULL, 'Dies Ravager'),
+(NULL, 'Disciples of Dead Panda'),
+(NULL, 'Disciples of the Rot'),
+(NULL, 'Doomsday Youth'),
+(NULL, 'Dorcha Knights'),
+(NULL, 'Dots of Dead Skull'),
+(NULL, 'Dragon Arms'),
+(NULL, 'Dragonhawk Revolution'),
+(NULL, 'Dragons Erythnul'),
+(NULL, 'Dragons of the Black'),
+(NULL, 'Drunken Thunder'),
+(NULL, 'Drunks of Matoskan'),
+(NULL, 'Dwarven Rock'),
+(NULL, 'Dynasty of the Emerald'),
+(NULL, 'Eastern Asylum'),
+(NULL, 'Echo Sanctus'),
+(NULL, 'Echoes of the Muphin'),
+(NULL, 'Effreno Death'),
+(NULL, 'Elite Guild'),
+(NULL, 'Elite Legion'),
+(NULL, 'Elite Veritas'),
+(NULL, 'Elunes Meat'),
+(NULL, 'Emerald Men'),
+(NULL, 'Emerald Mjolnir'),
+(NULL, 'Endless Defense'),
+(NULL, 'Enemies of Bleeding'),
+(NULL, 'Enternal Saber'),
+(NULL, 'Evictors of the Returned'),
+(NULL, 'Evil Guard'),
+(NULL, 'Exalted Effect'),
+(NULL, 'Eyes of a Night Elf'),
+(NULL, 'Eyes of the Elton Souls'),
+(NULL, 'Fallen Clan'),
+(NULL, 'Fallen Milk'),
+(NULL, 'Fenrir Seeker'),
+(NULL, 'Final Army'),
+(NULL, 'Flames of Ale Drinkers'),
+(NULL, 'Flames of Antarian Chaos'),
+(NULL, 'Forestt''s Wrath'),
+(NULL, 'Forgotten Within'),
+(NULL, 'From Synergy'),
+(NULL, 'Frozen Oblivion'),
+(NULL, 'Gashlycrumb Rollers'),
+(NULL, 'Giovannitwos Elune'),
+(NULL, 'Glass Meridian'),
+(NULL, 'Gnome Faction'),
+(NULL, 'Gods Gold'),
+(NULL, 'Gods of the Complete'),
+(NULL, 'Gold Catchers'),
+(NULL, 'Golden Legendz'),
+(NULL, 'Golden Souls'),
+(NULL, 'Goldshire Goats'),
+(NULL, 'Good Azeroth'),
+(NULL, 'Gotz Safety'),
+(NULL, 'Grammaton Alliance'),
+(NULL, 'Great Circle'),
+(NULL, 'Guardians of Honor'),
+(NULL, 'Guards of Frostmane'),
+(NULL, 'Guild of La Mano Dragons'),
+(NULL, 'Guild of the Puppet'),
+(NULL, 'Haggles Brigade'),
+(NULL, 'Hammer of the Moral'),
+(NULL, 'Hand of the Iron'),
+(NULL, 'Hands of Far Con Buddies'),
+(NULL, 'Hearts Knights'),
+(NULL, 'Hell Angels'),
+(NULL, 'Hells Thorn'),
+(NULL, 'Holy Darnassus'),
+(NULL, 'Horde Abh'),
+(NULL, 'Horde Dragons'),
+(NULL, 'Horde Leaders'),
+(NULL, 'Horde Squad'),
+(NULL, 'Horde of Omnia'),
+(NULL, 'Horde of Free Brigade'),
+(NULL, 'Horde of Shadow Flush'),
+(NULL, 'Hordes Buccaneers'),
+(NULL, 'Hordes Marauders'),
+(NULL, 'House Crusaders'),
+(NULL, 'Immortality Honor'),
+(NULL, 'Inside Poof'),
+(NULL, 'Iron Boyz'),
+(NULL, 'Iscariot Ginas'),
+(NULL, 'Island Kimchi'),
+(NULL, 'Jenovas Wild'),
+(NULL, 'Kalimdor Darkness'),
+(NULL, 'Keepers of Golden Misery'),
+(NULL, 'Keggers of Alt Hand Aton'),
+(NULL, 'Kill Mafia'),
+(NULL, 'Killer Durotar'),
+(NULL, 'Killer Force'),
+(NULL, 'Kindred Yardies'),
+(NULL, 'Kindred of King Assassin'),
+(NULL, 'Kingdom of the Ordo Crew'),
+(NULL, 'Kings Boys'),
+(NULL, 'Kings Windstorm'),
+(NULL, 'Kings of Blood Knuckle'),
+(NULL, 'Kings of Dol Aegis'),
+(NULL, 'Knight Combat'),
+(NULL, 'Knight of Fuzzy Night'),
+(NULL, 'Knights of Darkspear'),
+(NULL, 'Knights of Heavens Grave'),
+(NULL, 'Knights of Myrmidon Ivxx'),
+(NULL, 'Knights of the Avenging'),
+(NULL, 'Knights of the Ballpeen'),
+(NULL, 'Knights of the Black'),
+(NULL, 'Knights of the Bloodhoof'),
+(NULL, 'Knights of the Sovereign'),
+(NULL, 'Knights of the Storm'),
+(NULL, 'Knights of the Zulian'),
+(NULL, 'Last Ptesanwi'),
+(NULL, 'League of Hate Crew Seek'),
+(NULL, 'Legacy of Ninth Beard'),
+(NULL, 'Legendary Sons'),
+(NULL, 'Legion of Maple Syrup'),
+(NULL, 'Legion of Public Works'),
+(NULL, 'Legion of Three Course'),
+(NULL, 'Legion of United Souls'),
+(NULL, 'Legion of Westfall Gold'),
+(NULL, 'Legion of the Dark'),
+(NULL, 'Legionnaires of Skull'),
+(NULL, 'Les Warriors'),
+(NULL, 'Lifetakers Inc'),
+(NULL, 'Light of Dark Spire'),
+(NULL, 'Light of Jade Renegade'),
+(NULL, 'Liquid Guild'),
+(NULL, 'Lone Side'),
+(NULL, 'Lords of Fallen Blood'),
+(NULL, 'Los Frum'),
+(NULL, 'Lost Boyz'),
+(NULL, 'Lost Squad'),
+(NULL, 'Mad Daggers'),
+(NULL, 'Malice Fatale'),
+(NULL, 'Mandate of Jade'),
+(NULL, 'Marines of the Butt'),
+(NULL, 'Mercenaries of the Death'),
+(NULL, 'Midget Council'),
+(NULL, 'Midgets of Dark Sexy'),
+(NULL, 'Midnight Norrathians'),
+(NULL, 'Midnight Slayer'),
+(NULL, 'Midnight War'),
+(NULL, 'Minions of the Shadow'),
+(NULL, 'Ministry of the Allince'),
+(NULL, 'Mithril Destiny'),
+(NULL, 'Monarchs of Party Crew'),
+(NULL, 'Money Call'),
+(NULL, 'Moonwood Redeye'),
+(NULL, 'Narrow Patrol'),
+(NULL, 'New Clan'),
+(NULL, 'Night Pack'),
+(NULL, 'Nightmare Guild'),
+(NULL, 'Ninja Pledge'),
+(NULL, 'Nocturne of Totally Dead'),
+(NULL, 'Obsidian Fish'),
+(NULL, 'Old Cosa'),
+(NULL, 'One Valor'),
+(NULL, 'Opus Faithful'),
+(NULL, 'Order of Alts oF Fate'),
+(NULL, 'Order of Nagas Bike Hunt'),
+(NULL, 'Order of Omega Wards'),
+(NULL, 'Order of Pink'),
+(NULL, 'Order of Shield Bed'),
+(NULL, 'Order of the Alt Sheep'),
+(NULL, 'Order of the Honor'),
+(NULL, 'Order of the Divine Lord'),
+(NULL, 'Ordo Force'),
+(NULL, 'Orgrimmar Ones'),
+(NULL, 'Out of Lw Downed Wrynn'),
+(NULL, 'Out of Mithril Avengers'),
+(NULL, 'Oxbloods Medivh'),
+(NULL, 'Pally Guard'),
+(NULL, 'Path of the Brain'),
+(NULL, 'Peddlers of the Hidden'),
+(NULL, 'Phantoms of Wicked'),
+(NULL, 'Phoenix Keepers'),
+(NULL, 'Pillowcase Azeroth'),
+(NULL, 'Pillowcase Cats'),
+(NULL, 'Pius Tribe'),
+(NULL, 'Plague of Human Slayer'),
+(NULL, 'Plan Hand'),
+(NULL, 'Power of Tuatha De Blood'),
+(NULL, 'Priest Guild'),
+(NULL, 'Prophets of Fatima War'),
+(NULL, 'Prophets of Outlaw'),
+(NULL, 'Prophets of the Red Mean'),
+(NULL, 'Protectors of Black Hand'),
+(NULL, 'Pure Aequitas'),
+(NULL, 'Question Thrall'),
+(NULL, 'Quintessential Sister'),
+(NULL, 'Rage of Prairie Black'),
+(NULL, 'Rage of the Flame'),
+(NULL, 'Raiders of Candy Heart'),
+(NULL, 'Raiders of the Purple'),
+(NULL, 'Raiders of the Sil'),
+(NULL, 'Ram Runners'),
+(NULL, 'Rangers Vengeance'),
+(NULL, 'Rangers of Interitus'),
+(NULL, 'Raven Clan'),
+(NULL, 'Razzle Guardian'),
+(NULL, 'Reapers of the Shadow'),
+(NULL, 'Reckless Knights'),
+(NULL, 'Red Byam'),
+(NULL, 'Red Death'),
+(NULL, 'Reign of Alliance Task'),
+(NULL, 'Reign of Blazing Frell'),
+(NULL, 'Reign of Pure Conway'),
+(NULL, 'Restoration of Illegal'),
+(NULL, 'Resurrection of Tenui'),
+(NULL, 'Ronin Kalimdor'),
+(NULL, 'Rotting Tears'),
+(NULL, 'Ruins of Dark Azeroth'),
+(NULL, 'Rulers of Devils'),
+(NULL, 'Sacred Parts'),
+(NULL, 'Sacred Society'),
+(NULL, 'Sacrificial Brotherhood'),
+(NULL, 'Sanguine Council'),
+(NULL, 'Sapphic Exiles'),
+(NULL, 'Savage Kalimdor'),
+(NULL, 'Scourge of Eight Inches'),
+(NULL, 'Scourge of Wow Knights'),
+(NULL, 'Scythe Sauce'),
+(NULL, 'Secret Clan'),
+(NULL, 'Seki Council'),
+(NULL, 'Seraph Legends'),
+(NULL, 'Shaded Judgement'),
+(NULL, 'Shadow America'),
+(NULL, 'Shadow Boys'),
+(NULL, 'Shadow Knights'),
+(NULL, 'Shadowed Ghosts'),
+(NULL, 'Shadowed Goat'),
+(NULL, 'Shadows of Cole Trainz'),
+(NULL, 'Shadows of Los Banditos'),
+(NULL, 'Shattered Stormrage'),
+(NULL, 'Silent Night'),
+(NULL, 'Silver Fools'),
+(NULL, 'Silversky Sun'),
+(NULL, 'Sisters of Kalimdor'),
+(NULL, 'Skulled Ironforge'),
+(NULL, 'Slayers of the Primals'),
+(NULL, 'Sleepy Steel'),
+(NULL, 'Soldiers of Azeroth'),
+(NULL, 'Soldiers of Stalker'),
+(NULL, 'Sons of Lambent Virtue'),
+(NULL, 'Sons of the Top Truth'),
+(NULL, 'Soul Wish'),
+(NULL, 'Souls of Elite Gnome'),
+(NULL, 'Spanaway Metalheadz'),
+(NULL, 'Spoony Demise'),
+(NULL, 'Squires of Sacred Tribe'),
+(NULL, 'Stagnant Jesters'),
+(NULL, 'Stars of Gear Farming'),
+(NULL, 'Stupid Crusaders'),
+(NULL, 'Stop Guides'),
+(NULL, 'Storm of the Mope''s'),
+(NULL, 'Stormrage Ferguson'),
+(NULL, 'Stormtroopers of Fatima '),
+(NULL, 'Stormwind Crew'),
+(NULL, 'Straight Caedes'),
+(NULL, 'Stronghold Angels'),
+(NULL, 'Sturgeon Empire'),
+(NULL, 'Survivors of Devil Club'),
+(NULL, 'Sweet Bear'),
+(NULL, 'Sword of Lost Evil'),
+(NULL, 'Tainted Bunnies'),
+(NULL, 'Talon of the Eclectic'),
+(NULL, 'Team Kingdom'),
+(NULL, 'Team United'),
+(NULL, 'Tears of Eternal Kitties'),
+(NULL, 'Tears of Phantom Druids'),
+(NULL, 'Templar of Raid Dodgers'),
+(NULL, 'Templars of Plagueware'),
+(NULL, 'Terra Totem'),
+(NULL, 'Terra War'),
+(NULL, 'The Abiem'),
+(NULL, 'The Aceofchaos'),
+(NULL, 'The Afterlife'),
+(NULL, 'The Aggression'),
+(NULL, 'The Alliance of Dark'),
+(NULL, 'The Altimate'),
+(NULL, 'The Ancona Fire'),
+(NULL, 'The Apocalypse'),
+(NULL, 'The Arcane Monkey'),
+(NULL, 'The Army of Spartans'),
+(NULL, 'The Avalon'),
+(NULL, 'The Avengers of Shining'),
+(NULL, 'The Azure Gangstaz'),
+(NULL, 'The Battlegnome'),
+(NULL, 'The Black Hand Haven'),
+(NULL, 'The Blackdraygon'),
+(NULL, 'The Blackout'),
+(NULL, 'The Blade'),
+(NULL, 'The Blades of Caer Eel'),
+(NULL, 'The Blades of Onyxia'),
+(NULL, 'The Blood Red Violence'),
+(NULL, 'The Blood of Red Powers'),
+(NULL, 'The Bloodycrusaders'),
+(NULL, 'The Blues Azeroth'),
+(NULL, 'The Blues Grimfang'),
+(NULL, 'The Bluethunder'),
+(NULL, 'The Bonds of Arcane'),
+(NULL, 'The Brimstone'),
+(NULL, 'The Broken Chaos'),
+(NULL, 'The Brood of Unknown'),
+(NULL, 'The Burning Dog Firewall'),
+(NULL, 'The Cabal'),
+(NULL, 'The Cake Gankers'),
+(NULL, 'The Cannabuddies'),
+(NULL, 'The Circle of Shadow'),
+(NULL, 'The Clan Blackwatch Few'),
+(NULL, 'The Clan Cats'),
+(NULL, 'The Clan Knights'),
+(NULL, 'The Clean Combinations'),
+(NULL, 'The Clean Up Guard'),
+(NULL, 'The Council of Dark'),
+(NULL, 'The Covenant'),
+(NULL, 'The Crimson Guild'),
+(NULL, 'The Crimson Marbock'),
+(NULL, 'The Crusaders of Horde'),
+(NULL, 'The Crusaders of Seksoni'),
+(NULL, 'The Cult of Clan Brigade'),
+(NULL, 'The Cult of the Pink'),
+(NULL, 'The Daggers of the Vile'),
+(NULL, 'The Dark'),
+(NULL, 'The Dark Dogs'),
+(NULL, 'The Dark Pain'),
+(NULL, 'The Darkfall'),
+(NULL, 'The Darkside Vanguard'),
+(NULL, 'The Darkside of Initium'),
+(NULL, 'The Daughters of the Elite'),
+(NULL, 'The Daytripper'),
+(NULL, 'The Deadfriends'),
+(NULL, 'The Defiant'),
+(NULL, 'The Dont Overwhelming'),
+(NULL, 'The Doom Pasta'),
+(NULL, 'The Dragon Redeye'),
+(NULL, 'The Dragons Flame'),
+(NULL, 'The Dreadlords'),
+(NULL, 'The Dublainn Crown'),
+(NULL, 'The Durban Protecters'),
+(NULL, 'The Echoes of Goldshire'),
+(NULL, 'The Elit of Dark Elune'),
+(NULL, 'The Emissaries of Furiou'),
+(NULL, 'The Eternal Chaos'),
+(NULL, 'The Eternus'),
+(NULL, 'The Exiie'),
+(NULL, 'The Expendable Shadow'),
+(NULL, 'The Faith of Desert'),
+(NULL, 'The Family Misfits'),
+(NULL, 'The Fere Darkness'),
+(NULL, 'The Final Tears'),
+(NULL, 'The Forsaken Boochies'),
+(NULL, 'The Gates of the Bloody'),
+(NULL, 'The Gnomes Lordaero'),
+(NULL, 'The Gods of Blackscar'),
+(NULL, 'The Gods of Twilight'),
+(NULL, 'The Gold Fighters'),
+(NULL, 'The Guardian Thieves'),
+(NULL, 'The Guardians of Gnome'),
+(NULL, 'The Hands of Redridge'),
+(NULL, 'The Hawk'),
+(NULL, 'The Hearts Images'),
+(NULL, 'The Hellborn Die'),
+(NULL, 'The Heroes Plague'),
+(NULL, 'The Horde Farmer'),
+(NULL, 'The Horde Honor'),
+(NULL, 'The Hotpocket'),
+(NULL, 'The Ignis Prophecy'),
+(NULL, 'The Illuminatie'),
+(NULL, 'The Immortal League'),
+(NULL, 'The Independant'),
+(NULL, 'The Infragilis Legion'),
+(NULL, 'The Jag'),
+(NULL, 'The Jookmaster'),
+(NULL, 'The Kataclysm'),
+(NULL, 'The Knight'),
+(NULL, 'The Knightelf'),
+(NULL, 'The Knights Thorn'),
+(NULL, 'The Knights of Gods Fury'),
+(NULL, 'The Knights of Lost Peon'),
+(NULL, 'The Knights of Mortal'),
+(NULL, 'The Knights of Samurai'),
+(NULL, 'The Kobra'),
+(NULL, 'The Leaders of Evil'),
+(NULL, 'The Leaders of Life'),
+(NULL, 'The League of Red Knight'),
+(NULL, 'The Legacy Meathooks'),
+(NULL, 'The Legion of the Blue'),
+(NULL, 'The Legion of Death'),
+(NULL, 'The Lemmings of Flaming'),
+(NULL, 'The Let Blood Gamer'),
+(NULL, 'The Light'),
+(NULL, 'The Little Hunters'),
+(NULL, 'The Lords of Vae Knight'),
+(NULL, 'The Mercenaries'),
+(NULL, 'The Midieval Vanguard'),
+(NULL, 'The Might of Dark Tong'),
+(NULL, 'The Mithril Justice'),
+(NULL, 'The Mithril Pepsi'),
+(NULL, 'The Mjollnir'),
+(NULL, 'The Moo Licht'),
+(NULL, 'The Morgantis'),
+(NULL, 'The Mulletmen'),
+(NULL, 'The Necrontyr of Eternal'),
+(NULL, 'The Nedrage Kills'),
+(NULL, 'The Night'),
+(NULL, 'The Nightfall'),
+(NULL, 'The Ninja Heroes'),
+(NULL, 'The Order of Gold'),
+(NULL, 'The Order of Warcraft'),
+(NULL, 'The Order of Warsong'),
+(NULL, 'The Over Louder'),
+(NULL, 'The Overlord'),
+(NULL, 'The Pants'),
+(NULL, 'The Pie'),
+(NULL, 'The Pretectors'),
+(NULL, 'The Project Disease'),
+(NULL, 'The Psychotics'),
+(NULL, 'The Puggers'),
+(NULL, 'The Pyreborne'),
+(NULL, 'The Queen of Meow'),
+(NULL, 'The Red Hood Thunder'),
+(NULL, 'The Reign of Uber Enigma'),
+(NULL, 'The Resurrection'),
+(NULL, 'The Ring of Honor'),
+(NULL, 'The Ropetown'),
+(NULL, 'The Royal Militia Blanco'),
+(NULL, 'The Samurai Banda'),
+(NULL, 'The Sanity'),
+(NULL, 'The Sauce'),
+(NULL, 'The Schoolyard Reapers'),
+(NULL, 'The Secrets of Hehog'),
+(NULL, 'The Seers'),
+(NULL, 'The Servants of Cyclone'),
+(NULL, 'The Seven'),
+(NULL, 'The Shadow Gate'),
+(NULL, 'The Shadow Misfits'),
+(NULL, 'The Shadow of Ninja Pain'),
+(NULL, 'The Shadowborn'),
+(NULL, 'The Shizam'),
+(NULL, 'The Shockers'),
+(NULL, 'The Shriek of Nightmare'),
+(NULL, 'The Silent Grunts'),
+(NULL, 'The Silent Legion'),
+(NULL, 'The Skunkdesigns'),
+(NULL, 'The Sorrow'),
+(NULL, 'The Souls of Azeroth Old'),
+(NULL, 'The Spazler'),
+(NULL, 'The Squirrels'),
+(NULL, 'The Stringville'),
+(NULL, 'The Stronghold of Reds'),
+(NULL, 'The Tha Handlers'),
+(NULL, 'The Thieves of Moral'),
+(NULL, 'The Thorium Claw'),
+(NULL, 'The Thread'),
+(NULL, 'The Thule'),
+(NULL, 'The Thunderslayers'),
+(NULL, 'The True Wow'),
+(NULL, 'The Trusted Minions'),
+(NULL, 'The Twilight Rangers'),
+(NULL, 'The Tyraels Aggression'),
+(NULL, 'The Ultimates'),
+(NULL, 'The Unforgiven Heresy'),
+(NULL, 'The Unholy Bards'),
+(NULL, 'The Unsung Efficiency'),
+(NULL, 'The Valley of the Demon'),
+(NULL, 'The Valor'),
+(NULL, 'The Violent Chaos'),
+(NULL, 'The Virus Eternal'),
+(NULL, 'The War'),
+(NULL, 'The Warsong Gnomeregan'),
+(NULL, 'The Westcoast'),
+(NULL, 'The Wicked'),
+(NULL, 'The Will of Chronicles'),
+(NULL, 'The Windsword Nightmare'),
+(NULL, 'The Wings of Oxy Claw'),
+(NULL, 'The Wrath of Elton'),
+(NULL, 'The Wut'),
+(NULL, 'The Yoricks Assassins'),
+(NULL, 'The Zeksonic Thieves'),
+(NULL, 'Theramore Azeroth'),
+(NULL, 'Thirstquencher Chaos'),
+(NULL, 'Thralls Caribous'),
+(NULL, 'Three Alive'),
+(NULL, 'Titans of Blood Sun'),
+(NULL, 'Torvus Dragons'),
+(NULL, 'Tower of the Little'),
+(NULL, 'True Team'),
+(NULL, 'Tul Inc'),
+(NULL, 'Twinks of Cold Club'),
+(NULL, 'Twinks of Hidden Venture'),
+(NULL, 'Ultimate Rules'),
+(NULL, 'Undead Kingdom'),
+(NULL, 'Unforgiven Destiny'),
+(NULL, 'Unguilded War'),
+(NULL, 'Unholy Cats'),
+(NULL, 'Unholy Teeth'),
+(NULL, 'Union of Burning Prz'),
+(NULL, 'Unusual Guard'),
+(NULL, 'Valiant Riderz'),
+(NULL, 'Vanguard Omen'),
+(NULL, 'Vanguard Redeemers'),
+(NULL, 'Vanguard of Teutonic'),
+(NULL, 'Vengeful Mayhem'),
+(NULL, 'Verata Blackflame'),
+(NULL, 'Vicious Renegade'),
+(NULL, 'Vile Dead'),
+(NULL, 'Voodoo Hearth'),
+(NULL, 'War Legion'),
+(NULL, 'Warlockian Tree'),
+(NULL, 'Warlords of Kungfu Army'),
+(NULL, 'Warriors of Happy Death'),
+(NULL, 'Warriors of the Tundra'),
+(NULL, 'Warsong Insanity'),
+(NULL, 'Waste of Grey Death'),
+(NULL, 'Wayfarers of Maple Leaf'),
+(NULL, 'Wayward Agenda'),
+(NULL, 'Web of Forgoten Warfare'),
+(NULL, 'Wet Guard'),
+(NULL, 'Wild Fire'),
+(NULL, 'Will of the Forgotten'),
+(NULL, 'Winds of Steve Irwin'),
+(NULL, 'Wings of Emerald Minions'),
+(NULL, 'Wintermane Good'),
+(NULL, 'Witchhunters of Chaos'),
+(NULL, 'With Sea'),
+(NULL, 'Wrath of the Horde Troop'),
+(NULL, 'Wtf Losers'),
+(NULL, 'Xcalibur of Shogunz Depo'),
+(NULL, 'Xelium Determination');
diff --git a/sql/characters_ai_playerbot.sql b/sql/characters_ai_playerbot.sql
new file mode 100644
index 0000000..fdf3535
--- /dev/null
+++ b/sql/characters_ai_playerbot.sql
@@ -0,0 +1,34 @@
+DROP TABLE IF EXISTS `ai_playerbot_random_bots`;
+
+CREATE TABLE `ai_playerbot_random_bots` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `bot` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `event` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `bot` (`bot`),
+  KEY `event` (`event`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
+DROP TABLE IF EXISTS `ai_playerbot_guild_tasks`;
+
+CREATE TABLE `ai_playerbot_guild_tasks` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `guildid` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `type` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `guildid` (`guildid`),
+  KEY `type` (`type`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/sql/characters_ai_playerbot_names.zip b/sql/characters_ai_playerbot_names.zip
new file mode 100644
index 0000000000000000000000000000000000000000..7474032a4145a173409785175c93a0ef369418e1
GIT binary patch
literal 633604
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%0DIH;x-SW(Zdg
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
ciOm5}O9ci1000010097V0001cstEu907uchQUCw|

literal 0
HcmV?d00001

diff --git a/sql/characters_ai_playerbot_real_names.zip b/sql/characters_ai_playerbot_real_names.zip
new file mode 100644
index 0000000000000000000000000000000000000000..e77dc1475daafc9dd056dccb0a0e9c08c577f5b9
GIT binary patch
literal 34800
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

literal 0
HcmV?d00001

diff --git a/sql/characters_auctionhousebot.sql b/sql/characters_auctionhousebot.sql
new file mode 100644
index 0000000..c2d8824
--- /dev/null
+++ b/sql/characters_auctionhousebot.sql
@@ -0,0 +1,37 @@
+DROP TABLE IF EXISTS `ahbot_history`;
+DROP TABLE IF EXISTS `ahbot_category`;
+DROP TABLE IF EXISTS `ahbot_price`;
+
+CREATE TABLE `ahbot_history` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `buytime` bigint(20) NOT NULL,
+  `item` bigint(20) NOT NULL,
+  `bid` bigint(20) NOT NULL,
+  `buyout` bigint(20) NOT NULL,
+  `won` bigint(20) NOT NULL,
+  `category` varchar(45) DEFAULT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `won` (`won`),
+  KEY `category` (`category`),
+  KEY `auction_house` (`auction_house`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_category` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `category` varchar(45) DEFAULT NULL,
+  `multiplier` decimal(20, 2) NOT NULL,
+  `max_auction_count` bigint(20) NOT NULL,
+  `expire_time` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `helper` (`category`, `multiplier`, `expire_time`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_price` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `item` varchar(45) DEFAULT NULL,
+  `price` decimal(20, 2) NOT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `ahbot_price_item` (`item`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 914ad31..a6047d7 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -10,6 +10,7 @@
 
 add_subdirectory(genrev)
 add_subdirectory(common)
+add_subdirectory(plugins)
 
 if(SERVERS)
   add_subdirectory(server)
@@ -18,3 +19,7 @@ endif(SERVERS)
 if(TOOLS)
   add_subdirectory(tools)
 endif(TOOLS)
+
+if(TESTS)
+  add_subdirectory(test)
+endif(TESTS)
diff --git a/src/common/Configuration/Config.h b/src/common/Configuration/Config.h
index 5fb7cef..1979067 100644
--- a/src/common/Configuration/Config.h
+++ b/src/common/Configuration/Config.h
@@ -26,6 +26,8 @@
 
 class ConfigMgr
 {
+// playerbot mod
+public:
     ConfigMgr() { }
     ~ConfigMgr() { }
 
diff --git a/src/plugins/CMakeLists.txt b/src/plugins/CMakeLists.txt
new file mode 100644
index 0000000..fd1923d
--- /dev/null
+++ b/src/plugins/CMakeLists.txt
@@ -0,0 +1,190 @@
+# Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_Playerbot playerbot/*.cpp playerbot/*.h)
+file(GLOB_RECURSE sources_Ahbot ahbot/*.cpp ahbot/*.h)
+
+# Create plugins-libary
+
+if (USE_COREPCH)
+  set(plugins_STAT_PCH_HDR pch/pch.h)
+  set(plugins_STAT_PCH_SRC pch/pch.cpp)
+endif ()
+
+set(plugins_STAT_SRCS
+  ${sources_Playerbot}
+  ${sources_Ahbot}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/cppformat
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/common
+  ${CMAKE_SOURCE_DIR}/src/common/Collision
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Management
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Models
+  ${CMAKE_SOURCE_DIR}/src/common/Configuration
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/common/Debugging
+  ${CMAKE_SOURCE_DIR}/src/common/Logging
+  ${CMAKE_SOURCE_DIR}/src/common/Threading
+  ${CMAKE_SOURCE_DIR}/src/common/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/database
+  ${CMAKE_SOURCE_DIR}/src/server/database/Database
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouseBot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/pluginsObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+)
+
+add_library(plugins STATIC
+  ${plugins_STAT_SRCS}
+  ${plugins_STAT_PCH_SRC}
+)
+
+add_dependencies(plugins revision.h)
+
+if( WIN32 )
+  if ( MSVC )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+ 	  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/playerbot/aiplayerbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/$(ConfigurationName)/
+    )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+ 	  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ahbot/ahbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/$(ConfigurationName)/
+    )
+  elseif ( MINGW )
+
+	 add_custom_command(TARGET plugins
+      POST_BUILD
+      COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}playerbot/aiplayerbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/
+    )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+      COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}ahbot/ahbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/
+    )
+  endif()
+endif()
+
+if( UNIX )
+  install(TARGETS plugins DESTINATION bin)
+  install(FILES playerbot/aiplayerbot.conf.dist.in DESTINATION ${CONF_DIR})
+  install(FILES ahbot/ahbot.conf.dist.in DESTINATION ${CONF_DIR})
+elseif( WIN32 )
+  install(TARGETS plugins DESTINATION "${CMAKE_INSTALL_PREFIX}")
+  install(FILES playerbot/aiplayerbot.conf.dist.in DESTINATION "${CMAKE_INSTALL_PREFIX}")
+  install(FILES ahbot/ahbot.conf.dist.in DESTINATION "${CMAKE_INSTALL_PREFIX}")
+endif()
+
+
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(plugins ${plugins_STAT_PCH_HDR} ${plugins_STAT_PCH_SRC})
+endif ()
diff --git a/src/plugins/ahbot/AhBot.cpp b/src/plugins/ahbot/AhBot.cpp
new file mode 100644
index 0000000..4e9807b
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.cpp
@@ -0,0 +1,983 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBot.h"
+#include "../World/World.h"
+#include "../Chat.h"
+#include "AhBotConfig.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../../game/Entities/Player/Player.h"
+#include "../playerbot/PlayerbotAIConfig.h"
+#include "../playerbot/playerbot.h"
+
+using namespace ahbot;
+
+bool Player::MinimalLoadFromDB( QueryResult result, uint32 guid )
+{
+    if (!result)
+    {
+        //                                        0     1           2           3           4    5          6          7
+        result = CharacterDatabase.PQuery("SELECT name, position_x, position_y, position_z, map, totaltime, leveltime, at_login FROM characters WHERE guid = '%u'",guid);
+        if (!result)
+            return false;
+    }
+
+    Field *fields = result->Fetch();
+
+    m_name = fields[0].GetString();
+
+    Relocate(fields[1].GetFloat(),fields[2].GetFloat(),fields[3].GetFloat());
+    SetLocationMapId(fields[4].GetUInt32());
+
+    m_Played_time[PLAYED_TIME_TOTAL] = fields[5].GetUInt32();
+    m_Played_time[PLAYED_TIME_LEVEL] = fields[6].GetUInt32();
+
+    m_atLoginFlags = fields[7].GetUInt32();
+
+    for (int i = 0; i < PLAYER_SLOTS_COUNT; ++i)
+        m_items[i] = NULL;
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        m_deathState = DEAD;
+
+    return true;
+}
+
+bool AhBot::HandleAhBotCommand(ChatHandler* handler, char const* args)
+{
+    auctionbot.HandleCommand(args);
+    return true;
+}
+
+uint32 AhBot::auctionIds[MAX_AUCTIONS] = {1,6,7};
+uint32 AhBot::auctioneers[MAX_AUCTIONS] = {79707,4656,23442};
+map<uint32, uint32> AhBot::factions;
+
+void AhBot::Init()
+{
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "Initializing AhBot by ike3");
+
+    if (!sAhBotConfig.Initialize())
+        return;
+
+    factions[1] = 1;
+    factions[2] = 1;
+    factions[3] = 1;
+    factions[4] = 2;
+    factions[5] = 2;
+    factions[6] = 2;
+    factions[7] = 3;
+
+    availableItems.Init();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot configuration loaded");
+}
+
+AhBot::~AhBot()
+{
+}
+
+ObjectGuid AhBot::GetAHBplayerGUID()
+{
+    return ObjectGuid(sAhBotConfig.guid);
+}
+
+void AhBotThread(AhBot* ahbot)
+{
+    ahbot->ForceUpdate();
+}
+
+void AhBot::Update()
+{
+    time_t now = time(0);
+
+    if (now < nextAICheckTime)
+        return;
+
+    if (updating)
+        return;
+
+    nextAICheckTime = time(0) + sAhBotConfig.updateInterval;
+
+    thread ahBotThread(AhBotThread, this);
+    ahBotThread.detach();
+}
+
+void AhBot::ForceUpdate()
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (updating)
+        return;
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is now checking auctions");
+    updating = true;
+
+    if (!allBidders.size())
+        LoadRandomBots();
+
+    if (!allBidders.size())
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "Ahbot is disabled but there is no bidders available");
+        return;
+    }
+
+    CheckCategoryMultipliers();
+
+    int answered = 0, added = 0;
+    for (int i = 0; i < MAX_AUCTIONS; i++)
+    {
+        InAuctionItemsBag inAuctionItems(auctionIds[i]);
+        inAuctionItems.Init(true);
+
+        for (int j = 0; j < CategoryList::instance.size(); j++)
+        {
+            Category* category = CategoryList::instance[j];
+            answered += Answer(i, category, &inAuctionItems);
+            added += AddAuctions(i, category, &inAuctionItems);
+        }
+    }
+
+    CleanupHistory();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot auction check finished. %d auctions answered, %d new auctions added. Next check in %d seconds",
+            answered, added, sAhBotConfig.updateInterval);
+    updating = false;
+}
+
+struct SortByPricePredicate
+{
+    bool operator()(AuctionEntry* const & a, AuctionEntry* const & b) const
+    {
+        if (a->startbid == b->startbid)
+            return a->buyout < b->buyout;
+
+        return a->startbid < b->startbid;
+    }
+};
+
+vector<AuctionEntry*> AhBot::LoadAuctions(AuctionHouseObject* auctionHouse,
+        Category*& category, int& auction)
+{
+    vector<AuctionEntry*> entries;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (IsBotAuction(entry->owner) || IsBotAuction(entry->bidder))
+            continue;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item)
+            continue;
+
+        if (!category->Contains(item->GetTemplate()))
+            continue;
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(item->GetTemplate(), auctionIds[auction]);
+        if (!price || !item->GetCount())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price cannot be determined",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        entries.push_back(entry);
+    }
+    sort(entries.begin(), entries.end(), SortByPricePredicate());
+    return entries;
+}
+
+void AhBot::FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+        uint32* minBuyout)
+{
+    *minBid = 0;
+    *minBuyout = 0;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *other = itr->second;
+        if (other->owner == entry->owner)
+            continue;
+
+        Item *otherItem = sAuctionMgr->GetAItem(other->itemGUIDLow);
+        if (!otherItem || !otherItem->GetCount() || otherItem->GetTemplate()->ItemId != item->GetTemplate()->ItemId)
+            continue;
+
+        uint32 startbid = other->startbid / otherItem->GetCount() * item->GetCount();
+        uint32 bid = other->bid / otherItem->GetCount() * item->GetCount();
+        uint32 buyout = other->buyout / otherItem->GetCount() * item->GetCount();
+
+        if (!bid && startbid && (!*minBid || *minBid > startbid))
+            *minBid = startbid;
+
+        if (bid && (*minBid || *minBid > bid))
+            *minBid = bid;
+
+        if (buyout && (!*minBuyout || *minBuyout > buyout))
+            *minBuyout = buyout;
+    }
+}
+
+int AhBot::Answer(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if (!ahEntry)
+        return 0;
+
+    int answered = 0;
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    int64 availableMoney = GetAvailableMoney(auctionIds[auction]);
+
+    vector<AuctionEntry*> entries = LoadAuctions(auctionHouse, category, auction);
+    for (vector<AuctionEntry*>::iterator itr = entries.begin(); itr != entries.end(); ++itr)
+    {
+        AuctionEntry *entry = *itr;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item || !item->GetCount())
+            continue;
+
+        const ItemTemplate* proto = item->GetTemplate();
+        vector<uint32> items = availableItems.Get(category);
+        if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: unavailable item",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 answerCount = GetAnswerCount(proto->ItemId, auctionIds[auction], sAhBotConfig.itemBuyMaxInterval);
+        uint32 maxAnswerCount = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAnswerCount && answerCount > maxAnswerCount)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: answer count %d > %d (max)",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], answerCount, maxAnswerCount);
+            continue;
+        }
+
+        if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: above max required or item level",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+        if (!price)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: cannot determine price",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 bidPrice = item->GetCount() * price;
+        uint32 buyoutPrice = item->GetCount() * urand(price, 4 * price / 3);
+
+        uint32 curPrice = entry->bid;
+        if (!curPrice) curPrice = entry->startbid;
+        if (!curPrice) curPrice = entry->buyout;
+
+        if (curPrice > buyoutPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (buyout price)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, buyoutPrice);
+            continue;
+        }
+
+        if (availableMoney < curPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (available money)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, availableMoney);
+            continue;
+        }
+
+        uint32 minBid = 0, minBuyout = 0;
+        FindMinPrice(auctionHouse, entry, item, &minBid, &minBuyout);
+
+        if (minBid && entry->bid && minBid < entry->bid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (bid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->bid, minBid);
+            continue;
+        }
+
+        if (minBid && entry->startbid && minBid < entry->startbid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (startbid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->startbid, minBid);
+            continue;
+        }
+
+        double priceLevel = (double)curPrice / (double)buyoutPrice;
+        uint32 buytime = GetBuyTime(entry->Id, proto->ItemId, auctionIds[auction], category, priceLevel);
+        if (time(0) < buytime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: will buy/bid in %d seconds",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], buytime - time(0));
+            continue;
+        }
+
+        uint32 bidder = GetRandomBidder(auctionIds[auction]);
+        if (!bidder)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+            break;
+        }
+
+        entry->bidder = bidder;
+        entry->bid = curPrice + urand(1, 1 + bidPrice / 10);
+        availableMoney -= curPrice;
+
+        updateMarketPrice(item->GetTemplate()->ItemId, entry->buyout / item->GetCount(), auctionIds[auction]);
+
+        if ((entry->buyout && (entry->bid >= entry->buyout || 100 * (entry->buyout - entry->bid) / price < 25)) &&
+                !(minBuyout && entry->buyout && minBuyout < entry->buyout))
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d won %s (x%d) in auction %d for %d",
+                    bidder, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->buyout);
+
+            entry->bid = entry->buyout;
+        }
+        else
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d placed bid %d for %s (x%d) in auction %d",
+                    bidder, entry->bid, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'",
+                entry->bidder, entry->bid, entry->Id);
+            AddToHistory(entry, AHBOT_WON_BID);
+        }
+
+        CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = 4 AND auction_house = '%u' ",
+                proto->ItemId, factions[auctionIds[auction]]);
+
+        answered++;
+    }
+
+    return answered;
+}
+
+uint32 AhBot::GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type)
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT MAX(buytime) FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    if (!results)
+        return 0;
+
+    Field* fields = results->Fetch();
+    uint32 result = fields[0].GetUInt32();
+
+    return result;
+}
+
+void AhBot::SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value)
+{
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        value, id, 0, 0,
+        category.c_str(), type, factions[auctionHouse]);
+}
+
+uint32 AhBot::GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel)
+{
+    uint32 entryTime = GetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY);
+    if (entryTime > time(0))
+        return entryTime;
+
+    uint32 result = entryTime;
+
+    string categoryName = category->GetName();
+    uint32 categoryTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel;
+    itemTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel / rarity;
+    entryTime = max(categoryTime, itemTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY, itemTime);
+    SetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY, entryTime);
+
+    return result ? result : entryTime;
+}
+
+uint32 AhBot::GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category)
+{
+    uint32 itemSellTime = GetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 itemBuyTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = max(itemSellTime, itemBuyTime);
+
+    if (itemTime > time(0))
+        return itemTime;
+
+    uint32 result = itemTime;
+
+    string categoryName = category->GetName();
+    uint32 categorySellTime = GetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 categoryBuyTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 categoryTime = max(categorySellTime, categoryBuyTime);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval);
+    itemTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval) * rarity;
+    itemTime = max(itemTime, categoryTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY, itemTime);
+
+    return result ? result : itemTime;
+}
+
+int AhBot::AddAuctions(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    vector<uint32>& inAuction = inAuctionItems->Get(category);
+
+    int32 maxAllowedAuctionCount = categoryMaxAuctionCount[category->GetName()];
+    if (inAuctionItems->GetCount(category) >= maxAllowedAuctionCount)
+        return 0;
+
+    int added = 0;
+    vector<uint32> available = availableItems.Get(category);
+    for (int32 i = 0; i <= maxAllowedAuctionCount && available.size() > 0 && inAuctionItems->GetCount(category) < maxAllowedAuctionCount; ++i)
+    {
+        uint32 index = urand(0, available.size() - 1);
+        uint32 itemId = available[index];
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        int32 maxAllowedItems = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAllowedItems && inAuctionItems->GetCount(category, proto->ItemId) >= maxAllowedItems)
+            continue;
+
+        uint32 sellTime = GetSellTime(proto->ItemId, auctionIds[auction], category);
+        if (time(0) < sellTime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: will add in %d seconds",
+                    proto->Name1.c_str(), auctionIds[auction], sellTime - time(0));
+            continue;
+        }
+        else if (time(0) - sellTime > sAhBotConfig.maxSellInterval)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: too old (%d secs)",
+                    proto->Name1.c_str(), auctionIds[auction], time(0) - sellTime);
+            continue;
+        }
+
+        inAuctionItems->Add(proto);
+        added += AddAuction(auction, category, proto);
+    }
+
+    return added;
+}
+
+int AhBot::AddAuction(int auction, Category* category, ItemTemplate const* proto)
+{
+    uint32 owner = GetRandomBidder(auctionIds[auction]);
+    if (!owner)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+        return 0;
+    }
+
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return 0;
+
+    uint32 price = category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddAuction: market price adjust");
+    updateMarketPrice(proto->ItemId, price, auctionIds[auction]);
+
+    price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+    uint32 stackCount = category->GetStackCount(proto);
+    if (!price || !stackCount)
+        return 0;
+
+    if (urand(0, 100) <= sAhBotConfig.underPriceProbability * 100)
+        price = price * 100 / urand(100, 200);
+
+    uint32 bidPrice = stackCount * price;
+    uint32 buyoutPrice = stackCount * urand(price, 4 * price / 3);
+
+    Item* item = Item::CreateItem(proto->ItemId, stackCount);
+    if (!item)
+        return 0;
+
+    uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(proto->ItemId);
+    if (randomPropertyId)
+        item->SetItemRandomProperties(randomPropertyId);
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return 0;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionEntry* auctionEntry = new AuctionEntry;
+    auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+    auctionEntry->itemGUIDLow = item->GetGUIDLow();
+    auctionEntry->itemEntry = item->GetEntry();
+    auctionEntry->owner = owner;
+    auctionEntry->startbid = bidPrice;
+    auctionEntry->buyout = buyoutPrice;
+    auctionEntry->auctioneer = auctioneers[auction];
+    auctionEntry->bidder = 0;
+    auctionEntry->bid = 0;
+    auctionEntry->deposit = 0;
+    auctionEntry->expire_time = (time_t) (urand(8, 24) * 60 * 60 + time(NULL));
+    auctionEntry->auctionHouseEntry = ahEntry;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    item->SaveToDB(trans);
+    sAuctionMgr->AddAItem(item);
+    auctionHouse->AddAuction(auctionEntry);
+    auctionEntry->SaveToDB(trans);
+
+    auctionHouse->AddAuction(auctionEntry);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d added %d of %s to auction %d for %d..%d", owner, stackCount, proto->Name1.c_str(), auctionIds[auction], bidPrice, buyoutPrice);
+    return 1;
+}
+
+void AhBot::HandleCommand(string command)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (command == "expire")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            Expire(i);
+
+        return;
+    }
+
+    if (command == "stats")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            PrintStats(i);
+
+        return;
+    }
+
+    if (command == "update")
+    {
+        thread ahBotThread(AhBotThread, this);
+        ahBotThread.detach();
+        return;
+    }
+
+    uint32 itemId = atoi(command.c_str());
+    if (!itemId)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot stats - show short summary");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot expire - expire all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot update - update all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot <itemId> - show item price");
+        return;
+    }
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (category->Contains(proto))
+        {
+            vector<uint32> items = availableItems.Get(category);
+            if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+                continue;
+
+            ostringstream out;
+            out << proto->Name1 << " (" << category->GetDisplayName() << "), "
+                    << category->GetMaxAllowedAuctionCount() << "x" << category->GetMaxAllowedItemAuctionCount(proto)
+                    << "x" << category->GetStackCount(proto) << " max"
+                    << "\n";
+            for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+            {
+                const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+                out << "--- auction house " << auctionIds[auction] << "(faction: " << factions[auctionIds[auction]] << ", money: "
+                    << GetAvailableMoney(auctionIds[auction])
+                    << ") ---\n";
+
+                out << "sell: " << category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainSellPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+
+                out << "buy: " << category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainBuyPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+            }
+            sLog->outMessage("ahbot", LOG_LEVEL_INFO, out.str().c_str());
+            break;
+        }
+    }
+}
+
+void AhBot::Expire(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+
+    int count = 0;
+    while (itr != auctionHouse->GetAuctionsEnd())
+    {
+        if (IsBotAuction(itr->second->owner))
+        {
+            itr->second->expire_time = sWorld->GetGameTime();
+            count++;
+        }
+
+        ++itr;
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions marked as expired in auction %d", count, auctionIds[auction]);
+}
+
+void AhBot::PrintStats(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions available on auction house %d", auctionHouse->Getcount(), auctionIds[auction]);
+}
+
+void AhBot::AddToHistory(AuctionEntry* entry, uint32 won)
+{
+    if (!sAhBotConfig.enabled || !entry)
+        return;
+
+    if (!IsBotAuction(entry->owner) && !IsBotAuction(entry->bidder))
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry->itemEntry);
+    if (!proto)
+        return;
+
+    string category = "";
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            category = CategoryList::instance[i]->GetName();
+            break;
+        }
+    }
+
+    if (!won)
+    {
+        won = AHBOT_WON_PLAYER;
+        if (IsBotAuction(entry->bidder))
+            won = AHBOT_WON_SELF;
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddToHistory: market price adjust");
+    int count = entry->itemCount ? entry->itemCount : 1;
+    updateMarketPrice(proto->ItemId, entry->buyout / count, entry->auctionHouseEntry->houseId);
+
+    uint32 now = time(0);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        now, entry->itemEntry, entry->bid ? entry->bid : entry->startbid, entry->buyout,
+        category.c_str(), won, factions[entry->auctionHouseEntry->houseId]);
+}
+
+uint32 AhBot::GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime)
+{
+    uint32 count = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT COUNT(*) FROM ahbot_history WHERE "
+        "item = '%u' AND won in (2, 3) AND auction_house = '%u' AND buytime > '%u'",
+        itemId, factions[auctionHouse], time(0) - withinTime);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            count = fields[0].GetUInt32();
+        } while (results->NextRow());
+    }
+
+    return count;
+}
+
+void AhBot::CleanupHistory()
+{
+    uint32 when = time(0) - 3600 * 24 * sAhBotConfig.historyDays;
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE buytime < '%u'", when);
+}
+
+uint32 AhBot::GetAvailableMoney(uint32 auctionHouse)
+{
+    int64 result = sAhBotConfig.alwaysAvailableMoney;
+
+    map<uint32, uint32> data;
+    data[AHBOT_WON_PLAYER] = 0;
+    data[AHBOT_WON_SELF] = 0;
+
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionHouse);
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT won, SUM(bid) FROM ahbot_history WHERE auction_house = '%u' GROUP BY won HAVING won > 0 ORDER BY won",
+        factions[auctionHouse]);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            data[fields[0].GetUInt32()] = fields[1].GetUInt32();
+
+        } while (results->NextRow());
+    }
+
+    results = CharacterDatabase.PQuery(
+        "SELECT max(buytime) FROM ahbot_history WHERE auction_house = '%u' AND won = '2'",
+        factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 lastBuyTime = fields[0].GetUInt32();
+        uint32 now = time(0);
+        if (lastBuyTime && now > lastBuyTime)
+        result += (now - lastBuyTime) / 3600 / 24 * sAhBotConfig.alwaysAvailableMoney;
+    }
+
+    AuctionHouseObject* auctionHouseObject = sAuctionMgr->GetAuctionsMap(auctionHouse);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouseObject->GetAuctionsBegin(); itr != auctionHouseObject->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (!IsBotAuction(entry->bidder))
+            continue;
+
+        result -= entry->bid;
+    }
+
+    result += (data[AHBOT_WON_PLAYER] - data[AHBOT_WON_SELF]);
+    return result < 0 ? 0 : (uint32)result;
+}
+
+void AhBot::CheckCategoryMultipliers()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT category, multiplier, max_auction_count, expire_time FROM ahbot_category");
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            categoryMultipliers[fields[0].GetString()] = fields[1].GetFloat();
+            categoryMaxAuctionCount[fields[0].GetString()] = fields[2].GetInt32();
+            categoryMultiplierExpireTimes[fields[0].GetString()] = fields[3].GetUInt64();
+
+        } while (results->NextRow());
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        string name = CategoryList::instance[i]->GetName();
+        if (categoryMultiplierExpireTimes[name] <= time(0) || categoryMultipliers[name] <= 0)
+        {
+            categoryMultipliers[name] = (double)urand(20, 100) / 20.0;
+            uint32 maxAllowedAuctionCount = CategoryList::instance[i]->GetMaxAllowedAuctionCount();
+            categoryMaxAuctionCount[name] = urand(maxAllowedAuctionCount / 2, maxAllowedAuctionCount);
+            categoryMultiplierExpireTimes[name] = time(0) + urand(4, 7) * 3600 * 24;
+        }
+
+        CharacterDatabase.PExecute("INSERT INTO ahbot_category (category, multiplier, max_auction_count, expire_time) "
+                "VALUES ('%s', '%f', '%u', '%u')",
+                name.c_str(), categoryMultipliers[name], categoryMaxAuctionCount[name], categoryMultiplierExpireTimes[name]);
+    }
+}
+
+
+void AhBot::updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    if (marketPrice > 0)
+        marketPrice = (marketPrice + price) / 2;
+    else
+        marketPrice = price;
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_price (item, price, auction_house) VALUES ('%u', '%lf', '%u')", itemId, marketPrice, auctionHouse);
+}
+
+bool AhBot::IsBotAuction(uint32 bidder)
+{
+    return allBidders.find(bidder) != allBidders.end();
+}
+
+uint32 AhBot::GetRandomBidder(uint32 auctionHouse)
+{
+    vector<uint32> guids = bidders[factions[auctionHouse]];
+    if (guids.empty())
+        return 0;
+
+    vector<uint32> online;
+    for (vector<uint32>::iterator i = guids.begin(); i != guids.end(); ++i)
+    {
+        uint32 guid = *i;
+        Player* player = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (!player)
+            continue;
+
+        online.push_back(guid);
+    }
+
+    if (online.empty())
+        return 0;
+
+    int index = urand(0, online.size() - 1);
+    return online[index];
+}
+
+void AhBot::LoadRandomBots()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            uint32 auctionHouse = PlayerbotAI::IsOpposing(race, RACE_HUMAN) ? 2 : 1;
+            bidders[auctionHouse].push_back(guid);
+            bidders[3].push_back(guid);
+            allBidders.insert(guid);
+        } while (result->NextRow());
+    }
+
+    if (allBidders.empty() && sAhBotConfig.guid)
+    {
+        uint32 guid = sAhBotConfig.guid;
+        allBidders.insert(guid);
+        for (int i = 1; i <= 3; i++)
+        {
+            bidders[i].push_back(guid);
+        }
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "{A=%d,H=%d,N=%d} bidders loaded", bidders[1].size(), bidders[2].size(), bidders[3].size());
+}
+
+int32 AhBot::GetSellPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+            if (!price)
+                price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+int32 AhBot::GetBuyPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+            if (!price)
+                continue;
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+double AhBot::GetRarityPriceMultiplier(const ItemTemplate* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 1.0;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        return category->GetPricingStrategy()->GetRarityPriceMultiplier(proto->ItemId);
+    }
+
+    return 1.0;
+
+}
diff --git a/src/plugins/ahbot/AhBot.h b/src/plugins/ahbot/AhBot.h
new file mode 100644
index 0000000..4b704fb
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "Category.h"
+#include "ItemBag.h"
+#include "../playerbot/PlayerbotAIBase.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../pchdef.h"
+
+#define MAX_AUCTIONS 3
+#define AHBOT_WON_EXPIRE 0
+#define AHBOT_WON_PLAYER 1
+#define AHBOT_WON_SELF 2
+#define AHBOT_WON_BID 3
+#define AHBOT_WON_DELAY 4
+#define AHBOT_SELL_DELAY 5
+
+namespace ahbot
+{
+    using namespace std;
+
+    class AhBot
+    {
+    public:
+        AhBot() : nextAICheckTime(0), updating(false) {}
+        virtual ~AhBot();
+        static AhBot& instance()
+        {
+            static AhBot instance;
+            return instance;
+        }
+
+    public:
+        static bool HandleAhBotCommand(ChatHandler* handler, char const* args);
+        ObjectGuid GetAHBplayerGUID();
+        void Init();
+        void Update();
+        void ForceUpdate();
+        void HandleCommand(string command);
+        void Won(AuctionEntry* entry) { AddToHistory(entry); }
+        void Expired(AuctionEntry* entry) {}
+
+        double GetCategoryMultiplier(string category)
+        {
+            return categoryMultipliers[category];
+        }
+
+        int32 GetSellPrice(const ItemTemplate* proto);
+        int32 GetBuyPrice(const ItemTemplate* proto);
+        double GetRarityPriceMultiplier(const ItemTemplate* proto);
+
+    private:
+        int Answer(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuctions(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuction(int auction, Category* category, const ItemTemplate* proto);
+        void Expire(int auction);
+        void PrintStats(int auction);
+        void AddToHistory(AuctionEntry* entry, uint32 won = 0);
+        void CleanupHistory();
+        uint32 GetAvailableMoney(uint32 auctionHouse);
+        void CheckCategoryMultipliers();
+        void updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse);
+        bool IsBotAuction(uint32 bidder);
+        uint32 GetRandomBidder(uint32 auctionHouse);
+        void LoadRandomBots();
+        uint32 GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime);
+        vector<AuctionEntry*> LoadAuctions(AuctionHouseObject* auctionHouse, Category*& category,
+                int& auction);
+        void FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+                uint32* minBuyout);
+        uint32 GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel);
+        uint32 GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type);
+        void SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value);
+        uint32 GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category);
+
+    public:
+        static uint32 auctionIds[MAX_AUCTIONS];
+        static uint32 auctioneers[MAX_AUCTIONS];
+        static map<uint32, uint32> factions;
+
+    private:
+        AvailableItemsBag availableItems;
+        time_t nextAICheckTime;
+        map<string, double> categoryMultipliers;
+        map<string, uint32> categoryMaxAuctionCount;
+        map<string, uint64> categoryMultiplierExpireTimes;
+        map<uint32, vector<uint32> > bidders;
+        set<uint32> allBidders;
+        bool updating;
+    };
+};
+
+#define auctionbot ahbot::AhBot::instance()
diff --git a/src/plugins/ahbot/AhBotConfig.cpp b/src/plugins/ahbot/AhBotConfig.cpp
new file mode 100644
index 0000000..0ec2fd4
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.cpp
@@ -0,0 +1,60 @@
+#include "../pchdef.h"
+#include "AhBotConfig.h"
+
+std::vector<std::string> split(const std::string &s, char delim);
+
+using namespace std;
+
+AhBotConfig::AhBotConfig()
+{
+}
+
+template <class T>
+void LoadSet(string value, T &res)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        res.insert(id);
+    }
+}
+
+bool AhBotConfig::Initialize()
+{
+    string error;
+    if (!config.LoadInitial("ahbot.conf", error))
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled. Unable to open configuration file ahbot.conf");
+        return false;
+    }
+
+    // FEYZEE: change defaults to false because of lag
+    enabled = config.GetBoolDefault("AhBot.Enabled", false);
+
+    if (!enabled)
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled in ahbot.conf");
+
+    guid = (uint64)config.GetIntDefault("AhBot.GUID", 0);
+    updateInterval = config.GetIntDefault("AhBot.UpdateIntervalInSeconds", 300);
+    historyDays = config.GetIntDefault("AhBot.History.Days", 30);
+    itemBuyMinInterval = config.GetIntDefault("AhBot.ItemBuyMinInterval", 7200);
+    itemBuyMaxInterval = config.GetIntDefault("AhBot.ItemBuyMaxInterval", 28800);
+    itemSellMinInterval = config.GetIntDefault("AhBot.ItemSellMinInterval", 7200);
+    itemSellMaxInterval = config.GetIntDefault("AhBot.ItemSellMaxInterval", 28800);
+    maxSellInterval = config.GetIntDefault("AhBot.MaxSellInterval", 3600 * 8);
+    alwaysAvailableMoney = config.GetIntDefault("AhBot.AlwaysAvailableMoney", 200000);
+    priceMultiplier = config.GetFloatDefault("AhBot.PriceMultiplier", 1.0f);
+    defaultMinPrice = config.GetIntDefault("AhBot.DefaultMinPrice", 20);
+    maxItemLevel = config.GetIntDefault("AhBot.MaxItemLevel", 199);
+    maxRequiredLevel = config.GetIntDefault("AhBot.MaxRequiredLevel", 80);
+    priceQualityMultiplier = config.GetFloatDefault("AhBot.PriceQualityMultiplier", 1.0f);
+    underPriceProbability = config.GetFloatDefault("AhBot.UnderPriceProbability", 0.05f);
+    LoadSet<set<uint32> >(config.GetStringDefault("AhBot.IgnoreItemIds", "49283,52200,8494,6345,6891,2460,37164,34835"), ignoreItemIds);
+
+
+    return enabled;
+}
diff --git a/src/plugins/ahbot/AhBotConfig.h b/src/plugins/ahbot/AhBotConfig.h
new file mode 100644
index 0000000..dbbbacc
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "Config.h"
+
+using namespace std;
+
+class AhBotConfig
+{
+public:
+    AhBotConfig();
+    static AhBotConfig& instance()
+    {
+        static AhBotConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+
+    bool enabled;
+    uint64 guid;
+    uint32 updateInterval;
+    uint32 historyDays, maxSellInterval;
+    uint32 itemBuyMinInterval, itemBuyMaxInterval;
+    uint32 itemSellMinInterval, itemSellMaxInterval;
+    uint32 alwaysAvailableMoney;
+    float priceMultiplier, priceQualityMultiplier;
+    uint32 defaultMinPrice;
+    uint32 maxItemLevel, maxRequiredLevel;
+    float underPriceProbability;
+    std::set<uint32> ignoreItemIds;
+
+    float GetSellPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(sellPriceMultipliers, "PriceMultiplier.Sell", category, 1.0f);
+    }
+
+    float GetBuyPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(buyPriceMultipliers, "PriceMultiplier.Buy", category, 1.0f);
+    }
+
+    float GetItemPriceMultiplier(string name)
+    {
+        return GetCategoryParameter(itemPriceMultipliers, "PriceMultiplier.Item", name, 1.0f);
+    }
+
+    int32 GetMaxAllowedAuctionCount(string category)
+    {
+        return (int32)GetCategoryParameter(maxAuctionCount, "MaxAuctionCount", category, 5);
+    }
+
+    std::string GetStringDefault(const char* name, const char* def)
+    {
+        return config.GetStringDefault(name, def);
+    }
+
+    bool GetBoolDefault(const char* name, const bool def = false)
+    {
+        return config.GetBoolDefault(name, def);
+    }
+
+    int32 GetIntDefault(const char* name, const int32 def)
+    {
+        return config.GetIntDefault(name, def);
+    }
+
+    float GetFloatDefault(const char* name, const float def)
+    {
+        return config.GetFloatDefault(name, def);
+    }
+
+private:
+    float GetCategoryParameter(map<string, float>& cache, string type, string category, float defaultValue)
+    {
+        if (cache.find(category) == cache.end())
+        {
+            ostringstream out; out << "AhBot."<< type << "." << category;
+            cache[category] = config.GetFloatDefault(out.str().c_str(), defaultValue);
+        }
+
+        return cache[category];
+    }
+
+private:
+    ConfigMgr config;
+    map<string, float> sellPriceMultipliers;
+    map<string, float> buyPriceMultipliers;
+    map<string, float> itemPriceMultipliers;
+    map<string, float> maxAuctionCount;
+};
+
+#define sAhBotConfig AhBotConfig::instance()
diff --git a/src/plugins/ahbot/Category.cpp b/src/plugins/ahbot/Category.cpp
new file mode 100644
index 0000000..1dd0ac5
--- /dev/null
+++ b/src/plugins/ahbot/Category.cpp
@@ -0,0 +1,76 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "PricingStrategy.h"
+
+using namespace ahbot;
+
+uint32 Category::GetStackCount(ItemTemplate const* proto)
+{
+    if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+        return 1;
+
+    return urand(1, proto->GetMaxStackSize());
+}
+
+uint32 Category::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return 0;
+}
+
+uint32 Category::GetMaxAllowedAuctionCount()
+{
+    return sAhBotConfig.GetMaxAllowedAuctionCount(GetName());
+}
+
+PricingStrategy* Category::GetPricingStrategy()
+{
+    if (pricingStrategy)
+        return pricingStrategy;
+
+    ostringstream out; out << "AhBot.PricingStrategy." << GetName();
+    string name = sAhBotConfig.GetStringDefault(out.str().c_str(), "default");
+    return pricingStrategy = PricingStrategyFactory::Create(name, this);
+}
+
+QualityCategoryWrapper::QualityCategoryWrapper(Category* category, uint32 quality) : Category(), quality(quality), category(category)
+{
+    ostringstream out; out << category->GetName() << ".";
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR:
+        out << "gray";
+        break;
+    case ITEM_QUALITY_NORMAL:
+        out << "white";
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        out << "green";
+        break;
+    case ITEM_QUALITY_RARE:
+        out << "blue";
+        break;
+    default:
+        out << "epic";
+        break;
+    }
+
+    combinedName = out.str();
+}
+
+bool QualityCategoryWrapper::Contains(ItemTemplate const* proto)
+{
+    return proto->Quality == quality && category->Contains(proto);
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedAuctionCount()
+{
+    uint32 count = sAhBotConfig.GetMaxAllowedAuctionCount(combinedName);
+    return count > 0 ? count : category->GetMaxAllowedAuctionCount();
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return category->GetMaxAllowedItemAuctionCount(proto);
+}
diff --git a/src/plugins/ahbot/Category.h b/src/plugins/ahbot/Category.h
new file mode 100644
index 0000000..ed528dd
--- /dev/null
+++ b/src/plugins/ahbot/Category.h
@@ -0,0 +1,354 @@
+#pragma once
+#include "PricingStrategy.h"
+#include "../Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category
+    {
+    public:
+        Category() : pricingStrategy(NULL) {}
+        virtual ~Category() { if (pricingStrategy) delete pricingStrategy; }
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto) { return false; }
+        virtual string GetName() { return "default"; }
+        virtual string GetDisplayName() { return GetName(); }
+
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto);
+
+        virtual PricingStrategy* GetPricingStrategy();
+
+    private:
+        PricingStrategy *pricingStrategy;
+    };
+
+    class Consumable : public Category
+    {
+    public:
+        Consumable() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONSUMABLE;
+        }
+
+        virtual string GetName() { return "consumable"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 10;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (maxStackSize == 1)
+                return 1;
+
+            if (maxStackSize <= 10)
+                return urand(1, 10);
+
+            return urand(1, 4) * maxStackSize / 5;
+        }
+    };
+
+    class Quest : public Category
+    {
+    public:
+        Quest() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUEST;
+        }
+        virtual string GetName() { return "quest"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (proto->Quality == ITEM_QUALITY_UNCOMMON && maxStackSize > 10)
+                maxStackSize = urand(1, 10);
+
+            if (maxStackSize > 20)
+                maxStackSize = urand(1, 20);
+
+            return maxStackSize;
+        }
+    };
+
+    class Trade : public Category
+    {
+    public:
+        Trade() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_TRADE_GOODS;
+        }
+        virtual string GetName() { return "trade"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            uint32 maxStack = proto->GetMaxStackSize();
+            if (maxStack < 2)
+                return maxStack;
+
+            switch (proto->Quality)
+            {
+            case ITEM_QUALITY_NORMAL:
+                return maxStack;
+            case ITEM_QUALITY_UNCOMMON:
+                return urand(1, maxStack);
+            }
+
+            return 1;
+        }
+    };
+
+    class Enchant : public Category
+    {
+    public:
+        Enchant() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PERMANENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "enchant"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Reagent : public Category
+    {
+    public:
+        Reagent() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_REAGENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "reagent"; }
+    };
+
+    class Recipe : public Category
+    {
+    public:
+        Recipe() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_RECIPE && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "recipe"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Equip : public Category
+    {
+    public:
+        Equip() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return (proto->Class == ITEM_CLASS_WEAPON ||
+                proto->Class == ITEM_CLASS_ARMOR) && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "equip"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Other : public Category
+    {
+    public:
+        Other() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Quality > ITEM_QUALITY_POOR && (
+                proto->Class == ITEM_CLASS_MISC ||
+                proto->Class == ITEM_CLASS_GENERIC ||
+                proto->Class == ITEM_CLASS_MONEY) && proto->ItemLevel > 1 && proto->SubClass != ITEM_SUBCLASS_JUNK_MOUNT;
+        }
+        virtual string GetName() { return "other"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Quiver : public Category
+    {
+    public:
+        Quiver() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUIVER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "quiver"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Projectile : public Category
+    {
+    public:
+        Projectile() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PROJECTILE;
+        }
+
+        virtual string GetName() { return "projectile"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return proto->GetMaxStackSize();
+        }
+    };
+
+    class Container : public Category
+    {
+    public:
+        Container() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONTAINER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "container"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Glyph : public Category
+    {
+    public:
+        Glyph() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GLYPH;
+        }
+
+        virtual string GetName() { return "glyph"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class QualityCategoryWrapper : public Category
+    {
+    public:
+        QualityCategoryWrapper(Category* category, uint32 quality);
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto);
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual string GetName() { return category->GetName(); }
+        virtual string GetDisplayName() { return combinedName; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto) { return category->GetStackCount(proto); }
+        virtual PricingStrategy* GetPricingStrategy() { return category->GetPricingStrategy(); }
+
+    private:
+        uint32 quality;
+        Category* category;
+        string combinedName;
+    };
+};
diff --git a/src/plugins/ahbot/ConsumableCategory.cpp b/src/plugins/ahbot/ConsumableCategory.cpp
new file mode 100644
index 0000000..2cd06c5
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.cpp
@@ -0,0 +1,5 @@
+#include "../pchdef.h"
+#include "ConsumableCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/ConsumableCategory.h b/src/plugins/ahbot/ConsumableCategory.h
new file mode 100644
index 0000000..6f3051b
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.h
@@ -0,0 +1,86 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Alchemy : public Consumable
+    {
+    public:
+        Alchemy() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION ||
+                    proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK);
+        }
+
+        virtual string GetName() { return "Alchemy"; }
+    };
+
+    class Scroll : public Consumable
+    {
+    public:
+        Scroll() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_SCROLL ||
+                    proto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT);
+        }
+
+        virtual string GetName() { return "Scroll"; }
+    };
+
+    class Food : public Consumable
+    {
+    public:
+        Food() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_FOOD;
+        }
+
+        virtual string GetName() { return "Food"; }
+    };
+
+    class Bandage : public Consumable
+    {
+    public:
+        Bandage() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_BANDAGE;
+        }
+
+        virtual string GetName() { return "Bandage"; }
+    };
+
+    class OtherConsumable : public Consumable
+    {
+    public:
+        OtherConsumable() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) && (proto->RequiredSkill || proto->Flags & ITEM_FLAG_UNK6);
+        }
+
+        virtual string GetName() { return "OtherConsumable"; }
+    };
+};
diff --git a/src/plugins/ahbot/ItemBag.cpp b/src/plugins/ahbot/ItemBag.cpp
new file mode 100644
index 0000000..fb2cfd1
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.cpp
@@ -0,0 +1,184 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "ConsumableCategory.h"
+#include "TradeCategory.h"
+#include "AhBotConfig.h"
+#include "../DataStores/DBCStructure.h"
+#include "Log.h"
+#include "QueryResult.h"
+#include "DatabaseEnv.h"
+#include "DBCStore.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+
+using namespace ahbot;
+char * strstri (const char* str1, const char* str2);
+
+CategoryList CategoryList::instance;
+
+CategoryList::CategoryList()
+{
+    Add(new Equip());
+    Add(new ahbot::Quest());
+    Add(new Quiver());
+    Add(new Projectile());
+
+    Add(new Recipe());
+    Add(new Container());
+
+    Add(new Reagent());
+    Add(new Enchant());
+    Add(new Alchemy());
+    Add(new Scroll());
+    Add(new Food());
+    Add(new Bandage());
+
+    Add(new Cloth());
+    Add(new Leather());
+    Add(new Herb());
+    Add(new Metal());
+    Add(new Disenchants());
+    Add(new Meat());
+    Add(new Engineering());
+    Add(new SimpleGems());
+    Add(new SocketGems());
+    Add(new Elemental());
+
+    Add(new Glyph());
+
+    Add(new OtherConsumable());
+    Add(new OtherTrade());
+    Add(new Other());
+}
+
+void CategoryList::Add(Category* category)
+{
+    for (uint32 quality = ITEM_QUALITY_NORMAL; quality <= ITEM_QUALITY_EPIC; ++quality)
+        categories.push_back(new QualityCategoryWrapper(category, quality));
+}
+
+CategoryList::~CategoryList()
+{
+    for (vector<Category*>::const_iterator i = categories.begin(); i != categories.end(); ++i)
+        delete *i;
+}
+
+ItemBag::ItemBag()
+{
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        content[CategoryList::instance[i]] = vector<uint32>();
+    }
+}
+
+void ItemBag::Init(bool silent)
+{
+    if (silent)
+    {
+        Load();
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Loading/Scanning %s...", GetName().c_str());
+
+    Load();
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        Shuffle(content[category]);
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "loaded %d %s items", content[category].size(), category->GetDisplayName().c_str());
+    }
+}
+
+int32 ItemBag::GetCount(Category* category, uint32 item)
+{
+    uint32 count = 0;
+
+    vector<uint32>& items = content[category];
+    for (vector<uint32>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        if (*i == item)
+            count++;
+    }
+
+    return count;
+}
+
+bool ItemBag::Add(ItemTemplate const* proto)
+{
+    if (!proto ||
+        proto->Bonding == BIND_WHEN_PICKED_UP ||
+        proto->Bonding == BIND_QUEST_ITEM)
+        return false;
+
+    if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        return false;
+
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+        return false;
+
+    if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+        return false;
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            content[CategoryList::instance[i]].push_back(proto->ItemId);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void AvailableItemsBag::Load()
+{
+    set<uint32> vendorItems;
+
+      QueryResult results = WorldDatabase.PQuery("SELECT item FROM npc_vendor where maxcount = 0");
+      if (results != NULL)
+      {
+          do
+          {
+              Field* fields = results->Fetch();
+              vendorItems.insert(fields[0].GetUInt32());
+          } while (results->NextRow());
+      }
+
+      ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+      for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+      {
+          ItemTemplate const& itemTemplate = i->second;
+          uint32 itemId = i->first;
+
+          if (vendorItems.find(itemTemplate.ItemId) != vendorItems.end())
+              continue;
+
+        Add(sObjectMgr->GetItemTemplate(itemId));
+    }
+
+}
+
+void InAuctionItemsBag::Load()
+{
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionId);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->second->itemEntry);
+        if (!proto)
+            continue;
+
+        Add(proto);
+    }
+}
+
+string InAuctionItemsBag::GetName()
+{
+    ostringstream out; out << "auction house " << auctionId;
+    return out.str();
+}
diff --git a/src/plugins/ahbot/ItemBag.h b/src/plugins/ahbot/ItemBag.h
new file mode 100644
index 0000000..6fb936b
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.h
@@ -0,0 +1,82 @@
+#pragma once
+#include "Category.h"
+
+namespace ahbot
+{
+    using namespace std;
+
+    class CategoryList
+    {
+    public:
+        CategoryList();
+        virtual ~CategoryList();
+
+        Category* operator[](int index) { return categories[index]; }
+        int32 size() { return categories.size(); }
+        static CategoryList instance;
+
+    private:
+        void Add(Category* category);
+
+    private:
+        vector<Category*> categories;
+    };
+
+    template<class T>
+    void Shuffle(vector<T>& items)
+    {
+        uint32 count = items.size();
+        for (uint32 i = 0; i < count * 5; i++)
+        {
+            int i1 = urand(0, count - 1);
+            int i2 = urand(0, count - 1);
+
+            T item = items[i1];
+            items[i1] = items[i2];
+            items[i2] = item;
+        }
+    }
+
+    class ItemBag
+    {
+    public:
+        ItemBag();
+
+    public:
+        void Init(bool silent = false);
+        vector<uint32>& Get(Category* category) { return content[category]; }
+        int32 GetCount(Category* category) { return content[category].size(); }
+        int32 GetCount(Category* category, uint32 item);
+        bool Add(ItemTemplate const* proto);
+
+    protected:
+        virtual void Load() = 0;
+        virtual string GetName() = 0;
+
+    protected:
+        map<Category*,vector<uint32> > content;
+    };
+
+    class AvailableItemsBag : public ItemBag
+    {
+    public:
+        AvailableItemsBag() {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName() { return "available"; }
+    };
+
+    class InAuctionItemsBag : public ItemBag
+    {
+    public:
+        InAuctionItemsBag(uint32 auctionId) : auctionId(auctionId) {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName();
+
+    private:
+        uint32 auctionId;
+    };
+};
diff --git a/src/plugins/ahbot/PricingStrategy.cpp b/src/plugins/ahbot/PricingStrategy.cpp
new file mode 100644
index 0000000..0a62b96
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.cpp
@@ -0,0 +1,220 @@
+#include "PricingStrategy.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "DatabaseEnv.h"
+#include "AhBot.h"
+
+using namespace ahbot;
+
+uint32 PricingStrategy::GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    uint32 now = time(0);
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(now, auctionHouse) *
+        GetItemPriceMultiplier(proto, now, auctionHouse) *
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) *
+        GetDefaultSellPrice(proto);
+    return (uint32)price;
+}
+
+double PricingStrategy::GetMarketPrice(uint32 itemId, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    return marketPrice;
+}
+
+uint32 PricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+
+    if (marketPrice > 0)
+        return marketPrice;
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) *
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) *
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) *
+        GetDefaultBuyPrice(proto);
+    return (uint32)price;
+}
+
+string PricingStrategy::ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    uint32 untilTime = time(0);
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rariry) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) << " (sell) * " <<
+        GetDefaultSellPrice(proto) << " (price)";
+    return out.str();
+}
+
+string PricingStrategy::ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+    if (marketPrice > 0)
+    {
+        out << marketPrice << " (market)";
+        return out.str();
+    }
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rarity) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) << " (buy) * " <<
+        GetDefaultBuyPrice(proto) << " (price)";
+    return out.str();
+}
+
+double PricingStrategy::GetRarityPriceMultiplier(uint32 itemId)
+{
+    double result = 1.0;
+
+    QueryResult results = WorldDatabase.PQuery(
+        "select max(Chance) from ( "
+        "select Chance from gameobject_loot_template where item = '%u' "
+        "union select Chance from spell_loot_template where item = '%u' "
+        "union select Chance from disenchant_loot_template where item = '%u' "
+        "union select Chance from fishing_loot_template where item = '%u' "
+        "union select Chance from item_loot_template where item = '%u' "
+        "union select Chance from milling_loot_template where item = '%u' "
+        "union select Chance from pickpocketing_loot_template where item = '%u' "
+        "union select Chance from prospecting_loot_template where item = '%u' "
+        "union select Chance from reference_loot_template where item = '%u' "
+        "union select Chance from skinning_loot_template where item = '%u' "
+        "union select Chance from creature_loot_template where item = '%u' "
+        "union select 0 "
+        ") a",
+        itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        float chance = fields[0].GetFloat();
+
+        if (chance > 0 && chance <= 90.0)
+            result = sqrt((100.0 - chance) / 10.0);
+    }
+
+    return result >= 1.0 ? result : 1.0;
+}
+
+
+double PricingStrategy::GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE category = '%s' AND won = '1' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        category->GetName().c_str(), untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+double PricingStrategy::GetMultiplier(double count, double firstBuyTime, double lastBuyTime)
+{
+    double k1 = (double)count / (double)((time(0) - firstBuyTime) / 3600 / 24 + 1);
+    double k2 = (double)count / (double)((time(0) - lastBuyTime) / 3600 / 24 + 1);
+    return max(1.0, k1 + k2) * sAhBotConfig.priceMultiplier;
+}
+
+double PricingStrategy::GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE won = '1' AND item = '%u' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        proto->ItemId, untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+uint32 PricingStrategy::ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price)
+{
+    if (proto->Quality == ITEM_QUALITY_POOR)
+        return price;
+
+    return (uint32)(price * sqrt((double)proto->Quality) * sAhBotConfig.priceQualityMultiplier);
+}
+
+uint32 PricingStrategy::GetDefaultBuyPrice(ItemTemplate const* proto)
+{
+    uint32 price = 0;
+
+    if (proto->SellPrice)
+        price = proto->SellPrice;
+    if (proto->BuyPrice)
+        price = max(price, (uint32)(proto->BuyPrice / 4));
+
+    uint32 level = max(proto->ItemLevel, proto->RequiredLevel);
+    if (proto->Class == ITEM_CLASS_QUEST)
+    {
+        double result = 1.0;
+
+        QueryResult results = WorldDatabase.PQuery(
+            "select max(Level), max(MinLevel) from quest_template where RequiredItemId1 = %u or RequiredItemId2 = %u or RequiredItemId3 = %u or RequiredItemId4 = %u or RequiredItemId5 = %u or RequiredItemId6 = %u",
+            proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId);
+        if (results)
+        {
+            Field* fields = results->Fetch();
+            level = max(fields[0].GetUInt32(), fields[1].GetUInt32());
+        }
+    }
+    price = max(price, sAhBotConfig.defaultMinPrice * level * level / 10);
+    price = max(price, (uint32)100);
+
+    return ApplyQualityMultiplier(proto, price) * sAhBotConfig.priceMultiplier;
+}
+
+uint32 PricingStrategy::GetDefaultSellPrice(ItemTemplate const* proto)
+{
+    return GetDefaultBuyPrice(proto);
+}
+
+
+uint32 BuyOnlyRarePricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    if (proto->Quality < ITEM_QUALITY_RARE)
+        return 0;
+
+    return PricingStrategy::GetBuyPrice(proto, auctionHouse);
+}
+
diff --git a/src/plugins/ahbot/PricingStrategy.h b/src/plugins/ahbot/PricingStrategy.h
new file mode 100644
index 0000000..ac94724
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "../../game/Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category;
+
+    class PricingStrategy
+    {
+    public:
+        PricingStrategy(Category* category) : category(category) {}
+
+    public:
+        virtual uint32 GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual double GetRarityPriceMultiplier(uint32 itemId);
+
+    protected:
+        virtual uint32 GetDefaultBuyPrice(ItemTemplate const* proto);
+        virtual uint32 GetDefaultSellPrice(ItemTemplate const* proto);
+        virtual uint32 ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price);
+        virtual double GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse);
+        virtual double GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse);
+        double GetMultiplier(double count, double firstBuyTime, double lastBuyTime);
+        double GetMarketPrice(uint32 itemId, uint32 auctionHouse);
+
+    protected:
+        Category* category;
+    };
+
+    class BuyOnlyRarePricingStrategy : public PricingStrategy
+    {
+    public:
+        BuyOnlyRarePricingStrategy(Category* category) : PricingStrategy(category) {}
+
+    public:
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+    };
+
+    class PricingStrategyFactory
+    {
+    public:
+        static PricingStrategy* Create(string name, Category* category)
+        {
+            if (name == "buyOnlyRare")
+                return new BuyOnlyRarePricingStrategy(category);
+
+            return new PricingStrategy(category);
+        }
+    };
+};
diff --git a/src/plugins/ahbot/TradeCategory.cpp b/src/plugins/ahbot/TradeCategory.cpp
new file mode 100644
index 0000000..082ee56
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.cpp
@@ -0,0 +1,4 @@
+#include "TradeCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/TradeCategory.h b/src/plugins/ahbot/TradeCategory.h
new file mode 100644
index 0000000..1d987ba
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.h
@@ -0,0 +1,183 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Cloth : public Trade
+    {
+    public:
+        Cloth() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "Cloth"; }
+    };
+
+    class Leather : public Trade
+    {
+    public:
+        Leather() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_LEATHER;
+        }
+
+        virtual string GetName() { return "Leather"; }
+    };
+
+    class Elemental : public Trade
+    {
+    public:
+        Elemental() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                proto->SubClass == ITEM_SUBCLASS_ELEMENTAL;
+        }
+
+        virtual string GetName() { return "Elemental"; }
+    };
+
+    class Herb : public Trade
+    {
+    public:
+        Herb() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_HERB;
+        }
+
+        virtual string GetName() { return "Herb"; }
+    };
+
+    class Meat : public Trade
+    {
+    public:
+        Meat() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_MEAT;
+        }
+
+        virtual string GetName() { return "Meat"; }
+    };
+
+    class Metal : public Trade
+    {
+    public:
+        Metal() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_METAL_STONE;
+        }
+
+        virtual string GetName() { return "Metal"; }
+    };
+
+    class Disenchants : public Trade
+    {
+    public:
+        Disenchants() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_ENCHANTING;
+        }
+
+        virtual string GetName() { return "Disenchants"; }
+    };
+
+    class SimpleGems : public Trade
+    {
+    public:
+        SimpleGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SimpleGems"; }
+    };
+
+    class SocketGems : public Trade
+    {
+    public:
+        SocketGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SocketGems"; }
+    };
+
+    class Engineering : public Trade
+    {
+    public:
+        Engineering() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_PARTS ||
+                    proto->SubClass == ITEM_SUBCLASS_DEVICES ||
+                    proto->SubClass == ITEM_SUBCLASS_MATERIAL ||
+                    proto->SubClass == ITEM_SUBCLASS_EXPLOSIVES);
+        }
+
+        virtual string GetName() { return "Engineering"; }
+    };
+
+    class OtherTrade : public Trade
+    {
+    public:
+        OtherTrade() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass != ITEM_SUBCLASS_PARTS &&
+                    proto->SubClass != ITEM_SUBCLASS_DEVICES &&
+                    proto->SubClass != ITEM_SUBCLASS_MATERIAL &&
+                    proto->SubClass != ITEM_SUBCLASS_EXPLOSIVES &&
+                    proto->SubClass != ITEM_SUBCLASS_ENCHANTING &&
+                    proto->SubClass != ITEM_SUBCLASS_JEWELCRAFTING &&
+                    proto->SubClass != ITEM_SUBCLASS_METAL_STONE &&
+                    proto->SubClass != ITEM_SUBCLASS_MEAT &&
+                    proto->SubClass != ITEM_SUBCLASS_HERB &&
+                    proto->SubClass != ITEM_SUBCLASS_LEATHER &&
+                    proto->SubClass != ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "OtherTrade"; }
+    };
+};
diff --git a/src/plugins/ahbot/ahbot.conf.dist.in b/src/plugins/ahbot/ahbot.conf.dist.in
new file mode 100644
index 0000000..b2139b3
--- /dev/null
+++ b/src/plugins/ahbot/ahbot.conf.dist.in
@@ -0,0 +1,209 @@
+################################################
+# MANGOS Auction House Bot Configuration file  #
+################################################
+
+[AhbotConf]
+ConfVersion=2010102201
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+###################################################################################################################
+
+# Disable original AuctionHouseBot
+AuctionHouseBot.Seller.Enabled = 0
+AuctionHouseBot.Buyer.Enabled = 0
+
+# Replace with the new AhBot
+AhBot.Enabled = 0
+
+# Should be used only if random bots are disabled
+# AhBot.GUID = 0
+
+# 199 for 80, 80 for 70, 70 for 60, ..., 25 for 20
+AhBot.MaxItemLevel = 199
+# Same as level cap
+AhBot.MaxRequiredLevel = 80
+
+# Ignore items by ID
+AhBot.IgnoreItemIds = 49283,52200,8494,6345,6891,2460
+
+AhBot.PriceMultiplier = 1.0
+AhBot.DefaultMinPrice = 20
+AhBot.PriceQualityMultiplier = 1.0
+AhBot.AlwaysAvailableMoney = 2000000
+
+# Buy/sell delays
+AhBot.ItemBuyMinInterval = 7200
+AhBot.ItemBuyMaxInterval = 28800
+AhBot.ItemSellMinInterval = 7200
+AhBot.ItemSellMaxInterval = 28800
+
+#
+# Items
+#
+
+AhBot.MaxAuctionCount.equip.green = 0
+AhBot.MaxAuctionCount.equip.blue = 40
+AhBot.MaxAuctionCount.equip.epic = 20
+AhBot.PriceMultiplier.Sell.equip = 1.0
+AhBot.PriceMultiplier.Buy.equip = 1.0
+AhBot.PricingStrategy.equip = buyOnlyRare
+
+AhBot.MaxAuctionCount.reagent.white = 6
+AhBot.MaxAuctionCount.reagent.green = 2
+AhBot.PriceMultiplier.Sell.reagent = 1.0
+AhBot.PriceMultiplier.Buy.reagent = 1.0
+AhBot.PricingStrategy.reagent = buyOnlyRare
+
+AhBot.MaxAuctionCount.other.white = 20
+AhBot.MaxAuctionCount.other.green = 10
+AhBot.MaxAuctionCount.other.blue = 6
+AhBot.PriceMultiplier.Sell.other = 1.0
+AhBot.PriceMultiplier.Buy.other = 1.0
+AhBot.PricingStrategy.other = buyOnlyRare
+
+#
+# Container
+#
+
+AhBot.MaxAuctionCount.quiver.white = 2
+AhBot.PriceMultiplier.Sell.quiver = 1.0
+AhBot.PriceMultiplier.Buy.quiver = 1.0
+AhBot.PricingStrategy.quiver = buyOnlyRare
+
+AhBot.MaxAuctionCount.container.white = 6
+AhBot.MaxAuctionCount.container.green = 2
+AhBot.MaxAuctionCount.container.blue = 2
+AhBot.PriceMultiplier.Sell.container = 1.0
+AhBot.PriceMultiplier.Buy.container = 1.0
+
+#
+# Glyph
+#
+
+AhBot.MaxAuctionCount.glyph.white = 50
+AhBot.MaxAuctionCount.glyph.green = 20
+AhBot.MaxAuctionCount.glyph.blue = 10
+AhBot.PriceMultiplier.Sell.glyph = 1.0
+AhBot.PriceMultiplier.Buy.glyph = 1.0
+
+#
+# Quest
+#
+
+AhBot.MaxAuctionCount.quest.white = 14
+AhBot.MaxAuctionCount.quest.green = 2
+AhBot.MaxAuctionCount.quest.blue = 2
+AhBot.PriceMultiplier.Sell.quest = 1.0
+AhBot.PriceMultiplier.Buy.quest = 1.0
+
+#
+# Consumables
+#
+
+AhBot.MaxAuctionCount.alchemy.white = 50
+AhBot.MaxAuctionCount.alchemy.green = 20
+AhBot.MaxAuctionCount.alchemy.blue = 10
+AhBot.PriceMultiplier.Sell.alchemy = 1.0
+AhBot.PriceMultiplier.Buy.alchemy = 1.0
+
+AhBot.MaxAuctionCount.scroll.white = 40
+AhBot.MaxAuctionCount.scroll.green = 6
+AhBot.MaxAuctionCount.scroll.blue = 4
+AhBot.PriceMultiplier.Sell.scroll = 1.0
+AhBot.PriceMultiplier.Buy.scroll = 1.0
+
+AhBot.MaxAuctionCount.Food.white = 40
+AhBot.PriceMultiplier.Sell.Food = 1.0
+AhBot.PriceMultiplier.Buy.Food = 1.0
+
+AhBot.MaxAuctionCount.bandage.white = 10
+AhBot.PriceMultiplier.Sell.bandage = 1.0
+AhBot.PriceMultiplier.Buy.bandage = 1.0
+
+AhBot.MaxAuctionCount.OtherConsumable.white = 20
+AhBot.MaxAuctionCount.OtherConsumable.green = 10
+AhBot.MaxAuctionCount.OtherConsumable.blue = 5
+AhBot.PriceMultiplier.Sell.OtherConsumable = 1.0
+AhBot.PriceMultiplier.Buy.OtherConsumable = 1.0
+
+#
+# Recipe
+#
+
+AhBot.MaxAuctionCount.recipe.white = 8
+AhBot.MaxAuctionCount.recipe.green = 4
+AhBot.MaxAuctionCount.recipe.blue = 2
+AhBot.MaxAuctionCount.recipe.epic = 2
+AhBot.PriceMultiplier.Sell.recipe = 1.0
+AhBot.PriceMultiplier.Buy.recipe = 1.0
+
+#
+# Trade
+#
+
+AhBot.MaxAuctionCount.Elemental.white = 30
+AhBot.MaxAuctionCount.Elemental.green = 20
+AhBot.MaxAuctionCount.Elemental.blue = 6
+AhBot.PriceMultiplier.Sell.Elemental = 1.0
+AhBot.PriceMultiplier.Buy.Elemental = 1.0
+
+AhBot.MaxAuctionCount.Cloth.white = 50
+AhBot.MaxAuctionCount.Cloth.green = 14
+AhBot.MaxAuctionCount.Cloth.blue = 6
+AhBot.PriceMultiplier.Sell.Cloth = 1.0
+AhBot.PriceMultiplier.Buy.Cloth = 1.0
+
+AhBot.MaxAuctionCount.Leather.white = 50
+AhBot.MaxAuctionCount.Leather.green = 14
+AhBot.MaxAuctionCount.Leather.blue = 6
+AhBot.PriceMultiplier.Sell.Leather = 1.0
+AhBot.PriceMultiplier.Buy.Leather = 1.0
+
+AhBot.MaxAuctionCount.Herb.white = 50
+AhBot.MaxAuctionCount.Herb.green = 14
+AhBot.PriceMultiplier.Sell.Herb = 1.0
+AhBot.PriceMultiplier.Buy.Herb = 1.0
+
+AhBot.MaxAuctionCount.Meat.white = 50
+AhBot.PriceMultiplier.Sell.Meat = 1.0
+AhBot.PriceMultiplier.Buy.Meat = 1.0
+
+AhBot.MaxAuctionCount.Metal.white = 50
+AhBot.MaxAuctionCount.Metal.green = 14
+AhBot.MaxAuctionCount.Metal.blue = 6
+AhBot.PriceMultiplier.Sell.Metal = 1.0
+AhBot.PriceMultiplier.Buy.Metal = 1.0
+
+AhBot.MaxAuctionCount.Engineering.white = 20
+AhBot.MaxAuctionCount.Engineering.green = 10
+AhBot.MaxAuctionCount.Engineering.blue = 4
+AhBot.PriceMultiplier.Sell.Engineering = 1.0
+AhBot.PriceMultiplier.Buy.Engineering = 1.0
+
+AhBot.MaxAuctionCount.Disenchants.white = 40
+AhBot.MaxAuctionCount.Disenchants.green = 20
+AhBot.MaxAuctionCount.Disenchants.blue = 20
+AhBot.PriceMultiplier.Sell.Disenchants = 1.0
+AhBot.PriceMultiplier.Buy.Disenchants = 1.0
+
+AhBot.MaxAuctionCount.SimpleGems.green = 30
+AhBot.MaxAuctionCount.SimpleGems.blue = 20
+AhBot.MaxAuctionCount.SimpleGems.epic = 4
+AhBot.PriceMultiplier.Sell.SimpleGems = 1.0
+AhBot.PriceMultiplier.Buy.SimpleGems = 1.0
+
+AhBot.MaxAuctionCount.SocketGems.green = 50
+AhBot.MaxAuctionCount.SocketGems.blue = 20
+AhBot.MaxAuctionCount.SocketGems.epic = 4
+AhBot.PriceMultiplier.Sell.SocketGems = 1.0
+AhBot.PriceMultiplier.Buy.SocketGems = 1.0
+
+AhBot.MaxAuctionCount.OtherTrade.white = 10
+AhBot.PriceMultiplier.Sell.OtherTrade = 1.0
+AhBot.PriceMultiplier.Buy.OtherTrade = 1.0
+
+AhBot.PriceMultiplier.Sell.projectile = 1.0
+AhBot.PriceMultiplier.Buy.projectile = 1.0
+AhBot.PricingStrategy.projectile = buyOnlyRare
diff --git a/src/plugins/pch/pch.cpp b/src/plugins/pch/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/plugins/pch/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/plugins/pch/pch.h b/src/plugins/pch/pch.h
new file mode 100644
index 0000000..c7c6ca5
--- /dev/null
+++ b/src/plugins/pch/pch.h
@@ -0,0 +1,10 @@
+//add here most rarely modified headers to speed up debug build compilation
+
+#include "Common.h"
+#include "MapManager.h"
+#include "Log.h"
+#include "ObjectAccessor.h"
+#include "ObjectDefines.h"
+#include "Opcodes.h"
+#include "SharedDefines.h"
+#include "ObjectMgr.h"
diff --git a/src/plugins/pchdef.h b/src/plugins/pchdef.h
new file mode 100644
index 0000000..f58aae9
--- /dev/null
+++ b/src/plugins/pchdef.h
@@ -0,0 +1,4 @@
+#ifndef PCHDEF_H_
+#define PCHDEF_H_
+
+#endif /* PCHDEF_H_ */
diff --git a/src/plugins/playerbot/AiFactory.cpp b/src/plugins/playerbot/AiFactory.cpp
new file mode 100644
index 0000000..9dd58d7
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.cpp
@@ -0,0 +1,229 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "AiFactory.h"
+#include "strategy/Engine.h"
+
+#include "strategy/priest/PriestAiObjectContext.h"
+#include "strategy/mage/MageAiObjectContext.h"
+#include "strategy/warlock/WarlockAiObjectContext.h"
+#include "strategy/warrior/WarriorAiObjectContext.h"
+#include "strategy/shaman/ShamanAiObjectContext.h"
+#include "strategy/paladin/PaladinAiObjectContext.h"
+#include "strategy/druid/DruidAiObjectContext.h"
+#include "strategy/hunter/HunterAiObjectContext.h"
+#include "strategy/rogue/RogueAiObjectContext.h"
+#include "../Entities/Player/Player.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomPlayerbotMgr.h"
+
+
+AiObjectContext* AiFactory::createAiObjectContext(Player* player, PlayerbotAI* ai)
+{
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return new PriestAiObjectContext(ai);
+        break;
+    case CLASS_MAGE:
+        return new MageAiObjectContext(ai);
+        break;
+    case CLASS_WARLOCK:
+        return new WarlockAiObjectContext(ai);
+        break;
+    case CLASS_WARRIOR:
+        return new WarriorAiObjectContext(ai);
+        break;
+    case CLASS_SHAMAN:
+        return new ShamanAiObjectContext(ai);
+        break;
+    case CLASS_PALADIN:
+        return new PaladinAiObjectContext(ai);
+        break;
+    case CLASS_DRUID:
+        return new DruidAiObjectContext(ai);
+        break;
+    case CLASS_HUNTER:
+        return new HunterAiObjectContext(ai);
+        break;
+    case CLASS_ROGUE:
+        return new RogueAiObjectContext(ai);
+        break;
+    }
+    return new AiObjectContext(ai);
+}
+
+int AiFactory::GetPlayerSpecTab(Player* player)
+{
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    if (c0 >= c1 && c0 >= c2)
+        return 0;
+
+    if (c1 >= c0 && c1 >= c2)
+        return 1;
+
+    return 2;
+}
+
+void AiFactory::AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    engine->addStrategies("attack weak", "racials", "chat", "default", "aoe", "potions", "cast time", "conserve mana", "duel", "pvp", NULL);
+
+    switch (player->getClass())
+    {
+        case CLASS_PRIEST:
+            if (tab == 2)
+            {
+                engine->addStrategies("dps", "threat", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("dps debuff");
+            }
+            else
+                engine->addStrategy("heal");
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_MAGE:
+            if (tab == 0)
+                engine->addStrategies("arcane", "threat", NULL);
+            else if (tab == 1)
+                engine->addStrategies("fire", "fire aoe", "threat", NULL);
+            else
+                engine->addStrategies("frost", "frost aoe", "threat", NULL);
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_WARRIOR:
+            if (tab == 2)
+                engine->addStrategies("tank", "tank aoe", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_SHAMAN:
+            if (tab == 0)
+                engine->addStrategies("caster", "caster aoe", "bmana", "threat", "flee", NULL);
+            else if (tab == 2)
+                engine->addStrategies("heal", "bmana", "flee", NULL);
+            else
+                engine->addStrategies("dps", "melee aoe", "bdps", "threat", NULL);
+            break;
+        case CLASS_PALADIN:
+            if (tab == 1)
+                engine->addStrategies("tank", "tank aoe", "barmor", NULL);
+            else
+                engine->addStrategies("dps", "bdps", "threat", NULL);
+            break;
+        case CLASS_DRUID:
+            if (tab == 0)
+            {
+                engine->addStrategies("caster", "caster aoe", "threat", "flee", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("caster debuff");
+            }
+            else if (tab == 2)
+                engine->addStrategies("heal", "flee", NULL);
+            else
+                engine->addStrategies("bear", "tank aoe", "threat", "flee", NULL);
+            break;
+        case CLASS_HUNTER:
+            engine->addStrategies("dps", "bdps", "threat", NULL);
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+            break;
+        case CLASS_ROGUE:
+            engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_WARLOCK:
+            if (tab == 1)
+                engine->addStrategies("tank", "threat", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+
+            engine->addStrategy("flee");
+            break;
+    }
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        engine->ChangeStrategy(sPlayerbotAIConfig.randomBotCombatStrategies);
+        if (player->getClass() == CLASS_DRUID && player->getLevel() < 20)
+            engine->addStrategies("bear", "threat", NULL);
+    }
+}
+
+Engine* AiFactory::createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* engine = new Engine(facade, AiObjectContext);
+    AddDefaultCombatStrategies(player, facade, engine);
+    return engine;
+}
+
+void AiFactory::AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    switch (player->getClass()){
+        case CLASS_PALADIN:
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+            nonCombatEngine->addStrategy("bmana");
+            break;
+        case CLASS_MAGE:
+            if (tab == 1)
+                nonCombatEngine->addStrategy("bdps");
+            else
+                nonCombatEngine->addStrategy("bmana");
+            break;
+    }
+    nonCombatEngine->addStrategies("nc", "attack weak", "food", "stay", "chat",
+            "default", "quest", "loot", "gather", "duel", "emote", "lfg", NULL);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        nonCombatEngine->ChangeStrategy(sPlayerbotAIConfig.randomBotNonCombatStrategies);
+    }
+
+}
+
+Engine* AiFactory::createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* nonCombatEngine = new Engine(facade, AiObjectContext);
+
+    AddDefaultNonCombatStrategies(player, facade, nonCombatEngine);
+	return nonCombatEngine;
+}
+
+void AiFactory::AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine)
+{
+    deadEngine->addStrategies("dead", "stay", "chat", "default", "follow", NULL);
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        deadEngine->removeStrategy("follow");
+    }
+}
+
+Engine* AiFactory::createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+    Engine* deadEngine = new Engine(facade, AiObjectContext);
+    AddDefaultDeadStrategies(player, facade, deadEngine);
+    return deadEngine;
+}
diff --git a/src/plugins/playerbot/AiFactory.h b/src/plugins/playerbot/AiFactory.h
new file mode 100644
index 0000000..a101092
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.h
@@ -0,0 +1,20 @@
+#pragma once
+
+class Player;
+
+using namespace ai;
+
+class AiFactory
+{
+public:
+    static AiObjectContext* createAiObjectContext(Player* player, PlayerbotAI* ai);
+	static Engine* createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+	static Engine* createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static Engine* createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static void AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine);
+    static void AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine);
+    static void AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine);
+
+public:
+    static int GetPlayerSpecTab(Player* player);
+};
diff --git a/src/plugins/playerbot/ChatFilter.cpp b/src/plugins/playerbot/ChatFilter.cpp
new file mode 100644
index 0000000..8d9656c
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.cpp
@@ -0,0 +1,257 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatFilter.h"
+#include "strategy/values/RtiTargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+string ChatFilter::Filter(string message)
+{
+    if (message.find("@") == string::npos)
+        return message;
+
+    return message.substr(message.find(" ") + 1);
+}
+
+class StrategyChatFilter : public ChatFilter
+{
+public:
+    StrategyChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool tank = message.find("@tank") == 0;
+        if (tank && !ai->IsTank(bot))
+            return "";
+
+        bool dps = message.find("@dps") == 0;
+        if (dps && ai->IsTank(bot))
+            return "";
+
+        bool heal = message.find("@heal") == 0;
+        if (heal && !ai->IsHeal(bot))
+            return "";
+
+        if (tank || dps)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class LevelChatFilter : public ChatFilter
+{
+public:
+    LevelChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        if (message[0] != '@')
+            return message;
+
+        if (message.find("-") != string::npos)
+        {
+            int fromLevel = atoi(message.substr(message.find("@") + 1, message.find("-")).c_str());
+            int toLevel = atoi(message.substr(message.find("-") + 1, message.find(" ")).c_str());
+
+            if (bot->getLevel() >= fromLevel && bot->getLevel() <= toLevel)
+                return ChatFilter::Filter(message);
+
+            return message;
+        }
+
+		int level = atoi(message.substr(message.find("@") + 1, message.find(" ")).c_str());
+        if (bot->getLevel() == level)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class CombatTypeChatFilter : public ChatFilter
+{
+public:
+    CombatTypeChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool melee = message.find("@melee") == 0;
+        bool ranged = message.find("@ranged") == 0;
+
+        if (!melee && !ranged)
+            return message;
+
+        switch (bot->getClass())
+        {
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_DEATH_KNIGHT:
+                if (ranged)
+                    return "";
+                break;
+
+            case CLASS_HUNTER:
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+                if (melee)
+                    return "";
+                break;
+
+            case CLASS_DRUID:
+                if (ranged && ai->IsTank(bot))
+                    return "";
+                if (melee && !ai->IsTank(bot))
+                    return "";
+                break;
+
+            case CLASS_SHAMAN:
+                if (melee && ai->IsHeal(bot))
+                    return "";
+                if (ranged && !ai->IsHeal(bot))
+                    return "";
+                break;
+        }
+
+        return ChatFilter::Filter(message);
+    }
+};
+
+class RtiChatFilter : public ChatFilter
+{
+public:
+    RtiChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        rtis.push_back("@star");
+        rtis.push_back("@circle");
+        rtis.push_back("@diamond");
+        rtis.push_back("@triangle");
+        rtis.push_back("@moon");
+        rtis.push_back("@square");
+        rtis.push_back("@cross");
+        rtis.push_back("@skull");
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+        Group *group = bot->GetGroup();
+        if(!group)
+            return message;
+
+        bool found = false;
+        for (list<string>::iterator i = rtis.begin(); i != rtis.end(); i++)
+        {
+            string rti = *i;
+
+            bool isRti = message.find(rti) == 0;
+            if (!isRti)
+                continue;
+
+            ObjectGuid rtiTarget = group->GetTargetIcon(RtiTargetValue::GetRtiIndex(rti.substr(1)));
+            if (bot->GetGUID() == rtiTarget)
+                return ChatFilter::Filter(message);
+
+            Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+            if (!target)
+                return "";
+
+            if (target->GetGUID() != rtiTarget)
+                return "";
+
+            if (found |= isRti)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    list<string> rtis;
+};
+
+class ClassChatFilter : public ChatFilter
+{
+public:
+    ClassChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        classNames["@death_knight"] = CLASS_DEATH_KNIGHT;
+        classNames["@druid"] = CLASS_DRUID;
+        classNames["@hunter"] = CLASS_HUNTER;
+        classNames["@mage"] = CLASS_MAGE;
+        classNames["@paladin"] = CLASS_PALADIN;
+        classNames["@priest"] = CLASS_PRIEST;
+        classNames["@rogue"] = CLASS_ROGUE;
+        classNames["@shaman"] = CLASS_SHAMAN;
+        classNames["@warlock"] = CLASS_WARLOCK;
+        classNames["@warrior"] = CLASS_WARRIOR;
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool found = false;
+        for (map<string, uint8>::iterator i = classNames.begin(); i != classNames.end(); i++)
+        {
+            bool isClass = message.find(i->first) == 0;
+            if (isClass && bot->getClass() != i->second)
+                return "";
+
+            if (found |= isClass)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    map<string, uint8> classNames;
+};
+
+
+
+CompositeChatFilter::CompositeChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+{
+    filters.push_back(new StrategyChatFilter(ai));
+    filters.push_back(new ClassChatFilter(ai));
+    filters.push_back(new RtiChatFilter(ai));
+    filters.push_back(new CombatTypeChatFilter(ai));
+    filters.push_back(new LevelChatFilter(ai));
+}
+
+CompositeChatFilter::~CompositeChatFilter()
+{
+    for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        delete (*i);
+}
+
+string CompositeChatFilter::Filter(string message)
+{
+    for (int j = 0; j < filters.size(); ++j)
+    {
+        for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        {
+            message = (*i)->Filter(message);
+            if (message.empty())
+                break;
+        }
+    }
+
+    return message;
+}
+
diff --git a/src/plugins/playerbot/ChatFilter.h b/src/plugins/playerbot/ChatFilter.h
new file mode 100644
index 0000000..16dde4d
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.h
@@ -0,0 +1,24 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class ChatFilter : public PlayerbotAIAware
+    {
+    public:
+        ChatFilter(PlayerbotAI* ai) : PlayerbotAIAware(ai) {}
+        virtual string Filter(string message);
+    };
+
+    class CompositeChatFilter : public ChatFilter
+    {
+    public:
+        CompositeChatFilter(PlayerbotAI* ai);
+        virtual ~CompositeChatFilter();
+        string Filter(string message);
+
+    private:
+        list<ChatFilter*> filters;
+    };
+};
diff --git a/src/plugins/playerbot/ChatHelper.cpp b/src/plugins/playerbot/ChatHelper.cpp
new file mode 100644
index 0000000..a84a55c
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.cpp
@@ -0,0 +1,450 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatHelper.h"
+
+using namespace ai;
+using namespace std;
+
+map<string, uint32> ChatHelper::consumableSubClasses;
+map<string, uint32> ChatHelper::tradeSubClasses;
+map<string, uint32> ChatHelper::itemQualities;
+map<string, uint32> ChatHelper::slots;
+map<string, ChatMsg> ChatHelper::chats;
+map<uint8, string> ChatHelper::classes;
+map<uint8, string> ChatHelper::races;
+map<uint8, map<uint8, string> > ChatHelper::specs;
+
+template<class T>
+static bool substrContainsInMap(string searchTerm, map<string, T> searchIn)
+{
+    for (typename map<string, T>::iterator i = searchIn.begin(); i != searchIn.end(); ++i)
+    {
+		string term = i->first;
+		if (term.size() > 1 && searchTerm.find(term) != string::npos)
+            return true;
+    }
+
+    return false;
+}
+
+ChatHelper::ChatHelper(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    itemQualities["poor"] = ITEM_QUALITY_POOR;
+    itemQualities["gray"] = ITEM_QUALITY_POOR;
+    itemQualities["normal"] = ITEM_QUALITY_NORMAL;
+    itemQualities["white"] = ITEM_QUALITY_NORMAL;
+    itemQualities["uncommon"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["green"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["rare"] = ITEM_QUALITY_RARE;
+    itemQualities["blue"] = ITEM_QUALITY_RARE;
+    itemQualities["epic"] = ITEM_QUALITY_EPIC;
+    itemQualities["violet"] = ITEM_QUALITY_EPIC;
+
+    consumableSubClasses["potion"] = ITEM_SUBCLASS_POTION;
+    consumableSubClasses["elixir"] = ITEM_SUBCLASS_ELIXIR;
+    consumableSubClasses["flask"] = ITEM_SUBCLASS_FLASK;
+    consumableSubClasses["scroll"] = ITEM_SUBCLASS_SCROLL;
+    consumableSubClasses["food"] = ITEM_SUBCLASS_FOOD;
+    consumableSubClasses["bandage"] = ITEM_SUBCLASS_BANDAGE;
+    consumableSubClasses["enchant"] = ITEM_SUBCLASS_CONSUMABLE_OTHER;
+
+    tradeSubClasses["cloth"] = ITEM_SUBCLASS_CLOTH;
+    tradeSubClasses["leather"] = ITEM_SUBCLASS_LEATHER;
+    tradeSubClasses["metal"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["stone"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["ore"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["meat"] = ITEM_SUBCLASS_MEAT;
+    tradeSubClasses["herb"] = ITEM_SUBCLASS_HERB;
+    tradeSubClasses["elemental"] = ITEM_SUBCLASS_ELEMENTAL;
+    tradeSubClasses["disenchants"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["enchanting"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["gems"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewels"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewelcrafting"] = ITEM_SUBCLASS_JEWELCRAFTING;
+
+    slots["head"] = EQUIPMENT_SLOT_HEAD;
+    slots["neck"] = EQUIPMENT_SLOT_NECK;
+    slots["shoulder"] = EQUIPMENT_SLOT_SHOULDERS;
+    slots["shirt"] = EQUIPMENT_SLOT_BODY;
+    slots["chest"] = EQUIPMENT_SLOT_CHEST;
+    slots["waist"] = EQUIPMENT_SLOT_WAIST;
+    slots["legs"] = EQUIPMENT_SLOT_LEGS;
+    slots["feet"] = EQUIPMENT_SLOT_FEET;
+    slots["wrist"] = EQUIPMENT_SLOT_WRISTS;
+    slots["hands"] = EQUIPMENT_SLOT_HANDS;
+    slots["finger 1"] = EQUIPMENT_SLOT_FINGER1;
+    slots["finger 2"] = EQUIPMENT_SLOT_FINGER2;
+    slots["trinket 1"] = EQUIPMENT_SLOT_TRINKET1;
+    slots["trinket 2"] = EQUIPMENT_SLOT_TRINKET2;
+    slots["back"] = EQUIPMENT_SLOT_BACK;
+    slots["main hand"] = EQUIPMENT_SLOT_MAINHAND;
+    slots["off hand"] = EQUIPMENT_SLOT_OFFHAND;
+    slots["ranged"] = EQUIPMENT_SLOT_RANGED;
+    slots["tabard"] = EQUIPMENT_SLOT_TABARD;
+
+    chats["party"] = CHAT_MSG_PARTY;
+    chats["p"] = CHAT_MSG_PARTY;
+    chats["guild"] = CHAT_MSG_GUILD;
+    chats["g"] = CHAT_MSG_GUILD;
+    chats["raid"] = CHAT_MSG_RAID;
+    chats["r"] = CHAT_MSG_RAID;
+    chats["whisper"] = CHAT_MSG_WHISPER;
+    chats["w"] = CHAT_MSG_WHISPER;
+
+    classes[CLASS_DRUID] = "druid";
+    specs[CLASS_DRUID][0] = "balance";
+    specs[CLASS_DRUID][1] = "feral combat";
+    specs[CLASS_DRUID][2] = "restoration";
+
+    classes[CLASS_HUNTER] = "hunter";
+    specs[CLASS_HUNTER][0] = "beast mastery";
+    specs[CLASS_HUNTER][1] = "marksmanship";
+    specs[CLASS_HUNTER][2] = "survival";
+
+    classes[CLASS_MAGE] = "mage";
+    specs[CLASS_MAGE][0] = "arcane";
+    specs[CLASS_MAGE][1] = "fire";
+    specs[CLASS_MAGE][2] = "frost";
+
+    classes[CLASS_PALADIN] = "paladin";
+    specs[CLASS_PALADIN][0] = "holy";
+    specs[CLASS_PALADIN][1] = "protection";
+    specs[CLASS_PALADIN][2] = "retribution";
+
+    classes[CLASS_PRIEST] = "priest";
+    specs[CLASS_PRIEST][0] = "discipline";
+    specs[CLASS_PRIEST][1] = "holy";
+    specs[CLASS_PRIEST][2] = "shadow";
+
+    classes[CLASS_ROGUE] = "rogue";
+    specs[CLASS_ROGUE][0] = "assasination";
+    specs[CLASS_ROGUE][1] = "combat";
+    specs[CLASS_ROGUE][2] = "subtlety";
+
+    classes[CLASS_SHAMAN] = "shaman";
+    specs[CLASS_SHAMAN][0] = "elemental";
+    specs[CLASS_SHAMAN][1] = "enhancement";
+    specs[CLASS_SHAMAN][2] = "restoration";
+
+    classes[CLASS_WARLOCK] = "warlock";
+    specs[CLASS_WARLOCK][0] = "affliction";
+    specs[CLASS_WARLOCK][1] = "demonology";
+    specs[CLASS_WARLOCK][2] = "destruction";
+
+    classes[CLASS_WARRIOR] = "warrior";
+    specs[CLASS_WARRIOR][0] = "arms";
+    specs[CLASS_WARRIOR][1] = "fury";
+    specs[CLASS_WARRIOR][2] = "protection";
+
+    races[RACE_BLOODELF] = "Blood Elf";
+    races[RACE_DRAENEI] = "Draenei";
+    races[RACE_DWARF] = "Dwarf";
+    races[RACE_GNOME] = "Gnome";
+    races[RACE_HUMAN] = "Human";
+    races[RACE_NIGHTELF] = "Night Elf";
+    races[RACE_ORC] = "Orc";
+    races[RACE_TAUREN] = "Tauren";
+    races[RACE_TROLL] = "Troll";
+    races[RACE_UNDEAD_PLAYER] = "Undead";
+}
+
+string ChatHelper::formatMoney(uint32 copper)
+{
+    ostringstream out;
+	if (!copper)
+	{
+		out << "0|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+		return out.str();
+	}
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+    out << " ";
+    if (gold > 0)
+        out << gold <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\gold:0|t ";
+    if (silver > 0 && gold < 50)
+        out << silver <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\silver:0|t ";
+	if (copper > 0 && gold < 10)
+		out << copper <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+
+    return out.str();
+}
+
+uint32 ChatHelper::parseMoney(string& text)
+{
+    // if user specified money in ##g##s##c format
+    string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+ItemIds ChatHelper::parseItems(string& text)
+{
+    ItemIds itemIds;
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.insert(id);
+    }
+
+    return itemIds;
+}
+
+string ChatHelper::formatQuest(Quest const* quest)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << quest->GetTitle() << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatGameobject(GameObject* go)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hfound:" << go->GetGUID() << ":" << go->GetEntry() << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatSpell(SpellInfo const *sInfo)
+{
+    ostringstream out;
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[LOCALE_enUS] << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatItem(ItemTemplate const * proto, int count)
+{
+    char color[32];
+    sprintf(color, "%x", ItemQualityColors[proto->Quality]);
+
+    ostringstream out;
+    out << "|c" << color << "|Hitem:" << proto->ItemId
+        << ":0:0:0:0:0:0:0" << "|h[" << proto->Name1
+        << "]|h|r";
+
+    if (count > 1)
+        out << "x" << count;
+
+    return out.str();
+}
+
+ChatMsg ChatHelper::parseChat(string& text)
+{
+    if (chats.find(text) != chats.end())
+        return chats[text];
+
+    return CHAT_MSG_SYSTEM;
+}
+
+string ChatHelper::formatChat(ChatMsg chat)
+{
+    switch (chat)
+    {
+    case CHAT_MSG_GUILD:
+        return "guild";
+    case CHAT_MSG_PARTY:
+        return "party";
+    case CHAT_MSG_WHISPER:
+        return "whisper";
+    case CHAT_MSG_RAID:
+        return "raid";
+    }
+
+    return "unknown";
+}
+
+
+uint32 ChatHelper::parseSpell(string& text)
+{
+    PlayerbotChatHandler handler(ai->GetBot());
+    return handler.extractSpellId(text);
+}
+
+list<ObjectGuid> ChatHelper::parseGameobjects(string& text)
+{
+    list<ObjectGuid> gos;
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        istringstream stream(text.substr(pos, endPos - pos));
+        uint64 guid; stream >> guid;
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        ObjectGuid lootCurrent = ObjectGuid(guid);
+
+        if (guid)
+            gos.push_back(lootCurrent);
+    }
+
+    return gos;
+}
+
+string ChatHelper::formatQuestObjective(string name, int available, int required)
+{
+    ostringstream out;
+    out << "|cFFFFFFFF" << name << (available >= required ? "|c0000FF00: " : "|c00FF0000: ")
+        << available << "/" << required << "|r";
+
+    return out.str();
+}
+
+
+uint32 ChatHelper::parseItemQuality(string text)
+{
+    if (itemQualities.find(text) == itemQualities.end())
+        return MAX_ITEM_QUALITY;
+
+    return itemQualities[text];
+}
+
+bool ChatHelper::parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass)
+{
+    if (text == "questitem")
+    {
+        *itemClass = ITEM_CLASS_QUEST;
+        *itemSubClass = ITEM_SUBCLASS_QUEST;
+        return true;
+    }
+
+    if (consumableSubClasses.find(text) != consumableSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_CONSUMABLE;
+        *itemSubClass = consumableSubClasses[text];
+        return true;
+    }
+
+    if (tradeSubClasses.find(text) != tradeSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_TRADE_GOODS;
+        *itemSubClass = tradeSubClasses[text];
+        return true;
+    }
+
+    return false;
+}
+
+uint32 ChatHelper::parseSlot(string text)
+{
+    if (slots.find(text) != slots.end())
+        return slots[text];
+
+    return EQUIPMENT_SLOT_END;
+}
+
+bool ChatHelper::parseable(string text)
+{
+    return text.find("|H") != string::npos ||
+            text == "questitem" ||
+            substrContainsInMap<uint32>(text, consumableSubClasses) ||
+            substrContainsInMap<uint32>(text, tradeSubClasses) ||
+            substrContainsInMap<uint32>(text, itemQualities) ||
+            substrContainsInMap<uint32>(text, slots) ||
+            substrContainsInMap<ChatMsg>(text, chats) ||
+            parseMoney(text) > 0;
+}
+
+string ChatHelper::formatClass(Player* player, int spec)
+{
+    uint8 cls = player->getClass();
+
+    ostringstream out;
+    out << specs[cls][spec] << " (";
+
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    out << (c0 ? "|h|cff00ff00" : "") << c0 << "|h|cffffffff/";
+    out << (c1 ? "|h|cff00ff00" : "") << c1 << "|h|cffffffff/";
+    out << (c2 ? "|h|cff00ff00" : "") << c2 << "|h|cffffffff";
+
+    out <<  ") " << classes[cls];
+    return out.str();
+}
+
+string ChatHelper::formatClass(uint8 cls)
+{
+    return classes[cls];
+}
+
+string ChatHelper::formatRace(uint8 race)
+{
+    return races[race];
+}
diff --git a/src/plugins/playerbot/ChatHelper.h b/src/plugins/playerbot/ChatHelper.h
new file mode 100644
index 0000000..3d493d1
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.h
@@ -0,0 +1,52 @@
+#pragma once
+
+using namespace std;
+
+typedef set<uint32> ItemIds;
+typedef set<uint32> SpellIds;
+
+#include "../pchdef.h"
+
+namespace ai
+{
+    class ChatHelper : public PlayerbotAIAware
+    {
+    public:
+        ChatHelper(PlayerbotAI* ai);
+
+    public:
+        static string formatMoney(uint32 copper);
+        static uint32 parseMoney(string& text);
+        static ItemIds parseItems(string& text);
+        uint32 parseSpell(string& text);
+        static string formatQuest(Quest const* quest);
+        static string formatItem(ItemTemplate const * proto, int count = 0);
+        static string formatSpell(SpellInfo const *sInfo);
+        static string formatGameobject(GameObject* go);
+        static string formatQuestObjective(string name, int available, int required);
+        static list<ObjectGuid> parseGameobjects(string& text);
+
+        static ChatMsg parseChat(string& text);
+        static string formatChat(ChatMsg chat);
+
+        static string formatClass(Player* player, int spec);
+        static string formatClass(uint8 cls);
+        static string formatRace(uint8 race);
+
+        static uint32 parseItemQuality(string text);
+        static bool parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass);
+        static uint32 parseSlot(string text);
+
+        static bool parseable(string text);
+
+    private:
+        static map<string, uint32> consumableSubClasses;
+        static map<string, uint32> tradeSubClasses;
+        static map<string, uint32> itemQualities;
+        static map<string, uint32> slots;
+        static map<string, ChatMsg> chats;
+        static map<uint8, string> classes;
+        static map<uint8, string> races;
+        static map<uint8, map<uint8, string> > specs;
+    };
+};
diff --git a/src/plugins/playerbot/FleeManager.cpp b/src/plugins/playerbot/FleeManager.cpp
new file mode 100644
index 0000000..d7f93f5
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.cpp
@@ -0,0 +1,160 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "FleeManager.h"
+#include "PlayerbotAIConfig.h"
+#include "../Groups/Group.h"
+
+using namespace ai;
+using namespace std;
+
+void FleeManager::calculateDistanceToPlayers(FleePoint *point)
+{
+	Group* group = bot->GetGroup();
+	if (!group)
+		return;
+
+	for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+		Player* player = gref->GetSource();
+		if(player == bot)
+			continue;
+
+		float d = player->GetDistance(point->x, point->y, point->z);
+		point->toAllPlayers.probe(d);
+		switch (player->getClass()) {
+			case CLASS_HUNTER:
+			case CLASS_MAGE:
+			case CLASS_PRIEST:
+			case CLASS_WARLOCK:
+				point->toRangedPlayers.probe(d);
+				break;
+			case CLASS_PALADIN:
+			case CLASS_ROGUE:
+			case CLASS_WARRIOR:
+				point->toMeleePlayers.probe(d);
+				break;
+		}
+	}
+}
+
+void FleeManager::calculateDistanceToCreatures(FleePoint *point)
+{
+	RangePair &distance = point->toCreatures;
+
+	list<ObjectGuid> units = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<list<ObjectGuid> >("possible targets");
+	for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+		Unit* unit = bot->GetPlayerbotAI()->GetUnit(*i);
+		if (!unit)
+		    continue;
+
+		float d = unit->GetDistance(point->x, point->y, point->z);
+		if (d <= sPlayerbotAIConfig.tooCloseDistance)
+		    continue;
+
+		distance.probe(d);
+	}
+}
+
+void FleeManager::calculatePossibleDestinations(list<FleePoint*> &points)
+{
+	float botPosX = bot->GetPositionX();
+	float botPosY = bot->GetPositionY();
+	float botPosZ = bot->GetPositionZ();
+
+	for (float distance = maxAllowedDistance; distance > sPlayerbotAIConfig.tooCloseDistance + 5.0f; distance -= 5.0f)
+	{
+        for (float angle = -M_PI + followAngle; angle < M_PI + followAngle; angle += M_PI / 16)
+        {
+            float x = botPosX + cos(angle) * distance;
+            float y = botPosY + sin(angle) * distance;
+
+            if (!bot->IsWithinLOS(x, y, botPosZ))
+                continue;
+
+            FleePoint *point = new FleePoint(x, y, botPosZ);
+            calculateDistanceToPlayers(point);
+            calculateDistanceToCreatures(point);
+            points.push_back(point);
+        }
+	}
+}
+
+void FleeManager::cleanup(list<FleePoint*> &points)
+{
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		delete point;
+	}
+	points.clear();
+}
+
+bool FleePoint::isReasonable()
+{
+	return toAllPlayers.max <= sPlayerbotAIConfig.sightDistance && toCreatures.min >= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool FleePoint::isBetterByCreatures(FleePoint* other)
+{
+    return toCreatures.min > 0 && other->toCreatures.min > 0 &&
+            (toCreatures.min - other->toCreatures.min) >= 0;
+}
+
+bool FleePoint::isBetterByAll(FleePoint* other)
+{
+    bool isFartherFromCreatures = isBetterByCreatures(other);
+    bool isNearerToRangedPlayers = toRangedPlayers.max > 0 && other->toRangedPlayers.max > 0 &&
+            (toRangedPlayers.max - other->toRangedPlayers.max) <= 0;
+    bool isFartherFromMeleePlayers = toMeleePlayers.min > 0 && other->toMeleePlayers.min > 0 &&
+            (toMeleePlayers.min - other->toMeleePlayers.min) >= 0;
+
+    return isFartherFromCreatures && (isNearerToRangedPlayers || isFartherFromMeleePlayers);
+}
+
+FleePoint* FleeManager::selectOptimalDestination(list<FleePoint*> &points)
+{
+	FleePoint* byCreatures = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byCreatures || point->isBetterByCreatures(byCreatures)))
+			byCreatures = point;
+	}
+
+	FleePoint* byAll = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byAll || point->isBetterByAll(byAll)))
+		    byAll = point;
+	}
+
+	if (byAll && byCreatures)
+	{
+	    if (byAll->isBetterByCreatures(byCreatures))
+	        return byAll;
+	}
+
+	return byCreatures;
+}
+
+bool FleeManager::CalculateDestination(float* rx, float* ry, float* rz)
+{
+	list<FleePoint*> points;
+	calculatePossibleDestinations(points);
+
+    FleePoint* point = selectOptimalDestination(points);
+    if (!point)
+    {
+        cleanup(points);
+        return false;
+    }
+
+	*rx = point->x;
+	*ry = point->y;
+	*rz = bot->GetPositionZ();
+
+    cleanup(points);
+	return true;
+}
diff --git a/src/plugins/playerbot/FleeManager.h b/src/plugins/playerbot/FleeManager.h
new file mode 100644
index 0000000..3084cdd
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.h
@@ -0,0 +1,83 @@
+#pragma once
+
+using namespace std;
+
+class Player;
+
+namespace ai
+{
+    class Engine;
+
+	class RangePair {
+	public:
+		RangePair() {
+			min = -1.0f;
+			max = -1.0f;
+		}
+
+	public:
+		float min;
+		float max;
+
+	public:
+		void probe(float d) {
+			if (min < 0 || min > d)
+				min = d;
+
+			if (max < 0 || max < d)
+				max = d;
+		}
+	};
+
+	class FleePoint {
+	public:
+		FleePoint(float x, float y, float z) {
+			this->x = x;
+			this->y = y;
+			this->z = z;
+		}
+
+    public:
+        bool isReasonable();
+        bool isBetterByCreatures(FleePoint* other);
+        bool isBetterByAll(FleePoint* other);
+
+	public:
+		float x;
+		float y;
+		float z;
+
+		RangePair toCreatures;
+		RangePair toAllPlayers;
+		RangePair toMeleePlayers;
+		RangePair toRangedPlayers;
+	};
+
+	class FleeManager
+	{
+	public:
+		FleeManager(Player* bot, float maxAllowedDistance, float followAngle) {
+			this->bot = bot;
+			this->maxAllowedDistance = maxAllowedDistance;
+			this->followAngle = followAngle;
+		}
+
+	public:
+		bool CalculateDestination(float* rx, float* ry, float* rz);
+
+	private:
+		void calculatePossibleDestinations(list<FleePoint*> &points);
+		void calculateDistanceToPlayers(FleePoint *point);
+		void calculateDistanceToCreatures(FleePoint *point);
+		void cleanup(list<FleePoint*> &points);
+		FleePoint* selectOptimalDestination(list<FleePoint*> &points);
+		bool isReasonable(FleePoint* point);
+		bool isBetterThan(FleePoint* point, FleePoint* other);
+
+	private:
+		Player* bot;
+		float maxAllowedDistance;
+		float followAngle;
+	};
+
+};
diff --git a/src/plugins/playerbot/GuildTaskMgr.cpp b/src/plugins/playerbot/GuildTaskMgr.cpp
new file mode 100644
index 0000000..e71e3c2
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.cpp
@@ -0,0 +1,697 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "GuildTaskMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "DatabaseEnv.h"
+#include "../../server/game/Mails/Mail.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+#include "RandomItemMgr.h"
+
+char * strstri (const char* str1, const char* str2);
+
+enum GuildTaskType
+{
+    GUILD_TASK_TYPE_NONE = 0,
+    GUILD_TASK_TYPE_ITEM = 1,
+    GUILD_TASK_TYPE_KILL = 2
+};
+
+GuildTaskMgr::GuildTaskMgr()
+{
+}
+
+GuildTaskMgr::~GuildTaskMgr()
+{
+}
+
+void GuildTaskMgr::Update(Player* player, Player* guildMaster)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+        return;
+
+    uint32 guildId = guildMaster->GetGuildId();
+    if (!guildId || !guildMaster->GetPlayerbotAI() || !guildMaster->GetGuild())
+        return;
+
+    if (!player->IsFriendlyTo(guildMaster))
+        return;
+
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel secLevel = guildMaster->GetPlayerbotAI()->GetSecurity()->LevelFor(player, &reason);
+    if (secLevel == PLAYERBOT_SECURITY_DENY_ALL || (secLevel == PLAYERBOT_SECURITY_TALK && reason != PLAYERBOT_DENY_FAR))
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: skipping guild task update - not enough security level, reason = %u",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(), reason);
+        return;
+    }
+
+    uint32 owner = (uint32)player->GetGUID().GetRawValue();
+
+    uint32 activeTask = GetTaskValue(owner, guildId, "activeTask");
+    if (!activeTask)
+    {
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemCount", 0, 0);
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "killCount", 0, 0);
+        SetTaskValue(owner, guildId, "payment", 0, 0);
+        SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+
+        uint32 task = CreateTask(owner, guildId);
+
+        if (task == GUILD_TASK_TYPE_NONE)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error creating guild task",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+
+        uint32 time = urand(sPlayerbotAIConfig.minGuildTaskChangeTime, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "activeTask", task, time);
+        SetTaskValue(owner, guildId, "advertisement", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task %u is set for %u secs",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(),
+                task, time);
+        return;
+    }
+
+    uint32 advertisement = GetTaskValue(owner, guildId, "advertisement");
+    if (!advertisement)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending advertisement",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendAdvertisement(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "advertisement", 1,
+                    urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending advertisement",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 thanks = GetTaskValue(owner, guildId, "thanks");
+    if (!thanks)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending thanks",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendThanks(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending thanks",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 reward = GetTaskValue(owner, guildId, "reward");
+    if (!reward)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending reward",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (Reward(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending reward",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+}
+
+uint32 GuildTaskMgr::CreateTask(uint32 owner, uint32 guildId)
+{
+    switch (urand(0, 1))
+    {
+    case 0:
+        CreateItemTask(owner, guildId);
+        return GUILD_TASK_TYPE_ITEM;
+    default:
+        CreateKillTask(owner, guildId);
+        return GUILD_TASK_TYPE_KILL;
+    }
+}
+
+bool GuildTaskMgr::CreateItemTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK);
+    if (!itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no items avaible for item task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 count = GetMaxItemTaskCount(itemId);
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item task %u (x%d)",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            itemId, count);
+
+    SetTaskValue(owner, guildId, "itemCount", count, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    SetTaskValue(owner, guildId, "itemTask", itemId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::CreateKillTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    vector<uint32> ids;
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.rank != CREATURE_ELITE_RARE)
+            continue;
+
+        if (co.minlevel > player->getLevel() || co.maxlevel < player->getLevel() - 5)
+            continue;
+
+        ids.push_back(i->first);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no rare creatures available for kill task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    uint32 creatureId = ids[index];
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: kill task %u",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            creatureId);
+
+    SetTaskValue(owner, guildId, "killTask", creatureId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::SendAdvertisement(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask)
+        return SendItemAdvertisement(itemTask, owner, guildId);
+
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask");
+    if (killTask)
+        return SendKillAdvertisement(killTask, owner, guildId);
+
+    return false;
+}
+
+bool GuildTaskMgr::SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "We are in a great need of " << proto->Name1 << ". If you could sell us ";
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (count > 1)
+        body << "at least " << count << " of them ";
+    else
+        body << "some ";
+    body << "we'd really appreciate that and pay a high price.\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+    MailDraft("Guild Task Advertisement", body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+
+bool GuildTaskMgr::SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(creatureId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "As you probably know " << proto->Name << " is wanted dead for the crimes it did against our guild. If you should kill it ";
+    body << "we'd really appreciate that.\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+    MailDraft("Guild Task Advertisement", body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+bool GuildTaskMgr::SendThanks(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        ostringstream body;
+        body << "Hello, " << player->GetName() << ",\n";
+        body << "\n";
+        body << "One of our guild members wishes to thank you for the " << proto->Name1 << "! If we have another ";
+        uint32 count = GetTaskValue(owner, guildId, "itemCount");
+        body << count << " of them that would help us tremendously.\n";
+        body << "\n";
+        body << "Thanks again,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+
+        MailDraft("Thank You", body.str()).
+                AddMoney(GetTaskValue(owner, guildId, "payment")).
+                SendMailTo(trans, MailReceiver(player), MailSender(leader));
+
+        CharacterDatabase.CommitTransaction(trans);
+
+        return true;
+    }
+
+    return false;
+}
+
+uint32 GuildTaskMgr::GetMaxItemTaskCount(uint32 itemId)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return 0;
+
+    if (proto->Quality < ITEM_QUALITY_RARE && proto->Stackable && proto->GetMaxStackSize() > 1)
+        return proto->GetMaxStackSize();
+
+    return 1;
+}
+
+bool GuildTaskMgr::IsGuildTaskItem(uint32 itemId, uint32 guildId)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where `value` = '%u' and guildid = '%u' and `type` = 'itemTask'",
+            itemId, guildId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+map<uint32,uint32> GuildTaskMgr::GetTaskValues(uint32 owner, string type, uint32 *validIn /* = NULL */)
+{
+    map<uint32,uint32> result;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn, guildid from ai_playerbot_guild_tasks where owner = '%u' and `type` = '%s'",
+            owner, type.c_str());
+
+    if (!results)
+        return result;
+
+    do
+    {
+        Field* fields = results->Fetch();
+        uint32 value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        uint32 guildId = fields[3].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        result[guildId] = value;
+
+    } while (results->NextRow());
+
+    return result;
+}
+
+uint32 GuildTaskMgr::GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn /* = NULL */)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        if (validIn) *validIn = secs;
+    }
+
+    return value;
+}
+
+uint32 GuildTaskMgr::SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_guild_tasks (owner, guildid, `time`, validIn, `type`, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                owner, guildId, (uint32)time(0), validIn, type.c_str(), value);
+    }
+
+    return value;
+}
+
+bool GuildTaskMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Guild task system is currently disabled!");
+        return false;
+    }
+
+    if (!args || !*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: gtask stats/reset");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks");
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Guild tasks were reset for all players");
+        return true;
+    }
+
+    if (cmd == "stats")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask stats <player name>");
+        return true;
+    }
+
+    if (cmd.find("stats ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("stats ") + 6);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+
+        QueryResult result = CharacterDatabase.PQuery(
+                "select `value`, `time`, validIn, guildid, `type` from ai_playerbot_guild_tasks where owner = '%u' order by guildid, `type`",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 value = fields[0].GetUInt32();
+                uint32 lastChangeTime = fields[1].GetUInt32();
+                uint32 validIn = fields[2].GetUInt32();
+                if ((time(0) - lastChangeTime) >= validIn)
+                    value = 0;
+                uint32 guildId = fields[3].GetUInt32();
+                string type = fields[4].GetString();
+
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sLog->outMessage("gtask", LOG_LEVEL_INFO, "Player '%s' Guild '%s' %s=%u (%u secs)",
+                        charName.c_str(), guild->GetName().c_str(),
+                        type.c_str(), value, validIn);
+
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+        }
+
+        return true;
+    }
+
+    if (cmd == "reward")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask reward <player name>");
+        return true;
+    }
+
+    if (cmd.find("reward ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("reward ") + 7);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+        QueryResult result = CharacterDatabase.PQuery(
+                "select distinct guildid from ai_playerbot_guild_tasks where owner = '%u'",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 guildId = fields[0].GetUInt32();
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sGuildTaskMgr.Reward(owner, guildId);
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void GuildTaskMgr::CheckItemTask(uint32 itemId, uint32 obtained, Player* ownerPlayer, Player* bot, bool byMail)
+{
+    uint32 guildId = bot->GetGuildId();
+    if (!guildId)
+        return;
+
+    uint32 owner = (uint32)ownerPlayer->GetGUID().GetRawValue();
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: checking guild task",
+            bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask != itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item %u is not guild task item (%u)",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str(),
+                itemId, itemTask);
+        return;
+    }
+
+    if (byMail)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            return;
+
+        uint32 money = GetTaskValue(owner, guildId, "payment");
+        SetTaskValue(owner, guildId, "payment", money + auctionbot.GetBuyPrice(proto) * obtained,
+                sPlayerbotAIConfig.maxGuildTaskRewardTime);
+    }
+
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (obtained >= count)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+    else
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task progress",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "itemCount", count - obtained, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "thanks", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+}
+
+bool GuildTaskMgr::Reward(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask");
+    if (!itemTask && !killTask)
+        return false;
+
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name1 << " you provided so kindly. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+    else if (killTask)
+    {
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(killTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name << " you've killed recently. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft draft("Thank You", body.str());
+
+    uint32 count = urand(1, 3);
+    for (uint32 i = 0; i < count; ++i)
+    {
+        uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK_REWARD);
+        if (itemId)
+        {
+            Item* item = Item::CreateItem(itemId, 1, leader);
+            item->SaveToDB(trans);
+            draft.AddItem(item);
+        }
+    }
+
+    draft.AddMoney(GetTaskValue(owner, guildId, "payment")).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    SetTaskValue(owner, guildId, "activeTask", 0, 0);
+    return true;
+}
+
+void GuildTaskMgr::CheckKillTask(Player* player, Unit* victim)
+{
+    uint32 owner = player->GetGUIDLow();
+    Creature* creature = victim->ToCreature();
+    if (!creature)
+        return;
+
+    map<uint32,uint32> tasks = GetTaskValues(owner, "killTask");
+    for (map<uint32,uint32>::iterator i = tasks.begin(); i != tasks.end(); ++i)
+    {
+        uint32 guildId = i->first;
+        uint32 value = i->second;
+        Guild* guild = sGuildMgr->GetGuildById(guildId);
+
+        if (value != creature->GetCreatureTemplate()->Entry)
+            continue;
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                guild->GetName().c_str(), player->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/GuildTaskMgr.h b/src/plugins/playerbot/GuildTaskMgr.h
new file mode 100644
index 0000000..5e78e9f
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.h
@@ -0,0 +1,45 @@
+#ifndef _GuildTaskMgr_H
+#define _GuildTaskMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+class GuildTaskMgr
+{
+    public:
+        GuildTaskMgr();
+        virtual ~GuildTaskMgr();
+        static GuildTaskMgr& instance()
+        {
+            static GuildTaskMgr instance;
+            return instance;
+        }
+
+        void Update(Player* owner, Player* guildMaster);
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsGuildTaskItem(uint32 itemId, uint32 guildId);
+        void CheckItemTask(uint32 itemId, uint32 obtained, Player* owner, Player* bot, bool byMail = false);
+        void CheckKillTask(Player* owner, Unit* victim);
+
+    private:
+        map<uint32,uint32> GetTaskValues(uint32 owner, string type, uint32 *validIn = NULL);
+        uint32 GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn = NULL);
+        uint32 SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn);
+        uint32 CreateTask(uint32 owner, uint32 guildId);
+        bool SendAdvertisement(uint32 owner, uint32 guildId);
+        bool SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId);
+        bool SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId);
+        bool SendThanks(uint32 owner, uint32 guildId);
+        bool Reward(uint32 owner, uint32 guildId);
+        bool CreateItemTask(uint32 owner, uint32 guildId);
+        bool CreateKillTask(uint32 owner, uint32 guildId);
+        uint32 GetMaxItemTaskCount(uint32 itemId);
+};
+
+#define sGuildTaskMgr GuildTaskMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/Helpers.cpp b/src/plugins/playerbot/Helpers.cpp
new file mode 100644
index 0000000..1d0b408
--- /dev/null
+++ b/src/plugins/playerbot/Helpers.cpp
@@ -0,0 +1,90 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include <algorithm>
+#include <functional>
+#include <cctype>
+#include <locale>
+
+vector<string>& split(const string &s, char delim, vector<string> &elems)
+{
+    stringstream ss(s);
+    string item;
+    while(getline(ss, item, delim))
+    {
+        elems.push_back(item);
+    }
+    return elems;
+}
+
+
+vector<string> split(const string &s, char delim)
+{
+    vector<string> elems;
+    return split(s, delim, elems);
+}
+
+char *strstri(const char *haystack, const char *needle)
+{
+    if ( !*needle )
+    {
+        return (char*)haystack;
+    }
+    for ( ; *haystack; ++haystack )
+    {
+        if ( tolower(*haystack) == tolower(*needle) )
+        {
+            const char *h = haystack, *n = needle;
+            for ( ; *h && *n; ++h, ++n )
+            {
+                if ( tolower(*h) != tolower(*n) )
+                {
+                    break;
+                }
+            }
+            if ( !*n )
+            {
+                return (char*)haystack;
+            }
+        }
+    }
+    return 0;
+}
+
+
+
+uint64 extractGuid(WorldPacket& packet)
+{
+    uint8 mask;
+    packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while (true)
+    {
+        if (mask & testMask)
+        {
+            uint8 word;
+            packet >> word;
+            guid += (word << bit);
+        }
+        if (bit == 7)
+            break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+std::string &ltrim(std::string &s) {
+        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+        return s;
+}
+
+std::string &rtrim(std::string &s) {
+        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
+        return s;
+}
+
+std::string &trim(std::string &s) {
+        return ltrim(rtrim(s));
+}
diff --git a/src/plugins/playerbot/LazyCalculatedValue.h b/src/plugins/playerbot/LazyCalculatedValue.h
new file mode 100644
index 0000000..09e79aa
--- /dev/null
+++ b/src/plugins/playerbot/LazyCalculatedValue.h
@@ -0,0 +1,42 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    template <class TValue, class TOwner>
+    class LazyCalculatedValue
+    {
+    public:
+        typedef TValue (TOwner::*Calculator)();
+
+    public:
+        LazyCalculatedValue(TOwner* owner, Calculator calculator)
+        {
+            this->calculator = calculator;
+            this->owner = owner;
+            Reset();
+        }
+
+    public:
+        TValue GetValue()
+        {
+            if (!calculated)
+            {
+                value = (owner->*calculator)();
+                calculated = true;
+            }
+            return value;
+        }
+        void Reset()
+        {
+            calculated = false;
+        }
+
+    protected:
+        Calculator calculator;
+        TOwner* owner;
+        bool calculated;
+        TValue value;
+    };
+};
\ No newline at end of file
diff --git a/src/plugins/playerbot/LootObjectStack.cpp b/src/plugins/playerbot/LootObjectStack.cpp
new file mode 100644
index 0000000..20369c5
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.cpp
@@ -0,0 +1,244 @@
+#include "../pchdef.h"
+#include "LootObjectStack.h"
+#include "playerbot.h"
+
+using namespace ai;
+using namespace std;
+
+#define MAX_LOOT_OBJECT_COUNT 10
+
+LootTarget::LootTarget(ObjectGuid guid) : guid(guid), asOfTime(time(0))
+{
+}
+
+LootTarget::LootTarget(LootTarget const& other)
+{
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+}
+
+LootTarget& LootTarget::operator=(LootTarget const& other)
+{
+    if((void*)this == (void*)&other)
+        return *this;
+
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+
+    return *this;
+}
+
+bool LootTarget::operator< (const LootTarget& other) const
+{
+    return guid < other.guid;
+}
+
+void LootTargetList::shrink(time_t fromTime)
+{
+    for (set<LootTarget>::iterator i = begin(); i != end(); )
+    {
+        if (i->asOfTime <= fromTime)
+            erase(i++);
+		else
+			++i;
+    }
+}
+
+LootObject::LootObject(Player* bot, ObjectGuid guid)
+	: guid(), skillId(SKILL_NONE), reqSkillValue(0), reqItem(NULL)
+{
+    Refresh(bot, guid);
+}
+
+void LootObject::Refresh(Player* bot, ObjectGuid guid)
+{
+    skillId = SKILL_NONE;
+    reqSkillValue = 0;
+    reqItem = NULL;
+    this->guid = ObjectGuid();
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+    {
+        if (creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            this->guid = guid;
+
+        if (creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+        {
+            skillId = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+            uint32 targetLevel = creature->getLevel();
+            reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+            if (bot->HasSkill(skillId) && bot->GetSkillValue(skillId) >= reqSkillValue)
+                this->guid = guid;
+        }
+
+        return;
+    }
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+    {
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return;
+/*
+        for(uint32 i = 0; i < 6; ++i)
+        {
+            if (go->GetGOInfo()->questItems[i])
+            {
+                this->guid = guid;
+                return;
+            }
+        }
+*/
+        for (int i = 0; i < 8; ++i)
+        {
+            switch (lockInfo->Type[i])
+            {
+            case LOCK_KEY_ITEM:
+                if (lockInfo->Index[i] > 0)
+                {
+                    reqItem = lockInfo->Index[i];
+                    this->guid = guid;
+                }
+                break;
+            case LOCK_KEY_SKILL:
+                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                {
+                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                    reqSkillValue = lockInfo->Skill[i];
+                    this->guid = guid;
+                }
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
+WorldObject* LootObject::GetWorldObject(Player* bot)
+{
+    Refresh(bot, guid);
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+        return creature;
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+        return go;
+
+    return NULL;
+}
+
+LootObject::LootObject(const LootObject& other)
+{
+    guid = other.guid;
+    skillId = other.skillId;
+    reqSkillValue = other.reqSkillValue;
+    reqItem = other.reqItem;
+}
+
+bool LootObject::IsLootPossible(Player* bot)
+{
+    if (IsEmpty() || !GetWorldObject(bot))
+        return false;
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    if (reqItem && !bot->HasItemCount(reqItem, 1))
+        return false;
+
+    if (skillId == SKILL_NONE)
+        return true;
+
+    if (skillId == SKILL_FISHING)
+        return false;
+
+    if (!bot->HasSkill(skillId))
+        return false;
+
+    if (!reqSkillValue)
+        return true;
+
+    uint32 skillValue = uint32(bot->GetPureSkillValue(skillId));
+    if (reqSkillValue > skillValue)
+        return false;
+
+    if (skillId == SKILL_MINING && !bot->HasItemTotemCategory(TC_MINING_PICK))
+        return false;
+
+    if (skillId == SKILL_SKINNING && !bot->HasItemTotemCategory(TC_SKINNING_KNIFE))
+        return false;
+
+    return true;
+}
+
+bool LootObjectStack::Add(ObjectGuid guid)
+{
+    if (!availableLoot.insert(guid).second)
+        return false;
+
+    if (availableLoot.size() < MAX_LOOT_OBJECT_COUNT)
+        return true;
+
+    vector<LootObject> ordered = OrderByDistance();
+    for (size_t i = MAX_LOOT_OBJECT_COUNT; i < ordered.size(); i++)
+        Remove(ordered[i].guid);
+
+    return true;
+}
+
+void LootObjectStack::Remove(ObjectGuid guid)
+{
+    LootTargetList::iterator i = availableLoot.find(guid);
+    if (i != availableLoot.end())
+        availableLoot.erase(i);
+}
+
+void LootObjectStack::Clear()
+{
+    availableLoot.clear();
+}
+
+bool LootObjectStack::CanLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return !ordered.empty();
+}
+
+LootObject LootObjectStack::GetLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return ordered.empty() ? LootObject() : *ordered.begin();
+}
+
+vector<LootObject> LootObjectStack::OrderByDistance(float maxDistance)
+{
+    availableLoot.shrink(time(0) - 30);
+
+    map<float, LootObject> sortedMap;
+    LootTargetList safeCopy(availableLoot);
+    for (LootTargetList::iterator i = safeCopy.begin(); i != safeCopy.end(); i++)
+    {
+        ObjectGuid guid = i->guid;
+        LootObject lootObject(bot, guid);
+        if (!lootObject.IsLootPossible(bot))
+            continue;
+
+        float distance = bot->GetDistance(lootObject.GetWorldObject(bot));
+        if (!maxDistance || distance <= maxDistance)
+            sortedMap[distance] = lootObject;
+    }
+
+    vector<LootObject> result;
+    for (map<float, LootObject>::iterator i = sortedMap.begin(); i != sortedMap.end(); i++)
+        result.push_back(i->second);
+    return result;
+}
+
diff --git a/src/plugins/playerbot/LootObjectStack.h b/src/plugins/playerbot/LootObjectStack.h
new file mode 100644
index 0000000..a35bdd2
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.h
@@ -0,0 +1,76 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    enum LootStrategy
+    {
+        LOOTSTRATEGY_QUEST = 1,
+        LOOTSTRATEGY_SKILL = 2,
+        LOOTSTRATEGY_GRAY = 3,
+        LOOTSTRATEGY_NORMAL = 4,
+        LOOTSTRATEGY_ALL = 5
+    };
+
+    class LootObject
+    {
+    public:
+        LootObject() {}
+        LootObject(Player* bot, ObjectGuid guid);
+        LootObject(const LootObject& other);
+
+    public:
+        bool IsEmpty() { return !guid; }
+        bool IsLootPossible(Player* bot);
+        void Refresh(Player* bot, ObjectGuid guid);
+        WorldObject* GetWorldObject(Player* bot);
+        ObjectGuid guid;
+
+        uint32 skillId;
+        uint32 reqSkillValue;
+        uint32 reqItem;
+    };
+
+    class LootTarget
+    {
+    public:
+        LootTarget(ObjectGuid guid);
+        LootTarget(LootTarget const& other);
+
+    public:
+        LootTarget& operator=(LootTarget const& other);
+        bool operator< (const LootTarget& other) const;
+
+    public:
+        ObjectGuid guid;
+        time_t asOfTime;
+    };
+
+    class LootTargetList : public set<LootTarget>
+    {
+    public:
+        void shrink(time_t fromTime);
+    };
+
+    class LootObjectStack
+    {
+    public:
+        LootObjectStack(Player* bot) : bot(bot) {}
+
+    public:
+        bool Add(ObjectGuid guid);
+        void Remove(ObjectGuid guid);
+        void Clear();
+        bool CanLoot(float maxDistance);
+        LootObject GetLoot(float maxDistance = 0);
+
+    private:
+        vector<LootObject> OrderByDistance(float maxDistance = 0);
+
+    private:
+        Player* bot;
+        LootTargetList availableLoot;
+    };
+
+};
diff --git a/src/plugins/playerbot/PlayerbotAI.cpp b/src/plugins/playerbot/PlayerbotAI.cpp
new file mode 100644
index 0000000..2d8e94a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.cpp
@@ -0,0 +1,1395 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+
+#include "AiFactory.h"
+
+#include "../Grids/Notifiers/GridNotifiers.h"
+#include "../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../Grids/Cells/CellImpl.h"
+#include "strategy/values/LastMovementValue.h"
+#include "strategy/actions/LogLevelAction.h"
+#include "strategy/values/LastSpellCastValue.h"
+#include "LootObjectStack.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotSecurity.h"
+#include "../Groups/Group.h"
+#include "../Entities/Pet/Pet.h"
+#include "../Spells/Auras/SpellAuraEffects.h"
+
+using namespace ai;
+using namespace std;
+
+vector<string>& split(const string &s, char delim, vector<string> &elems);
+vector<string> split(const string &s, char delim);
+uint64 extractGuid(WorldPacket& packet);
+std::string &trim(std::string &s);
+
+uint32 PlayerbotChatHandler::extractQuestId(string str)
+{
+    char* source = (char*)str.c_str();
+    char* cId = extractKeyFromLink(source,"Hquest");
+    return cId ? atol(cId) : 0;
+}
+
+void PacketHandlingHelper::AddHandler(uint16 opcode, string handler)
+{
+    handlers[opcode] = handler;
+}
+
+void PacketHandlingHelper::Handle(ExternalEventHelper &helper)
+{
+    while (!queue.empty())
+    {
+        helper.HandlePacket(handlers, queue.top());
+        queue.pop();
+    }
+}
+
+void PacketHandlingHelper::AddPacket(const WorldPacket& packet)
+{
+	if (handlers.find(packet.GetOpcode()) != handlers.end())
+        queue.push(WorldPacket(packet));
+}
+
+
+PlayerbotAI::PlayerbotAI() : PlayerbotAIBase(), bot(NULL), aiObjectContext(NULL),
+    currentEngine(NULL), chatHelper(this), chatFilter(this), accountId(0), security(NULL), master(NULL)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i] = NULL;
+}
+
+PlayerbotAI::PlayerbotAI(Player* bot) :
+    PlayerbotAIBase(), chatHelper(this), chatFilter(this), security(bot), master(NULL)
+{
+	this->bot = bot;
+
+	accountId = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+
+    aiObjectContext = AiFactory::createAiObjectContext(bot, this);
+
+    engines[BOT_STATE_COMBAT] = AiFactory::createCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_NON_COMBAT] = AiFactory::createNonCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_DEAD] = AiFactory::createDeadEngine(bot, this, aiObjectContext);
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    currentState = BOT_STATE_NON_COMBAT;
+
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_REPORT_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_AREATRIGGER, "area trigger");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LOOT_ROLL, "loot roll");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GOSSIP_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_COMPLETE_QUEST, "complete quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_ACCEPT_QUEST, "accept quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXI, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXIEXPRESS, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_MOVE_SPLINE_DONE, "taxi done");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GROUP_UNINVITE_GUID, "uninvite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_PUSHQUESTTOPARTY, "quest share");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GUILD_INVITE, "guild invite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LFG_TELEPORT, "lfg teleport");
+
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_INVITE, "group invite");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_NOT_ENOUGHT_MONEY, "not enough money");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_REPUTATION_REQUIRE, "not enough reputation");
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_SET_LEADER, "group set leader");
+    botOutgoingPacketHandlers.AddHandler(SMSG_FORCE_RUN_SPEED_CHANGE, "check mount state");
+    botOutgoingPacketHandlers.AddHandler(SMSG_RESURRECT_REQUEST, "resurrect request");
+    botOutgoingPacketHandlers.AddHandler(SMSG_INVENTORY_CHANGE_FAILURE, "cannot equip");
+    botOutgoingPacketHandlers.AddHandler(SMSG_TRADE_STATUS, "trade status");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LOOT_RESPONSE, "loot response");
+    botOutgoingPacketHandlers.AddHandler(SMSG_QUESTUPDATE_ADD_KILL, "quest objective completed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_ITEM_PUSH_RESULT, "item push result");
+    botOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    botOutgoingPacketHandlers.AddHandler(SMSG_CAST_FAILED, "cast failed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_DUEL_REQUESTED, "duel requested");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_ROLE_CHECK_UPDATE, "lfg role check");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_PROPOSAL_UPDATE, "lfg proposal");
+
+    masterOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK, "ready check");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK_FINISHED, "ready check finished");
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i])
+            delete engines[i];
+    }
+
+    if (aiObjectContext)
+        delete aiObjectContext;
+}
+
+void PlayerbotAI::UpdateAI(uint32 elapsed)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown &&
+            bot->IsNonMeleeSpellCast(true, true, false) &&
+            *GetAiObjectContext()->GetValue<bool>("invalid target", "current target"))
+    {
+        Spell* spell = bot->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && !spell->GetSpellInfo()->IsPositive())
+        {
+            InterruptSpell();
+            SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        }
+    }
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.maxWaitForMove && bot->IsInCombat() && !bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+    {
+        nextAICheckDelay = sPlayerbotAIConfig.maxWaitForMove;
+    }
+
+    PlayerbotAIBase::UpdateAI(elapsed);
+}
+
+void PlayerbotAI::UpdateAIInternal(uint32 elapsed)
+{
+    ExternalEventHelper helper(aiObjectContext);
+    while (!chatCommands.empty())
+    {
+        ChatCommandHolder holder = chatCommands.top();
+        string command = holder.GetCommand();
+        Player* owner = holder.GetOwner();
+        if (!helper.ParseChatCommand(command, owner) && holder.GetType() == CHAT_MSG_WHISPER)
+        {
+            ostringstream out; out << "Unknown command " << command;
+            TellMaster(out);
+            helper.ParseChatCommand("help");
+        }
+        chatCommands.pop();
+    }
+
+    botOutgoingPacketHandlers.Handle(helper);
+    masterIncomingPacketHandlers.Handle(helper);
+    masterOutgoingPacketHandlers.Handle(helper);
+
+	DoNextAction();
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+	bot->GetMotionMaster()->Clear(true);
+	if (bot->IsBeingTeleportedNear())
+	{
+		WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+		p.appendPackGUID(bot->GetGUID());
+		p << (uint32) 0; // supposed to be flags? not used currently
+		p << (uint32) time(0); // time - not currently used
+		bot->GetSession()->HandleMoveTeleportAck(p);
+	}
+	else if (bot->IsBeingTeleportedFar())
+	{
+		bot->GetSession()->HandleMoveWorldportAckOpcode();
+		SetNextCheckDelay(1000);
+	}
+}
+
+void PlayerbotAI::Reset()
+{
+    if (bot->IsFlying())
+        return;
+
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    nextAICheckDelay = 0;
+
+    aiObjectContext->GetValue<Unit*>("old target")->Set(NULL);
+    aiObjectContext->GetValue<Unit*>("current target")->Set(NULL);
+    aiObjectContext->GetValue<LootObject>("loot target")->Set(LootObject());
+    aiObjectContext->GetValue<uint32>("lfg proposal")->Set(0);
+
+    LastSpellCast & lastSpell = aiObjectContext->GetValue<LastSpellCast& >("last spell cast")->Get();
+    lastSpell.Reset();
+
+    LastMovement & lastMovement = aiObjectContext->GetValue<LastMovement& >("last movement")->Get();
+    lastMovement.Set(NULL);
+
+    bot->GetMotionMaster()->Clear();
+    bot->m_taxi.ClearTaxiDestinations();
+    InterruptSpell();
+
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        engines[i]->Init();
+    }
+}
+
+void PlayerbotAI::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    if (!GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_ADDON)
+        return;
+
+    string filtered = text;
+    if (!sPlayerbotAIConfig.commandPrefix.empty())
+    {
+        if (filtered.find(sPlayerbotAIConfig.commandPrefix) != 0)
+            return;
+
+        filtered = filtered.substr(sPlayerbotAIConfig.commandPrefix.size());
+    }
+
+    filtered = chatFilter.Filter(trim((string&)filtered));
+    if (filtered.empty())
+        return;
+
+    if (filtered.find("who") != 0 && !GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_RAID_WARNING && filtered.find(bot->GetName()) != string::npos && filtered.find("award") == string::npos)
+    {
+        ChatCommandHolder cmd("warning", &fromPlayer, type);
+        chatCommands.push(cmd);
+        return;
+    }
+
+    if (filtered.size() > 2 && filtered.substr(0, 2) == "d " || filtered.size() > 3 && filtered.substr(0, 3) == "do ")
+    {
+        std::string action = filtered.substr(filtered.find(" ") + 1);
+        DoSpecificAction(action);
+    }
+    else if (filtered == "reset")
+    {
+        Reset();
+    }
+    else
+    {
+        ChatCommandHolder cmd(filtered, &fromPlayer, type);
+        chatCommands.push(cmd);
+    }
+}
+
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+    case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+
+            bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+            return;
+        }
+    case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+            bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+            return;
+        }
+    case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint8 castCount, result;
+            uint32 spellId;
+            p >> castCount >> spellId >> result;
+            if (result != SPELL_CAST_OK)
+            {
+                SpellInterrupted(spellId);
+                botOutgoingPacketHandlers.AddPacket(packet);
+            }
+            return;
+        }
+    case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            uint32 spellId;
+            p >> castCount;
+            p >> spellId;
+            SpellInterrupted(spellId);
+            return;
+        }
+    case SMSG_SPELL_DELAYED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint32 delaytime;
+            p >> delaytime;
+            if (delaytime <= 1000)
+                IncreaseNextCheckDelay(delaytime);
+            return;
+        }
+    default:
+        botOutgoingPacketHandlers.AddPacket(packet);
+    }
+}
+
+void PlayerbotAI::SpellInterrupted(uint32 spellid)
+{
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    if (lastSpell.id != spellid)
+        return;
+
+    lastSpell.Reset();
+
+    time_t now = time(0);
+    if (now <= lastSpell.time)
+        return;
+
+    uint32 castTimeSpent = 1000 * (now - lastSpell.time);
+
+    int32 globalCooldown = CalculateGlobalCooldown(lastSpell.id);
+    if (castTimeSpent < globalCooldown)
+        SetNextCheckDelay(globalCooldown - castTimeSpent);
+    else
+        SetNextCheckDelay(0);
+
+    lastSpell.id = 0;
+}
+
+int32 PlayerbotAI::CalculateGlobalCooldown(uint32 spellid)
+{
+    if (!spellid)
+        return 0;
+/*
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+
+    if (bot->GetSpellHistory()->HasGlobalCooldown(spellInfo))
+        return sPlayerbotAIConfig.globalCoolDown;
+
+    return sPlayerbotAIConfig.reactDelay;*/
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    masterIncomingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    masterOutgoingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::ChangeEngine(BotState type)
+{
+    Engine* engine = engines[type];
+
+    if (currentEngine != engine)
+    {
+        currentEngine = engine;
+        currentState = type;
+        ReInitCurrentEngine();
+
+        switch (type)
+        {
+        case BOT_STATE_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_NON_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s NON-COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_DEAD:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s DEAD ===", bot->GetName().c_str());
+            break;
+        }
+    }
+}
+
+void PlayerbotAI::DoNextAction()
+{
+    if (bot->IsBeingTeleported() || (GetMaster() && GetMaster()->IsBeingTeleported()))
+        return;
+
+    currentEngine->DoNextAction(NULL);
+
+    if (bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        // TODO
+        //WorldPacket packet(CMSG_MOVE_SET_FLY);
+        //packet.appendPackGUID(bot->GetGUID());
+        //packet << bot->m_movementInfo;
+        bot->SetMover(bot);
+        //bot->GetSession()->HandleMovementOpcodes(packet);
+    }
+
+    Player* master = GetMaster();
+    if (bot->IsMounted() && bot->IsFlying())
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        bot->SetSpeed(MOVE_FLIGHT, 1.0f, true);
+        bot->SetSpeed(MOVE_RUN, 1.0f, true);
+
+        if (master)
+        {
+            bot->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT), true);
+            bot->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT), true);
+        }
+
+    }
+
+    if (currentEngine != engines[BOT_STATE_DEAD] && !bot->IsAlive())
+        ChangeEngine(BOT_STATE_DEAD);
+
+    if (currentEngine == engines[BOT_STATE_DEAD] && bot->IsAlive())
+        ChangeEngine(BOT_STATE_NON_COMBAT);
+
+    Group *group = bot->GetGroup();
+    if (!master && group)
+    {
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member && member->IsInWorld() && !member->GetPlayerbotAI() && (!master || master->GetPlayerbotAI()))
+            {
+                ai->SetMaster(member);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::ReInitCurrentEngine()
+{
+    InterruptSpell();
+    currentEngine->Init();
+}
+
+void PlayerbotAI::ChangeStrategy(string names, BotState type)
+{
+    Engine* e = engines[type];
+    if (!e)
+        return;
+
+    e->ChangeStrategy(names);
+}
+
+void PlayerbotAI::DoSpecificAction(string name)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        ostringstream out;
+        ActionResult res = engines[i]->ExecuteAction(name);
+        switch (res)
+        {
+        case ACTION_RESULT_UNKNOWN:
+            continue;
+        case ACTION_RESULT_OK:
+            out << name << ": done";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_IMPOSSIBLE:
+            out << name << ": impossible";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_USELESS:
+            out << name << ": useless";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_FAILED:
+            out << name << ": failed";
+            TellMaster(out);
+            return;
+        }
+    }
+    ostringstream out;
+    out << name << ": unknown action";
+    TellMaster(out);
+}
+
+bool PlayerbotAI::ContainsStrategy(StrategyType type)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i]->ContainsStrategy(type))
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasStrategy(string name, BotState type)
+{
+    return engines[type]->HasStrategy(name);
+}
+
+void PlayerbotAI::ResetStrategies()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i]->removeAllStrategies();
+
+    AiFactory::AddDefaultCombatStrategies(bot, this, engines[BOT_STATE_COMBAT]);
+    AiFactory::AddDefaultNonCombatStrategies(bot, this, engines[BOT_STATE_NON_COMBAT]);
+    AiFactory::AddDefaultDeadStrategies(bot, this, engines[BOT_STATE_DEAD]);
+}
+
+bool PlayerbotAI::IsRanged(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_RANGED);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        return false;
+    case CLASS_DRUID:
+        return !HasAnyAuraOf(player, "cat form", "bear form", "dire bear form", NULL);
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsTank(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_TANK);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "bear form", "dire bear form", NULL);
+    }
+    return false;
+}
+
+bool PlayerbotAI::IsHeal(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_HEAL);
+
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "tree of life form", NULL);
+    }
+    return false;
+}
+
+
+
+namespace MaNGOS
+{
+
+    class UnitByGuidInRangeCheck
+    {
+    public:
+        UnitByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(Unit* u)
+        {
+            return u->GetGUID() == i_guid && i_obj->IsWithinDistInMap(u, i_range);
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+    class GameObjectByGuidInRangeCheck
+    {
+    public:
+        GameObjectByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(GameObject* u)
+        {
+            if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo() && u->GetGUID() == i_guid)
+                return true;
+
+            return false;
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+};
+
+
+Unit* PlayerbotAI::GetUnit(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return ObjectAccessor::GetObjectInMap(guid, map, (Unit*)NULL);
+}
+
+
+Creature* PlayerbotAI::GetCreature(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetCreature(guid);
+}
+
+GameObject* PlayerbotAI::GetGameObject(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetGameObject(guid);
+}
+
+bool PlayerbotAI::TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!GetSecurity()->CheckLevelFor(securityLevel, true, master))
+        return false;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            master->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.whisperDistance))
+        return false;
+
+    bot->Whisper(text, LANG_UNIVERSAL, master);
+    return true;
+}
+
+bool PlayerbotAI::TellMaster(string text, PlayerbotSecurityLevel securityLevel)
+{
+    if (!TellMasterNoFacing(text, securityLevel))
+        return false;
+
+    if (!bot->isMoving() && !bot->IsInCombat() && bot->GetMapId() == master->GetMapId())
+    {
+        if (!bot->isInFront(master, M_PI / 2))
+            bot->SetFacingTo(bot->GetAngle(master));
+
+        bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+
+    return true;
+}
+
+bool IsRealAura(Player* bot, Aura const* aura, Unit* unit)
+{
+    if (!aura)
+        return false;
+
+    if (!unit->IsHostileTo(bot))
+        return true;
+
+    uint32 stacks = aura->GetStackAmount();
+    if (stacks >= aura->GetSpellInfo()->StackAmount)
+        return true;
+
+    if (aura->GetCaster() == bot || aura->GetSpellInfo()->IsPositive() || aura->IsArea())
+        return true;
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(string name, Unit* unit)
+{
+    if (!unit)
+        return false;
+
+    uint32 spellId = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellId)
+        return HasAura(spellId, unit);
+
+    wstring wnamepart;
+    if (!Utf8toWStr(name, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+
+    Unit::AuraApplicationMap& map = unit->GetAppliedAuras();
+    for (Unit::AuraApplicationMap::iterator i = map.begin(); i != map.end(); ++i)
+    {
+        Aura const* aura  = i->second->GetBase();
+        if (!aura)
+            continue;
+
+        const string auraName = aura->GetSpellInfo()->SpellName[0];
+        if (auraName.empty() || auraName.length() != wnamepart.length() || !Utf8FitTo(auraName, wnamepart))
+            continue;
+
+        if (IsRealAura(bot, aura, unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit* unit)
+{
+    if (!spellId || !unit)
+        return false;
+
+    for (uint32 effect = EFFECT_0; effect <= EFFECT_2; effect++)
+    {
+        Aura* aura = ((Unit*)unit)->GetAura(spellId);
+
+        if (IsRealAura(bot, aura, (Unit*)unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAnyAuraOf(Unit* player, ...)
+{
+    if (!player)
+        return false;
+
+    va_list vl;
+    va_start(vl, player);
+
+    const char* cur;
+    do {
+        cur = va_arg(vl, const char*);
+        if (cur && HasAura(cur, player)) {
+            va_end(vl);
+            return true;
+        }
+    }
+    while (cur);
+
+    va_end(vl);
+    return false;
+}
+
+bool PlayerbotAI::CanCastSpell(string name, Unit* target)
+{
+    return CanCastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+}
+
+bool PlayerbotAI::CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell)
+{
+    if (!spellid)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    if (checkHasSpell && !bot->HasSpell(spellid))
+        return false;
+/*
+    if (bot->HasSpellCooldown(spellid))
+        return false;
+*/
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    bool positiveSpell = spellInfo->IsPositive();
+    if (positiveSpell && bot->IsHostileTo(target))
+        return false;
+
+    if (!positiveSpell && bot->IsFriendlyTo(target))
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    if (bot != target && bot->GetDistance(target) > sPlayerbotAIConfig.sightDistance)
+        return false;
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+    Spell *spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
+
+    spell->m_targets.SetUnitTarget(target);
+    spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellid)->Get();
+    spell->m_targets.SetItemTarget(spell->m_CastItem);
+    SpellCastResult result = spell->CheckCast(false);
+    delete spell;
+	if (oldSel)
+		bot->SetSelection(oldSel->GetGUID());
+
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_INFRONT:
+    case SPELL_FAILED_NOT_STANDING:
+    case SPELL_FAILED_UNIT_NOT_INFRONT:
+    case SPELL_FAILED_SUCCESS:
+    case SPELL_FAILED_MOVING:
+    case SPELL_FAILED_TRY_AGAIN:
+    case SPELL_FAILED_NOT_IDLE:
+    case SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW:
+    case SPELL_FAILED_SUMMON_PENDING:
+    case SPELL_FAILED_BAD_IMPLICIT_TARGETS:
+    case SPELL_FAILED_BAD_TARGETS:
+    case SPELL_CAST_OK:
+    case SPELL_FAILED_ITEM_NOT_FOUND:
+        return true;
+    default:
+        return false;
+    }
+}
+
+
+bool PlayerbotAI::CastSpell(string name, Unit* target)
+{
+    bool result = CastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+    if (result)
+    {
+        aiObjectContext->GetValue<time_t>("last spell cast time", name)->Set(time(0));
+    }
+
+    return result;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit* target)
+{
+    if (!spellId)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    Pet* pet = bot->GetPet();
+    const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (pet && pet->HasSpell(spellId))
+    {
+        pet->GetCharmInfo()->SetSpellAutocast(pSpellInfo, true);
+        pet->GetCharmInfo()->ToggleCreatureAutocast(pSpellInfo, true);
+        TellMaster("My pet will auto-cast this spell");
+        return true;
+    }
+
+    aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get().Set(spellId, target->GetGUID(), time(0));
+    aiObjectContext->GetValue<LastMovement&>("last movement")->Get().Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (bot->IsFlying())
+        return false;
+
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    if (bot->isMoving() && spell->GetCastTime())
+    {
+        delete spell;
+        return false;
+    }
+
+    SpellCastTargets targets;
+    WorldObject* faceTo = target;
+
+    if (pSpellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION ||
+            pSpellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
+    {
+        targets.SetDst(target->GetPosition());
+    }
+    else
+    {
+        targets.SetUnitTarget(target);
+    }
+
+    if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+    {
+        spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellId)->Get();
+        targets.SetItemTarget(spell->m_CastItem);
+    }
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        LootObject loot = *aiObjectContext->GetValue<LootObject>("loot target");
+        if (!loot.IsLootPossible(bot))
+        {
+            delete spell;
+            return false;
+        }
+
+        GameObject* go = GetGameObject(loot.guid);
+        if (go && go->isSpawned())
+        {
+            WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+            *packetgouse << loot.guid;
+            bot->GetSession()->QueuePacket(packetgouse);
+            targets.SetGOTarget(go);
+            faceTo = go;
+        }
+        else
+        {
+            Unit* creature = GetUnit(loot.guid);
+            if (creature)
+            {
+                targets.SetUnitTarget(creature);
+                faceTo = creature;
+            }
+        }
+    }
+
+
+    if (!bot->isInFront(faceTo, M_PI / 2))
+    {
+        bot->SetFacingTo(bot->GetAngle(faceTo));
+        delete spell;
+        SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        return false;
+    }
+
+	spell->prepare(&targets);
+	WaitForSpellCast(spell);
+
+    if (oldSel)
+        bot->SetSelection(oldSel->GetGUID());
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    return lastSpell.id == spellId;
+}
+
+void PlayerbotAI::WaitForSpellCast(Spell *spell)
+{
+    const SpellInfo* const pSpellInfo = spell->GetSpellInfo();
+
+    float castTime = spell->GetCastTime() + sPlayerbotAIConfig.reactDelay;
+    if (pSpellInfo->IsChanneled())
+    {
+        int32 duration = pSpellInfo->GetDuration();
+        if (duration > 0)
+            castTime += duration;
+    }
+
+    castTime = ceil(castTime);
+
+    uint32 globalCooldown = CalculateGlobalCooldown(pSpellInfo->Id);
+    if (castTime < globalCooldown)
+        castTime = globalCooldown;
+
+    SetNextCheckDelay(castTime);
+}
+
+void PlayerbotAI::InterruptSpell()
+{
+    if (bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+        return;
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+
+    for (int type = CURRENT_MELEE_SPELL; type < CURRENT_CHANNELED_SPELL; type++)
+    {
+        Spell* spell = bot->GetCurrentSpell((CurrentSpellTypes)type);
+        if (!spell)
+            continue;
+
+        bot->InterruptSpell((CurrentSpellTypes)type);
+
+        WorldPacket data(SMSG_SPELL_FAILURE, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        data.Initialize(SMSG_SPELL_FAILED_OTHER, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        SpellInterrupted(spell->m_spellInfo->Id);
+    }
+
+    SpellInterrupted(lastSpell.id);
+}
+
+
+void PlayerbotAI::RemoveAura(string name)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellid && HasAura(spellid, bot))
+        bot->RemoveAurasDueToSpell(spellid);
+}
+
+bool PlayerbotAI::IsInterruptableSpellCasting(Unit* target, string spell)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", spell)->Get();
+    if (!spellid || !target->IsNonMeleeSpellCast(true))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    for (uint32 i = EFFECT_0; i <= EFFECT_2; i++)
+    {
+        if ((spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) && spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            return true;
+
+        if ((spellInfo->Effects[i].Effect == SPELL_EFFECT_REMOVE_AURA || spellInfo->Effects[i].Effect == SPELL_EFFECT_INTERRUPT_CAST) &&
+                !target->IsImmunedToSpellEffect(spellInfo, i))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAuraToDispel(Unit* target, uint32 dispelType)
+{
+    // FEYZEE: disable dispel for class death knight because of priest Abolish Disease bug
+    if (target->getClass() == CLASS_DEATH_KNIGHT)
+        return false;
+    for (uint32 type = SPELL_AURA_NONE; type < TOTAL_AURAS; ++type)
+    {
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType((AuraType)type);
+        for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            const AuraEffect *const aura = *itr;
+			const SpellInfo* entry = aura->GetSpellInfo();
+            uint32 spellId = entry->Id;
+
+            bool isPositiveSpell = entry->IsPositive();
+            if (isPositiveSpell && bot->IsFriendlyTo(target))
+                continue;
+
+            if (!isPositiveSpell && bot->IsHostileTo(target))
+                continue;
+
+            if (canDispel(entry, dispelType))
+                return true;
+        }
+    }
+    return false;
+}
+
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool PlayerbotAI::canDispel(const SpellInfo* entry, uint32 dispelType)
+{
+    if (entry->Dispel != dispelType)
+        return false;
+
+    return !entry->SpellName[0] ||
+        (strcmpi((const char*)entry->SpellName[0], "demon skin") &&
+        strcmpi((const char*)entry->SpellName[0], "mage armor") &&
+        strcmpi((const char*)entry->SpellName[0], "frost armor") &&
+        strcmpi((const char*)entry->SpellName[0], "wavering will") &&
+        strcmpi((const char*)entry->SpellName[0], "chilled") &&
+        strcmpi((const char*)entry->SpellName[0], "ice armor"));
+}
+
+bool IsAlliance(uint8 race)
+{
+    return race == RACE_HUMAN || race == RACE_DWARF || race == RACE_NIGHTELF ||
+            race == RACE_GNOME || race == RACE_DRAENEI;
+}
+
+bool PlayerbotAI::IsOpposing(Player* player)
+{
+    return IsOpposing(player->getRace(), bot->getRace());
+}
+
+bool PlayerbotAI::IsOpposing(uint8 race1, uint8 race2)
+{
+    return (IsAlliance(race1) && !IsAlliance(race2)) || (!IsAlliance(race1) && IsAlliance(race2));
+}
+
+void PlayerbotAI::RemoveShapeshift()
+{
+    RemoveAura("bear form");
+    RemoveAura("dire bear form");
+    RemoveAura("moonkin form");
+    RemoveAura("travel form");
+    RemoveAura("cat form");
+    RemoveAura("flight form");
+    RemoveAura("swift flight form");
+    RemoveAura("aquatic form");
+    RemoveAura("ghost wolf");
+    RemoveAura("tree of life");
+}
+
+uint32 PlayerbotAI::GetEquipGearScore(Player* player, bool withBags, bool withBank)
+{
+    std::vector<uint32> gearScore(EQUIPMENT_SLOT_END);
+    uint32 twoHandScore = 0;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            _fillGearScoreData(player, item, &gearScore, twoHandScore);
+    }
+
+    if (withBags)
+    {
+        // check inventory
+        for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        // check bags
+        for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Bag* pBag = (Bag*)player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                {
+                    if (Item* item2 = pBag->GetItemByPos(j))
+                        _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                }
+            }
+        }
+    }
+
+    if (withBank)
+    {
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                if (item->IsBag())
+                {
+                    Bag* bag = (Bag*)item;
+                    for (uint8 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (Item* item2 = bag->GetItemByPos(j))
+                            _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                    }
+                }
+            }
+        }
+    }
+
+    uint8 count = EQUIPMENT_SLOT_END - 2;   // ignore body and tabard slots
+    uint32 sum = 0;
+
+    // check if 2h hand is higher level than main hand + off hand
+    if (gearScore[EQUIPMENT_SLOT_MAINHAND] + gearScore[EQUIPMENT_SLOT_OFFHAND] < twoHandScore * 2)
+    {
+        gearScore[EQUIPMENT_SLOT_OFFHAND] = 0;  // off hand is ignored in calculations if 2h weapon has higher score
+        --count;
+        gearScore[EQUIPMENT_SLOT_MAINHAND] = twoHandScore;
+    }
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+       sum += gearScore[i];
+    }
+
+    if (count)
+    {
+        uint32 res = uint32(sum / count);
+        return res;
+    }
+    else
+        return 0;
+}
+
+void PlayerbotAI::_fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore)
+{
+    if (!item)
+        return;
+
+    if (player->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+        return;
+
+    uint8 type   = item->GetTemplate()->InventoryType;
+    uint32 level = item->GetTemplate()->ItemLevel;
+
+    switch (type)
+    {
+        case INVTYPE_2HWEAPON:
+            twoHandScore = std::max(twoHandScore, level);
+            break;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+            (*gearScore)[SLOT_MAIN_HAND] = std::max((*gearScore)[SLOT_MAIN_HAND], level);
+            break;
+        case INVTYPE_SHIELD:
+        case INVTYPE_WEAPONOFFHAND:
+            (*gearScore)[EQUIPMENT_SLOT_OFFHAND] = std::max((*gearScore)[EQUIPMENT_SLOT_OFFHAND], level);
+            break;
+        case INVTYPE_THROWN:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_RANGED:
+        case INVTYPE_QUIVER:
+        case INVTYPE_RELIC:
+            (*gearScore)[EQUIPMENT_SLOT_RANGED] = std::max((*gearScore)[EQUIPMENT_SLOT_RANGED], level);
+            break;
+        case INVTYPE_HEAD:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        case INVTYPE_NECK:
+            (*gearScore)[EQUIPMENT_SLOT_NECK] = std::max((*gearScore)[EQUIPMENT_SLOT_NECK], level);
+            break;
+        case INVTYPE_SHOULDERS:
+            (*gearScore)[EQUIPMENT_SLOT_SHOULDERS] = std::max((*gearScore)[EQUIPMENT_SLOT_SHOULDERS], level);
+            break;
+        case INVTYPE_BODY:
+            (*gearScore)[EQUIPMENT_SLOT_BODY] = std::max((*gearScore)[EQUIPMENT_SLOT_BODY], level);
+            break;
+        case INVTYPE_CHEST:
+            (*gearScore)[EQUIPMENT_SLOT_CHEST] = std::max((*gearScore)[EQUIPMENT_SLOT_CHEST], level);
+            break;
+        case INVTYPE_WAIST:
+            (*gearScore)[EQUIPMENT_SLOT_WAIST] = std::max((*gearScore)[EQUIPMENT_SLOT_WAIST], level);
+            break;
+        case INVTYPE_LEGS:
+            (*gearScore)[EQUIPMENT_SLOT_LEGS] = std::max((*gearScore)[EQUIPMENT_SLOT_LEGS], level);
+            break;
+        case INVTYPE_FEET:
+            (*gearScore)[EQUIPMENT_SLOT_FEET] = std::max((*gearScore)[EQUIPMENT_SLOT_FEET], level);
+            break;
+        case INVTYPE_WRISTS:
+            (*gearScore)[EQUIPMENT_SLOT_WRISTS] = std::max((*gearScore)[EQUIPMENT_SLOT_WRISTS], level);
+            break;
+        case INVTYPE_HANDS:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        // equipped gear score check uses both rings and trinkets for calculation, assume that for bags/banks it is the same
+        // with keeping second highest score at second slot
+        case INVTYPE_FINGER:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_FINGER1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = (*gearScore)[EQUIPMENT_SLOT_FINGER1];
+                (*gearScore)[EQUIPMENT_SLOT_FINGER1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_FINGER2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = level;
+            break;
+        }
+        case INVTYPE_TRINKET:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_TRINKET1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = (*gearScore)[EQUIPMENT_SLOT_TRINKET1];
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_TRINKET2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = level;
+            break;
+        }
+        case INVTYPE_CLOAK:
+            (*gearScore)[EQUIPMENT_SLOT_BACK] = std::max((*gearScore)[EQUIPMENT_SLOT_BACK], level);
+            break;
+        default:
+            break;
+    }
+}
+
+string PlayerbotAI::HandleRemoteCommand(string command)
+{
+    if (command == "state")
+    {
+        switch (currentState)
+        {
+        case BOT_STATE_COMBAT:
+            return "combat";
+        case BOT_STATE_DEAD:
+            return "dead";
+        case BOT_STATE_NON_COMBAT:
+            return "non-combat";
+        default:
+            return "unknown";
+        }
+    }
+    else if (command == "position")
+    {
+        ostringstream out; out << bot->GetMapId() << "," << bot->GetPositionX() << "," << bot->GetPositionY() << "," << bot->GetPositionZ() << "," << bot->GetOrientation();
+        return out.str();
+    }
+    else if (command == "target")
+    {
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return "";
+        }
+
+        return target->GetName();
+    }
+    else if (command == "hp")
+    {
+        int pct = (int)((static_cast<float> (bot->GetHealth()) / bot->GetMaxHealth()) * 100);
+        ostringstream out; out << pct << "%";
+
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return out.str();
+        }
+
+        pct = (int)((static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100);
+        out << " / " << pct << "%";
+        return out.str();
+    }
+    else if (command == "strategy")
+    {
+        return currentEngine->ListStrategies();
+    }
+    else if (command == "action")
+    {
+        return currentEngine->GetLastAction();
+    }
+    ostringstream out; out << "invalid command: " << command;
+    return out.str();
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAI.h b/src/plugins/playerbot/PlayerbotAI.h
new file mode 100644
index 0000000..06cd309
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.h
@@ -0,0 +1,186 @@
+#pragma once
+
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotAIBase.h"
+#include "strategy/AiObjectContext.h"
+#include "strategy/Engine.h"
+#include "strategy/ExternalEventHelper.h"
+#include "ChatFilter.h"
+#include "PlayerbotSecurity.h"
+#include <stack>
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using namespace ai;
+
+bool IsAlliance(uint8 race);
+
+class PlayerbotChatHandler: protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer->GetSession()) {}
+    void sysmessage(string str) { SendSysMessage(str.c_str()); }
+    uint32 extractQuestId(string str);
+    uint32 extractSpellId(string str)
+    {
+        char* source = (char*)str.c_str();
+        return extractSpellIdFromLink(source);
+    }
+};
+
+namespace ai
+{
+	class MinValueCalculator {
+	public:
+		MinValueCalculator(float def = 0.0f) {
+			param = NULL;
+			minValue = def;
+		}
+
+	public:
+		void probe(float value, void* p) {
+			if (!param || minValue >= value) {
+				minValue = value;
+				param = p;
+			}
+		}
+
+	public:
+		void* param;
+		float minValue;
+	};
+};
+
+enum BotState
+{
+    BOT_STATE_COMBAT = 0,
+    BOT_STATE_NON_COMBAT = 1,
+    BOT_STATE_DEAD = 2
+};
+
+#define BOT_STATE_MAX 3
+
+class PacketHandlingHelper
+{
+public:
+    void AddHandler(uint16 opcode, string handler);
+    void Handle(ExternalEventHelper &helper);
+    void AddPacket(const WorldPacket& packet);
+
+private:
+    map<uint16, string> handlers;
+    stack<WorldPacket> queue;
+};
+
+class ChatCommandHolder
+{
+public:
+    ChatCommandHolder(string command, Player* owner = NULL, uint32 type = CHAT_MSG_WHISPER) : command(command), owner(owner), type(type) {}
+    ChatCommandHolder(ChatCommandHolder const& other)
+    {
+        this->command = other.command;
+        this->owner = other.owner;
+        this->type = other.type;
+    }
+
+public:
+    string GetCommand() { return command; }
+    Player* GetOwner() { return owner; }
+    uint32 GetType() { return type; }
+
+private:
+    string command;
+    Player* owner;
+    uint32 type;
+};
+
+class PlayerbotAI : public PlayerbotAIBase
+{
+public:
+	PlayerbotAI();
+	PlayerbotAI(Player* bot);
+	virtual ~PlayerbotAI();
+
+public:
+	virtual void UpdateAI(uint32 elapsed);
+	virtual void UpdateAIInternal(uint32 elapsed);
+	string HandleRemoteCommand(string command);
+    void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+	void HandleBotOutgoingPacket(const WorldPacket& packet);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+	void HandleTeleportAck();
+    void ChangeEngine(BotState type);
+    void DoNextAction();
+    void DoSpecificAction(string name);
+    void ChangeStrategy(string name, BotState type);
+    bool ContainsStrategy(StrategyType type);
+    bool HasStrategy(string name, BotState type);
+    void ResetStrategies();
+    void ReInitCurrentEngine();
+    void Reset();
+    bool IsTank(Player* player);
+    bool IsHeal(Player* player);
+    bool IsRanged(Player* player);
+    Creature* GetCreature(ObjectGuid guid);
+    Unit* GetUnit(ObjectGuid guid);
+    GameObject* GetGameObject(ObjectGuid guid);
+    bool TellMaster(ostringstream &stream, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL) { return TellMaster(stream.str(), securityLevel); }
+    bool TellMaster(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    bool TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    void SpellInterrupted(uint32 spellid);
+    int32 CalculateGlobalCooldown(uint32 spellid);
+    void InterruptSpell();
+    void RemoveAura(string name);
+    void RemoveShapeshift();
+    void WaitForSpellCast(Spell *spell);
+
+    virtual bool CanCastSpell(string name, Unit* target);
+    virtual bool CastSpell(string name, Unit* target);
+    virtual bool HasAura(string spellName, Unit* player);
+    virtual bool HasAnyAuraOf(Unit* player, ...);
+
+    virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+    virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+    bool CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell = true);
+
+    bool HasAura(uint32 spellId, const Unit* player);
+    bool CastSpell(uint32 spellId, Unit* target);
+    bool canDispel(const SpellInfo* entry, uint32 dispelType);
+
+    uint32 GetEquipGearScore(Player* player, bool withBags, bool withBank);
+
+private:
+    void _fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore);
+
+public:
+	Player* GetBot() { return bot; }
+    Player* GetMaster() { return master; }
+    void SetMaster(Player* master) { this->master = master; }
+    AiObjectContext* GetAiObjectContext() { return aiObjectContext; }
+    ChatHelper* GetChatHelper() { return &chatHelper; }
+    bool IsOpposing(Player* player);
+    static bool IsOpposing(uint8 race1, uint8 race2);
+    PlayerbotSecurity* GetSecurity() { return &security; }
+
+protected:
+	Player* bot;
+	Player* master;
+	uint32 accountId;
+    AiObjectContext* aiObjectContext;
+    Engine* currentEngine;
+    Engine* engines[BOT_STATE_MAX];
+    BotState currentState;
+    ChatHelper chatHelper;
+    stack<ChatCommandHolder> chatCommands;
+    PacketHandlingHelper botOutgoingPacketHandlers;
+    PacketHandlingHelper masterIncomingPacketHandlers;
+    PacketHandlingHelper masterOutgoingPacketHandlers;
+    CompositeChatFilter chatFilter;
+    PlayerbotSecurity security;
+};
+
diff --git a/src/plugins/playerbot/PlayerbotAIAware.h b/src/plugins/playerbot/PlayerbotAIAware.h
new file mode 100644
index 0000000..c639f2c
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIAware.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class PlayerbotAIAware
+    {
+    public:
+        PlayerbotAIAware(PlayerbotAI* const ai) : ai(ai) { }
+
+    protected:
+        PlayerbotAI* ai;
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAIBase.cpp b/src/plugins/playerbot/PlayerbotAIBase.cpp
new file mode 100644
index 0000000..4acb310
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.cpp
@@ -0,0 +1,51 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+PlayerbotAIBase::PlayerbotAIBase() : nextAICheckDelay(0)
+{
+}
+
+void PlayerbotAIBase::UpdateAI(uint32 elapsed)
+{
+    if (nextAICheckDelay > elapsed)
+        nextAICheckDelay -= elapsed;
+    else
+        nextAICheckDelay = 0;
+
+    if (!CanUpdateAI())
+        return;
+
+    UpdateAIInternal(elapsed);
+    YieldThread();
+}
+
+void PlayerbotAIBase::SetNextCheckDelay(const uint32 delay)
+{
+    nextAICheckDelay = delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "set next check delay: %d", nextAICheckDelay);
+}
+
+void PlayerbotAIBase::IncreaseNextCheckDelay(uint32 delay)
+{
+    nextAICheckDelay += delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "increase next check delay: %d", nextAICheckDelay);
+}
+
+bool PlayerbotAIBase::CanUpdateAI()
+{
+    return nextAICheckDelay < 100;
+}
+
+void PlayerbotAIBase::YieldThread()
+{
+    if (nextAICheckDelay < sPlayerbotAIConfig.reactDelay)
+        nextAICheckDelay = sPlayerbotAIConfig.reactDelay;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIBase.h b/src/plugins/playerbot/PlayerbotAIBase.h
new file mode 100644
index 0000000..8e72bf0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.h
@@ -0,0 +1,24 @@
+#pragma once
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+
+class PlayerbotAIBase
+{
+public:
+	PlayerbotAIBase();
+
+public:
+	bool CanUpdateAI();
+	void SetNextCheckDelay(const uint32 delay);
+    void IncreaseNextCheckDelay(uint32 delay);
+	void YieldThread();
+    virtual void UpdateAI(uint32 elapsed);
+    virtual void UpdateAIInternal(uint32 elapsed) = 0;
+
+protected:
+	uint32 nextAICheckDelay;
+};
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.cpp b/src/plugins/playerbot/PlayerbotAIConfig.cpp
new file mode 100644
index 0000000..f4ad611
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.cpp
@@ -0,0 +1,230 @@
+#include "../pchdef.h"
+#include "PlayerbotAIConfig.h"
+#include "playerbot.h"
+#include "RandomPlayerbotFactory.h"
+#include "../../game/Accounts/AccountMgr.h"
+
+using namespace std;
+
+PlayerbotAIConfig::PlayerbotAIConfig()
+{
+}
+
+template <class T>
+void LoadList(string value, T &list)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        list.push_back(id);
+    }
+}
+
+bool PlayerbotAIConfig::Initialize()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing AI Playerbot by ike3, based on the original Playerbot by blueboy");
+
+    string error;
+    if (!config.LoadInitial("aiplayerbot.conf", error))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled. Unable to open configuration file aiplayerbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AiPlayerbot.Enabled", true);
+    if (!enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled in aiplayerbot.conf");
+        return false;
+    }
+
+    globalCoolDown = (uint32) config.GetIntDefault("AiPlayerbot.GlobalCooldown", 500);
+    maxWaitForMove = config.GetIntDefault("AiPlayerbot.MaxWaitForMove", 3000);
+    reactDelay = (uint32) config.GetIntDefault("AiPlayerbot.ReactDelay", 100);
+
+    sightDistance = config.GetFloatDefault("AiPlayerbot.SightDistance", 50.0f);
+    spellDistance = config.GetFloatDefault("AiPlayerbot.SpellDistance", 30.0f);
+    reactDistance = config.GetFloatDefault("AiPlayerbot.ReactDistance", 150.0f);
+    grindDistance = config.GetFloatDefault("AiPlayerbot.GrindDistance", 100.0f);
+    lootDistance = config.GetFloatDefault("AiPlayerbot.LootDistance", 20.0f);
+    fleeDistance = config.GetFloatDefault("AiPlayerbot.FleeDistance", 20.0f);
+    tooCloseDistance = config.GetFloatDefault("AiPlayerbot.TooCloseDistance", 7.0f);
+    meleeDistance = config.GetFloatDefault("AiPlayerbot.MeleeDistance", 1.5f);
+    followDistance = config.GetFloatDefault("AiPlayerbot.FollowDistance", 1.5f);
+    whisperDistance = config.GetFloatDefault("AiPlayerbot.WhisperDistance", 6000.0f);
+    contactDistance = config.GetFloatDefault("AiPlayerbot.ContactDistance", 0.5f);
+
+    criticalHealth = config.GetIntDefault("AiPlayerbot.CriticalHealth", 20);
+    lowHealth = config.GetIntDefault("AiPlayerbot.LowHealth", 50);
+    mediumHealth = config.GetIntDefault("AiPlayerbot.MediumHealth", 70);
+    almostFullHealth = config.GetIntDefault("AiPlayerbot.AlmostFullHealth", 85);
+    lowMana = config.GetIntDefault("AiPlayerbot.LowMana", 15);
+    mediumMana = config.GetIntDefault("AiPlayerbot.MediumMana", 40);
+
+    randomGearLoweringChance = config.GetFloatDefault("AiPlayerbot.RandomGearLoweringChance", 0.15);
+    randomBotMaxLevelChance = config.GetFloatDefault("AiPlayerbot.RandomBotMaxLevelChance", 0.4);
+
+    iterationsPerTick = config.GetIntDefault("AiPlayerbot.IterationsPerTick", 4);
+
+    allowGuildBots = config.GetBoolDefault("AiPlayerbot.AllowGuildBots", true);
+
+    randomBotMapsAsString = config.GetStringDefault("AiPlayerbot.RandomBotMaps", "0,1,530,571");
+    LoadList<vector<uint32> >(randomBotMapsAsString, randomBotMaps);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotQuestItems", "6948,5175,5176,5177,5178"), randomBotQuestItems);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotSpellIds", "54197"), randomBotSpellIds);
+
+    randomBotAutologin = config.GetBoolDefault("AiPlayerbot.RandomBotAutologin", true);
+    // FEYZEE: change defaults for minimum lag
+    minRandomBots = config.GetIntDefault("AiPlayerbot.MinRandomBots", 20);
+    maxRandomBots = config.GetIntDefault("AiPlayerbot.MaxRandomBots", 40);
+    randomBotUpdateInterval = config.GetIntDefault("AiPlayerbot.RandomBotUpdateInterval", 60);
+    randomBotCountChangeMinInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMinInterval", 24 * 3600);
+    randomBotCountChangeMaxInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMaxInterval", 3 * 24 * 3600);
+    minRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MinRandomBotInWorldTime", 2 * 3600);
+    maxRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MaxRandomBotInWorldTime", 14 * 24 * 3600);
+    minRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MinRandomBotRandomizeTime", 2 * 3600);
+    maxRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MaxRandomRandomizeTime", 14 * 24 * 3600);
+    minRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MinRandomBotReviveTime", 60);
+    maxRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MaxRandomReviveTime", 300);
+    randomBotTeleportDistance = config.GetIntDefault("AiPlayerbot.RandomBotTeleportDistance", 1000);
+    minRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPerInterval", 50);
+    maxRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPerInterval", 100);
+    minRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPriceChangeInterval", 2 * 3600);
+    maxRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPriceChangeInterval", 48 * 3600);
+    randomBotJoinLfg = config.GetBoolDefault("AiPlayerbot.RandomBotJoinLfg", true);
+    logInGroupOnly = config.GetBoolDefault("AiPlayerbot.LogInGroupOnly", true);
+    logValuesPerTick = config.GetBoolDefault("AiPlayerbot.LogValuesPerTick", false);
+    fleeingEnabled = config.GetBoolDefault("AiPlayerbot.FleeingEnabled", true);
+    randomBotMinLevel = config.GetIntDefault("AiPlayerbot.RandomBotMinLevel", 1);
+    randomBotMaxLevel = config.GetIntDefault("AiPlayerbot.RandomBotMaxLevel", 255);
+    randomBotLoginAtStartup = config.GetBoolDefault("AiPlayerbot.RandomBotLoginAtStartup", true);
+    randomBotTeleLevel = config.GetIntDefault("AiPlayerbot.RandomBotTeleLevel", 3);
+
+    randomChangeMultiplier = config.GetFloatDefault("AiPlayerbot.RandomChangeMultiplier", 1.0);
+
+    randomBotCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotCombatStrategies", "+dps,+attack weak");
+    randomBotNonCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotNonCombatStrategies", "+grind,+move random,+loot");
+
+    commandPrefix = config.GetStringDefault("AiPlayerbot.CommandPrefix", "");
+
+    commandServerPort = config.GetIntDefault("AiPlayerbot.CommandServerPort", 0);
+
+    for (uint32 cls = 0; cls < MAX_CLASSES; ++cls)
+    {
+        for (uint32 spec = 0; spec < 3; ++spec)
+        {
+            ostringstream os; os << "AiPlayerbot.RandomClassSpecProbability." << cls << "." << spec;
+            specProbability[cls][spec] = config.GetIntDefault(os.str().c_str(), 33);
+        }
+    }
+
+    randomBotAccountPrefix = config.GetStringDefault("AiPlayerbot.RandomBotAccountPrefix", "rndbot");
+    randomBotAccountCount = config.GetIntDefault("AiPlayerbot.RandomBotAccountCount", 50);
+    deleteRandomBotAccounts = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotAccounts", false);
+    randomBotGuildCount = config.GetIntDefault("AiPlayerbot.RandomBotGuildCount", 50);
+    deleteRandomBotGuilds = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotGuilds", false);
+
+    guildTaskEnabled = config.GetBoolDefault("AiPlayerbot.EnableGuildTasks", true);
+    minGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskChangeTime", 2 * 24 * 3600);
+    maxGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskChangeTime", 5 * 24 * 3600);
+    minGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskAdvertisementTime", 300);
+    maxGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskAdvertisementTime", 8 * 3600);
+    minGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskRewardTime", 300);
+    maxGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskRewardTime", 1 * 3600);
+
+    RandomPlayerbotFactory::CreateRandomBots();
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot configuration loaded");
+
+    return true;
+}
+
+
+bool PlayerbotAIConfig::IsInRandomAccountList(uint32 id)
+{
+    return find(randomBotAccounts.begin(), randomBotAccounts.end(), id) != randomBotAccounts.end();
+}
+
+bool PlayerbotAIConfig::IsInRandomQuestItemList(uint32 id)
+{
+    return find(randomBotQuestItems.begin(), randomBotQuestItems.end(), id) != randomBotQuestItems.end();
+}
+
+string PlayerbotAIConfig::GetValue(string name)
+{
+    ostringstream out;
+
+    if (name == "GlobalCooldown")
+        out << globalCoolDown;
+    else if (name == "ReactDelay")
+        out << reactDelay;
+
+    else if (name == "SightDistance")
+        out << sightDistance;
+    else if (name == "SpellDistance")
+        out << spellDistance;
+    else if (name == "ReactDistance")
+        out << reactDistance;
+    else if (name == "GrindDistance")
+        out << grindDistance;
+    else if (name == "LootDistance")
+        out << lootDistance;
+    else if (name == "FleeDistance")
+        out << fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out << criticalHealth;
+    else if (name == "LowHealth")
+        out << lowHealth;
+    else if (name == "MediumHealth")
+        out << mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out << almostFullHealth;
+    else if (name == "LowMana")
+        out << lowMana;
+
+    else if (name == "IterationsPerTick")
+        out << iterationsPerTick;
+
+    return out.str();
+}
+
+void PlayerbotAIConfig::SetValue(string name, string value)
+{
+    istringstream out(value, istringstream::in);
+
+    if (name == "GlobalCooldown")
+        out >> globalCoolDown;
+    else if (name == "ReactDelay")
+        out >> reactDelay;
+
+    else if (name == "SightDistance")
+        out >> sightDistance;
+    else if (name == "SpellDistance")
+        out >> spellDistance;
+    else if (name == "ReactDistance")
+        out >> reactDistance;
+    else if (name == "GrindDistance")
+        out >> grindDistance;
+    else if (name == "LootDistance")
+        out >> lootDistance;
+    else if (name == "FleeDistance")
+        out >> fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out >> criticalHealth;
+    else if (name == "LowHealth")
+        out >> lowHealth;
+    else if (name == "MediumHealth")
+        out >> mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out >> almostFullHealth;
+    else if (name == "LowMana")
+        out >> lowMana;
+
+    else if (name == "IterationsPerTick")
+        out >> iterationsPerTick;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.h b/src/plugins/playerbot/PlayerbotAIConfig.h
new file mode 100644
index 0000000..cc8602e
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "Config.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+class PlayerbotAIConfig
+{
+public:
+    PlayerbotAIConfig();
+    static PlayerbotAIConfig& instance()
+    {
+        static PlayerbotAIConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+    bool IsInRandomAccountList(uint32 id);
+    bool IsInRandomQuestItemList(uint32 id);
+
+    bool enabled;
+    bool allowGuildBots;
+    uint32 globalCoolDown, reactDelay, maxWaitForMove;
+    float sightDistance, spellDistance, reactDistance, grindDistance, lootDistance,
+        fleeDistance, tooCloseDistance, meleeDistance, followDistance, whisperDistance, contactDistance;
+    uint32 criticalHealth, lowHealth, mediumHealth, almostFullHealth;
+    uint32 lowMana, mediumMana;
+
+    bool randomBotAutologin;
+    std::string randomBotMapsAsString;
+    std::vector<uint32> randomBotMaps;
+    std::list<uint32> randomBotQuestItems;
+    std::list<uint32> randomBotAccounts;
+    std::list<uint32> randomBotSpellIds;
+    uint32 randomBotTeleportDistance;
+    float randomGearLoweringChance;
+    float randomBotMaxLevelChance;
+    uint32 minRandomBots, maxRandomBots;
+    uint32 randomBotUpdateInterval, randomBotCountChangeMinInterval, randomBotCountChangeMaxInterval;
+    uint32 minRandomBotInWorldTime, maxRandomBotInWorldTime;
+    uint32 minRandomBotRandomizeTime, maxRandomBotRandomizeTime;
+    uint32 minRandomBotReviveTime, maxRandomBotReviveTime;
+    uint32 minRandomBotPvpTime, maxRandomBotPvpTime;
+    uint32 minRandomBotsPerInterval, maxRandomBotsPerInterval;
+    uint32 minRandomBotsPriceChangeInterval, maxRandomBotsPriceChangeInterval;
+    bool randomBotJoinLfg;
+    bool randomBotLoginAtStartup;
+    uint32 randomBotTeleLevel;
+    bool logInGroupOnly, logValuesPerTick;
+    bool fleeingEnabled;
+    std::string randomBotCombatStrategies, randomBotNonCombatStrategies;
+    uint32 randomBotMinLevel, randomBotMaxLevel;
+    float randomChangeMultiplier;
+    uint32 specProbability[MAX_CLASSES][3];
+    std::string commandPrefix;
+    std::string randomBotAccountPrefix;
+    uint32 randomBotAccountCount;
+    bool deleteRandomBotAccounts;
+    uint32 randomBotGuildCount;
+    bool deleteRandomBotGuilds;
+    std::list<uint32> randomBotGuilds;
+
+    bool guildTaskEnabled;
+    uint32 minGuildTaskChangeTime, maxGuildTaskChangeTime;
+    uint32 minGuildTaskAdvertisementTime, maxGuildTaskAdvertisementTime;
+    uint32 minGuildTaskRewardTime, maxGuildTaskRewardTime;
+
+    uint32 iterationsPerTick;
+
+    int commandServerPort;
+
+    std::string GetValue(std::string name);
+    void SetValue(std::string name, std::string value);
+
+private:
+    ConfigMgr config;
+};
+
+#define sPlayerbotAIConfig PlayerbotAIConfig::instance()
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.cpp b/src/plugins/playerbot/PlayerbotCommandServer.cpp
new file mode 100644
index 0000000..07aceb2
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.cpp
@@ -0,0 +1,94 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotCommandServer.h"
+#include <cstdlib>
+#include <iostream>
+#include <boost/bind.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/asio.hpp>
+#include <boost/thread/thread.hpp>
+
+
+using namespace std;
+using boost::asio::ip::tcp;
+typedef boost::shared_ptr<tcp::socket> socket_ptr;
+
+bool ReadLine(socket_ptr sock, string* buffer, string* line)
+{
+    // Do the real reading from fd until buffer has '\n'.
+    string::iterator pos;
+    while ((pos = find(buffer->begin(), buffer->end(), '\n')) == buffer->end())
+    {
+        char buf[1025];
+        boost::system::error_code error;
+        size_t n = sock->read_some(boost::asio::buffer(buf), error);
+        if (n == -1 || error == boost::asio::error::eof)
+            return false;
+        else if (error)
+            throw boost::system::system_error(error); // Some other error.
+
+        buf[n] = 0;
+        *buffer += buf;
+    }
+
+    *line = string(buffer->begin(), pos);
+    *buffer = string(pos + 1, buffer->end());
+    return true;
+}
+
+void session(socket_ptr sock)
+{
+    try
+    {
+        string buffer, request;
+        while (ReadLine(sock, &buffer, &request)) {
+            string response = sRandomPlayerbotMgr.HandleRemoteCommand(request) + "\n";
+            boost::asio::write(*sock, boost::asio::buffer(response.c_str(), response.size()));
+            request = "";
+        }
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+void server(boost::asio::io_service& io_service, short port)
+{
+    tcp::acceptor a(io_service, tcp::endpoint(tcp::v4(), port));
+    for (;;)
+    {
+        socket_ptr sock(new tcp::socket(io_service));
+        a.accept(*sock);
+        boost::thread t(boost::bind(session, sock));
+    }
+}
+
+void Run()
+{
+    if (!sPlayerbotAIConfig.commandServerPort) {
+        return;
+    }
+
+    ostringstream s; s << "Starting Playerbot Command Server on port " << sPlayerbotAIConfig.commandServerPort;
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, s.str().c_str());
+
+    try
+    {
+        boost::asio::io_service io_service;
+        server(io_service, sPlayerbotAIConfig.commandServerPort);
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+
+void PlayerbotCommandServer::Start()
+{
+    thread serverThread(Run);
+    serverThread.detach();
+}
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.h b/src/plugins/playerbot/PlayerbotCommandServer.h
new file mode 100644
index 0000000..0ea66c7
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.h
@@ -0,0 +1,26 @@
+#ifndef _PlayerbotCommandServer_H
+#define _PlayerbotCommandServer_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+using namespace std;
+
+class PlayerbotCommandServer
+{
+public:
+    PlayerbotCommandServer() {}
+    virtual ~PlayerbotCommandServer() {}
+    static PlayerbotCommandServer& instance()
+    {
+        static PlayerbotCommandServer instance;
+        return instance;
+    }
+
+    void Start();
+};
+
+#define sPlayerbotCommandServer PlayerbotCommandServer::instance()
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotFactory.cpp b/src/plugins/playerbot/PlayerbotFactory.cpp
new file mode 100644
index 0000000..41a404a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.cpp
@@ -0,0 +1,2818 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotFactory.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "../ItemPrototype.h"
+#include "PlayerbotAIConfig.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../ahbot/AhBot.h"
+#include "../Entities/Pet/Pet.h"
+#include "RandomPlayerbotFactory.h"
+
+using namespace ai;
+using namespace std;
+
+uint32 PlayerbotFactory::tradeSkills[] =
+{
+    SKILL_ALCHEMY,
+    SKILL_ENCHANTING,
+    SKILL_SKINNING,
+    SKILL_JEWELCRAFTING,
+    SKILL_INSCRIPTION,
+    SKILL_TAILORING,
+    SKILL_LEATHERWORKING,
+    SKILL_ENGINEERING,
+    SKILL_HERBALISM,
+    SKILL_MINING,
+    SKILL_BLACKSMITHING,
+    SKILL_COOKING,
+    SKILL_FIRST_AID,
+    SKILL_FISHING
+};
+
+void PlayerbotFactory::Randomize()
+{
+    Randomize(true);
+}
+
+void PlayerbotFactory::Refresh()
+{
+    Prepare();
+    InitEquipment(true);
+    InitAmmo();
+    InitFood();
+    InitPotions();
+
+    uint32 money = urand(level * 1000, level * 5 * 1000);
+    if (bot->GetMoney() < money)
+        bot->SetMoney(money);
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::CleanRandomize()
+{
+    Randomize(false);
+}
+
+// FEYZEE: new functions used by init=high80 command
+void PlayerbotFactory::AddEquipment(uint8 Slot, uint32 ItemId)
+{
+    uint16 dest;
+    if (!CanEquipUnseenItem(Slot, dest, ItemId))
+        return;
+    Item* newItem = bot->EquipNewItem(dest, ItemId, true);
+    if (newItem)
+    {
+        newItem->AddToWorld();
+        newItem->AddToUpdateQueueOf(bot);
+        bot->AutoUnequipOffhandIfNeed();
+    }
+}
+
+void PlayerbotFactory::InitHunterPet()
+{
+    if (bot->getClass() != CLASS_HUNTER)
+        return;
+    Pet* pet = bot->GetPet();
+
+    if (!pet)
+    {
+        Map* map = bot->GetMap();
+        if (!map)
+            return;
+
+        vector<uint32> ids;
+        CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+        for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+        {
+            CreatureTemplate const& co = i->second;
+            if (!co.IsTameable(false))
+                continue;
+
+            if (co.minlevel > bot->getLevel())
+                continue;
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co.Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            ids.push_back(i->first);
+        }
+
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No pets available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+            return;
+        }
+
+        for (int i = 0; i < 100; i++)
+        {
+            int index = urand(0, ids.size() - 1);
+            CreatureTemplate const* co = sObjectMgr->GetCreatureTemplate(ids[index]);
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co->Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            uint32 guid = sObjectMgr->GenerateLowGuid(HIGHGUID_PET);
+            pet = new Pet(bot, HUNTER_PET);
+            if (!pet->Create(guid, map, 0, ids[index], 0))
+            {
+                delete pet;
+                pet = NULL;
+                continue;
+            }
+
+            pet->SetPosition(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), bot->GetOrientation());
+            pet->setFaction(bot->getFaction());
+            pet->SetLevel(bot->getLevel());
+            bot->SetPetGUID(pet->GetGUID());
+            bot->GetMap()->AddToMap(pet->ToCreature());
+            bot->SetMinion(pet, true);
+            pet->InitTalentForLevel();
+            bot->PetSpellInitialize();
+            bot->InitTamedPet(pet, bot->getLevel(), 0);
+
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "Bot %s: assign pet %d (%d level)", bot->GetName().c_str(), co->Entry, bot->getLevel());
+            pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+            break;
+        }
+    }
+
+    if (!pet)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot create pet for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        if(itr->second.state == PETSPELL_REMOVED)
+            continue;
+
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (spellInfo->IsPassive())
+            continue;
+
+        pet->ToggleAutocast(spellInfo, true);
+    }
+}
+
+void PlayerbotFactory::CleanBuild()
+{
+    uint8 BotClass;
+    uint8 BotRace;
+    BotClass = bot->getClass();
+    BotRace = bot->getRace();
+    if (!itemQuality)
+        itemQuality = urand(ITEM_QUALITY_RARE, ITEM_QUALITY_EPIC);
+    if (bot->isDead())
+        bot->ResurrectPlayer(1.0f, false);
+    bot->CombatStop(true);
+    bot->SetLevel(80);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+    bot->ResetTalents(true);
+    ClearSpells();
+    ClearInventory();
+    bot->SaveToDB();
+    InitQuests();
+    // quest rewards boost bot level, so reduce back
+    bot->SetLevel(80);
+    ClearInventory();
+    bot->SetUInt32Value(PLAYER_XP, 0);
+    CancelAuras();
+    bot->SaveToDB();
+    InitAvailableSpells();
+    switch (bot->getClass())
+    {
+        case CLASS_WARRIOR:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_PALADIN:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_MAGE:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            //bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_PRIEST:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            //bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_WARLOCK:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            //bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_HUNTER:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            //bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_ROGUE:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_SHAMAN:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            //bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+        case CLASS_DRUID:
+            bot->SetSkill(SKILL_DEFENSE, 0, 400, 400);
+            //bot->SetSkill(SKILL_SWORDS, 0, 400, 400);
+            //bot->SetSkill(SKILL_AXES, 0, 400, 400);
+            //bot->SetSkill(SKILL_BOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_GUNS, 0, 400, 400);
+            bot->SetSkill(SKILL_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_SWORDS, 0, 400, 400);
+            bot->SetSkill(SKILL_STAVES, 0, 400, 400);
+            bot->SetSkill(SKILL_2H_MACES, 0, 400, 400);
+            //bot->SetSkill(SKILL_2H_AXES, 0, 400, 400);
+            bot->SetSkill(SKILL_DAGGERS, 0, 400, 400);
+            //bot->SetSkill(SKILL_THROWN, 0, 400, 400);
+            //bot->SetSkill(SKILL_CROSSBOWS, 0, 400, 400);
+            //bot->SetSkill(SKILL_WANDS, 0, 400, 400);
+            bot->SetSkill(SKILL_POLEARMS, 0, 400, 400);
+            //bot->SetSkill(SKILL_FIST_WEAPONS, 0, 400, 400);
+            bot->SetSkill(SKILL_UNARMED, 0, 400, 400);
+            break;
+    }
+    bot->SetSkill(SKILL_RIDING, 0, 300, 300);
+    switch (bot->getClass())
+    {
+        case CLASS_DEATH_KNIGHT:
+        case CLASS_WARRIOR:
+        case CLASS_PALADIN:
+            bot->SetSkill(SKILL_PLATE_MAIL, 0, 1, 1);
+            break;
+        case CLASS_SHAMAN:
+        case CLASS_HUNTER:
+            bot->SetSkill(SKILL_MAIL, 0, 1, 1);
+            break;
+    }
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+    bot->SetSkill(SKILL_FIRST_AID, 0, 450, 450);
+    bot->SetSkill(SKILL_FISHING, 0, 450, 450);
+    bot->SetSkill(SKILL_COOKING, 0, 450, 450);
+    switch (bot->getClass())
+    {
+        case CLASS_WARRIOR:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Fury
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Arms
+            }
+            break;
+        case CLASS_PALADIN:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Protection
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(2); // Retribution
+            }
+            break;
+        case CLASS_MAGE:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(0); // Arcane
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(1); // Fire
+            }
+            break;
+        case CLASS_PRIEST:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Holy
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Discipline
+            }
+            break;
+        case CLASS_WARLOCK:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(0); // Affliction
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(2); // Destruction
+            }
+            break;
+        case CLASS_HUNTER:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Marksmanship
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Beast Mastery
+            }
+            break;
+        case CLASS_ROGUE:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Combat
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Assassination
+            }
+            break;
+        case CLASS_DEATH_KNIGHT:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(1); // Frost
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Blood
+            }
+            break;
+        case CLASS_SHAMAN:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(2); // Restoration
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(1); // Enhancement
+            }
+            break;
+        case CLASS_DRUID:
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() <= 6)
+                    break;
+                InitTalents(2); // Restoration
+            }
+            for (uint8 i = 0; i < 15; i++)
+            {
+                if (bot->GetFreeTalentPoints() == 0)
+                    break;
+                InitTalents(0); // Balance
+            }
+            break;
+    }
+    InitAvailableSpells();
+    // Cold Weather Flying
+    bot->LearnSpell(54197, false);
+    // Unlearn Fade
+    if (bot->getClass() == CLASS_PRIEST)
+    {
+        bot->RemoveSpell(586, false, false);
+    }
+    // Learn Death Gate
+    if (bot->getClass() == CLASS_DEATH_KNIGHT)
+    {
+        bot->LearnSpell(50977, false);
+    }
+    // Mounts
+    switch (bot->getRace())
+    {
+        case RACE_HUMAN:
+            bot->LearnSpell(23228, false);
+            bot->LearnSpell(32242, false);
+            break;
+        case RACE_ORC:
+            bot->LearnSpell(23251, false);
+            bot->LearnSpell(32295, false);
+            break;
+        case RACE_DWARF:
+            bot->LearnSpell(23240, false);
+            bot->LearnSpell(32242, false);
+            break;
+        case RACE_NIGHTELF:
+            bot->LearnSpell(23221, false);
+            bot->LearnSpell(32242, false);
+            break;
+        case RACE_UNDEAD_PLAYER:
+            bot->LearnSpell(17465, false);
+            bot->LearnSpell(32295, false);
+            break;
+        case RACE_TAUREN:
+            bot->LearnSpell(23247, false);
+            bot->LearnSpell(32295, false);
+            break;
+        case RACE_GNOME:
+            bot->LearnSpell(23223, false);
+            bot->LearnSpell(32242, false);
+            break;
+        case RACE_TROLL:
+            bot->LearnSpell(23243, false);
+            bot->LearnSpell(32295, false);
+            break;
+        case RACE_BLOODELF:
+            bot->LearnSpell(35025, false);
+            bot->LearnSpell(32295, false);
+            break;
+        case RACE_DRAENEI:
+            bot->LearnSpell(35713, false);
+            bot->LearnSpell(32242, false);
+            break;
+    }
+    UpdateTradeSkills();
+    bot->SaveToDB();
+    ClearAllInventory();
+    switch (bot->getClass())
+    {
+        case CLASS_WARRIOR:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51227); // Sanctified Ymirjar Lord's Helmet
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50647); // Ahn'kahar Onyx Neckguard
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51229); // Sanctified Ymirjar Lord's Shoulderplates
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51225); // Sanctified Ymirjar Lord's Battleplate
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50620); // Coldwraith Links
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51228); // Sanctified Ymirjar Lord's Legplates
+            AddEquipment(EQUIPMENT_SLOT_FEET, 54578); // Apocalypse's Advance
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50659); // Polar Bear Claw Bracers
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51226); // Sanctified Ymirjar Lord's Gauntlets
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50657); // Skeleton Lord's Circle
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50693); // Might of Blight
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 40684); // Mirror of Truth
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 47214); // Banner of Victory
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50677); // Winding Sheet
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50730); // Glorenzelg, High-Blade of the Silver Hand
+            //AddEquipment(EQUIPMENT_SLOT_OFFHAND, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 51535); // Wrathful Gladiator's War Edge
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_PALADIN:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51266); // Sanctified Lightsworn Faceguard
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50627); // Noose of Malachite
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51269); // Sanctified Lightsworn Shoulderguards
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51265); // Sanctified Lightsworn Chestguard
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50691); // Belt of Broken Bones
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51268); // Sanctified Lightsworn Legguards
+            AddEquipment(EQUIPMENT_SLOT_FEET, 54579); // Treads of Impending Resurrection
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50611); // Bracers of Dark Reckoning
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51267); // Sanctified Lightsworn Handguards
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50622); // Devium's Eternally Cold Ring
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50642); // Juggernaut Band
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 50356); // Corroded Skeleton Key
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 47735); // Glyph of Indomitability
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50718); // Royal Crimson Cloak
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 51947); // Troggbane, Axe of the Frostborne King
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 50729); // Icecrown Glacial Wall
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 50461); // Libram of the Eternal Tower
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_MAGE:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51281); // Sanctified Bloodmage Hood
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50700); // Holiday's Grace
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51284); // Sanctified Bloodmage Shoulderpads
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51283); // Sanctified Bloodmage Robe
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50613); // Crushing Coldwraith Belt
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51282); // Sanctified Bloodmage Leggings
+            AddEquipment(EQUIPMENT_SLOT_FEET, 51850); // Pale Corpse Boots
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50651); // The Lady's Brittle Bracers
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51280); // Sanctified Bloodmage Gloves
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50610); // Marrowgar's Frigid Eye
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50644); // Ring of Maddening Whispers
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 45490); // Pandora's Plea
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 45929); // Sif's Remembrance
+            AddEquipment(EQUIPMENT_SLOT_BACK, 54583); // Cloak of Burning Dusk
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50704); // Rigormortis
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 50719); // Shadow Silk Spindle
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 50631); // Nightmare Ender
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_PRIEST:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51261); // Sanctified Crimson Acolyte Hood
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50700); // Holiday's Grace
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51264); // Sanctified Crimson Acolyte Shoulderpads
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51263); // Sanctified Crimson Acolyte Robe
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50702); // Lingering Illness
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51262); // Sanctified Crimson Acolyte Leggings
+            AddEquipment(EQUIPMENT_SLOT_FEET, 51850); // Pale Corpse Boots
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50686); // Death Surgeon's Sleeves
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51260); // Sanctified Crimson Acolyte Gloves
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 54585); // Ring of Phased Regeneration
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50610); // Marrowgar's Frigid Eye
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 45490); // Pandora's Plea
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 45929); // Sif's Remembrance
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50668); // Greatcloak of the Turned Champion
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50685); // Trauma
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 50635); // Sundial of Eternal Dusk
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 50631); // Nightmare Ender
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_WARLOCK:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51231); // Sanctified Dark Coven Hood
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50700); // Holiday's Grace
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51234); // Sanctified Dark Coven Shoulderpads
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51233); // Sanctified Dark Coven Robe
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50613); // Crushing Coldwraith Belt
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51232); // Sanctified Dark Coven Leggings
+            AddEquipment(EQUIPMENT_SLOT_FEET, 51850); // Pale Corpse Boots
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50651); // The Lady's Brittle Bracers
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51230); // Sanctified Dark Coven Gloves
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50610); // Marrowgar's Frigid Eye
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50644); // Ring of Maddening Whispers
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 45490); // Pandora's Plea
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 45929); // Sif's Remembrance
+            AddEquipment(EQUIPMENT_SLOT_BACK, 54583); // Cloak of Burning Dusk
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50704); // Rigormortis
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 50719); // Shadow Silk Spindle
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 50631); // Nightmare Ender
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_HUNTER:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51286); // Sanctified Ahn'Kahar Blood Hunter's Headpiece
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50633); // Sindragosa's Cruel Claw
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51288); // Sanctified Ahn'Kahar Blood Hunter's Spaulders
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51289); // Sanctified Ahn'Kahar Blood Hunter's Tunic
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50688); // Nerub'ar Stalker's Cord
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51287); // Sanctified Ahn'Kahar Blood Hunter's Legguards
+            AddEquipment(EQUIPMENT_SLOT_FEET, 54577); // Returning Footfalls
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50655); // Scourge Hunter's Vambraces
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51285); // Sanctified Ahn'Kahar Blood Hunter's Handguards
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50618); // Frostbrood Sapphire Ring
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50678); // Seal of Many Mouths
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 40684); // Mirror of Truth
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 50355); // Herkuml War Token
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50653); // Shadowvault Slayer's Cloak
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 47515); // Decimation
+            //AddEquipment(EQUIPMENT_SLOT_OFFHAND, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 50733); // Fal'inrush, Defender of Quel'thalas
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_ROGUE:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51252); // Sanctified Shadowblade Helmet
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50633); // Sindragosa's Cruel Claw
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51254); // Sanctified Shadowblade Pauldrons
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51250); // Sanctified Shadowblade Breastplate
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50707); // Astrylian's Sutured Cinch
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51253); // Sanctified Shadowblade Legplates
+            AddEquipment(EQUIPMENT_SLOT_FEET, 50607); // Frostbitten Fur Boots
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 54580); // Umbrage Armbands
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51251); // Sanctified Shadowblade Gauntlets
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50618); // Frostbrood Sapphire Ring
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50678); // Seal of Many Mouths
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 40684); // Mirror of Truth
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 50355); // Herkuml War Token
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50653); // Shadowvault Slayer's Cloak
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 51942); // Stormfury, Black Blade of the Betrayer
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 51942); // Stormfury, Black Blade of the Betrayer
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 51535); // Wrathful Gladiator's War Edge
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_DEATH_KNIGHT:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51312); // Sanctified Scourgelord Helmet
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50647); // Ahn'kahar Onyx Neckguard
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51314); // Sanctified Scourgelord Shoulderplates
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51310); // Sanctified Scourgelord Battleplate
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50620); // Coldwraith Links
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51313); // Sanctified Scourgelord Legplates
+            AddEquipment(EQUIPMENT_SLOT_FEET, 54578); // Apocalypse's Advance
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50659); // Polar Bear Claw Bracers
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51311); // Sanctified Scourgelord Gauntlets
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 50657); // Skeleton Lord's Circle
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50693); // Might of Blight
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 40684); // Mirror of Truth
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 47214); // Banner of Victory
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50677); // Winding Sheet
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50730); // Glorenzelg, High-Blade of the Silver Hand
+            //AddEquipment(EQUIPMENT_SLOT_OFFHAND, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 47673); // Sigil of Virulence
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_SHAMAN:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51247); // Sanctified Frost Witch's Headpiece
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50700); // Holiday's Grace
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51245); // Sanctified Frost Witch's Spaulders
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51249); // Sanctified Frost Witch's Tunic
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50671); // Belt of the Blood Nova
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51246); // Sanctified Frost Witch's Legguards
+            AddEquipment(EQUIPMENT_SLOT_FEET, 50652); // Necrophotic Greaves
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 50655); // Scourge Hunter's Vambraces
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51248); // Sanctified Frost Witch's Handguards
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 54585); // Ring of Phased Regeneration
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50610); // Marrowgar's Frigid Eye
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 45490); // Pandora's Plea
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 45929); // Sif's Remembrance
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50668); // Greatcloak of the Turned Champion
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50685); // Trauma
+            AddEquipment(EQUIPMENT_SLOT_OFFHAND, 50635); // Sundial of Eternal Dusk
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 47665); // Totem of Calming Tides
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+        case CLASS_DRUID:
+            AddEquipment(EQUIPMENT_SLOT_HEAD, 51302); // Sanctified Lasherweave Helmet
+            AddEquipment(EQUIPMENT_SLOT_NECK, 50700); // Holiday's Grace
+            AddEquipment(EQUIPMENT_SLOT_SHOULDERS, 51304); // Sanctified Lasherweave Pauldrons
+            //AddEquipment(EQUIPMENT_SLOT_BODY, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_CHEST, 51300); // Sanctified Lasherweave Robes
+            AddEquipment(EQUIPMENT_SLOT_WAIST, 50705); // Professor's Bloodied Smock
+            AddEquipment(EQUIPMENT_SLOT_LEGS, 51303); // Sanctified Lasherweave Legplates
+            AddEquipment(EQUIPMENT_SLOT_FEET, 50665); // Boots of Unnatural Growth
+            AddEquipment(EQUIPMENT_SLOT_WRISTS, 54584); // Phaseshifter's Bracers
+            AddEquipment(EQUIPMENT_SLOT_HANDS, 51301); // Sanctified Lasherweave Gauntlets
+            AddEquipment(EQUIPMENT_SLOT_FINGER1, 54585); // Ring of Phased Regeneration
+            AddEquipment(EQUIPMENT_SLOT_FINGER2, 50610); // Marrowgar's Frigid Eye
+            AddEquipment(EQUIPMENT_SLOT_TRINKET1, 45490); // Pandora's Plea
+            AddEquipment(EQUIPMENT_SLOT_TRINKET2, 45929); // Sif's Remembrance
+            AddEquipment(EQUIPMENT_SLOT_BACK, 50668); // Greatcloak of the Turned Champion
+            AddEquipment(EQUIPMENT_SLOT_MAINHAND, 50731); // Archus, Greatstaff of Antonidas
+            //AddEquipment(EQUIPMENT_SLOT_OFFHAND, XXXXX); // Empty
+            AddEquipment(EQUIPMENT_SLOT_RANGED, 47670); // Idol of Lunar Fury
+            //AddEquipment(EQUIPMENT_SLOT_TABARD, XXXXX); // Empty
+            break;
+    }
+    for (uint8 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        Item* oldItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (oldItem)
+        {
+            bot->RemoveItem(INVENTORY_SLOT_BAG_0, slot, true);
+            oldItem->DestroyForPlayer(bot, false);
+        }
+        uint32 newItemId = 38082; // Gigantique Bag
+        uint16 dest;
+        if (!CanEquipUnseenItem(slot, dest, newItemId))
+            continue;
+        Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+        if (newItem)
+        {
+            newItem->AddToWorld();
+            newItem->AddToUpdateQueueOf(bot);
+        }
+    }
+    uint32 itemId;
+    ItemTemplate const* proto;
+    itemId = 43000; // Drangonfin Filet
+    proto = sObjectMgr->GetItemTemplate(itemId);
+    bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+    bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+    bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+    itemId = 33447; // Runic Healing Potion
+    proto = sObjectMgr->GetItemTemplate(itemId);
+    bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+    itemId = 34722; // Heavy Frostweave Bandage
+    proto = sObjectMgr->GetItemTemplate(itemId);
+    bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+    switch (bot->getClass())
+    {
+        case CLASS_WARRIOR:
+            break;
+        case CLASS_PALADIN:
+            itemId = 21177; // Symbol of Kings
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17033; // Symbol of Divinity
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            break;
+        case CLASS_MAGE:
+            itemId = 17020; // Arcane Powder
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17032; // Rune of Portals
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17031; // Rune of Teleportation
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17056; // Light Feather
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            break;
+        case CLASS_PRIEST:
+            itemId = 17028; // Holy Candle
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17029; // Sacred Candle
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17056; // Light Feather
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 44615; // Devout Candle
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            break;
+        case CLASS_WARLOCK:
+            itemId = 6265; // Soul Shard
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, 20);
+            break;
+        case CLASS_HUNTER:
+            itemId = 52021; // Iceblade Arrow
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, 1000);
+            bot->StoreNewItemInBestSlots(itemId, 1000);
+            bot->StoreNewItemInBestSlots(itemId, 1000);
+            bot->StoreNewItemInBestSlots(itemId, 1000);
+            bot->StoreNewItemInBestSlots(itemId, 1000);
+            bot->SetAmmo(itemId);
+            break;
+        case CLASS_ROGUE:
+            break;
+        case CLASS_DEATH_KNIGHT:
+            itemId = 6948; // Hearthstone
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, 1);
+            break;
+        case CLASS_SHAMAN:
+            itemId = 17057; // Shiny Fish Scales
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17058; // Fish Oil
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17030; // Ankh
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            //itemId = 5175; // Earth Totem
+            //proto = sObjectMgr->GetItemTemplate(itemId);
+            //bot->StoreNewItemInBestSlots(itemId, 1);
+            //itemId = 5176; // Fire Totem
+            //proto = sObjectMgr->GetItemTemplate(itemId);
+            //bot->StoreNewItemInBestSlots(itemId, 1);
+            //itemId = 5177; // Water Totem
+            //proto = sObjectMgr->GetItemTemplate(itemId);
+            //bot->StoreNewItemInBestSlots(itemId, 1);
+            //itemId = 5178; // Air Totem
+            //proto = sObjectMgr->GetItemTemplate(itemId);
+            //bot->StoreNewItemInBestSlots(itemId, 1);
+            break;
+        case CLASS_DRUID:
+            itemId = 17034; // Maple Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17035; // Stranglethorn Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17036; // Ashwood Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17037; // Hornbeam Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17038; // Ironwood Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 22147; // Flintweed Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 44614; // Starleaf Seed
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17021; // Wild Berries
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 17026; // Wild Thornroot
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 22148; // Wild Quillvine
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            itemId = 44605; // Wild Spineleaf
+            proto = sObjectMgr->GetItemTemplate(itemId);
+            bot->StoreNewItemInBestSlots(itemId, proto->GetMaxStackSize());
+            break;
+    }
+    for (uint32 slotIndex = 0; slotIndex < MAX_GLYPH_SLOT_INDEX; ++slotIndex)
+    {
+        bot->SetGlyph(slotIndex, 0);
+    }
+    InitHunterPet();
+    bot->SetMoney(5000000);
+    bot->DurabilityRepairAll(false, 1.0f, false);
+    bot->SetFullHealth();
+    bot->SetPvP(true);
+    if (bot->GetMaxPower(POWER_MANA) > 0)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA));
+    if (bot->GetMaxPower(POWER_ENERGY) > 0)
+        bot->SetPower(POWER_ENERGY, bot->GetMaxPower(POWER_ENERGY));
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::Prepare()
+{
+    if (!itemQuality)
+    {
+        if (level <= 10)
+            itemQuality = urand(ITEM_QUALITY_NORMAL, ITEM_QUALITY_UNCOMMON);
+        else if (level <= 20)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_RARE);
+        else if (level <= 40)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else if (level < 60)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else
+            itemQuality = urand(ITEM_QUALITY_RARE, ITEM_QUALITY_EPIC);
+    }
+
+    if (bot->isDead())
+        bot->ResurrectPlayer(1.0f, false);
+
+    bot->CombatStop(true);
+    bot->SetLevel(level);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+}
+
+void PlayerbotFactory::Randomize(bool incremental)
+{
+    Prepare();
+
+    bot->ResetTalents(true);
+    ClearSpells();
+    ClearInventory();
+    bot->SaveToDB();
+
+    InitQuests();
+    // quest rewards boost bot level, so reduce back
+    bot->SetLevel(level);
+    ClearInventory();
+    bot->SetUInt32Value(PLAYER_XP, 0);
+    CancelAuras();
+    bot->SaveToDB();
+
+    InitAvailableSpells();
+    InitSkills();
+    InitTradeSkills();
+    InitTalents();
+    InitAvailableSpells();
+    InitSpecialSpells();
+    InitMounts();
+    UpdateTradeSkills();
+    bot->SaveToDB();
+
+    InitEquipment(incremental);
+    InitBags();
+    InitAmmo();
+    InitFood();
+    InitPotions();
+    InitSecondEquipmentSet();
+    InitInventory();
+    InitGlyphs();
+    InitGuild();
+    bot->SetMoney(urand(level * 1000, level * 5 * 1000));
+    bot->SaveToDB();
+
+    InitPet();
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::InitPet()
+{
+    Pet* pet = bot->GetPet();
+    if (!pet)
+    {
+        if (bot->getClass() != CLASS_HUNTER)
+            return;
+
+        Map* map = bot->GetMap();
+        if (!map)
+            return;
+
+		vector<uint32> ids;
+	    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+	    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+	    {
+	        CreatureTemplate const& co = i->second;
+            if (!co.IsTameable(false))
+                continue;
+
+            if (co.minlevel > bot->getLevel())
+                continue;
+
+			PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co.Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+			ids.push_back(i->first);
+		}
+
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No pets available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+            return;
+        }
+
+		for (int i = 0; i < 100; i++)
+		{
+			int index = urand(0, ids.size() - 1);
+			CreatureTemplate const* co = sObjectMgr->GetCreatureTemplate(ids[index]);
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co->Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            uint32 guid = sObjectMgr->GenerateLowGuid(HIGHGUID_PET);
+            pet = new Pet(bot, HUNTER_PET);
+            if (!pet->Create(guid, map, 0, ids[index], 0))
+            {
+                delete pet;
+                pet = NULL;
+                continue;
+            }
+
+            pet->SetPosition(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), bot->GetOrientation());
+            pet->setFaction(bot->getFaction());
+            pet->SetLevel(bot->getLevel());
+            bot->SetPetGUID(pet->GetGUID());
+            bot->GetMap()->AddToMap(pet->ToCreature());
+            bot->SetMinion(pet, true);
+            pet->InitTalentForLevel();
+            bot->PetSpellInitialize();
+            bot->InitTamedPet(pet, bot->getLevel(), 0);
+
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "Bot %s: assign pet %d (%d level)", bot->GetName().c_str(), co->Entry, bot->getLevel());
+            pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+            break;
+        }
+    }
+
+    if (!pet)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot create pet for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        if(itr->second.state == PETSPELL_REMOVED)
+            continue;
+
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (spellInfo->IsPassive())
+            continue;
+
+        pet->ToggleAutocast(spellInfo, true);
+    }
+}
+
+void PlayerbotFactory::ClearSpells()
+{
+    list<uint32> spells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        spells.push_back(spellId);
+    }
+
+    for (list<uint32>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        bot->RemoveSpell(*i, false, false);
+    }
+}
+
+void PlayerbotFactory::InitSpells()
+{
+    for (int i = 0; i < 15; i++)
+        InitAvailableSpells();
+}
+
+void PlayerbotFactory::InitTalents()
+{
+    uint32 point = urand(0, 100);
+    uint8 cls = bot->getClass();
+    uint32 p1 = sPlayerbotAIConfig.specProbability[cls][0];
+    uint32 p2 = p1 + sPlayerbotAIConfig.specProbability[cls][1];
+
+    uint32 specNo = (point < p1 ? 0 : (point < p2 ? 1 : 2));
+    InitTalents(specNo);
+
+    if (bot->GetFreeTalentPoints())
+        InitTalents(2 - specNo);
+}
+
+
+class DestroyItemsVisitor : public IterateItemsVisitor
+{
+public:
+    DestroyItemsVisitor(Player* bot) : IterateItemsVisitor(), bot(bot) {}
+
+    virtual bool Visit(Item* item)
+    {
+        uint32 id = item->GetTemplate()->ItemId;
+        if (CanKeep(id))
+        {
+            keep.insert(id);
+            return true;
+        }
+
+        bot->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+        return true;
+    }
+
+private:
+    bool CanKeep(uint32 id)
+    {
+        if (keep.find(id) != keep.end())
+            return false;
+
+        if (sPlayerbotAIConfig.IsInRandomQuestItemList(id))
+            return true;
+
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        if (proto->Class == ITEM_CLASS_MISC && (proto->SubClass == ITEM_SUBCLASS_JUNK_REAGENT || proto->SubClass == ITEM_SUBCLASS_JUNK))
+            return true;
+
+        return false;
+    }
+
+private:
+    Player* bot;
+    set<uint32> keep;
+
+};
+
+bool PlayerbotFactory::CanEquipArmor(ItemTemplate const* proto)
+{
+    if (bot->HasSkill(SKILL_SHIELD) && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        return true;
+
+    if (bot->HasSkill(SKILL_PLATE_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_LEATHER))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+            return false;
+    }
+
+    if (proto->Quality <= ITEM_QUALITY_NORMAL)
+        return true;
+
+    uint8 sp = 0, ap = 0, tank = 0;
+    for (int j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
+    {
+        // for ItemStatValue != 0
+        if(!proto->ItemStat[j].ItemStatValue)
+            continue;
+
+        AddItemStats(proto->ItemStat[j].ItemStatType, sp, ap, tank);
+    }
+
+    return CheckItemStats(sp, ap, tank);
+}
+
+bool PlayerbotFactory::CheckItemStats(uint8 sp, uint8 ap, uint8 tank)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (!sp || ap > sp || tank > sp)
+            return false;
+        break;
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        if ((!ap && !tank) || sp > ap || sp > tank)
+            return false;
+        break;
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        if (!ap || sp > ap || sp > tank)
+            return false;
+        break;
+    }
+
+    return sp || ap || tank;
+}
+
+void PlayerbotFactory::AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank)
+{
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_MANA:
+    case ITEM_MOD_INTELLECT:
+    case ITEM_MOD_SPIRIT:
+    case ITEM_MOD_MANA_REGENERATION:
+    case ITEM_MOD_SPELL_POWER:
+    case ITEM_MOD_SPELL_PENETRATION:
+    case ITEM_MOD_HIT_SPELL_RATING:
+    case ITEM_MOD_CRIT_SPELL_RATING:
+    case ITEM_MOD_HASTE_SPELL_RATING:
+        sp++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_DEFENSE_SKILL_RATING:
+    case ITEM_MOD_DODGE_RATING:
+    case ITEM_MOD_PARRY_RATING:
+    case ITEM_MOD_BLOCK_RATING:
+    case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_HIT_TAKEN_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RATING:
+    case ITEM_MOD_RESILIENCE_RATING:
+    case ITEM_MOD_BLOCK_VALUE:
+        tank++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HIT_MELEE_RATING:
+    case ITEM_MOD_HIT_RANGED_RATING:
+    case ITEM_MOD_CRIT_MELEE_RATING:
+    case ITEM_MOD_CRIT_RANGED_RATING:
+    case ITEM_MOD_HASTE_MELEE_RATING:
+    case ITEM_MOD_HASTE_RANGED_RATING:
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_EXPERTISE_RATING:
+    case ITEM_MOD_ATTACK_POWER:
+    case ITEM_MOD_RANGED_ATTACK_POWER:
+    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+        ap++;
+        break;
+    }
+}
+
+bool PlayerbotFactory::CanEquipWeapon(ItemTemplate const* proto)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE)
+            return false;
+        break;
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_WARRIOR:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    case CLASS_PALADIN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_SHAMAN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_DRUID:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_HUNTER:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW)
+            return false;
+        break;
+    case CLASS_ROGUE:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    }
+
+    return true;
+}
+
+bool PlayerbotFactory::CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality)
+{
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (proto->Quality != desiredQuality)
+        return false;
+
+    if (proto->Bonding == BIND_QUEST_ITEM || proto->Bonding == BIND_WHEN_USE)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_CONTAINER)
+        return true;
+
+    uint32 requiredLevel = proto->RequiredLevel;
+    if (!requiredLevel)
+        return false;
+
+    uint32 level = bot->getLevel();
+    uint32 delta = 2;
+    if (level < 15)
+        delta = urand(7, 15);
+    else if (proto->Class == ITEM_CLASS_WEAPON || proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        delta = urand(2, 3);
+    else if (!(level % 10) || (level % 10) == 9)
+        delta = 2;
+    else if (level < 40)
+        delta = urand(5, 10);
+    else if (level < 60)
+        delta = urand(3, 7);
+    else if (level < 70)
+        delta = urand(2, 5);
+    else if (level < 80)
+        delta = urand(2, 4);
+
+    if (desiredQuality > ITEM_QUALITY_NORMAL &&
+            (requiredLevel > level || requiredLevel < level - delta))
+        return false;
+
+    for (uint32 gap = 60; gap <= 80; gap += 10)
+    {
+        if (level > gap && requiredLevel <= gap)
+            return false;
+    }
+
+    return true;
+}
+
+void PlayerbotFactory::InitEquipment(bool incremental)
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor, ITERATE_ALL_ITEMS);
+
+    map<uint8, vector<uint32> > items;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        uint32 desiredQuality = itemQuality;
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+            desiredQuality--;
+        }
+
+        do
+        {
+            ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+            for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+            {
+                uint32 itemId = i->first;
+                ItemTemplate const* proto = &i->second;
+                if (!proto)
+                    continue;
+
+                if (proto->Class != ITEM_CLASS_WEAPON &&
+                    proto->Class != ITEM_CLASS_ARMOR &&
+                    proto->Class != ITEM_CLASS_CONTAINER &&
+                    proto->Class != ITEM_CLASS_PROJECTILE)
+                    continue;
+
+                if (!CanEquipItem(proto, desiredQuality))
+                    continue;
+
+                if (proto->Class == ITEM_CLASS_ARMOR && (
+                    slot == EQUIPMENT_SLOT_HEAD ||
+                    slot == EQUIPMENT_SLOT_SHOULDERS ||
+                    slot == EQUIPMENT_SLOT_CHEST ||
+                    slot == EQUIPMENT_SLOT_WAIST ||
+                    slot == EQUIPMENT_SLOT_LEGS ||
+                    slot == EQUIPMENT_SLOT_FEET ||
+                    slot == EQUIPMENT_SLOT_WRISTS ||
+                    slot == EQUIPMENT_SLOT_HANDS) && !CanEquipArmor(proto))
+                        continue;
+
+                if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+                    continue;
+
+                if (slot == EQUIPMENT_SLOT_OFFHAND && bot->getClass() == CLASS_ROGUE && proto->Class != ITEM_CLASS_WEAPON)
+                    continue;
+
+                uint16 dest = 0;
+                if (CanEquipUnseenItem(slot, dest, itemId))
+                    items[slot].push_back(itemId);
+            }
+        } while (items[slot].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+    }
+
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        vector<uint32>& ids = items[slot];
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to equip for slot %d", bot->GetName().c_str(), slot);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+            Item* oldItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+            if (incremental && !IsDesiredReplacement(oldItem)) {
+                continue;
+            }
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            if (oldItem)
+            {
+                bot->RemoveItem(INVENTORY_SLOT_BAG_0, slot, true);
+                oldItem->DestroyForPlayer(bot, false);
+            }
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                bot->AutoUnequipOffhandIfNeed();
+                EnchantItem(newItem);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotFactory::IsDesiredReplacement(Item* item)
+{
+    if (!item)
+        return true;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int delta = 1 + (80 - bot->getLevel()) / 10;
+    return (int)bot->getLevel() - (int)proto->RequiredLevel > delta;
+}
+
+void PlayerbotFactory::InitSecondEquipmentSet()
+{
+    if (bot->getClass() == CLASS_MAGE || bot->getClass() == CLASS_WARLOCK || bot->getClass() == CLASS_PRIEST)
+        return;
+
+    map<uint32, vector<uint32> > items;
+
+    uint32 desiredQuality = itemQuality;
+    while (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    do
+    {
+        ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+        {
+            uint32 itemId = i->first;
+            ItemTemplate const* proto = &i->second;
+            if (!proto)
+                continue;
+
+            if (!CanEquipItem(proto, desiredQuality))
+                continue;
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!CanEquipWeapon(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+                if (existingItem)
+                {
+                    switch (existingItem->GetTemplate()->SubClass)
+                    {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    default:
+                        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE && proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_FIST && proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    }
+                }
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (!CanEquipArmor(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                if (existingItem && existingItem->GetTemplate()->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    continue;
+            }
+            else
+                continue;
+
+            items[proto->Class].push_back(itemId);
+        }
+    } while (items[ITEM_CLASS_ARMOR].empty() && items[ITEM_CLASS_WEAPON].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+
+    for (map<uint32, vector<uint32> >::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        vector<uint32>& ids = i->second;
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to make second equipment set for slot %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            ItemPosCountVec sDest;
+            Item* newItem = StoreItem(newItemId, 1);
+            if (newItem)
+            {
+                EnchantItem(newItem);
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::InitBags()
+{
+    vector<uint32> ids;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto || proto->Class != ITEM_CLASS_CONTAINER)
+            continue;
+
+        if (!CanEquipItem(proto, ITEM_QUALITY_NORMAL))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: no bags found", bot->GetName().c_str());
+        return;
+    }
+
+    for (uint8 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::EnchantItem(Item* item)
+{
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance)
+        return;
+
+    if (bot->getLevel() < urand(40, 50))
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int32 itemLevel = proto->ItemLevel;
+
+    vector<uint32> ids;
+    for (int id = 0; id < sSpellStore.GetNumRows(); ++id)
+    {
+        SpellInfo const *entry = sSpellMgr->GetSpellInfo(id);
+        if (!entry)
+            continue;
+
+        int32 requiredLevel = (int32)entry->BaseLevel;
+        if (requiredLevel && (requiredLevel > itemLevel || requiredLevel < itemLevel - 35))
+            continue;
+
+        if (entry->MaxLevel && level > entry->MaxLevel)
+            continue;
+
+        uint32 spellLevel = entry->SpellLevel;
+        if (spellLevel && (spellLevel > level || spellLevel < level - 10))
+            continue;
+
+        for (int j = 0; j < 3; ++j)
+        {
+            if (entry->Effects[j].Effect != SPELL_EFFECT_ENCHANT_ITEM)
+                continue;
+
+            uint32 enchant_id = entry->Effects[j].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchant || enchant->slot != PERM_ENCHANTMENT_SLOT)
+                continue;
+
+            if (enchant->requiredLevel && enchant->requiredLevel > level)
+                continue;
+
+            uint8 sp = 0, ap = 0, tank = 0;
+            for (int i = 0; i < 3; ++i)
+            {
+                if (enchant->type[i] != ITEM_ENCHANTMENT_TYPE_STAT)
+                    continue;
+
+                AddItemStats(enchant->spellid[i], sp, ap, tank);
+            }
+
+            if (!CheckItemStats(sp, ap, tank))
+                continue;
+
+            if (enchant->EnchantmentCondition && !bot->EnchantmentFitsRequirements(enchant->EnchantmentCondition, -1))
+                continue;
+
+            if (!item->IsFitToSpellRequirements(entry))
+                continue;
+
+            ids.push_back(enchant_id);
+        }
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no enchantments found for item %d", bot->GetName().c_str(), item->GetTemplate()->ItemId);
+        return;
+    }
+
+    int index = urand(0, ids.size() - 1);
+    uint32 id = ids[index];
+
+    SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(id);
+    if (!enchant)
+        return;
+
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, id, 0, 0);
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+}
+
+bool PlayerbotFactory::CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item)
+{
+    dest = 0;
+    Item *pItem = Item::CreateItem(item, 1, bot);
+    if (pItem)
+    {
+        InventoryResult result = bot->CanEquipItem(slot, dest, pItem, true, false);
+        pItem->RemoveFromUpdateQueueOf(bot);
+        delete pItem;
+        return result == EQUIP_ERR_OK;
+    }
+
+    return false;
+}
+
+void PlayerbotFactory::InitTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+
+    vector<uint32> firstSkills;
+    vector<uint32> secondSkills;
+    switch (bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        firstSkills.push_back(SKILL_MINING);
+        secondSkills.push_back(SKILL_BLACKSMITHING);
+        secondSkills.push_back(SKILL_ENGINEERING);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_DRUID:
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        firstSkills.push_back(SKILL_SKINNING);
+        secondSkills.push_back(SKILL_LEATHERWORKING);
+        break;
+    default:
+        firstSkills.push_back(SKILL_TAILORING);
+        secondSkills.push_back(SKILL_ENCHANTING);
+    }
+
+    SetRandomSkill(SKILL_FIRST_AID);
+    SetRandomSkill(SKILL_FISHING);
+    SetRandomSkill(SKILL_COOKING);
+
+    switch (urand(0, 3))
+    {
+    case 0:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_ALCHEMY);
+        break;
+    case 1:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_INSCRIPTION);
+        break;
+    case 2:
+        SetRandomSkill(SKILL_MINING);
+        SetRandomSkill(SKILL_JEWELCRAFTING);
+        break;
+    case 3:
+        SetRandomSkill(firstSkills[urand(0, firstSkills.size() - 1)]);
+        SetRandomSkill(secondSkills[urand(0, secondSkills.size() - 1)]);
+        break;
+    }
+}
+
+void PlayerbotFactory::UpdateTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        if (bot->GetSkillValue(tradeSkills[i]) == 1)
+            bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+}
+
+void PlayerbotFactory::InitSkills()
+{
+    uint32 maxValue = level * 5;
+    // FEYZEE: add skills based on class
+    switch (bot->getClass())
+    {
+        case CLASS_WARRIOR:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            SetRandomSkill(SKILL_BOWS);
+            SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            SetRandomSkill(SKILL_2H_MACES);
+            SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            SetRandomSkill(SKILL_THROWN);
+            SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_PALADIN:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            SetRandomSkill(SKILL_2H_SWORDS);
+            //SetRandomSkill(SKILL_STAVES);
+            SetRandomSkill(SKILL_2H_MACES);
+            SetRandomSkill(SKILL_2H_AXES);
+            //SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_MAGE:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            //SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            //SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            //SetRandomSkill(SKILL_2H_MACES);
+            //SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            SetRandomSkill(SKILL_WANDS);
+            //SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_PRIEST:
+            SetRandomSkill(SKILL_DEFENSE);
+            //SetRandomSkill(SKILL_SWORDS);
+            //SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            //SetRandomSkill(SKILL_2H_MACES);
+            //SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            SetRandomSkill(SKILL_WANDS);
+            //SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_WARLOCK:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            //SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            //SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            //SetRandomSkill(SKILL_2H_MACES);
+            //SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            SetRandomSkill(SKILL_WANDS);
+            //SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_HUNTER:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            SetRandomSkill(SKILL_BOWS);
+            SetRandomSkill(SKILL_GUNS);
+            //SetRandomSkill(SKILL_MACES);
+            SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            //SetRandomSkill(SKILL_2H_MACES);
+            SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            SetRandomSkill(SKILL_THROWN);
+            SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_ROGUE:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            SetRandomSkill(SKILL_BOWS);
+            SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            //SetRandomSkill(SKILL_STAVES);
+            //SetRandomSkill(SKILL_2H_MACES);
+            //SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            SetRandomSkill(SKILL_THROWN);
+            SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            //SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_DEATH_KNIGHT:
+            SetRandomSkill(SKILL_DEFENSE);
+            SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            SetRandomSkill(SKILL_2H_SWORDS);
+            //SetRandomSkill(SKILL_STAVES);
+            SetRandomSkill(SKILL_2H_MACES);
+            SetRandomSkill(SKILL_2H_AXES);
+            //SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_SHAMAN:
+            SetRandomSkill(SKILL_DEFENSE);
+            //SetRandomSkill(SKILL_SWORDS);
+            SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            SetRandomSkill(SKILL_2H_MACES);
+            SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            //SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+        case CLASS_DRUID:
+            SetRandomSkill(SKILL_DEFENSE);
+            //SetRandomSkill(SKILL_SWORDS);
+            //SetRandomSkill(SKILL_AXES);
+            //SetRandomSkill(SKILL_BOWS);
+            //SetRandomSkill(SKILL_GUNS);
+            SetRandomSkill(SKILL_MACES);
+            //SetRandomSkill(SKILL_2H_SWORDS);
+            SetRandomSkill(SKILL_STAVES);
+            SetRandomSkill(SKILL_2H_MACES);
+            //SetRandomSkill(SKILL_2H_AXES);
+            SetRandomSkill(SKILL_DAGGERS);
+            //SetRandomSkill(SKILL_THROWN);
+            //SetRandomSkill(SKILL_CROSSBOWS);
+            //SetRandomSkill(SKILL_WANDS);
+            SetRandomSkill(SKILL_POLEARMS);
+            //SetRandomSkill(SKILL_FIST_WEAPONS);
+            SetRandomSkill(SKILL_UNARMED);
+            break;
+    }
+
+    if (bot->getLevel() >= 70)
+        bot->SetSkill(SKILL_RIDING, 0, 300, 300);
+    else if (bot->getLevel() >= 60)
+        bot->SetSkill(SKILL_RIDING, 0, 225, 225);
+    else if (bot->getLevel() >= 40)
+        bot->SetSkill(SKILL_RIDING, 0, 150, 150);
+    else if (bot->getLevel() >= 20)
+        bot->SetSkill(SKILL_RIDING, 0, 75, 75);
+    else
+        bot->SetSkill(SKILL_RIDING, 0, 0, 0);
+
+    uint32 skillLevel = bot->getLevel() < 40 ? 0 : 1;
+    switch (bot->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        bot->SetSkill(SKILL_PLATE_MAIL, 0, skillLevel, skillLevel);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_HUNTER:
+        bot->SetSkill(SKILL_MAIL, 0, skillLevel, skillLevel);
+    }
+}
+
+void PlayerbotFactory::SetRandomSkill(uint16 id)
+{
+    uint32 maxValue = level * 5;
+    uint32 curValue = urand(maxValue - level, maxValue);
+    bot->SetSkill(id, 0, curValue, maxValue);
+
+}
+
+void PlayerbotFactory::InitAvailableSpells()
+{
+    bot->LearnDefaultSkills();
+
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.trainer_type != TRAINER_TYPE_TRADESKILLS && co.trainer_type != TRAINER_TYPE_CLASS)
+            continue;
+
+        if (co.trainer_type == TRAINER_TYPE_CLASS && co.trainer_class != bot->getClass())
+            continue;
+
+		uint32 trainerId = co.Entry;
+
+		TrainerSpellData const* trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+        if (!trainer_spells)
+            trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+
+        if (!trainer_spells)
+            continue;
+
+        for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+        {
+            TrainerSpell const* tSpell = &itr->second;
+
+            if (!tSpell)
+                continue;
+
+            if (!tSpell->learnedSpell[0] && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                continue;
+
+            TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+            if (state != TRAINER_SPELL_GREEN)
+                continue;
+
+            if (tSpell->learnedSpell)
+                bot->LearnSpell(tSpell->learnedSpell[0], false);
+            else
+                ai->CastSpell(tSpell->spell, bot);
+        }
+    }
+}
+
+void PlayerbotFactory::InitSpecialSpells()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotSpellIds.begin(); i != sPlayerbotAIConfig.randomBotSpellIds.end(); ++i)
+    {
+        uint32 spellId = *i;
+        bot->LearnSpell(spellId, false);
+    }
+}
+
+void PlayerbotFactory::InitTalents(uint32 specNo)
+{
+    uint32 classMask = bot->getClassMask();
+
+    map<uint32, vector<TalentEntry const*> > spells;
+    for (uint32 i = 0; i < sTalentStore.GetNumRows(); ++i)
+    {
+        TalentEntry const *talentInfo = sTalentStore.LookupEntry(i);
+        if(!talentInfo)
+            continue;
+
+        TalentTabEntry const *talentTabInfo = sTalentTabStore.LookupEntry( talentInfo->TalentTab );
+        if(!talentTabInfo || talentTabInfo->tabpage != specNo)
+            continue;
+
+        if( (classMask & talentTabInfo->ClassMask) == 0 )
+            continue;
+
+        spells[talentInfo->Row].push_back(talentInfo);
+    }
+
+    uint32 freePoints = bot->GetFreeTalentPoints();
+    for (map<uint32, vector<TalentEntry const*> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        vector<TalentEntry const*> &spells = i->second;
+        if (spells.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: No spells for talent row %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        int attemptCount = 0;
+        while (!spells.empty() && (int)freePoints - (int)bot->GetFreeTalentPoints() < 5 && attemptCount++ < 3 && bot->GetFreeTalentPoints())
+        {
+            int index = urand(0, spells.size() - 1);
+            TalentEntry const *talentInfo = spells[index];
+            int maxRank = 0;
+            for (int rank = 0; rank < min((uint32)MAX_TALENT_RANK, bot->GetFreeTalentPoints()); ++rank)
+            {
+                uint32 spellId = talentInfo->RankID[rank];
+                if (!spellId)
+                    continue;
+
+                maxRank = rank;
+            }
+
+            bot->LearnTalent(talentInfo->TalentID, maxRank);
+			spells.erase(spells.begin() + index);
+        }
+
+        freePoints = bot->GetFreeTalentPoints();
+    }
+
+    for (uint32 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        for (PlayerTalentMap::iterator itr = bot->GetTalentMap(i).begin(); itr != bot->GetTalentMap(i).end(); ++itr)
+        {
+            if (itr->second->state != PLAYERSPELL_REMOVED)
+                itr->second->state = PLAYERSPELL_CHANGED;
+        }
+    }
+}
+
+ObjectGuid PlayerbotFactory::GetRandomBot()
+{
+    vector<ObjectGuid> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, fields[0].GetUInt32());
+            if (!sObjectMgr->GetPlayerByLowGUID(guid))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+    if (guids.empty())
+        return ObjectGuid();
+
+    int index = urand(0, guids.size() - 1);
+    return guids[index];
+}
+
+void PlayerbotFactory::InitQuests()
+{
+    QueryResult results = WorldDatabase.PQuery("SELECT Id, RequiredClasses, RequiredRaces FROM quest_template where Level = -1 and MinLevel <= '%u'",
+            bot->getLevel());
+
+    list<uint32> ids;
+    do
+    {
+        Field* fields = results->Fetch();
+        uint32 questId = fields[0].GetUInt32();
+        uint16 requiredClasses = fields[1].GetUInt16();
+        uint16 requiredRaces = fields[2].GetUInt16();
+        if ((requiredClasses & bot->getClassMask()) && (requiredRaces & bot->getRaceMask()))
+            ids.push_back(questId);
+    } while (results->NextRow());
+
+    for (int i = 0; i < 15; i++)
+    {
+        for (list<uint32>::iterator i = ids.begin(); i != ids.end(); ++i)
+        {
+			uint32 questId = *i;
+            Quest const *quest = sObjectMgr->GetQuestTemplate(questId);
+
+            bot->SetQuestStatus(questId, QUEST_STATUS_NONE);
+
+            if (!bot->SatisfyQuestClass(quest, false) ||
+                    !bot->SatisfyQuestRace(quest, false) ||
+                    !bot->SatisfyQuestStatus(quest, false))
+                continue;
+
+            if (quest->IsDailyOrWeekly() || quest->IsRepeatable() || quest->IsMonthly())
+                continue;
+
+            bot->SetQuestStatus(questId, QUEST_STATUS_COMPLETE);
+            bot->RewardQuest(quest, 0, bot, false);
+            ClearInventory();
+        }
+    }
+}
+
+void PlayerbotFactory::ClearInventory()
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor);
+}
+
+// FEYZEE: new functions used by init=high80 command
+void PlayerbotFactory::ClearAllInventory()
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor, ITERATE_ALL_ITEMS);
+}
+
+void PlayerbotFactory::InitAmmo()
+{
+    if (bot->getClass() != CLASS_HUNTER && bot->getClass() != CLASS_ROGUE && bot->getClass() != CLASS_WARRIOR)
+        return;
+
+    Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+    if (!pItem)
+        return;
+
+    uint32 subClass = 0;
+    switch (pItem->GetTemplate()->SubClass)
+    {
+    case ITEM_SUBCLASS_WEAPON_GUN:
+        subClass = ITEM_SUBCLASS_BULLET;
+        break;
+    case ITEM_SUBCLASS_WEAPON_BOW:
+    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+        subClass = ITEM_SUBCLASS_ARROW;
+        break;
+    }
+
+    if (!subClass)
+        return;
+
+    QueryResult results = WorldDatabase.PQuery("select max(entry), max(RequiredLevel) from item_template where class = '%u' and subclass = '%u' and RequiredLevel <= '%u'",
+            ITEM_CLASS_PROJECTILE, subClass, bot->getLevel());
+
+    Field* fields = results->Fetch();
+    if (fields)
+    {
+        uint32 entry = fields[0].GetUInt32();
+        for (int i = 0; i < 5; i++)
+        {
+            bot->StoreNewItemInBestSlots(entry, 1000);
+        }
+        bot->SetAmmo(entry);
+    }
+}
+
+void PlayerbotFactory::InitMounts()
+{
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); ++spellId)
+    {
+        SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if (spellInfo->GetDuration() != -1)
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < 50)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    for (uint32 type = 0; type < 2; ++type)
+    {
+        map<int32, vector<uint32> >& spells = allSpells[type];
+        for (map<int32, vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+        {
+            int32 effect = i->first;
+            vector<uint32>& ids = i->second;
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            bot->LearnSpell(ids[index], false);
+        }
+    }
+}
+
+void PlayerbotFactory::InitPotions()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_POTION ||
+            proto->Spells[0].SpellCategory != 4 ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+        {
+            const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+            if (!spellInfo)
+                continue;
+
+            for (int i = 0 ; i < 3; i++)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_HEAL || spellInfo->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                {
+                    items[spellInfo->Effects[i].Effect].push_back(itemId);
+                    break;
+                }
+            }
+        }
+    }
+
+    uint32 effects[] = { SPELL_EFFECT_HEAL, SPELL_EFFECT_ENERGIZE };
+    for (int i = 0; i < sizeof(effects) / sizeof(uint32); ++i)
+    {
+        uint32 effect = effects[i];
+        vector<uint32>& ids = items[effect];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+void PlayerbotFactory::InitFood()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_FOOD ||
+            (proto->Spells[0].SpellCategory != 11 && proto->Spells[0].SpellCategory != 59) ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        items[proto->Spells[0].SpellCategory].push_back(itemId);
+    }
+
+    uint32 categories[] = { 11, 59 };
+    for (int i = 0; i < sizeof(categories) / sizeof(uint32); ++i)
+    {
+        uint32 category = categories[i];
+        vector<uint32>& ids = items[category];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+
+void PlayerbotFactory::CancelAuras()
+{
+    bot->RemoveAllAuras();
+}
+
+void PlayerbotFactory::InitInventory()
+{
+    InitInventoryTrade();
+    InitInventoryEquip();
+    InitInventorySkill();
+}
+
+void PlayerbotFactory::InitInventorySkill()
+{
+    if (bot->HasSkill(SKILL_MINING)) {
+        StoreItem(2901, 1); // Mining Pick
+    }
+    if (bot->HasSkill(SKILL_JEWELCRAFTING)) {
+        StoreItem(20815, 1); // Jeweler's Kit
+        StoreItem(20824, 1); // Simple Grinder
+    }
+    if (bot->HasSkill(SKILL_BLACKSMITHING) || bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(5956, 1); // Blacksmith Hammer
+    }
+    if (bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(6219, 1); // Arclight Spanner
+    }
+    if (bot->HasSkill(SKILL_ENCHANTING)) {
+        StoreItem(44452, 1); // Runed Titanium Rod
+    }
+    if (bot->HasSkill(SKILL_INSCRIPTION)) {
+        StoreItem(39505, 1); // Virtuoso Inking Set
+    }
+    if (bot->HasSkill(SKILL_SKINNING)) {
+        StoreItem(7005, 1); // Skinning Knife
+    }
+}
+
+Item* PlayerbotFactory::StoreItem(uint32 itemId, uint32 count)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    ItemPosCountVec sDest;
+    InventoryResult msg = bot->CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, itemId, count);
+    if (msg != EQUIP_ERR_OK)
+        return NULL;
+
+    return bot->StoreNewItem(sDest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+}
+
+void PlayerbotFactory::InitInventoryTrade()
+{
+    vector<uint32> ids;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_TRADE_GOODS || proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->ItemLevel < bot->getLevel())
+            continue;
+
+        if (proto->RequiredLevel > bot->getLevel() || proto->RequiredLevel < bot->getLevel() - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        // FEYZEE: hide error caused by no trade items available
+        //sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No trade items available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+        return;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    if (index >= ids.size())
+        return;
+
+    uint32 itemId = ids[index];
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    uint32 count = 1, stacks = 1;
+    switch (proto->Quality)
+    {
+    case ITEM_QUALITY_NORMAL:
+        count = proto->GetMaxStackSize();
+        stacks = urand(1, 7) / auctionbot.GetRarityPriceMultiplier(proto);
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        stacks = 1;
+        count = urand(1, proto->GetMaxStackSize());
+        break;
+    case ITEM_QUALITY_RARE:
+        stacks = 1;
+        count = urand(1, min(uint32(3), proto->GetMaxStackSize()));
+        break;
+    }
+
+    for (uint32 i = 0; i < stacks; i++)
+        StoreItem(itemId, count);
+}
+
+void PlayerbotFactory::InitInventoryEquip()
+{
+    vector<uint32> ids;
+
+    uint32 desiredQuality = itemQuality;
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_WEAPON || (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_WHEN_USE))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_ARMOR && !CanEquipArmor(proto))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+            continue;
+
+        if (!CanEquipItem(proto, desiredQuality))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    int maxCount = urand(0, 3);
+    int count = 0;
+    for (int attempts = 0; attempts < 15; attempts++)
+    {
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        if (StoreItem(itemId, 1) && count++ >= maxCount)
+            break;
+   }
+}
+
+void PlayerbotFactory::InitGlyphs()
+{
+    bot->InitGlyphsForLevel();
+
+    for (uint32 slotIndex = 0; slotIndex < MAX_GLYPH_SLOT_INDEX; ++slotIndex)
+    {
+        bot->SetGlyph(slotIndex, 0);
+    }
+
+    uint32 level = bot->getLevel();
+    uint32 maxSlot = 0;
+    if (level >= 15)
+        maxSlot = 2;
+    if (level >= 30)
+        maxSlot = 3;
+    if (level >= 50)
+        maxSlot = 4;
+    if (level >= 70)
+        maxSlot = 5;
+    if (level >= 80)
+        maxSlot = 6;
+
+    if (!maxSlot)
+        return;
+
+    list<uint32> glyphs;
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_GLYPH)
+            continue;
+
+        if ((proto->AllowableClass & bot->getClassMask()) == 0 || (proto->AllowableRace & bot->getRaceMask()) == 0)
+            continue;
+
+        for (uint32 spell = 0; spell < MAX_ITEM_PROTO_SPELLS; spell++)
+        {
+            uint32 spellId = proto->Spells[spell].SpellId;
+            SpellInfo const *entry = sSpellMgr->GetSpellInfo(spellId);
+            if (!entry)
+                continue;
+
+            for (uint32 effect = 0; effect <= EFFECT_2; ++effect)
+            {
+                if (entry->Effects[effect].Effect != SPELL_EFFECT_APPLY_GLYPH)
+                    continue;
+
+                uint32 glyph = entry->Effects[effect].MiscValue;
+                glyphs.push_back(glyph);
+            }
+        }
+    }
+
+    if (glyphs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    set<uint32> chosen;
+    for (uint32 slotIndex = 0; slotIndex < maxSlot; ++slotIndex)
+    {
+        uint32 slot = bot->GetGlyphSlot(slotIndex);
+        GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(slot);
+        if (!gs)
+            continue;
+
+        vector<uint32> ids;
+        for (list<uint32>::iterator i = glyphs.begin(); i != glyphs.end(); ++i)
+        {
+            uint32 id = *i;
+            GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(id);
+            if (!gp || gp->TypeFlags != gs->TypeFlags)
+                continue;
+
+            ids.push_back(id);
+        }
+
+        int maxCount = urand(0, 3);
+        int count = 0;
+        bool found = false;
+        for (int attempts = 0; attempts < 15; ++attempts)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            uint32 id = ids[index];
+            if (chosen.find(id) != chosen.end())
+                continue;
+
+            chosen.insert(id);
+
+            bot->SetGlyph(slotIndex, id);
+            found = true;
+            break;
+        }
+        if (!found)
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s index %d slot %d", bot->GetName().c_str(), slotIndex, slot);
+    }
+}
+
+void PlayerbotFactory::InitGuild()
+{
+    if (bot->GetGuildId())
+        return;
+
+    if (sPlayerbotAIConfig.randomBotGuilds.empty())
+        RandomPlayerbotFactory::CreateRandomGuilds();
+
+    vector<uint32> guilds;
+    for(list<uint32>::iterator i = sPlayerbotAIConfig.randomBotGuilds.begin(); i != sPlayerbotAIConfig.randomBotGuilds.end(); ++i)
+        guilds.push_back(*i);
+
+    if (guilds.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No random guilds available");
+        return;
+    }
+
+    int index = urand(0, guilds.size() - 1);
+    uint32 guildId = guilds[index];
+    Guild* guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Invalid guild %u", guildId);
+        return;
+    }
+
+    if (guild->GetMemberCount() < 10)
+        guild->AddMember(bot->GetGUID(), urand(GR_OFFICER, GR_INITIATE));
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotFactory.h b/src/plugins/playerbot/PlayerbotFactory.h
new file mode 100644
index 0000000..415dc2d
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.h
@@ -0,0 +1,74 @@
+#pragma once
+
+#include "strategy/actions/InventoryAction.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using ai::InventoryAction;
+
+class PlayerbotFactory : public InventoryAction
+{
+public:
+    PlayerbotFactory(Player* bot, uint32 level, uint32 itemQuality = 0) :
+        bot(bot), level(level), itemQuality(itemQuality), InventoryAction(bot->GetPlayerbotAI(), "factory") {}
+
+    static ObjectGuid GetRandomBot();
+    void CleanRandomize();
+    // FEYZEE: new functions used by init=high80 command
+    void CleanBuild();
+    void Randomize();
+    void Refresh();
+
+private:
+    // FEYZEE: new functions used by init=high80 command
+    void AddEquipment(uint8 Slot, uint32 ItemId);
+    void InitHunterPet();
+    void ClearAllInventory();
+    void Randomize(bool incremental);
+    void Prepare();
+    void InitSecondEquipmentSet();
+    void InitEquipment(bool incremental);
+    bool CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality);
+    bool CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item);
+    void InitSkills();
+    void InitTradeSkills();
+    void UpdateTradeSkills();
+    void SetRandomSkill(uint16 id);
+    void InitSpells();
+    void ClearSpells();
+    void InitAvailableSpells();
+    void InitSpecialSpells();
+    void InitTalents();
+    void InitTalents(uint32 specNo);
+    void InitQuests();
+    void InitPet();
+    void ClearInventory();
+    void InitAmmo();
+    void InitMounts();
+    void InitPotions();
+    void InitFood();
+    bool CanEquipArmor(ItemTemplate const* proto);
+    bool CanEquipWeapon(ItemTemplate const* proto);
+    void EnchantItem(Item* item);
+    void AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank);
+    bool CheckItemStats(uint8 sp, uint8 ap, uint8 tank);
+    void CancelAuras();
+    bool IsDesiredReplacement(Item* item);
+    void InitBags();
+    void InitInventory();
+    void InitInventoryTrade();
+    void InitInventoryEquip();
+    void InitInventorySkill();
+    Item* StoreItem(uint32 itemId, uint32 count);
+    void InitGlyphs();
+    void InitGuild();
+
+private:
+    Player* bot;
+    uint32 level;
+    uint32 itemQuality;
+    static uint32 tradeSkills[];
+};
diff --git a/src/plugins/playerbot/PlayerbotMgr.cpp b/src/plugins/playerbot/PlayerbotMgr.cpp
new file mode 100644
index 0000000..69163ae
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.cpp
@@ -0,0 +1,479 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "RandomPlayerbotMgr.h"
+
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+PlayerbotHolder::PlayerbotHolder() : PlayerbotAIBase()
+{
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+        sSpellStore.LookupEntry(spellId);
+}
+
+PlayerbotHolder::~PlayerbotHolder()
+{
+    LogoutAllBots();
+}
+
+
+void PlayerbotHolder::UpdateAIInternal(uint32 elapsed)
+{
+}
+
+void PlayerbotHolder::UpdateSessions(uint32 elapsed)
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* const bot = itr->second;
+        if (bot->IsBeingTeleported())
+        {
+            bot->GetPlayerbotAI()->HandleTeleportAck();
+        }
+        else if (bot->IsInWorld())
+        {
+            bot->GetSession()->HandleBotPackets();
+        }
+    }
+}
+
+void PlayerbotHolder::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot= itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+void PlayerbotHolder::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        bot->GetPlayerbotAI()->TellMaster("Goodbye!");
+        //bot->SaveToDB();
+
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+Player* PlayerbotHolder::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = playerBots.find(playerGuid);
+    return (it == playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotHolder::OnBotLogin(Player * const bot)
+{
+	PlayerbotAI* ai = new PlayerbotAI(bot);
+	bot->SetPlayerbotAI(ai);
+	OnBotLoginInternal(bot);
+
+    playerBots[bot->GetGUID()] = bot;
+
+    Player* master = ai->GetMaster();
+    if (master)
+    {
+        ObjectGuid masterGuid = master->GetGUID();
+        if (master->GetGroup() &&
+            ! master->GetGroup()->IsLeader(masterGuid))
+            master->GetGroup()->ChangeLeader(masterGuid);
+    }
+
+    Group *group = bot->GetGroup();
+    if (group)
+    {
+        bool groupValid = false;
+        Group::MemberSlotList const& slots = group->GetMemberSlots();
+        for (Group::MemberSlotList::const_iterator i = slots.begin(); i != slots.end(); ++i)
+        {
+            ObjectGuid member = i->guid;
+            uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(member);
+            if (!sPlayerbotAIConfig.IsInRandomAccountList(account))
+            {
+                groupValid = true;
+                break;
+            }
+        }
+
+        if (!groupValid)
+        {
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+        }
+    }
+
+    ai->ResetStrategies();
+    ai->TellMaster("Hello!");
+}
+
+string PlayerbotHolder::ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId)
+{
+    if (!sPlayerbotAIConfig.enabled || guid.IsEmpty())
+        return "bot system is disabled";
+
+    uint32 botAccount = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    bool isRandomBot = sRandomPlayerbotMgr.IsRandomBot(guid);
+    bool isRandomAccount = sPlayerbotAIConfig.IsInRandomAccountList(botAccount);
+    bool isMasterAccount = (masterAccountId == botAccount);
+
+    if (isRandomAccount && !isRandomBot && !admin)
+    {
+        Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (bot->GetGuildId() != masterGuildId)
+            return "not in your guild";
+    }
+
+    if (!isRandomAccount && !isMasterAccount && !admin)
+        return "not in your account";
+
+    if (cmd == "add" || cmd == "login")
+    {
+        if (sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player already logged in";
+
+        AddPlayerBot(guid.GetRawValue(), masterAccountId);
+        return "ok";
+    }
+    else if (cmd == "remove" || cmd == "logout" || cmd == "rm")
+    {
+        if (!sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player is offline";
+
+        if (!GetPlayerBot(guid.GetRawValue()))
+            return "not your bot";
+
+        LogoutPlayerBot(guid.GetRawValue());
+        return "ok";
+    }
+
+    if (admin)
+    {
+        Player* bot = GetPlayerBot(guid.GetRawValue());
+        if (!bot)
+            return "bot not found";
+
+        Player* master = bot->GetPlayerbotAI()->GetMaster();
+        if (master)
+        {
+            if (cmd == "init=white" || cmd == "init=common")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_NORMAL);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=green" || cmd == "init=uncommon")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_UNCOMMON);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=blue" || cmd == "init=rare")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_RARE);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=epic" || cmd == "init=purple")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_EPIC);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            // FEYZEE: new command init=high80 used for 6000 gearscore gear set for bots
+            else if (cmd == "init=high80")
+            {
+                PlayerbotFactory factory(bot, 80, ITEM_QUALITY_EPIC);
+                factory.CleanBuild();
+                return "ok";
+            }
+        }
+
+        if (cmd == "update")
+        {
+            PlayerbotFactory factory(bot, bot->getLevel());
+            factory.Refresh();
+            return "ok";
+        }
+        else if (cmd == "random")
+        {
+            sRandomPlayerbotMgr.Randomize(bot);
+            return "ok";
+        }
+    }
+
+    return "unknown command";
+}
+
+bool PlayerbotMgr::HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args)
+{
+	if (!sPlayerbotAIConfig.enabled)
+	{
+		handler->PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+		handler->SetSentErrorMessage(true);
+        return false;
+	}
+
+    WorldSession *m_session = handler->GetSession();
+
+    if (!m_session)
+    {
+        handler->PSendSysMessage("You may only add bots from an active session");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    Player* player = m_session->GetPlayer();
+    PlayerbotMgr* mgr = player->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        handler->PSendSysMessage("you cannot control bots yet");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    list<string> messages = mgr->HandlePlayerbotCommand(args, player);
+    if (messages.empty())
+        return true;
+
+    for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+    {
+        handler->PSendSysMessage(i->c_str());
+    }
+
+    handler->SetSentErrorMessage(true);
+    return false;
+}
+
+list<string> PlayerbotHolder::HandlePlayerbotCommand(char const* args, Player* master)
+{
+    list<string> messages;
+
+    if (!*args)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    set<string> bots;
+    if (charnameStr == "*" && master)
+    {
+        Group* group = master->GetGroup();
+        if (!group)
+        {
+            messages.push_back("you must be in group");
+            return messages;
+        }
+
+        Group::MemberSlotList slots = group->GetMemberSlots();
+        for (Group::member_citerator i = slots.begin(); i != slots.end(); i++)
+        {
+			ObjectGuid member = i->guid;
+
+			if (member == master->GetGUID())
+				continue;
+
+			string bot;
+			if (sObjectMgr->GetPlayerNameByGUID(member, bot))
+			    bots.insert(bot);
+        }
+    }
+
+    if (charnameStr == "!" && master && master->GetSession()->GetSecurity() > SEC_GAMEMASTER)
+    {
+        for (PlayerBotMap::const_iterator i = GetPlayerBotsBegin(); i != GetPlayerBotsEnd(); ++i)
+        {
+            Player* bot = i->second;
+            if (bot && bot->IsInWorld())
+                bots.insert(bot->GetName());
+        }
+    }
+
+    vector<string> chars = split(charnameStr, ',');
+    for (vector<string>::iterator i = chars.begin(); i != chars.end(); i++)
+    {
+        string s = *i;
+
+        uint32 accountId = GetAccountId(s);
+        if (!accountId)
+        {
+            bots.insert(s);
+            continue;
+        }
+
+        QueryResult results = CharacterDatabase.PQuery(
+            "SELECT name FROM characters WHERE account = '%u'",
+            accountId);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                string charName = fields[0].GetString();
+                bots.insert(charName);
+            } while (results->NextRow());
+        }
+	}
+
+    for (set<string>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        string bot = *i;
+        ostringstream out;
+        out << cmdStr << ": " << bot << " - ";
+
+        ObjectGuid member = sObjectMgr->GetPlayerGUIDByName(bot);
+        if (!member)
+        {
+            out << "character not found";
+        }
+        else if (master && member != master->GetGUID())
+        {
+            out << ProcessBotCommand(cmdStr, member,
+                    master->GetSession()->GetSecurity() >= SEC_GAMEMASTER,
+                    master->GetSession()->GetAccountId(),
+                    master->GetGuildId());
+        }
+        else if (!master)
+        {
+            out << ProcessBotCommand(cmdStr, member, true, -1, -1);
+        }
+
+        messages.push_back(out.str());
+    }
+
+    return messages;
+}
+
+uint32 PlayerbotHolder::GetAccountId(string name)
+{
+    uint32 accountId = 0;
+
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account WHERE username = '%s'", name.c_str());
+    if(results)
+    {
+        Field* fields = results->Fetch();
+        accountId = fields[0].GetUInt32();
+    }
+
+    return accountId;
+}
+
+
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : PlayerbotHolder(),  master(master)
+{
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+}
+
+void PlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.reactDelay);
+}
+
+void PlayerbotMgr::HandleCommand(uint32 type, const string& text)
+{
+    Player *master = GetMaster();
+    if (!master)
+        return;
+
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == master)
+            bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    switch (packet.GetOpcode())
+    {
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+    }
+}
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+}
+
+void PlayerbotMgr::SaveToDB()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->SaveToDB();
+    }
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->SaveToDB();
+    }
+}
+
+void PlayerbotMgr::OnBotLoginInternal(Player * const bot)
+{
+    bot->GetPlayerbotAI()->SetMaster(master);
+    bot->GetPlayerbotAI()->ResetStrategies();
+}
+
diff --git a/src/plugins/playerbot/PlayerbotMgr.h b/src/plugins/playerbot/PlayerbotMgr.h
new file mode 100644
index 0000000..d22074c
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "../pchdef.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+typedef map<uint64, Player*> PlayerBotMap;
+
+class PlayerbotHolder : public PlayerbotAIBase
+{
+public:
+    PlayerbotHolder();
+    virtual ~PlayerbotHolder();
+
+    void AddPlayerBot(uint64 guid, uint32 masterAccountId);
+    void LogoutPlayerBot(uint64 guid);
+    Player* GetPlayerBot (uint64 guid) const;
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return playerBots.end();   }
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+    void UpdateSessions(uint32 elapsed);
+
+    void LogoutAllBots();
+    void OnBotLogin(Player * const bot);
+
+    list<string> HandlePlayerbotCommand(char const* args, Player* master = NULL);
+    string ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId);
+    uint32 GetAccountId(string name);
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot) = 0;
+
+protected:
+    PlayerBotMap playerBots;
+};
+
+class PlayerbotMgr : public PlayerbotHolder
+{
+public:
+    PlayerbotMgr(Player* const master);
+    virtual ~PlayerbotMgr();
+
+    static bool HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+    void HandleCommand(uint32 type, const string& text);
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+
+    Player* GetMaster() const { return master; };
+
+    void SaveToDB();
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot);
+
+private:
+    Player* const master;
+};
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotSecurity.cpp b/src/plugins/playerbot/PlayerbotSecurity.cpp
new file mode 100644
index 0000000..c925543
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.cpp
@@ -0,0 +1,188 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "ChatHelper.h"
+
+PlayerbotSecurity::PlayerbotSecurity(Player* const bot) : bot(bot)
+{
+    if (bot)
+        account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+}
+
+PlayerbotSecurityLevel PlayerbotSecurity::LevelFor(Player* from, DenyReason* reason, bool ignoreGroup)
+{
+    if (from->GetSession()->GetSecurity() >= SEC_GAMEMASTER)
+        return PLAYERBOT_SECURITY_ALLOW_ALL;
+
+    if (from->GetPlayerbotAI())
+    {
+        if (reason) *reason = PLAYERBOT_DENY_IS_BOT;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (bot->GetPlayerbotAI()->IsOpposing(from))
+    {
+        if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account))
+    {
+        if (bot->GetPlayerbotAI()->IsOpposing(from))
+        {
+            if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+            return PLAYERBOT_SECURITY_DENY_ALL;
+        }
+
+        Group* group = from->GetGroup();
+        if (group)
+        {
+            for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+            {
+                Player* player = gref->GetSource();
+                if (player == bot && !ignoreGroup)
+                    return PLAYERBOT_SECURITY_ALLOW_ALL;
+            }
+        }
+        // FEYZEE: disable bot invite rejects caused by level, distance and gear difference
+        /*
+        if ((int)bot->getLevel() - (int)from->getLevel() > 5)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_LOW_LEVEL;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->GetMapId() != from->GetMapId() || bot->GetDistance(from) > sPlayerbotAIConfig.whisperDistance)
+        {
+            if (!bot->GetGuildId() || bot->GetGuildId() != from->GetGuildId())
+            {
+                if (reason) *reason = PLAYERBOT_DENY_FAR;
+                return PLAYERBOT_SECURITY_TALK;
+            }
+        }
+
+        int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+        int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+        if (botGS && bot->getLevel() > 15 && (100 * (botGS - fromGS) / botGS) >= 20)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_GEARSCORE;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+        */
+        if (bot->isDead())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_DEAD;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        group = bot->GetGroup();
+        if (!group)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_INVITE;
+            return PLAYERBOT_SECURITY_INVITE;
+        }
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* player = gref->GetSource();
+            if (player == from)
+                return PLAYERBOT_SECURITY_ALLOW_ALL;
+        }
+
+        if (group->IsFull())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_FULL_GROUP;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (reason) *reason = PLAYERBOT_DENY_INVITE;
+        return PLAYERBOT_SECURITY_INVITE;
+    }
+
+    return PLAYERBOT_SECURITY_ALLOW_ALL;
+}
+
+bool PlayerbotSecurity::CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup)
+{
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel realLevel = LevelFor(from, &reason, ignoreGroup);
+    if (realLevel >= level)
+        return true;
+
+    if (silent || from->GetPlayerbotAI())
+        return false;
+
+    Player* master = bot->GetPlayerbotAI()->GetMaster();
+    if (master && bot->GetPlayerbotAI() && bot->GetPlayerbotAI()->IsOpposing(master) && master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+        return false;
+
+    ostringstream out;
+    switch (realLevel)
+    {
+    case PLAYERBOT_SECURITY_DENY_ALL:
+        out << "I'm kind of busy now";
+        break;
+    case PLAYERBOT_SECURITY_TALK:
+        switch (reason)
+        {
+        case PLAYERBOT_DENY_NONE:
+            out << "I'll do it later";
+            break;
+        case PLAYERBOT_DENY_LOW_LEVEL:
+            out << "You are too low level: |cffff0000" << (uint32)from->getLevel() << "|cffffffff/|cff00ff00" << (uint32)bot->getLevel();
+            break;
+        case PLAYERBOT_DENY_GEARSCORE:
+            {
+                int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+                int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+                out << "Your gearscore is too low: |cffff0000" << fromGS << "|cffffffff/|cff00ff00" << botGS;
+            }
+            break;
+        case PLAYERBOT_DENY_NOT_YOURS:
+            out << "I have a master already";
+            break;
+        case PLAYERBOT_DENY_IS_BOT:
+            out << "You are a bot";
+            break;
+        case PLAYERBOT_DENY_OPPOSING:
+            out << "You are the enemy";
+            break;
+        case PLAYERBOT_DENY_DEAD:
+            out << "I'm dead. Will do it later";
+            break;
+        case PLAYERBOT_DENY_INVITE:
+            out << "Invite me to your group first";
+            break;
+        case PLAYERBOT_DENY_FAR:
+            {
+                out << "I am too far away";
+
+                uint32 area = bot->GetAreaId();
+                if (area)
+                {
+                    const AreaTableEntry* entry = sAreaStore.LookupEntry(area);
+                    if (entry)
+                    {
+                        out << " |cffffffff(|cffff0000" << entry->area_name[0] << "|cffffffff)";
+                    }
+                }
+            }
+            break;
+        case PLAYERBOT_DENY_FULL_GROUP:
+            out << "I am in a full group. Will do it later";
+            break;
+        default:
+            out << "I can't do that";
+            break;
+        }
+        break;
+    case PLAYERBOT_SECURITY_INVITE:
+        out << "Invite me to your group first";
+        break;
+    }
+
+	bot->Whisper(out.str(), LANG_UNIVERSAL, from);
+    return false;
+}
diff --git a/src/plugins/playerbot/PlayerbotSecurity.h b/src/plugins/playerbot/PlayerbotSecurity.h
new file mode 100644
index 0000000..5349555
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.h
@@ -0,0 +1,42 @@
+#ifndef _PlayerbotSecurity_H
+#define _PlayerbotSecurity_H
+
+using namespace std;
+
+enum PlayerbotSecurityLevel
+{
+    PLAYERBOT_SECURITY_DENY_ALL = 0,
+    PLAYERBOT_SECURITY_TALK = 1,
+    PLAYERBOT_SECURITY_INVITE = 2,
+    PLAYERBOT_SECURITY_ALLOW_ALL = 3
+};
+
+enum DenyReason
+{
+    PLAYERBOT_DENY_NONE,
+    PLAYERBOT_DENY_LOW_LEVEL,
+    PLAYERBOT_DENY_GEARSCORE,
+    PLAYERBOT_DENY_NOT_YOURS,
+    PLAYERBOT_DENY_IS_BOT,
+    PLAYERBOT_DENY_OPPOSING,
+    PLAYERBOT_DENY_DEAD,
+    PLAYERBOT_DENY_FAR,
+    PLAYERBOT_DENY_INVITE,
+    PLAYERBOT_DENY_FULL_GROUP
+};
+
+class PlayerbotSecurity
+{
+    public:
+        PlayerbotSecurity(Player* const bot);
+
+	public:
+        PlayerbotSecurityLevel LevelFor(Player* from, DenyReason* reason = NULL, bool ignoreGroup = false);
+        bool CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup = false);
+
+    private:
+        Player* const bot;
+        uint32 account;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomItemMgr.cpp b/src/plugins/playerbot/RandomItemMgr.cpp
new file mode 100644
index 0000000..712d1f1
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.cpp
@@ -0,0 +1,154 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomItemMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "DatabaseEnv.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+
+char * strstri (const char* str1, const char* str2);
+
+class RandomItemGuildTaskPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_UNCOMMON)
+            return false;
+
+        if ((proto->Class == ITEM_CLASS_ARMOR || proto->Class == ITEM_CLASS_WEAPON) && proto->Quality >= ITEM_QUALITY_RARE)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS || proto->Class == ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        return false;
+    }
+};
+
+class RandomItemGuildTaskRewardPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_RARE)
+            return false;
+
+        if (proto->Class == ITEM_CLASS_QUEST)
+            return false;
+
+        return true;
+    }
+};
+
+RandomItemMgr::RandomItemMgr()
+{
+    predicates[RANDOM_ITEM_GUILD_TASK] = new RandomItemGuildTaskPredicate();
+    predicates[RANDOM_ITEM_GUILD_TASK_REWARD] = new RandomItemGuildTaskRewardPredicate();
+}
+
+RandomItemMgr::~RandomItemMgr()
+{
+    for (map<RandomItemType, RandomItemPredicate*>::iterator i = predicates.begin(); i != predicates.end(); ++i)
+        delete i->second;
+
+    predicates.clear();
+}
+
+bool RandomItemMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!args || !*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: rnditem");
+        return false;
+    }
+
+    return false;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList &list = cache[type];
+    if (list.empty())
+        list = cache[type] = Query(type);
+
+    RandomItemList result;
+    for (RandomItemList::iterator i = list.begin(); i != list.end(); ++i)
+    {
+        uint32 itemId = *i;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (predicate && !predicate->Apply(proto))
+            continue;
+
+        result.push_back(itemId);
+    }
+
+    return result;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type)
+{
+    RandomItemList items;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Duration & 0x80000000)
+            continue;
+
+        if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+            continue;
+
+        if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+            continue;
+
+        if ((proto->RequiredLevel && proto->RequiredLevel > sAhBotConfig.maxRequiredLevel) || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+            continue;
+
+        if (predicates[type] && !predicates[type]->Apply(proto))
+            continue;
+
+        if (!auctionbot.GetSellPrice(proto))
+            continue;
+
+        items.push_back(itemId);
+    }
+
+    if (items.empty())
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "no items available for random item query %u", type);
+
+    return items;
+}
+
+uint32 RandomItemMgr::GetRandomItem(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList const& list = Query(type, predicate);
+    if (list.empty())
+        return 0;
+
+    uint32 index = urand(0, list.size() - 1);
+    uint32 itemId = list[index];
+
+    return itemId;
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/RandomItemMgr.h b/src/plugins/playerbot/RandomItemMgr.h
new file mode 100644
index 0000000..a0f8149
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.h
@@ -0,0 +1,50 @@
+#ifndef _RandomItemMgr_H
+#define _RandomItemMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+enum RandomItemType
+{
+    RANDOM_ITEM_GUILD_TASK,
+    RANDOM_ITEM_GUILD_TASK_REWARD
+};
+
+class RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto) = 0;
+};
+
+typedef vector<uint32> RandomItemList;
+typedef map<RandomItemType, RandomItemList> RandomItemCache;
+
+class RandomItemMgr
+{
+    public:
+        RandomItemMgr();
+        virtual ~RandomItemMgr();
+        static RandomItemMgr& instance()
+        {
+            static RandomItemMgr instance;
+            return instance;
+        }
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        RandomItemList Query(RandomItemType type, RandomItemPredicate* predicate);
+        uint32 GetRandomItem(RandomItemType type, RandomItemPredicate* predicate = NULL);
+
+    private:
+        RandomItemList Query(RandomItemType type);
+
+    private:
+        RandomItemCache cache;
+        map<RandomItemType, RandomItemPredicate*> predicates;
+};
+
+#define sRandomItemMgr RandomItemMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.cpp b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
new file mode 100644
index 0000000..3ac6954
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
@@ -0,0 +1,357 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "../../server/game/Entities/Player/Player.h"
+#include "../../server/game/Guilds/Guild.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "RandomPlayerbotFactory.h"
+
+map<uint8, vector<uint8> > RandomPlayerbotFactory::availableRaces;
+
+RandomPlayerbotFactory::RandomPlayerbotFactory(uint32 accountId) : accountId(accountId)
+{
+    availableRaces[CLASS_WARRIOR].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DWARF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_ORC);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TAUREN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TROLL);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DRAENEI);
+
+    availableRaces[CLASS_PALADIN].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DWARF);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PALADIN].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_ROGUE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_ROGUE].push_back(RACE_DWARF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_GNOME);
+    availableRaces[CLASS_ROGUE].push_back(RACE_ORC);
+    availableRaces[CLASS_ROGUE].push_back(RACE_TROLL);
+    availableRaces[CLASS_ROGUE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_PRIEST].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DWARF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PRIEST].push_back(RACE_TROLL);
+    availableRaces[CLASS_PRIEST].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_PRIEST].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_MAGE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_MAGE].push_back(RACE_GNOME);
+    availableRaces[CLASS_MAGE].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_MAGE].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_MAGE].push_back(RACE_TROLL);
+    availableRaces[CLASS_MAGE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_WARLOCK].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_ORC);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_SHAMAN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_ORC);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TAUREN);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TROLL);
+
+    availableRaces[CLASS_HUNTER].push_back(RACE_DWARF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_HUNTER].push_back(RACE_ORC);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TAUREN);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TROLL);
+    availableRaces[CLASS_HUNTER].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_DRUID].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_DRUID].push_back(RACE_TAUREN);
+}
+
+bool RandomPlayerbotFactory::CreateRandomBot(uint8 cls)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Creating new random bot for class %d", cls);
+
+    uint8 gender = rand() % 2 ? GENDER_MALE : GENDER_FEMALE;
+
+    uint8 race = availableRaces[cls][urand(0, availableRaces[cls].size() - 1)];
+    string name = CreateRandomBotName();
+    if (name.empty())
+        return false;
+
+    uint8 skin = urand(0, 7);
+    uint8 face = urand(0, 7);
+    uint8 hairStyle = urand(0, 7);
+    uint8 hairColor = urand(0, 7);
+    uint8 facialHair = urand(0, 7);
+    uint8 outfitId = 0;
+
+    WorldSession* session = new WorldSession(accountId, NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+    if (!session)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Couldn't create session for random bot account %d", accountId);
+        delete session;
+        return false;
+    }
+
+    Player *player = new Player(session);
+    CharacterCreateInfo cci;
+    cci.Name = name;
+    cci.Race = race;
+    cci.Class = cls;
+    cci.Gender = gender;
+    cci.Skin = skin;
+    cci.Face = face;
+    cci.HairStyle = hairStyle;
+    cci.HairColor = hairColor;
+    cci.FacialHair = facialHair;
+    cci.OutfitId = outfitId;
+
+    if (!player->Create(sObjectMgr->GenerateLowGuid(HIGHGUID_PLAYER), &cci))
+    {
+        player->DeleteFromDB(player->GetGUID(), accountId, true, true);
+        delete session;
+        delete player;
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Unable to create random bot for account %d - name: \"%s\"; race: %u; class: %u; gender: %u; skin: %u; face: %u; hairStyle: %u; hairColor: %u; facialHair: %u; outfitId: %u",
+                accountId, name.c_str(), race, cls, gender, skin, face, hairStyle, hairColor, facialHair, outfitId);
+        return false;
+    }
+
+    player->setCinematic(2);
+    player->SetAtLoginFlag(AT_LOGIN_NONE);
+    player->SaveToDB(true);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot created for account %d - name: \"%s\"; race: %u; class: %u; gender: %u; skin: %u; face: %u; hairStyle: %u; hairColor: %u; facialHair: %u; outfitId: %u",
+            accountId, name.c_str(), race, cls, gender, skin, face, hairStyle, hairColor, facialHair, outfitId);
+
+    return true;
+}
+
+string RandomPlayerbotFactory::CreateRandomBotName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_names n "
+            "LEFT OUTER JOIN characters e ON e.name = n.name "
+            "WHERE e.guid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random bots");
+        return "";
+    }
+
+	fields = result->Fetch();
+    return fields[0].GetString();
+}
+
+
+void RandomPlayerbotFactory::CreateRandomBots()
+{
+    if (sPlayerbotAIConfig.deleteRandomBotAccounts)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot accounts...");
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                sAccountMgr->DeleteAccount(fields[0].GetUInt32());
+            } while (results->NextRow());
+        }
+
+        CharacterDatabase.Execute("DELETE FROM ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot accounts deleted");
+    }
+
+    for (int accountNumber = 0; accountNumber < sPlayerbotAIConfig.randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (results)
+        {
+            continue;
+        }
+
+        string password = "";
+        for (int i = 0; i < 10; i++)
+        {
+            password += (char)urand('!', 'z');
+        }
+        sAccountMgr->CreateAccount(accountName, password, "playerbot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Account %s created for random bots", accountName.c_str());
+    }
+
+    LoginDatabase.PExecute("UPDATE account SET expansion = '%u' where username like '%s%%'", 2, sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+
+    int totalRandomBotChars = 0;
+    for (int accountNumber = 0; accountNumber < sPlayerbotAIConfig.randomBotAccountCount; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (!results)
+            continue;
+
+        Field* fields = results->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+
+        sPlayerbotAIConfig.randomBotAccounts.push_back(accountId);
+
+        int count = sAccountMgr->GetCharactersCount(accountId);
+        if (count >= 10)
+        {
+            totalRandomBotChars += count;
+            continue;
+        }
+
+        RandomPlayerbotFactory factory(accountId);
+        for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+        {
+            if (cls != 10 && cls != CLASS_DEATH_KNIGHT)
+                factory.CreateRandomBot(cls);
+        }
+
+        totalRandomBotChars += sAccountMgr->GetCharactersCount(accountId);
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot accounts with %d characters available", sPlayerbotAIConfig.randomBotAccounts.size(), totalRandomBotChars);
+}
+
+
+void RandomPlayerbotFactory::CreateRandomGuilds()
+{
+    vector<uint32> randomBots;
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 accountId = fields[0].GetUInt32();
+
+            QueryResult results2 = CharacterDatabase.PQuery("SELECT guid FROM characters where account  = '%u'", accountId);
+            if (results2)
+            {
+                do
+                {
+                    Field* fields = results2->Fetch();
+                    uint32 guid = fields[0].GetUInt32();
+                    randomBots.push_back(guid);
+                } while (results2->NextRow());
+            }
+
+        } while (results->NextRow());
+    }
+
+    if (sPlayerbotAIConfig.deleteRandomBotGuilds)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot guilds...");
+        for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+        {
+            ObjectGuid leader(HIGHGUID_PLAYER, *i);
+            Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+            if (guild) guild->Disband();
+        }
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot guilds deleted");
+    }
+
+    int guildNumber = 0;
+    vector<ObjectGuid> availableLeaders;
+    for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+    {
+        ObjectGuid leader(HIGHGUID_PLAYER, *i);
+        Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+        if (guild)
+        {
+            ++guildNumber;
+            sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+        }
+        else
+        {
+            Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+            if (player)
+                availableLeaders.push_back(leader);
+        }
+    }
+
+    for (; guildNumber < sPlayerbotAIConfig.randomBotGuildCount; ++guildNumber)
+    {
+        string guildName = CreateRandomGuildName();
+        if (guildName.empty())
+            break;
+
+        if (availableLeaders.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No leaders for random guilds available");
+            break;
+        }
+
+        int index = urand(0, availableLeaders.size() - 1);
+        ObjectGuid leader = availableLeaders[index];
+        Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+        if (!player)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot find player for leader %u", leader);
+            break;
+        }
+
+        Guild* guild = new Guild();
+        if (!guild->Create(player, guildName))
+        {
+            // FEYZEE: hide error caused by guild create
+            //sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Error creating guild %s", guildName.c_str());
+            break;
+        }
+
+        sGuildMgr->AddGuild(guild);
+        sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot guilds available", guildNumber);
+}
+
+string RandomPlayerbotFactory::CreateRandomGuildName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_guild_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_guild_names n "
+            "LEFT OUTER JOIN guild e ON e.name = n.name "
+            "WHERE e.guildid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    fields = result->Fetch();
+    return fields[0].GetString();
+}
+
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.h b/src/plugins/playerbot/RandomPlayerbotFactory.h
new file mode 100644
index 0000000..76f4d08
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.h
@@ -0,0 +1,35 @@
+#ifndef _RandomPlayerbotFactory_H
+#define _RandomPlayerbotFactory_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotFactory
+{
+    public:
+        RandomPlayerbotFactory(uint32 accountId);
+		virtual ~RandomPlayerbotFactory() {}
+
+	public:
+        bool CreateRandomBot(uint8 cls);
+        static void CreateRandomBots();
+        static void CreateRandomGuilds();
+
+	private:
+        string CreateRandomBotName();
+        static string CreateRandomGuildName();
+
+    private:
+        uint32 accountId;
+        static map<uint8, vector<uint8> > availableRaces;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.cpp b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
new file mode 100644
index 0000000..fe9433d
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
@@ -0,0 +1,893 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "AiFactory.h"
+#include "../../game/Maps/MapManager.h"
+#include "PlayerbotCommandServer.h"
+#include "GuildTaskMgr.h"
+
+RandomPlayerbotMgr::RandomPlayerbotMgr() : PlayerbotHolder(), processTicks(0)
+{
+    sPlayerbotCommandServer.Start();
+}
+
+RandomPlayerbotMgr::~RandomPlayerbotMgr()
+{
+}
+
+void RandomPlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.randomBotUpdateInterval * 1000);
+
+    if (!sPlayerbotAIConfig.randomBotAutologin || !sPlayerbotAIConfig.enabled)
+        return;
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Processing random bots...");
+
+    int maxAllowedBotCount = GetEventValue(0, "bot_count");
+    if (!maxAllowedBotCount)
+    {
+        maxAllowedBotCount = urand(sPlayerbotAIConfig.minRandomBots, sPlayerbotAIConfig.maxRandomBots);
+        SetEventValue(0, "bot_count", maxAllowedBotCount,
+                urand(sPlayerbotAIConfig.randomBotCountChangeMinInterval, sPlayerbotAIConfig.randomBotCountChangeMaxInterval));
+    }
+
+    list<uint32> bots = GetBots();
+    int botCount = bots.size();
+    int allianceNewBots = 0, hordeNewBots = 0;
+    int randomBotsPerInterval = (int)urand(sPlayerbotAIConfig.minRandomBotsPerInterval, sPlayerbotAIConfig.maxRandomBotsPerInterval);
+    if (!processTicks)
+    {
+        if (sPlayerbotAIConfig.randomBotLoginAtStartup)
+            randomBotsPerInterval = bots.size();
+    }
+
+    while (botCount++ < maxAllowedBotCount)
+    {
+        bool alliance = botCount % 2;
+        uint32 bot = AddRandomBot(alliance);
+        if (bot)
+        {
+            if (alliance)
+                allianceNewBots++;
+            else
+                hordeNewBots++;
+
+            bots.push_back(bot);
+        }
+        else
+            break;
+    }
+
+    int botProcessed = 0;
+    for (list<uint32>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        uint32 bot = *i;
+        if (ProcessBot(bot))
+            botProcessed++;
+
+        if (botProcessed >= randomBotsPerInterval)
+            break;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d bots processed. %d alliance and %d horde bots added. %d bots online. Next check in %d seconds",
+            botProcessed, allianceNewBots, hordeNewBots, playerBots.size(), sPlayerbotAIConfig.randomBotUpdateInterval);
+
+    if (processTicks++ == 1)
+        PrintStats();
+}
+
+uint32 RandomPlayerbotMgr::AddRandomBot(bool alliance)
+{
+    vector<uint32> bots = GetFreeBots(alliance);
+    if (bots.size() == 0)
+        return 0;
+
+    int index = urand(0, bots.size() - 1);
+    uint32 bot = bots[index];
+    SetEventValue(bot, "add", 1, urand(sPlayerbotAIConfig.minRandomBotInWorldTime, sPlayerbotAIConfig.maxRandomBotInWorldTime));
+    uint32 randomTime = 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3);
+    ScheduleRandomize(bot, randomTime);
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot %d added", bot);
+    return bot;
+}
+
+void RandomPlayerbotMgr::ScheduleRandomize(uint32 bot, uint32 time)
+{
+    SetEventValue(bot, "randomize", 1, time);
+    SetEventValue(bot, "logout", 1, time + 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+void RandomPlayerbotMgr::ScheduleTeleport(uint32 bot)
+{
+    SetEventValue(bot, "teleport", 1, 60 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+bool RandomPlayerbotMgr::ProcessBot(uint32 bot)
+{
+    uint32 isValid = GetEventValue(bot, "add");
+    if (!isValid)
+    {
+		Player* player = GetPlayerBot(bot);
+		if (!player || !player->GetGroup())
+		{
+			sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d expired", bot);
+			SetEventValue(bot, "add", 0, 0);
+		}
+        return true;
+    }
+
+    if (!GetPlayerBot(bot))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d logged in", bot);
+        AddPlayerBot(bot, 0);
+        if (!GetEventValue(bot, "online"))
+        {
+            SetEventValue(bot, "online", 1, sPlayerbotAIConfig.minRandomBotInWorldTime);
+        }
+        return true;
+    }
+
+    Player* player = GetPlayerBot(bot);
+    if (!player)
+        return false;
+
+    PlayerbotAI* ai = player->GetPlayerbotAI();
+    if (!ai)
+        return false;
+
+    if (player->GetGroup())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Skipping bot %d as it is in group", bot);
+        return false;
+    }
+
+    if (player->isDead())
+    {
+        if (!GetEventValue(bot, "dead"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Setting dead flag for bot %d", bot);
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotReviveTime, sPlayerbotAIConfig.maxRandomBotReviveTime);
+            SetEventValue(bot, "dead", 1, randomTime);
+            SetEventValue(bot, "revive", 1, randomTime - 60);
+            return false;
+        }
+
+        if (!GetEventValue(bot, "revive"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Reviving dead bot %d", bot);
+            SetEventValue(bot, "dead", 0, 0);
+            SetEventValue(bot, "revive", 0, 0);
+            RandomTeleport(player, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+            return true;
+        }
+
+        return false;
+    }
+
+    if (player->GetGuild() && player->GetGuild()->GetLeaderGUID() == player->GetGUID())
+    {
+        for (vector<Player*>::iterator i = players.begin(); i != players.end(); ++i)
+            sGuildTaskMgr.Update(*i, player);
+    }
+
+    uint32 randomize = GetEventValue(bot, "randomize");
+    if (!randomize)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %d", bot);
+        Randomize(player);
+        uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+        ScheduleRandomize(bot, randomTime);
+        return true;
+    }
+
+    uint32 logout = GetEventValue(bot, "logout");
+    if (!logout)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Logging out bot %d", bot);
+        LogoutPlayerBot(bot);
+        SetEventValue(bot, "logout", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    uint32 teleport = GetEventValue(bot, "teleport");
+    if (!teleport)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %d", bot);
+        RandomTeleportForLevel(ai->GetBot());
+        SetEventValue(bot, "teleport", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, vector<WorldLocation> &locs)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (locs.empty())
+    {
+        // FEYZEE: hide error caused by bot teleport
+        //sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+        return;
+    }
+
+    for (int attemtps = 0; attemtps < 10; ++attemtps)
+    {
+        int index = urand(0, locs.size() - 1);
+        WorldLocation loc = locs[index];
+        float x = loc.m_positionX + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float y = loc.m_positionY + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float z = loc.m_positionZ;
+
+        Map* map = sMapMgr->FindMap(loc.GetMapId(), 0);
+        if (!map)
+            continue;
+
+        if (!map->IsOutdoors(x, y, z) ||
+                map->IsInWater(x, y, z))
+            continue;
+
+        uint32 areaId = map->GetAreaId(x, y, z);
+        if (!areaId)
+            continue;
+
+        AreaTableEntry const* area = sAreaStore.LookupEntry(areaId);
+        if (!area)
+            continue;
+
+        float ground = map->GetHeight(x, y, z + 0.5f);
+        if (ground <= INVALID_HEIGHT)
+            continue;
+
+        z = 0.05f + ground;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s to %s %f,%f,%f", bot->GetName().c_str(), area->area_name[0], x, y, z);
+
+        bot->GetMotionMaster()->Clear();
+        bot->TeleportTo(loc.GetMapId(), x, y, z, 0);
+        return;
+    }
+
+    // FEYZEE: hide error caused by bot teleport
+    //sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+}
+
+void RandomPlayerbotMgr::RandomTeleportForLevel(Player* bot)
+{
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select map, position_x, position_y, position_z "
+        "from (select map, position_x, position_y, position_z, avg(t.maxlevel), avg(t.minlevel), "
+        "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+        "from creature c inner join creature_template t on c.id = t.entry group by t.entry) q "
+        "where delta >= 0 and delta <= %u and map in (%s) and not exists ( "
+        "select map, position_x, position_y, position_z from "
+        "("
+        "select map, c.position_x, c.position_y, c.position_z, avg(t.maxlevel), avg(t.minlevel), "
+        "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+        "from creature c "
+        "inner join creature_template t on c.id = t.entry group by t.entry "
+        ") q1 "
+        "where delta > %u and q1.map = q.map "
+        "and sqrt("
+        "(q1.position_x - q.position_x)*(q1.position_x - q.position_x) +"
+        "(q1.position_y - q.position_y)*(q1.position_y - q.position_y) +"
+        "(q1.position_z - q.position_z)*(q1.position_z - q.position_z)"
+        ") < %u)",
+        bot->getLevel(),
+        sPlayerbotAIConfig.randomBotTeleLevel,
+        sPlayerbotAIConfig.randomBotMapsAsString.c_str(),
+        bot->getLevel(),
+        sPlayerbotAIConfig.randomBotTeleLevel,
+        sPlayerbotAIConfig.sightDistance
+        );
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint16 mapId = fields[0].GetUInt16();
+            float x = fields[1].GetFloat();
+            float y = fields[2].GetFloat();
+            float z = fields[3].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select position_x, position_y, position_z from creature where map = '%u' and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            float x = fields[0].GetFloat();
+            float y = fields[1].GetFloat();
+            float z = fields[2].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+    Refresh(bot);
+}
+
+void RandomPlayerbotMgr::Randomize(Player* bot)
+{
+    if (bot->getLevel() == 1)
+        RandomizeFirst(bot);
+    else
+        IncreaseLevel(bot);
+}
+
+void RandomPlayerbotMgr::IncreaseLevel(Player* bot)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    uint32 level = min((uint32)(bot->getLevel() + 1), maxLevel);
+    PlayerbotFactory factory(bot, level);
+    if (bot->GetGuildId())
+        factory.Refresh();
+    else
+        factory.Randomize();
+    RandomTeleportForLevel(bot);
+}
+
+void RandomPlayerbotMgr::RandomizeFirst(Player* bot)
+{
+    uint32 maxLevel = sPlayerbotAIConfig.randomBotMaxLevel;
+    if (maxLevel > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+    for (int attempt = 0; attempt < 100; ++attempt)
+    {
+        int index = urand(0, sPlayerbotAIConfig.randomBotMaps.size() - 1);
+        uint16 mapId = sPlayerbotAIConfig.randomBotMaps[index];
+
+        vector<GameTele const*> locs;
+        GameTeleContainer const & teleMap = sObjectMgr->GetGameTeleMap();
+        for(GameTeleContainer::const_iterator itr = teleMap.begin(); itr != teleMap.end(); ++itr)
+        {
+            GameTele const* tele = &itr->second;
+            if (tele->mapId == mapId)
+                locs.push_back(tele);
+        }
+
+        index = urand(0, locs.size() - 1);
+        GameTele const* tele = locs[index];
+        uint32 level = GetZoneLevel(tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        if (level > maxLevel + 5)
+            continue;
+
+        level = min(level, maxLevel);
+        if (!level) level = 1;
+
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomBotMaxLevelChance)
+            level = maxLevel;
+
+        if (level < sPlayerbotAIConfig.randomBotMinLevel)
+            continue;
+
+        PlayerbotFactory factory(bot, level);
+        factory.CleanRandomize();
+        RandomTeleport(bot, tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        break;
+    }
+}
+
+uint32 RandomPlayerbotMgr::GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+	uint32 level;
+    QueryResult results = WorldDatabase.PQuery("select avg(t.minlevel) minlevel, avg(t.maxlevel) maxlevel from creature c "
+            "inner join creature_template t on c.id = t.entry "
+            "where map = '%u' and minlevel > 1 and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint8 minLevel = fields[0].GetUInt8();
+        uint8 maxLevel = fields[1].GetUInt8();
+        level = urand(minLevel, maxLevel);
+        if (level > maxLevel)
+            level = maxLevel;
+    }
+    else
+    {
+        level = urand(1, maxLevel);
+    }
+
+    return level;
+}
+
+void RandomPlayerbotMgr::Refresh(Player* bot)
+{
+    if (bot->isDead())
+    {
+        bot->ResurrectPlayer(1.0f);
+        bot->SpawnCorpseBones();
+        bot->SaveToDB();
+        bot->GetPlayerbotAI()->ResetStrategies();
+    }
+
+    bot->GetPlayerbotAI()->Reset();
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        unit->RemoveAllAttackers();
+        unit->ClearInCombat();
+
+        ref = ref->next();
+    }
+
+    bot->RemoveAllAttackers();
+    bot->ClearInCombat();
+
+    bot->DurabilityRepairAll(false, 1.0f, false);
+    bot->SetFullHealth();
+    bot->SetPvP(true);
+
+    if (bot->GetMaxPower(POWER_MANA) > 0)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA));
+
+    if (bot->GetMaxPower(POWER_ENERGY) > 0)
+        bot->SetPower(POWER_ENERGY, bot->GetMaxPower(POWER_ENERGY));
+}
+
+
+bool RandomPlayerbotMgr::IsRandomBot(Player* bot)
+{
+    return IsRandomBot(bot->GetGUID());
+}
+
+bool RandomPlayerbotMgr::IsRandomBot(uint32 bot)
+{
+    return GetEventValue(bot, "add");
+}
+
+list<uint32> RandomPlayerbotMgr::GetBots()
+{
+    list<uint32> bots;
+
+    QueryResult results = CharacterDatabase.Query(
+            "select bot from ai_playerbot_random_bots where owner = 0 and event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.push_back(bot);
+        } while (results->NextRow());
+    }
+
+    return bots;
+}
+
+vector<uint32> RandomPlayerbotMgr::GetFreeBots(bool alliance)
+{
+    set<uint32> bots;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `bot` from ai_playerbot_random_bots where event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.insert(bot);
+        } while (results->NextRow());
+    }
+
+    vector<uint32> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            if (bots.find(guid) == bots.end() &&
+                    ((alliance && IsAlliance(race)) || ((!alliance && !IsAlliance(race))
+            )))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+
+    return guids;
+}
+
+uint32 RandomPlayerbotMgr::GetEventValue(uint32 bot, string event)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+uint32 RandomPlayerbotMgr::SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_random_bots (owner, bot, `time`, validIn, event, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                0, bot, (uint32)time(0), validIn, event.c_str(), value);
+    }
+
+    return value;
+}
+
+bool RandomPlayerbotMgr::HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Playerbot system is currently disabled!");
+        return false;
+    }
+
+    if (!args || !*args)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Usage: rndbot stats/update/reset/init/refresh/add/remove");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bots were reset for all players");
+        return true;
+    }
+    else if (cmd == "stats")
+    {
+        sRandomPlayerbotMgr.PrintStats();
+        return true;
+    }
+    else if (cmd == "update")
+    {
+        sRandomPlayerbotMgr.UpdateAIInternal(0);
+        return true;
+    }
+    else if (cmd == "init" || cmd == "refresh" || cmd == "teleport")
+    {
+		sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bots for %d accounts", sPlayerbotAIConfig.randomBotAccounts.size());
+        for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); ++i)
+        {
+            uint32 account = *i;
+            if (QueryResult results = CharacterDatabase.PQuery("SELECT guid FROM characters where account = '%u'", account))
+            {
+                do
+                {
+                    Field* fields = results->Fetch();
+                    ObjectGuid guid = ObjectGuid(HIGHGUID_PLAYER, fields[0].GetUInt32());
+                    Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+                    if (!bot)
+                        continue;
+
+                    if (cmd == "init")
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %s for account %u", bot->GetName().c_str(), account);
+                        sRandomPlayerbotMgr.RandomizeFirst(bot);
+                    }
+                    else if (cmd == "teleport")
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s for account %u", bot->GetName().c_str(), account);
+                        sRandomPlayerbotMgr.RandomTeleportForLevel(bot);
+                    }
+                    else
+                    {
+                        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Refreshing bot %s for account %u", bot->GetName().c_str(), account);
+                        bot->SetLevel(bot->getLevel() - 1);
+                        sRandomPlayerbotMgr.IncreaseLevel(bot);
+                    }
+                    uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+                    CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'randomize' and bot = '%u'",
+                            randomTime, bot->GetGUIDLow());
+                    CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'logout' and bot = '%u'",
+                            sPlayerbotAIConfig.maxRandomBotInWorldTime, bot->GetGUIDLow());
+                } while (results->NextRow());
+            }
+        }
+        return true;
+    }
+    else
+    {
+        list<string> messages = sRandomPlayerbotMgr.HandlePlayerbotCommand(args, NULL);
+        for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, i->c_str());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, fromPlayer);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogout(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        PlayerbotAI* ai = bot->GetPlayerbotAI();
+        if (player == ai->GetMaster())
+        {
+            ai->SetMaster(NULL);
+            ai->ResetStrategies();
+        }
+    }
+
+    if (!player->GetPlayerbotAI())
+    {
+        vector<Player*>::iterator i = find(players.begin(), players.end(), player);
+        if (i != players.end())
+            players.erase(i);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogin(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (player == bot || player->GetPlayerbotAI())
+            continue;
+
+        Group* group = bot->GetGroup();
+        if (!group)
+            continue;
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member == player && (!ai->GetMaster() || ai->GetMaster()->GetPlayerbotAI()))
+            {
+                ai->SetMaster(player);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+
+    if (player->GetPlayerbotAI())
+        return;
+
+    players.push_back(player);
+}
+
+Player* RandomPlayerbotMgr::GetRandomPlayer()
+{
+    if (players.empty())
+        return NULL;
+
+    uint32 index = urand(0, players.size() - 1);
+    return players[index];
+}
+
+void RandomPlayerbotMgr::PrintStats()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d Random Bots online", playerBots.size());
+
+    map<uint32, int> alliance, horde;
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        alliance[i] = 0;
+        horde[i] = 0;
+    }
+
+    map<uint8, int> perRace, perClass;
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        perRace[race] = 0;
+    }
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        perClass[cls] = 0;
+    }
+
+    int dps = 0, heal = 0, tank = 0;
+    for (PlayerBotMap::iterator i = playerBots.begin(); i != playerBots.end(); ++i)
+    {
+        Player* bot = i->second;
+        if (IsAlliance(bot->getRace()))
+            alliance[bot->getLevel() / 10]++;
+        else
+            horde[bot->getLevel() / 10]++;
+
+        perRace[bot->getRace()]++;
+        perClass[bot->getClass()]++;
+
+        int spec = AiFactory::GetPlayerSpecTab(bot);
+        switch (bot->getClass())
+        {
+        case CLASS_DRUID:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PALADIN:
+            if (spec == 1)
+                tank++;
+            else if (spec == 0)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PRIEST:
+            if (spec != 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_SHAMAN:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_WARRIOR:
+            if (spec == 2)
+                tank++;
+            else
+                dps++;
+            break;
+        default:
+            dps++;
+            break;
+        }
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per level:");
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        if (!alliance[i] && !horde[i])
+            continue;
+
+        uint32 from = i*10;
+        uint32 to = min(from + 9, maxLevel);
+        if (!from) from = 1;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %d..%d: %d alliance, %d horde", from, to, alliance[i], horde[i]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per race:");
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        if (perRace[race])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatRace(race).c_str(), perRace[race]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per class:");
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        if (perClass[cls])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatClass(cls).c_str(), perClass[cls]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per role:");
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    tank: %d", tank);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    heal: %d", heal);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    dps: %d", dps);
+}
+
+double RandomPlayerbotMgr::GetBuyMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "buymultiplier");
+    if (!value)
+    {
+        value = urand(1, 120);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "buymultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+double RandomPlayerbotMgr::GetSellMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "sellmultiplier");
+    if (!value)
+    {
+        value = urand(80, 250);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "sellmultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+uint32 RandomPlayerbotMgr::GetLootAmount(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    return GetEventValue(id, "lootamount");
+}
+
+void RandomPlayerbotMgr::SetLootAmount(Player* bot, uint32 value)
+{
+    uint32 id = bot->GetGUID();
+    SetEventValue(id, "lootamount", value, 24 * 3600);
+}
+
+uint32 RandomPlayerbotMgr::GetTradeDiscount(Player* bot)
+{
+    Group* group = bot->GetGroup();
+    return GetLootAmount(bot) / (group ? group->GetMembersCount() : 10);
+}
+
+string RandomPlayerbotMgr::HandleRemoteCommand(string request)
+{
+    string::iterator pos = find(request.begin(), request.end(), ',');
+    if (pos == request.end())
+    {
+        ostringstream out; out << "invalid request: " << request;
+        return out.str();
+    }
+
+    string command = string(request.begin(), pos);
+    uint64 guid = atoi(string(pos + 1, request.end()).c_str());
+    Player* bot = GetPlayerBot(guid);
+    if (!bot)
+        return "invalid guid";
+
+    PlayerbotAI *ai = bot->GetPlayerbotAI();
+    if (!ai)
+        return "invalid guid";
+
+    return ai->HandleRemoteCommand(command);
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.h b/src/plugins/playerbot/RandomPlayerbotMgr.h
new file mode 100644
index 0000000..ee5cf24
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.h
@@ -0,0 +1,73 @@
+#ifndef _RandomPlayerbotMgr_H
+#define _RandomPlayerbotMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotMgr : public PlayerbotHolder
+{
+    public:
+        RandomPlayerbotMgr();
+        virtual ~RandomPlayerbotMgr();
+        static RandomPlayerbotMgr& instance()
+        {
+            static RandomPlayerbotMgr instance;
+            return instance;
+        }
+
+        virtual void UpdateAIInternal(uint32 elapsed);
+
+	public:
+        static bool HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsRandomBot(Player* bot);
+        bool IsRandomBot(uint32 bot);
+        void Randomize(Player* bot);
+        void RandomizeFirst(Player* bot);
+        void IncreaseLevel(Player* bot);
+        void ScheduleTeleport(uint32 bot);
+        void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+        string HandleRemoteCommand(string request);
+        void OnPlayerLogout(Player* player);
+        void OnPlayerLogin(Player* player);
+        Player* GetRandomPlayer();
+        void PrintStats();
+        double GetBuyMultiplier(Player* bot);
+        double GetSellMultiplier(Player* bot);
+        uint32 GetLootAmount(Player* bot);
+        void SetLootAmount(Player* bot, uint32 value);
+        uint32 GetTradeDiscount(Player* bot);
+        void Refresh(Player* bot);
+        void RandomTeleportForLevel(Player* bot);
+
+	protected:
+	    virtual void OnBotLoginInternal(Player * const bot) {}
+
+    private:
+        uint32 GetEventValue(uint32 bot, string event);
+        uint32 SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn);
+        list<uint32> GetBots();
+        vector<uint32> GetFreeBots(bool alliance);
+        uint32 AddRandomBot(bool alliance);
+        bool ProcessBot(uint32 bot);
+        void ScheduleRandomize(uint32 bot, uint32 time);
+        void RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ);
+        void RandomTeleport(Player* bot, vector<WorldLocation> &locs);
+        uint32 GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ);
+
+    private:
+        vector<Player*> players;
+        int processTicks;
+};
+
+#define sRandomPlayerbotMgr RandomPlayerbotMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/aiplayerbot.conf.dist.in b/src/plugins/playerbot/aiplayerbot.conf.dist.in
new file mode 100644
index 0000000..b66f8ba
--- /dev/null
+++ b/src/plugins/playerbot/aiplayerbot.conf.dist.in
@@ -0,0 +1,183 @@
+##########################################
+# MANGOS Ai Playerbot Configuration file #
+##########################################
+
+[AiPlayerbotConf]
+ConfVersion=2010102201
+
+# Enable or disable AI Playerbot
+AiPlayerbot.Enabled = 1
+
+# Warrior
+AiPlayerbot.RandomClassSpecProbability.1.0 = 20
+AiPlayerbot.RandomClassSpecProbability.1.1 = 30
+AiPlayerbot.RandomClassSpecProbability.1.2 = 50
+# Paladin
+AiPlayerbot.RandomClassSpecProbability.2.0 = 20
+AiPlayerbot.RandomClassSpecProbability.2.1 = 50
+AiPlayerbot.RandomClassSpecProbability.2.2 = 30
+# Hunter
+AiPlayerbot.RandomClassSpecProbability.3.0 = 25
+AiPlayerbot.RandomClassSpecProbability.3.1 = 50
+AiPlayerbot.RandomClassSpecProbability.3.2 = 25
+# Rogue
+AiPlayerbot.RandomClassSpecProbability.4.0 = 40
+AiPlayerbot.RandomClassSpecProbability.4.1 = 50
+AiPlayerbot.RandomClassSpecProbability.4.2 = 10
+# Priest
+AiPlayerbot.RandomClassSpecProbability.5.0 = 40
+AiPlayerbot.RandomClassSpecProbability.5.1 = 40
+AiPlayerbot.RandomClassSpecProbability.5.2 = 20
+# Shaman
+AiPlayerbot.RandomClassSpecProbability.7.0 = 10
+AiPlayerbot.RandomClassSpecProbability.7.1 = 45
+AiPlayerbot.RandomClassSpecProbability.7.2 = 45
+# Mage
+AiPlayerbot.RandomClassSpecProbability.8.0 = 20
+AiPlayerbot.RandomClassSpecProbability.8.1 = 10
+AiPlayerbot.RandomClassSpecProbability.8.2 = 70
+# Warlock
+AiPlayerbot.RandomClassSpecProbability.9.0 = 33
+AiPlayerbot.RandomClassSpecProbability.9.1 = 33
+AiPlayerbot.RandomClassSpecProbability.9.2 = 33
+# Druid
+AiPlayerbot.RandomClassSpecProbability.11.0 = 10
+AiPlayerbot.RandomClassSpecProbability.11.1 = 45
+AiPlayerbot.RandomClassSpecProbability.11.2 = 45
+
+#
+# All other parameters are optional but can be changed by uncommenting them here
+#
+
+# Prefix for bot chat commands (e.g. follow, stay)
+AiPlayerbot.CommandPrefix =
+
+# Max AI iterations per tick
+#AiPlayerbot.IterationsPerTick = 10
+
+# Allow/deny bots from your guild
+#AiPlayerbot.AllowGuildBots = 1
+
+# Delay between two short-time spells cast
+#AiPlayerbot.GlobalCooldown = 500
+
+# Max wait time when moving
+#AiPlayerbot.MaxWaitForMove = 5000
+
+# Delay between two bot actions
+#AiPlayerbot.ReactDelay = 100
+
+# Distances
+#AiPlayerbot.SightDistance = 75.0
+#AiPlayerbot.SpellDistance = 30.0
+#AiPlayerbot.ReactDistance = 150.0
+#AiPlayerbot.GrindDistance = 100.0
+#AiPlayerbot.LootDistance = 20.0
+#AiPlayerbot.FleeDistance = 20.0
+#AiPlayerbot.TooCloseDistance = 7.0
+#AiPlayerbot.MeleeDistance = 1.0
+#AiPlayerbot.FollowDistance = 1.5
+#AiPlayerbot.WhisperDistance = 6000.0
+#AiPlayerbot.ContactDistance = 0.5
+
+# Bot can flee for enemy
+#AiPlayerbot.FleeingEnabled = 1
+
+# Health/Mana levels
+#AiPlayerbot.CriticalHealth = 25
+#AiPlayerbot.LowHealth = 45
+#AiPlayerbot.MediumHealth = 65
+#AiPlayerbot.AlmostFullHealth = 85
+#AiPlayerbot.LowMana = 15
+#AiPlayerbot.MediumMana = 40
+
+# Enable random bot system
+AiPlayerbot.RandomBotAutologin = 1
+
+# Random bot default strategies (applied after defaults)
+#AiPlayerbot.RandomBotCombatStrategies = +dps,+attack weak
+#AiPlayerbot.RandomBotNonCombatStrategies = +grind,+move random,+loot
+
+# Create random bot characters automatically
+AiPlayerbot.RandomBotAutoCreate = 1
+
+# Random bot count
+AiPlayerbot.MinRandomBots = 20
+AiPlayerbot.MaxRandomBots = 40
+#AiPlayerbot.RandomBotMinLevel = 1
+#AiPlayerbot.RandomBotMaxLevel = 255 (ignored if more than MaxPlayerLevel mangosd.conf value)
+
+# Accounts to create for random bots
+#AiPlayerbot.RandomBotAccountPrefix = rndbot
+#AiPlayerbot.RandomBotAccountCount = 50
+
+# Delete all random bot accounts
+#AiPlayerbot.DeleteRandomBotAccounts = 0
+
+# Random bot guild count
+#AiPlayerbot.RandomBotGuildCount = 50
+
+# Guild Task system
+AiPlayerbot.EnableGuildTasks = 0
+
+# How often tasks are changed
+#AiPlayerbot.MinGuildTaskChangeTime = 172800
+#AiPlayerbot.MaxGuildTaskChangeTime = 432000
+# Mail spam interval
+#AiPlayerbot.MinGuildTaskAdvertisementTime = 300
+#AiPlayerbot.MaxGuildTaskAdvertisementTime = 28800
+# Delay before reward is sent
+#AiPlayerbot.MinGuildTaskRewardTime = 300
+#AiPlayerbot.MaxGuildTaskRewardTime = 3600
+
+# Delete all random bot guilds
+#AiPlayerbot.DeleteRandomBotGuilds = 0
+
+# Maps to teleport random bots
+#AiPlayerbot.RandomBotMaps = 0,1,530,571
+
+# Change random bot has lower gear
+#AiPlayerbot.RandomGearLoweringChance = 0.15
+
+# Chance random bot has max level on first randomize
+#AiPlayerbot.RandomBotMaxLevelChance = 0.4
+
+# Quest items to leave (do not destroy)
+#AiPlayerbot.RandomBotQuestItems = 6948,5175,5176,5177,5178
+
+# Spells every random bot will learn on randomize (54197 - cold weather flying)
+#AiPlayerbot.RandomBotSpellIds = 54197
+
+# Enable LFG for random bots
+#AiPlayerbot.RandomBotJoinLfg = 1
+
+# Level diff between random bots and nearby creatures for random teleports
+AiPlayerbot.RandomBotTeleLevel = 3
+
+# Intervals
+#AiPlayerbot.RandomBotUpdateInterval = 60
+#AiPlayerbot.RandomBotCountChangeMinInterval = 86400
+#AiPlayerbot.RandomBotCountChangeMaxInterval = 259200
+#AiPlayerbot.MinRandomBotInWorldTime = 7200
+#AiPlayerbot.MaxRandomBotInWorldTime = 1209600
+#AiPlayerbot.MinRandomBotRandomizeTime = 7200
+#AiPlayerbot.MaxRandomRandomizeTime = 1209600
+#AiPlayerbot.MinRandomBotsPerInterval = 50
+#AiPlayerbot.MaxRandomBotsPerInterval = 100
+#AiPlayerbot.MinRandomBotsPriceChangeInterval = 7200
+#AiPlayerbot.MaxRandomBotsPriceChangeInterval = 172800
+
+# Log on all random bots on start
+#AiPlayerbot.RandomBotLoginAtStartup = 1
+
+# How far random bots are teleported after death
+#AiPlayerbot.RandomBotTeleportDistance = 1000
+
+# Debug switches
+#AiPlayerbot.SpellDump = 0
+#AiPlayerbot.LogInGroupOnly = 1
+#AiPlayerbot.LogValuesPerTick = 0
+#AiPlayerbot.RandomChangeMultiplier = 1
+
+# Command server port, 0 - disabled
+#AiPlayerbot.CommandServerPort = 8888
diff --git a/src/plugins/playerbot/playerbot.h b/src/plugins/playerbot/playerbot.h
new file mode 100644
index 0000000..b53d50c
--- /dev/null
+++ b/src/plugins/playerbot/playerbot.h
@@ -0,0 +1,31 @@
+#pragma once
+
+std::vector<std::string> split(const std::string &s, char delim);
+#ifndef WIN32
+int strcmpi(std::string s1, std::string s2);
+#endif
+
+#include "../Spell.h"
+#include "../../shared/Packets/WorldPacket.h"
+#include "../Loot/LootMgr.h"
+#include "../Entities/Creature/GossipDef.h"
+#include "../Chat/Chat.h"
+#include "Common.h"
+#include "../World/World.h"
+#include "../Spells/SpellMgr.h"
+#include "../Globals/ObjectMgr.h"
+#include "../Entities/Unit/Unit.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../Movement/MotionMaster.h"
+#include "../Spells/Auras/SpellAuras.h"
+#include "../Guilds/Guild.h"
+#include "../Groups/Group.h"
+#include "../../game/Accounts/AccountMgr.h"
+#include "../../game/Globals/ObjectMgr.h"
+
+#include "playerbotDefs.h"
+#include "PlayerbotAIAware.h"
+#include "PlayerbotMgr.h"
+#include "RandomPlayerbotMgr.h"
+#include "ChatHelper.h"
+#include "PlayerbotAI.h"
diff --git a/src/plugins/playerbot/playerbotDefs.h b/src/plugins/playerbot/playerbotDefs.h
new file mode 100644
index 0000000..3f59c93
--- /dev/null
+++ b/src/plugins/playerbot/playerbotDefs.h
@@ -0,0 +1,2 @@
+#pragma once
+
diff --git a/src/plugins/playerbot/strategy/Action.cpp b/src/plugins/playerbot/strategy/Action.cpp
new file mode 100644
index 0000000..a8f981e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.cpp
@@ -0,0 +1,93 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "Action.h"
+
+using namespace ai;
+
+int NextAction::size(NextAction** actions)
+{
+    if (!actions)
+        return 0;
+
+    int size;
+    for (size=0; size<10 && actions[size]; )
+        size++;
+    return size;
+}
+
+NextAction** NextAction::clone(NextAction** actions)
+{
+    if (!actions)
+        return NULL;
+
+    int size = NextAction::size(actions);
+
+    NextAction** res = new NextAction*[size + 1];
+    for (int i=0; i<size; i++)
+        res[i] = new NextAction(*actions[i]);
+    res[size] = NULL;
+    return res;
+}
+
+NextAction** NextAction::merge(NextAction** left, NextAction** right)
+{
+    int leftSize = NextAction::size(left);
+    int rightSize = NextAction::size(right);
+
+    NextAction** res = new NextAction*[leftSize + rightSize + 1];
+    for (int i=0; i<leftSize; i++)
+        res[i] = new NextAction(*left[i]);
+    for (int i=0; i<rightSize; i++)
+        res[leftSize + i] = new NextAction(*right[i]);
+    res[leftSize + rightSize] = NULL;
+
+    NextAction::destroy(left);
+    NextAction::destroy(right);
+
+    return res;
+}
+
+NextAction** NextAction::array(uint8 nil, ...)
+{
+    va_list vl;
+    va_start(vl, nil);
+
+    int size = 0;
+    NextAction* cur = NULL;
+    do
+    {
+        cur = va_arg(vl, NextAction*);
+        size++;
+    }
+    while (cur);
+
+    va_end(vl);
+
+    NextAction** res = new NextAction*[size];
+    va_start(vl, nil);
+    for (int i=0; i<size; i++)
+        res[i] = va_arg(vl, NextAction*);
+    va_end(vl);
+
+    return res;
+}
+
+void NextAction::destroy(NextAction** actions)
+{
+    if (!actions)
+        return;
+
+    for (int i=0; i<10 && actions[i]; i++)
+        delete actions[i];
+}
+
+Value<Unit*>* Action::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Action::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Action.h b/src/plugins/playerbot/strategy/Action.h
new file mode 100644
index 0000000..b8d2a1c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.h
@@ -0,0 +1,138 @@
+#pragma once
+#include "Event.h"
+#include "Value.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class NextAction
+    {
+    public:
+        NextAction(string name, float relevance = 0.0f)
+        {
+            this->name = name;
+            this->relevance = relevance;
+        }
+        NextAction(const NextAction& o)
+        {
+            this->name = o.name;
+            this->relevance = o.relevance;
+        }
+
+    public:
+        string getName() { return name; }
+        float getRelevance() {return relevance;}
+
+    public:
+        static int size(NextAction** actions);
+        static NextAction** clone(NextAction** actions);
+        static NextAction** merge(NextAction** what, NextAction** with);
+        static NextAction** array(uint8 nil,...);
+        static void destroy(NextAction** actions);
+
+    private:
+        float relevance;
+        std::string name;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class ActionBasket;
+
+    enum ActionThreatType
+    {
+        ACTION_THREAT_NONE = 0,
+        ACTION_THREAT_SINGLE= 1,
+        ACTION_THREAT_AOE = 2
+    };
+
+    class Action : public AiNamedObject
+	{
+	public:
+        Action(PlayerbotAI* ai, string name = "action") : verbose(false), AiNamedObject(ai, name) { }
+        virtual ~Action(void) {}
+
+    public:
+        virtual bool Execute(Event event) { return true; }
+        virtual bool isPossible() { return true; }
+        virtual bool isUseful() { return true; }
+        virtual NextAction** getPrerequisites() { return NULL; }
+        virtual NextAction** getAlternatives() { return NULL; }
+        virtual NextAction** getContinuers() { return NULL; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+        void Update() {}
+        void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+        void MakeVerbose() { verbose = true; }
+
+    protected:
+        bool verbose;
+	};
+
+    class ActionNode
+    {
+    public:
+        ActionNode(string name, NextAction** prerequisites = NULL, NextAction** alternatives = NULL, NextAction** continuers = NULL)
+        {
+            this->action = NULL;
+            this->name = name;
+            this->prerequisites = prerequisites;
+            this->alternatives = alternatives;
+            this->continuers = continuers;
+        }
+        virtual ~ActionNode()
+        {
+            NextAction::destroy(prerequisites);
+            NextAction::destroy(alternatives);
+            NextAction::destroy(continuers);
+        }
+
+    public:
+        Action* getAction() { return action; }
+        void setAction(Action* action) { this->action = action; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getContinuers() { return NextAction::merge(NextAction::clone(continuers), action->getContinuers()); }
+        NextAction** getAlternatives() { return NextAction::merge(NextAction::clone(alternatives), action->getAlternatives()); }
+        NextAction** getPrerequisites() { return NextAction::merge(NextAction::clone(prerequisites), action->getPrerequisites()); }
+
+    private:
+        string name;
+        Action* action;
+        NextAction** continuers;
+        NextAction** alternatives;
+        NextAction** prerequisites;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+	class ActionBasket
+	{
+	public:
+        ActionBasket(ActionNode* action, float relevance, bool skipPrerequisites, Event event) :
+          action(action), relevance(relevance), skipPrerequisites(skipPrerequisites), event(event) {}
+        virtual ~ActionBasket(void) {}
+	public:
+		float getRelevance() {return relevance;}
+		ActionNode* getAction() {return action;}
+        Event getEvent() { return event; }
+        bool isSkipPrerequisites() { return skipPrerequisites; }
+        void AmendRelevance(float k) {relevance *= k; }
+        void setRelevance(float relevance) { this->relevance = relevance; }
+	private:
+		ActionNode* action;
+		float relevance;
+        bool skipPrerequisites;
+        Event event;
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+
+}
+
+#define AI_VALUE(type, name) context->GetValue<type>(name)->Get()
+#define AI_VALUE2(type, name, param) context->GetValue<type>(name, param)->Get()
diff --git a/src/plugins/playerbot/strategy/ActionBasket.cpp b/src/plugins/playerbot/strategy/ActionBasket.cpp
new file mode 100644
index 0000000..ef8e4b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.cpp
@@ -0,0 +1,4 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "ActionBasket.h"
+
diff --git a/src/plugins/playerbot/strategy/ActionBasket.h b/src/plugins/playerbot/strategy/ActionBasket.h
new file mode 100644
index 0000000..d85293b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.h
@@ -0,0 +1,5 @@
+#pragma once
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/AiObject.cpp b/src/plugins/playerbot/strategy/AiObject.cpp
new file mode 100644
index 0000000..3b807e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.cpp
@@ -0,0 +1,16 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObject.h"
+
+AiObject::AiObject(PlayerbotAI* ai) :
+    PlayerbotAIAware(ai),
+    bot(ai->GetBot()),
+    context(ai->GetAiObjectContext()),
+    chat(ai->GetChatHelper())
+{
+}
+
+Player* AiObject::GetMaster()
+{
+    return ai->GetMaster();
+}
diff --git a/src/plugins/playerbot/strategy/AiObject.h b/src/plugins/playerbot/strategy/AiObject.h
new file mode 100644
index 0000000..0b4f214
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.h
@@ -0,0 +1,33 @@
+#pragma once
+
+class PlayerbotAI;
+
+namespace ai
+{
+    class AiObjectContext;
+    class ChatHelper;
+
+    class AiObject : public PlayerbotAIAware
+	{
+	public:
+        AiObject(PlayerbotAI* ai);
+
+    protected:
+        Player* bot;
+        Player* GetMaster();
+        AiObjectContext* context;
+        ChatHelper* chat;
+	};
+
+    class AiNamedObject : public AiObject
+    {
+    public:
+        AiNamedObject(PlayerbotAI* ai, string name) : AiObject(ai), name(name) {}
+
+    public:
+        virtual string getName() { return name; }
+
+    protected:
+        string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.cpp b/src/plugins/playerbot/strategy/AiObjectContext.cpp
new file mode 100644
index 0000000..3c75542
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.cpp
@@ -0,0 +1,48 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "NamedObjectContext.h"
+#include "StrategyContext.h"
+#include "triggers/TriggerContext.h"
+#include "actions/ActionContext.h"
+#include "triggers/ChatTriggerContext.h"
+#include "actions/ChatActionContext.h"
+#include "triggers/WorldPacketTriggerContext.h"
+#include "actions/WorldPacketActionContext.h"
+#include "values/ValueContext.h"
+
+using namespace ai;
+
+AiObjectContext::AiObjectContext(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    strategyContexts.Add(new StrategyContext());
+    strategyContexts.Add(new MovementStrategyContext());
+    strategyContexts.Add(new AssistStrategyContext());
+    strategyContexts.Add(new QuestStrategyContext());
+
+    actionContexts.Add(new ActionContext());
+    actionContexts.Add(new ChatActionContext());
+    actionContexts.Add(new WorldPacketActionContext());
+
+    triggerContexts.Add(new TriggerContext());
+    triggerContexts.Add(new ChatTriggerContext());
+    triggerContexts.Add(new WorldPacketTriggerContext());
+
+    valueContexts.Add(new ValueContext());
+}
+
+void AiObjectContext::Update()
+{
+    strategyContexts.Update();
+    triggerContexts.Update();
+    actionContexts.Update();
+    valueContexts.Update();
+}
+
+void AiObjectContext::Reset()
+{
+    strategyContexts.Reset();
+    triggerContexts.Reset();
+    actionContexts.Reset();
+    valueContexts.Reset();
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.h b/src/plugins/playerbot/strategy/AiObjectContext.h
new file mode 100644
index 0000000..f9313bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include "../PlayerbotAIAware.h"
+#include "Action.h"
+#include "Value.h"
+#include "NamedObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class AiObjectContext : public PlayerbotAIAware
+    {
+    public:
+        AiObjectContext(PlayerbotAI* ai);
+        virtual ~AiObjectContext() {}
+
+    public:
+        virtual Strategy* GetStrategy(string name) { return strategyContexts.GetObject(name, ai); }
+        virtual set<string> GetSiblingStrategy(string name) { return strategyContexts.GetSiblings(name); }
+        virtual Trigger* GetTrigger(string name) { return triggerContexts.GetObject(name, ai); }
+        virtual Action* GetAction(string name) { return actionContexts.GetObject(name, ai); }
+        virtual UntypedValue* GetUntypedValue(string name) { return valueContexts.GetObject(name, ai); }
+
+        template<class T>
+        Value<T>* GetValue(string name)
+        {
+            return dynamic_cast<Value<T>*>(GetUntypedValue(name));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, string param)
+        {
+            return GetValue<T>((string(name) + "::" + param));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, uint32 param)
+        {
+        	ostringstream out; out << param;
+            return GetValue<T>(name, out.str());
+        }
+
+        set<string> GetSupportedStrategies()
+        {
+            return strategyContexts.supports();
+        }
+
+        string FormatValues()
+        {
+            ostringstream out;
+            set<string> names = valueContexts.GetCreated();
+            for (set<string>::iterator i = names.begin(); i != names.end(); ++i)
+            {
+                UntypedValue* value = GetUntypedValue(*i);
+                if (!value)
+                    continue;
+
+                string text = value->Format();
+                if (text == "?")
+                    continue;
+
+                out << "{" << *i << "=" << text << "} ";
+            }
+            return out.str();
+        }
+
+    public:
+        virtual void Update();
+        virtual void Reset();
+        virtual void AddShared(NamedObjectContext<UntypedValue>* sharedValues)
+        {
+            valueContexts.Add(sharedValues);
+        }
+
+    protected:
+        NamedObjectContextList<Strategy> strategyContexts;
+        NamedObjectContextList<Action> actionContexts;
+        NamedObjectContextList<Trigger> triggerContexts;
+        NamedObjectContextList<UntypedValue> valueContexts;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Engine.cpp b/src/plugins/playerbot/strategy/Engine.cpp
new file mode 100644
index 0000000..58ab72d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.cpp
@@ -0,0 +1,536 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+
+#include "Engine.h"
+#include "../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Engine::Engine(PlayerbotAI* ai, AiObjectContext *factory) : PlayerbotAIAware(ai), aiObjectContext(factory)
+{
+    lastRelevance = 0.0f;
+    testMode = false;
+}
+
+bool ActionExecutionListeners::Before(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->Before(action, event);
+    }
+    return result;
+}
+
+void ActionExecutionListeners::After(Action* action, bool executed, Event event)
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        (*i)->After(action, executed, event);
+    }
+}
+
+bool ActionExecutionListeners::OverrideResult(Action* action, bool executed, Event event)
+{
+    bool result = executed;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result = (*i)->OverrideResult(action, result, event);
+    }
+    return result;
+}
+
+bool ActionExecutionListeners::AllowExecution(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->AllowExecution(action, event);
+    }
+    return result;
+}
+
+ActionExecutionListeners::~ActionExecutionListeners()
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        delete *i;
+    }
+    listeners.clear();
+}
+
+
+Engine::~Engine(void)
+{
+    Reset();
+
+    strategies.clear();
+}
+
+void Engine::Reset()
+{
+    ActionNode* action = NULL;
+    do
+    {
+        action = queue.Pop();
+        delete action;
+    } while (action);
+
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* trigger = *i;
+        delete trigger;
+    }
+    triggers.clear();
+
+    for (list<Multiplier*>::iterator i = multipliers.begin(); i != multipliers.end(); i++)
+    {
+        Multiplier* multiplier = *i;
+        delete multiplier;
+    }
+    multipliers.clear();
+}
+
+void Engine::Init()
+{
+    Reset();
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        strategy->InitMultipliers(multipliers);
+        strategy->InitTriggers(triggers);
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+
+	if (testMode)
+	{
+        FILE* file = fopen("test.log", "w");
+        fprintf(file, "\n");
+        fclose(file);
+	}
+}
+
+
+bool Engine::DoNextAction(Unit* unit, int depth)
+{
+    LogAction("--- AI Tick ---");
+    if (sPlayerbotAIConfig.logValuesPerTick)
+        LogValues();
+
+    bool actionExecuted = false;
+    ActionBasket* basket = NULL;
+
+    time_t currentTime = time(0);
+    aiObjectContext->Update();
+    ProcessTriggers();
+
+    int iterations = 0;
+    int iterationsPerTick = queue.Size() * sPlayerbotAIConfig.iterationsPerTick;
+    do {
+        basket = queue.Peek();
+        if (basket) {
+            if (++iterations > iterationsPerTick)
+                break;
+
+            float relevance = basket->getRelevance(); // just for reference
+            bool skipPrerequisites = basket->isSkipPrerequisites();
+            Event event = basket->getEvent();
+            // NOTE: queue.Pop() deletes basket
+            ActionNode* actionNode = queue.Pop();
+            Action* action = InitializeAction(actionNode);
+
+            if (!action)
+            {
+                LogAction("A:%s - UNKNOWN", actionNode->getName().c_str());
+            }
+            else if (action->isUseful())
+            {
+                for (list<Multiplier*>::iterator i = multipliers.begin(); i!= multipliers.end(); i++)
+                {
+                    Multiplier* multiplier = *i;
+                    relevance *= multiplier->GetValue(action);
+                    if (!relevance)
+                    {
+                        LogAction("Multiplier %s made action %s useless", multiplier->getName().c_str(), action->getName().c_str());
+                        break;
+                    }
+                }
+
+                if (action->isPossible() && relevance)
+                {
+                    if ((!skipPrerequisites || lastRelevance-relevance > 0.04) &&
+                            MultiplyAndPush(actionNode->getPrerequisites(), relevance + 0.02, false, event))
+                    {
+                        PushAgain(actionNode, relevance + 0.01, event);
+                        continue;
+                    }
+
+                    actionExecuted = ListenAndExecute(action, event);
+
+                    if (actionExecuted)
+                    {
+                        LogAction("A:%s - OK", action->getName().c_str());
+                        MultiplyAndPush(actionNode->getContinuers(), 0, false, event);
+                        lastRelevance = relevance;
+                        delete actionNode;
+                        break;
+                    }
+                    else
+                    {
+                        MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                        LogAction("A:%s - FAILED", action->getName().c_str());
+                    }
+                }
+                else
+                {
+                    MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                    LogAction("A:%s - IMPOSSIBLE", action->getName().c_str());
+                }
+            }
+            else
+            {
+                lastRelevance = relevance;
+                LogAction("A:%s - USELESS", action->getName().c_str());
+            }
+            delete actionNode;
+        }
+    }
+    while (basket);
+
+    if (!basket)
+    {
+        lastRelevance = 0.0f;
+        PushDefaultActions();
+        if (queue.Peek() && depth < 2)
+            return DoNextAction(unit, depth + 1);
+    }
+
+    if (time(0) - currentTime > 1) {
+        LogAction("too long execution");
+    }
+
+    if (!actionExecuted)
+        LogAction("no actions executed");
+
+    return actionExecuted;
+}
+
+ActionNode* Engine::CreateActionNode(string name)
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        ActionNode* node = strategy->GetAction(name);
+        if (node)
+            return node;
+    }
+    return new ActionNode (name,
+        /*P*/ NULL,
+        /*A*/ NULL,
+        /*C*/ NULL);
+}
+
+bool Engine::MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event)
+{
+    bool pushed = false;
+    if (actions)
+    {
+        for (int j=0; j<10; j++) // TODO: remove 10
+        {
+            NextAction* nextAction = actions[j];
+            if (nextAction)
+            {
+                ActionNode* action = CreateActionNode(nextAction->getName());
+                InitializeAction(action);
+
+                float k = nextAction->getRelevance();
+                if (forceRelevance > 0.0f)
+                {
+                    k = forceRelevance;
+                }
+
+                if (k > 0)
+                {
+                    LogAction("PUSH:%s %f", action->getName().c_str(), k);
+                    queue.Push(new ActionBasket(action, k, skipPrerequisites, event));
+                    pushed = true;
+                }
+
+                delete nextAction;
+            }
+            else
+                break;
+        }
+        delete actions;
+    }
+    return pushed;
+}
+
+ActionResult Engine::ExecuteAction(string name)
+{
+	bool result = false;
+
+    ActionNode *actionNode = CreateActionNode(name);
+    if (!actionNode)
+        return ACTION_RESULT_UNKNOWN;
+
+    Action* action = InitializeAction(actionNode);
+    if (!action)
+        return ACTION_RESULT_UNKNOWN;
+
+    if (!action->isPossible())
+    {
+        delete actionNode;
+        return ACTION_RESULT_IMPOSSIBLE;
+    }
+
+    if (!action->isUseful())
+    {
+        delete actionNode;
+        return ACTION_RESULT_USELESS;
+    }
+
+    action->MakeVerbose();
+    Event emptyEvent;
+    result = ListenAndExecute(action, emptyEvent);
+    MultiplyAndPush(action->getContinuers(), 0.0f, false, emptyEvent);
+    delete actionNode;
+	return result ? ACTION_RESULT_OK : ACTION_RESULT_FAILED;
+}
+
+void Engine::addStrategy(string name)
+{
+    removeStrategy(name);
+
+    Strategy* strategy = aiObjectContext->GetStrategy(name);
+    if (strategy)
+    {
+        set<string> siblings = aiObjectContext->GetSiblingStrategy(name);
+        for (set<string>::iterator i = siblings.begin(); i != siblings.end(); i++)
+            removeStrategy(*i);
+
+        LogAction("S:+%s", strategy->getName().c_str());
+        strategies[strategy->getName()] = strategy;
+    }
+    Init();
+}
+
+void Engine::addStrategies(string first, ...)
+{
+	addStrategy(first);
+
+	va_list vl;
+	va_start(vl, first);
+
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			addStrategy(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+bool Engine::removeStrategy(string name)
+{
+    map<string, Strategy*>::iterator i = strategies.find(name);
+    if (i == strategies.end())
+        return false;
+
+    LogAction("S:-%s", name.c_str());
+    strategies.erase(i);
+    Init();
+    return true;
+}
+
+void Engine::removeAllStrategies()
+{
+    strategies.clear();
+    Init();
+}
+
+void Engine::toggleStrategy(string name)
+{
+    if (!removeStrategy(name))
+        addStrategy(name);
+}
+
+bool Engine::HasStrategy(string name)
+{
+    return strategies.find(name) != strategies.end();
+}
+
+void Engine::ProcessTriggers()
+{
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* node = *i;
+        if (!node)
+            continue;
+
+        Trigger* trigger = node->getTrigger();
+        if (!trigger)
+        {
+            trigger = aiObjectContext->GetTrigger(node->getName());
+            node->setTrigger(trigger);
+        }
+
+        if (!trigger)
+            continue;
+
+        if (testMode || trigger->needCheck())
+        {
+            Event event = trigger->Check();
+            if (!event)
+                continue;
+
+            LogAction("T:%s", trigger->getName().c_str());
+            MultiplyAndPush(node->getHandlers(), 0.0f, false, event);
+        }
+    }
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        Trigger* trigger = (*i)->getTrigger();
+        if (trigger) trigger->Reset();
+    }
+}
+
+void Engine::PushDefaultActions()
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+}
+
+string Engine::ListStrategies()
+{
+    string s = "Strategies: ";
+
+    if (strategies.empty())
+        return s;
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        s.append(i->first);
+        s.append(", ");
+    }
+    return s.substr(0, s.length() - 2);
+}
+
+void Engine::PushAgain(ActionNode* actionNode, float relevance, Event event)
+{
+    NextAction** nextAction = new NextAction*[2];
+    nextAction[0] = new NextAction(actionNode->getName(), relevance);
+    nextAction[1] = NULL;
+    MultiplyAndPush(nextAction, relevance, true, event);
+    delete actionNode;
+}
+
+bool Engine::ContainsStrategy(StrategyType type)
+{
+	for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+	{
+		Strategy* strategy = i->second;
+		if (strategy->GetType() & type)
+			return true;
+	}
+	return false;
+}
+
+Action* Engine::InitializeAction(ActionNode* actionNode)
+{
+    Action* action = actionNode->getAction();
+    if (!action)
+    {
+        action = aiObjectContext->GetAction(actionNode->getName());
+        actionNode->setAction(action);
+    }
+    return action;
+}
+
+bool Engine::ListenAndExecute(Action* action, Event event)
+{
+    bool actionExecuted = false;
+
+    if (actionExecutionListeners.Before(action, event))
+    {
+        actionExecuted = actionExecutionListeners.AllowExecution(action, event) ? action->Execute(event) : true;
+    }
+
+    actionExecuted = actionExecutionListeners.OverrideResult(action, actionExecuted, event);
+    actionExecutionListeners.After(action, actionExecuted, event);
+    return actionExecuted;
+}
+
+void Engine::LogAction(const char* format, ...)
+{
+    char buf[1024];
+
+    va_list ap;
+    va_start(ap, format);
+    vsprintf(buf, format, ap);
+    va_end(ap);
+    lastAction = buf;
+
+    if (testMode)
+    {
+        FILE* file = fopen("test.log", "a");
+        fprintf(file, buf);
+        fprintf(file, "\n");
+        fclose(file);
+    }
+    else
+    {
+        Player* bot = ai->GetBot();
+        if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+            return;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "%s %s", bot->GetName().c_str(), buf);
+    }
+}
+
+void Engine::ChangeStrategy(string names)
+{
+    vector<string> splitted = split(names, ',');
+    for (vector<string>::iterator i = splitted.begin(); i != splitted.end(); i++)
+    {
+        const char* name = i->c_str();
+        switch (name[0])
+        {
+        case '+':
+            addStrategy(name+1);
+            break;
+        case '-':
+            removeStrategy(name+1);
+            break;
+        case '~':
+            toggleStrategy(name+1);
+            break;
+        case '?':
+            ai->TellMaster(ListStrategies());
+            break;
+        }
+    }
+}
+
+void Engine::LogValues()
+{
+    if (testMode)
+        return;
+
+    Player* bot = ai->GetBot();
+    if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+        return;
+
+    string text = ai->GetAiObjectContext()->FormatValues();
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Values for %s: %s", bot->GetName().c_str(), text.c_str());
+}
diff --git a/src/plugins/playerbot/strategy/Engine.h b/src/plugins/playerbot/strategy/Engine.h
new file mode 100644
index 0000000..a395a1b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.h
@@ -0,0 +1,123 @@
+#pragma once
+
+#include "Action.h"
+#include "Queue.h"
+#include "Trigger.h"
+#include "Multiplier.h"
+#include "AiObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class ActionExecutionListener
+    {
+    public:
+        virtual bool Before(Action* action, Event event) = 0;
+        virtual bool AllowExecution(Action* action, Event event) = 0;
+        virtual void After(Action* action, bool executed, Event event) = 0;
+        virtual bool OverrideResult(Action* action, bool executed, Event event) = 0;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    class ActionExecutionListeners : public ActionExecutionListener
+    {
+    public:
+        virtual ~ActionExecutionListeners();
+
+    // ActionExecutionListener
+    public:
+        virtual bool Before(Action* action, Event event);
+        virtual bool AllowExecution(Action* action, Event event);
+        virtual void After(Action* action, bool executed, Event event);
+        virtual bool OverrideResult(Action* action, bool executed, Event event);
+
+    public:
+        void Add(ActionExecutionListener* listener)
+        {
+            listeners.push_back(listener);
+        }
+        void Remove(ActionExecutionListener* listener)
+        {
+            listeners.remove(listener);
+        }
+
+    private:
+        std::list<ActionExecutionListener*> listeners;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    enum ActionResult
+    {
+        ACTION_RESULT_UNKNOWN,
+        ACTION_RESULT_OK,
+        ACTION_RESULT_IMPOSSIBLE,
+        ACTION_RESULT_USELESS,
+        ACTION_RESULT_FAILED
+    };
+
+    class Engine : public PlayerbotAIAware
+    {
+    public:
+        Engine(PlayerbotAI* ai, AiObjectContext *factory);
+
+	    void Init();
+        void addStrategy(string name);
+		void addStrategies(string first, ...);
+        bool removeStrategy(string name);
+        bool HasStrategy(string name);
+        void removeAllStrategies();
+        void toggleStrategy(string name);
+        std::string ListStrategies();
+		bool ContainsStrategy(StrategyType type);
+		void ChangeStrategy(string names);
+		string GetLastAction() { return lastAction; }
+
+    public:
+	    virtual bool DoNextAction(Unit*, int depth = 0);
+	    ActionResult ExecuteAction(string name);
+
+    public:
+        void AddActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Add(listener);
+        }
+        void removeActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Remove(listener);
+        }
+
+    public:
+	    virtual ~Engine(void);
+
+    private:
+        bool MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event);
+        void Reset();
+        void ProcessTriggers();
+        void PushDefaultActions();
+        void PushAgain(ActionNode* actionNode, float relevance, Event event);
+        ActionNode* CreateActionNode(string name);
+        Action* InitializeAction(ActionNode* actionNode);
+        bool ListenAndExecute(Action* action, Event event);
+
+    private:
+        void LogAction(const char* format, ...);
+        void LogValues();
+
+    protected:
+	    Queue queue;
+	    std::list<TriggerNode*> triggers;
+        std::list<Multiplier*> multipliers;
+        AiObjectContext* aiObjectContext;
+        std::map<string, Strategy*> strategies;
+        float lastRelevance;
+        std::string lastAction;
+
+    public:
+		bool testMode;
+
+    private:
+        ActionExecutionListeners actionExecutionListeners;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Event.cpp b/src/plugins/playerbot/strategy/Event.cpp
new file mode 100644
index 0000000..4287d16
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.cpp
@@ -0,0 +1,20 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Event.h"
+
+
+using namespace ai;
+
+ObjectGuid Event::getObject()
+{
+    if (packet.empty())
+        return ObjectGuid();
+
+    WorldPacket p(packet);
+    p.rpos(0);
+
+    ObjectGuid guid;
+    p >> guid;
+
+    return guid;
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Event.h b/src/plugins/playerbot/strategy/Event.h
new file mode 100644
index 0000000..86ea279
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.h
@@ -0,0 +1,36 @@
+#pragma once
+
+namespace ai
+{
+    class Event
+	{
+	public:
+        Event(Event const& other)
+        {
+            source = other.source;
+            param = other.param;
+            packet = other.packet;
+            owner = other.owner;
+        }
+        Event() {}
+        Event(string source) : source(source) {}
+        Event(string source, string param, Player* owner = NULL) : source(source), param(param), owner(owner) {}
+        Event(string source, WorldPacket &packet, Player* owner = NULL) : source(source), packet(packet), owner(owner) {}
+        virtual ~Event() {}
+
+	public:
+        string getSource() { return source; }
+        string getParam() { return param; }
+        WorldPacket& getPacket() { return packet; }
+        ObjectGuid getObject();
+        Player* getOwner() { return owner; }
+        bool operator! () const { return source.empty(); }
+
+    protected:
+        string source;
+        string param;
+        WorldPacket packet;
+        ObjectGuid object;
+        Player* owner;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/ExternalEventHelper.h b/src/plugins/playerbot/strategy/ExternalEventHelper.h
new file mode 100644
index 0000000..a25154e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ExternalEventHelper.h
@@ -0,0 +1,69 @@
+#pragma once
+
+#include "Trigger.h"
+
+namespace ai
+{
+    class ExternalEventHelper {
+    public:
+        ExternalEventHelper(AiObjectContext* aiObjectContext) : aiObjectContext(aiObjectContext) {}
+
+        bool ParseChatCommand(string command, Player* owner = NULL)
+        {
+            if (HandleCommand(command, "", owner))
+                return true;
+
+            size_t i = string::npos;
+            while (true)
+            {
+                size_t found = command.rfind(" ", i);
+                if (found == string::npos || !found)
+                    break;
+
+                string name = command.substr(0, found);
+                string param = command.substr(found + 1);
+
+                i = found - 1;
+
+                if (HandleCommand(name, param, owner))
+                    return true;
+            }
+
+            if (!ChatHelper::parseable(command))
+                return false;
+
+            HandleCommand("q", command, owner);
+            HandleCommand("c", command, owner);
+            HandleCommand("t", command, owner);
+            return true;
+        }
+
+        void HandlePacket(map<uint16, string> &handlers, const WorldPacket &packet, Player* owner = NULL)
+        {
+            uint16 opcode = packet.GetOpcode();
+            string name = handlers[opcode];
+            if (name.empty())
+                return;
+
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return;
+
+            WorldPacket p(packet);
+            trigger->ExternalEvent(p, owner);
+        }
+
+        bool HandleCommand(string name, string param, Player* owner = NULL)
+        {
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return false;
+
+            trigger->ExternalEvent(param, owner);
+            return true;
+        }
+
+    private:
+        AiObjectContext* aiObjectContext;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/ItemVisitors.h b/src/plugins/playerbot/strategy/ItemVisitors.h
new file mode 100644
index 0000000..09deb17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ItemVisitors.h
@@ -0,0 +1,258 @@
+#pragma once
+
+char * strstri (const char* str1, const char* str2);
+
+namespace ai
+{
+    class IterateItemsVisitor
+    {
+    public:
+        IterateItemsVisitor() {}
+
+        virtual bool Visit(Item* item) = 0;
+    };
+
+    class FindItemVisitor : public IterateItemsVisitor {
+    public:
+        FindItemVisitor() : IterateItemsVisitor(), result(NULL) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (!Accept(item->GetTemplate()))
+                return true;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult() { return result; }
+
+    protected:
+        virtual bool Accept(const ItemTemplate* proto) = 0;
+
+    private:
+        list<Item*> result;
+    };
+
+    enum IterateItemsMask
+    {
+        ITERATE_ITEMS_IN_BAGS = 1,
+        ITERATE_ITEMS_IN_EQUIP = 2,
+        ITERATE_ALL_ITEMS = 255
+    };
+
+    class FindUsableItemVisitor : public FindItemVisitor {
+    public:
+        FindUsableItemVisitor(Player* bot) : FindItemVisitor()
+        {
+            this->bot = bot;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (bot->CanUseItem(item->GetTemplate()) == EQUIP_ERR_OK)
+                return FindItemVisitor::Visit(item);
+
+            return true;
+        }
+
+    private:
+        Player* bot;
+    };
+
+
+    class FindItemsByQualityVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsByQualityVisitor(uint32 quality, int count) : IterateItemsVisitor()
+        {
+            this->quality = quality;
+            this->count = count;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->Quality != quality)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 quality;
+        int count;
+        list<Item*> result;
+    };
+
+    class FindItemsToTradeByQualityVisitor : public FindItemsByQualityVisitor
+    {
+    public:
+        FindItemsToTradeByQualityVisitor(uint32 quality, int count) : FindItemsByQualityVisitor(quality, count) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            return FindItemsByQualityVisitor::Visit(item);
+        }
+    };
+
+    class FindItemsToTradeByClassVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsToTradeByClassVisitor(uint32 itemClass, uint32 itemSubClass, int count)
+            : IterateItemsVisitor(), count(count), itemClass(itemClass), itemSubClass(itemSubClass) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            if (item->GetTemplate()->Class != itemClass || item->GetTemplate()->SubClass != itemSubClass)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 itemClass;
+        uint32 itemSubClass;
+        int count;
+        list<Item*> result;
+    };
+
+    class QueryItemCountVisitor : public IterateItemsVisitor
+    {
+    public:
+        QueryItemCountVisitor(uint32 itemId)
+        {
+            count = 0;
+            this->itemId = itemId;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->ItemId == itemId)
+                count += item->GetCount();
+
+            return true;
+        }
+
+        int GetCount() { return count; }
+
+    protected:
+        int count;
+        uint32 itemId;
+    };
+
+
+    class QueryNamedItemCountVisitor : public QueryItemCountVisitor
+    {
+    public:
+        QueryNamedItemCountVisitor(string name) : QueryItemCountVisitor(0)
+        {
+            this->name = name;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            const ItemTemplate* proto = item->GetTemplate();
+            if (proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str()))
+                count += item->GetCount();
+
+            return true;
+        }
+
+    private:
+        string name;
+    };
+
+    class FindUsableNamedItemVisitor : public FindUsableItemVisitor {
+    public:
+        FindUsableNamedItemVisitor(Player* bot, string name) : FindUsableItemVisitor(bot)
+        {
+            this->name = name;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str());
+        }
+
+    private:
+        string name;
+    };
+
+    class FindItemByIdVisitor : public FindItemVisitor {
+    public:
+        FindItemByIdVisitor(uint32 id) : FindItemVisitor()
+        {
+            this->id = id;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto->ItemId == id;
+        }
+
+    private:
+        uint32 id;
+    };
+
+    class ListItemsVisitor : public IterateItemsVisitor
+    {
+    public:
+        ListItemsVisitor() : IterateItemsVisitor() {}
+
+        map<uint32, int> items;
+
+        virtual bool Visit(Item* item)
+        {
+            uint32 id = item->GetTemplate()->ItemId;
+
+            if (items.find(id) == items.end())
+                items[id] = 0;
+
+            items[id] += item->GetCount();
+            return true;
+        }
+    };
+
+    class ItemCountByQuality : public IterateItemsVisitor
+    {
+    public:
+        ItemCountByQuality() : IterateItemsVisitor()
+        {
+            for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i)
+                count[i] = 0;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            count[item->GetTemplate()->Quality]++;
+            return true;
+        }
+
+    public:
+        map<uint32, int> count;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Multiplier.cpp b/src/plugins/playerbot/strategy/Multiplier.cpp
new file mode 100644
index 0000000..893d7f3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Multiplier.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Multiplier.h b/src/plugins/playerbot/strategy/Multiplier.h
new file mode 100644
index 0000000..e86fa05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "Action.h"
+
+namespace ai
+{
+    class Multiplier : public AiNamedObject
+    {
+    public:
+        Multiplier(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual ~Multiplier() {}
+
+    public:
+        virtual float GetValue(Action* action) { return 1.0f; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/NamedObjectContext.h b/src/plugins/playerbot/strategy/NamedObjectContext.h
new file mode 100644
index 0000000..2ccb68c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/NamedObjectContext.h
@@ -0,0 +1,249 @@
+#pragma once
+
+namespace ai
+{
+    using namespace std;
+
+    class Qualified
+    {
+    public:
+        Qualified() {};
+
+    public:
+        void Qualify(string qualifier) { this->qualifier = qualifier; }
+
+    protected:
+        string qualifier;
+    };
+
+    template <class T> class NamedObjectFactory
+    {
+    protected:
+        typedef T* (*ActionCreator) (PlayerbotAI* ai);
+        map<string, ActionCreator> creators;
+
+    public:
+        T* create(string name, PlayerbotAI* ai)
+        {
+            size_t found = name.find("::");
+            string qualifier;
+            if (found != string::npos)
+            {
+                qualifier = name.substr(found + 2);
+                name = name.substr(0, found);
+            }
+
+            if (creators.find(name) == creators.end())
+                return NULL;
+
+            ActionCreator creator = creators[name];
+            if (!creator)
+                return NULL;
+
+            T *object = (*creator)(ai);
+            Qualified *q = dynamic_cast<Qualified *>(object);
+            if (q)
+                q->Qualify(qualifier);
+
+            return object;
+        }
+
+        set<string> supports()
+        {
+            set<string> keys;
+            for (typename map<string, ActionCreator>::iterator it = creators.begin(); it != creators.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+    };
+
+
+    template <class T> class NamedObjectContext : public NamedObjectFactory<T>
+    {
+    public:
+        NamedObjectContext(bool shared = false, bool supportsSiblings = false) :
+            NamedObjectFactory<T>(), shared(shared), supportsSiblings(supportsSiblings) {}
+
+        T* create(string name, PlayerbotAI* ai)
+        {
+            if (created.find(name) == created.end())
+                return created[name] = NamedObjectFactory<T>::create(name, ai);
+
+            return created[name];
+        }
+
+        virtual ~NamedObjectContext()
+        {
+            Clear();
+        }
+
+        void Clear()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    delete i->second;
+            }
+
+            created.clear();
+        }
+
+        void Update()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Reset();
+            }
+        }
+
+        bool IsShared() { return shared; }
+        bool IsSupportsSiblings() { return supportsSiblings; }
+
+        set<string> GetCreated()
+        {
+            set<string> keys;
+            for (typename map<string, T*>::iterator it = created.begin(); it != created.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+
+    protected:
+        map<string, T*> created;
+        bool shared;
+        bool supportsSiblings;
+    };
+
+    template <class T> class NamedObjectContextList
+    {
+    public:
+        virtual ~NamedObjectContextList()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                NamedObjectContext<T>* context = *i;
+                if (!context->IsShared())
+                    delete context;
+            }
+        }
+
+        void Add(NamedObjectContext<T>* context)
+        {
+            contexts.push_back(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+        void Update()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsShared())
+                    (*i)->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                (*i)->Reset();
+            }
+        }
+
+        set<string> GetSiblings(string name)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsSupportsSiblings())
+                    continue;
+
+                set<string> supported = (*i)->supports();
+                set<string>::iterator found = supported.find(name);
+                if (found == supported.end())
+                    continue;
+
+                supported.erase(found);
+                return supported;
+            }
+
+            return set<string>();
+        }
+
+        set<string> supports()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> supported = (*i)->supports();
+
+                for (set<string>::iterator j = supported.begin(); j != supported.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+        set<string> GetCreated()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> createdKeys = (*i)->GetCreated();
+
+                for (set<string>::iterator j = createdKeys.begin(); j != createdKeys.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+    private:
+        list<NamedObjectContext<T>*> contexts;
+    };
+
+    template <class T> class NamedObjectFactoryList
+    {
+    public:
+        virtual ~NamedObjectFactoryList()
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+                delete *i;
+        }
+
+        void Add(NamedObjectFactory<T>* context)
+        {
+            factories.push_front(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+    private:
+        list<NamedObjectFactory<T>*> factories;
+    };
+};
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.cpp b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
new file mode 100644
index 0000000..f987438
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
@@ -0,0 +1,47 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "PassiveMultiplier.h"
+
+using namespace ai;
+
+list<string> PassiveMultiplier::allowedActions;
+list<string> PassiveMultiplier::allowedParts;
+
+PassiveMultiplier::PassiveMultiplier(PlayerbotAI* ai) : Multiplier(ai, "passive")
+{
+    if (allowedActions.empty())
+    {
+        allowedActions.push_back("co");
+        allowedActions.push_back("nc");
+        allowedActions.push_back("reset ai");
+        allowedActions.push_back("check mount state");
+    }
+
+    if (allowedParts.empty())
+    {
+        allowedParts.push_back("follow");
+        allowedParts.push_back("stay");
+        allowedParts.push_back("chat shortcut");
+    }
+}
+
+float PassiveMultiplier::GetValue(Action* action) {
+    if (!action)
+		return 1.0f;
+
+    string name = action->getName();
+
+    for (list<string>::iterator i = allowedActions.begin(); i != allowedActions.end(); i++)
+    {
+        if (name == *i)
+            return 1.0f;
+    }
+
+    for (list<string>::iterator i = allowedParts.begin(); i != allowedParts.end(); i++)
+    {
+        if (name.find(*i) != string::npos)
+            return 1.0f;
+    }
+
+    return 0;
+}
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.h b/src/plugins/playerbot/strategy/PassiveMultiplier.h
new file mode 100644
index 0000000..37985a0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+
+namespace ai
+{
+    class PassiveMultiplier : public Multiplier
+    {
+    public:
+        PassiveMultiplier(PlayerbotAI* ai);
+
+    public:
+        virtual float GetValue(Action* action);
+
+    private:
+        static list<string> allowedActions;
+        static list<string> allowedParts;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/Queue.cpp b/src/plugins/playerbot/strategy/Queue.cpp
new file mode 100644
index 0000000..8553b44
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.cpp
@@ -0,0 +1,81 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Action.h"
+#include "Queue.h"
+
+using namespace ai;
+
+
+void Queue::Push(ActionBasket *action)
+{
+	if (action)
+    {
+        for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+        {
+            ActionBasket* basket = *iter;
+            if (action->getAction()->getName() == basket->getAction()->getName())
+            {
+				if (basket->getRelevance() < action->getRelevance())
+					basket->setRelevance(action->getRelevance());
+                delete action;
+                return;
+            }
+        }
+		actions.push_back(action);
+    }
+}
+
+void Queue::Push(ActionBasket **actions)
+{
+	if (actions)
+	{
+		for (int i=0; i<sizeof(actions)/sizeof(ActionBasket*); i++)
+		{
+			Push(actions[i]);
+		}
+	}
+}
+
+ActionNode* Queue::Pop()
+{
+	float max = -1;
+	ActionBasket* selection = NULL;
+	for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+	{
+		ActionBasket* basket = *iter;
+		if (basket->getRelevance() > max)
+		{
+			max = basket->getRelevance();
+			selection = basket;
+		}
+	}
+	if (selection != NULL)
+	{
+		ActionNode* action = selection->getAction();
+		actions.remove(selection);
+		delete selection;
+		return action;
+	}
+	return NULL;
+}
+
+ActionBasket* Queue::Peek()
+{
+    float max = -1;
+    ActionBasket* selection = NULL;
+    for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+    {
+        ActionBasket* basket = *iter;
+        if (basket->getRelevance() > max)
+        {
+            max = basket->getRelevance();
+            selection = basket;
+        }
+    }
+    return selection;
+}
+
+int Queue::Size()
+{
+	return actions.size();
+}
diff --git a/src/plugins/playerbot/strategy/Queue.h b/src/plugins/playerbot/strategy/Queue.h
new file mode 100644
index 0000000..b70a526
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.h
@@ -0,0 +1,21 @@
+#include "ActionBasket.h"
+
+#pragma once
+namespace ai
+{
+class Queue
+{
+public:
+    Queue(void) {}
+public:
+    ~Queue(void) {}
+public:
+	void Push(ActionBasket *action);
+	void Push(ActionBasket **actions);
+	ActionNode* Pop();
+    ActionBasket* Peek();
+	int Size();
+private:
+	std::list<ActionBasket*> actions;
+};
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Strategy.cpp b/src/plugins/playerbot/strategy/Strategy.cpp
new file mode 100644
index 0000000..5275ae0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.cpp
@@ -0,0 +1,117 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Strategy.h"
+#include "NamedObjectContext.h"
+
+using namespace ai;
+using namespace std;
+
+
+class ActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ActionNodeFactoryInternal()
+    {
+        creators["melee"] = &melee;
+        creators["healthstone"] = &healthstone;
+        creators["be near"] = &follow_master_random;
+        creators["attack anything"] = &attack_anything;
+        creators["move random"] = &move_random;
+        creators["move to loot"] = &move_to_loot;
+        creators["food"] = &food;
+        creators["drink"] = &drink;
+        creators["mana potion"] = &mana_potion;
+        creators["healing potion"] = &healing_potion;
+        creators["flee"] = &flee;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* healthstone(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healthstone",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* follow_master_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("be near",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("follow"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* attack_anything(PlayerbotAI* ai)
+    {
+        return new ActionNode ("attack anything",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* move_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move random",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("stay line"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* move_to_loot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move to loot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* food(PlayerbotAI* ai)
+    {
+        return new ActionNode ("food",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* drink(PlayerbotAI* ai)
+    {
+        return new ActionNode ("drink",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* healing_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healing potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("food"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+Strategy::Strategy(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    actionNodeFactories.Add(new ActionNodeFactoryInternal());
+}
+
+ActionNode* Strategy::GetAction(string name)
+{
+    return actionNodeFactories.GetObject(name, ai);
+}
+
diff --git a/src/plugins/playerbot/strategy/Strategy.h b/src/plugins/playerbot/strategy/Strategy.h
new file mode 100644
index 0000000..12e98eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+#include "Trigger.h"
+#include "NamedObjectContext.h"
+
+namespace ai
+{
+	enum StrategyType
+	{
+		STRATEGY_TYPE_GENERIC = 0,
+		STRATEGY_TYPE_COMBAT = 1,
+		STRATEGY_TYPE_NONCOMBAT = 2,
+		STRATEGY_TYPE_TANK = 4,
+		STRATEGY_TYPE_DPS = 8,
+		STRATEGY_TYPE_HEAL = 16,
+		STRATEGY_TYPE_RANGED = 32,
+		STRATEGY_TYPE_MELEE = 64
+	};
+
+	enum ActionPriority
+	{
+	    ACTION_IDLE = 0,
+	    ACTION_NORMAL = 10,
+	    ACTION_HIGH = 20,
+	    ACTION_MOVE = 30,
+	    ACTION_INTERRUPT = 40,
+	    ACTION_DISPEL = 50,
+	    ACTION_LIGHT_HEAL = 60,
+	    ACTION_MEDIUM_HEAL = 70,
+	    ACTION_CRITICAL_HEAL = 80,
+	    ACTION_EMERGENCY = 90
+	};
+
+    class Strategy : public PlayerbotAIAware
+    {
+    public:
+        Strategy(PlayerbotAI* ai);
+        virtual ~Strategy() {}
+
+    public:
+        virtual NextAction** getDefaultActions() { return NULL; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers) {}
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers) {}
+        virtual string getName() = 0;
+		virtual int GetType() { return STRATEGY_TYPE_GENERIC; }
+        virtual ActionNode* GetAction(string name);
+        void Update() {}
+        void Reset() {}
+
+    protected:
+        NamedObjectFactoryList<ActionNode> actionNodeFactories;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/StrategyContext.h b/src/plugins/playerbot/strategy/StrategyContext.h
new file mode 100644
index 0000000..7283ed7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/StrategyContext.h
@@ -0,0 +1,146 @@
+#pragma once
+
+#include "generic/NonCombatStrategy.h"
+#include "generic/RacialsStrategy.h"
+#include "generic/ChatCommandHandlerStrategy.h"
+#include "generic/WorldPacketHandlerStrategy.h"
+#include "generic/DeadStrategy.h"
+#include "generic/QuestStrategies.h"
+#include "generic/LootNonCombatStrategy.h"
+#include "generic/DuelStrategy.h"
+#include "generic/KiteStrategy.h"
+#include "generic/FleeStrategy.h"
+#include "generic/FollowMasterStrategy.h"
+#include "generic/RunawayStrategy.h"
+#include "generic/StayStrategy.h"
+#include "generic/UseFoodStrategy.h"
+#include "generic/ConserveManaStrategy.h"
+#include "generic/EmoteStrategy.h"
+#include "generic/AttackRtiStrategy.h"
+#include "generic/AttackWeakStrategy.h"
+#include "generic/TankAoeStrategy.h"
+#include "generic/TankAssistStrategy.h"
+#include "generic/DpsAoeStrategy.h"
+#include "generic/DpsAssistStrategy.h"
+#include "generic/PassiveStrategy.h"
+#include "generic/GrindingStrategy.h"
+#include "generic/UsePotionsStrategy.h"
+#include "generic/GuardStrategy.h"
+#include "generic/CastTimeStrategy.h"
+#include "generic/ThreatStrategy.h"
+#include "generic/TellTargetStrategy.h"
+#include "generic/AttackEnemyPlayersStrategy.h"
+#include "generic/MoveRandomStrategy.h"
+
+namespace ai
+{
+    class StrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        StrategyContext()
+        {
+            creators["racials"] = &StrategyContext::racials;
+            creators["loot"] = &StrategyContext::loot;
+            creators["gather"] = &StrategyContext::gather;
+            creators["emote"] = &StrategyContext::emote;
+            creators["passive"] = &StrategyContext::passive;
+            creators["conserve mana"] = &StrategyContext::conserve_mana;
+            creators["food"] = &StrategyContext::food;
+            creators["chat"] = &StrategyContext::chat;
+            creators["default"] = &StrategyContext::world_packet;
+            creators["ready check"] = &StrategyContext::ready_check;
+            creators["dead"] = &StrategyContext::dead;
+            creators["flee"] = &StrategyContext::flee;
+            creators["duel"] = &StrategyContext::duel;
+            creators["kite"] = &StrategyContext::kite;
+            creators["potions"] = &StrategyContext::potions;
+            creators["cast time"] = &StrategyContext::cast_time;
+            creators["threat"] = &StrategyContext::threat;
+            creators["tell target"] = &StrategyContext::tell_target;
+            creators["pvp"] = &StrategyContext::pvp;
+            creators["move random"] = &StrategyContext::move_random;
+            creators["lfg"] = &StrategyContext::lfg;
+        }
+
+    private:
+        static Strategy* tell_target(PlayerbotAI* ai) { return new TellTargetStrategy(ai); }
+        static Strategy* threat(PlayerbotAI* ai) { return new ThreatStrategy(ai); }
+        static Strategy* cast_time(PlayerbotAI* ai) { return new CastTimeStrategy(ai); }
+        static Strategy* potions(PlayerbotAI* ai) { return new UsePotionsStrategy(ai); }
+        static Strategy* kite(PlayerbotAI* ai) { return new KiteStrategy(ai); }
+        static Strategy* duel(PlayerbotAI* ai) { return new DuelStrategy(ai); }
+        static Strategy* flee(PlayerbotAI* ai) { return new FleeStrategy(ai); }
+        static Strategy* dead(PlayerbotAI* ai) { return new DeadStrategy(ai); }
+        static Strategy* racials(PlayerbotAI* ai) { return new RacialsStrategy(ai); }
+        static Strategy* loot(PlayerbotAI* ai) { return new LootNonCombatStrategy(ai); }
+        static Strategy* gather(PlayerbotAI* ai) { return new GatherStrategy(ai); }
+        static Strategy* emote(PlayerbotAI* ai) { return new EmoteStrategy(ai); }
+        static Strategy* passive(PlayerbotAI* ai) { return new PassiveStrategy(ai); }
+        static Strategy* conserve_mana(PlayerbotAI* ai) { return new ConserveManaStrategy(ai); }
+        static Strategy* food(PlayerbotAI* ai) { return new UseFoodStrategy(ai); }
+        static Strategy* chat(PlayerbotAI* ai) { return new ChatCommandHandlerStrategy(ai); }
+        static Strategy* world_packet(PlayerbotAI* ai) { return new WorldPacketHandlerStrategy(ai); }
+        static Strategy* ready_check(PlayerbotAI* ai) { return new ReadyCheckStrategy(ai); }
+        static Strategy* pvp(PlayerbotAI* ai) { return new AttackEnemyPlayersStrategy(ai); }
+        static Strategy* move_random(PlayerbotAI* ai) { return new MoveRandomStrategy(ai); }
+        static Strategy* lfg(PlayerbotAI* ai) { return new LfgStrategy(ai); }
+    };
+
+    class MovementStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        MovementStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["follow"] = &MovementStrategyContext::follow_master;
+            creators["stay"] = &MovementStrategyContext::stay;
+            creators["runaway"] = &MovementStrategyContext::runaway;
+            creators["flee from adds"] = &MovementStrategyContext::flee_from_adds;
+            creators["guard"] = &MovementStrategyContext::guard;
+        }
+
+    private:
+        static Strategy* guard(PlayerbotAI* ai) { return new GuardStrategy(ai); }
+        static Strategy* follow_master(PlayerbotAI* ai) { return new FollowMasterStrategy(ai); }
+        static Strategy* stay(PlayerbotAI* ai) { return new StayStrategy(ai); }
+        static Strategy* runaway(PlayerbotAI* ai) { return new RunawayStrategy(ai); }
+        static Strategy* flee_from_adds(PlayerbotAI* ai) { return new FleeFromAddsStrategy(ai); }
+    };
+
+    class AssistStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        AssistStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["dps assist"] = &AssistStrategyContext::dps_assist;
+            creators["dps aoe"] = &AssistStrategyContext::dps_aoe;
+            creators["tank assist"] = &AssistStrategyContext::tank_assist;
+            creators["tank aoe"] = &AssistStrategyContext::tank_aoe;
+            creators["attack weak"] = &AssistStrategyContext::attack_weak;
+            creators["grind"] = &AssistStrategyContext::grind;
+            creators["attack rti"] = &AssistStrategyContext::attack_rti;
+        }
+
+    private:
+        static Strategy* dps_assist(PlayerbotAI* ai) { return new DpsAssistStrategy(ai); }
+        static Strategy* dps_aoe(PlayerbotAI* ai) { return new DpsAoeStrategy(ai); }
+        static Strategy* tank_assist(PlayerbotAI* ai) { return new TankAssistStrategy(ai); }
+        static Strategy* tank_aoe(PlayerbotAI* ai) { return new TankAoeStrategy(ai); }
+        static Strategy* attack_weak(PlayerbotAI* ai) { return new AttackWeakStrategy(ai); }
+        static Strategy* grind(PlayerbotAI* ai) { return new GrindingStrategy(ai); }
+        static Strategy* attack_rti(PlayerbotAI* ai) { return new AttackRtiStrategy(ai); }
+    };
+
+    class QuestStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        QuestStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["quest"] = &QuestStrategyContext::quest;
+            creators["accept all quests"] = &QuestStrategyContext::accept_all_quests;
+        }
+
+    private:
+        static Strategy* quest(PlayerbotAI* ai) { return new DefaultQuestStrategy(ai); }
+        static Strategy* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsStrategy(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/Trigger.cpp b/src/plugins/playerbot/strategy/Trigger.cpp
new file mode 100644
index 0000000..7487f33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.cpp
@@ -0,0 +1,27 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Trigger.h"
+#include "Action.h"
+
+using namespace ai;
+
+Event Trigger::Check()
+{
+	if (IsActive())
+	{
+		Event event(getName());
+		return event;
+	}
+	Event event;
+	return event;
+}
+
+Value<Unit*>* Trigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Trigger::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Trigger.h b/src/plugins/playerbot/strategy/Trigger.h
new file mode 100644
index 0000000..2ae7276
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.h
@@ -0,0 +1,84 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+
+#define NEXT_TRIGGERS(name, relevance) \
+    virtual NextAction* getNextAction() { return new NextAction(name, relevance); }
+
+#define BEGIN_TRIGGER(clazz, super) \
+class clazz : public super \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : super(ai) {} \
+    public: \
+        virtual bool IsActive();
+
+#define END_TRIGGER() \
+    };
+
+namespace ai
+{
+    class Trigger : public AiNamedObject
+	{
+	public:
+        Trigger(PlayerbotAI* ai, string name = "trigger", int checkInterval = 1) : AiNamedObject(ai, name) {
+			this->checkInterval = checkInterval;
+			ticksElapsed = 0;
+        }
+        virtual ~Trigger() {}
+
+	public:
+        virtual Event Check();
+        virtual void ExternalEvent(string param, Player* owner = NULL) {}
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL) {}
+        virtual bool IsActive() { return false; }
+        virtual NextAction** getHandlers() { return NULL; }
+        void Update() {}
+        virtual void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+
+		bool needCheck() {
+			if (++ticksElapsed >= checkInterval) {
+				ticksElapsed = 0;
+				return true;
+			}
+			return false;
+		}
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+	};
+
+
+    class TriggerNode
+    {
+    public:
+        TriggerNode(string name, NextAction** handlers = NULL)
+        {
+            this->name = name;
+            this->handlers = handlers;
+            this->trigger = NULL;
+        }
+        virtual ~TriggerNode()
+        {
+            NextAction::destroy(handlers);
+        }
+
+    public:
+        Trigger* getTrigger() { return trigger; }
+        void setTrigger(Trigger* trigger) { this->trigger = trigger; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getHandlers() { return NextAction::merge(NextAction::clone(handlers), trigger->getHandlers()); }
+
+    private:
+        Trigger* trigger;
+        NextAction** handlers;
+        std::string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Value.cpp b/src/plugins/playerbot/strategy/Value.cpp
new file mode 100644
index 0000000..8b87c26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Value.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/Value.h b/src/plugins/playerbot/strategy/Value.h
new file mode 100644
index 0000000..930e3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.h
@@ -0,0 +1,177 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class UntypedValue : public AiNamedObject
+    {
+    public:
+        UntypedValue(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual void Update() {}
+        virtual void Reset() {}
+        virtual string Format() { return "?"; }
+    };
+
+    template<class T>
+    class Value
+    {
+    public:
+        virtual T Get() = 0;
+        virtual void Set(T value) = 0;
+        operator T() { return Get(); }
+    };
+
+    template<class T>
+    class CalculatedValue : public UntypedValue, public Value<T>
+	{
+	public:
+        CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) : UntypedValue(ai, name),
+            checkInterval(checkInterval), ticksElapsed(checkInterval)
+        { }
+        virtual ~CalculatedValue() {}
+
+	public:
+        virtual T Get()
+        {
+            if (ticksElapsed >= checkInterval) {
+                ticksElapsed = 0;
+                value = Calculate();
+            }
+            return value;
+        }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update()
+        {
+            if (ticksElapsed < checkInterval) {
+                ticksElapsed++;
+            }
+        }
+
+    protected:
+        virtual T Calculate() = 0;
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+        T value;
+	};
+
+    class Uint8CalculatedValue : public CalculatedValue<uint8>
+    {
+    public:
+        Uint8CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint8>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class Uint32CalculatedValue : public CalculatedValue<uint32>
+    {
+    public:
+        Uint32CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint32>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class FloatCalculatedValue : public CalculatedValue<float>
+    {
+    public:
+        FloatCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<float>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << Calculate();
+            return out.str();
+        }
+    };
+
+    class BoolCalculatedValue : public CalculatedValue<bool>
+    {
+    public:
+        BoolCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<bool>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            return Calculate() ? "true" : "false";
+        }
+    };
+
+    class UnitCalculatedValue : public CalculatedValue<Unit*>
+    {
+    public:
+        UnitCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<Unit*>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Calculate();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+
+    class ObjectGuidListCalculatedValue : public CalculatedValue<list<ObjectGuid> >
+    {
+    public:
+        ObjectGuidListCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<list<ObjectGuid> >(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << "{";
+            list<ObjectGuid> guids = Calculate();
+            for (list<ObjectGuid>::iterator i = guids.begin(); i != guids.end(); ++i)
+            {
+                ObjectGuid guid = *i;
+                out << guid.GetRawValue() << ",";
+            }
+            out << "}";
+            return out.str();
+        }
+    };
+
+    template<class T>
+    class ManualSetValue : public UntypedValue, public Value<T>
+    {
+    public:
+        ManualSetValue(PlayerbotAI* ai, T defaultValue, string name = "value") :
+            UntypedValue(ai, name), value(defaultValue), defaultValue(defaultValue) {}
+        virtual ~ManualSetValue() {}
+
+    public:
+        virtual T Get() { return value; }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update() { }
+        virtual void Reset() { value = defaultValue; }
+
+    protected:
+        T value;
+        T defaultValue;
+    };
+
+    class UnitManualSetValue : public ManualSetValue<Unit*>
+    {
+    public:
+        UnitManualSetValue(PlayerbotAI* ai, Unit* defaultValue, string name = "value") :
+            ManualSetValue<Unit*>(ai, defaultValue, name) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Get();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
new file mode 100644
index 0000000..461ea7e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptDuelAction : public Action
+    {
+    public:
+        AcceptDuelAction(PlayerbotAI* ai) : Action(ai, "accept duel")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket p(event.getPacket());
+
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+            *packet << flagGuid;
+            bot->GetSession()->QueuePacket(packet);
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
new file mode 100644
index 0000000..096fb84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Globals/ObjectMgr.h"
+
+namespace ai
+{
+    class AcceptInvitationAction : public Action {
+    public:
+        AcceptInvitationAction(PlayerbotAI* ai) : Action(ai, "accept invitation") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+
+            Group* grp = bot->GetGroupInvite();
+            if (!grp)
+                return false;
+
+            Player* inviter = sObjectMgr->GetPlayerByLowGUID(grp->GetLeaderGUID());
+            if (!inviter)
+                return false;
+
+			if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, inviter))
+            {
+                WorldPacket data(SMSG_GROUP_DECLINE, 10);
+                data << bot->GetName();
+                inviter->GetSession()->SendPacket(&data);
+                bot->UninviteFromGroup();
+                return false;
+            }
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << roles_mask;
+            bot->GetSession()->HandleGroupAcceptOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+                bot->GetPlayerbotAI()->SetMaster(inviter);
+
+            ai->ResetStrategies();
+            ai->TellMaster("Hello");
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
new file mode 100644
index 0000000..af63f76
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
@@ -0,0 +1,102 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AcceptQuestAction.h"
+
+using namespace ai;
+
+void AcceptAllQuestsAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    AcceptQuest(quest, questGiver->GetGUID());
+}
+
+bool AcceptQuestAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Player *bot = ai->GetBot();
+    uint64 guid;
+    uint32 quest;
+
+    string text = event.getParam();
+    PlayerbotChatHandler ch(master);
+    quest = ch.extractQuestId(text);
+    if (quest)
+    {
+        Unit* npc = master->GetSelectedUnit();
+        if (!npc)
+        {
+            ai->TellMaster("Please select quest giver NPC");
+            return false;
+        }
+    }
+    else if (!event.getPacket().empty())
+    {
+        WorldPacket& p = event.getPacket();
+        p.rpos(0);
+        p >> guid >> quest;
+    }
+    else if (text == "*")
+    {
+        return QuestAction::Execute(event);
+    }
+    else
+        return false;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+    if (!qInfo)
+        return false;
+
+    return AcceptQuest(qInfo, guid);
+}
+
+bool AcceptQuestShareAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    Player *bot = ai->GetBot();
+
+    WorldPacket& p = event.getPacket();
+    p.rpos(0);
+    uint32 quest;
+    p >> quest;
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+
+    if (!qInfo || !bot->GetDivider())
+        return false;
+
+    quest = qInfo->GetQuestId();
+    if( !bot->CanTakeQuest( qInfo, false ) )
+    {
+        // can't take quest
+        bot->SetDivider( ObjectGuid() );
+        ai->TellMaster("I can't take this quest");
+
+        return false;
+    }
+
+    // send msg to quest giving player
+    master->SendPushToPartyResponse( bot, QUEST_PARTY_MSG_ACCEPT_QUEST );
+    bot->SetDivider( ObjectGuid() );
+
+    if( bot->CanAddQuest( qInfo, false ) )
+    {
+        bot->AddQuest( qInfo, master );
+
+        if( bot->CanCompleteQuest( quest ) )
+            bot->CompleteQuest( quest );
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if( qInfo->GetSrcSpell() > 0 )
+            bot->CastSpell( bot, qInfo->GetSrcSpell(), true );
+
+        ai->TellMaster("Quest accepted");
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
new file mode 100644
index 0000000..856c697
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class AcceptAllQuestsAction : public QuestAction {
+    public:
+        AcceptAllQuestsAction(PlayerbotAI* ai, string name = "accept all quests") : QuestAction(ai, name) {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+    };
+
+    class AcceptQuestAction : public AcceptAllQuestsAction {
+    public:
+        AcceptQuestAction(PlayerbotAI* ai) : AcceptAllQuestsAction(ai, "accept quest") {}
+        virtual bool Execute(Event event);
+    };
+
+    class AcceptQuestShareAction : public Action {
+    public:
+        AcceptQuestShareAction(PlayerbotAI* ai) : Action(ai, "accept quest share") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
new file mode 100644
index 0000000..77dd0dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptResurrectAction : public Action {
+    public:
+        AcceptResurrectAction(PlayerbotAI* ai) : Action(ai, "accept resurrect") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive())
+                return false;
+
+            WorldPacket p(event.getPacket());
+            p.rpos(0);
+            ObjectGuid guid;
+            p >> guid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8+1);
+            *packet << guid;
+            *packet << uint8(1);                        // accept
+            bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ActionContext.h b/src/plugins/playerbot/strategy/actions/ActionContext.h
new file mode 100644
index 0000000..7e76955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ActionContext.h
@@ -0,0 +1,110 @@
+#pragma once
+
+#include "GenericActions.h"
+#include "NonCombatActions.h"
+#include "EmoteAction.h"
+#include "AddLootAction.h"
+#include "LootAction.h"
+#include "AddLootAction.h"
+#include "StayActions.h"
+#include "FollowActions.h"
+#include "ChangeStrategyAction.h"
+#include "ChooseTargetActions.h"
+#include "SuggestWhatToDoAction.h"
+#include "PositionAction.h"
+#include "AttackAction.h"
+#include "CheckMailAction.h"
+
+namespace ai
+{
+    class ActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ActionContext()
+        {
+            creators["attack"] = &ActionContext::melee;
+            creators["melee"] = &ActionContext::melee;
+            creators["reach spell"] = &ActionContext::ReachSpell;
+            creators["reach melee"] = &ActionContext::ReachMelee;
+            creators["flee"] = &ActionContext::flee;
+            creators["gift of the naaru"] = &ActionContext::gift_of_the_naaru;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["lifeblood"] = &ActionContext::lifeblood;
+            creators["arcane torrent"] = &ActionContext::arcane_torrent;
+            creators["end pull"] = &ActionContext::end_pull;
+            creators["healthstone"] = &ActionContext::healthstone;
+            creators["healing potion"] = &ActionContext::healing_potion;
+            creators["mana potion"] = &ActionContext::mana_potion;
+            creators["food"] = &ActionContext::food;
+            creators["drink"] = &ActionContext::drink;
+            creators["tank assist"] = &ActionContext::tank_assist;
+            creators["dps assist"] = &ActionContext::dps_assist;
+            creators["attack rti target"] = &ActionContext::attack_rti_target;
+            creators["loot"] = &ActionContext::loot;
+            creators["add loot"] = &ActionContext::add_loot;
+            creators["add gathering loot"] = &ActionContext::add_gathering_loot;
+            creators["add all loot"] = &ActionContext::add_all_loot;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["follow"] = &ActionContext::follow;
+            creators["follow"] = &ActionContext::follow;
+            creators["runaway"] = &ActionContext::runaway;
+            creators["stay"] = &ActionContext::stay;
+            creators["attack anything"] = &ActionContext::attack_anything;
+            creators["attack least hp target"] = &ActionContext::attack_least_hp_target;
+            creators["attack enemy player"] = &ActionContext::enemy_player_target;
+            creators["emote"] = &ActionContext::emote;
+            creators["suggest what to do"] = &ActionContext::suggest_what_to_do;
+            creators["move random"] = &ActionContext::move_random;
+            creators["move to loot"] = &ActionContext::move_to_loot;
+            creators["open loot"] = &ActionContext::open_loot;
+            creators["guard"] = &ActionContext::guard;
+            creators["move out of enemy contact"] = &ActionContext::move_out_of_enemy_contact;
+            creators["set facing"] = &ActionContext::set_facing;
+            creators["attack duel opponent"] = &ActionContext::attack_duel_opponent;
+            creators["drop target"] = &ActionContext::drop_target;
+            creators["check mail"] = &ActionContext::check_mail;
+        }
+
+    private:
+        static Action* check_mail(PlayerbotAI* ai) { return new CheckMailAction(ai); }
+        static Action* drop_target(PlayerbotAI* ai) { return new DropTargetAction(ai); }
+        static Action* attack_duel_opponent(PlayerbotAI* ai) { return new AttackDuelOpponentAction(ai); }
+        static Action* guard(PlayerbotAI* ai) { return new GuardAction(ai); }
+        static Action* open_loot(PlayerbotAI* ai) { return new OpenLootAction(ai); }
+        static Action* move_to_loot(PlayerbotAI* ai) { return new MoveToLootAction(ai); }
+        static Action* move_random(PlayerbotAI* ai) { return new MoveRandomAction(ai); }
+        static Action* shoot(PlayerbotAI* ai) { return new CastShootAction(ai); }
+        static Action* melee(PlayerbotAI* ai) { return new MeleeAction(ai); }
+        static Action* ReachSpell(PlayerbotAI* ai) { return new ReachSpellAction(ai); }
+        static Action* ReachMelee(PlayerbotAI* ai) { return new ReachMeleeAction(ai); }
+        static Action* flee(PlayerbotAI* ai) { return new FleeAction(ai); }
+        static Action* gift_of_the_naaru(PlayerbotAI* ai) { return new CastGiftOfTheNaaruAction(ai); }
+        static Action* lifeblood(PlayerbotAI* ai) { return new CastLifeBloodAction(ai); }
+        static Action* arcane_torrent(PlayerbotAI* ai) { return new CastArcaneTorrentAction(ai); }
+        static Action* end_pull(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai, "-pull"); }
+
+        static Action* emote(PlayerbotAI* ai) { return new EmoteAction(ai); }
+        static Action* suggest_what_to_do(PlayerbotAI* ai) { return new SuggestWhatToDoAction(ai); }
+        static Action* attack_anything(PlayerbotAI* ai) { return new AttackAnythingAction(ai); }
+        static Action* attack_least_hp_target(PlayerbotAI* ai) { return new AttackLeastHpTargetAction(ai); }
+        static Action* enemy_player_target(PlayerbotAI* ai) { return new AttackEnemyPlayerAction(ai); }
+        static Action* stay(PlayerbotAI* ai) { return new StayAction(ai); }
+        static Action* runaway(PlayerbotAI* ai) { return new RunAwayAction(ai); }
+        static Action* follow(PlayerbotAI* ai) { return new FollowAction(ai); }
+        static Action* add_gathering_loot(PlayerbotAI* ai) { return new AddGatheringLootAction(ai); }
+        static Action* add_loot(PlayerbotAI* ai) { return new AddLootAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* loot(PlayerbotAI* ai) { return new LootAction(ai); }
+        static Action* dps_assist(PlayerbotAI* ai) { return new DpsAssistAction(ai); }
+        static Action* attack_rti_target(PlayerbotAI* ai) { return new AttackRtiTargetAction(ai); }
+        static Action* tank_assist(PlayerbotAI* ai) { return new TankAssistAction(ai); }
+        static Action* drink(PlayerbotAI* ai) { return new DrinkAction(ai); }
+        static Action* food(PlayerbotAI* ai) { return new EatAction(ai); }
+        static Action* mana_potion(PlayerbotAI* ai) { return new UseManaPotion(ai); }
+        static Action* healing_potion(PlayerbotAI* ai) { return new UseHealingPotion(ai); }
+        static Action* healthstone(PlayerbotAI* ai) { return new UseItemAction(ai, "healthstone"); }
+        static Action* move_out_of_enemy_contact(PlayerbotAI* ai) { return new MoveOutOfEnemyContactAction(ai); }
+        static Action* set_facing(PlayerbotAI* ai) { return new SetFacingTargetAction(ai); }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.cpp b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
new file mode 100644
index 0000000..4d2c3ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AddLootAction.h"
+
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AddLootAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+    if (!guid)
+        return false;
+
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddAllLootAction::Execute(Event event)
+{
+    bool added = false;
+
+    list<ObjectGuid> gos = context->GetValue<list<ObjectGuid> >("nearest game objects")->Get();
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        added |= AddLoot(*i);
+
+    list<ObjectGuid> corpses = context->GetValue<list<ObjectGuid> >("nearest corpses")->Get();
+    for (list<ObjectGuid>::iterator i = corpses.begin(); i != corpses.end(); i++)
+        added |= AddLoot(*i);
+
+    return added;
+}
+
+bool AddLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::AddLoot(ObjectGuid guid)
+{
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddGatheringLootAction::AddLoot(ObjectGuid guid)
+{
+    LootObject loot(bot, guid);
+
+    if (loot.IsEmpty() || !loot.GetWorldObject(bot))
+        return false;
+
+    if (loot.skillId == SKILL_NONE)
+        return false;
+
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return AddAllLootAction::AddLoot(guid);
+}
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.h b/src/plugins/playerbot/strategy/actions/AddLootAction.h
new file mode 100644
index 0000000..402c50a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AddLootAction : public Action {
+    public:
+        AddLootAction(PlayerbotAI* ai) : Action(ai, "add loot") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class AddAllLootAction : public Action {
+    public:
+        AddAllLootAction(PlayerbotAI* ai, string name = "add all loot") : Action(ai, name) {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+    class AddGatheringLootAction : public AddAllLootAction {
+    public:
+        AddGatheringLootAction(PlayerbotAI* ai) : AddAllLootAction(ai, "add gathering loot") {}
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
new file mode 100644
index 0000000..45518b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
@@ -0,0 +1,80 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AreaTriggerAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool ReachAreaTriggerAction::Execute(Event event)
+{
+    uint32 triggerId;
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    p >> triggerId;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+    {
+        WorldPacket p1(CMSG_AREATRIGGER);
+        p1 << triggerId;
+        p1.rpos(0);
+        bot->GetSession()->HandleAreaTriggerOpcode(p1);
+
+        return true;
+    }
+
+    if (bot->GetMapId() != atEntry->mapid || bot->GetDistance(atEntry->x, atEntry->y, atEntry->z) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I won't follow: too far away");
+        return true;
+    }
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+	mm.MovePoint(atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
+    float distance = bot->GetDistance(atEntry->x, atEntry->y, atEntry->z);
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+    ai->TellMaster("Wait for me");
+    ai->SetNextCheckDelay(delay);
+    context->GetValue<LastMovement&>("last movement")->Get().lastAreaTrigger = triggerId;
+
+    return true;
+}
+
+
+
+bool AreaTriggerAction::Execute(Event event)
+{
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    uint32 triggerId = movement.lastAreaTrigger;
+    movement.lastAreaTrigger = 0;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+        return true;
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+
+    WorldPacket p(CMSG_AREATRIGGER);
+    p << triggerId;
+    p.rpos(0);
+    bot->GetSession()->HandleAreaTriggerOpcode(p);
+
+    ai->TellMaster("Hello");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
new file mode 100644
index 0000000..de2b63a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class ReachAreaTriggerAction : public MovementAction {
+    public:
+        ReachAreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "reach area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class AreaTriggerAction : public MovementAction {
+    public:
+        AreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.cpp b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
new file mode 100644
index 0000000..ded8aab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
@@ -0,0 +1,104 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackAction.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../../game/AI/CreatureAI.h"
+#include "../../../Entities/Pet/Pet.h"
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AttackAction::Execute(Event event)
+{
+    Unit* target = GetTarget();
+
+    if (!target)
+        return false;
+
+    return Attack(target);
+}
+
+bool AttackMyTargetAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("You have no target");
+        return false;
+    }
+
+    return Attack(target);
+}
+
+bool AttackAction::Attack(Unit* target)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (bot->IsFlying())
+    {
+        if (verbose) ai->TellMaster("I cannot attack in flight");
+        return false;
+    }
+
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("I have no target");
+        return false;
+    }
+
+    ostringstream msg;
+    msg << target->GetName();
+    if (bot->IsFriendlyTo(target))
+    {
+        msg << " is friendly to me";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+    if (!bot->IsWithinLOSInMap(target))
+    {
+        msg << " is not on my sight";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+
+    if (bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+
+    ObjectGuid guid = target->GetGUID();
+    bot->SetSelection(target->GetGUID());
+
+    Unit* oldTarget = context->GetValue<Unit*>("current target")->Get();
+    context->GetValue<Unit*>("old target")->Set(oldTarget);
+
+    context->GetValue<Unit*>("current target")->Set(target);
+    context->GetValue<LootObjectStack*>("available loot")->Get()->Add(guid);
+
+    Pet* pet = bot->GetPet();
+    if (pet)
+    {
+        pet->SetTarget(target->GetGUID());
+        pet->AI()->EnterCombat(target);
+		pet->GetCharmInfo()->SetIsCommandAttack(true);
+		pet->AI()->AttackStart(target);
+    }
+
+    bot->Attack(target, true);
+    ai->ChangeEngine(BOT_STATE_COMBAT);
+    return true;
+}
+
+bool AttackDuelOpponentAction::isUseful()
+{
+    return AI_VALUE(Unit*, "duel target");
+}
+
+bool AttackDuelOpponentAction::Execute(Event event)
+{
+    return Attack(AI_VALUE(Unit*, "duel target"));
+}
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.h b/src/plugins/playerbot/strategy/actions/AttackAction.h
new file mode 100644
index 0000000..ede665d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class AttackAction : public MovementAction
+	{
+	public:
+		AttackAction(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Attack(Unit* target);
+    };
+
+    class AttackMyTargetAction : public AttackAction
+    {
+    public:
+        AttackMyTargetAction(PlayerbotAI* ai, string name = "attack my target") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class AttackDuelOpponentAction : public AttackAction
+    {
+    public:
+        AttackDuelOpponentAction(PlayerbotAI* ai, string name = "attack duel opponent") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.cpp b/src/plugins/playerbot/strategy/actions/BankAction.cpp
new file mode 100644
index 0000000..c7254be
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.cpp
@@ -0,0 +1,168 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BankAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace std;
+using namespace ai;
+
+bool BankAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (!npc || !bot->GetNPCIfCanInteractWith(npc->GetGUID(), UNIT_NPC_FLAG_BANKER))
+            continue;
+
+        return Execute(text, npc);
+    }
+
+    ai->TellMaster("Cannot find banker nearby");
+    return false;
+}
+
+bool BankAction::Execute(string text, Unit* bank)
+{
+    if (text.empty() || text == "?")
+    {
+        ListItems();
+        return true;
+    }
+
+    bool result = false;
+    if (text[0] == '-')
+    {
+        ItemIds found = chat->parseItems(text);
+        for (ItemIds::iterator i = found.begin(); i != found.end(); i++)
+        {
+            uint32 itemId = *i;
+            result &= Withdraw(itemId);
+        }
+    }
+    else
+    {
+        list<Item*> found = parseItems(text);
+        if (found.empty())
+            return false;
+
+        for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        {
+            Item* item = *i;
+            if (!item)
+                continue;
+
+            result &= Deposit(item);
+        }
+    }
+
+    return result;
+}
+
+bool BankAction::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (!pItem)
+        return false;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->StoreItem(dest, pItem, true);
+
+    std::ostringstream out;
+    out << "got " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " from bank";
+    ai->TellMaster(out.str());
+    return true;
+}
+
+bool BankAction::Deposit(Item* pItem)
+{
+    std::ostringstream out;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->BankItem(dest, pItem, true);
+
+    out << "put " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " to bank";
+    ai->TellMaster(out.str());
+	return true;
+}
+
+void BankAction::ListItems()
+{
+    ai->TellMaster("=== Bank ===");
+
+    map<uint32, int> items;
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = static_cast<Bag *>(bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = bot->GetItemByPos(bag, slot);
+                if (item)
+                    items[item->GetTemplate()->ItemId] = item->GetCount();
+            }
+        }
+    }
+
+    TellItems(items);
+}
+
+Item* BankAction::FindItemInBank(uint32 ItemId)
+{
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.h b/src/plugins/playerbot/strategy/actions/BankAction.h
new file mode 100644
index 0000000..6b22095
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BankAction : public InventoryAction {
+    public:
+        BankAction(PlayerbotAI* ai) : InventoryAction(ai, "bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, Unit* bank);
+        void ListItems();
+        bool Withdraw(const uint32 itemid);
+        bool Deposit(Item* pItem);
+        Item* FindItemInBank(uint32 ItemId);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.cpp b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
new file mode 100644
index 0000000..4a45c9b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuffAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+class FindBuffVisitor : public IterateItemsVisitor {
+public:
+    FindBuffVisitor(Player* bot) : IterateItemsVisitor(), bot(bot)
+    {
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        if (bot->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+            return true;
+
+        const ItemTemplate* proto = item->GetTemplate();
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        if (proto->SubClass != ITEM_SUBCLASS_ELIXIR &&
+            proto->SubClass != ITEM_SUBCLASS_FLASK &&
+            proto->SubClass != ITEM_SUBCLASS_SCROLL &&
+            proto->SubClass != ITEM_SUBCLASS_FOOD &&
+            proto->SubClass != ITEM_SUBCLASS_CONSUMABLE_OTHER &&
+            proto->SubClass != ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+            return true;
+
+        for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+        {
+            uint32 spellId = proto->Spells[i].SpellId;
+            if (!spellId)
+                continue;
+
+            if (bot->HasAura(spellId))
+                return true;
+
+            Item* itemForSpell = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<Item*>("item for spell", spellId);
+            if (itemForSpell && itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                return true;
+
+            if (items.find(proto->SubClass) == items.end())
+                items[proto->SubClass] = list<Item*>();
+
+            items[proto->SubClass].push_back(item);
+            break;
+        }
+
+        return true;
+    }
+
+public:
+    map<uint32, list<Item*> > items;
+
+private:
+    Player* bot;
+};
+
+void BuffAction::TellHeader(uint32 subClass)
+{
+    switch (subClass)
+    {
+    case ITEM_SUBCLASS_ELIXIR:
+        ai->TellMaster("--- Elixir ---");
+        return;
+    case ITEM_SUBCLASS_FLASK:
+        ai->TellMaster("--- Flask ---");
+        return;
+    case ITEM_SUBCLASS_SCROLL:
+        ai->TellMaster("--- Scroll ---");
+        return;
+    case ITEM_SUBCLASS_FOOD:
+        ai->TellMaster("--- Food ---");
+        return;
+    case ITEM_SUBCLASS_GENERIC:
+        ai->TellMaster("--- Other ---");
+        return;
+    case ITEM_SUBCLASS_ITEM_ENHANCEMENT:
+        ai->TellMaster("--- Enchant ---");
+        return;
+    }
+}
+
+
+bool BuffAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    FindBuffVisitor visitor(bot);
+    IterateItems(&visitor);
+
+    uint32 oldSubClass = -1;
+    for (map<uint32, list<Item*> >::iterator i = visitor.items.begin(); i != visitor.items.end(); ++i)
+    {
+        list<Item*> items = i->second;
+
+        uint32 subClass = i->first;
+        if (oldSubClass != subClass)
+        {
+            if (!items.empty())
+                TellHeader(subClass);
+            oldSubClass = subClass;
+        }
+        for (list<Item*>::iterator j = items.begin(); j != items.end(); ++j)
+        {
+            Item* item = *j;
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate(), item->GetCount());
+            ai->TellMaster(out);
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.h b/src/plugins/playerbot/strategy/actions/BuffAction.h
new file mode 100644
index 0000000..da8b6a6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuffAction : public InventoryAction {
+    public:
+        BuffAction(PlayerbotAI* ai) : InventoryAction(ai, "buff") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellHeader(uint32 subClass);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.cpp b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
new file mode 100644
index 0000000..20d9cea
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuyAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool BuyAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(vendor->GetGUID(), UNIT_NPC_FLAG_VENDOR);
+    if (!pCreature)
+    {
+        ai->TellMaster("Cannot talk to vendor");
+        return false;
+    }
+
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+    if (!tItems)
+    {
+        ai->TellMaster("This vendor has no items");
+        return false;
+    }
+
+    for (ItemIds::iterator i = itemIds.begin(); i != itemIds.end(); i++)
+    {
+        for (uint32 slot = 0; slot < tItems->GetItemCount(); slot++)
+        {
+            if (tItems->GetItem(slot)->item == *i)
+            {
+                bot->BuyItemFromVendorSlot(vendor->GetGUID(), slot, *i, 1, NULL_BAG, NULL_SLOT);
+                ai->TellMaster("Bought item");
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.h b/src/plugins/playerbot/strategy/actions/BuyAction.h
new file mode 100644
index 0000000..2e0822c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuyAction : public InventoryAction {
+    public:
+        BuyAction(PlayerbotAI* ai) : InventoryAction(ai, "buy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(FindItemVisitor *visitor, int8 slot);
+        bool TradeItem(const Item& item, int8 slot);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
new file mode 100644
index 0000000..e59110e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
@@ -0,0 +1,48 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastCustomSpellAction.h"
+
+using namespace ai;
+
+bool CastCustomSpellAction::Execute(Event event)
+{
+    Unit* target = NULL;
+
+    Player* master = GetMaster();
+    if (master)
+        target = master->GetSelectedUnit();
+
+    if (!target)
+        target = bot;
+
+    string text = event.getParam();
+
+    uint32 spell = chat->parseSpell(text);
+
+    ostringstream msg;
+    if (!ai->CanCastSpell(spell, target))
+    {
+        msg << "Cannot cast " << text << " on " << target->GetName();
+        ai->TellMaster(msg.str());
+        return false;
+    }
+
+    bool result = false;
+    if (spell)
+        result = ai->CastSpell(spell, target);
+    else
+        ai->CastSpell(text, target);
+
+    if (result)
+    {
+        msg << "Casting " << text << " on " << target->GetName();
+        ai->TellMasterNoFacing(msg.str());
+    }
+    else
+    {
+        msg << "Cast " << text << " on " << target->GetName() << " is failed";
+        ai->TellMaster(msg.str());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
new file mode 100644
index 0000000..976a9e4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CastCustomSpellAction : public Action
+    {
+    public:
+        CastCustomSpellAction(PlayerbotAI* ai) : Action(ai, "cast custom spell") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
new file mode 100644
index 0000000..3c2187d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeChatAction.h"
+
+
+using namespace ai;
+
+
+bool ChangeChatAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ChatMsg parsed = chat->parseChat(text);
+    if (parsed == CHAT_MSG_SYSTEM)
+    {
+        ostringstream out; out << "Current chat is " << chat->formatChat(*context->GetValue<ChatMsg>("chat"));
+        ai->TellMaster(out);
+    }
+    else
+    {
+        context->GetValue<ChatMsg>("chat")->Set(parsed);
+        ostringstream out; out << "Chat set to " << chat->formatChat(parsed);
+        ai->TellMaster(out);
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.h b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
new file mode 100644
index 0000000..2d749c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ChangeChatAction : public Action {
+    public:
+        ChangeChatAction(PlayerbotAI* ai) : Action(ai, "chat") {}
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
new file mode 100644
index 0000000..64538cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeStrategyAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ChangeCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text.empty() ? getName() : text, BOT_STATE_COMBAT);
+    return true;
+}
+
+bool ChangeNonCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        if (text.find("loot") != string::npos || text.find("gather") != string::npos)
+        {
+            ai->TellMaster("You can change any strategy except loot and gather");
+            return false;
+        }
+    }
+
+    ai->ChangeStrategy(text, BOT_STATE_NON_COMBAT);
+    return true;
+}
+
+bool ChangeDeadStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text, BOT_STATE_DEAD);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
new file mode 100644
index 0000000..9c3f4c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeCombatStrategyAction : public Action {
+	public:
+		ChangeCombatStrategyAction(PlayerbotAI* ai, string name = "co") : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeNonCombatStrategyAction : public Action {
+    public:
+        ChangeNonCombatStrategyAction(PlayerbotAI* ai) : Action(ai, "nc") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeDeadStrategyAction : public Action {
+    public:
+        ChangeDeadStrategyAction(PlayerbotAI* ai) : Action(ai, "dead") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
new file mode 100644
index 0000000..8e1d34a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeTalentsAction.h"
+
+using namespace ai;
+
+bool ChangeTalentsAction::Execute(Event event)
+{
+
+
+    string text = event.getParam();
+    if (text == "1" || text == "primary")
+    {
+        bot->ActivateSpec(0);
+        ai->TellMaster("Primary talents activated");
+    }
+    else if (text == "2" || text == "secondary")
+    {
+        bot->ActivateSpec(1);
+        ai->TellMaster("Secondary talents activated");
+    }
+    else
+    {
+        ostringstream out;
+        switch (bot->GetActiveSpec())
+        {
+        case 0: out << "Primary";
+            break;
+        default: out << "Secondary";
+            break;
+        }
+        out << " talents are active";
+        ai->TellMaster(out);
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
new file mode 100644
index 0000000..dd9941a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeTalentsAction : public Action {
+	public:
+		ChangeTalentsAction(PlayerbotAI* ai) : Action(ai, "talents") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChatActionContext.h b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
new file mode 100644
index 0000000..6a0ab6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
@@ -0,0 +1,184 @@
+#pragma once
+
+#include "ListQuestsActions.h"
+#include "StatsAction.h"
+#include "LeaveGroupAction.h"
+#include "TellReputationAction.h"
+#include "LogLevelAction.h"
+#include "TellLosAction.h"
+#include "DropQuestAction.h"
+#include "QueryQuestAction.h"
+#include "QueryItemUsageAction.h"
+#include "LootStrategyAction.h"
+#include "AddLootAction.h"
+#include "ReleaseSpiritAction.h"
+#include "TeleportAction.h"
+#include "TaxiAction.h"
+#include "RepairAllAction.h"
+#include "UseItemAction.h"
+#include "TellItemCountAction.h"
+#include "RewardAction.h"
+#include "BuyAction.h"
+#include "SellAction.h"
+#include "UnequipAction.h"
+#include "EquipAction.h"
+#include "TradeAction.h"
+#include "ChangeTalentsAction.h"
+#include "ListSpellsAction.h"
+#include "ChangeStrategyAction.h"
+#include "TrainerAction.h"
+#include "ChangeChatAction.h"
+#include "SetHomeAction.h"
+#include "ResetAiAction.h"
+#include "DestroyItemAction.h"
+#include "BuffAction.h"
+#include "AttackAction.h"
+#include "HelpAction.h"
+#include "GuildBankAction.h"
+#include "ChatShortcutActions.h"
+#include "GossipHelloAction.h"
+#include "CastCustomSpellAction.h"
+#include "InviteToGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "RtiAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "BankAction.h"
+#include "PositionAction.h"
+#include "TellTargetAction.h"
+#include "UseMeetingStoneAction.h"
+#include "WhoAction.h"
+#include "SaveManaAction.h"
+#include "../values/Formations.h"
+
+namespace ai
+{
+    class ChatActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ChatActionContext()
+        {
+            creators["stats"] = &ChatActionContext::stats;
+            creators["quests"] = &ChatActionContext::quests;
+            creators["leave"] = &ChatActionContext::leave;
+            creators["reputation"] = &ChatActionContext::reputation;
+            creators["log"] = &ChatActionContext::log;
+            creators["los"] = &ChatActionContext::los;
+            creators["drop"] = &ChatActionContext::drop;
+            creators["query quest"] = &ChatActionContext::query_quest;
+            creators["query item usage"] = &ChatActionContext::query_item_usage;
+            creators["ll"] = &ChatActionContext::ll;
+            creators["add all loot"] = &ChatActionContext::add_all_loot;
+            creators["release"] = &ChatActionContext::release;
+            creators["teleport"] = &ChatActionContext::teleport;
+            creators["taxi"] = &ChatActionContext::taxi;
+            creators["repair"] = &ChatActionContext::repair;
+            creators["use"] = &ChatActionContext::use;
+            creators["item count"] = &ChatActionContext::item_count;
+            creators["equip"] = &ChatActionContext::equip;
+            creators["unequip"] = &ChatActionContext::unequip;
+            creators["sell"] = &ChatActionContext::sell;
+            creators["buy"] = &ChatActionContext::buy;
+            creators["reward"] = &ChatActionContext::reward;
+            creators["trade"] = &ChatActionContext::trade;
+            creators["talents"] = &ChatActionContext::talents;
+            creators["spells"] = &ChatActionContext::spells;
+            creators["co"] = &ChatActionContext::co;
+            creators["nc"] = &ChatActionContext::nc;
+            creators["dead"] = &ChatActionContext::dead;
+            creators["trainer"] = &ChatActionContext::trainer;
+            creators["attack my target"] = &ChatActionContext::attack_my_target;
+            creators["chat"] = &ChatActionContext::chat;
+            creators["home"] = &ChatActionContext::home;
+            creators["destroy"] = &ChatActionContext::destroy;
+            creators["reset ai"] = &ChatActionContext::reset_ai;
+            creators["buff"] = &ChatActionContext::buff;
+            creators["help"] = &ChatActionContext::help;
+            creators["gb"] = &ChatActionContext::gb;
+            creators["bank"] = &ChatActionContext::bank;
+            creators["follow chat shortcut"] = &ChatActionContext::follow_chat_shortcut;
+            creators["stay chat shortcut"] = &ChatActionContext::stay_chat_shortcut;
+            creators["flee chat shortcut"] = &ChatActionContext::flee_chat_shortcut;
+            creators["runaway chat shortcut"] = &ChatActionContext::runaway_chat_shortcut;
+            creators["grind chat shortcut"] = &ChatActionContext::grind_chat_shortcut;
+            creators["tank attack chat shortcut"] = &ChatActionContext::tank_attack_chat_shortcut;
+            creators["gossip hello"] = &ChatActionContext::gossip_hello;
+            creators["cast custom spell"] = &ChatActionContext::cast_custom_spell;
+            creators["invite"] = &ChatActionContext::invite;
+            creators["spell"] = &ChatActionContext::spell;
+            creators["rti"] = &ChatActionContext::rti;
+            creators["spirit healer"] = &ChatActionContext::spirit_healer;
+            creators["position"] = &ChatActionContext::position;
+            creators["tell target"] = &ChatActionContext::tell_target;
+            creators["summon"] = &ChatActionContext::summon;
+            creators["who"] = &ChatActionContext::who;
+            creators["save mana"] = &ChatActionContext::save_mana;
+            creators["max dps chat shortcut"] = &ChatActionContext::max_dps_chat_shortcut;
+            creators["tell attackers"] = &ChatActionContext::tell_attackers;
+            creators["formation"] = &ChatActionContext::formation;
+        }
+
+    private:
+        static Action* formation(PlayerbotAI* ai) { return new SetFormationAction(ai); }
+        static Action* tell_attackers(PlayerbotAI* ai) { return new TellAttackersAction(ai); }
+        static Action* max_dps_chat_shortcut(PlayerbotAI* ai) { return new MaxDpsChatShortcutAction(ai); }
+        static Action* save_mana(PlayerbotAI* ai) { return new SaveManaAction(ai); }
+        static Action* who(PlayerbotAI* ai) { return new WhoAction(ai); }
+        static Action* summon(PlayerbotAI* ai) { return new SummonAction(ai); }
+        static Action* tell_target(PlayerbotAI* ai) { return new TellTargetAction(ai); }
+        static Action* position(PlayerbotAI* ai) { return new PositionAction(ai); }
+        static Action* spirit_healer(PlayerbotAI* ai) { return new SpiritHealerAction(ai); }
+        static Action* rti(PlayerbotAI* ai) { return new RtiAction(ai); }
+        static Action* invite(PlayerbotAI* ai) { return new InviteToGroupAction(ai); }
+        static Action* spell(PlayerbotAI* ai) { return new TellSpellAction(ai); }
+        static Action* cast_custom_spell(PlayerbotAI* ai) { return new CastCustomSpellAction(ai); }
+        static Action* tank_attack_chat_shortcut(PlayerbotAI* ai) { return new TankAttackChatShortcutAction(ai); }
+        static Action* grind_chat_shortcut(PlayerbotAI* ai) { return new GrindChatShortcutAction(ai); }
+        static Action* flee_chat_shortcut(PlayerbotAI* ai) { return new FleeChatShortcutAction(ai); }
+        static Action* runaway_chat_shortcut(PlayerbotAI* ai) { return new GoawayChatShortcutAction(ai); }
+        static Action* stay_chat_shortcut(PlayerbotAI* ai) { return new StayChatShortcutAction(ai); }
+        static Action* follow_chat_shortcut(PlayerbotAI* ai) { return new FollowChatShortcutAction(ai); }
+        static Action* gb(PlayerbotAI* ai) { return new GuildBankAction(ai); }
+        static Action* bank(PlayerbotAI* ai) { return new BankAction(ai); }
+        static Action* help(PlayerbotAI* ai) { return new HelpAction(ai); }
+        static Action* buff(PlayerbotAI* ai) { return new BuffAction(ai); }
+        static Action* destroy(PlayerbotAI* ai) { return new DestroyItemAction(ai); }
+        static Action* home(PlayerbotAI* ai) { return new SetHomeAction(ai); }
+        static Action* chat(PlayerbotAI* ai) { return new ChangeChatAction(ai); }
+        static Action* attack_my_target(PlayerbotAI* ai) { return new AttackMyTargetAction(ai); }
+        static Action* trainer(PlayerbotAI* ai) { return new TrainerAction(ai); }
+        static Action* co(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai); }
+        static Action* nc(PlayerbotAI* ai) { return new ChangeNonCombatStrategyAction(ai); }
+        static Action* dead(PlayerbotAI* ai) { return new ChangeDeadStrategyAction(ai); }
+        static Action* spells(PlayerbotAI* ai) { return new ListSpellsAction(ai); }
+        static Action* talents(PlayerbotAI* ai) { return new ChangeTalentsAction(ai); }
+
+        static Action* equip(PlayerbotAI* ai) { return new EquipAction(ai); }
+        static Action* unequip(PlayerbotAI* ai) { return new UnequipAction(ai); }
+        static Action* sell(PlayerbotAI* ai) { return new SellAction(ai); }
+        static Action* buy(PlayerbotAI* ai) { return new BuyAction(ai); }
+        static Action* reward(PlayerbotAI* ai) { return new RewardAction(ai); }
+        static Action* trade(PlayerbotAI* ai) { return new TradeAction(ai); }
+
+        static Action* item_count(PlayerbotAI* ai) { return new TellItemCountAction(ai); }
+        static Action* use(PlayerbotAI* ai) { return new UseItemAction(ai); }
+        static Action* repair(PlayerbotAI* ai) { return new RepairAllAction(ai); }
+        static Action* taxi(PlayerbotAI* ai) { return new TaxiAction(ai); }
+        static Action* teleport(PlayerbotAI* ai) { return new TeleportAction(ai); }
+        static Action* release(PlayerbotAI* ai) { return new ReleaseSpiritAction(ai); }
+        static Action* query_item_usage(PlayerbotAI* ai) { return new QueryItemUsageAction(ai); }
+        static Action* query_quest(PlayerbotAI* ai) { return new QueryQuestAction(ai); }
+        static Action* drop(PlayerbotAI* ai) { return new DropQuestAction(ai); }
+        static Action* stats(PlayerbotAI* ai) { return new StatsAction(ai); }
+        static Action* quests(PlayerbotAI* ai) { return new ListQuestsAction(ai); }
+        static Action* leave(PlayerbotAI* ai) { return new LeaveGroupAction(ai); }
+        static Action* reputation(PlayerbotAI* ai) { return new TellReputationAction(ai); }
+        static Action* log(PlayerbotAI* ai) { return new LogLevelAction(ai); }
+        static Action* los(PlayerbotAI* ai) { return new TellLosAction(ai); }
+        static Action* ll(PlayerbotAI* ai) { return new LootStrategyAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* reset_ai(PlayerbotAI* ai) { return new ResetAiAction(ai); }
+        static Action* gossip_hello(PlayerbotAI* ai) { return new GossipHelloAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
new file mode 100644
index 0000000..e0c3f12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
@@ -0,0 +1,108 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatShortcutActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool FollowChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not follow you - too far away");
+        return true;
+    }
+    ai->TellMaster("Following");
+    return true;
+}
+
+bool StayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+stay,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Staying");
+    return true;
+}
+
+bool FleeChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not flee with you - too far away");
+        return true;
+    }
+    ai->TellMaster("Fleeing");
+    return true;
+}
+
+bool GoawayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+runaway", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+runaway", BOT_STATE_COMBAT);
+    ai->TellMaster("Running away");
+    return true;
+}
+
+bool GrindChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+grind,-passive", BOT_STATE_NON_COMBAT);
+    ai->TellMaster("Grinding");
+    return true;
+}
+
+bool TankAttackChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!ai->IsTank(bot))
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Attacking");
+    return true;
+}
+
+bool MaxDpsChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-threat,-conserve mana,-cast time,+dps debuff", BOT_STATE_COMBAT);
+    ai->TellMaster("Max DPS");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
new file mode 100644
index 0000000..de9a86a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class FollowChatShortcutAction : public Action
+    {
+    public:
+        FollowChatShortcutAction(PlayerbotAI* ai) : Action(ai, "follow chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class StayChatShortcutAction : public Action
+    {
+    public:
+        StayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "stay chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class FleeChatShortcutAction : public Action
+    {
+    public:
+        FleeChatShortcutAction(PlayerbotAI* ai) : Action(ai, "flee chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GoawayChatShortcutAction : public Action
+    {
+    public:
+        GoawayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "runaway chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GrindChatShortcutAction : public Action
+    {
+    public:
+        GrindChatShortcutAction(PlayerbotAI* ai) : Action(ai, "grind chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TankAttackChatShortcutAction : public Action
+    {
+    public:
+        TankAttackChatShortcutAction(PlayerbotAI* ai) : Action(ai, "tank attack chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MaxDpsChatShortcutAction : public Action
+    {
+    public:
+        MaxDpsChatShortcutAction(PlayerbotAI* ai) : Action(ai, "max dps chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
new file mode 100644
index 0000000..c5aa48f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CheckMailAction.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+bool CheckMailAction::Execute(Event event)
+{
+    if (!bot->IsMailsLoaded())
+    {
+        WorldPacket p;
+        bot->GetSession()->HandleQueryNextMailTime(p);
+    }
+
+    if (!bot->GetMailSize())
+        return false;
+
+    list<uint32> ids;
+    for (PlayerMails::iterator i = bot->GetMailBegin(); i != bot->GetMailEnd(); ++i)
+    {
+        Mail* mail = *i;
+
+        if (!mail || mail->state == MAIL_STATE_DELETED)
+            continue;
+
+        Player* owner = sObjectMgr->GetPlayerByLowGUID(mail->sender);
+        if (!owner)
+            continue;
+
+        ProcessMail(mail, owner);
+        ids.push_back(mail->messageID);
+        mail->state = MAIL_STATE_DELETED;
+    }
+
+    for (list<uint32>::iterator i = ids.begin(); i != ids.end(); ++i)
+    {
+        uint32 id = *i;
+        bot->SendMailResult(id, MAIL_DELETED, MAIL_OK);
+        SQLTransaction tran = CharacterDatabase.BeginTransaction();
+        CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", id);
+        CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", id);
+        CharacterDatabase.CommitTransaction(tran);
+        bot->RemoveMail(id);
+    }
+
+    return true;
+}
+
+
+void CheckMailAction::ProcessMail(Mail* mail, Player* owner)
+{
+    if (!mail->HasItems())
+        return;
+
+    for (MailItemInfoVec::iterator i = mail->items.begin(); i != mail->items.end(); ++i)
+    {
+        Item *item = bot->GetMItem(i->item_guid);
+        if (!item)
+            continue;
+
+        sGuildTaskMgr.CheckItemTask(i->item_template, item->GetCount(), owner, bot, true);
+        bot->RemoveMItem(i->item_guid);
+        item->DestroyForPlayer(bot);
+    }
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.h b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
new file mode 100644
index 0000000..9da88a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CheckMailAction : public Action
+    {
+    public:
+        CheckMailAction(PlayerbotAI* ai) : Action(ai, "check mail") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ProcessMail(Mail* mail, Player* owner);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
new file mode 100644
index 0000000..3c94f97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
@@ -0,0 +1,79 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../../Spells/Auras/SpellAuraEffects.h"
+#include "CheckMountStateAction.h"
+
+using namespace ai;
+
+uint64 extractGuid(WorldPacket& packet);
+
+bool CheckMountStateAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!bot->GetGroup() || !master)
+        return false;
+
+    if (bot->IsFlying())
+        return false;
+
+    if (master->IsMounted() && !bot->IsMounted())
+    {
+        return Mount();
+    }
+    else if (!master->IsMounted() && bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+        return true;
+    }
+    return false;
+}
+
+
+bool CheckMountStateAction::Mount()
+{
+    Player* master = GetMaster();
+    ai->RemoveShapeshift();
+
+    Unit::AuraEffectList const& auras = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    const SpellInfo* masterSpell = auras.front()->GetSpellInfo();
+    int32 masterSpeed = max(masterSpell->Effects[1].BasePoints, masterSpell->Effects[2].BasePoints);
+
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < masterSpeed)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    int masterMountType = (masterSpell->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+            masterSpell->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+
+    map<int32, vector<uint32> >& spells = allSpells[masterMountType];
+    for (map<int32,vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+		vector<uint32>& ids = i->second;
+        int index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        ai->CastSpell(ids[index], bot);
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
new file mode 100644
index 0000000..c5b087e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class CheckMountStateAction : public Action {
+    public:
+        CheckMountStateAction(PlayerbotAI* ai) : Action(ai, "check mount state") {}
+
+        virtual bool Execute(Event event);
+
+    private:
+        bool Mount();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
new file mode 100644
index 0000000..d0b1a9a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
@@ -0,0 +1,80 @@
+#pragma once
+
+#include "../Action.h"
+#include "AttackAction.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+
+namespace ai
+{
+    class DpsAssistAction : public AttackAction
+    {
+    public:
+        DpsAssistAction(PlayerbotAI* ai) : AttackAction(ai, "dps assist") {}
+
+        virtual string GetTargetName() { return "dps target"; }
+    };
+
+    class TankAssistAction : public AttackAction
+    {
+    public:
+        TankAssistAction(PlayerbotAI* ai) : AttackAction(ai, "tank assist") {}
+        virtual string GetTargetName() { return "tank target"; }
+    };
+
+    class AttackAnythingAction : public AttackAction
+    {
+    public:
+        AttackAnythingAction(PlayerbotAI* ai) : AttackAction(ai, "attack anything") {}
+        virtual string GetTargetName() { return "grind target"; }
+        virtual bool Execute(Event event)
+        {
+            return AttackAction::Execute(event);
+        }
+        virtual bool isUseful() {
+            return GetTarget() &&
+                (AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana)) || AI_VALUE2(bool, "combat", "self target");
+        }
+        virtual bool isPossible()
+        {
+            return AttackAction::isPossible() && GetTarget();
+        }
+    };
+
+    class AttackLeastHpTargetAction : public AttackAction
+    {
+    public:
+        AttackLeastHpTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack least hp target") {}
+        virtual string GetTargetName() { return "least hp target"; }
+    };
+
+    class AttackEnemyPlayerAction : public AttackAction
+    {
+    public:
+        AttackEnemyPlayerAction(PlayerbotAI* ai) : AttackAction(ai, "attack enemy player") {}
+        virtual string GetTargetName() { return "enemy player target"; }
+    };
+
+    class AttackRtiTargetAction : public AttackAction
+    {
+    public:
+        AttackRtiTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack rti target") {}
+        virtual string GetTargetName() { return "rti target"; }
+    };
+
+    class DropTargetAction : public Action
+    {
+    public:
+        DropTargetAction(PlayerbotAI* ai) : Action(ai, "drop target") {}
+
+        virtual bool Execute(Event event)
+        {
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid());
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            ai->InterruptSpell();
+			return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
new file mode 100644
index 0000000..9167182
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DestroyItemAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool DestroyItemAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        DestroyItem(&visitor);
+    }
+
+    return true;
+}
+
+void DestroyItemAction::DestroyItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+		Item* item = *i;
+        bot->DestroyItem(item->GetBagSlot(),item->GetSlot(), true);
+        ostringstream out; out << chat->formatItem(item->GetTemplate()) << " destroyed";
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.h b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
new file mode 100644
index 0000000..ad1ab05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class DestroyItemAction : public InventoryAction {
+    public:
+        DestroyItemAction(PlayerbotAI* ai) : InventoryAction(ai, "destroy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void DestroyItem(FindItemVisitor* visitor);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
new file mode 100644
index 0000000..e94e779
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DropQuestAction.h"
+
+
+using namespace ai;
+
+bool DropQuestAction::Execute(Event event)
+{
+    string link = event.getParam();
+    if (!GetMaster())
+        return false;
+
+    PlayerbotChatHandler handler(GetMaster());
+    uint32 entry = handler.extractQuestId(link);
+    if (!entry)
+        return false;
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+    if (!quest)
+        return false;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 logQuest = bot->GetQuestSlotQuestId(slot);
+        if (logQuest == entry)
+        {
+            bot->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            bot->TakeQuestSourceItem(logQuest, false);
+
+            if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
+            {
+                bot->pvpInfo.IsHostile = bot->pvpInfo.IsInHostileArea || bot->HasPvPForcingQuest();
+                bot->UpdatePvPState();
+            }
+        }
+    }
+
+    bot->RemoveActiveQuest(entry, false);
+    bot->RemoveRewardedQuest(entry);
+
+    ai->TellMaster("Quest removed");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.h b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
new file mode 100644
index 0000000..af5d4ca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class DropQuestAction : public Action {
+    public:
+        DropQuestAction(PlayerbotAI* ai) : Action(ai, "drop quest") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.cpp b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
new file mode 100644
index 0000000..f345629
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
@@ -0,0 +1,104 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteAction.h"
+
+using namespace ai;
+
+map<string, uint32> EmoteAction::emotes;
+
+bool EmoteAction::Execute(Event event)
+{
+    if (emotes.empty())
+        InitEmotes();
+
+    // FEYZEE: disable bot emotes
+    return true;
+/*
+    uint32 emote = 0;
+
+    string param = event.getParam();
+	if (param.empty() || emotes.find(param) == emotes.end())
+    {
+        int index = rand() % emotes.size();
+		for (map<string, uint32>::iterator i = emotes.begin(); i != emotes.end() && index; ++i, --index)
+			emote = i->second;
+    }
+    else
+    {
+        emote = emotes[param];
+    }
+
+	bot->CastStop();
+	ai->InterruptSpell();
+	bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Player* master = GetMaster();
+	if (master)
+	{
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            Unit* oldSelection = bot->GetSelectedUnit();
+            bot->SetSelection(masterSelection->GetGUID());
+            bot->HandleEmoteCommand(emote);
+            if (oldSelection)
+                bot->SetSelection(oldSelection->GetGUID());
+            return true;
+        }
+	}
+
+    bot->HandleEmoteCommand(emote);
+    return true;
+*/
+}
+
+void EmoteAction::InitEmotes()
+{
+    emotes["cower"] = EMOTE_ONESHOT_COWER;
+    emotes["dance"] = EMOTE_ONESHOT_DANCE;
+    emotes["drown"] = EMOTE_ONESHOT_DROWN;
+    emotes["emerge"] = EMOTE_ONESHOT_EMERGE;
+    emotes["land"] = EMOTE_ONESHOT_LAND;
+    emotes["laugh_nosheathe"] = EMOTE_ONESHOT_LAUGH_NO_SHEATHE;
+    emotes["liftoff"] = EMOTE_ONESHOT_LIFTOFF;
+    emotes["loot"] = EMOTE_ONESHOT_LOOT;
+    emotes["no"] = EMOTE_ONESHOT_NO;
+    emotes["one_shot_stun"] = EMOTE_ONESHOT_STUN;
+    emotes["point_nosheathe"] = EMOTE_ONESHOT_POINT_NO_SHEATHE;
+    emotes["roar"] = EMOTE_STATE_ROAR;
+    emotes["salute"] = EMOTE_ONESHOT_SALUTE;
+    emotes["stomp"] = EMOTE_ONESHOT_STOMP;
+    emotes["train"] = EMOTE_ONESHOT_TRAIN;
+    emotes["yes"] = EMOTE_ONESHOT_YES;
+    emotes["applaud"] = EMOTE_ONESHOT_APPLAUD;
+    emotes["battleroar"] = EMOTE_ONESHOT_BATTLE_ROAR;
+    emotes["beg"] = EMOTE_ONESHOT_BEG;
+    emotes["bow"] = EMOTE_ONESHOT_BOW;
+    emotes["cheer"] = EMOTE_ONESHOT_CHEER;
+    emotes["chicken"] = EMOTE_ONESHOT_CHICKEN;
+    emotes["cry"] = EMOTE_ONESHOT_CRY;
+    emotes["dance"] = EMOTE_STATE_DANCE;
+    emotes["eat"] = EMOTE_ONESHOT_EAT;
+    emotes["exclamation"] = EMOTE_ONESHOT_EXCLAMATION;
+    emotes["flex"] = EMOTE_ONESHOT_FLEX;
+    emotes["kick"] = EMOTE_ONESHOT_KICK;
+    emotes["kiss"] = EMOTE_ONESHOT_KISS;
+    emotes["kneel"] = EMOTE_ONESHOT_KNEEL;
+    emotes["laugh"] = EMOTE_ONESHOT_LAUGH;
+    emotes["parryshield"] = EMOTE_ONESHOT_PARRY_SHIELD;
+    emotes["parryunarmed"] = EMOTE_ONESHOT_PARRY_UNARMED;
+    emotes["point"] = EMOTE_ONESHOT_POINT;
+    emotes["question"] = EMOTE_ONESHOT_QUESTION;
+    emotes["ready1h"] = EMOTE_ONESHOT_READY1H;
+    emotes["readybow"] = EMOTE_ONESHOT_READY_BOW;
+    emotes["readyunarmed"] = EMOTE_ONESHOT_READY_UNARMED;
+    emotes["roar"] = EMOTE_ONESHOT_ROAR;
+    emotes["rude"] = EMOTE_ONESHOT_RUDE;
+    emotes["shout"] = EMOTE_ONESHOT_SHOUT;
+    emotes["shy"] = EMOTE_ONESHOT_SHY;
+    emotes["sleep"] = EMOTE_STATE_SLEEP;
+    emotes["talk"] = EMOTE_ONESHOT_TALK;
+    emotes["wave"] = EMOTE_ONESHOT_WAVE;
+    emotes["woundcritical"] = EMOTE_ONESHOT_WOUND_CRITICAL;
+    emotes["wound"] = EMOTE_ONESHOT_WOUND;
+}
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.h b/src/plugins/playerbot/strategy/actions/EmoteAction.h
new file mode 100644
index 0000000..8aa8fda
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class EmoteAction : public Action
+    {
+    public:
+        EmoteAction(PlayerbotAI* ai) : Action(ai, "emote") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void InitEmotes();
+        static map<string, uint32> emotes;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.cpp b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
new file mode 100644
index 0000000..1f8de55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
@@ -0,0 +1,105 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EquipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool EquipAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text == "?")
+    {
+        TellEquipmentSets();
+        return true;
+    }
+
+    if (UseEquipmentSet(text))
+        return true;
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        EquipItem(&visitor);
+    }
+
+    return true;
+}
+
+bool EquipAction::UseEquipmentSet(string& name)
+{
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state == EQUIPMENT_SET_DELETED || i->second.Name != name)
+            continue;
+
+        UseEquipmentSet(i->second);
+
+        ostringstream out; out << name << " set equipped";
+        ai->TellMaster(out);
+        return true;
+    }
+    return false;
+}
+
+bool EquipAction::UseEquipmentSet(EquipmentSet& set)
+{
+    WorldPacket* p = new WorldPacket(CMSG_EQUIPMENT_SET_USE);
+    uint8 srcbag = 0;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        ObjectGuid guid;
+        uint32 itemId = set.Items[slot];
+        if (set.IgnoreMask & (1 << slot))
+            p->appendPackGUID((uint64(1)));
+        else
+            p->appendPackGUID(itemId);
+        *p << srcbag << slot;
+    }
+    bot->GetSession()->QueuePacket(p);
+    return true;
+}
+
+void EquipAction::TellEquipmentSets()
+{
+    ai->TellMaster("=== Equipment sets ===");
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state != EQUIPMENT_SET_DELETED)
+            ai->TellMaster(i->second.Name);
+    }
+}
+
+void EquipAction::EquipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) EquipItem(**items.begin());
+}
+
+
+void EquipAction::EquipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint32 itemId = item.GetTemplate()->ItemId;
+
+    if (item.GetTemplate()->InventoryType == INVTYPE_AMMO)
+    {
+        bot->SetAmmo(itemId);
+    }
+    else
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+            *packet << bagIndex << slot;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    ostringstream out; out << "equipping " << chat->formatItem(item.GetTemplate());
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.h b/src/plugins/playerbot/strategy/actions/EquipAction.h
new file mode 100644
index 0000000..d23223c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class EquipAction : public InventoryAction {
+    public:
+        EquipAction(PlayerbotAI* ai) : InventoryAction(ai, "equip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void EquipItem(FindItemVisitor* visitor);
+        void EquipItem(Item& item);
+        void TellEquipmentSets();
+        bool UseEquipmentSet(string& name);
+        bool UseEquipmentSet(EquipmentSet& set);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.cpp b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
new file mode 100644
index 0000000..dfa115f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowActions.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../values/Formations.h"
+
+using namespace ai;
+
+bool FollowAction::Execute(Event event)
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    string target = formation->GetTargetName();
+    if (!target.empty())
+    {
+        return Follow(AI_VALUE(Unit*, target));
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || loc.GetMapId() == -1)
+            return false;
+
+        return MoveTo(loc.GetMapId(), loc.m_positionX, loc.m_positionY, loc.m_positionZ);
+    }
+}
+
+bool FollowAction::isUseful()
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    float distance = 0;
+    string target = formation->GetTargetName();
+
+    if (!target.empty())
+    {
+        distance = AI_VALUE2(float, "distance", target);
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || bot->GetMapId() != loc.GetMapId())
+            return false;
+
+        distance = bot->GetDistance(loc);
+    }
+
+    return distance > formation->GetMaxDistance() &&
+            !AI_VALUE(bool, "can loot");
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.h b/src/plugins/playerbot/strategy/actions/FollowActions.h
new file mode 100644
index 0000000..971ca99
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class FollowAction : public MovementAction {
+	public:
+		FollowAction(PlayerbotAI* ai) : MovementAction(ai, "follow") {}
+		virtual bool Execute(Event event);
+        virtual bool isUseful();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.cpp b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
new file mode 100644
index 0000000..22285f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.h b/src/plugins/playerbot/strategy/actions/GenericActions.h
new file mode 100644
index 0000000..d728175
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "GenericSpellActions.h"
+#include "ReachTargetActions.h"
+#include "ChooseTargetActions.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class MeleeAction : public AttackAction
+    {
+    public:
+        MeleeAction(PlayerbotAI* ai) : AttackAction(ai, "melee") {}
+
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
new file mode 100644
index 0000000..2500126
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
+
+bool CastSpellAction::Execute(Event event)
+{
+	return ai->CastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isPossible()
+{
+    if (AI_VALUE2(float, "distance", GetTargetName()) > range)
+        return false;
+
+	return ai->CanCastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isUseful()
+{
+	return GetTarget() && AI_VALUE2(bool, "spell cast useful", spell);
+}
+
+bool CastAuraSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+}
+
+bool CastEnchantItemAction::isUseful()
+{
+    if (!CastSpellAction::isUseful())
+        return false;
+
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+bool CastHealingSpellAction::isUseful()
+{
+	return CastAuraSpellAction::isUseful() && AI_VALUE2(uint8, "health", GetTargetName()) < (100 - estAmount);
+}
+
+bool CastAoeHealSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && AI_VALUE2(uint8, "aoe heal", "medium") > 0;
+}
+
+
+Value<Unit*>* CurePartyMemberAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
+
+Value<Unit*>* BuffOnPartyAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member without aura", spell);
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.h b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
new file mode 100644
index 0000000..e286a17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
@@ -0,0 +1,271 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BEGIN_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+
+#define END_SPELL_ACTION() \
+    };
+
+#define BEGIN_DEBUFF_ACTION(clazz, name) \
+class clazz : public CastDebuffSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastDebuffSpellAction(ai, name) {} \
+
+#define BEGIN_RANGED_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+#define BEGIN_MELEE_SPELL_ACTION(clazz, name) \
+class clazz : public CastMeleeSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastMeleeSpellAction(ai, name) {} \
+
+
+#define END_RANGED_SPELL_ACTION() \
+    };
+
+
+#define BEGIN_BUFF_ON_PARTY_ACTION(clazz, name) \
+class clazz : public BuffOnPartyAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyAction(ai, name) {}
+
+namespace ai
+{
+    class CastSpellAction : public Action
+    {
+    public:
+        CastSpellAction(PlayerbotAI* ai, string spell) : Action(ai, spell),
+			range(sPlayerbotAIConfig.spellDistance)
+        {
+            this->spell = spell;
+        }
+
+		virtual string GetTargetName() { return "current target"; };
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+		virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_SINGLE; }
+
+		virtual NextAction** getPrerequisites()
+		{
+			if (range > sPlayerbotAIConfig.spellDistance)
+				return NULL;
+			else if (range > ATTACK_DISTANCE)
+				return NextAction::merge( NextAction::array(0, new NextAction("reach spell"), NULL), Action::getPrerequisites());
+			else
+				return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), Action::getPrerequisites());
+		}
+
+    protected:
+        string spell;
+		float range;
+    };
+
+	//---------------------------------------------------------------------------------------------------------------------
+	class CastAuraSpellAction : public CastSpellAction
+	{
+	public:
+		CastAuraSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual bool isUseful();
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastMeleeSpellAction : public CastSpellAction
+    {
+    public:
+        CastMeleeSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {
+			range = ATTACK_DISTANCE;
+		}
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastDebuffSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+    };
+
+    class CastDebuffSpellOnAttackerAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellOnAttackerAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("attacker without aura", spell);
+        }
+        virtual string getName() { return spell + " on attacker"; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+    };
+
+	class CastBuffSpellAction : public CastAuraSpellAction
+	{
+	public:
+		CastBuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastEnchantItemAction : public CastSpellAction
+	{
+	public:
+	    CastEnchantItemAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual bool isUseful();
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastHealingSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastHealingSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastAuraSpellAction(ai, spell)
+		{
+            this->estAmount = estAmount;
+			range = sPlayerbotAIConfig.spellDistance;
+        }
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+
+    protected:
+        uint8 estAmount;
+    };
+
+    class CastAoeHealSpellAction : public CastHealingSpellAction
+    {
+    public:
+    	CastAoeHealSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastHealingSpellAction(ai, spell, estAmount) {}
+		virtual string GetTargetName() { return "party member to heal"; }
+        virtual bool isUseful();
+    };
+
+	class CastCureSpellAction : public CastSpellAction
+	{
+	public:
+		CastCureSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class PartyMemberActionNameSupport {
+	public:
+		PartyMemberActionNameSupport(string spell)
+		{
+			name = string(spell) + " on party";
+		}
+
+		virtual string getName() { return name; }
+
+	private:
+		string name;
+	};
+
+    class HealPartyMemberAction : public CastHealingSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        HealPartyMemberAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) :
+			CastHealingSpellAction(ai, spell, estAmount), PartyMemberActionNameSupport(spell) {}
+
+		virtual string GetTargetName() { return "party member to heal"; }
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+	class ResurrectPartyMemberAction : public CastSpellAction
+	{
+	public:
+		ResurrectPartyMemberAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual string GetTargetName() { return "party member to resurrect"; }
+	};
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CurePartyMemberAction : public CastSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        CurePartyMemberAction(PlayerbotAI* ai, string spell, uint32 dispelType) :
+			CastSpellAction(ai, spell), PartyMemberActionNameSupport(spell)
+        {
+            this->dispelType = dispelType;
+        }
+
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+
+    protected:
+        uint32 dispelType;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class BuffOnPartyAction : public CastBuffSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        BuffOnPartyAction(PlayerbotAI* ai, string spell) :
+			CastBuffSpellAction(ai, spell), PartyMemberActionNameSupport(spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastShootAction : public CastSpellAction
+    {
+    public:
+        CastShootAction(PlayerbotAI* ai) : CastSpellAction(ai, "shoot") {}
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+    };
+
+	class CastLifeBloodAction : public CastHealingSpellAction
+	{
+	public:
+		CastLifeBloodAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lifeblood") {}
+	};
+
+	class CastGiftOfTheNaaruAction : public CastHealingSpellAction
+	{
+	public:
+		CastGiftOfTheNaaruAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "gift of the naaru") {}
+	};
+
+    class CastArcaneTorrentAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneTorrentAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane torrent") {}
+    };
+
+    class CastSpellOnEnemyHealerAction : public CastSpellAction
+    {
+    public:
+        CastSpellOnEnemyHealerAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("enemy healer target", spell);
+        }
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
new file mode 100644
index 0000000..c5000cd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GossipHelloAction.h"
+
+
+using namespace ai;
+
+bool GossipHelloAction::Execute(Event event)
+{
+    ObjectGuid guid;
+
+    WorldPacket &p = event.getPacket();
+    if (p.empty())
+    {
+        Player* master = GetMaster();
+        if (master && master->GetSelectedUnit())
+            guid = master->GetSelectedUnit()->GetGUID();
+    }
+    else
+    {
+        p.rpos(0);
+        p >> guid;
+    }
+
+    if (!guid)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+    if (!pCreature)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %d not found or you can't interact with him.", guid.GetRawValue());
+        return false;
+    }
+
+    GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+    if (pMenuItemBounds.first == pMenuItemBounds.second)
+        return false;
+
+    WorldPacket p1;
+    p1 << guid;
+    bot->GetSession()->HandleGossipHelloOpcode(p1);
+    bot->SetFacingToObject(pCreature);
+
+    ostringstream out; out << "--- " << pCreature->GetName() << " ---";
+    ai->TellMasterNoFacing(out.str());
+
+    GossipMenu& menu = bot->PlayerTalkClass->GetGossipMenu();
+    int i = 0, loops = 0;
+    set<uint32> alreadyTalked;
+    while (i < menu.GetMenuItemCount() && loops++ < 100)
+    {
+        GossipMenuItem const* item = menu.GetItem(i);
+        ai->TellMasterNoFacing(item->Message);
+
+        if (item->OptionType < 1000 && item->OptionType != GOSSIP_OPTION_GOSSIP)
+        {
+            i++;
+            continue;
+        }
+
+        WorldPacket p1;
+        std::string code;
+        p1 << guid << menu.GetMenuId() << i << code;
+        bot->GetSession()->HandleGossipSelectOptionOpcode(p1);
+
+        i = 0;
+    }
+
+    bot->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.h b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
new file mode 100644
index 0000000..603737c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class GossipHelloAction : public Action {
+    public:
+        GossipHelloAction(PlayerbotAI* ai) : Action(ai, "gossip hello") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
new file mode 100644
index 0000000..49d71cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildAcceptAction.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildAcceptAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    bool accept = true;
+    uint32 guildId = master->GetGuildId();
+    if (!guildId)
+    {
+        ai->TellMaster("You are not in a guild");
+        accept = false;
+    }
+    else if (bot->GetGuildId())
+    {
+        ai->TellMaster("Sorry, I am in a guild already");
+        accept = false;
+    }
+    else if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, master, true))
+    {
+        accept = false;
+    }
+
+    WorldPacket packet;
+    if (accept)
+    {
+        bot->SetGuildIdInvited(guildId);
+        bot->GetSession()->HandleGuildAcceptOpcode(packet);
+    }
+    else
+    {
+        bot->GetSession()->HandleGuildDeclineOpcode(packet);
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
new file mode 100644
index 0000000..ab8910c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildAcceptAction : public Action {
+    public:
+        GuildAcceptAction(PlayerbotAI* ai) : Action(ai, "guild accept") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
new file mode 100644
index 0000000..849b1b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildBankAction.h"
+
+#include "../values/ItemCountValue.h"
+#include "../../../Guilds/Guild.h"
+#include "../../../Guilds/GuildMgr.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildBankAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text.empty())
+        return false;
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go || !bot->GetGameObjectIfCanInteractWith(go->GetGUID(), GAMEOBJECT_TYPE_GUILD_BANK))
+            continue;
+
+        return Execute(text, go);
+    }
+
+    ai->TellMaster("Cannot find the guild bank nearby");
+    return false;
+}
+
+bool GuildBankAction::Execute(string text, GameObject* bank)
+{
+    bool result = true;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+    {
+        Item* item = *i;
+        if (item)
+            result &= MoveFromCharToBank(item, bank);
+    }
+
+    return result;
+}
+
+bool GuildBankAction::MoveFromCharToBank(Item* item, GameObject* bank)
+{
+    uint32 playerSlot = item->GetSlot();
+    uint32 playerBag = item->GetBagSlot();
+
+    Guild* guild = sGuildMgr->GetGuildById(bot->GetGuildId());
+    guild->SwapItems(bot, 0, playerSlot, 0, INVENTORY_SLOT_BAG_0, 0);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " put to guild bank";
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.h b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
new file mode 100644
index 0000000..374fc0f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildBankAction : public InventoryAction {
+    public:
+        GuildBankAction(PlayerbotAI* ai) : InventoryAction(ai, "guild bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, GameObject* bank);
+        bool MoveFromCharToBank(Item* item, GameObject* bank);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.cpp b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
new file mode 100644
index 0000000..6e7b776
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HelpAction.h"
+#include "ChatActionContext.h"
+
+using namespace ai;
+
+HelpAction::HelpAction(PlayerbotAI* ai) : Action(ai, "help")
+{
+    chatContext = new ChatActionContext();
+}
+
+HelpAction::~HelpAction()
+{
+    delete chatContext;
+}
+
+bool HelpAction::Execute(Event event)
+{
+    TellChatCommands();
+    TellStrategies();
+    return true;
+}
+
+void HelpAction::TellChatCommands()
+{
+    ostringstream out;
+    out << "Whisper any of: ";
+    out << CombineSupported(chatContext->supports());
+    out << ", [item], [quest] or [object] link";
+    ai->TellMaster(out);
+}
+
+void HelpAction::TellStrategies()
+{
+    ostringstream out;
+    out << "Possible strategies (co/nc/dead commands): ";
+    out << CombineSupported(ai->GetAiObjectContext()->GetSupportedStrategies());
+    ai->TellMaster(out);
+}
+
+string HelpAction::CombineSupported(set<string> commands)
+{
+    ostringstream out;
+
+    for (set<string>::iterator i = commands.begin(); i != commands.end(); )
+	{
+        out << *i;
+		if (++i != commands.end())
+			out << ", ";
+	}
+
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.h b/src/plugins/playerbot/strategy/actions/HelpAction.h
new file mode 100644
index 0000000..c0bc5e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class HelpAction : public Action {
+    public:
+        HelpAction(PlayerbotAI* ai);
+        virtual ~HelpAction();
+        virtual bool Execute(Event event);
+
+    private:
+        void TellChatCommands();
+        void TellStrategies();
+        string CombineSupported(set<string> commands);
+
+    private:
+        NamedObjectContext<Action>* chatContext;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
new file mode 100644
index 0000000..896466c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
@@ -0,0 +1,288 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+
+class FindPotionVisitor : public FindUsableItemVisitor
+{
+public:
+    FindPotionVisitor(Player* bot, uint32 effectId) : FindUsableItemVisitor(bot), effectId(effectId) {}
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        if (proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_POTION &&
+            proto->Spells[0].SpellCategory == 4)
+        {
+            for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+            {
+                const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+                if (!spellInfo)
+                    return false;
+
+                for (int i = 0 ; i < 3; i++)
+                {
+                    if (spellInfo->Effects[i].Effect == effectId)
+                        return true;
+                }
+            }
+        }
+        return false;
+    }
+
+private:
+    uint32 effectId;
+};
+
+class FindFoodVisitor : public FindUsableItemVisitor
+{
+public:
+    FindFoodVisitor(Player* bot, uint32 spellCategory) : FindUsableItemVisitor(bot)
+    {
+        this->spellCategory = spellCategory;
+    }
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        return proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_FOOD &&
+            proto->Spells[0].SpellCategory == spellCategory;
+    }
+
+private:
+    uint32 spellCategory;
+};
+
+void InventoryAction::IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask)
+{
+    if (mask & ITERATE_ITEMS_IN_BAGS)
+        IterateItemsInBags(visitor);
+
+    if (mask & ITERATE_ITEMS_IN_EQUIP)
+        IterateItemsInEquip(visitor);
+}
+
+void InventoryAction::IterateItemsInBags(IterateItemsVisitor* visitor)
+{
+
+
+    for(int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag *pBag = (Bag*)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (!visitor->Visit(pItem))
+                        return;
+}
+
+void InventoryAction::IterateItemsInEquip(IterateItemsVisitor* visitor)
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        if (!visitor->Visit(pItem))
+            return;
+    }
+}
+
+bool compare_items(const ItemTemplate *proto1, const ItemTemplate *proto2)
+{
+    if (proto1->Class != proto2->Class)
+        return proto1->Class > proto2->Class;
+
+    if (proto1->SubClass != proto2->SubClass)
+        return proto1->SubClass < proto2->SubClass;
+
+    if (proto1->Quality != proto2->Quality)
+        return proto1->Quality < proto2->Quality;
+
+    if (proto1->ItemLevel != proto2->ItemLevel)
+        return proto1->ItemLevel > proto2->ItemLevel;
+
+    return false;
+}
+
+bool compare_items_by_level(const Item* item1, const Item* item2)
+{
+    return compare_items(item1->GetTemplate(), item2->GetTemplate());
+}
+
+void InventoryAction::TellItems(map<uint32, int> itemMap)
+{
+    list<ItemTemplate const*> items;
+    for (map<uint32, int>::iterator i = itemMap.begin(); i != itemMap.end(); i++)
+    {
+        items.push_back(sObjectMgr->GetItemTemplate(i->first));
+    }
+
+    items.sort(compare_items);
+
+    uint32 oldClass = -1;
+    for (list<ItemTemplate const*>::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *proto = *i;
+
+        if (proto->Class != oldClass)
+        {
+            oldClass = proto->Class;
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_CONSUMABLE:
+                ai->TellMaster("--- consumable ---");
+                break;
+            case ITEM_CLASS_CONTAINER:
+                ai->TellMaster("--- container ---");
+                break;
+            case ITEM_CLASS_WEAPON:
+                ai->TellMaster("--- weapon ---");
+                break;
+            case ITEM_CLASS_GEM:
+                ai->TellMaster("--- gem ---");
+                break;
+            case ITEM_CLASS_ARMOR:
+                ai->TellMaster("--- armor ---");
+                break;
+            case ITEM_CLASS_REAGENT:
+                ai->TellMaster("--- reagent ---");
+                break;
+            case ITEM_CLASS_PROJECTILE:
+                ai->TellMaster("--- projectile ---");
+                break;
+            case ITEM_CLASS_TRADE_GOODS:
+                ai->TellMaster("--- trade goods ---");
+                break;
+            case ITEM_CLASS_GENERIC:
+                ai->TellMaster("--- generic ---");
+                break;
+            case ITEM_CLASS_RECIPE:
+                ai->TellMaster("--- recipe ---");
+                break;
+            case ITEM_CLASS_MONEY:
+                ai->TellMaster("--- money ---");
+                break;
+            case ITEM_CLASS_QUIVER:
+                ai->TellMaster("--- quiver ---");
+                break;
+            case ITEM_CLASS_QUEST:
+                ai->TellMaster("--- quest items ---");
+                break;
+            case ITEM_CLASS_KEY:
+                ai->TellMaster("--- keys ---");
+                break;
+            case ITEM_CLASS_PERMANENT:
+                ai->TellMaster("--- permanent ---");
+                break;
+            case ITEM_CLASS_MISC:
+                ai->TellMaster("--- other ---");
+                break;
+            case ITEM_CLASS_GLYPH:
+                ai->TellMaster("--- glyph ---");
+                break;
+            }
+        }
+
+        TellItem(proto, itemMap[proto->ItemId]);
+    }
+}
+
+void InventoryAction::TellItem(ItemTemplate const * proto, int count)
+{
+    ai->TellMaster(chat->formatItem(proto, count));
+}
+
+list<Item*> InventoryAction::parseItems(string text)
+{
+    set<Item*> found;
+    size_t pos = text.find(" ");
+    int count = pos!=string::npos ? atoi(text.substr(pos + 1).c_str()) : TRADE_SLOT_TRADED_COUNT;
+    if (count < 1) count = 1;
+    else if (count > TRADE_SLOT_TRADED_COUNT) count = TRADE_SLOT_TRADED_COUNT;
+
+    if (text == "food")
+    {
+        FindFoodVisitor visitor(bot, 11);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "drink")
+    {
+        FindFoodVisitor visitor(bot, 59);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "mana potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_ENERGIZE);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "healing potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_HEAL);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    FindUsableNamedItemVisitor visitor(bot, text);
+    IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+    found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+
+    uint32 quality = chat->parseItemQuality(text);
+    if (quality != MAX_ITEM_QUALITY)
+    {
+        FindItemsToTradeByQualityVisitor visitor(quality, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 itemClass = MAX_ITEM_CLASS, itemSubClass = 0;
+    if (chat->parseItemClass(text, &itemClass, &itemSubClass))
+    {
+        FindItemsToTradeByClassVisitor visitor(itemClass, itemSubClass, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 fromSlot = chat->parseSlot(text);
+    if (fromSlot != EQUIPMENT_SLOT_END)
+    {
+        Item* item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, fromSlot);
+        if (item)
+            found.insert(item);
+    }
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        IterateItems(&visitor, ITERATE_ALL_ITEMS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    list<Item*> result;
+    for (set<Item*>::iterator i = found.begin(); i != found.end(); ++i)
+        result.push_back(*i);
+
+    result.sort(compare_items_by_level);
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.h b/src/plugins/playerbot/strategy/actions/InventoryAction.h
new file mode 100644
index 0000000..a1f1af7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "../ItemVisitors.h"
+
+namespace ai
+{
+
+
+    class InventoryAction : public Action {
+    public:
+        InventoryAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    protected:
+        void IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask = ITERATE_ITEMS_IN_BAGS);
+        void TellItems(map<uint32, int> items);
+        void TellItem(ItemTemplate const * proto, int count);
+        list<Item*> parseItems(string text);
+
+    private:
+        void IterateItemsInBags(IterateItemsVisitor* visitor);
+        void IterateItemsInEquip(IterateItemsVisitor* visitor);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
new file mode 100644
index 0000000..5933a19
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
@@ -0,0 +1,55 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryChangeFailureAction.h"
+
+
+using namespace ai;
+
+bool InventoryChangeFailureAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 err;
+    p >> err;
+    if (err == EQUIP_ERR_OK)
+        return false;
+
+    switch (err)
+    {
+    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+        ai->TellMaster("I can't carry anymore of those.");
+        break;
+    case EQUIP_ERR_MISSING_REAGENT:
+        ai->TellMaster("I'm missing some reagents for that.");
+        break;
+    case EQUIP_ERR_ITEM_LOCKED:
+        ai->TellMaster("That item is locked.");
+        break;
+    case EQUIP_ERR_ALREADY_LOOTED:
+        break;
+    case EQUIP_ERR_INVENTORY_FULL:
+        ai->TellMaster("My inventory is full.");
+        break;
+    case EQUIP_ERR_NOT_IN_COMBAT:
+        ai->TellMaster("I can't use that in combat.");
+        break;
+    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+        ai->TellMaster("I can't get that now.");
+        break;
+    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+        ai->TellMaster("I can only have one of those equipped.");
+        break;
+    case EQUIP_ERR_BANK_FULL:
+        ai->TellMaster("My bank is full.");
+        break;
+    case EQUIP_ERR_ITEM_NOT_FOUND:
+        ai->TellMaster("I can't find the item.");
+        break;
+    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+        ai->TellMaster("I'm too far from the bank.");
+        break;
+    default:
+        ai->TellMaster("I can't use that.");
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
new file mode 100644
index 0000000..4125cd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InventoryChangeFailureAction : public Action {
+    public:
+        InventoryChangeFailureAction(PlayerbotAI* ai) : Action(ai, "inventory change failure") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
new file mode 100644
index 0000000..d57ee50
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InviteToGroupAction : public Action
+    {
+    public:
+        InviteToGroupAction(PlayerbotAI* ai) : Action(ai, "invite") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = event.getOwner();
+            if (!master)
+                return false;
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << master->GetName();
+            p << roles_mask;
+            bot->GetSession()->HandleGroupInviteOpcode(p);
+
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
new file mode 100644
index 0000000..0ce2ee3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../RandomPlayerbotMgr.h"
+
+namespace ai
+{
+    class LeaveGroupAction : public Action {
+    public:
+        LeaveGroupAction(PlayerbotAI* ai, string name = "leave") : Action(ai, name) {}
+
+        virtual bool Execute(Event event)
+        {
+            if (!bot->GetGroup())
+                return false;
+
+            ai->TellMaster("Goodbye!", PLAYERBOT_SECURITY_TALK);
+
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                bot->GetPlayerbotAI()->SetMaster(NULL);
+                sRandomPlayerbotMgr.ScheduleTeleport(bot->GetGUIDLow());
+                sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+            }
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+    class PartyCommandAction : public LeaveGroupAction {
+    public:
+        PartyCommandAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            uint32 operation;
+            string member;
+
+            p >> operation >> member;
+
+            if (operation != PARTY_OP_LEAVE)
+                return false;
+
+            Player* master = GetMaster();
+            if (master && member == master->GetName())
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+    class UninviteAction : public LeaveGroupAction {
+    public:
+        UninviteAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (bot->GetGUID() == guid)
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.cpp b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
new file mode 100644
index 0000000..5d72952
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
@@ -0,0 +1,258 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LfgActions.h"
+#include "../../AiFactory.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../ItemVisitors.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+#include "../../../DungeonFinding/LFG.h"
+
+using namespace ai;
+using namespace lfg;
+
+bool LfgJoinAction::Execute(Event event)
+{
+    if (!sPlayerbotAIConfig.randomBotJoinLfg)
+        return false;
+
+    if (bot->isDead())
+        return false;
+
+    // FEYZEE: disable join LFG restriction for playerbots
+    //if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+    //    return false;
+
+    // FEYZEE: add join LFG restriction when grouped
+    Group* group = bot->GetGroup();
+    if (group)
+        return false;
+
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_NONE)
+        return false;
+
+    if (bot->IsBeingTeleported())
+        return false;
+
+    Map* map = bot->GetMap();
+    if (map && map->Instanceable())
+        return false;
+
+    return JoinProposal();
+}
+
+uint8 LfgJoinAction::GetRoles()
+{
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    switch (bot->getClass())
+    {
+    case CLASS_DRUID:
+        // FEYZEE: druid LFG issue, join as tank and dps
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        //else if (spec == 1 && bot->getLevel() >= 40)
+        //    return PLAYER_ROLE_TANK;
+        else if (spec == 1)
+        {
+            if (bot->getLevel() >= 40)
+                return PLAYER_ROLE_TANK | PLAYER_ROLE_DAMAGE;
+            else
+                return PLAYER_ROLE_DAMAGE;
+        }
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PALADIN:
+        if (spec == 1)
+            return PLAYER_ROLE_TANK;
+        else if (spec == 0)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PRIEST:
+        if (spec != 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_SHAMAN:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_WARRIOR:
+        if (spec == 2)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    default:
+        return PLAYER_ROLE_DAMAGE;
+        break;
+    }
+
+    return PLAYER_ROLE_DAMAGE;
+}
+
+bool LfgJoinAction::SetRoles()
+{
+    sLFGMgr->SetRoles(bot->GetGUID(), GetRoles());
+    return true;
+}
+
+bool LfgJoinAction::JoinProposal()
+{
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+    // FEYZEE: disable probability to join LFG
+    //bool heroic = urand(0, 100) < 50 && (visitor.count[ITEM_QUALITY_EPIC] >= 3 || visitor.count[ITEM_QUALITY_RARE] >= 10) && bot->getLevel() >= 70;
+    bool heroic = ((bot->getLevel() == 70) || (bot->getLevel() == 80)) && (visitor.count[ITEM_QUALITY_EPIC] >= 3 || visitor.count[ITEM_QUALITY_RARE] >= 10);
+    //bool random = urand(0, 100) < 25;
+    bool random = false;
+    //bool raid = !heroic && (urand(0, 100) < 50 && visitor.count[ITEM_QUALITY_EPIC] >= 5 && (bot->getLevel() == 60 || bot->getLevel() == 70 || bot->getLevel() == 80));
+    bool raid = false;
+
+    LfgDungeonSet list;
+    vector<uint32> idx;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(i);
+        //if (!dungeon || (dungeon->type != LFG_TYPE_RANDOM && dungeon->type != LFG_TYPE_DUNGEON && dungeon->type != LFG_TYPE_HEROIC &&
+        //    dungeon->type != LFG_TYPE_RAID))
+        if (!dungeon || (dungeon->type != LFG_TYPE_DUNGEON && dungeon->type != LFG_TYPE_HEROIC))
+            continue;
+
+        int botLevel = (int)bot->getLevel();
+        if (dungeon->minlevel && botLevel < (int)dungeon->minlevel)
+            continue;
+
+        if (dungeon->minlevel && botLevel > (int)dungeon->minlevel + 10)
+            continue;
+
+        if (dungeon->maxlevel && botLevel > (int)dungeon->maxlevel)
+            continue;
+
+        if (heroic && !dungeon->difficulty)
+            continue;
+
+        if (raid && dungeon->type != LFG_TYPE_RAID)
+            continue;
+
+        if (random && dungeon->type != LFG_TYPE_RANDOM)
+            continue;
+
+        if (!random && !raid && !heroic && dungeon->type != LFG_TYPE_DUNGEON)
+            continue;
+
+        if (!random)
+            list.insert(dungeon->ID);
+        else
+            idx.push_back(dungeon->ID);
+    }
+
+    if (list.empty())
+        return false;
+
+    uint8 roles = GetRoles();
+    if (random)
+    {
+        list.insert(idx[urand(0, idx.size() - 1)]);
+        sLFGMgr->JoinLfg(bot, roles, list, "bot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RANDOM as %d", bot->GetName().c_str(), (uint32)roles);
+        return true;
+    }
+    else if (heroic)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_HEROIC_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+    }
+    else if (raid)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RAID as %d", bot->GetName().c_str(), (uint32)roles);
+    }
+    else
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+    }
+
+    sLFGMgr->JoinLfg(bot, roles, list, "bot");
+    return true;
+}
+
+bool LfgRoleCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        sLFGMgr->UpdateRoleCheck(group->GetGUID(), bot->GetGUID(), GetRoles());
+        return true;
+    }
+
+    return false;
+}
+
+bool LfgAcceptAction::Execute(Event event)
+{
+    uint32 id = AI_VALUE(uint32, "lfg proposal");
+    if (id)
+    {
+        // FEYZEE: changed leave LFG procedure
+        //if (bot->IsInCombat() || bot->isDead() || bot->IsFalling())
+        if (bot->isDead())
+        {
+            sLFGMgr->LeaveLfg(bot->GetGUID());
+            return false;
+        }
+
+        ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+        // FEYZEE: disable probability for reject LFG
+        //if (urand(0, 1 + 10 / sPlayerbotAIConfig.randomChangeMultiplier))
+        //    return false;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot) && !bot->GetGroup())
+            ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s updated proposal %d", bot->GetName().c_str(), id);
+        ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(0);
+        bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+        sLFGMgr->UpdateProposal(id, bot->GetGUID(), true);
+
+        return true;
+    }
+
+    WorldPacket p(event.getPacket());
+
+    uint32 dungeon;
+    uint8 state;
+    p >> dungeon >> state >> id;
+
+    ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(id);
+    return true;
+}
+
+bool LfgLeaveAction::Execute(Event event)
+{
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_QUEUED)
+        return false;
+
+    sLFGMgr->LeaveLfg(bot->GetGUID());
+    return true;
+}
+
+bool LfgTeleportAction::Execute(Event event)
+{
+    bool out = false;
+
+    WorldPacket p(event.getPacket());
+    if (!p.empty())
+    {
+        p.rpos(0);
+        p >> out;
+    }
+
+    bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+    sLFGMgr->TeleportPlayer(bot, out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.h b/src/plugins/playerbot/strategy/actions/LfgActions.h
new file mode 100644
index 0000000..052cdcc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class LfgJoinAction : public InventoryAction
+    {
+    public:
+        LfgJoinAction(PlayerbotAI* ai, string name = "lfg join") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool JoinProposal();
+        bool SetRoles();
+        uint8 GetRoles();
+    };
+
+    class LfgAcceptAction : public LfgJoinAction
+    {
+    public:
+        LfgAcceptAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg accept") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgRoleCheckAction : public LfgJoinAction
+    {
+    public:
+        LfgRoleCheckAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg role check") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgLeaveAction : public Action
+    {
+    public:
+        LfgLeaveAction(PlayerbotAI* ai) : Action(ai, "lfg leave") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgTeleportAction : public Action
+    {
+    public:
+        LfgTeleportAction(PlayerbotAI* ai) : Action(ai, "lfg teleport") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
new file mode 100644
index 0000000..d9249ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListQuestsActions.h"
+
+
+using namespace ai;
+
+bool ListQuestsAction::Execute(Event event)
+{
+    if (event.getParam() == "completed")
+    {
+        ListQuests(QUEST_LIST_FILTER_COMPLETED);
+    }
+    else if (event.getParam() == "incompleted")
+    {
+        ListQuests(QUEST_LIST_FILTER_INCOMPLETED);
+    }
+    else if (event.getParam() == "all")
+    {
+        ListQuests(QUEST_LIST_FILTER_ALL);
+    }
+    else
+    {
+        ListQuests(QUEST_LIST_FILTER_SUMMARY);
+    }
+    return true;
+}
+
+void ListQuestsAction::ListQuests(QuestListFilter filter)
+{
+    bool showIncompleted = filter & QUEST_LIST_FILTER_INCOMPLETED;
+    bool showCompleted = filter & QUEST_LIST_FILTER_COMPLETED;
+
+    if (showIncompleted)
+        ai->TellMaster("--- Incomplete quests ---");
+    int incompleteCount = ListQuests(false, !showIncompleted);
+
+    if (showCompleted)
+        ai->TellMaster("--- Complete quests ---");
+    int completeCount = ListQuests(true, !showCompleted);
+
+    ai->TellMaster("--- Summary ---");
+    std::ostringstream out;
+    out << "Total: " << (completeCount + incompleteCount) << " / 25 (incomplete: " << incompleteCount << ", complete: " << completeCount << ")";
+    ai->TellMaster(out);
+}
+
+int ListQuestsAction::ListQuests(bool completed, bool silent)
+{
+    int count = 0;
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+        bool isCompletedQuest = bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE;
+        if (completed != isCompletedQuest)
+            continue;
+
+        count++;
+
+        if (silent)
+            continue;
+
+        ai->TellMaster(chat->formatQuest(pQuest));
+    }
+
+    return count;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.h b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
new file mode 100644
index 0000000..961acb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    enum QuestListFilter {
+        QUEST_LIST_FILTER_SUMMARY = 0,
+        QUEST_LIST_FILTER_COMPLETED = 1,
+        QUEST_LIST_FILTER_INCOMPLETED = 2,
+        QUEST_LIST_FILTER_ALL = QUEST_LIST_FILTER_COMPLETED | QUEST_LIST_FILTER_INCOMPLETED
+    };
+
+    class ListQuestsAction : public Action {
+    public:
+        ListQuestsAction(PlayerbotAI* ai) : Action(ai, "quests") {}
+        virtual bool Execute(Event event);
+
+    private:
+        int ListQuests(bool completed, bool silent);
+        void ListQuests(QuestListFilter filter);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
new file mode 100644
index 0000000..4602fb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListSpellsAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool ListSpellsAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    string filter = event.getParam();
+
+    const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+    std::string alreadySeenList = ",";
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr) {
+        const uint32 spellId = itr->first;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        //|| name.find("Teleport") != -1
+
+        std::string comp = ",";
+        comp.append(pSpellInfo->SpellName[loc]);
+        comp.append(",");
+
+        if (!(ignoreList.find(comp) == std::string::npos && alreadySeenList.find(comp) == std::string::npos))
+            continue;
+
+        if (!filter.empty() && !strstri(pSpellInfo->SpellName[loc], filter.c_str()))
+            continue;
+
+        alreadySeenList += pSpellInfo->SpellName[loc];
+        alreadySeenList += ",";
+
+        if (pSpellInfo->IsPositive())
+            posOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+        else
+            negOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+    }
+
+    ai->TellMaster("here's my non-attack spells:");
+    ai->TellMaster(posOut);
+
+    ai->TellMaster("here's my attack spells:");
+    ai->TellMaster(negOut);
+
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.h b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
new file mode 100644
index 0000000..b4fe3af
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+
+namespace ai
+{
+    class ListSpellsAction : public Action {
+    public:
+        ListSpellsAction(PlayerbotAI* ai) : Action(ai, "spells") {}
+
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
new file mode 100644
index 0000000..92005a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
@@ -0,0 +1,43 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LogLevelAction.h"
+
+
+using namespace ai;
+
+bool LogLevelAction::Execute(Event event)
+{
+    string param = event.getParam();
+    Value<LogLevel> *value = ai->GetAiObjectContext()->GetValue<LogLevel>("log level");
+
+    ostringstream out;
+    if (param != "?")
+    {
+        value->Set(string2logLevel(param));
+        out << "My log level set to " << logLevel2string(value->Get());
+    }
+    else
+    {
+        out << "My log level is " << logLevel2string(value->Get());
+    }
+    ai->TellMaster(out);
+    return true;
+}
+
+string LogLevelAction::logLevel2string(LogLevel level)
+{
+    switch (level)
+    {
+    case LOG_LEVEL_INFO:
+        return "info";
+    default:
+        return "debug";
+    }
+}
+LogLevel LogLevelAction::string2logLevel(string level)
+{
+    if (level == "debug")
+        return LOG_LEVEL_DEBUG;
+    else
+        return LOG_LEVEL_INFO;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.h b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
new file mode 100644
index 0000000..4ad2a33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class LogLevelAction : public Action {
+    public:
+        LogLevelAction(PlayerbotAI* ai) : Action(ai, "log") {}
+        virtual bool Execute(Event event);
+
+    public:
+        static string logLevel2string(LogLevel level);
+        static LogLevel string2logLevel(string level);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.cpp b/src/plugins/playerbot/strategy/actions/LootAction.cpp
new file mode 100644
index 0000000..41c17aa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.cpp
@@ -0,0 +1,338 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootAction.h"
+
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../values/ItemUsageValue.h"
+#include "../../GuildTaskMgr.h"
+
+using namespace ai;
+
+bool LootAction::Execute(Event event)
+{
+    if (!AI_VALUE(bool, "has available loot"))
+        return false;
+
+    LootObject const& lootObject = AI_VALUE(LootObjectStack*, "available loot")->GetLoot(sPlayerbotAIConfig.lootDistance);
+    context->GetValue<LootObject>("loot target")->Set(lootObject);
+    return true;
+}
+
+enum ProfessionSpells
+{
+    ALCHEMY                      = 2259,
+    BLACKSMITHING                = 2018,
+    COOKING                      = 2550,
+    ENCHANTING                   = 7411,
+    ENGINEERING                  = 49383,
+    FIRST_AID                    = 3273,
+    FISHING                      = 7620,
+    HERB_GATHERING               = 2366,
+    INSCRIPTION                  = 45357,
+    JEWELCRAFTING                = 25229,
+    MINING                       = 2575,
+    SKINNING                     = 8613,
+    TAILORING                    = 3908
+};
+
+bool OpenLootAction::Execute(Event event)
+{
+    LootObject lootObject = AI_VALUE(LootObject, "loot target");
+    bool result = DoLoot(lootObject);
+    if (result)
+    {
+        AI_VALUE(LootObjectStack*, "available loot")->Remove(lootObject.guid);
+        context->GetValue<LootObject>("loot target")->Set(LootObject());
+    }
+    return result;
+}
+
+bool OpenLootAction::DoLoot(LootObject& lootObject)
+{
+    if (lootObject.IsEmpty())
+        return false;
+
+    Creature* creature = ai->GetCreature(lootObject.guid);
+    if (creature && bot->GetDistance(creature) > INTERACTION_DISTANCE)
+        return false;
+
+    if (creature && creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+    {
+        bot->GetMotionMaster()->Clear();
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+        *packet << lootObject.guid;
+        bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+
+    if (creature)
+    {
+        SkillType skill = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+        if (!CanOpenLock(skill, lootObject.reqSkillValue))
+            return false;
+
+        bot->GetMotionMaster()->Clear();
+        switch (skill)
+        {
+        case SKILL_ENGINEERING:
+            return bot->HasSkill(SKILL_ENGINEERING) ? ai->CastSpell(ENGINEERING, creature) : false;
+        case SKILL_HERBALISM:
+            return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(32605, creature) : false;
+        case SKILL_MINING:
+            return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(32606, creature) : false;
+        default:
+            return bot->HasSkill(SKILL_SKINNING) ? ai->CastSpell(SKINNING, creature) : false;
+        }
+    }
+
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && bot->GetDistance(go) > INTERACTION_DISTANCE)
+        return false;
+
+    bot->GetMotionMaster()->Clear();
+    if (lootObject.skillId == SKILL_MINING)
+        return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(MINING, bot) : false;
+
+    if (lootObject.skillId == SKILL_HERBALISM)
+        return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(HERB_GATHERING, bot) : false;
+
+    uint32 spellId = GetOpeningSpell(lootObject);
+    if (!spellId)
+        return false;
+
+    return ai->CastSpell(spellId, bot);
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject)
+{
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && go->isSpawned())
+        return GetOpeningSpell(lootObject, go);
+
+    return 0;
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject, GameObject* go)
+{
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+    {
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    return 0; //Spell 3365 = Opening?
+}
+
+bool OpenLootAction::CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go)
+{
+    for (int effIndex = 0; effIndex <= EFFECT_2; effIndex++)
+    {
+        if (pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_OPEN_LOCK && pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_SKINNING)
+            return false;
+
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        if (!lockId)
+            return false;
+
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return false;
+
+        bool reqKey = false;                                    // some locks not have reqs
+
+        for(int j = 0; j < 8; ++j)
+        {
+            switch(lockInfo->Type[j])
+            {
+            /*
+            case LOCK_KEY_ITEM:
+                return true;
+            */
+            case LOCK_KEY_SKILL:
+                {
+                    if(uint32(pSpellInfo->Effects[effIndex].MiscValue) != lockInfo->Index[j])
+                        continue;
+
+                    uint32 skillId = SkillByLockType(LockType(lockInfo->Index[j]));
+                    if (skillId == SKILL_NONE)
+                        return true;
+
+                    if (CanOpenLock(skillId, lockInfo->Skill[j]))
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool OpenLootAction::CanOpenLock(uint32 skillId, uint32 reqSkillValue)
+{
+    uint32 skillValue = bot->GetSkillValue(skillId);
+    return skillValue >= reqSkillValue || !reqSkillValue;
+}
+
+bool StoreLootAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket()); // (8+1+4+1+1+4+4+4+4+4+1)
+    ObjectGuid guid;
+    uint8 loot_type;
+    uint32 gold = 0;
+    uint8 items = 0;
+
+    p.rpos(0);
+    p >> guid;      // 8 corpse guid
+    p >> loot_type; // 1 loot type
+
+    if (p.size() > 10)
+    {
+        p >> gold;      // 4 money on corpse
+        p >> items;     // 1 number of items on corpse
+    }
+
+    if (gold > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    for (uint8 i = 0; i < items; ++i)
+    {
+        uint32 itemid;
+        uint32 itemcount;
+        uint8 lootslot_type;
+        uint8 itemindex;
+        bool grab = false;
+
+        p >> itemindex;
+        p >> itemid;
+        p >> itemcount;
+        p.read_skip<uint32>();  // display id
+        p.read_skip<uint32>();  // randomSuffix
+        p.read_skip<uint32>();  // randomPropertyId
+        p >> lootslot_type;     // 0 = can get, 1 = look only, 2 = master get
+
+        if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+            continue;
+
+        if (loot_type != LOOT_SKINNING && !IsLootAllowed(itemid))
+            continue;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot))
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+            if (proto)
+            {
+                uint32 price = itemcount * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) + gold;
+                uint32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                if (bot->GetGroup() && price)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, lootAmount + price);
+                }
+                else if (lootAmount)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+                }
+
+                Group* group = bot->GetGroup();
+                if (group)
+                {
+                    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+                    {
+                        if( ref->GetSource() != bot)
+                            sGuildTaskMgr.CheckItemTask(itemid, itemcount, ref->GetSource(), bot);
+                    }
+                }
+            }
+        }
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+        *packet << itemindex;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    AI_VALUE(LootObjectStack*, "available loot")->Remove(guid);
+
+    // release loot
+    WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+    *packet << guid;
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool StoreLootAction::IsLootAllowed(uint32 itemid)
+{
+    LootStrategy lootStrategy = AI_VALUE(LootStrategy, "loot strategy");
+
+    if (lootStrategy == LOOTSTRATEGY_ALL)
+        return true;
+
+    set<uint32>& lootItems = AI_VALUE(set<uint32>&, "always loot list");
+    if (lootItems.find(itemid) != lootItems.end())
+        return true;
+
+    ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+    if (!proto)
+        return false;
+
+    uint32 max = proto->MaxCount;
+    if (max > 0 && bot->HasItemCount(itemid, max, true))
+        return false;
+
+    if (proto->StartQuest ||
+        proto->Bonding == BIND_QUEST_ITEM ||
+        proto->Bonding == BIND_QUEST_ITEM1 ||
+        proto->Class == ITEM_CLASS_QUEST)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_QUEST)
+        return false;
+
+    ostringstream out; out << itemid;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_SKILL || usage == ITEM_USAGE_USE || usage == ITEM_USAGE_GUILD_TASK)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_SKILL)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_MONEY || proto->Quality == ITEM_QUALITY_POOR)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_GRAY)
+        return true;
+
+    if (proto->Bonding == BIND_WHEN_PICKED_UP)
+        return false;
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.h b/src/plugins/playerbot/strategy/actions/LootAction.h
new file mode 100644
index 0000000..c18fbb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class LootAction : public MovementAction
+    {
+    public:
+        LootAction(PlayerbotAI* ai) : MovementAction(ai, "loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class OpenLootAction : public MovementAction
+    {
+    public:
+        OpenLootAction(PlayerbotAI* ai) : MovementAction(ai, "open loot") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool DoLoot(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject, GameObject* go);
+        bool CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go);
+        bool CanOpenLock(uint32 skillId, uint32 reqSkillValue);
+    };
+
+    class StoreLootAction : public MovementAction
+    {
+    public:
+        StoreLootAction(PlayerbotAI* ai) : MovementAction(ai, "store loot") {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool IsLootAllowed(uint32 itemid);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.cpp b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
new file mode 100644
index 0000000..498cb42
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootRollAction.h"
+#include "../../../Groups/Group.h"
+
+
+using namespace ai;
+
+bool LootRollAction::Execute(Event event)
+{
+    Player *bot = QueryItemUsageAction::ai->GetBot();
+
+    WorldPacket p(event.getPacket()); //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+    ObjectGuid guid;
+    uint32 slot;
+    uint8 rollType;
+    p.rpos(0); //reset packet pointer
+    p >> guid; //guid of the item rolled
+    p >> slot; //number of players invited to roll
+    p >> rollType; //need,greed or pass on roll
+
+    Group* group = bot->GetGroup();
+    if(!group)
+        return false;
+
+    RollVote vote = PASS;
+    for (vector<Roll*>::iterator i = group->GetRolls()->begin(); i != group->GetRolls()->end(); ++i)
+    {
+        if ((*i)->isValid() && (*i)->itemGUID == guid && (*i)->itemSlot == slot)
+        {
+            uint32 itemId = (*i)->itemid;
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemId);
+            if (!proto)
+                continue;
+
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_WEAPON:
+            case ITEM_CLASS_ARMOR:
+                if (QueryItemUsage(proto))
+                    vote = NEED;
+                else if (bot->HasSkill(SKILL_ENCHANTING))
+                    vote = DISENCHANT;
+                break;
+            default:
+                if (IsLootAllowed(itemId))
+                    vote = NEED;
+                break;
+            }
+            break;
+        }
+    }
+
+    switch (group->GetLootMethod())
+    {
+    case MASTER_LOOT:
+    case FREE_FOR_ALL:
+        group->CountRollVote(bot->GetGUID(), guid, PASS);
+        break;
+    default:
+        group->CountRollVote(bot->GetGUID(), guid, vote);
+        break;
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.h b/src/plugins/playerbot/strategy/actions/LootRollAction.h
new file mode 100644
index 0000000..05651a4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "../Action.h"
+#include "QueryItemUsageAction.h"
+#include "LootAction.h"
+
+namespace ai
+{
+    class LootRollAction : public QueryItemUsageAction, public StoreLootAction {
+    public:
+        LootRollAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "loot roll"), StoreLootAction(ai) {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
new file mode 100644
index 0000000..633429e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootStrategyAction.h"
+
+
+using namespace ai;
+
+
+bool LootStrategyAction::Execute(Event event)
+{
+    string strategy = event.getParam();
+
+    LootObjectStack* lootItems = AI_VALUE(LootObjectStack*, "available loot");
+    set<uint32>& alwaysLootItems = AI_VALUE(set<uint32>&, "always loot list");
+    Value<LootStrategy>* lootStrategy = context->GetValue<LootStrategy>("loot strategy");
+
+    if (strategy == "?")
+    {
+        ostringstream out;
+        out << "Loot strategy: ";
+        out << LootStrategy2string(lootStrategy->Get());
+        out << ", always loot items: ";
+
+        for (set<uint32>::iterator i = alwaysLootItems.begin(); i != alwaysLootItems.end(); i++)
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(*i);
+            if (!proto)
+                continue;
+
+            out << chat->formatItem(proto);
+        }
+        ai->TellMaster(out);
+    }
+    else
+    {
+        ItemIds items = chat->parseItems(strategy);
+
+        if (items.size() == 0)
+        {
+            lootStrategy->Set(String2LootStrategy(strategy));
+            ostringstream out;
+            out << "Loot strategy set to " << LootStrategy2string(lootStrategy->Get());
+            ai->TellMaster(out);
+            return true;
+        }
+
+        bool remove = strategy.size() > 1 && strategy.substr(0, 1) == "-";
+        for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+        {
+            uint32 itemid = *i;
+            if (remove)
+            {
+                set<uint32>::iterator j = alwaysLootItems.find(itemid);
+                if (j != alwaysLootItems.end())
+                    alwaysLootItems.erase(j);
+
+                ai->TellMaster("Item(s) removed from always loot list");
+            }
+            else
+            {
+                alwaysLootItems.insert(itemid);
+                ai->TellMaster("Item(s) added to always loot list");
+            }
+        }
+    }
+
+    return true;
+}
+
+
+LootStrategy LootStrategyAction::String2LootStrategy(string strategy)
+{
+    if (strategy == "*" || strategy == "all")
+        return LOOTSTRATEGY_ALL;
+    else if (strategy == "q" || strategy == "quest")
+        return LOOTSTRATEGY_QUEST;
+    else if (strategy == "s" || strategy == "skill")
+        return LOOTSTRATEGY_SKILL;
+    else if (strategy == "g" || strategy == "gray")
+        return LOOTSTRATEGY_GRAY;
+    else
+        return LOOTSTRATEGY_NORMAL;
+}
+
+string LootStrategyAction::LootStrategy2string(LootStrategy lootStrategy)
+{
+    switch (lootStrategy)
+    {
+    case LOOTSTRATEGY_ALL:
+        return "all";
+    case LOOTSTRATEGY_QUEST:
+        return "quest";
+    case LOOTSTRATEGY_SKILL:
+        return "skill";
+    case LOOTSTRATEGY_GRAY:
+        return "gray";
+    default:
+        return "normal";
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.h b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
new file mode 100644
index 0000000..08edbe0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class LootStrategyAction : public Action {
+    public:
+        LootStrategyAction(PlayerbotAI* ai) : Action(ai, "ll") {}
+        virtual bool Execute(Event event);
+
+    private:
+        static LootStrategy String2LootStrategy(string strategy);
+        static string LootStrategy2string(LootStrategy lootStrategy);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.cpp b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
new file mode 100644
index 0000000..f1fcfc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
@@ -0,0 +1,373 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../values/LastMovementValue.h"
+#include "MovementActions.h"
+#include "../../../Movement/MotionMaster.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../FleeManager.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool MovementAction::MoveNear(uint32 mapId, float x, float y, float z, float distance)
+{
+    float angle = GetFollowAngle();
+    return MoveTo(mapId, x + cos(angle) * distance, y + sin(angle) * distance, z);
+}
+
+bool MovementAction::MoveNear(WorldObject* target, float distance)
+{
+    if (!target)
+        return false;
+
+    distance += target->GetObjectSize() / 2.0f;
+
+    float followAngle = GetFollowAngle();
+    for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+    {
+        bool moved = MoveTo(target->GetMapId(),
+            target->GetPositionX() + cos(angle) * distance,
+            target->GetPositionY()+ sin(angle) * distance,
+            target->GetPositionZ());
+        if (moved)
+            return true;
+    }
+    return false;
+}
+
+bool MovementAction::MoveTo(uint32 mapId, float x, float y, float z)
+{
+    bot->UpdateGroundPositionZ(x, y, z);
+    if (!IsMovingAllowed(mapId, x, y, z))
+        return false;
+
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.contactDistance)
+    {
+        WaitForReach(distance);
+
+        if (bot->IsSitState())
+            bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (bot->IsNonMeleeSpellCast(true))
+        {
+            bot->CastStop();
+            ai->InterruptSpell();
+        }
+
+        bool generatePath = bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) &&
+                !bot->IsFlying() && !bot->IsUnderWater();
+        MotionMaster &mm = *bot->GetMotionMaster();
+        mm.Clear();
+
+        float botZ = bot->GetPositionZ();
+        if (z - botZ > 0.5f && bot->GetDistance2d(x, y) <= 5.0f)
+        {
+            float speed = bot->GetSpeed(MOVE_RUN);
+            mm.MoveJump(x, y, botZ + 0.5f, speed, speed, 1);
+        }
+        else
+            mm.MovePoint(mapId, x, y, z, generatePath);
+    }
+
+    AI_VALUE(LastMovement&, "last movement").Set(x, y, z, bot->GetOrientation());
+    return true;
+}
+
+bool MovementAction::MoveTo(Unit* target, float distance)
+{
+    if (!IsMovingAllowed(target))
+        return false;
+
+    float bx = bot->GetPositionX();
+    float by = bot->GetPositionY();
+    float bz = bot->GetPositionZ();
+
+    float tx = target->GetPositionX();
+    float ty = target->GetPositionY();
+    float tz = target->GetPositionZ();
+
+    float distanceToTarget = bot->GetDistance(target);
+    float angle = bot->GetAngle(target);
+    float needToGo = distanceToTarget - distance;
+
+    float maxDistance = sPlayerbotAIConfig.spellDistance;
+    if (needToGo > 0 && needToGo > maxDistance)
+        needToGo = maxDistance;
+    else if (needToGo < 0 && needToGo < -maxDistance)
+        needToGo = -maxDistance;
+
+    float dx = cos(angle) * needToGo + bx;
+    float dy = sin(angle) * needToGo + by;
+
+    return MoveTo(target->GetMapId(), dx, dy, tz);
+}
+
+float MovementAction::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+bool MovementAction::IsMovingAllowed(Unit* target)
+{
+    if (!target)
+        return false;
+
+    if (bot->GetMapId() != target->GetMapId())
+        return false;
+
+    float distance = bot->GetDistance(target);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed(uint32 mapId, float x, float y, float z)
+{
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed()
+{
+    if (bot->isFrozen() || bot->IsPolymorphed() ||
+            (bot->isDead() && !bot->GetCorpse()) ||
+            bot->IsBeingTeleported() ||
+            bot->isInRoots() ||
+            bot->HasAuraType(SPELL_AURA_MOD_CONFUSE) || bot->IsCharmed() ||
+            bot->HasAuraType(SPELL_AURA_MOD_STUN) || bot->IsFlying())
+        return false;
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    return mm.GetCurrentMovementGeneratorType() != FLIGHT_MOTION_TYPE;
+}
+
+bool MovementAction::Follow(Unit* target, float distance)
+{
+    return Follow(target, distance, GetFollowAngle());
+}
+
+bool MovementAction::Follow(Unit* target, float distance, float angle)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (!target)
+        return false;
+
+    if (bot->GetDistance2d(target->GetPositionX(), target->GetPositionY()) <= sPlayerbotAIConfig.sightDistance &&
+            abs(bot->GetPositionZ() - target->GetPositionZ()) >= sPlayerbotAIConfig.spellDistance)
+    {
+        mm.Clear();
+        float x = bot->GetPositionX(), y = bot->GetPositionY(), z = target->GetPositionZ();
+        if (target->GetMapId() && bot->GetMapId() != target->GetMapId())
+        {
+            bot->TeleportTo(target->GetMapId(), x, y, z, bot->GetOrientation());
+        }
+        else
+        {
+            bot->Relocate(x, y, z, bot->GetOrientation());
+        }
+        AI_VALUE(LastMovement&, "last movement").Set(target);
+        return true;
+    }
+
+    if (!IsMovingAllowed(target))
+        return false;
+
+    if (target->IsFriendlyTo(bot) && bot->IsMounted() && AI_VALUE(list<ObjectGuid>, "possible targets").empty())
+        distance += angle;
+
+    if (bot->GetDistance(target) <= sPlayerbotAIConfig.followDistance)
+        return false;
+
+    if (bot->IsSitState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (bot->IsNonMeleeSpellCast(true))
+    {
+        bot->CastStop();
+        ai->InterruptSpell();
+    }
+
+    mm.MoveFollow(target, distance, angle);
+
+    AI_VALUE(LastMovement&, "last movement").Set(target);
+    return true;
+}
+
+void MovementAction::WaitForReach(float distance)
+{
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+
+    if (delay > sPlayerbotAIConfig.maxWaitForMove)
+        delay = sPlayerbotAIConfig.maxWaitForMove;
+
+    Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+    Unit* player = *ai->GetAiObjectContext()->GetValue<Unit*>("enemy player target");
+    if ((player || target) && delay > sPlayerbotAIConfig.globalCoolDown)
+        delay = sPlayerbotAIConfig.globalCoolDown;
+
+    ai->SetNextCheckDelay((uint32)delay);
+}
+
+bool MovementAction::Flee(Unit *target)
+{
+    Player* master = GetMaster();
+    if (!target)
+        target = master;
+
+    if (!target)
+        return false;
+
+    if (!sPlayerbotAIConfig.fleeingEnabled)
+        return false;
+
+    if (!IsMovingAllowed())
+        return false;
+
+    FleeManager manager(bot, sPlayerbotAIConfig.fleeDistance, GetFollowAngle());
+
+    float rx, ry, rz;
+    if (!manager.CalculateDestination(&rx, &ry, &rz))
+        return false;
+
+    return MoveTo(target->GetMapId(), rx, ry, rz);
+}
+
+bool FleeAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "current target"));
+}
+
+bool FleeAction::isUseful()
+{
+    return AI_VALUE(uint8, "attacker count") > 0 &&
+            AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool RunAwayAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "master target"));
+}
+
+bool MoveRandomAction::Execute(Event event)
+{
+    WorldObject* target = NULL;
+
+    if (!(rand() % 3))
+    {
+        list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+        for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+        {
+            target = ai->GetUnit(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    if (!target || !(rand() % 3))
+    {
+        list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+        for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        {
+            target = ai->GetGameObject(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    float distance = sPlayerbotAIConfig.tooCloseDistance + sPlayerbotAIConfig.grindDistance * urand(3, 10) / 10.0f;
+
+    Map* map = bot->GetMap();
+    if (target)
+    {
+        float x = target->GetPositionX();
+        float y = target->GetPositionY();
+        float z = target->GetPositionZ();
+        if (!map->IsInWater(x, y, z))
+        {
+            return MoveNear(target);
+        }
+    }
+
+    for (int i = 0; i < 10; ++i)
+    {
+        float x = bot->GetPositionX();
+        float y = bot->GetPositionY();
+        float z = bot->GetPositionZ();
+        x += urand(0, distance) - distance / 2;
+        y += urand(0, distance) - distance / 2;
+        bot->UpdateGroundPositionZ(x, y, z);
+
+        if (map->IsInWater(x, y, z))
+            continue;
+
+        bool moved = MoveNear(bot->GetMapId(), x, y, z);
+        if (moved)
+            return true;
+    }
+
+    return false;
+}
+
+bool MoveToLootAction::Execute(Event event)
+{
+    LootObject loot = AI_VALUE(LootObject, "loot target");
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return MoveNear(loot.GetWorldObject(bot));
+}
+
+bool MoveOutOfEnemyContactAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    return MoveNear(target, sPlayerbotAIConfig.meleeDistance);
+}
+
+bool MoveOutOfEnemyContactAction::isUseful()
+{
+    return AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+}
+
+bool SetFacingTargetAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    bot->SetFacingTo(bot->GetAngle(target));
+    ai->SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+    return true;
+}
+
+bool SetFacingTargetAction::isUseful()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.h b/src/plugins/playerbot/strategy/actions/MovementActions.h
new file mode 100644
index 0000000..dc27b92
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.h
@@ -0,0 +1,92 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class MovementAction : public Action {
+    public:
+        MovementAction(PlayerbotAI* ai, string name) : Action(ai, name)
+        {
+            bot = ai->GetBot();
+        }
+
+    protected:
+        bool MoveNear(uint32 mapId, float x, float y, float z, float distance = sPlayerbotAIConfig.followDistance);
+        bool MoveTo(uint32 mapId, float x, float y, float z);
+        bool MoveTo(Unit* target, float distance = 0.0f);
+        bool MoveNear(WorldObject* target, float distance = sPlayerbotAIConfig.followDistance);
+        float GetFollowAngle();
+        bool Follow(Unit* target, float distance = sPlayerbotAIConfig.followDistance);
+        bool Follow(Unit* target, float distance, float angle);
+        void WaitForReach(float distance);
+        bool IsMovingAllowed(Unit* target);
+        bool IsMovingAllowed(uint32 mapId, float x, float y, float z);
+        bool IsMovingAllowed();
+        bool Flee(Unit *target);
+
+    protected:
+        Player* bot;
+    };
+
+    class FleeAction : public MovementAction
+    {
+    public:
+        FleeAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : MovementAction(ai, "flee")
+        {
+			this->distance = distance;
+		}
+
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+	private:
+		float distance;
+    };
+
+
+    class RunAwayAction : public MovementAction
+    {
+    public:
+        RunAwayAction(PlayerbotAI* ai) : MovementAction(ai, "runaway") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveRandomAction : public MovementAction
+    {
+    public:
+        MoveRandomAction(PlayerbotAI* ai) : MovementAction(ai, "move random") {}
+        virtual bool Execute(Event event);
+        virtual bool isPossible()
+        {
+            return MovementAction::isPossible() &&
+                    AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                    (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana);
+        }
+    };
+
+    class MoveToLootAction : public MovementAction
+    {
+    public:
+        MoveToLootAction(PlayerbotAI* ai) : MovementAction(ai, "move to loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveOutOfEnemyContactAction : public MovementAction
+    {
+    public:
+        MoveOutOfEnemyContactAction(PlayerbotAI* ai) : MovementAction(ai, "move out of enemy contact") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class SetFacingTargetAction : public MovementAction
+    {
+    public:
+        SetFacingTargetAction(PlayerbotAI* ai) : MovementAction(ai, "set facing") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
new file mode 100644
index 0000000..56961c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.h b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
new file mode 100644
index 0000000..d66e92c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "UseItemAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class DrinkAction : public UseItemAction
+    {
+    public:
+        DrinkAction(PlayerbotAI* ai) : UseItemAction(ai, "drink") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+        }
+    };
+
+    class EatAction : public UseItemAction
+    {
+    public:
+        EatAction(PlayerbotAI* ai) : UseItemAction(ai, "food") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.lowHealth;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
new file mode 100644
index 0000000..fb558df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class PassLeadershipToMasterAction : public Action {
+    public:
+        PassLeadershipToMasterAction(PlayerbotAI* ai) : Action(ai, "leader") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+            if (master && bot->GetGroup() && bot->GetGroup()->IsMember(master->GetGUID()))
+            {
+                WorldPacket p(SMSG_GROUP_SET_LEADER, 8);
+                p << master->GetGUID();
+                bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                return true;
+            }
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.cpp b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
new file mode 100644
index 0000000..242c7fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionAction.h"
+#include "../values/PositionValue.h"
+
+using namespace ai;
+
+bool PositionAction::Execute(Event event)
+{
+	string qualifier = event.getParam();
+	if (qualifier.empty())
+		return false;
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    pos.Set( master->GetPositionX(), master->GetPositionY(), master->GetPositionZ());
+
+    ostringstream out; out << "Position " << qualifier << " is set";
+    ai->TellMaster(out);
+    return true;
+}
+
+bool MoveToPositionAction::Execute(Event event)
+{
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    if (!pos.isSet())
+    {
+        ostringstream out; out << "Position " << qualifier << " is not set";
+        ai->TellMaster(out);
+        return false;
+    }
+
+    return MoveTo(bot->GetMapId(), pos.x, pos.y, pos.z);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.h b/src/plugins/playerbot/strategy/actions/PositionAction.h
new file mode 100644
index 0000000..f96553b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class PositionAction : public Action
+    {
+    public:
+        PositionAction(PlayerbotAI* ai) : Action(ai, "position")
+        {}
+
+        virtual bool Execute(Event event);
+
+    };
+
+    class MoveToPositionAction : public MovementAction
+    {
+    public:
+        MoveToPositionAction(PlayerbotAI* ai, string qualifier) : MovementAction(ai, "move to position"), qualifier(qualifier)
+        {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        string qualifier;
+    };
+
+    class GuardAction : public MoveToPositionAction
+    {
+    public:
+        GuardAction(PlayerbotAI* ai) : MoveToPositionAction(ai, "guard")
+        {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
new file mode 100644
index 0000000..4cbd973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
@@ -0,0 +1,172 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryItemUsageAction.h"
+#include "../values/ItemUsageValue.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+
+using namespace ai;
+
+
+bool QueryItemUsageAction::Execute(Event event)
+{
+    WorldPacket& data = event.getPacket();
+    if (!data.empty())
+    {
+        data.rpos(0);
+
+        ObjectGuid guid;
+        data >> guid;
+        if (guid.GetRawValue() != bot->GetGUID())
+            return false;
+
+        uint32 received, created, isShowChatMessage, notUsed, itemId,
+            suffixFactor, itemRandomPropertyId, count, invCount;
+        uint8 bagSlot;
+
+        data >> received;                               // 0=looted, 1=from npc
+        data >> created;                                // 0=received, 1=created
+        data >> isShowChatMessage;                                      // IsShowChatMessage
+        data >> bagSlot;
+                                                                // item slot, but when added to stack: 0xFFFFFFFF
+        data >> notUsed;
+        data >> itemId;
+        data >> suffixFactor;
+        data >> itemRandomPropertyId;
+        data >> count;
+        data >> invCount;
+
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(itemId);
+        if (!item)
+            return false;
+
+        ostringstream out; out << chat->formatItem(item, count);
+        if (created)
+            out << " created";
+        else if (received)
+            out << " received";
+        ai->TellMaster(out);
+
+        QueryItemUsage(item);
+        QueryQuestItem(itemId);
+        return true;
+    }
+
+    string text = event.getParam();
+
+    ItemIds items = chat->parseItems(text);
+    QueryItemsUsage(items);
+    return true;
+}
+
+bool QueryItemUsageAction::QueryItemUsage(ItemTemplate const *item)
+{
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    switch (usage)
+    {
+    case ITEM_USAGE_EQUIP:
+        ai->TellMaster("Equip");
+        return true;
+    case ITEM_USAGE_REPLACE:
+        ai->TellMaster("Equip (replace)");
+        return true;
+    case ITEM_USAGE_SKILL:
+        ai->TellMaster("Tradeskill");
+        return true;
+    case ITEM_USAGE_USE:
+        ai->TellMaster("Use");
+        return true;
+    case ITEM_USAGE_GUILD_TASK:
+        ai->TellMaster("Guild task");
+        return true;
+    }
+
+    return false;
+}
+
+void QueryItemUsageAction::QueryItemPrice(ItemTemplate const *item)
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    if (item->Bonding == BIND_WHEN_PICKED_UP)
+        return;
+
+    list<Item*> items = InventoryAction::parseItems(item->Name1);
+    if (!items.empty())
+    {
+        for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        {
+            Item* sell = *i;
+            int32 sellPrice = sell->GetCount() * auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+            ostringstream out;
+            out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+            ai->TellMaster(out.str());
+        }
+    }
+
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_NONE)
+        return;
+
+    int32 buyPrice = auctionbot.GetBuyPrice(item) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+    if (buyPrice)
+    {
+        ostringstream out;
+        out << "Will buy for " << chat->formatMoney(buyPrice);
+        ai->TellMaster(out.str());
+    }
+}
+
+void QueryItemUsageAction::QueryItemsUsage(ItemIds items)
+{
+    for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(*i);
+        QueryItemUsage(item);
+        QueryQuestItem(*i);
+        QueryItemPrice(item);
+    }
+}
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId)
+{
+    Player *bot = ai->GetBot();
+    QuestStatusMap const& questMap = bot->getQuestStatusMap();
+    for (QuestStatusMap::const_iterator i = questMap.begin(); i != questMap.end(); i++)
+    {
+        const Quest *questTemplate = sObjectMgr->GetQuestTemplate( i->first );
+        if( !questTemplate )
+            continue;
+
+        uint32 questId = questTemplate->GetQuestId();
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || (status == QUEST_STATE_COMPLETE && !bot->GetQuestRewardStatus(questId)))
+        {
+            QuestStatusData const& questStatus = i->second;
+            QueryQuestItem(itemId, questTemplate, &questStatus);
+        }
+    }
+}
+
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus)
+{
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (questTemplate->RequiredItemId[i] != itemId)
+            continue;
+
+        int required = questTemplate->RequiredItemCount[i];
+        int available = questStatus->ItemCount[i];
+
+        if (!required)
+            continue;
+
+        ai->TellMaster(chat->formatQuestObjective(chat->formatQuest(questTemplate), available, required));
+    }
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
new file mode 100644
index 0000000..643ae96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class QueryItemUsageAction : public InventoryAction {
+    public:
+        QueryItemUsageAction(PlayerbotAI* ai, string name = "query item usage") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        void QueryItemsUsage(ItemIds items);
+        bool QueryItemUsage(ItemTemplate const *item);
+        void QueryItemPrice(ItemTemplate const *item);
+        void QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus);
+        void QueryQuestItem(uint32 itemId);
+
+    private:
+        ostringstream out;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
new file mode 100644
index 0000000..33eddca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
@@ -0,0 +1,89 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryQuestAction.h"
+
+
+using namespace ai;
+
+void QueryQuestAction::TellObjective(string name, int available, int required)
+{
+    ai->TellMaster(chat->formatQuestObjective(name, available, required));
+}
+
+
+bool QueryQuestAction::Execute(Event event)
+{
+
+    Player *bot = ai->GetBot();
+    string text = event.getParam();
+
+    PlayerbotChatHandler ch(bot);
+    uint32 questId = ch.extractQuestId(text);
+    if (!questId)
+        return false;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        if(questId != bot->GetQuestSlotQuestId(slot))
+            continue;
+
+        ostringstream out;
+        out << "--- " << chat->formatQuest(sObjectMgr->GetQuestTemplate(questId)) << " ";
+        if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        {
+            out << "|c0000FF00completed|r ---";
+            ai->TellMaster(out);
+        }
+        else
+        {
+            out << "|c00FF0000not completed|r ---";
+            ai->TellMaster(out);
+            TellObjectives(questId);
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+void QueryQuestAction::TellObjectives(uint32 questId)
+{
+    Quest const* questTemplate = sObjectMgr->GetQuestTemplate(questId);
+    QuestStatusMap &questMap = bot->getQuestStatusMap();
+    QuestStatusData questStatus = questMap[questId];
+
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (!questTemplate->ObjectiveText[i].empty())
+            ai->TellMaster(questTemplate->ObjectiveText[i]);
+
+        if (questTemplate->RequiredItemId[i])
+        {
+            int required = questTemplate->RequiredItemCount[i];
+            int available = questStatus.ItemCount[i];
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(questTemplate->RequiredItemId[i]);
+            TellObjective(chat->formatItem(proto), available, required);
+        }
+
+        if (questTemplate->RequiredNpcOrGo[i])
+        {
+            int required = questTemplate->RequiredNpcOrGoCount[i];
+            int available = questStatus.CreatureOrGOCount[i];
+
+            if (questTemplate->RequiredNpcOrGo[i] < 0)
+            {
+                GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->name, available, required);
+            }
+            else
+            {
+
+                CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->Name, available, required);
+            }
+        }
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.h b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
new file mode 100644
index 0000000..1822293
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class QueryQuestAction : public Action {
+    public:
+        QueryQuestAction(PlayerbotAI* ai) : Action(ai, "query quest") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellObjectives(uint32 questId);
+        void TellObjective(string name, int available, int required);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.cpp b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
new file mode 100644
index 0000000..2b1cfbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool QuestAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!guid)
+    {
+        Unit* target = master->GetSelectedUnit();
+        if (target)
+            guid = target->GetGUID();
+    }
+
+    if (!guid)
+        return false;
+
+    return ProcessQuests(guid);
+}
+
+bool QuestAction::ProcessQuests(ObjectGuid questGiver)
+{
+    GameObject *gameObject = ai->GetGameObject(questGiver);
+    if (gameObject && gameObject->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+        return ProcessQuests(gameObject);
+
+    Creature* creature = ai->GetCreature(questGiver);
+    if (creature)
+        return ProcessQuests(creature);
+
+    return false;
+}
+
+bool QuestAction::ProcessQuests(WorldObject* questGiver)
+{
+    ObjectGuid guid = questGiver->GetGUID();
+
+    if (bot->GetDistance(questGiver) > INTERACTION_DISTANCE)
+    {
+        ai->TellMaster("Cannot talk to quest giver");
+        return false;
+    }
+
+    if (!bot->isInFront(questGiver, M_PI / 2))
+        bot->SetFacingTo(bot->GetAngle(questGiver));
+
+    bot->SetSelection(guid);
+    bot->PrepareQuestMenu(guid);
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 i = 0; i < questMenu.GetMenuItemCount(); ++i)
+    {
+        QuestMenuItem const& menuItem = questMenu.GetItem(i);
+        uint32 questID = menuItem.QuestId;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(questID);
+        if (!quest)
+            continue;
+
+        ProcessQuest(quest, questGiver);
+    }
+
+    return true;
+}
+
+bool QuestAction::AcceptQuest(Quest const* quest, uint64 questGiver)
+{
+    std::ostringstream out;
+
+    uint32 questId = quest->GetQuestId();
+
+    if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        out << "Already completed";
+    else if (! bot->CanTakeQuest(quest, false))
+    {
+        if (! bot->SatisfyQuestStatus(quest, false))
+            out << "Already on";
+        else
+            out << "Can't take";
+    }
+    else if (! bot->SatisfyQuestLog(false))
+        out << "Quest log is full";
+    else if (! bot->CanAddQuest(quest, false))
+        out << "Bags are full";
+
+    else
+    {
+        WorldPacket p(CMSG_QUESTGIVER_ACCEPT_QUEST);
+        uint32 unk1 = 0;
+        p << questGiver << questId << unk1;
+        p.rpos(0);
+        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+
+        if (bot->GetQuestStatus(questId) != QUEST_STATUS_NONE)
+        {
+            out << "Accepted " << chat->formatQuest(quest);
+            ai->TellMaster(out);
+            return true;
+        }
+    }
+
+    out << " " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+    return false;
+}
+
+bool QuestObjectiveCompletedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    uint32 entry, questId, available, required;
+    ObjectGuid guid;
+    p >> questId >> entry >> available >> required >> guid;
+
+    if (entry & 0x80000000)
+    {
+        entry &= 0x7FFFFFFF;
+        GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->name, available, required));
+    }
+    else
+    {
+        CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->Name, available, required));
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.h b/src/plugins/playerbot/strategy/actions/QuestAction.h
new file mode 100644
index 0000000..97010ed
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Quests/QuestDef.h"
+
+namespace ai
+{
+    class QuestAction : public Action
+    {
+    public:
+        QuestAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver) = 0;
+
+    protected:
+        bool AcceptQuest(Quest const* quest, uint64 questGiver);
+        bool ProcessQuests(ObjectGuid questGiver);
+        bool ProcessQuests(WorldObject* questGiver);
+    };
+
+    class QuestObjectiveCompletedAction : public Action
+    {
+    public:
+        QuestObjectiveCompletedAction(PlayerbotAI* ai) : Action(ai, "quest objective completed") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReachTargetActions.h b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
new file mode 100644
index 0000000..c988365
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ReachTargetAction : public MovementAction
+    {
+    public:
+        ReachTargetAction(PlayerbotAI* ai, string name, float distance) : MovementAction(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool Execute(Event event)
+		{
+			return MoveTo(AI_VALUE(Unit*, "current target"), distance);
+        }
+        virtual bool isUseful()
+		{
+            return AI_VALUE2(float, "distance", "current target") > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class CastReachTargetSpellAction : public CastSpellAction
+    {
+    public:
+        CastReachTargetSpellAction(PlayerbotAI* ai, string spell, float distance) : CastSpellAction(ai, spell)
+		{
+            this->distance = distance;
+        }
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(float, "distance", "current target") > distance;
+		}
+
+    protected:
+        float distance;
+    };
+
+    class ReachMeleeAction : public ReachTargetAction
+	{
+    public:
+        ReachMeleeAction(PlayerbotAI* ai) : ReachTargetAction(ai, "reach melee", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class ReachSpellAction : public ReachTargetAction
+	{
+    public:
+        ReachSpellAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : ReachTargetAction(ai, "reach spell", distance) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
new file mode 100644
index 0000000..98f8c4b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
@@ -0,0 +1,84 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReadyCheckAction.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+bool ReadyCheckAction::Execute(Event event)
+{
+    WorldPacket &p = event.getPacket();
+	ObjectGuid player;
+	p.rpos(0);
+    if (!p.empty())
+        p >> player;
+
+	if (player.GetRawValue() == bot->GetGUID())
+        return false;
+
+	return ReadyCheck();
+}
+
+bool ReadyCheckAction::ReadyCheck()
+{
+    bool health = AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.almostFullHealth;
+    if (!health)
+    {
+        ai->TellMaster("Low health!");
+        return false;
+    }
+
+    bool mana = !AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumHealth;
+    if (!mana)
+    {
+        ai->TellMaster("Low mana!");
+        return false;
+    }
+
+    Player* master = GetMaster();
+    if (master)
+    {
+        bool distance = bot->GetDistance(master) <= sPlayerbotAIConfig.sightDistance;
+        if (!distance)
+        {
+            ai->TellMaster("Too far away!");
+            return false;
+        }
+    }
+
+    if (bot->getClass() == CLASS_HUNTER)
+    {
+        if (!bot->GetUInt32Value(PLAYER_AMMO_ID))
+        {
+            ai->TellMaster("Out of ammo!");
+            return false;
+        }
+
+        if (!bot->GetPet())
+        {
+            ai->TellMaster("No pet!");
+            return false;
+        }
+
+        if (bot->GetPet()->GetHappinessState() == UNHAPPY)
+        {
+            ai->TellMaster("Pet is unhappy!");
+            return false;
+        }
+    }
+
+    WorldPacket* const packet = new WorldPacket(MSG_RAID_READY_CHECK);
+    *packet << bot->GetGUID();
+    *packet << uint8(1);
+    bot->GetSession()->QueuePacket(packet);
+
+    ai->ChangeStrategy("-ready check", BOT_STATE_NON_COMBAT);
+
+    return true;
+}
+
+bool FinishReadyCheckAction::Execute(Event event)
+{
+    return ReadyCheck();
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
new file mode 100644
index 0000000..0e26b61
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ReadyCheckAction : public Action
+    {
+    public:
+        ReadyCheckAction(PlayerbotAI* ai, string name = "ready check") : Action(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool ReadyCheck();
+    };
+
+    class FinishReadyCheckAction : public ReadyCheckAction
+    {
+    public:
+        FinishReadyCheckAction(PlayerbotAI* ai) : ReadyCheckAction(ai, "finish ready check") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
new file mode 100644
index 0000000..47ce1e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+	class ReleaseSpiritAction : public Action {
+	public:
+		ReleaseSpiritAction(PlayerbotAI* ai) : Action(ai, "release") {}
+
+    public:
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive() || bot->GetCorpse())
+                return false;
+
+            ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+            bot->SetBotDeathTimer();
+            bot->BuildPlayerRepop();
+
+            bot->RepopAtGraveyard();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
new file mode 100644
index 0000000..f4f387d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RememberTaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool RememberTaxiAction::Execute(Event event)
+{
+
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    switch (p.GetOpcode())
+    {
+    case CMSG_ACTIVATETAXI:
+        {
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            movement.taxiNodes.resize(2);
+
+            p >> movement.taxiMaster >> movement.taxiNodes[0] >> movement.taxiNodes[1];
+            return true;
+        }
+    case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            ObjectGuid guid;
+            uint32 node_count;
+            p >> guid >> node_count;
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                movement.taxiNodes.push_back(node);
+            }
+
+            return true;
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
new file mode 100644
index 0000000..16c1f07
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class RememberTaxiAction : public Action {
+	public:
+		RememberTaxiAction(PlayerbotAI* ai) : Action(ai, "remember taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
new file mode 100644
index 0000000..7104792
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RepairAllAction.h"
+
+
+using namespace ai;
+
+bool RepairAllAction::Execute(Event event)
+{
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_REPAIR);
+        if (!unit)
+            continue;
+
+        bot->SetFacingToObject(unit);
+        float discountMod = bot->GetReputationPriceDiscount(unit);
+        uint32 totalCost = bot->DurabilityRepairAll(true, discountMod, false);
+
+        ostringstream out;
+        out << "Repair: " << chat->formatMoney(totalCost) << " (" << unit->GetName() << ")";
+        ai->TellMasterNoFacing(out.str());
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any npc to repair at");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.h b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
new file mode 100644
index 0000000..2b4d96e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RepairAllAction : public Action
+    {
+    public:
+        RepairAllAction(PlayerbotAI* ai) : Action(ai, "repair") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
new file mode 100644
index 0000000..995f241
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ResetAiAction.h"
+
+using namespace ai;
+
+bool ResetAiAction::Execute(Event event)
+{
+    ai->ResetStrategies();
+    ai->TellMaster("AI was reset to defaults");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.h b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
new file mode 100644
index 0000000..929abcb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class ResetAiAction : public Action {
+    public:
+        ResetAiAction(PlayerbotAI* ai) : Action(ai, "reset ai") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
new file mode 100644
index 0000000..88e4a23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReviveFromCorpseAction.h"
+#include "../../PlayerbotFactory.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ReviveFromCorpseAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    time_t reclaimTime = corpse->GetGhostTime() + bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP );
+    if (reclaimTime > time(0) || corpse->GetDistance(bot) > sPlayerbotAIConfig.spellDistance)
+        return false;
+
+    bot->ResurrectPlayer(0.5f);
+    bot->SpawnCorpseBones();
+    bot->SaveToDB();
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    bot->SetSelection(ObjectGuid::Empty);
+    return true;
+}
+
+bool SpiritHealerAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit && unit->IsSpiritHealer())
+        {
+            PlayerbotChatHandler ch(bot);
+            bot->ResurrectPlayer(0.5f);
+            bot->SpawnCorpseBones();
+            bot->SaveToDB();
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid::Empty);
+            return true;
+        }
+    }
+
+    ai->TellMaster("Cannot find any spirit healer nearby");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
new file mode 100644
index 0000000..0e3a8cb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+	class ReviveFromCorpseAction : public Action {
+	public:
+		ReviveFromCorpseAction(PlayerbotAI* ai) : Action(ai, "revive") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+	class SpiritHealerAction : public Action {
+	public:
+	    SpiritHealerAction(PlayerbotAI* ai) : Action(ai, "spirit healer") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.cpp b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
new file mode 100644
index 0000000..c85db71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RewardAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool RewardAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    uint32 itemId = *itemIds.begin();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (npc && Reward(itemId, npc))
+            return true;
+    }
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go && Reward(itemId, go))
+            return true;
+    }
+
+    ai->TellMaster("Cannot talk to quest giver");
+    return false;
+}
+
+bool RewardAction::Reward(uint32 itemId, Object* questGiver)
+{
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+        QuestStatus status = bot->GetQuestStatus(questID);
+
+        // if quest is complete, turn it in
+        if (status == QUEST_STATUS_COMPLETE &&
+            ! bot->GetQuestRewardStatus(questID) &&
+            pQuest->GetRewChoiceItemsCount() > 1 &&
+            bot->CanRewardQuest(pQuest, false))
+        {
+            for (uint8 rewardIdx=0; rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+            {
+                ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                if (itemId == pRewardItem->ItemId)
+                {
+                    bot->RewardQuest(pQuest, rewardIdx, questGiver, false);
+
+                    string questTitle  = pQuest->GetTitle();
+                    string itemName = pRewardItem->Name1;
+
+                    ostringstream out; out << chat->formatItem(pRewardItem) << " rewarded";
+                    ai->TellMaster(out);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.h b/src/plugins/playerbot/strategy/actions/RewardAction.h
new file mode 100644
index 0000000..f4eda13
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class RewardAction : public InventoryAction {
+    public:
+        RewardAction(PlayerbotAI* ai) : InventoryAction(ai, "reward") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Reward(uint32 itemId, Object* pNpc);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RtiAction.h b/src/plugins/playerbot/strategy/actions/RtiAction.h
new file mode 100644
index 0000000..f0cca94
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RtiAction.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RtiAction : public Action
+    {
+    public:
+        RtiAction(PlayerbotAI* ai) : Action(ai, "rti")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            string text = event.getParam();
+            if (text.empty() || text == "?")
+            {
+                ostringstream out; out << "RTI: ";
+                AppendRti(out);
+                ai->TellMaster(out);
+                return true;
+            }
+
+            context->GetValue<string>("rti")->Set(text);
+            ostringstream out; out << "RTI set to: ";
+            AppendRti(out);
+            ai->TellMaster(out);
+            return true;
+        }
+
+    private:
+        void AppendRti(ostringstream & out)
+        {
+            out << AI_VALUE(string, "rti");
+
+            Unit* target = AI_VALUE(Unit*, "rti target");
+            if(target)
+                out << " (" << target->GetName() << ")";
+
+        }
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
new file mode 100644
index 0000000..c5d56a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SaveManaAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool SaveManaAction::Execute(Event event)
+{
+    string text = event.getParam();
+    double value = AI_VALUE(double, "mana save level");
+
+    if (text == "?")
+    {
+        ostringstream out; out << "Mana save level: " << format(value);
+        ai->TellMaster(out);
+        return true;
+    }
+
+    if (text == "*")
+    {
+        switch (bot->getClass())
+        {
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+        case CLASS_DRUID:
+            value = 5.0;
+            break;
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_WARLOCK:
+            value = 2.0;
+            break;
+        default:
+            value = 3.0;
+        }
+    }
+    else if (text.empty())
+    {
+        value = 1.0;
+    }
+    else
+    {
+        value = atof(text.c_str());
+    }
+
+    value = min(10.0, value);
+    value = max(1.0, value);
+    value = floor(value * 100 + 0.5) / 100.0;
+
+    ai->GetAiObjectContext()->GetValue<double>("mana save level")->Set(value);
+
+    ostringstream out; out << "Mana save level set: " << format(value);
+    ai->TellMaster(out);
+
+    return true;
+}
+
+string SaveManaAction::format(double value)
+{
+    ostringstream out;
+    if (value <= 1.0)
+        out << "|cFF808080";
+    else if (value <= 5.0)
+        out << "|cFF00FF00";
+    else if (value <= 7.0)
+        out << "|cFFFFFF00";
+    else
+        out << "|cFFFF0000";
+    out << value << "|cffffffff";
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.h b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
new file mode 100644
index 0000000..3d9b3e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SaveManaAction : public Action
+    {
+    public:
+        SaveManaAction(PlayerbotAI* ai) : Action(ai, "save mana") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        string format(double value);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
new file mode 100644
index 0000000..891b03c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "SecurityCheckAction.h"
+#include "../../../Groups/Group.h"
+
+using namespace ai;
+
+
+bool SecurityCheckAction::isUseful()
+{
+    return sRandomPlayerbotMgr.IsRandomBot(bot) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER;
+}
+
+bool SecurityCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        LootMethod method = group->GetLootMethod();
+        ItemQualities threshold = group->GetLootThreshold();
+        if (method == MASTER_LOOT || method == FREE_FOR_ALL || threshold > ITEM_QUALITY_UNCOMMON)
+        {
+            ai->TellMaster("I won't do anything until you change loot type to group loot with green threshold");
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_NON_COMBAT);
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_COMBAT);
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
new file mode 100644
index 0000000..4ae38f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class SecurityCheckAction : public Action
+    {
+    public:
+        SecurityCheckAction(PlayerbotAI* ai) : Action(ai, "security check") {}
+        virtual bool isUseful();
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.cpp b/src/plugins/playerbot/strategy/actions/SellAction.cpp
new file mode 100644
index 0000000..1af725c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.cpp
@@ -0,0 +1,95 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SellAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+class SellItemsVisitor : public IterateItemsVisitor
+{
+public:
+    SellItemsVisitor(SellAction* action) : IterateItemsVisitor()
+    {
+        this->action = action;
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        action->Sell(item);
+        return true;
+    }
+
+private:
+    SellAction* action;
+};
+
+class SellGrayItemsVisitor : public SellItemsVisitor
+{
+public:
+    SellGrayItemsVisitor(SellAction* action) : SellItemsVisitor(action) {}
+
+    virtual bool Visit(Item* item)
+    {
+        if (item->GetTemplate()->Quality != ITEM_QUALITY_POOR)
+            return true;
+
+        return SellItemsVisitor::Visit(item);
+    }
+};
+
+
+bool SellAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    string text = event.getParam();
+
+    if (text == "gray" || text == "*")
+    {
+        SellGrayItemsVisitor visitor(this);
+        IterateItems(&visitor);
+        return true;
+    }
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        Sell(&visitor);
+    }
+
+    return true;
+}
+
+
+void SellAction::Sell(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        Sell(*i);
+}
+
+void SellAction::Sell(Item* item)
+{
+    Player* master = GetMaster();
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+    {
+        ai->TellMaster("Select a vendor first");
+        return;
+    }
+
+    ObjectGuid itemguid = item->GetGUID();
+    uint32 count = item->GetCount();
+
+    WorldPacket p;
+    p << vendor->GetGUID() << itemguid << count;
+    bot->GetSession()->HandleSellItemOpcode(p);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " sold";
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.h b/src/plugins/playerbot/strategy/actions/SellAction.h
new file mode 100644
index 0000000..c1f0915
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SellAction : public InventoryAction {
+    public:
+        SellAction(PlayerbotAI* ai) : InventoryAction(ai, "sell") {}
+        virtual bool Execute(Event event);
+
+        void Sell(FindItemVisitor* visitor);
+        void Sell(Item* item);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
new file mode 100644
index 0000000..1b2d22f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SetHomeAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool SetHomeAction::Execute(Event event)
+{
+    Player* master = ai->GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (unit && unit->IsInnkeeper())
+    {
+        float angle = GetFollowAngle();
+        float x = unit->GetPositionX() + sPlayerbotAIConfig.followDistance * cos(angle);
+        float y = unit->GetPositionY() + sPlayerbotAIConfig.followDistance * sin(angle);
+        float z = unit->GetPositionZ();
+        WorldLocation loc(unit->GetMapId(), x, y, z);
+        bot->SetHomebind(loc, unit->GetAreaId());
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_INNKEEPER);
+        if (!unit)
+            continue;
+
+        bot->GetSession()->SendBindPoint(unit);
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    ai->TellMaster("Can't find any innkeeper around");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.h b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
new file mode 100644
index 0000000..b98a5b5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SetHomeAction : public MovementAction {
+    public:
+        SetHomeAction(PlayerbotAI* ai) : MovementAction(ai, "home") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.cpp b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
new file mode 100644
index 0000000..50f6669
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
@@ -0,0 +1,145 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsAction.h"
+
+
+using namespace ai;
+
+bool StatsAction::Execute(Event event)
+{
+    ostringstream out;
+
+    ListGold(out);
+
+    out << ", ";
+    ListBagSlots(out);
+
+    out << ", ";
+    ListRepairCost(out);
+
+    if (bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP))
+    {
+        out << ", ";
+        ListXP(out);
+    }
+
+    ai->TellMaster(out);
+    return true;
+}
+
+void StatsAction::ListGold(ostringstream &out)
+{
+    out << chat->formatMoney(bot->GetMoney());
+}
+
+void StatsAction::ListBagSlots(ostringstream &out)
+{
+    uint32 totalused = 0, total = 16;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+	string color = "ff00ff00";
+	if (totalfree < total / 2)
+		color = "ffffff00";
+	if (totalfree < total / 4)
+		color = "ffff0000";
+    out << "|h|c" << color << (total - totalfree) << "/" << total << "|h|cffffffff Bag";
+}
+
+void StatsAction::ListXP( ostringstream &out )
+{
+    uint32 curXP = bot->GetUInt32Value(PLAYER_XP);
+    uint32 nextLevelXP = bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 xpPercent = 0;
+    if (nextLevelXP)
+        xpPercent = 100 * curXP / nextLevelXP;
+
+    out << "|r|cff00ff00" << xpPercent << "|r|cffffd333%" << "|h|cffffffff XP";
+}
+
+void StatsAction::ListRepairCost(ostringstream &out)
+{
+    out << chat->formatMoney(EstRepairAll()) << " Repair";
+}
+
+uint32 StatsAction::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(( (INVENTORY_SLOT_BAG_0 << 8) | i ));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for(int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for(int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(( (j << 8) | i ));
+    return TotalCost;
+}
+
+uint32 StatsAction::EstRepair(uint16 pos)
+{
+    Item* item = bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if(!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if(!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if(LostDurability>0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if(!dcost)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if(!dQualitymodEntry)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class,ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+        if (costs==0)                                   //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.h b/src/plugins/playerbot/strategy/actions/StatsAction.h
new file mode 100644
index 0000000..e30558c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class StatsAction : public Action {
+    public:
+        StatsAction(PlayerbotAI* ai) : Action(ai, "stats") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListBagSlots(ostringstream &out);
+        void ListXP(ostringstream &out);
+        void ListRepairCost(ostringstream &out);
+        void ListGold(ostringstream &out);
+        uint32 EstRepairAll();
+        uint32 EstRepair(uint16 pos);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.cpp b/src/plugins/playerbot/strategy/actions/StayActions.cpp
new file mode 100644
index 0000000..32ebd0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayActions.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+void StayActionBase::Stay()
+{
+    AI_VALUE(LastMovement&, "last movement").Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (mm.GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE || bot->IsFlying())
+        return;
+
+    mm.Clear();
+    mm.MoveIdle();
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    if (!bot->IsStandState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+bool StayAction::Execute(Event event)
+{
+    Stay();
+
+    return true;
+}
+
+bool StayAction::isUseful()
+{
+    return !AI_VALUE2(bool, "moving", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.h b/src/plugins/playerbot/strategy/actions/StayActions.h
new file mode 100644
index 0000000..ccbe2e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class StayActionBase : public MovementAction {
+    public:
+        StayActionBase(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    protected:
+        void Stay();
+    };
+
+    class StayAction : public StayActionBase {
+    public:
+        StayAction(PlayerbotAI* ai) : StayActionBase(ai, "stay") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
new file mode 100644
index 0000000..fb975e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
@@ -0,0 +1,256 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SuggestWhatToDoAction.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+SuggestWhatToDoAction::SuggestWhatToDoAction(PlayerbotAI* ai) : InventoryAction(ai, "suggest what to do"), suggested(false)
+{
+    suggestions.push_back(&SuggestWhatToDoAction::instance);
+    suggestions.push_back(&SuggestWhatToDoAction::specificQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::newQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::grindMaterials);
+    suggestions.push_back(&SuggestWhatToDoAction::trade);
+    suggestions.push_back(&SuggestWhatToDoAction::grindReputation);
+    suggestions.push_back(&SuggestWhatToDoAction::nothing);
+    suggestions.push_back(&SuggestWhatToDoAction::relax);
+    suggestions.push_back(&SuggestWhatToDoAction::achievement);
+}
+
+bool SuggestWhatToDoAction::Execute(Event event)
+{
+    if (suggested)
+    {
+        trade();
+        return true;
+    }
+
+    if (bot->GetInstanceId() || suggested)
+        return false;
+
+    // FEYZEE: disable bot suggestions
+    //int index = rand() % suggestions.size();
+    //(this->*suggestions[index])();
+
+    return suggested = true;
+}
+
+void SuggestWhatToDoAction::instance()
+{
+    uint32 level = bot->getLevel();
+    if (level > 15)
+    {
+        switch (urand(0, 5))
+        {
+        case 0:
+            spam("Need a tank for an instance run");
+            break;
+        case 1:
+            spam("Need a healer for an instance run");
+            break;
+        case 2:
+            spam("I would like to do an instance run. Would you like to join me?");
+            break;
+        case 3:
+            spam("Need better equipment. Why not do an instance run?");
+            break;
+        case 4:
+            spam("Have dungeon quests? Can join your group!");
+            break;
+        case 5:
+            spam("Have group quests? Invite me!");
+            break;
+        default:
+            spam("Hey, why not join Dungeon Finder?");
+        }
+    }
+}
+
+vector<uint32> SuggestWhatToDoAction::GetIncompletedQuests()
+{
+    vector<uint32> result;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || status == QUEST_STATUS_NONE)
+            result.push_back(questId);
+    }
+
+    return result;
+}
+
+void SuggestWhatToDoAction::specificQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.empty())
+        return;
+
+    int index = rand() % quests.size();
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(quests[index]);
+    ostringstream out; out << "We could do some quest, for instance " << chat->formatQuest(quest);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::newQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.size() < MAX_QUEST_LOG_SIZE - 5)
+        spam("I would like to pick up and do a new quest. Just invite me!");
+}
+
+void SuggestWhatToDoAction::grindMaterials()
+{
+    if (bot->getLevel() <= 5)
+        return;
+
+    switch (urand(0, 5))
+    {
+    case 0:
+        spam("Need help for tradeskill?");
+        break;
+    case 1:
+        spam("Can we have some trade material grinding?");
+        break;
+    case 2:
+        spam("I have some trade materials for sell");
+        break;
+    default:
+        spam("I am going to grind some trade materials. Would you like to join me?");
+    }
+}
+
+void SuggestWhatToDoAction::grindReputation()
+{
+    if (bot->getLevel() > 15)
+        ai->TellMasterNoFacing("I think we should do something to improve our reputation", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::nothing()
+{
+    ai->TellMasterNoFacing("I don't want to do anything", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::relax()
+{
+    ai->TellMasterNoFacing("It is so boring... We could relax a bit", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::achievement()
+{
+    if (bot->getLevel() > 15)
+        spam("I would like to get some achievement. Would you like to join me?");
+}
+
+class FindTradeItemsVisitor : public IterateItemsVisitor
+{
+public:
+    FindTradeItemsVisitor(uint32 quality) : quality(quality), IterateItemsVisitor() {}
+
+    virtual bool Visit(Item* item)
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (proto->Quality != quality)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS && proto->Bonding == NO_BIND)
+        {
+            if(proto->Quality == ITEM_QUALITY_NORMAL && item->GetCount() > 1 && item->GetCount() == item->GetMaxStackCount())
+                stacks.push_back(proto->ItemId);
+
+            items.push_back(proto->ItemId);
+            count[proto->ItemId] += item->GetCount();
+        }
+
+        return true;
+    }
+
+    map<uint32, int > count;
+    vector<uint32> stacks;
+    vector<uint32> items;
+
+private:
+    uint32 quality;
+};
+
+
+void SuggestWhatToDoAction::trade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    uint32 quality = urand(0, 100);
+    if (quality > 90)
+        quality = ITEM_QUALITY_EPIC;
+    else if (quality >75)
+        quality = ITEM_QUALITY_RARE;
+    else if (quality > 50)
+        quality = ITEM_QUALITY_UNCOMMON;
+    else
+        quality = ITEM_QUALITY_NORMAL;
+
+    uint32 item = 0, count = 0;
+    while (quality-- > ITEM_QUALITY_POOR)
+    {
+        FindTradeItemsVisitor visitor(quality);
+        IterateItems(&visitor);
+        if (!visitor.stacks.empty())
+        {
+            int index = urand(0, visitor.stacks.size() - 1);
+            item = visitor.stacks[index];
+        }
+
+        if (!item)
+        {
+            if (!visitor.items.empty())
+            {
+                int index = urand(0, visitor.items.size() - 1);
+                item = visitor.items[index];
+            }
+        }
+
+        if (item)
+        {
+            count = visitor.count[item];
+            break;
+        }
+    }
+
+    if (!item || !count)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item);
+    if (!proto)
+        return;
+
+    uint32 price = auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * count;
+    if (!price)
+        return;
+
+    ostringstream out; out << "Selling " << chat->formatItem(proto, count) << " for " << chat->formatMoney(price);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::spam(string msg)
+{
+    Player* player = sRandomPlayerbotMgr.GetRandomPlayer();
+    if (!player || !player->IsInWorld())
+        return;
+
+    if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_TALK, true, player))
+        return;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            player->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != player->GetMapId() || bot->GetDistance(player) > sPlayerbotAIConfig.whisperDistance))
+        return;
+
+    bot->Whisper(msg, LANG_UNIVERSAL, player);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
new file mode 100644
index 0000000..750bb08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SuggestWhatToDoAction : public InventoryAction
+    {
+    public:
+        SuggestWhatToDoAction(PlayerbotAI* ai);
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (SuggestWhatToDoAction::*Suggestion) ();
+        vector<Suggestion> suggestions;
+
+    private:
+        void instance();
+        void specificQuest();
+        void newQuest();
+        void grindMaterials();
+        void grindReputation();
+        void nothing();
+        void relax();
+        void achievement();
+        void trade();
+        void spam(string msg);
+
+        vector<uint32> GetIncompletedQuests();
+
+    private:
+        bool suggested;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
new file mode 100644
index 0000000..747abb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TalkToQuestGiverAction.h"
+
+
+using namespace ai;
+
+void TalkToQuestGiverAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    std::ostringstream out; out << "Quest ";
+
+    QuestStatus status = bot->GetQuestStatus(quest->GetQuestId());
+    switch (status)
+    {
+    case QUEST_STATUS_COMPLETE:
+        TurnInQuest(quest, questGiver, out);
+        break;
+    case QUEST_STATUS_INCOMPLETE:
+        out << "|cffff0000Incompleted|r";
+        break;
+    case QUEST_STATUS_NONE:
+        out << "|cff00ff00Available|r";
+        break;
+    case QUEST_STATUS_FAILED:
+        out << "|cffff0000Failed|r";
+        break;
+    }
+
+    out << ": " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+}
+
+void TalkToQuestGiverAction::TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    uint32 questID = quest->GetQuestId();
+
+    if (bot->GetQuestRewardStatus(questID))
+        return;
+
+    if (quest->GetRewChoiceItemsCount() == 0)
+        RewardNoItem(quest, questGiver, out);
+    else if (quest->GetRewChoiceItemsCount() == 1)
+        RewardSingleItem(quest, questGiver, out);
+    else {
+        AskToSelectReward(quest, out);
+    }
+}
+
+void TalkToQuestGiverAction::RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    if (bot->CanRewardQuest(quest, false))
+    {
+        bot->RewardQuest(quest, 0, questGiver, false);
+        out << "Completed";
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in|r";
+    }
+}
+
+void TalkToQuestGiverAction::RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    int index = 0;
+    ItemTemplate const *item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[index]);
+    if (bot->CanRewardQuest(quest, index, false))
+    {
+        bot->RewardQuest(quest, index, questGiver, true);
+
+        out << "Rewarded " << chat->formatItem(item);
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in:|r, reward: " << chat->formatItem(item);
+    }
+}
+
+void TalkToQuestGiverAction::AskToSelectReward(Quest const* quest, ostringstream& out)
+{
+    ostringstream msg;
+    msg << "Choose reward: ";
+    for (uint8 i=0; i < quest->GetRewChoiceItemsCount(); ++i)
+    {
+        ItemTemplate const* item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[i]);
+        msg << chat->formatItem(item);
+    }
+    ai->TellMaster(msg);
+
+    out << "Reward pending";
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
new file mode 100644
index 0000000..374dc69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class TalkToQuestGiverAction : public QuestAction {
+    public:
+        TalkToQuestGiverAction(PlayerbotAI* ai) : QuestAction(ai, "talk to quest giver") {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+
+    private:
+        void TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void AskToSelectReward(Quest const* quest, ostringstream& out);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.cpp b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
new file mode 100644
index 0000000..8037679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TaxiAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    WorldPacket& p = event.getPacket();
+	if (!p.empty() && p.GetOpcode() == CMSG_MOVE_SPLINE_DONE)
+    {
+        WorldPacket p1(p);
+        p1.rpos(0);
+        bot->GetSession()->HandleMoveSplineDoneOpcode(p1);
+        movement.taxiNodes.clear();
+        movement.Set(NULL);
+        return true;
+    }
+
+    list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Creature *npc = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_FLIGHTMASTER);
+        if (!npc)
+            continue;
+
+        if (movement.taxiNodes.empty())
+        {
+            ostringstream out;
+            out << "I will order the taxi from " << npc->GetName() << ". Please start flying, then instruct me again";
+            ai->TellMaster(out);
+            return true;
+        }
+
+        if (!bot->ActivateTaxiPathTo(movement.taxiNodes, npc))
+        {
+            ai->TellMaster("I can't fly with you");
+            return false;
+        }
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any flightmaster to talk");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.h b/src/plugins/playerbot/strategy/actions/TaxiAction.h
new file mode 100644
index 0000000..84bbe4d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class TaxiAction : public Action {
+	public:
+		TaxiAction(PlayerbotAI* ai) : Action(ai, "taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.cpp b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
new file mode 100644
index 0000000..ef82a7a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TeleportAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TeleportAction::Execute(Event event)
+{
+    list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go)
+            continue;
+
+        GameObjectTemplate const *goInfo = go->GetGOInfo();
+        if (goInfo->type != GAMEOBJECT_TYPE_SPELLCASTER)
+            continue;
+
+        uint32 spellId = goInfo->spellcaster.spellId;
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Effects[0].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[1].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[2].Effect != SPELL_EFFECT_TELEPORT_UNITS)
+            continue;
+
+        ostringstream out; out << "Teleporting using " << goInfo->name;
+        ai->TellMasterNoFacing(out.str());
+
+        ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        SpellCastTargets targets;
+        targets.SetUnitTarget(bot);
+        spell->prepare(&targets);
+        spell->cast(true);
+        return true;
+    }
+
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+    if (movement.lastAreaTrigger)
+    {
+        WorldPacket p(CMSG_AREATRIGGER);
+        p << movement.lastAreaTrigger;
+        p.rpos(0);
+
+        bot->GetSession()->HandleAreaTriggerOpcode(p);
+        movement.lastAreaTrigger = 0;
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any portal to teleport");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.h b/src/plugins/playerbot/strategy/actions/TeleportAction.h
new file mode 100644
index 0000000..96b5973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class TeleportAction : public Action {
+	public:
+		TeleportAction(PlayerbotAI* ai) : Action(ai, "teleport") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
new file mode 100644
index 0000000..2469816
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellCastFailedAction.h"
+
+
+using namespace ai;
+
+bool TellCastFailedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 castCount, result;
+    uint32 spellId;
+    p >> castCount >> spellId >> result;
+    ai->SpellInterrupted(spellId);
+
+    if (result == SPELL_CAST_OK)
+        return false;
+
+    const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+    ostringstream out; out << chat->formatSpell(pSpellInfo) << ": ";
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_READY:
+        out << "not ready";
+        break;
+    case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
+        out << "requires spell focus";
+        break;
+    case SPELL_FAILED_REQUIRES_AREA:
+        out << "cannot cast here";
+        break;
+    case SPELL_FAILED_TOTEMS:
+    case SPELL_FAILED_TOTEM_CATEGORY:
+        out << "requires totem";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
+        out << "requires item";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND:
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND:
+        out << "requires weapon";
+        break;
+    case SPELL_FAILED_PREVENTED_BY_MECHANIC:
+        out << "interrupted";
+        break;
+    default:
+        out << "cannot cast";
+    }
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    int32 castTime = spell->GetCastTime();
+    delete spell;
+
+    if (castTime >= 2000)
+        ai->TellMasterNoFacing(out.str());
+
+    return true;
+}
+
+
+bool TellSpellAction::Execute(Event event)
+{
+    string spell = event.getParam();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    if (!spellId)
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId );
+    if (!spellInfo)
+        return false;
+
+    ostringstream out; out << chat->formatSpell(spellInfo);
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
new file mode 100644
index 0000000..1de906a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellSpellAction : public Action
+    {
+    public:
+        TellSpellAction(PlayerbotAI* ai) : Action(ai, "spell") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class TellCastFailedAction : public Action
+    {
+    public:
+        TellCastFailedAction(PlayerbotAI* ai) : Action(ai, "tell cast failed") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
new file mode 100644
index 0000000..fdbe0d3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellItemCountAction.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TellItemCountAction::Execute(Event event)
+{
+    string text = event.getParam();
+    list<Item*> found = parseItems(text);
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TellItem((*i)->GetTemplate(), (*i)->GetCount());
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.h b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
new file mode 100644
index 0000000..093b0e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TellItemCountAction : public InventoryAction {
+    public:
+        TellItemCountAction(PlayerbotAI* ai) : InventoryAction(ai, "c") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.cpp b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
new file mode 100644
index 0000000..02227f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellLosAction.h"
+
+
+using namespace ai;
+
+bool TellLosAction::Execute(Event event)
+{
+    string param = event.getParam();
+
+    if (param.empty() || param == "targets")
+    {
+        list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+        ListUnits("--- Targets ---", targets);
+    }
+
+    if (param.empty() || param == "npcs")
+    {
+        list<ObjectGuid> npcs = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+        ListUnits("--- NPCs ---", npcs);
+    }
+
+    if (param.empty() || param == "corpses")
+    {
+        list<ObjectGuid> corpses = *context->GetValue<list<ObjectGuid> >("nearest corpses");
+        ListUnits("--- Corpses ---", corpses);
+    }
+
+    if (param.empty() || param == "gos" || param == "game objects")
+    {
+        list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+        ListGameObjects("--- Game objects ---", gos);
+    }
+
+    return true;
+}
+
+void TellLosAction::ListUnits(string title, list<ObjectGuid> units)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit)
+            ai->TellMaster(unit->GetName());
+    }
+
+}
+void TellLosAction::ListGameObjects(string title, list<ObjectGuid> gos)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go)
+            ai->TellMaster(chat->formatGameobject(go));
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.h b/src/plugins/playerbot/strategy/actions/TellLosAction.h
new file mode 100644
index 0000000..15d83fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellLosAction : public Action {
+    public:
+        TellLosAction(PlayerbotAI* ai) : Action(ai, "los") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListUnits(string title, list<ObjectGuid> units);
+        void ListGameObjects(string title, list<ObjectGuid> gos);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellMasterAction.h b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
new file mode 100644
index 0000000..4174708
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellMasterAction : public Action {
+    public:
+        TellMasterAction(PlayerbotAI* ai, string text) : Action(ai, "tell master"), text(text) {}
+
+        virtual bool Execute(Event event)
+        {
+            ai->TellMaster(text);
+            return true;
+        }
+
+    private:
+        string text;
+    };
+
+    class OutOfReactRangeAction : public MovementAction {
+    public:
+        OutOfReactRangeAction(PlayerbotAI* ai) : MovementAction(ai, "tell out of react range") {}
+
+        virtual bool Execute(Event event)
+        {
+            bool canFollow = Follow(AI_VALUE(Unit*, "master target"));
+            if (!canFollow)
+            {
+                ai->SetNextCheckDelay(5000);
+                return false;
+            }
+
+            ai->TellMaster("Wait for me!");
+            return true;
+        }
+   };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
new file mode 100644
index 0000000..f1bd104
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
@@ -0,0 +1,68 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellReputationAction.h"
+#include "../../../Reputation/ReputationMgr.h"
+
+
+using namespace ai;
+
+bool TellReputationAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (!unit)
+        return false;
+
+    const FactionTemplateEntry *factionTemplate = unit->GetFactionTemplateEntry();
+    uint32 faction = factionTemplate->faction;
+    const FactionEntry* entry = sFactionStore.LookupEntry(faction);
+    int32 reputation = bot->GetReputationMgr().GetReputation(faction);
+
+    ostringstream out;
+    out << entry->name[0] << ": ";
+    out << "|cff";
+    ReputationRank rank = bot->GetReputationMgr().GetRank(entry);
+    switch (rank) {
+        case REP_HATED:
+            out << "cc2222hated";
+            break;
+        case REP_HOSTILE:
+            out << "ff0000hostile";
+            break;
+        case REP_UNFRIENDLY:
+            out << "ee6622unfriendly";
+            break;
+        case REP_NEUTRAL:
+            out << "ffff00neutral";
+            break;
+        case REP_FRIENDLY:
+            out << "00ff00friendly";
+            break;
+        case REP_HONORED:
+            out << "00ff88honored";
+            break;
+        case REP_REVERED:
+            out << "00ffccrevered";
+            break;
+        case REP_EXALTED:
+            out << "00ffffexalted";
+            break;
+        default:
+            out << "808080unknown";
+            break;
+    }
+
+    out << "|cffffffff";
+
+    int32 base = ReputationMgr::Reputation_Cap + 1;
+    for (int i = MAX_REPUTATION_RANK - 1; i >= rank; --i)
+        base -= ReputationMgr::PointsInRank[i];
+
+    out << " (" << (reputation - base) << "/" << ReputationMgr::PointsInRank[rank] << ")";
+    ai->TellMaster(out);
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.h b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
new file mode 100644
index 0000000..449e67f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellReputationAction : public Action {
+    public:
+        TellReputationAction(PlayerbotAI* ai) : Action(ai, "reputation") {}
+        virtual bool Execute(Event event);
+
+    private:
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
new file mode 100644
index 0000000..a302772
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetAction.h"
+
+
+using namespace ai;
+
+bool TellTargetAction::Execute(Event event)
+{
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    if (target)
+    {
+        ostringstream out;
+		out << "Attacking " << target->GetName();
+        ai->TellMaster(out);
+
+        context->GetValue<Unit*>("old target")->Set(target);
+    }
+    return true;
+}
+
+bool TellAttackersAction::Execute(Event event)
+{
+    ai->TellMaster("--- Attackers ---");
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        ai->TellMaster(unit->GetName());
+    }
+
+    ai->TellMaster("--- Threat ---");
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        ostringstream out; out << unit->GetName() << " (" << threat << ")";
+        ai->TellMaster(out);
+
+        ref = ref->next();
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.h b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
new file mode 100644
index 0000000..7995100
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellTargetAction : public Action
+    {
+    public:
+        TellTargetAction(PlayerbotAI* ai) : Action(ai, "tell target") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TellAttackersAction : public Action
+    {
+    public:
+        TellAttackersAction(PlayerbotAI* ai) : Action(ai, "tell attackers") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.cpp b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
new file mode 100644
index 0000000..62f1c45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TradeAction::Execute(Event event)
+{
+    string text = event.getParam();
+    uint32 copper = chat->parseMoney(text);
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    int8 slot = -1;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TradeItem(**i, slot);
+
+    return true;
+}
+
+bool TradeAction::TradeItem(const Item& item, int8 slot)
+{
+    if (!bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    if (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED)
+        slot = TRADE_SLOT_NONTRADED;
+
+    int8 tradeSlot = -1;
+    Item* itemPtr = const_cast<Item*>(&item);
+
+    TradeData* pTrade = bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+
+    if (slot == TRADE_SLOT_NONTRADED)
+        pTrade->SetItem(TRADE_SLOT_NONTRADED, itemPtr);
+    else
+    {
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == itemPtr)
+            {
+                tradeSlot = i;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_CLEAR_TRADE_ITEM, 1);
+                *packet << (uint8) tradeSlot;
+                bot->GetSession()->QueuePacket(packet);
+                pTrade->SetItem(TradeSlots(i), NULL);
+                return true;
+            }
+        }
+
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                pTrade->SetItem(TradeSlots(i), itemPtr);
+                tradeSlot = i;
+            }
+        }
+    }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+        << (uint8) item.GetSlot();
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.h b/src/plugins/playerbot/strategy/actions/TradeAction.h
new file mode 100644
index 0000000..050a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TradeAction : public InventoryAction {
+    public:
+        TradeAction(PlayerbotAI* ai) : InventoryAction(ai, "trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(const Item& item, int8 slot);
+
+        static map<string, uint32> slots;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
new file mode 100644
index 0000000..df30a5c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
@@ -0,0 +1,216 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeStatusAction.h"
+
+#include "../ItemVisitors.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../GuildTaskMgr.h"
+#include "../values/ItemUsageValue.h"
+
+using namespace ai;
+
+
+
+bool TradeStatusAction::Execute(Event event)
+{
+    Player* trader = bot->GetTrader();
+    Player* master = GetMaster();
+    if (!trader)
+        return false;
+
+    if (trader != master)
+    {
+		bot->Whisper("I'm kind of busy now", LANG_UNIVERSAL, trader);
+    }
+
+    if (trader != master || !ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, true, master))
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+        bot->GetSession()->HandleCancelTradeOpcode(p);
+        return false;
+    }
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint32 status;
+    p >> status;
+
+    if (status == TRADE_STATUS_TRADE_ACCEPT)
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+
+        if (CheckTrade())
+        {
+            int32 botMoney = CalculateCost(bot->GetTradeData(), true);
+
+            map<uint32, uint32> itemIds;
+            for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+            {
+                Item* item = master->GetTradeData()->GetItem((TradeSlots)slot);
+                if (item)
+                    itemIds[item->GetTemplate()->ItemId] += item->GetCount();
+            }
+
+            bot->GetSession()->HandleAcceptTradeOpcode(p);
+            if (bot->GetTradeData())
+                return false;
+
+            for (map<uint32, uint32>::iterator i = itemIds.begin(); i != itemIds.end(); ++i)
+                sGuildTaskMgr.CheckItemTask(i->first, i->second, master, bot);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                int32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                sRandomPlayerbotMgr.SetLootAmount(bot, max(0, lootAmount - botMoney * 10));
+            }
+            return true;
+        }
+    }
+    else if (status == TRADE_STATUS_BEGIN_TRADE)
+    {
+        if (!bot->isInFront(trader, M_PI / 2))
+            bot->SetFacingToObject(trader);
+        BeginTrade();
+        return true;
+    }
+
+    return false;
+}
+
+
+void TradeStatusAction::BeginTrade()
+{
+    WorldPacket p;
+    bot->GetSession()->HandleBeginTradeOpcode(p);
+
+    ListItemsVisitor visitor;
+    IterateItems(&visitor);
+
+    ai->TellMaster("=== Trade ===");
+    TellItems(visitor.items);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(bot))
+    {
+        uint32 discount = sRandomPlayerbotMgr.GetTradeDiscount(bot);
+        if (discount)
+        {
+            ostringstream out; out << "Discount up to: " << chat->formatMoney(discount);
+            ai->TellMaster(out);
+        }
+    }
+}
+
+bool TradeStatusAction::CheckTrade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return true;
+
+    Player* master = GetMaster();
+    if (!bot->GetTradeData() || !master->GetTradeData())
+        return false;
+
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = bot->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item && !auctionbot.GetSellPrice(item->GetTemplate()))
+        {
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate()) << " - This is not for sale";
+            ai->TellMaster(out);
+            return false;
+        }
+
+        item = master->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item)
+        {
+            ostringstream out; out << item->GetTemplate()->ItemId;
+            ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+            if (!auctionbot.GetBuyPrice(item->GetTemplate()) || usage == ITEM_USAGE_NONE)
+            {
+                ostringstream out;
+                out << chat->formatItem(item->GetTemplate()) << " - I don't need this";
+                ai->TellMaster(out);
+                return false;
+            }
+        }
+    }
+
+    int32 botItemsMoney = CalculateCost(bot->GetTradeData(), true);
+    int32 botMoney = bot->GetTradeData()->GetMoney() + botItemsMoney;
+    int32 playerItemsMoney = CalculateCost(master->GetTradeData(), false);
+    int32 playerMoney = master->GetTradeData()->GetMoney() + playerItemsMoney;
+
+    if (!botMoney && !playerMoney)
+        return true;
+
+    if (!botItemsMoney && !playerItemsMoney)
+    {
+        ai->TellMaster("There are no items to trade");
+        return false;
+    }
+
+    int32 discount = min(botItemsMoney, (int32)sRandomPlayerbotMgr.GetTradeDiscount(bot));
+    botMoney = max(0, botMoney - discount);
+
+    if (playerMoney >= botMoney)
+    {
+        switch (urand(0, 4)) {
+        case 0:
+            ai->TellMaster("A pleasure doing business with you");
+            break;
+        case 1:
+            ai->TellMaster("Fair trade");
+            break;
+        case 2:
+            ai->TellMaster("Thanks");
+            break;
+        case 3:
+            ai->TellMaster("Off with you");
+            break;
+        }
+        return true;
+    }
+
+    ostringstream out;
+    out << "I want " << chat->formatMoney(botMoney - playerMoney) << " for this";
+    ai->TellMaster(out);
+    return false;
+}
+
+int32 TradeStatusAction::CalculateCost(TradeData* data, bool sell)
+{
+    if (!data)
+        return 0;
+
+    uint32 sum = 0;
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = data->GetItem((TradeSlots)slot);
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        if (proto->Quality < ITEM_QUALITY_NORMAL)
+            return 0;
+
+        if (sell)
+        {
+            sum += item->GetCount() * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+        }
+        else
+        {
+            sum += item->GetCount() * auctionbot.GetBuyPrice(proto) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+        }
+    }
+
+    return sum;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.h b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
new file mode 100644
index 0000000..7500a64
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+#include "QueryItemUsageAction.h"
+
+namespace ai
+{
+    class TradeStatusAction : public QueryItemUsageAction
+    {
+    public:
+        TradeStatusAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "accept trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void BeginTrade();
+        bool CheckTrade();
+        int32 CalculateCost(TradeData* data, bool sell);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.cpp b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
new file mode 100644
index 0000000..e261a2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
@@ -0,0 +1,114 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TrainerAction.h"
+
+using namespace ai;
+
+void TrainerAction::Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg)
+{
+    if (bot->GetMoney() < cost)
+        return;
+
+    bot->ModifyMoney(-int32(cost));
+    if (tSpell->IsCastable())
+        bot->CastSpell(bot, tSpell->spell, true);
+    else
+        bot->LearnSpell(tSpell->learnedSpell[0], false, false);
+
+    msg << " - learned";
+}
+
+void TrainerAction::List(Creature* creature, TrainerSpellAction action, SpellIds& spells)
+{
+    TellHeader(creature);
+
+    TrainerSpellData const* trainer_spells = creature->GetTrainerSpells();
+    float fDiscountMod =  bot->GetReputationPriceDiscount(creature);
+    uint32 totalCost = 0;
+
+    for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        if (!tSpell)
+            continue;
+
+        if (!tSpell->learnedSpell && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+            continue;
+
+        TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+        if (state != TRAINER_SPELL_GREEN)
+            continue;
+
+        uint32 spellId = tSpell->spell;
+        const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+        totalCost += cost;
+
+        ostringstream out;
+        out << chat->formatSpell(pSpellInfo) << chat->formatMoney(cost);
+
+        if (action && (spells.empty() || spells.find(tSpell->spell) != spells.end() || spells.find(tSpell->learnedSpell[0]) != spells.end()))
+            (this->*action)(cost, tSpell, out);
+
+        ai->TellMaster(out);
+    }
+
+    TellFooter(totalCost);
+}
+
+
+bool TrainerAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+        return false;
+
+    Creature *creature = ai->GetCreature(target->GetGUID());
+    if (!creature)
+        return false;
+
+    // check present spell in trainer spell list
+    TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+    if (!cSpells)
+    {
+        ai->TellMaster("No spells can be learned from this trainer");
+        return false;
+    }
+
+    uint32 spell = chat->parseSpell(text);
+    SpellIds spells;
+    if (spell)
+        spells.insert(spell);
+
+    if (text == "learn")
+        List(creature, &TrainerAction::Learn, spells);
+    else
+        List(creature, NULL, spells);
+
+    return true;
+}
+
+void TrainerAction::TellHeader(Creature* creature)
+{
+    ostringstream out; out << "--- can learn from " << creature->GetName() << " ---";
+    ai->TellMaster(out);
+}
+
+void TrainerAction::TellFooter(uint32 totalCost)
+{
+    if (totalCost)
+    {
+        ostringstream out; out << "Total cost: " << chat->formatMoney(totalCost);
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.h b/src/plugins/playerbot/strategy/actions/TrainerAction.h
new file mode 100644
index 0000000..3dbe18f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class TrainerAction : public Action {
+	public:
+		TrainerAction(PlayerbotAI* ai) : Action(ai, "trainer") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (TrainerAction::*TrainerSpellAction)(uint32, TrainerSpell const*, ostringstream& msg);
+        void List(Creature* creature, TrainerSpellAction action, SpellIds& spells);
+        void Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg);
+        void TellHeader(Creature* creature);
+        void TellFooter(uint32 totalCost);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.cpp b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
new file mode 100644
index 0000000..cf70f80
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UnequipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool UnequipAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        UnequipItem(&visitor);
+    }
+
+    return true;
+}
+
+
+void UnequipAction::UnequipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor, ITERATE_ALL_ITEMS);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) UnequipItem(**items.begin());
+}
+
+void UnequipAction::UnequipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 dstBag = NULL_BAG;
+
+
+    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_BAG_ITEM, 3);
+    *packet << bagIndex << slot << dstBag;
+    bot->GetSession()->QueuePacket(packet);
+
+    ostringstream out; out << chat->formatItem(item.GetTemplate()) << " unequipped";
+    ai->TellMaster(out);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.h b/src/plugins/playerbot/strategy/actions/UnequipAction.h
new file mode 100644
index 0000000..fdf7ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class UnequipAction : public InventoryAction {
+    public:
+        UnequipAction(PlayerbotAI* ai) : InventoryAction(ai, "unequip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void UnequipItem(Item& item);
+        void UnequipItem(FindItemVisitor* visitor);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.cpp b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
new file mode 100644
index 0000000..1ec05bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
@@ -0,0 +1,302 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseItemAction.h"
+
+using namespace ai;
+
+bool UseItemAction::Execute(Event event)
+{
+    string name = event.getParam();
+    if (name.empty())
+        name = getName();
+
+    list<Item*> items = AI_VALUE2(list<Item*>, "inventory items", name);
+    list<ObjectGuid> gos = chat->parseGameobjects(name);
+
+    if (gos.empty())
+    {
+        if (items.size() > 1)
+        {
+            list<Item*>::iterator i = items.begin();
+            Item* itemTarget = *i++;
+            Item* item = *i;
+            return UseItemOnItem(item, itemTarget);
+        }
+        else if (!items.empty())
+            return UseItemAuto(*items.begin());
+    }
+    else
+    {
+        if (items.empty())
+            return UseGameObject(*gos.begin());
+        else
+            return UseItemOnGameObject(*items.begin(), *gos.begin());
+    }
+
+    ai->TellMaster("No items (or game objects) available");
+    return false;
+}
+
+bool UseItemAction::UseGameObject(ObjectGuid guid)
+{
+    GameObject* go = ai->GetGameObject(guid);
+    if (!go || !go->isSpawned())
+        return false;
+
+    go->Use(bot);
+    ostringstream out; out << "Using " << chat->formatGameobject(go);
+    ai->TellMasterNoFacing(out.str());
+    return true;
+}
+
+bool UseItemAction::UseItemAuto(Item* item)
+{
+    return UseItem(item, ObjectGuid(), NULL);
+}
+
+bool UseItemAction::UseItemOnGameObject(Item* item, ObjectGuid go)
+{
+    return UseItem(item, go, NULL);
+}
+
+bool UseItemAction::UseItemOnItem(Item* item, Item* itemTarget)
+{
+    return UseItem(item, ObjectGuid(), itemTarget);
+}
+
+bool UseItemAction::UseItem(Item* item, ObjectGuid goGuid, Item* itemTarget)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return false;
+
+    if (bot->IsNonMeleeSpellCast(true))
+        return false;
+
+    if (bot->IsInCombat() && item->IsPotion() && bot->GetLastPotionId())
+        return false;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 8 + 1);
+    *packet << bagIndex << slot << cast_count << uint32(0) << item_guid
+        << glyphIndex << unk_flags;
+
+    bool targetSelected = false;
+    ostringstream out; out << "Using " << chat->formatItem(item->GetTemplate());
+    if (item->GetTemplate()->Stackable)
+    {
+        uint32 count = item->GetCount();
+        if (count > 1)
+            out << " (" << count << " available) ";
+        else
+            out << " (the last one!)";
+    }
+
+    if (goGuid)
+    {
+        GameObject* go = ai->GetGameObject(goGuid);
+        if (go && go->isSpawned())
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT_ENEMY;
+            *packet << targetFlag;
+            packet->appendPackGUID(goGuid.GetRawValue());
+            out << " on " << chat->formatGameobject(go);
+            targetSelected = true;
+        }
+    }
+
+    if (itemTarget)
+    {
+        if (item->GetTemplate()->Class == ITEM_CLASS_GEM)
+        {
+            bool fit = SocketItem(itemTarget, item) || SocketItem(itemTarget, item, true);
+            if (!fit)
+                ai->TellMaster("Socket does not fit");
+            return fit;
+        }
+        else
+        {
+            uint32 targetFlag = TARGET_FLAG_ITEM;
+            *packet << targetFlag;
+            packet->appendPackGUID(itemTarget->GetGUID());
+            out << " on " << chat->formatItem(itemTarget->GetTemplate());
+            targetSelected = true;
+        }
+    }
+
+    Player* master = GetMaster();
+    if (!targetSelected && item->GetTemplate()->Class != ITEM_CLASS_CONSUMABLE && master)
+    {
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT;
+            *packet << targetFlag;
+            packet->appendPackGUID(masterSelection->GetGUID());
+            out << " on " << masterSelection->GetName();
+            targetSelected = true;
+        }
+    }
+
+    if(uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8+4+4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            ostringstream out; out << "Got quest " << chat->formatQuest(qInfo);
+            ai->TellMasterNoFacing(out.str());
+            return true;
+        }
+    }
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+    bot->ClearUnitState( UNIT_STATE_CHASE );
+    bot->ClearUnitState( UNIT_STATE_FOLLOW );
+
+    if (bot->isMoving())
+        return false;
+
+    for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+    {
+        uint32 spellId = item->GetTemplate()->Spells[i].SpellId;
+        if (!spellId)
+            continue;
+
+        if (!ai->CanCastSpell(spellId, bot, false))
+            continue;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+        {
+            Item* itemForSpell = AI_VALUE2(Item*, "item for spell", spellId);
+            if (!itemForSpell)
+                continue;
+
+            if (itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                continue;
+
+            if (bot->GetTrader())
+            {
+                if (selfOnly)
+                    return false;
+
+                *packet << TARGET_FLAG_TRADE_ITEM << (uint8)1 << (uint64)TRADE_SLOT_NONTRADED;
+                targetSelected = true;
+                out << " on traded item";
+            }
+            else
+            {
+                *packet << TARGET_FLAG_ITEM;
+                packet->appendPackGUID(itemForSpell->GetGUID());
+                targetSelected = true;
+                out << " on "<< chat->formatItem(itemForSpell->GetTemplate());
+            }
+
+            Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE, ObjectGuid::Empty, true);
+            ai->WaitForSpellCast(spell);
+            delete spell;
+        }
+        else
+        {
+            *packet << TARGET_FLAG_NONE;
+            targetSelected = true;
+            out << " on self";
+        }
+        break;
+    }
+
+    if (!targetSelected)
+        return false;
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        if (bot->IsInCombat())
+            return false;
+
+        ai->InterruptSpell();
+        ai->SetNextCheckDelay(30000);
+    }
+
+    ai->TellMasterNoFacing(out.str());
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool UseItemAction::SocketItem(Item* item, Item* gem, bool replace)
+{
+    WorldPacket* const packet = new WorldPacket(CMSG_SOCKET_GEMS);
+    *packet << item->GetGUID();
+
+    bool fits = false;
+    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
+    {
+        uint8 SocketColor = item->GetTemplate()->Socket[enchant_slot-SOCK_ENCHANTMENT_SLOT].Color;
+        GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gem->GetTemplate()->GemProperties);
+        if (gemProperty && (gemProperty->color & SocketColor))
+        {
+            if (fits)
+            {
+                *packet << ObjectGuid();
+                continue;
+            }
+
+            uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry || !enchantEntry->GemID)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+			if (replace && enchantEntry->GemID != gem->GetTemplate()->ItemId)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+        }
+
+        *packet << ObjectGuid();
+    }
+
+    if (fits)
+    {
+        ostringstream out; out << "Socketing " << chat->formatItem(item->GetTemplate());
+        out << " with "<< chat->formatItem(gem->GetTemplate());
+        ai->TellMasterNoFacing(out.str());
+
+        bot->GetSession()->QueuePacket(packet);
+    }
+    return fits;
+}
+
+
+bool UseItemAction::isPossible()
+{
+    return getName() == "use" || AI_VALUE2(uint8, "item count", getName()) > 0;
+}
+
+bool UseSpellItemAction::isUseful()
+{
+    return AI_VALUE2(bool, "spell cast useful", getName());
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.h b/src/plugins/playerbot/strategy/actions/UseItemAction.h
new file mode 100644
index 0000000..ef65561
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class UseItemAction : public Action {
+	public:
+		UseItemAction(PlayerbotAI* ai, string name = "use", bool selfOnly = false) : Action(ai, name), selfOnly(selfOnly) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+
+    private:
+        bool UseItemAuto(Item* item);
+        bool UseItemOnGameObject(Item* item, ObjectGuid go);
+        bool UseItemOnItem(Item* item, Item* itemTarget);
+        bool UseItem(Item* item, ObjectGuid go, Item* itemTarget);
+        bool UseGameObject(ObjectGuid guid);
+        bool SocketItem(Item* item, Item* gem, bool replace = false);
+
+    private:
+        bool selfOnly;
+    };
+
+    class UseSpellItemAction : public UseItemAction {
+    public:
+        UseSpellItemAction(PlayerbotAI* ai, string name, bool selfOnly = false) : UseItemAction(ai, name, selfOnly) {}
+
+    public:
+        virtual bool isUseful();
+    };
+
+    class UseHealingPotion : public UseItemAction {
+    public:
+        UseHealingPotion(PlayerbotAI* ai) : UseItemAction(ai, "healing potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+
+    class UseManaPotion : public UseItemAction
+    {
+    public:
+        UseManaPotion(PlayerbotAI* ai) : UseItemAction(ai, "mana potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
new file mode 100644
index 0000000..23a95ed
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
@@ -0,0 +1,81 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseMeetingStoneAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+bool UseMeetingStoneAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    ObjectGuid guid;
+    p >> guid;
+
+    if (master->GetSelectedPlayer() && master->GetSelectedPlayer() != bot)
+        return false;
+
+    if (!master->GetSelectedPlayer() && master->GetGroup() != bot->GetGroup())
+        return false;
+
+    if (master->IsBeingTeleported())
+        return false;
+
+    if (bot->IsInCombat())
+    {
+        ai->TellMasterNoFacing("I am in combat");
+        return false;
+    }
+
+    GameObject *gameObject = ai->GetGameObject(guid);
+    if (!gameObject)
+        return false;
+
+    const GameObjectTemplate* goInfo = gameObject->GetGOInfo();
+    if (!goInfo || goInfo->type != GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+        return false;
+
+    return Teleport();
+}
+
+
+bool SummonAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (master->GetSession()->GetSecurity() < SEC_PLAYER)
+    {
+        ai->TellMasterNoFacing("You cannot summon me");
+        return false;
+    }
+
+    return Teleport();
+}
+
+bool SummonAction::Teleport()
+{
+    Player* master = GetMaster();
+    if (!master->IsBeingTeleported())
+    {
+        float followAngle = GetFollowAngle();
+        for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+        {
+            uint32 mapId = master->GetMapId();
+            float x = master->GetPositionX() + cos(angle) * sPlayerbotAIConfig.followDistance;
+            float y = master->GetPositionY()+ sin(angle) * sPlayerbotAIConfig.followDistance;
+            float z = master->GetPositionZ();
+            if (master->IsWithinLOS(x, y, z))
+            {
+                bot->GetMotionMaster()->Clear();
+                bot->TeleportTo(mapId, x, y, z, 0);
+                return true;
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
new file mode 100644
index 0000000..e787d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SummonAction : public MovementAction
+    {
+    public:
+        SummonAction(PlayerbotAI* ai, string name = "summon") : MovementAction(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Teleport();
+    };
+
+    class UseMeetingStoneAction : public SummonAction
+    {
+    public:
+        UseMeetingStoneAction(PlayerbotAI* ai) : SummonAction(ai, "use meeting stone") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.cpp b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
new file mode 100644
index 0000000..9dd7f95
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
@@ -0,0 +1,160 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WhoAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+map<uint32, string> WhoAction::skills;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool WhoAction::Execute(Event event)
+{
+    Player* owner = event.getOwner();
+    if (!owner)
+        return false;
+
+    string tell = "";
+    string text = event.getParam();
+    if (!text.empty())
+    {
+        if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+            return false;
+
+        tell = QuerySkill(text);
+        if (tell.empty())
+        {
+            tell = QueryTrade(text);
+        }
+    }
+    else
+    {
+        tell = QuerySpec(text);
+    }
+
+    if (tell.empty())
+        return false;
+
+    // ignore random bot chat filter
+	bot->Whisper(tell, LANG_UNIVERSAL, owner);
+    return true;
+}
+
+
+string WhoAction::QueryTrade(string text)
+{
+    ostringstream out;
+
+    list<Item*> items = InventoryAction::parseItems(text);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* sell = *i;
+        int32 sellPrice = auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * sell->GetCount();
+        if (!sellPrice)
+            continue;
+
+        out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+        return out.str();
+    }
+
+    return "";
+}
+
+string WhoAction::QuerySkill(string text)
+{
+    ostringstream out;
+    InitSkills();
+
+    for (map<uint32, string>::iterator i = skills.begin(); i != skills.end(); ++i)
+    {
+        string name = i->second;
+        uint16 skill = i->first;
+        if (!strcmpi(text.c_str(), name.c_str()) && bot->HasSkill(skill))
+        {
+            string skillName = i->second;
+            uint32 spellId = AI_VALUE2(uint32, "spell id", skillName);
+            uint16 value = bot->GetSkillValue(skill);
+            uint16 maxSkill = bot->GetMaxSkillValue(skill);
+            ObjectGuid guid = bot->GetGUID();
+            string data = "0";
+            out << "|cFFFFFF00|Htrade:" << spellId << ":" << value << ":" << maxSkill << ":"
+                    << std::hex << std::uppercase << guid.GetRawValue()
+                    << std::nouppercase << std::dec << ":" << data
+                    << "|h[" << skills[skill] << "]|h|r"
+                    << " |h|cff00ff00" << value << "|h|cffffffff/"
+                    << "|h|cff00ff00" << maxSkill << "|h|cffffffff ";
+        }
+    }
+
+    return out.str();
+}
+
+string WhoAction::QuerySpec(string text)
+{
+    ostringstream out;
+
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    out << "|h|cffffffff" << chat->formatClass(bot, spec);
+    out << " (|h|cff00ff00" << (uint32)bot->getLevel() << "|h|cffffffff lvl), ";
+    out << "|h|cff00ff00" << ai->GetEquipGearScore(bot, false, false) << "|h|cffffffff GS (";
+
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+
+    bool needSlash = false;
+    if (visitor.count[ITEM_QUALITY_EPIC])
+    {
+        out << "|h|cffff00ff" << visitor.count[ITEM_QUALITY_EPIC] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_RARE])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff8080ff" << visitor.count[ITEM_QUALITY_RARE] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_UNCOMMON])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff00ff00" << visitor.count[ITEM_QUALITY_UNCOMMON] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    out << ")";
+
+    return out.str();
+}
+
+
+void WhoAction::InitSkills()
+{
+    if (!skills.empty())
+        return;
+
+    skills[SKILL_ALCHEMY] = "Alchemy";
+    skills[SKILL_ENCHANTING] = "Enchanting";
+    skills[SKILL_SKINNING] = "Skinning";
+    skills[SKILL_JEWELCRAFTING] = "Jewelcrafting";
+    skills[SKILL_INSCRIPTION] = "Inscription";
+    skills[SKILL_TAILORING] = "Tailoring";
+    skills[SKILL_LEATHERWORKING] = "Leatherworking";
+    skills[SKILL_ENGINEERING] = "Engineering";
+    skills[SKILL_HERBALISM] = "Herbalism";
+    skills[SKILL_MINING] = "Mining";
+    skills[SKILL_BLACKSMITHING] = "Blacksmithing";
+    skills[SKILL_COOKING] = "Cooking";
+    skills[SKILL_FIRST_AID] = "First Aid";
+    skills[SKILL_FISHING] = "Fishing";
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.h b/src/plugins/playerbot/strategy/actions/WhoAction.h
new file mode 100644
index 0000000..92ed834
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class WhoAction : public InventoryAction {
+    public:
+        WhoAction(PlayerbotAI* ai) : InventoryAction(ai, "who") {}
+
+    public:
+        virtual bool Execute(Event event);
+        static map<uint32, string> skills;
+
+    private:
+        void InitSkills();
+        string QueryTrade(string text);
+        string QuerySkill(string text);
+        string QuerySpec(string text);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
new file mode 100644
index 0000000..268f2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include "AcceptInvitationAction.h"
+#include "PassLeadershipToMasterAction.h"
+#include "TellMasterAction.h"
+#include "TalkToQuestGiverAction.h"
+#include "AcceptQuestAction.h"
+#include "LootRollAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "AcceptResurrectAction.h"
+#include "UseMeetingStoneAction.h"
+#include "AreaTriggerAction.h"
+#include "CheckMountStateAction.h"
+#include "RememberTaxiAction.h"
+#include "TradeStatusAction.h"
+#include "InventoryChangeFailureAction.h"
+#include "LootAction.h"
+#include "QuestAction.h"
+#include "LeaveGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "AcceptDuelAction.h"
+#include "ReadyCheckAction.h"
+#include "LfgActions.h"
+#include "SecurityCheckAction.h"
+#include "GuildAcceptAction.h"
+
+namespace ai
+{
+    class WorldPacketActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        WorldPacketActionContext()
+        {
+            creators["accept invitation"] = &WorldPacketActionContext::accept_invitation;
+            creators["leader"] = &WorldPacketActionContext::pass_leadership_to_master;
+            creators["tell not enough money"] = &WorldPacketActionContext::tell_not_enough_money;
+            creators["tell not enough reputation"] = &WorldPacketActionContext::tell_not_enough_reputation;
+            creators["tell cannot equip"] = &WorldPacketActionContext::tell_cannot_equip;
+            creators["talk to quest giver"] = &WorldPacketActionContext::turn_in_quest;
+            creators["accept quest"] = &WorldPacketActionContext::accept_quest;
+            creators["accept all quests"] = &WorldPacketActionContext::accept_all_quests;
+            creators["accept quest share"] = &WorldPacketActionContext::accept_quest_share;
+            creators["loot roll"] = &WorldPacketActionContext::loot_roll;
+            creators["revive from corpse"] = &WorldPacketActionContext::revive_from_corpse;
+            creators["accept resurrect"] = &WorldPacketActionContext::accept_resurrect;
+            creators["use meeting stone"] = &WorldPacketActionContext::use_meeting_stone;
+            creators["area trigger"] = &WorldPacketActionContext::area_trigger;
+            creators["reach area trigger"] = &WorldPacketActionContext::reach_area_trigger;
+            creators["check mount state"] = &WorldPacketActionContext::check_mount_state;
+            creators["remember taxi"] = &WorldPacketActionContext::remember_taxi;
+            creators["accept trade"] = &WorldPacketActionContext::accept_trade;
+            creators["store loot"] = &WorldPacketActionContext::store_loot;
+            creators["tell out of react range"] = &WorldPacketActionContext::tell_out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketActionContext::quest_objective_completed;
+            creators["party command"] = &WorldPacketActionContext::party_command;
+            creators["tell cast failed"] = &WorldPacketActionContext::tell_cast_failed;
+            creators["accept duel"] = &WorldPacketActionContext::accept_duel;
+            creators["ready check"] = &WorldPacketActionContext::ready_check;
+            creators["ready check finished"] = &WorldPacketActionContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketActionContext::uninvite;
+            creators["lfg join"] = &WorldPacketActionContext::lfg_join;
+            creators["lfg accept"] = &WorldPacketActionContext::lfg_accept;
+            creators["lfg role check"] = &WorldPacketActionContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketActionContext::lfg_leave;
+            creators["lfg teleport"] = &WorldPacketActionContext::lfg_teleport;
+            creators["security check"] = &WorldPacketActionContext::security_check;
+            creators["guild accept"] = &WorldPacketActionContext::guild_accept;
+        }
+
+    private:
+        static Action* guild_accept(PlayerbotAI* ai) { return new GuildAcceptAction(ai); }
+        static Action* security_check(PlayerbotAI* ai) { return new SecurityCheckAction(ai); }
+        static Action* lfg_teleport(PlayerbotAI* ai) { return new LfgTeleportAction(ai); }
+        static Action* lfg_leave(PlayerbotAI* ai) { return new LfgLeaveAction(ai); }
+        static Action* lfg_accept(PlayerbotAI* ai) { return new LfgAcceptAction(ai); }
+        static Action* lfg_role_check(PlayerbotAI* ai) { return new LfgRoleCheckAction(ai); }
+        static Action* lfg_join(PlayerbotAI* ai) { return new LfgJoinAction(ai); }
+        static Action* uninvite(PlayerbotAI* ai) { return new UninviteAction(ai); }
+        static Action* ready_check_finished(PlayerbotAI* ai) { return new FinishReadyCheckAction(ai); }
+        static Action* ready_check(PlayerbotAI* ai) { return new ReadyCheckAction(ai); }
+        static Action* accept_duel(PlayerbotAI* ai) { return new AcceptDuelAction(ai); }
+        static Action* tell_cast_failed(PlayerbotAI* ai) { return new TellCastFailedAction(ai); }
+        static Action* party_command(PlayerbotAI* ai) { return new PartyCommandAction(ai); }
+        static Action* quest_objective_completed(PlayerbotAI* ai) { return new QuestObjectiveCompletedAction(ai); }
+        static Action* store_loot(PlayerbotAI* ai) { return new StoreLootAction(ai); }
+        static Action* tell_out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeAction(ai); }
+        static Action* accept_trade(PlayerbotAI* ai) { return new TradeStatusAction(ai); }
+        static Action* remember_taxi(PlayerbotAI* ai) { return new RememberTaxiAction(ai); }
+        static Action* check_mount_state(PlayerbotAI* ai) { return new CheckMountStateAction(ai); }
+        static Action* area_trigger(PlayerbotAI* ai) { return new AreaTriggerAction(ai); }
+        static Action* reach_area_trigger(PlayerbotAI* ai) { return new ReachAreaTriggerAction(ai); }
+        static Action* use_meeting_stone(PlayerbotAI* ai) { return new UseMeetingStoneAction(ai); }
+        static Action* accept_resurrect(PlayerbotAI* ai) { return new AcceptResurrectAction(ai); }
+        static Action* revive_from_corpse(PlayerbotAI* ai) { return new ReviveFromCorpseAction(ai); }
+        static Action* accept_invitation(PlayerbotAI* ai) { return new AcceptInvitationAction(ai); }
+        static Action* pass_leadership_to_master(PlayerbotAI* ai) { return new PassLeadershipToMasterAction(ai); }
+        static Action* tell_not_enough_money(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough money"); }
+        static Action* tell_not_enough_reputation(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough reputation"); }
+        static Action* tell_cannot_equip(PlayerbotAI* ai) { return new InventoryChangeFailureAction(ai); }
+        static Action* turn_in_quest(PlayerbotAI* ai) { return new TalkToQuestGiverAction(ai); }
+        static Action* accept_quest(PlayerbotAI* ai) { return new AcceptQuestAction(ai); }
+        static Action* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsAction(ai); }
+        static Action* accept_quest_share(PlayerbotAI* ai) { return new AcceptQuestShareAction(ai); }
+        static Action* loot_roll(PlayerbotAI* ai) { return (QueryItemUsageAction*)new LootRollAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
new file mode 100644
index 0000000..fa86bb1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
@@ -0,0 +1,171 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "BearTankDruidStrategy.h"
+
+using namespace ai;
+
+class BearTankDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    BearTankDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["feral charge - bear"] = &feral_charge_bear;
+        creators["swipe (bear)"] = &swipe_bear;
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["bear form"] = &bear_form;
+        creators["dire bear form"] = &dire_bear_form;
+        creators["mangle (bear)"] = &mangle_bear;
+        creators["maul"] = &maul;
+        creators["bash"] = &bash;
+        creators["swipe"] = &swipe;
+        creators["lacerate"] = &lacerate;
+        creators["demoralizing roar"] = &demoralizing_roar;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - bear",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe (bear)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bear form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* dire_bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dire bear form",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("bear form"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (bear)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lacerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* maul(PlayerbotAI* ai)
+    {
+        return new ActionNode ("maul",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lacerate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lacerate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("maul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* growl(PlayerbotAI* ai)
+    {
+        return new ActionNode ("growl",
+            /*P*/ NextAction::array(0, new NextAction("reach spell"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* demoralizing_roar(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demoralizing roar",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+BearTankDruidStrategy::BearTankDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new BearTankDruidStrategyActionNodeFactory());
+}
+
+NextAction** BearTankDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0,
+            new NextAction("lacerate", ACTION_NORMAL + 4),
+            new NextAction("mangle (bear)", ACTION_NORMAL + 3),
+            new NextAction("maul", ACTION_NORMAL + 2),
+            new NextAction("faerie fire (feral)", ACTION_NORMAL + 1),
+            NULL);
+}
+
+void BearTankDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "thorns",
+        NextAction::array(0, new NextAction("thorns", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bear form",
+        NextAction::array(0, new NextAction("dire bear form", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("growl", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("demoralizing roar", ACTION_HIGH + 6), new NextAction("swipe (bear)", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("swipe (bear)", ACTION_HIGH + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash",
+        NextAction::array(0, new NextAction("bash", ACTION_INTERRUPT + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash on enemy healer",
+        NextAction::array(0, new NextAction("bash on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
new file mode 100644
index 0000000..1e8a3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+
+namespace ai
+{
+    class BearTankDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        BearTankDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bear"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
new file mode 100644
index 0000000..bb07940
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CasterDruidStrategy.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class CasterDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire"] = &faerie_fire;
+        creators["hibernate"] = &hibernate;
+        creators["entangling roots"] = &entangling_roots;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["wrath"] = &wrath;
+        creators["starfall"] = &starfall;
+        creators["insect swarm"] = &insect_swarm;
+        creators["moonfire"] = &moonfire;
+        creators["starfire"] = &starfire;
+        creators["nature's grasp"] = &natures_grasp;
+    }
+private:
+    static ActionNode* faerie_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* hibernate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hibernate",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("entangling roots"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* wrath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("wrath",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfall",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("hurricane"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* insect_swarm(PlayerbotAI* ai)
+    {
+        return new ActionNode ("insect swarm",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* moonfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("moonfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* natures_grasp(PlayerbotAI* ai)
+    {
+        return new ActionNode ("nature's grasp",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CasterDruidStrategy::CasterDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+NextAction** CasterDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 2), new NextAction("wrath", ACTION_NORMAL + 1), NULL);
+}
+
+void CasterDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_MOVE), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+
+	triggers.push_back(new TriggerNode(
+		"insect swarm",
+		NextAction::array(0, new NextAction("insect swarm", ACTION_NORMAL + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"moonfire",
+		NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (solar)",
+        NextAction::array(0, new NextAction("wrath", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (lunar)",
+        NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "moonfire",
+        NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+
+
+	triggers.push_back(new TriggerNode(
+		"nature's grasp",
+		NextAction::array(0, new NextAction("nature's grasp", ACTION_EMERGENCY), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 2), NULL)));
+}
+
+void CasterDruidAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("starfall", ACTION_HIGH + 1), NULL)));
+}
+
+void CasterDruidDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "faerie fire",
+        NextAction::array(0, new NextAction("faerie fire", ACTION_HIGH), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
new file mode 100644
index 0000000..66ac838
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CasterDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        CasterDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterDruidAoeStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+
+    class CasterDruidDebuffStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
new file mode 100644
index 0000000..67515b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
@@ -0,0 +1,139 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CatDpsDruidStrategy.h"
+
+using namespace ai;
+
+class CatDpsDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CatDpsDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["melee"] = &melee;
+        creators["feral charge - cat"] = &feral_charge_cat;
+        creators["cat form"] = &cat_form;
+        creators["claw"] = &claw;
+        creators["mangle (cat)"] = &mangle_cat;
+        creators["rake"] = &rake;
+        creators["ferocious bite"] = &ferocious_bite;
+        creators["rip"] = &rip;
+    }
+private:
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - cat"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - cat",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* cat_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cat form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* claw(PlayerbotAI* ai)
+    {
+        return new ActionNode ("claw",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (cat)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("claw"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rake(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rake",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* ferocious_bite(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ferocious bite",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rip"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rip(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rip",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CatDpsDruidStrategy::CatDpsDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CatDpsDruidStrategyActionNodeFactory());
+}
+
+NextAction** CatDpsDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mangle (cat)", ACTION_NORMAL + 1), NULL);
+}
+
+void CatDpsDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "cat form",
+        NextAction::array(0, new NextAction("cat form", ACTION_MOVE + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rake",
+        NextAction::array(0, new NextAction("rake", ACTION_NORMAL + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("ferocious bite", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("cower", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"tiger's fury",
+		NextAction::array(0, new NextAction("tiger's fury", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+
+}
+
+void CatAoeDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("swipe (cat)", ACTION_HIGH + 2), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
new file mode 100644
index 0000000..397f0b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CatDpsDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        CatDpsDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+    class CatAoeDruidStrategy : public CombatStrategy
+    {
+    public:
+        CatAoeDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.cpp b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
new file mode 100644
index 0000000..fa71bda
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
+bool CastCasterFormAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+    return true;
+}
+
+NextAction** CastAbolishPoisonAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison"), NULL), CastSpellAction::getPrerequisites());
+}
+
+NextAction** CastAbolishPoisonOnPartyAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison on party"), NULL), CastSpellAction::getPrerequisites());
+}
+
+Value<Unit*>* CastEntanglingRootsCcAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "entangling roots");
+}
+
+bool CastEntanglingRootsCcAction::Execute(Event event)
+{
+    return ai->CastSpell("entangling roots", GetTarget());
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.h b/src/plugins/playerbot/strategy/druid/DruidActions.h
new file mode 100644
index 0000000..965f454
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "DruidShapeshiftActions.h"
+#include "DruidBearActions.h"
+#include "DruidCatActions.h"
+
+namespace ai
+{
+	class CastFaerieFireAction : public CastSpellAction
+	{
+	public:
+		CastFaerieFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire") {}
+	};
+
+    class CastFaerieFireFeralAction : public CastSpellAction
+    {
+    public:
+        CastFaerieFireFeralAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire (feral)") {}
+    };
+
+	class CastRejuvenationAction : public CastHealingSpellAction {
+	public:
+		CastRejuvenationAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "rejuvenation") {}
+	};
+
+	class CastRegrowthAction : public CastHealingSpellAction {
+	public:
+		CastRegrowthAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "regrowth") {}
+
+	};
+
+    class CastHealingTouchAction : public CastHealingSpellAction {
+    public:
+        CastHealingTouchAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing touch") {}
+
+    };
+
+    class CastRejuvenationOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRejuvenationOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "rejuvenation") {}
+    };
+
+    class CastRegrowthOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRegrowthOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "regrowth") {}
+    };
+
+    class CastHealingTouchOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingTouchOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing touch") {}
+    };
+
+	class CastReviveAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastReviveAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "revive") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastRebirthAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRebirthAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "rebirth") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastMarkOfTheWildAction : public CastBuffSpellAction {
+	public:
+		CastMarkOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mark of the wild") {}
+	};
+
+	class CastMarkOfTheWildOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastMarkOfTheWildOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "mark of the wild") {}
+	};
+
+	class CastSurvivalInstinctsAction : public CastBuffSpellAction {
+	public:
+		CastSurvivalInstinctsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "survival instincts") {}
+	};
+
+	class CastThornsAction : public CastBuffSpellAction {
+	public:
+		CastThornsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "thorns") {}
+	};
+
+	class CastWrathAction : public CastSpellAction
+	{
+	public:
+		CastWrathAction(PlayerbotAI* ai) : CastSpellAction(ai, "wrath") {}
+	};
+
+	class CastStarfallAction : public CastSpellAction
+	{
+	public:
+		CastStarfallAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfall") {}
+	};
+
+	class CastHurricaneAction : public CastSpellAction
+	{
+	public:
+	    CastHurricaneAction(PlayerbotAI* ai) : CastSpellAction(ai, "hurricane") {}
+	};
+
+	class CastMoonfireAction : public CastDebuffSpellAction
+	{
+	public:
+		CastMoonfireAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "moonfire") {}
+	};
+
+	class CastInsectSwarmAction : public CastDebuffSpellAction
+	{
+	public:
+		CastInsectSwarmAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "insect swarm") {}
+	};
+
+	class CastStarfireAction : public CastSpellAction
+	{
+	public:
+		CastStarfireAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfire") {}
+	};
+
+	class CastEntanglingRootsAction : public CastSpellAction
+	{
+	public:
+		CastEntanglingRootsAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots") {}
+	};
+
+    class CastEntanglingRootsCcAction : public CastSpellAction
+    {
+    public:
+        CastEntanglingRootsCcAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots on cc") {}
+        virtual Value<Unit*>* GetTargetValue();
+        virtual bool Execute(Event event);
+    };
+
+	class CastNaturesGraspAction : public CastBuffSpellAction
+	{
+	public:
+		CastNaturesGraspAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "nature's grasp") {}
+	};
+
+	class CastHibernateAction : public CastSpellAction
+	{
+	public:
+		CastHibernateAction(PlayerbotAI* ai) : CastSpellAction(ai, "hibernate") {}
+	};
+
+	class CastCurePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCurePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure poison") {}
+	};
+
+    class CastCurePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCurePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+	class CastAbolishPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastAbolishPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish poison") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish poison", DISPEL_POISON) {}
+
+        virtual NextAction** getAlternatives();
+    };
+
+    class CastBarskinAction : public CastBuffSpellAction
+    {
+    public:
+        CastBarskinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "barskin") {}
+    };
+
+    class CastInnervateAction : public CastSpellAction
+    {
+    public:
+        CastInnervateAction(PlayerbotAI* ai) : CastSpellAction(ai, "innervate") {}
+
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastTranquilityAction : public CastAoeHealSpellAction
+    {
+    public:
+        CastTranquilityAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "tranquility") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
new file mode 100644
index 0000000..65c9fc9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
@@ -0,0 +1,258 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+#include "DruidAiObjectContext.h"
+#include "BearTankDruidStrategy.h"
+#include "CatDpsDruidStrategy.h"
+#include "CasterDruidStrategy.h"
+#include "GenericDruidNonCombatStrategy.h"
+#include "../NamedObjectContext.h"
+#include "DruidTriggers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &druid::StrategyFactoryInternal::nc;
+                creators["cat aoe"] = &druid::StrategyFactoryInternal::cat_aoe;
+                creators["caster aoe"] = &druid::StrategyFactoryInternal::caster_aoe;
+                creators["caster debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+                creators["dps debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericDruidNonCombatStrategy(ai); }
+            static Strategy* cat_aoe(PlayerbotAI* ai) { return new CatAoeDruidStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterDruidAoeStrategy(ai); }
+            static Strategy* caster_debuff(PlayerbotAI* ai) { return new CasterDruidDebuffStrategy(ai); }
+        };
+
+        class DruidStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            DruidStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bear"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["tank"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["cat"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["caster"] = &druid::DruidStrategyFactoryInternal::caster;
+                creators["dps"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["heal"] = &druid::DruidStrategyFactoryInternal::heal;
+            }
+
+        private:
+            static Strategy* bear(PlayerbotAI* ai) { return new BearTankDruidStrategy(ai); }
+            static Strategy* cat(PlayerbotAI* ai) { return new CatDpsDruidStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterDruidStrategy(ai); }
+            static Strategy* heal(PlayerbotAI* ai) { return new HealDruidStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["thorns"] = &TriggerFactoryInternal::Thorns;
+                creators["bash"] = &TriggerFactoryInternal::bash;
+                creators["faerie fire (feral)"] = &TriggerFactoryInternal::faerie_fire_feral;
+                creators["faerie fire"] = &TriggerFactoryInternal::faerie_fire;
+                creators["insect swarm"] = &TriggerFactoryInternal::insect_swarm;
+                creators["moonfire"] = &TriggerFactoryInternal::moonfire;
+                creators["nature's grasp"] = &TriggerFactoryInternal::natures_grasp;
+                creators["tiger's fury"] = &TriggerFactoryInternal::tigers_fury;
+                creators["rake"] = &TriggerFactoryInternal::rake;
+                creators["mark of the wild"] = &TriggerFactoryInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &TriggerFactoryInternal::mark_of_the_wild_on_party;
+                creators["cure poison"] = &TriggerFactoryInternal::cure_poison;
+                creators["party member cure poison"] = &TriggerFactoryInternal::party_member_cure_poison;
+                creators["entangling roots"] = &TriggerFactoryInternal::entangling_roots;
+                creators["bear form"] = &TriggerFactoryInternal::bear_form;
+                creators["cat form"] = &TriggerFactoryInternal::cat_form;
+                creators["tree form"] = &TriggerFactoryInternal::tree_form;
+                creators["eclipse (solar)"] = &TriggerFactoryInternal::eclipse_solar;
+                creators["eclipse (lunar)"] = &TriggerFactoryInternal::eclipse_lunar;
+                creators["bash on enemy healer"] = &TriggerFactoryInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* eclipse_solar(PlayerbotAI* ai) { return new EclipseSolarTrigger(ai); }
+            static Trigger* eclipse_lunar(PlayerbotAI* ai) { return new EclipseLunarTrigger(ai); }
+            static Trigger* Thorns(PlayerbotAI* ai) { return new ThornsTrigger(ai); }
+            static Trigger* bash(PlayerbotAI* ai) { return new BashInterruptSpellTrigger(ai); }
+            static Trigger* faerie_fire_feral(PlayerbotAI* ai) { return new FaerieFireFeralTrigger(ai); }
+            static Trigger* insect_swarm(PlayerbotAI* ai) { return new InsectSwarmTrigger(ai); }
+            static Trigger* moonfire(PlayerbotAI* ai) { return new MoonfireTrigger(ai); }
+            static Trigger* faerie_fire(PlayerbotAI* ai) { return new FaerieFireTrigger(ai); }
+            static Trigger* natures_grasp(PlayerbotAI* ai) { return new NaturesGraspTrigger(ai); }
+            static Trigger* tigers_fury(PlayerbotAI* ai) { return new TigersFuryTrigger(ai); }
+            static Trigger* rake(PlayerbotAI* ai) { return new RakeTrigger(ai); }
+            static Trigger* mark_of_the_wild(PlayerbotAI* ai) { return new MarkOfTheWildTrigger(ai); }
+            static Trigger* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new MarkOfTheWildOnPartyTrigger(ai); }
+            static Trigger* cure_poison(PlayerbotAI* ai) { return new CurePoisonTrigger(ai); }
+            static Trigger* party_member_cure_poison(PlayerbotAI* ai) { return new PartyMemberCurePoisonTrigger(ai); }
+            static Trigger* entangling_roots(PlayerbotAI* ai) { return new EntanglingRootsTrigger(ai); }
+            static Trigger* bear_form(PlayerbotAI* ai) { return new BearFormTrigger(ai); }
+            static Trigger* cat_form(PlayerbotAI* ai) { return new CatFormTrigger(ai); }
+            static Trigger* tree_form(PlayerbotAI* ai) { return new TreeFormTrigger(ai); }
+            static Trigger* bash_on_enemy_healer(PlayerbotAI* ai) { return new BashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["feral charge - bear"] = &AiObjectContextInternal::feral_charge_bear;
+                creators["feral charge - cat"] = &AiObjectContextInternal::feral_charge_cat;
+                creators["swipe (bear)"] = &AiObjectContextInternal::swipe_bear;
+                creators["faerie fire (feral)"] = &AiObjectContextInternal::faerie_fire_feral;
+                creators["faerie fire"] = &AiObjectContextInternal::faerie_fire;
+                creators["bear form"] = &AiObjectContextInternal::bear_form;
+                creators["dire bear form"] = &AiObjectContextInternal::dire_bear_form;
+                creators["moonkin form"] = &AiObjectContextInternal::moonkin_form;
+                creators["cat form"] = &AiObjectContextInternal::cat_form;
+                creators["tree form"] = &AiObjectContextInternal::tree_form;
+                creators["caster form"] = &AiObjectContextInternal::caster_form;
+                creators["mangle (bear)"] = &AiObjectContextInternal::mangle_bear;
+                creators["maul"] = &AiObjectContextInternal::maul;
+                creators["bash"] = &AiObjectContextInternal::bash;
+                creators["swipe"] = &AiObjectContextInternal::swipe;
+                creators["growl"] = &AiObjectContextInternal::growl;
+                creators["demoralizing roar"] = &AiObjectContextInternal::demoralizing_roar;
+                creators["hibernate"] = &AiObjectContextInternal::hibernate;
+                creators["entangling roots"] = &AiObjectContextInternal::entangling_roots;
+                creators["entangling roots on cc"] = &AiObjectContextInternal::entangling_roots_on_cc;
+                creators["wrath"] = &AiObjectContextInternal::wrath;
+                creators["starfall"] = &AiObjectContextInternal::starfall;
+                creators["insect swarm"] = &AiObjectContextInternal::insect_swarm;
+                creators["moonfire"] = &AiObjectContextInternal::moonfire;
+                creators["starfire"] = &AiObjectContextInternal::starfire;
+                creators["nature's grasp"] = &AiObjectContextInternal::natures_grasp;
+                creators["claw"] = &AiObjectContextInternal::claw;
+                creators["mangle (cat)"] = &AiObjectContextInternal::mangle_cat;
+                creators["swipe (cat)"] = &AiObjectContextInternal::swipe_cat;
+                creators["rake"] = &AiObjectContextInternal::rake;
+                creators["ferocious bite"] = &AiObjectContextInternal::ferocious_bite;
+                creators["rip"] = &AiObjectContextInternal::rip;
+                creators["cower"] = &AiObjectContextInternal::cower;
+                creators["survival instincts"] = &AiObjectContextInternal::survival_instincts;
+                creators["thorns"] = &AiObjectContextInternal::thorns;
+                creators["cure poison"] = &AiObjectContextInternal::cure_poison;
+                creators["cure poison on party"] = &AiObjectContextInternal::cure_poison_on_party;
+                creators["abolish poison"] = &AiObjectContextInternal::abolish_poison;
+                creators["abolish poison on party"] = &AiObjectContextInternal::abolish_poison_on_party;
+                creators["berserk"] = &AiObjectContextInternal::berserk;
+                creators["tiger's fury"] = &AiObjectContextInternal::tigers_fury;
+                creators["mark of the wild"] = &AiObjectContextInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &AiObjectContextInternal::mark_of_the_wild_on_party;
+                creators["regrowth"] = &AiObjectContextInternal::regrowth;
+                creators["rejuvenation"] = &AiObjectContextInternal::rejuvenation;
+                creators["healing touch"] = &AiObjectContextInternal::healing_touch;
+                creators["regrowth on party"] = &AiObjectContextInternal::regrowth_on_party;
+                creators["rejuvenation on party"] = &AiObjectContextInternal::rejuvenation_on_party;
+                creators["healing touch on party"] = &AiObjectContextInternal::healing_touch_on_party;
+                creators["rebirth"] = &AiObjectContextInternal::rebirth;
+                creators["revive"] = &AiObjectContextInternal::revive;
+                creators["barskin"] = &AiObjectContextInternal::barskin;
+                creators["lacerate"] = &AiObjectContextInternal::lacerate;
+                creators["hurricane"] = &AiObjectContextInternal::hurricane;
+                creators["innervate"] = &AiObjectContextInternal::innervate;
+                creators["tranquility"] = &AiObjectContextInternal::tranquility;
+                creators["bash on enemy healer"] = &AiObjectContextInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* tranquility(PlayerbotAI* ai) { return new CastTranquilityAction(ai); }
+            static Action* feral_charge_bear(PlayerbotAI* ai) { return new CastFeralChargeBearAction(ai); }
+            static Action* feral_charge_cat(PlayerbotAI* ai) { return new CastFeralChargeCatAction(ai); }
+            static Action* swipe_bear(PlayerbotAI* ai) { return new CastSwipeBearAction(ai); }
+            static Action* faerie_fire_feral(PlayerbotAI* ai) { return new CastFaerieFireFeralAction(ai); }
+            static Action* faerie_fire(PlayerbotAI* ai) { return new CastFaerieFireAction(ai); }
+            static Action* bear_form(PlayerbotAI* ai) { return new CastBearFormAction(ai); }
+            static Action* dire_bear_form(PlayerbotAI* ai) { return new CastDireBearFormAction(ai); }
+            static Action* cat_form(PlayerbotAI* ai) { return new CastCatFormAction(ai); }
+            static Action* tree_form(PlayerbotAI* ai) { return new CastTreeFormAction(ai); }
+            static Action* caster_form(PlayerbotAI* ai) { return new CastCasterFormAction(ai); }
+            static Action* mangle_bear(PlayerbotAI* ai) { return new CastMangleBearAction(ai); }
+            static Action* maul(PlayerbotAI* ai) { return new CastMaulAction(ai); }
+            static Action* bash(PlayerbotAI* ai) { return new CastBashAction(ai); }
+            static Action* swipe(PlayerbotAI* ai) { return new CastSwipeAction(ai); }
+            static Action* growl(PlayerbotAI* ai) { return new CastGrowlAction(ai); }
+            static Action* demoralizing_roar(PlayerbotAI* ai) { return new CastDemoralizingRoarAction(ai); }
+            static Action* moonkin_form(PlayerbotAI* ai) { return new CastMoonkinFormAction(ai); }
+            static Action* hibernate(PlayerbotAI* ai) { return new CastHibernateAction(ai); }
+            static Action* entangling_roots(PlayerbotAI* ai) { return new CastEntanglingRootsAction(ai); }
+            static Action* entangling_roots_on_cc(PlayerbotAI* ai) { return new CastEntanglingRootsCcAction(ai); }
+            static Action* wrath(PlayerbotAI* ai) { return new CastWrathAction(ai); }
+            static Action* starfall(PlayerbotAI* ai) { return new CastStarfallAction(ai); }
+            static Action* insect_swarm(PlayerbotAI* ai) { return new CastInsectSwarmAction(ai); }
+            static Action* moonfire(PlayerbotAI* ai) { return new CastMoonfireAction(ai); }
+            static Action* starfire(PlayerbotAI* ai) { return new CastStarfireAction(ai); }
+            static Action* natures_grasp(PlayerbotAI* ai) { return new CastNaturesGraspAction(ai); }
+            static Action* claw(PlayerbotAI* ai) { return new CastClawAction(ai); }
+            static Action* mangle_cat(PlayerbotAI* ai) { return new CastMangleCatAction(ai); }
+            static Action* swipe_cat(PlayerbotAI* ai) { return new CastSwipeCatAction(ai); }
+            static Action* rake(PlayerbotAI* ai) { return new CastRakeAction(ai); }
+            static Action* ferocious_bite(PlayerbotAI* ai) { return new CastFerociousBiteAction(ai); }
+            static Action* rip(PlayerbotAI* ai) { return new CastRipAction(ai); }
+            static Action* cower(PlayerbotAI* ai) { return new CastCowerAction(ai); }
+            static Action* survival_instincts(PlayerbotAI* ai) { return new CastSurvivalInstinctsAction(ai); }
+            static Action* thorns(PlayerbotAI* ai) { return new CastThornsAction(ai); }
+            static Action* cure_poison(PlayerbotAI* ai) { return new CastCurePoisonAction(ai); }
+            static Action* cure_poison_on_party(PlayerbotAI* ai) { return new CastCurePoisonOnPartyAction(ai); }
+            static Action* abolish_poison(PlayerbotAI* ai) { return new CastAbolishPoisonAction(ai); }
+            static Action* abolish_poison_on_party(PlayerbotAI* ai) { return new CastAbolishPoisonOnPartyAction(ai); }
+            static Action* berserk(PlayerbotAI* ai) { return new CastBerserkAction(ai); }
+            static Action* tigers_fury(PlayerbotAI* ai) { return new CastTigersFuryAction(ai); }
+            static Action* mark_of_the_wild(PlayerbotAI* ai) { return new CastMarkOfTheWildAction(ai); }
+            static Action* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new CastMarkOfTheWildOnPartyAction(ai); }
+            static Action* regrowth(PlayerbotAI* ai) { return new CastRegrowthAction(ai); }
+            static Action* rejuvenation(PlayerbotAI* ai) { return new CastRejuvenationAction(ai); }
+            static Action* healing_touch(PlayerbotAI* ai) { return new CastHealingTouchAction(ai); }
+            static Action* regrowth_on_party(PlayerbotAI* ai) { return new CastRegrowthOnPartyAction(ai); }
+            static Action* rejuvenation_on_party(PlayerbotAI* ai) { return new CastRejuvenationOnPartyAction(ai); }
+            static Action* healing_touch_on_party(PlayerbotAI* ai) { return new CastHealingTouchOnPartyAction(ai); }
+            static Action* rebirth(PlayerbotAI* ai) { return new CastRebirthAction(ai); }
+            static Action* revive(PlayerbotAI* ai) { return new CastReviveAction(ai); }
+            static Action* barskin(PlayerbotAI* ai) { return new CastBarskinAction(ai); }
+            static Action* lacerate(PlayerbotAI* ai) { return new CastLacerateAction(ai); }
+            static Action* hurricane(PlayerbotAI* ai) { return new CastHurricaneAction(ai); }
+            static Action* innervate(PlayerbotAI* ai) { return new CastInnervateAction(ai); }
+            static Action* bash_on_enemy_healer(PlayerbotAI* ai) { return new CastBashOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+DruidAiObjectContext::DruidAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::druid::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::druid::DruidStrategyFactoryInternal());
+    actionContexts.Add(new ai::druid::AiObjectContextInternal());
+    triggerContexts.Add(new ai::druid::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
new file mode 100644
index 0000000..b5d7a2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class DruidAiObjectContext : public AiObjectContext
+    {
+    public:
+        DruidAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidBearActions.h b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
new file mode 100644
index 0000000..81bc8ab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
@@ -0,0 +1,64 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeBearAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeBearAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - bear", 1.5f) {}
+	};
+
+	class CastGrowlAction : public CastSpellAction
+	{
+	public:
+		CastGrowlAction(PlayerbotAI* ai) : CastSpellAction(ai, "growl") {}
+	};
+
+	class CastMaulAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMaulAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "maul") {}
+		virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "rage", "self target") >= 45; }
+	};
+
+	class CastBashAction : public CastMeleeSpellAction
+	{
+	public:
+		CastBashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bash") {}
+	};
+
+	class CastSwipeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe") {}
+	};
+
+	class CastDemoralizingRoarAction : public CastDebuffSpellAction
+	{
+	public:
+		CastDemoralizingRoarAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing roar") {}
+	};
+
+	class CastMangleBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMangleBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (bear)") {}
+	};
+
+	class CastSwipeBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (bear)") {}
+	};
+
+    class CastLacerateAction : public CastMeleeSpellAction
+    {
+    public:
+        CastLacerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lacerate") {}
+    };
+
+    class CastBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidCatActions.h b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
new file mode 100644
index 0000000..90f50c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
@@ -0,0 +1,69 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeCatAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeCatAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - cat", 1.5f) {}
+	};
+
+	class CastCowerAction : public CastBuffSpellAction
+	{
+	public:
+		CastCowerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cower") {}
+	};
+
+
+	class CastBerserkAction : public CastBuffSpellAction
+	{
+	public:
+		CastBerserkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserk") {}
+	};
+
+	class CastTigersFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastTigersFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tiger's fury") {}
+	};
+
+	class CastRakeAction : public CastDebuffSpellAction
+	{
+	public:
+		CastRakeAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "rake") {}
+
+        virtual NextAction** getPrerequisites()
+        {
+            return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+        }
+	};
+
+
+	class CastClawAction : public CastMeleeSpellAction {
+	public:
+		CastClawAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "claw") {}
+	};
+
+	class CastMangleCatAction : public CastMeleeSpellAction {
+	public:
+		CastMangleCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (cat)") {}
+	};
+
+	class CastSwipeCatAction : public CastMeleeSpellAction {
+	public:
+		CastSwipeCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (cat)") {}
+	};
+
+	class CastFerociousBiteAction : public CastMeleeSpellAction {
+	public:
+		CastFerociousBiteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "ferocious bite") {}
+	};
+
+
+	class CastRipAction : public CastMeleeSpellAction {
+	public:
+		CastRipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rip") {}
+	};
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
new file mode 100644
index 0000000..d273c7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "DruidActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.h b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
new file mode 100644
index 0000000..1b0c14c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
@@ -0,0 +1,53 @@
+#pragma once
+
+namespace ai {
+	class CastBearFormAction : public CastBuffSpellAction {
+	public:
+		CastBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bear form") {}
+
+        virtual bool isPossible() {
+			return CastBuffSpellAction::isPossible() && !ai->HasAura("dire bear form", GetTarget());
+		}
+        virtual bool isUseful() {
+			return CastBuffSpellAction::isUseful() && !ai->HasAura("dire bear form", GetTarget());
+		}
+	};
+
+	class CastDireBearFormAction : public CastBuffSpellAction {
+	public:
+		CastDireBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "dire bear form") {}
+
+        virtual NextAction** getAlternatives() {
+			return NextAction::merge(NextAction::array(0, new NextAction("bear form"), NULL), CastSpellAction::getAlternatives());
+		}
+	};
+
+	class CastCatFormAction : public CastBuffSpellAction {
+	public:
+		CastCatFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cat form") {}
+	};
+
+	class CastTreeFormAction : public CastBuffSpellAction {
+	public:
+		CastTreeFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tree of life") {}
+	};
+
+	class CastMoonkinFormAction : public CastBuffSpellAction {
+	public:
+		CastMoonkinFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "moonkin form") {}
+	};
+
+	class CastCasterFormAction : public CastBuffSpellAction {
+	public:
+		CastCasterFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "caster form") {}
+
+		virtual bool isUseful() {
+			return ai->HasAnyAuraOf(GetTarget(), "dire bear form", "bear form", "cat form", "travel form", "aquatic form",
+				"flight form", "swift flight form", "moonkin form", "tree of life", NULL);
+		}
+		virtual bool isPossible() { return true; }
+
+		virtual bool Execute(Event event);
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
new file mode 100644
index 0000000..963c9fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidTriggers.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.h b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
new file mode 100644
index 0000000..1c0d4d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
@@ -0,0 +1,127 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai {
+    class MarkOfTheWildOnPartyTrigger : public BuffOnPartyTrigger
+    {
+    public:
+        MarkOfTheWildOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "mark of the wild") {}
+    };
+
+    class MarkOfTheWildTrigger : public BuffTrigger
+    {
+    public:
+        MarkOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mark of the wild") {}
+    };
+
+    class ThornsTrigger : public BuffTrigger
+    {
+    public:
+        ThornsTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "thorns") {}
+    };
+
+    class RakeTrigger : public DebuffTrigger
+    {
+    public:
+        RakeTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rake") {}
+    };
+
+    class InsectSwarmTrigger : public DebuffTrigger
+    {
+    public:
+        InsectSwarmTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "insect swarm") {}
+    };
+
+    class MoonfireTrigger : public DebuffTrigger
+    {
+    public:
+        MoonfireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "moonfire") {}
+    };
+
+    class FaerieFireTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire") {}
+    };
+
+    class FaerieFireFeralTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireFeralTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire (feral)") {}
+    };
+
+    class BashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        BashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "bash") {}
+    };
+
+    class TigersFuryTrigger : public BoostTrigger
+    {
+    public:
+        TigersFuryTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "tiger's fury") {}
+    };
+
+    class NaturesGraspTrigger : public BoostTrigger
+    {
+    public:
+        NaturesGraspTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "nature's grasp") {}
+    };
+
+    class EntanglingRootsTrigger : public HasCcTargetTrigger
+    {
+    public:
+        EntanglingRootsTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "entangling roots") {}
+    };
+
+    class CurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCurePoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCurePoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class BearFormTrigger : public BuffTrigger
+    {
+    public:
+        BearFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "bear form") {}
+        virtual bool IsActive() { return !ai->HasAnyAuraOf(bot, "bear form", "dire bear form", NULL); }
+    };
+
+    class TreeFormTrigger : public BuffTrigger
+    {
+    public:
+        TreeFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "tree of life") {}
+        virtual bool IsActive() { return !ai->HasAura("tree of life", bot); }
+    };
+
+    class CatFormTrigger : public BuffTrigger
+    {
+    public:
+        CatFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "cat form") {}
+        virtual bool IsActive() { return !ai->HasAura("cat form", bot); }
+    };
+
+    class EclipseSolarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseSolarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (solar)") {}
+    };
+
+    class EclipseLunarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseLunarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (lunar)") {}
+    };
+
+    class BashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        BashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
new file mode 100644
index 0000000..1956573
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class FeralDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    FeralDruidStrategyActionNodeFactory()
+    {
+        creators["survival instincts"] = &survival_instincts;
+        creators["thorns"] = &thorns;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+    }
+private:
+    static ActionNode* survival_instincts(PlayerbotAI* ai)
+    {
+        return new ActionNode ("survival instincts",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("barskin"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* thorns(PlayerbotAI* ai)
+    {
+        return new ActionNode ("thorns",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+FeralDruidStrategy::FeralDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new FeralDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+void FeralDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("survival instincts", ACTION_EMERGENCY + 1), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
new file mode 100644
index 0000000..0ee4a8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
@@ -0,0 +1,75 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+namespace ai
+{
+    class ShapeshiftDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShapeshiftDruidStrategyActionNodeFactory()
+        {
+            creators["rejuvenation"] = &rejuvenation;
+            creators["regrowth"] = &regrowth;
+            creators["healing touch"] = &healing_touch;
+            creators["rejuvenation on party"] = &rejuvenation_on_party;
+            creators["regrowth on party"] = &regrowth_on_party;
+            creators["healing touch on party"] = &healing_touch_on_party;
+        }
+    private:
+        static ActionNode* regrowth(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* regrowth_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch on party"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+    };
+
+    class FeralDruidStrategy : public GenericDruidStrategy
+    {
+    protected:
+        FeralDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
new file mode 100644
index 0000000..e6377da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "GenericDruidNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericDruidNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidNonCombatStrategyActionNodeFactory()
+    {
+        creators["mark of the wild"] = &mark_of_the_wild;
+        creators["mark of the wild on party"] = &mark_of_the_wild_on_party;
+        creators["innervate"] = &innervate;
+    }
+private:
+    static ActionNode* mark_of_the_wild(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mark_of_the_wild_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidNonCombatStrategy::GenericDruidNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidNonCombatStrategyActionNodeFactory());
+}
+
+void GenericDruidNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild",
+        NextAction::array(0, new NextAction("mark of the wild", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild on party",
+        NextAction::array(0, new NextAction("mark of the wild on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("revive", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
new file mode 100644
index 0000000..82cba15
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericDruidNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericDruidNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
new file mode 100644
index 0000000..e4f1921
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
@@ -0,0 +1,132 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["caster form"] = &caster_form;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+        creators["rebirth"] = &rebirth;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["innervate"] = &innervate;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* caster_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("caster form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rebirth(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rebirth",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidStrategy::GenericDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidStrategyActionNodeFactory());
+}
+
+void GenericDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_CRITICAL_HEAL + 2), new NextAction("healing touch", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0,  new NextAction("regrowth on party", ACTION_CRITICAL_HEAL + 1), new NextAction("healing touch on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("rebirth", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
new file mode 100644
index 0000000..dc12a85
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericDruidStrategy : public CombatStrategy
+    {
+    protected:
+        GenericDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
new file mode 100644
index 0000000..5b1cfb3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
@@ -0,0 +1,57 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+class HealDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealDruidStrategyActionNodeFactory()
+    {
+    }
+private:
+};
+
+HealDruidStrategy::HealDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new HealDruidStrategyActionNodeFactory());
+}
+
+void HealDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tree form",
+        NextAction::array(0, new NextAction("tree form", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("tranquility", ACTION_MEDIUM_HEAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
new file mode 100644
index 0000000..a0440ba
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+
+namespace ai
+{
+    class HealDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        HealDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+        virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
new file mode 100644
index 0000000..43db065
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackEnemyPlayersStrategy.h"
+
+using namespace ai;
+
+void AttackEnemyPlayersStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy player is attacking",
+        NextAction::array(0, new NextAction("attack enemy player", 61.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
new file mode 100644
index 0000000..cd9ce7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackEnemyPlayersStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackEnemyPlayersStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "pvp"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
new file mode 100644
index 0000000..d33bb74
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackRtiStrategy.h"
+
+using namespace ai;
+
+
+void AttackRtiStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack rti target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
new file mode 100644
index 0000000..ad9662a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackRtiStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackRtiStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack rti"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
new file mode 100644
index 0000000..d3a832a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackWeakStrategy.h"
+
+using namespace ai;
+
+void AttackWeakStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "not least hp target active",
+        NextAction::array(0, new NextAction("attack least hp target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
new file mode 100644
index 0000000..c6c20c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackWeakStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackWeakStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack weak"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
new file mode 100644
index 0000000..7d1a483
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastTimeStrategy.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float CastTimeMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    string name = action->getName();
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastSpellAction*>(action))
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", name);
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            return 1.0f;
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        int32 castTime = spell->GetCastTime();
+        delete spell;
+
+        if (spellId && castTime >= 3000)
+            return 0.0f;
+        else if (spellId && castTime >= 1500)
+            return 0.5f;
+    }
+
+    return 1.0f;
+}
+
+
+void CastTimeStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new CastTimeMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
new file mode 100644
index 0000000..a483fc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+
+    class CastTimeMultiplier : public Multiplier
+    {
+    public:
+        CastTimeMultiplier(PlayerbotAI* ai) : Multiplier(ai, "cast time") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class CastTimeStrategy : public Strategy
+    {
+    public:
+        CastTimeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "cast time"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
new file mode 100644
index 0000000..991551e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+class ChatCommandActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ChatCommandActionNodeFactoryInternal()
+    {
+        creators["tank attack chat shortcut"] = &tank_attack_chat_shortcut;
+    }
+
+private:
+    static ActionNode* tank_attack_chat_shortcut(PlayerbotAI* ai)
+    {
+        return new ActionNode ("tank attack chat shortcut",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("attack my target", 100.0f), NULL));
+    }
+};
+
+void ChatCommandHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "rep",
+        NextAction::array(0, new NextAction("reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "q",
+        NextAction::array(0,
+            new NextAction("query quest", relevance),
+            new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "add all loot",
+        NextAction::array(0, new NextAction("add all loot", relevance), new NextAction("loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "u",
+        NextAction::array(0, new NextAction("use", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "c",
+        NextAction::array(0, new NextAction("item count", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "e",
+        NextAction::array(0, new NextAction("equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ue",
+        NextAction::array(0, new NextAction("unequip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "t",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "nt",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "s",
+        NextAction::array(0, new NextAction("sell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "b",
+        NextAction::array(0, new NextAction("buy", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "r",
+        NextAction::array(0, new NextAction("reward", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attack",
+        NextAction::array(0, new NextAction("attack my target", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "accept",
+        NextAction::array(0, new NextAction("accept quest", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "follow",
+        NextAction::array(0, new NextAction("follow chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "stay",
+        NextAction::array(0, new NextAction("stay chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flee",
+        NextAction::array(0, new NextAction("flee chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tank attack",
+        NextAction::array(0, new NextAction("tank attack chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "grind",
+        NextAction::array(0, new NextAction("grind chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "talk",
+        NextAction::array(0, new NextAction("gossip hello", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cast",
+        NextAction::array(0, new NextAction("cast custom spell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "revive",
+        NextAction::array(0, new NextAction("spirit healer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "runaway",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "warning",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "max dps",
+        NextAction::array(0, new NextAction("max dps chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attackers",
+        NextAction::array(0, new NextAction("tell attackers", relevance), NULL)));
+}
+
+
+
+ChatCommandHandlerStrategy::ChatCommandHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    actionNodeFactories.Add(new ChatCommandActionNodeFactoryInternal());
+
+    supported.push_back("quests");
+    supported.push_back("stats");
+    supported.push_back("leave");
+    supported.push_back("reputation");
+    supported.push_back("log");
+    supported.push_back("los");
+    supported.push_back("drop");
+    supported.push_back("ll");
+    supported.push_back("release");
+    supported.push_back("teleport");
+    supported.push_back("taxi");
+    supported.push_back("repair");
+    supported.push_back("talents");
+    supported.push_back("spells");
+    supported.push_back("co");
+    supported.push_back("nc");
+    supported.push_back("dead");
+    supported.push_back("trainer");
+    supported.push_back("chat");
+    supported.push_back("home");
+    supported.push_back("destroy");
+    supported.push_back("reset ai");
+    supported.push_back("emote");
+    supported.push_back("buff");
+    supported.push_back("help");
+    supported.push_back("gb");
+    supported.push_back("bank");
+    supported.push_back("invite");
+    supported.push_back("spell");
+    supported.push_back("rti");
+    supported.push_back("position");
+    supported.push_back("summon");
+    supported.push_back("who");
+    supported.push_back("save mana");
+    supported.push_back("formation");
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
new file mode 100644
index 0000000..c8c93b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class ChatCommandHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        ChatCommandHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "chat"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
new file mode 100644
index 0000000..4ef95b1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CombatStrategy.h"
+
+using namespace ai;
+
+void CombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "invalid target",
+        NextAction::array(0, new NextAction("drop target", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.h b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
new file mode 100644
index 0000000..475922f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class CombatStrategy : public Strategy
+    {
+    public:
+        CombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
new file mode 100644
index 0000000..b1c13fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ConserveManaStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+#include "../values/LastSpellCastValue.h"
+
+using namespace ai;
+
+float ConserveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 health = AI_VALUE2(uint8, "health", "self target");
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    uint8 mana = AI_VALUE2(uint8, "mana", "self target");
+    bool hasMana = AI_VALUE2(bool, "has mana", "self target");
+    bool mediumMana = hasMana && mana < sPlayerbotAIConfig.mediumMana;
+
+    string name = action->getName();
+
+    if (health < sPlayerbotAIConfig.lowHealth)
+        return 1.0f;
+
+    if (name == "melee" || name == "reach melee" || name == "reach spell")
+        return 1.0f;
+
+    if (mediumMana && dynamic_cast<CastBuffSpellAction*>(action))
+        return 0.0f;
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (AI_VALUE(uint8, "balance") <= 50)
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    if (mediumMana && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+float SaveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL)
+        return 1.0f;
+
+    double saveLevel = AI_VALUE(double, "mana save level");
+    if (saveLevel <= 1.0)
+        return 1.0f;
+
+    CastSpellAction* spellAction = dynamic_cast<CastSpellAction*>(action);
+    if (!spellAction)
+        return 1.0f;
+
+    string spell = spellAction->getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo || spellInfo->PowerType != POWER_MANA)
+        return 1.0f;
+
+    int32 cost = spellInfo->ManaCost;
+    if (spellInfo->ManaCostPercentage)
+        cost += spellInfo->ManaCostPercentage * bot->GetCreateMana() / 100;
+
+    uint32 mana = bot->GetMaxPower(POWER_MANA);
+    double percent = (double)cost / (double)mana * 100.0f;
+
+    time_t lastCastTime = AI_VALUE2(time_t, "last spell cast time", spell);
+    if (!lastCastTime)
+        return 1.0f;
+
+    time_t elapsed = time(0) - lastCastTime;
+    if ((double)elapsed < 10 + pow(saveLevel, sqrt(percent)))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+
+void ConserveManaStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ConserveManaMultiplier(ai));
+    multipliers.push_back(new SaveManaMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
new file mode 100644
index 0000000..a206934
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
@@ -0,0 +1,32 @@
+#pragma once
+
+namespace ai
+{
+    class ConserveManaMultiplier : public Multiplier
+    {
+    public:
+        ConserveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "conserve mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class SaveManaMultiplier : public Multiplier
+    {
+    public:
+        SaveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "save mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ConserveManaStrategy : public Strategy
+    {
+    public:
+        ConserveManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "conserve mana"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
new file mode 100644
index 0000000..1c31adb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "DeadStrategy.h"
+
+using namespace ai;
+
+void DeadStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "dead",
+        NextAction::array(0, new NextAction("revive from corpse", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "resurrect request",
+        NextAction::array(0, new NextAction("accept resurrect", relevance), NULL)));
+}
+
+DeadStrategy::DeadStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.h b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
new file mode 100644
index 0000000..4008570
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DeadStrategy : public PassTroughStrategy
+    {
+    public:
+        DeadStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dead"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
new file mode 100644
index 0000000..40fa703
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAoeStrategy.h"
+
+using namespace ai;
+
+void DpsAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
new file mode 100644
index 0000000..61ac9b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
new file mode 100644
index 0000000..c38860d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAssistStrategy.h"
+
+using namespace ai;
+
+void DpsAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
+
+
+
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
new file mode 100644
index 0000000..4368d7b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps assist"; }
+		virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
new file mode 100644
index 0000000..92e9049
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
@@ -0,0 +1,24 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelStrategy.h"
+
+using namespace ai;
+
+void DuelStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "duel requested",
+        NextAction::array(0, new NextAction("accept duel", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack duel opponent", 70.0f), NULL)));
+}
+
+
+
+DuelStrategy::DuelStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.h b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
new file mode 100644
index 0000000..5828406
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DuelStrategy : public PassTroughStrategy
+    {
+    public:
+        DuelStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "duel"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
new file mode 100644
index 0000000..408ecd1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteStrategy.h"
+
+using namespace ai;
+
+
+void EmoteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("emote", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("suggest what to do", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.h b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
new file mode 100644
index 0000000..7acbc70
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class EmoteStrategy : public Strategy
+    {
+    public:
+        EmoteStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "emote"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
new file mode 100644
index 0000000..4b16bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FleeStrategy.h"
+
+using namespace ai;
+
+void FleeStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "panic",
+        NextAction::array(0, new NextAction("flee", ACTION_EMERGENCY + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+       "critical health",
+       NextAction::array(0, new NextAction("flee", ACTION_MOVE + 9), NULL)));
+
+   triggers.push_back(new TriggerNode(
+       "low mana",
+       NextAction::array(0,  new NextAction("flee", ACTION_MOVE + 9), NULL)));}
+
+void FleeFromAddsStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has nearest adds",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.h b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
new file mode 100644
index 0000000..4aa96b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class FleeStrategy : public Strategy
+    {
+    public:
+        FleeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee"; };
+    };
+
+    class FleeFromAddsStrategy : public Strategy
+    {
+    public:
+        FleeFromAddsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee from adds"; };
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
new file mode 100644
index 0000000..753811b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowMasterStrategy.h"
+
+using namespace ai;
+
+NextAction** FollowMasterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("follow", 1.0f), NULL);
+}
+
+void FollowMasterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "out of react range",
+        NextAction::array(0, new NextAction("tell out of react range", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
new file mode 100644
index 0000000..a43e330
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class FollowMasterStrategy : public NonCombatStrategy
+    {
+    public:
+        FollowMasterStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "follow"; }
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
new file mode 100644
index 0000000..259cc96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindingStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GrindingStrategy::getDefaultActions()
+{
+    return NULL;
+}
+
+void GrindingStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no target",
+        NextAction::array(0,
+        new NextAction("attack anything", 5.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.h b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
new file mode 100644
index 0000000..ce42140
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
@@ -0,0 +1,20 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GrindingStrategy : public NonCombatStrategy
+    {
+    public:
+        GrindingStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "grind"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
new file mode 100644
index 0000000..301322c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuardStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GuardStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("guard", 4.0f), NULL);
+}
+
+void GuardStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.h b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
new file mode 100644
index 0000000..8705ba3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
@@ -0,0 +1,19 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GuardStrategy : public NonCombatStrategy
+    {
+    public:
+        GuardStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "guard"; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
new file mode 100644
index 0000000..e329162
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "KiteStrategy.h"
+
+using namespace ai;
+
+KiteStrategy::KiteStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+}
+
+void KiteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has aggro",
+        NextAction::array(0, new NextAction("runaway", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.h b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
new file mode 100644
index 0000000..e88c7e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class KiteStrategy : public Strategy
+    {
+    public:
+        KiteStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "kite"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
new file mode 100644
index 0000000..0701cf5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootNonCombatStrategy.h"
+
+using namespace ai;
+
+void LootNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "loot available",
+        NextAction::array(0, new NextAction("loot", 6.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "far from loot target",
+        NextAction::array(0, new NextAction("move to loot", 7.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "can loot",
+        NextAction::array(0, new NextAction("open loot", 8.0f), NULL)));
+}
+
+void GatherStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("add gathering loot", 2.0f), NULL)));
+}
+
+
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
new file mode 100644
index 0000000..5eecd63
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+    class LootNonCombatStrategy : public Strategy
+    {
+    public:
+        LootNonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "loot"; }
+    };
+
+    class GatherStrategy : public Strategy
+    {
+    public:
+        GatherStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "gather"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
new file mode 100644
index 0000000..6bc8267
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MeleeCombatStrategy.h"
+
+using namespace ai;
+
+
+void MeleeCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
new file mode 100644
index 0000000..eeeb90a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
@@ -0,0 +1,16 @@
+#include "CombatStrategy.h"
+#include "../generic/CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MeleeCombatStrategy : public CombatStrategy
+    {
+    public:
+        MeleeCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
new file mode 100644
index 0000000..c941dd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MoveRandomStrategy.h"
+
+using namespace ai;
+
+void MoveRandomStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("move random", 1.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
new file mode 100644
index 0000000..ff453bf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MoveRandomStrategy : public NonCombatStrategy
+    {
+    public:
+        MoveRandomStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "move random"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
new file mode 100644
index 0000000..38b8227
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
@@ -0,0 +1,28 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatStrategy.h"
+
+using namespace ai;
+
+void NonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("check mount state", 1.0f), NULL)));
+}
+
+
+void LfgStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("lfg join", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal active",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
new file mode 100644
index 0000000..5216679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class NonCombatStrategy : public Strategy
+    {
+    public:
+        NonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class LfgStrategy : public Strategy
+    {
+    public:
+        LfgStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "lfg"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
new file mode 100644
index 0000000..14083d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+    class PassTroughStrategy : public Strategy
+    {
+    public:
+        PassTroughStrategy(PlayerbotAI* ai, float relevance = 100.0f) : Strategy(ai), relevance(relevance) {}
+
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+        {
+            for (list<string>::iterator i = supported.begin(); i != supported.end(); i++)
+            {
+                string s = i->c_str();
+
+                triggers.push_back(new TriggerNode(
+                    s,
+                    NextAction::array(0, new NextAction(s, relevance), NULL)));
+            }
+        }
+
+    protected:
+        list<string> supported;
+        float relevance;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
new file mode 100644
index 0000000..a4bb3fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PassiveStrategy.h"
+#include "../PassiveMultiplier.h"
+
+using namespace ai;
+
+
+void PassiveStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new PassiveMultiplier(ai));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.h b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
new file mode 100644
index 0000000..8e96388
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class PassiveStrategy : public Strategy
+    {
+    public:
+        PassiveStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "passive"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.cpp b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
new file mode 100644
index 0000000..12aa97b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
@@ -0,0 +1,52 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../PassiveMultiplier.h"
+#include "PullStrategy.h"
+
+using namespace ai;
+
+class MagePullMultiplier : public PassiveMultiplier
+{
+public:
+    MagePullMultiplier(PlayerbotAI* ai, string action) : PassiveMultiplier(ai)
+    {
+        this->action = action;
+    }
+
+public:
+    virtual float GetValue(Action* action);
+
+private:
+    string action;
+};
+
+float MagePullMultiplier::GetValue(Action* action)
+{
+    if (!action)
+        return 1.0f;
+
+    string name = action->getName();
+    if (this->action == name ||
+        name == "reach spell" ||
+        name == "change strategy")
+        return 1.0f;
+
+    return PassiveMultiplier::GetValue(action);
+}
+
+NextAction** PullStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction(action, 105.0f), new NextAction("follow", 104.0f), new NextAction("end pull", 103.0f), NULL);
+}
+
+void PullStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+}
+
+void PullStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new MagePullMultiplier(ai, action));
+    RangedCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.h b/src/plugins/playerbot/strategy/generic/PullStrategy.h
new file mode 100644
index 0000000..946d47c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "RangedCombatStrategy.h"
+
+namespace ai
+{
+    class PullStrategy : public RangedCombatStrategy
+    {
+    public:
+        PullStrategy(PlayerbotAI* ai, string action) : RangedCombatStrategy(ai)
+        {
+            this->action = action;
+        }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "pull"; }
+        virtual NextAction** getDefaultActions();
+
+    private:
+        string action;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
new file mode 100644
index 0000000..1ff375d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
@@ -0,0 +1,69 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestStrategies.h"
+
+using namespace ai;
+
+QuestStrategy::QuestStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("accept quest");
+}
+
+void QuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "quest share",
+        NextAction::array(0, new NextAction("accept quest share", relevance), NULL)));
+}
+
+
+void DefaultQuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, new NextAction("talk to quest giver", relevance), NULL)));
+}
+
+DefaultQuestStrategy::DefaultQuestStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
+
+
+
+void AcceptAllQuestsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+}
+
+AcceptAllQuestsStrategy::AcceptAllQuestsStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.h b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
new file mode 100644
index 0000000..08423dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class QuestStrategy : public PassTroughStrategy
+    {
+    public:
+        QuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class DefaultQuestStrategy : public QuestStrategy
+    {
+    public:
+        DefaultQuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "quest"; }
+    };
+
+    class AcceptAllQuestsStrategy : public QuestStrategy
+    {
+    public:
+        AcceptAllQuestsStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "accept all quests"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
new file mode 100644
index 0000000..8fc73f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
@@ -0,0 +1,39 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RacialsStrategy.h"
+
+using namespace ai;
+
+
+class RacialsStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    RacialsStrategyActionNodeFactory()
+    {
+        creators["lifeblood"] = &lifeblood;
+    }
+private:
+    static ActionNode* lifeblood(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lifeblood",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("gift of the naaru"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+void RacialsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("lifeblood", 71.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("arcane torrent", ACTION_EMERGENCY + 6), NULL)));
+}
+
+RacialsStrategy::RacialsStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+    actionNodeFactories.Add(new RacialsStrategyActionNodeFactory());
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.h b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
new file mode 100644
index 0000000..f5a6c96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class RacialsStrategy : public Strategy
+    {
+    public:
+        RacialsStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "racials"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
new file mode 100644
index 0000000..9fd6ad9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RangedCombatStrategy.h"
+
+using namespace ai;
+
+
+void RangedCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
new file mode 100644
index 0000000..a00cbc1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
@@ -0,0 +1,15 @@
+#include "CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RangedCombatStrategy : public CombatStrategy
+    {
+    public:
+        RangedCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_RANGED; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
new file mode 100644
index 0000000..5ac877b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RunawayStrategy.h"
+
+using namespace ai;
+
+
+NextAction** RunawayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("runaway", 50.0f), NULL);
+}
+
+void RunawayStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.h b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
new file mode 100644
index 0000000..d1c3ef5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RunawayStrategy : public NonCombatStrategy
+       {
+       public:
+           RunawayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+           virtual string getName() { return "runaway"; }
+           virtual NextAction** getDefaultActions();
+           virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+       };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.cpp b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
new file mode 100644
index 0000000..f8cbf96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayStrategy.h"
+
+using namespace ai;
+
+NextAction** StayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stay", 1.0f), NULL);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.h b/src/plugins/playerbot/strategy/generic/StayStrategy.h
new file mode 100644
index 0000000..d9f4229
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.h
@@ -0,0 +1,14 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class StayStrategy : public NonCombatStrategy
+    {
+    public:
+        StayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "stay"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
new file mode 100644
index 0000000..29afdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAoeStrategy.h"
+
+using namespace ai;
+
+void TankAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "tank aoe",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
new file mode 100644
index 0000000..f9ed2fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
new file mode 100644
index 0000000..d54b8ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAssistStrategy.h"
+
+using namespace ai;
+
+
+void TankAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
new file mode 100644
index 0000000..3ecbbb9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
@@ -0,0 +1,17 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank assist"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
new file mode 100644
index 0000000..ce1340d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetStrategy.h"
+
+using namespace ai;
+
+
+void TellTargetStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "target changed",
+        NextAction::array(0, new NextAction("tell target", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
new file mode 100644
index 0000000..22b2e2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class TellTargetStrategy : public Strategy
+    {
+    public:
+        TellTargetStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "TellTarget"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
new file mode 100644
index 0000000..155dc24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float ThreatMultiplier::GetValue(Action* action)
+{
+    if (action == NULL || action->getThreatType() == ACTION_THREAT_NONE)
+        return 1.0f;
+
+    if (action->getThreatType() == ACTION_THREAT_AOE)
+    {
+        uint8 threat = AI_VALUE2(uint8, "threat", "aoe");
+        if (threat >= 90)
+            return 0.0f;
+    }
+
+    uint8 threat = AI_VALUE2(uint8, "threat", "current target");
+
+    if (threat >= 90)
+        return 0.0f;
+
+    return 1.0f;
+}
+
+void ThreatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ThreatMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.h b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
new file mode 100644
index 0000000..406f433
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+
+namespace ai
+{
+    class ThreatMultiplier : public Multiplier
+    {
+    public:
+        ThreatMultiplier(PlayerbotAI* ai) : Multiplier(ai, "threat") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ThreatStrategy : public Strategy
+    {
+    public:
+        ThreatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "threat"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
new file mode 100644
index 0000000..b141a46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseFoodStrategy.h"
+
+using namespace ai;
+
+void UseFoodStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("food", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("drink", 2.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
new file mode 100644
index 0000000..b68ab35
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UseFoodStrategy : public Strategy
+    {
+    public:
+        UseFoodStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "food"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
new file mode 100644
index 0000000..09616bb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UsePotionsStrategy.h"
+
+using namespace ai;
+
+void UsePotionsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing potion", ACTION_MEDIUM_HEAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0,  new NextAction("mana potion", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
new file mode 100644
index 0000000..b48f89f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UsePotionsStrategy : public Strategy
+    {
+    public:
+        UsePotionsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "potions"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
new file mode 100644
index 0000000..177eb5c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
@@ -0,0 +1,107 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WorldPacketHandlerStrategy.h"
+
+using namespace ai;
+
+void WorldPacketHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "group invite",
+        NextAction::array(0, new NextAction("accept invitation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "group set leader",
+        NextAction::array(0, new NextAction("leader", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough money",
+        NextAction::array(0, new NextAction("tell not enough money", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough reputation",
+        NextAction::array(0, new NextAction("tell not enough reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cannot equip",
+        NextAction::array(0, new NextAction("tell cannot equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("add loot", relevance),
+            new NextAction("use meeting stone", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("trainer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "activate taxi",
+        NextAction::array(0, new NextAction("remember taxi", relevance), new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "taxi done",
+        NextAction::array(0, new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "trade status",
+        NextAction::array(0, new NextAction("accept trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "area trigger",
+        NextAction::array(0, new NextAction("reach area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "within area trigger",
+        NextAction::array(0, new NextAction("area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "loot response",
+        NextAction::array(0, new NextAction("store loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "item push result",
+        NextAction::array(0, new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ready check finished",
+        NextAction::array(0, new NextAction("finish ready check", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "often",
+        NextAction::array(0, new NextAction("security check", relevance), new NextAction("check mail", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "guild invite",
+        NextAction::array(0, new NextAction("guild accept", relevance), NULL)));
+
+    // FEYZEE: disable random lfg leave trigger
+    //triggers.push_back(new TriggerNode(
+    //    "seldom",
+    //    NextAction::array(0, new NextAction("lfg leave", relevance), NULL)));
+
+}
+
+WorldPacketHandlerStrategy::WorldPacketHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("loot roll");
+    supported.push_back("check mount state");
+    supported.push_back("quest objective completed");
+    supported.push_back("party command");
+    supported.push_back("ready check");
+    supported.push_back("uninvite");
+    supported.push_back("lfg role check");
+    supported.push_back("lfg teleport");
+}
+
+
+void ReadyCheckStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("ready check", relevance), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
new file mode 100644
index 0000000..6a5a44d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class WorldPacketHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        WorldPacketHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "default"; }
+    };
+
+    class ReadyCheckStrategy : public PassTroughStrategy
+    {
+    public:
+        ReadyCheckStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "ready check"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
new file mode 100644
index 0000000..bb6c477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+
+#include "HunterMultipliers.h"
+#include "DpsHunterStrategy.h"
+
+using namespace ai;
+
+class DpsHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsHunterStrategyActionNodeFactory()
+    {
+        creators["aimed shot"] = &aimed_shot;
+        creators["chimera shot"] = &chimera_shot;
+        creators["explosive shot"] = &explosive_shot;
+        creators["concussive shot"] = &concussive_shot;
+        creators["viper sting"] = &viper_sting;
+    }
+private:
+    static ActionNode* viper_sting(PlayerbotAI* ai)
+    {
+        return new ActionNode ("viper sting",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aimed_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aimed shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("chimera shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chimera_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chimera shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* explosive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("explosive shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aimed shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* concussive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("concussive shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("wyvern sting", 11.0f), NULL));
+    }
+
+};
+
+DpsHunterStrategy::DpsHunterStrategy(PlayerbotAI* ai) : GenericHunterStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsHunterStrategyActionNodeFactory());
+}
+
+NextAction** DpsHunterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("explosive shot", 11.0f), new NextAction("auto shot", 10.0f), NULL);
+}
+
+void DpsHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericHunterStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "black arrow",
+        NextAction::array(0, new NextAction("black arrow", 51.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("viper sting", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunter's mark",
+        NextAction::array(0, new NextAction("hunter's mark", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "freezing trap",
+        NextAction::array(0, new NextAction("freezing trap", 83.0f), NULL)));
+}
+
+void DpsAoeHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("multi-shot", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("volley", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"serpent sting on attacker",
+		NextAction::array(0, new NextAction("serpent sting on attacker", 49.0f), NULL)));
+}
+
+void DpsHunterDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no stings",
+        NextAction::array(0, new NextAction("serpent sting", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
new file mode 100644
index 0000000..4992e0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsHunterStrategy : public GenericHunterStrategy
+    {
+    public:
+        DpsHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+
+    };
+
+    class DpsAoeHunterStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeHunterStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsHunterDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsHunterDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
new file mode 100644
index 0000000..6fab572
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "GenericHunterNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericHunterNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterNonCombatStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterNonCombatStrategy::GenericHunterNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterNonCombatStrategyActionNodeFactory());
+}
+
+void GenericHunterNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "trueshot aura",
+        NextAction::array(0, new NextAction("trueshot aura", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet dead",
+        NextAction::array(0, new NextAction("revive pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
new file mode 100644
index 0000000..d01486d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericHunterNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericHunterNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
new file mode 100644
index 0000000..e4c5d45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericHunterStrategy.h"
+#include "HunterAiObjectContext.h"
+
+using namespace ai;
+
+class GenericHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+        creators["feign death"] = &feign_death;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* feign_death(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feign death",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterStrategy::GenericHunterStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterStrategyActionNodeFactory());
+}
+
+void GenericHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("wing clip", 50.0f), new NextAction("flee",49.0f), new NextAction("concussive shot", 48.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("feign death", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rapid fire",
+        NextAction::array(0, new NextAction("rapid fire", 55.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
new file mode 100644
index 0000000..f2db28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericHunterStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "hunter"; }
+    };
+}
+
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.cpp b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
new file mode 100644
index 0000000..00d13e4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../actions/GenericActions.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool CastSerpentStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "health", "current target") > 50;
+}
+
+bool CastViperStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "mana", "self target") < 50 && AI_VALUE2(uint8, "mana", "current target") >= 30;
+}
+
+bool CastAspectOfTheCheetahAction::isUseful()
+{
+    return !ai->HasAnyAuraOf(GetTarget(), "aspect of the cheetah", "aspect of the pack", NULL);
+}
+
+Value<Unit*>* CastFreezingTrap::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "freezing trap");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.h b/src/plugins/playerbot/strategy/hunter/HunterActions.h
new file mode 100644
index 0000000..74611ce
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.h
@@ -0,0 +1,154 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    BEGIN_RANGED_SPELL_ACTION(CastHuntersMarkAction, "hunter's mark")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastAutoShotAction, "auto shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastArcaneShotAction, "arcane shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastExplosiveShotAction, "explosive shot")
+    END_SPELL_ACTION()
+
+
+    BEGIN_RANGED_SPELL_ACTION(CastAimedShotAction, "aimed shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastChimeraShotAction, "chimera shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastConcussiveShotAction, "concussive shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastDistractingShotAction, "distracting shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMultiShotAction, "multi-shot")
+    END_SPELL_ACTION()
+
+	BEGIN_RANGED_SPELL_ACTION(CastVolleyAction, "volley")
+	END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSerpentStingAction, "serpent sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastWyvernStingAction, "wyvern sting")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastViperStingAction, "viper sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastScorpidStingAction, "scorpid sting")
+    END_SPELL_ACTION()
+
+	class CastAspectOfTheHawkAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheHawkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the hawk") {}
+	};
+
+	class CastAspectOfTheWildAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the wild") {}
+	};
+
+	class CastAspectOfTheCheetahAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheCheetahAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the cheetah") {}
+		virtual bool isUseful();
+	};
+
+	class CastAspectOfThePackAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfThePackAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the pack") {}
+	};
+
+	class CastAspectOfTheViperAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheViperAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the viper") {}
+	};
+
+	class CastCallPetAction : public CastBuffSpellAction
+	{
+	public:
+		CastCallPetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "call pet") {}
+	};
+
+	class CastMendPetAction : public CastAuraSpellAction
+	{
+	public:
+		CastMendPetAction(PlayerbotAI* ai) : CastAuraSpellAction(ai, "mend pet") {}
+		virtual string GetTargetName() { return "pet target"; }
+	};
+
+	class CastRevivePetAction : public CastBuffSpellAction
+	{
+	public:
+		CastRevivePetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "revive pet") {}
+	};
+
+    class CastTrueshotAuraAction : public CastBuffSpellAction
+    {
+    public:
+        CastTrueshotAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "trueshot aura") {}
+    };
+
+    class CastFeignDeathAction : public CastBuffSpellAction
+    {
+    public:
+        CastFeignDeathAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feign death") {}
+    };
+
+	class CastRapidFireAction : public CastBuffSpellAction
+	{
+	public:
+		CastRapidFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "rapid fire") {}
+	};
+
+	class CastReadinessAction : public CastBuffSpellAction
+	{
+	public:
+		CastReadinessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "readiness") {}
+	};
+
+	class CastBlackArrow : public CastDebuffSpellAction
+	{
+	public:
+		CastBlackArrow(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "black arrow") {}
+	};
+
+    class CastFreezingTrap : public CastDebuffSpellAction
+    {
+    public:
+        CastFreezingTrap(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "freezing trap") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+    class CastWingClipAction : public CastMeleeSpellAction
+    {
+    public:
+        CastWingClipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "wing clip") {}
+        virtual bool isUseful()
+        {
+            return CastMeleeSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class CastSerpentStingOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastSerpentStingOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
new file mode 100644
index 0000000..dd62523
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
@@ -0,0 +1,191 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterActions.h"
+#include "HunterTriggers.h"
+#include "HunterAiObjectContext.h"
+#include "DpsHunterStrategy.h"
+#include "GenericHunterNonCombatStrategy.h"
+#include "HunterBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &hunter::StrategyFactoryInternal::dps;
+                creators["nc"] = &hunter::StrategyFactoryInternal::nc;
+                creators["aoe"] = &hunter::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &hunter::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeHunterStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsHunterStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericHunterNonCombatStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsHunterDebuffStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bspeed"] = &hunter::BuffStrategyFactoryInternal::bspeed;
+                creators["bdps"] = &hunter::BuffStrategyFactoryInternal::bdps;
+                creators["bmana"] = &hunter::BuffStrategyFactoryInternal::bmana;
+                creators["rnature"] = &hunter::BuffStrategyFactoryInternal::rnature;
+            }
+
+        private:
+            static Strategy* bspeed(PlayerbotAI* ai) { return new HunterBuffSpeedStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new HunterBuffDpsStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new HunterBuffManaStrategy(ai); }
+            static Strategy* rnature(PlayerbotAI* ai) { return new HunterNatureResistanceStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["black arrow"] = &TriggerFactoryInternal::black_arrow;
+                creators["no stings"] = &TriggerFactoryInternal::NoStings;
+                creators["hunters pet dead"] = &TriggerFactoryInternal::hunters_pet_dead;
+                creators["hunters pet low health"] = &TriggerFactoryInternal::hunters_pet_low_health;
+                creators["hunter's mark"] = &TriggerFactoryInternal::hunters_mark;
+                creators["freezing trap"] = &TriggerFactoryInternal::freezing_trap;
+                creators["aspect of the pack"] = &TriggerFactoryInternal::aspect_of_the_pack;
+                creators["rapid fire"] = &TriggerFactoryInternal::rapid_fire;
+                creators["aspect of the hawk"] = &TriggerFactoryInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &TriggerFactoryInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["trueshot aura"] = &TriggerFactoryInternal::trueshot_aura;
+                creators["serpent sting on attacker"] = &TriggerFactoryInternal::serpent_sting_on_attacker;
+            }
+
+        private:
+            static Trigger* serpent_sting_on_attacker(PlayerbotAI* ai) { return new SerpentStingOnAttackerTrigger(ai); }
+            static Trigger* trueshot_aura(PlayerbotAI* ai) { return new TrueshotAuraTrigger(ai); }
+            static Trigger* aspect_of_the_viper(PlayerbotAI* ai) { return new HunterAspectOfTheViperTrigger(ai); }
+            static Trigger* black_arrow(PlayerbotAI* ai) { return new BlackArrowTrigger(ai); }
+            static Trigger* NoStings(PlayerbotAI* ai) { return new HunterNoStingsActiveTrigger(ai); }
+            static Trigger* hunters_pet_dead(PlayerbotAI* ai) { return new HuntersPetDeadTrigger(ai); }
+            static Trigger* hunters_pet_low_health(PlayerbotAI* ai) { return new HuntersPetLowHealthTrigger(ai); }
+            static Trigger* hunters_mark(PlayerbotAI* ai) { return new HuntersMarkTrigger(ai); }
+            static Trigger* freezing_trap(PlayerbotAI* ai) { return new FreezingTrapTrigger(ai); }
+            static Trigger* aspect_of_the_pack(PlayerbotAI* ai) { return new HunterAspectOfThePackTrigger(ai); }
+            static Trigger* rapid_fire(PlayerbotAI* ai) { return new RapidFireTrigger(ai); }
+            static Trigger* aspect_of_the_hawk(PlayerbotAI* ai) { return new HunterAspectOfTheHawkTrigger(ai); }
+            static Trigger* aspect_of_the_wild(PlayerbotAI* ai) { return new HunterAspectOfTheWildTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["auto shot"] = &AiObjectContextInternal::auto_shot;
+                creators["aimed shot"] = &AiObjectContextInternal::aimed_shot;
+                creators["chimera shot"] = &AiObjectContextInternal::chimera_shot;
+                creators["explosive shot"] = &AiObjectContextInternal::explosive_shot;
+                creators["arcane shot"] = &AiObjectContextInternal::arcane_shot;
+                creators["concussive shot"] = &AiObjectContextInternal::concussive_shot;
+                creators["distracting shot"] = &AiObjectContextInternal::distracting_shot;
+                creators["multi-shot"] = &AiObjectContextInternal::multi_shot;
+                creators["volley"] = &AiObjectContextInternal::volley;
+                creators["serpent sting"] = &AiObjectContextInternal::serpent_sting;
+                creators["serpent sting on attacker"] = &AiObjectContextInternal::serpent_sting_on_attacker;
+                creators["wyvern sting"] = &AiObjectContextInternal::wyvern_sting;
+                creators["viper sting"] = &AiObjectContextInternal::viper_sting;
+                creators["scorpid sting"] = &AiObjectContextInternal::scorpid_sting;
+                creators["hunter's mark"] = &AiObjectContextInternal::hunters_mark;
+                creators["mend pet"] = &AiObjectContextInternal::mend_pet;
+                creators["revive pet"] = &AiObjectContextInternal::revive_pet;
+                creators["call pet"] = &AiObjectContextInternal::call_pet;
+                creators["black arrow"] = &AiObjectContextInternal::black_arrow;
+                creators["freezing trap"] = &AiObjectContextInternal::freezing_trap;
+                creators["rapid fire"] = &AiObjectContextInternal::rapid_fire;
+                creators["boost"] = &AiObjectContextInternal::rapid_fire;
+                creators["readiness"] = &AiObjectContextInternal::readiness;
+                creators["aspect of the hawk"] = &AiObjectContextInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &AiObjectContextInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &AiObjectContextInternal::aspect_of_the_viper;
+                creators["aspect of the pack"] = &AiObjectContextInternal::aspect_of_the_pack;
+                creators["aspect of the cheetah"] = &AiObjectContextInternal::aspect_of_the_cheetah;
+                creators["trueshot aura"] = &AiObjectContextInternal::trueshot_aura;
+                creators["feign death"] = &AiObjectContextInternal::feign_death;
+                creators["wing clip"] = &AiObjectContextInternal::wing_clip;
+            }
+
+        private:
+            static Action* feign_death(PlayerbotAI* ai) { return new CastFeignDeathAction(ai); }
+            static Action* trueshot_aura(PlayerbotAI* ai) { return new CastTrueshotAuraAction(ai); }
+            static Action* auto_shot(PlayerbotAI* ai) { return new CastAutoShotAction(ai); }
+            static Action* aimed_shot(PlayerbotAI* ai) { return new CastAimedShotAction(ai); }
+            static Action* chimera_shot(PlayerbotAI* ai) { return new CastChimeraShotAction(ai); }
+            static Action* explosive_shot(PlayerbotAI* ai) { return new CastExplosiveShotAction(ai); }
+            static Action* arcane_shot(PlayerbotAI* ai) { return new CastArcaneShotAction(ai); }
+            static Action* concussive_shot(PlayerbotAI* ai) { return new CastConcussiveShotAction(ai); }
+            static Action* distracting_shot(PlayerbotAI* ai) { return new CastDistractingShotAction(ai); }
+            static Action* multi_shot(PlayerbotAI* ai) { return new CastMultiShotAction(ai); }
+            static Action* volley(PlayerbotAI* ai) { return new CastVolleyAction(ai); }
+            static Action* serpent_sting(PlayerbotAI* ai) { return new CastSerpentStingAction(ai); }
+            static Action* serpent_sting_on_attacker(PlayerbotAI* ai) { return new CastSerpentStingOnAttackerAction(ai); }
+            static Action* wyvern_sting(PlayerbotAI* ai) { return new CastWyvernStingAction(ai); }
+            static Action* viper_sting(PlayerbotAI* ai) { return new CastViperStingAction(ai); }
+            static Action* scorpid_sting(PlayerbotAI* ai) { return new CastScorpidStingAction(ai); }
+            static Action* hunters_mark(PlayerbotAI* ai) { return new CastHuntersMarkAction(ai); }
+            static Action* mend_pet(PlayerbotAI* ai) { return new CastMendPetAction(ai); }
+            static Action* revive_pet(PlayerbotAI* ai) { return new CastRevivePetAction(ai); }
+            static Action* call_pet(PlayerbotAI* ai) { return new CastCallPetAction(ai); }
+            static Action* black_arrow(PlayerbotAI* ai) { return new CastBlackArrow(ai); }
+            static Action* freezing_trap(PlayerbotAI* ai) { return new CastFreezingTrap(ai); }
+            static Action* rapid_fire(PlayerbotAI* ai) { return new CastRapidFireAction(ai); }
+            static Action* readiness(PlayerbotAI* ai) { return new CastReadinessAction(ai); }
+            static Action* aspect_of_the_hawk(PlayerbotAI* ai) { return new CastAspectOfTheHawkAction(ai); }
+            static Action* aspect_of_the_wild(PlayerbotAI* ai) { return new CastAspectOfTheWildAction(ai); }
+            static Action* aspect_of_the_viper(PlayerbotAI* ai) { return new CastAspectOfTheViperAction(ai); }
+            static Action* aspect_of_the_pack(PlayerbotAI* ai) { return new CastAspectOfThePackAction(ai); }
+            static Action* aspect_of_the_cheetah(PlayerbotAI* ai) { return new CastAspectOfTheCheetahAction(ai); }
+            static Action* wing_clip(PlayerbotAI* ai) { return new CastWingClipAction(ai); }
+        };
+    };
+};
+
+HunterAiObjectContext::HunterAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::hunter::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::hunter::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::hunter::AiObjectContextInternal());
+    triggerContexts.Add(new ai::hunter::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
new file mode 100644
index 0000000..8891a54
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class HunterAiObjectContext : public AiObjectContext
+    {
+    public:
+        HunterAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
new file mode 100644
index 0000000..d06ec54
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "HunterBuffStrategies.h"
+
+using namespace ai;
+
+void HunterBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the hawk",
+		NextAction::array(0, new NextAction("aspect of the hawk", 90.0f), NULL)));
+}
+
+void HunterNatureResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the wild",
+		NextAction::array(0, new NextAction("aspect of the wild", 90.0f), NULL)));
+}
+
+
+void HunterBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the pack",
+        NextAction::array(0, new NextAction("aspect of the pack", 10.0f), NULL)));
+}
+
+void HunterBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the viper",
+        NextAction::array(0, new NextAction("aspect of the viper", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
new file mode 100644
index 0000000..d59f245
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class HunterBuffSpeedStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffSpeedStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bspeed"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class HunterBuffManaStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffManaStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bmana"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+	class HunterBuffDpsStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterBuffDpsStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "bdps"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+
+	class HunterNatureResistanceStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterNatureResistanceStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "rnature"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
new file mode 100644
index 0000000..9d0bdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
new file mode 100644
index 0000000..c356a0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterTriggers.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool HunterNoStingsActiveTrigger::IsActive()
+{
+	Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(uint8, "health", "current target") > 40 &&
+        !ai->HasAura("serpent sting", target) &&
+        !ai->HasAura("scorpid sting", target) &&
+        !ai->HasAura("viper sting", target);
+}
+
+bool HuntersPetDeadTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
+
+
+bool HuntersPetLowHealthTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(uint8, "health", "pet target") < 40 &&
+        !AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.h b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
new file mode 100644
index 0000000..9466218
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BEGIN_TRIGGER(HunterNoStingsActiveTrigger, Trigger)
+    END_TRIGGER()
+
+    class HunterAspectOfTheHawkTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheHawkTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the hawk") {
+			checkInterval = 1;
+		}
+    };
+
+	class HunterAspectOfTheWildTrigger : public BuffTrigger
+	{
+	public:
+		HunterAspectOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the wild") {
+			checkInterval = 1;
+		}
+	};
+
+    class HunterAspectOfTheViperTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheViperTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the viper") {}
+        virtual bool IsActive()
+        {
+            return SpellTrigger::IsActive() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class HunterAspectOfThePackTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfThePackTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the pack") {}
+        virtual bool IsActive() {
+			return BuffTrigger::IsActive() && !ai->HasAura("aspect of the cheetah", GetTarget());
+        };
+    };
+
+    BEGIN_TRIGGER(HuntersPetDeadTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(HuntersPetLowHealthTrigger, Trigger)
+    END_TRIGGER()
+
+    class BlackArrowTrigger : public DebuffTrigger
+    {
+    public:
+        BlackArrowTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "black arrow") {}
+    };
+
+    class HuntersMarkTrigger : public DebuffTrigger
+    {
+    public:
+        HuntersMarkTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "hunter's mark") {}
+    };
+
+    class FreezingTrapTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FreezingTrapTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "freezing trap") {}
+    };
+
+    class RapidFireTrigger : public BoostTrigger
+    {
+    public:
+        RapidFireTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "rapid fire") {}
+    };
+
+    class TrueshotAuraTrigger : public BuffTrigger
+    {
+    public:
+        TrueshotAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "trueshot aura") {}
+    };
+
+    class SerpentStingOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        SerpentStingOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
new file mode 100644
index 0000000..0779477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
@@ -0,0 +1,64 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "ArcaneMageStrategy.h"
+
+using namespace ai;
+
+class ArcaneMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    ArcaneMageStrategyActionNodeFactory()
+    {
+        creators["arcane blast"] = &arcane_blast;
+        creators["arcane barrage"] = &arcane_barrage;
+        creators["arcane missiles"] = &arcane_missiles;
+    }
+private:
+    static ActionNode* arcane_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_barrage(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane barrage",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_missiles(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane missiles",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+ArcaneMageStrategy::ArcaneMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+    actionNodeFactories.Add(new ArcaneMageStrategyActionNodeFactory());
+}
+
+NextAction** ArcaneMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("arcane barrage", 10.0f), NULL);
+}
+
+void ArcaneMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane blast",
+        NextAction::array(0, new NextAction("arcane blast", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "missile barrage",
+        NextAction::array(0, new NextAction("arcane missiles", 15.0f), NULL)));
+
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
new file mode 100644
index 0000000..ac053a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+
+namespace ai
+{
+    class ArcaneMageStrategy : public GenericMageStrategy
+    {
+    public:
+        ArcaneMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "arcane"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
new file mode 100644
index 0000000..47c4bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FireMageStrategy.h"
+
+using namespace ai;
+
+NextAction** FireMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("scorch", 7.0f), new NextAction("fireball", 6.0f), new NextAction("fire blast", 5.0f), NULL);
+}
+
+void FireMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "pyroblast",
+        NextAction::array(0, new NextAction("pyroblast", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hot streak",
+        NextAction::array(0, new NextAction("pyroblast", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combustion",
+        NextAction::array(0, new NextAction("combustion", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("dragon's breath", 70.0f), NULL)));
+}
+
+void FireMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flamestrike", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "living bomb",
+        NextAction::array(0, new NextAction("living bomb", 25.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.h b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
new file mode 100644
index 0000000..fc0cd7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FireMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FireMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FireMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FireMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
new file mode 100644
index 0000000..e6fb861
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FrostMageStrategy.h"
+
+using namespace ai;
+
+
+FrostMageStrategy::FrostMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+}
+
+NextAction** FrostMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("frostbolt", 7.0f), NULL);
+}
+
+void FrostMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "icy veins",
+        NextAction::array(0, new NextAction("icy veins", 50.0f), NULL)));
+}
+
+void FrostMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("blizzard", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
new file mode 100644
index 0000000..15fac2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FrostMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FrostMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FrostMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FrostMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
new file mode 100644
index 0000000..f4111de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
@@ -0,0 +1,87 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericMageNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageNonCombatStrategyActionNodeFactory()
+    {
+        creators["molten armor"] = &molten_armor;
+        creators["mage armor"] = &mage_armor;
+        creators["ice armor"] = &ice_armor;
+    }
+private:
+    static ActionNode* molten_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("molten armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mage armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mage_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mage armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("ice armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* ice_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ice armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost armor"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericMageNonCombatStrategy::GenericMageNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageNonCombatStrategyActionNodeFactory());
+}
+
+void GenericMageNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect",
+        NextAction::array(0, new NextAction("arcane intellect", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect on party",
+        NextAction::array(0, new NextAction("arcane intellect on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no drink",
+		NextAction::array(0, new NextAction("conjure water", 16.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no food",
+		NextAction::array(0, new NextAction("conjure food", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+}
+
+void MageBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("mage armor", 19.0f), NULL)));
+}
+
+void MageBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("molten armor", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
new file mode 100644
index 0000000..5319bf9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericMageNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class MageBuffManaStrategy : public Strategy
+    {
+    public:
+        MageBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class MageBuffDpsStrategy : public Strategy
+    {
+    public:
+        MageBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
new file mode 100644
index 0000000..7f137c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageStrategy.h"
+
+using namespace ai;
+
+class GenericMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageStrategyActionNodeFactory()
+    {
+        creators["frostbolt"] = &frostbolt;
+        creators["fire blast"] = &fire_blast;
+        creators["scorch"] = &scorch;
+        creators["frost nova"] = &frost_nova;
+        creators["icy veins"] = &icy_veins;
+        creators["combustion"] = &combustion;
+        creators["evocation"] = &evocation;
+        creators["dragon's breath"] = &dragons_breath;
+        creators["blast wave"] = &blast_wave;
+    }
+private:
+    static ActionNode* frostbolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* fire_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fire blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("scorch"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* scorch(PlayerbotAI* ai)
+    {
+        return new ActionNode ("scorch",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frost_nova(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frost nova",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee"), NULL));
+    }
+    static ActionNode* icy_veins(PlayerbotAI* ai)
+    {
+        return new ActionNode ("icy veins",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* combustion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("combustion",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* evocation(PlayerbotAI* ai)
+    {
+        return new ActionNode ("evocation",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* dragons_breath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dragon's breath",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blast wave"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+    static ActionNode* blast_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blast wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost nova"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+};
+
+GenericMageStrategy::GenericMageStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageStrategyActionNodeFactory());
+}
+
+void GenericMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("frost nova", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell",
+        NextAction::array(0, new NextAction("counterspell", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell on enemy healer",
+        NextAction::array(0, new NextAction("counterspell on enemy healer", 40.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("ice block", 80.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "polymorph",
+        NextAction::array(0, new NextAction("polymorph", 30.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"spellsteal",
+		NextAction::array(0, new NextAction("spellsteal", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("invisibility", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("evocation", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
new file mode 100644
index 0000000..4dcb9d9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericMageStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "mage"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.cpp b/src/plugins/playerbot/strategy/mage/MageActions.cpp
new file mode 100644
index 0000000..ee4d6fc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+Value<Unit*>* CastPolymorphAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", getName());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.h b/src/plugins/playerbot/strategy/mage/MageActions.h
new file mode 100644
index 0000000..ea541a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastFireballAction : public CastSpellAction
+    {
+    public:
+        CastFireballAction(PlayerbotAI* ai) : CastSpellAction(ai, "fireball") {}
+    };
+
+    class CastScorchAction : public CastSpellAction
+    {
+    public:
+        CastScorchAction(PlayerbotAI* ai) : CastSpellAction(ai, "scorch") {}
+    };
+
+    class CastFireBlastAction : public CastSpellAction
+    {
+    public:
+        CastFireBlastAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire blast") {}
+    };
+
+    class CastArcaneBlastAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneBlastAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane blast") {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class CastArcaneBarrageAction : public CastSpellAction
+    {
+    public:
+        CastArcaneBarrageAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane barrage") {}
+    };
+
+    class CastArcaneMissilesAction : public CastSpellAction
+    {
+    public:
+        CastArcaneMissilesAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane missiles") {}
+    };
+
+    class CastPyroblastAction : public CastSpellAction
+    {
+    public:
+        CastPyroblastAction(PlayerbotAI* ai) : CastSpellAction(ai, "pyroblast") {}
+    };
+
+    class CastFlamestrikeAction : public CastSpellAction
+    {
+    public:
+        CastFlamestrikeAction(PlayerbotAI* ai) : CastSpellAction(ai, "flamestrike") {}
+    };
+
+    class CastFrostNovaAction : public CastSpellAction
+    {
+    public:
+        CastFrostNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "frost nova") {}
+        virtual bool isUseful() { return AI_VALUE2(float, "distance", GetTargetName()) <= sPlayerbotAIConfig.tooCloseDistance; }
+    };
+
+	class CastFrostboltAction : public CastSpellAction
+	{
+	public:
+		CastFrostboltAction(PlayerbotAI* ai) : CastSpellAction(ai, "frostbolt") {}
+	};
+
+	class CastBlizzardAction : public CastSpellAction
+	{
+	public:
+		CastBlizzardAction(PlayerbotAI* ai) : CastSpellAction(ai, "blizzard") {}
+	};
+
+	class CastArcaneIntellectAction : public CastBuffSpellAction
+    {
+	public:
+		CastArcaneIntellectAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane intellect") {}
+	};
+
+	class CastArcaneIntellectOnPartyAction : public BuffOnPartyAction
+    {
+	public:
+		CastArcaneIntellectOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "arcane intellect") {}
+	};
+
+	class CastRemoveCurseAction : public CastCureSpellAction
+    {
+	public:
+		CastRemoveCurseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "remove curse") {}
+	};
+
+	class CastIcyVeinsAction : public CastBuffSpellAction
+    {
+	public:
+		CastIcyVeinsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "icy veins") {}
+	};
+
+	class CastCombustionAction : public CastBuffSpellAction
+    {
+	public:
+		CastCombustionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "combustion") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastCounterspellAction, "counterspell")
+    END_SPELL_ACTION()
+
+    class CastRemoveCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastRemoveCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+	class CastConjureFoodAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureFoodAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure food") {}
+	};
+
+	class CastConjureWaterAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureWaterAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure water") {}
+	};
+
+	class CastIceBlockAction : public CastBuffSpellAction
+    {
+	public:
+		CastIceBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice block") {}
+	};
+
+    class CastMoltenArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMoltenArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "molten armor") {}
+    };
+
+    class CastMageArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMageArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mage armor") {}
+    };
+
+    class CastIceArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastIceArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice armor") {}
+    };
+
+    class CastFrostArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastFrostArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost armor") {}
+    };
+
+    class CastPolymorphAction : public CastBuffSpellAction
+    {
+    public:
+        CastPolymorphAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "polymorph") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+	class CastSpellstealAction : public CastSpellAction
+	{
+	public:
+		CastSpellstealAction(PlayerbotAI* ai) : CastSpellAction(ai, "spellsteal") {}
+	};
+
+	class CastLivingBombAction : public CastDebuffSpellAction
+	{
+	public:
+	    CastLivingBombAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "living bomb") {}
+	};
+
+	class CastDragonsBreathAction : public CastSpellAction
+	{
+	public:
+	    CastDragonsBreathAction(PlayerbotAI* ai) : CastSpellAction(ai, "dragon's breath") {}
+	};
+
+	class CastBlastWaveAction : public CastSpellAction
+	{
+	public:
+	    CastBlastWaveAction(PlayerbotAI* ai) : CastSpellAction(ai, "blast wave") {}
+	};
+
+	class CastInvisibilityAction : public CastBuffSpellAction
+	{
+	public:
+	    CastInvisibilityAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "invisibility") {}
+	};
+
+	class CastEvocationAction : public CastSpellAction
+	{
+	public:
+	    CastEvocationAction(PlayerbotAI* ai) : CastSpellAction(ai, "evocation") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+    class CastCounterspellOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+	    CastCounterspellOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
new file mode 100644
index 0000000..366ef77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
@@ -0,0 +1,221 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "MageActions.h"
+#include "MageAiObjectContext.h"
+#include "FrostMageStrategy.h"
+#include "ArcaneMageStrategy.h"
+#include "GenericMageNonCombatStrategy.h"
+#include "FireMageStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "MageTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &mage::StrategyFactoryInternal::nc;
+                creators["pull"] = &mage::StrategyFactoryInternal::pull;
+                creators["fire aoe"] = &mage::StrategyFactoryInternal::fire_aoe;
+                creators["frost aoe"] = &mage::StrategyFactoryInternal::frost_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericMageNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* fire_aoe(PlayerbotAI* ai) { return new FireMageAoeStrategy(ai); }
+            static Strategy* frost_aoe(PlayerbotAI* ai) { return new FrostMageAoeStrategy(ai); }
+        };
+
+        class MageStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["frost"] = &mage::MageStrategyFactoryInternal::frost;
+                creators["fire"] = &mage::MageStrategyFactoryInternal::fire;
+                creators["arcane"] = &mage::MageStrategyFactoryInternal::arcane;
+            }
+
+        private:
+            static Strategy* frost(PlayerbotAI* ai) { return new FrostMageStrategy(ai); }
+            static Strategy* fire(PlayerbotAI* ai) { return new FireMageStrategy(ai); }
+            static Strategy* arcane(PlayerbotAI* ai) { return new ArcaneMageStrategy(ai); }
+        };
+
+        class MageBuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageBuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &mage::MageBuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &mage::MageBuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new MageBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new MageBuffDpsStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["fireball"] = &TriggerFactoryInternal::fireball;
+                creators["pyroblast"] = &TriggerFactoryInternal::pyroblast;
+                creators["combustion"] = &TriggerFactoryInternal::combustion;
+                creators["icy veins"] = &TriggerFactoryInternal::icy_veins;
+                creators["arcane intellect"] = &TriggerFactoryInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &TriggerFactoryInternal::arcane_intellect_on_party;
+                creators["mage armor"] = &TriggerFactoryInternal::mage_armor;
+                creators["remove curse"] = &TriggerFactoryInternal::remove_curse;
+                creators["remove curse on party"] = &TriggerFactoryInternal::remove_curse_on_party;
+                creators["counterspell"] = &TriggerFactoryInternal::counterspell;
+                creators["polymorph"] = &TriggerFactoryInternal::polymorph;
+                creators["spellsteal"] = &TriggerFactoryInternal::spellsteal;
+                creators["hot streak"] = &TriggerFactoryInternal::hot_streak;
+                creators["living bomb"] = &TriggerFactoryInternal::living_bomb;
+                creators["missile barrage"] = &TriggerFactoryInternal::missile_barrage;
+                creators["arcane blast"] = &TriggerFactoryInternal::arcane_blast;
+                creators["counterspell on enemy healer"] = &TriggerFactoryInternal::counterspell_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hot_streak(PlayerbotAI* ai) { return new HotStreakTrigger(ai); }
+            static Trigger* fireball(PlayerbotAI* ai) { return new FireballTrigger(ai); }
+            static Trigger* pyroblast(PlayerbotAI* ai) { return new PyroblastTrigger(ai); }
+            static Trigger* combustion(PlayerbotAI* ai) { return new CombustionTrigger(ai); }
+            static Trigger* icy_veins(PlayerbotAI* ai) { return new IcyVeinsTrigger(ai); }
+            static Trigger* arcane_intellect(PlayerbotAI* ai) { return new ArcaneIntellectTrigger(ai); }
+            static Trigger* arcane_intellect_on_party(PlayerbotAI* ai) { return new ArcaneIntellectOnPartyTrigger(ai); }
+            static Trigger* mage_armor(PlayerbotAI* ai) { return new MageArmorTrigger(ai); }
+            static Trigger* remove_curse(PlayerbotAI* ai) { return new RemoveCurseTrigger(ai); }
+            static Trigger* remove_curse_on_party(PlayerbotAI* ai) { return new PartyMemberRemoveCurseTrigger(ai); }
+            static Trigger* counterspell(PlayerbotAI* ai) { return new CounterspellInterruptSpellTrigger(ai); }
+            static Trigger* polymorph(PlayerbotAI* ai) { return new PolymorphTrigger(ai); }
+            static Trigger* spellsteal(PlayerbotAI* ai) { return new SpellstealTrigger(ai); }
+            static Trigger* living_bomb(PlayerbotAI* ai) { return new LivingBombTrigger(ai); }
+            static Trigger* missile_barrage(PlayerbotAI* ai) { return new MissileBarrageTrigger(ai); }
+            static Trigger* arcane_blast(PlayerbotAI* ai) { return new ArcaneBlastTrigger(ai); }
+            static Trigger* counterspell_enemy_healer(PlayerbotAI* ai) { return new CounterspellEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["frostbolt"] = &AiObjectContextInternal::frostbolt;
+                creators["blizzard"] = &AiObjectContextInternal::blizzard;
+                creators["frost nova"] = &AiObjectContextInternal::frost_nova;
+                creators["arcane intellect"] = &AiObjectContextInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &AiObjectContextInternal::arcane_intellect_on_party;
+                creators["conjure water"] = &AiObjectContextInternal::conjure_water;
+                creators["conjure food"] = &AiObjectContextInternal::conjure_food;
+                creators["molten armor"] = &AiObjectContextInternal::molten_armor;
+                creators["mage armor"] = &AiObjectContextInternal::mage_armor;
+                creators["ice armor"] = &AiObjectContextInternal::ice_armor;
+                creators["frost armor"] = &AiObjectContextInternal::frost_armor;
+                creators["fireball"] = &AiObjectContextInternal::fireball;
+                creators["pyroblast"] = &AiObjectContextInternal::pyroblast;
+                creators["flamestrike"] = &AiObjectContextInternal::flamestrike;
+                creators["fire blast"] = &AiObjectContextInternal::fire_blast;
+                creators["scorch"] = &AiObjectContextInternal::scorch;
+                creators["counterspell"] = &AiObjectContextInternal::counterspell;
+                creators["remove curse"] = &AiObjectContextInternal::remove_curse;
+                creators["remove curse on party"] = &AiObjectContextInternal::remove_curse_on_party;
+                creators["icy veins"] = &AiObjectContextInternal::icy_veins;
+                creators["combustion"] = &AiObjectContextInternal::combustion;
+                creators["ice block"] = &AiObjectContextInternal::ice_block;
+                creators["polymorph"] = &AiObjectContextInternal::polymorph;
+                creators["spellsteal"] = &AiObjectContextInternal::spellsteal;
+                creators["living bomb"] = &AiObjectContextInternal::living_bomb;
+                creators["dragon's breath"] = &AiObjectContextInternal::dragons_breath;
+                creators["blast wave"] = &AiObjectContextInternal::blast_wave;
+                creators["invisibility"] = &AiObjectContextInternal::invisibility;
+                creators["evocation"] = &AiObjectContextInternal::evocation;
+                creators["arcane blast"] = &AiObjectContextInternal::arcane_blast;
+                creators["arcane barrage"] = &AiObjectContextInternal::arcane_barrage;
+                creators["arcane missiles"] = &AiObjectContextInternal::arcane_missiles;
+                creators["counterspell on enemy healer"] = &AiObjectContextInternal::counterspell_on_enemy_healer;
+            }
+
+        private:
+            static Action* arcane_missiles(PlayerbotAI* ai) { return new CastArcaneMissilesAction(ai); }
+            static Action* arcane_barrage(PlayerbotAI* ai) { return new CastArcaneBarrageAction(ai); }
+            static Action* arcane_blast(PlayerbotAI* ai) { return new CastArcaneBlastAction(ai); }
+            static Action* frostbolt(PlayerbotAI* ai) { return new CastFrostboltAction(ai); }
+            static Action* blizzard(PlayerbotAI* ai) { return new CastBlizzardAction(ai); }
+            static Action* frost_nova(PlayerbotAI* ai) { return new CastFrostNovaAction(ai); }
+            static Action* arcane_intellect(PlayerbotAI* ai) { return new CastArcaneIntellectAction(ai); }
+            static Action* arcane_intellect_on_party(PlayerbotAI* ai) { return new CastArcaneIntellectOnPartyAction(ai); }
+            static Action* conjure_water(PlayerbotAI* ai) { return new CastConjureWaterAction(ai); }
+            static Action* conjure_food(PlayerbotAI* ai) { return new CastConjureFoodAction(ai); }
+            static Action* molten_armor(PlayerbotAI* ai) { return new CastMoltenArmorAction(ai); }
+            static Action* mage_armor(PlayerbotAI* ai) { return new CastMageArmorAction(ai); }
+            static Action* ice_armor(PlayerbotAI* ai) { return new CastIceArmorAction(ai); }
+            static Action* frost_armor(PlayerbotAI* ai) { return new CastFrostArmorAction(ai); }
+            static Action* fireball(PlayerbotAI* ai) { return new CastFireballAction(ai); }
+            static Action* pyroblast(PlayerbotAI* ai) { return new CastPyroblastAction(ai); }
+            static Action* flamestrike(PlayerbotAI* ai) { return new CastFlamestrikeAction(ai); }
+            static Action* fire_blast(PlayerbotAI* ai) { return new CastFireBlastAction(ai); }
+            static Action* scorch(PlayerbotAI* ai) { return new CastScorchAction(ai); }
+            static Action* counterspell(PlayerbotAI* ai) { return new CastCounterspellAction(ai); }
+            static Action* remove_curse(PlayerbotAI* ai) { return new CastRemoveCurseAction(ai); }
+            static Action* remove_curse_on_party(PlayerbotAI* ai) { return new CastRemoveCurseOnPartyAction(ai); }
+            static Action* icy_veins(PlayerbotAI* ai) { return new CastIcyVeinsAction(ai); }
+            static Action* combustion(PlayerbotAI* ai) { return new CastCombustionAction(ai); }
+            static Action* ice_block(PlayerbotAI* ai) { return new CastIceBlockAction(ai); }
+            static Action* polymorph(PlayerbotAI* ai) { return new CastPolymorphAction(ai); }
+            static Action* spellsteal(PlayerbotAI* ai) { return new CastSpellstealAction(ai); }
+            static Action* living_bomb(PlayerbotAI* ai) { return new CastLivingBombAction(ai); }
+            static Action* dragons_breath(PlayerbotAI* ai) { return new CastDragonsBreathAction(ai); }
+            static Action* blast_wave(PlayerbotAI* ai) { return new CastBlastWaveAction(ai); }
+            static Action* invisibility(PlayerbotAI* ai) { return new CastInvisibilityAction(ai); }
+            static Action* evocation(PlayerbotAI* ai) { return new CastEvocationAction(ai); }
+            static Action* counterspell_on_enemy_healer(PlayerbotAI* ai) { return new CastCounterspellOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+MageAiObjectContext::MageAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::mage::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageStrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageBuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::mage::AiObjectContextInternal());
+    triggerContexts.Add(new ai::mage::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
new file mode 100644
index 0000000..0fe90e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class MageAiObjectContext : public AiObjectContext
+    {
+    public:
+        MageAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
new file mode 100644
index 0000000..8ebe45f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "MageActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.h b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.cpp b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
new file mode 100644
index 0000000..48750fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageTriggers.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+bool MageArmorTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+    return !ai->HasAura("ice armor", target) &&
+        !ai->HasAura("frost armor", target) &&
+        !ai->HasAura("molten armor", target) &&
+        !ai->HasAura("mage armor", target);
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.h b/src/plugins/playerbot/strategy/mage/MageTriggers.h
new file mode 100644
index 0000000..a07b4f2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.h
@@ -0,0 +1,92 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(ArcaneIntellectOnPartyTrigger, "arcane intellect", "arcane intellect on party")
+    BUFF_TRIGGER(ArcaneIntellectTrigger, "arcane intellect", "arcane intellect")
+
+    class MageArmorTrigger : public BuffTrigger {
+    public:
+        MageArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mage armor") {}
+        virtual bool IsActive();
+    };
+
+    class LivingBombTrigger : public DebuffTrigger {
+    public:
+        LivingBombTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "living bomb") {}
+	};
+
+    class FireballTrigger : public DebuffTrigger {
+    public:
+        FireballTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "fireball") {}
+	};
+
+    class PyroblastTrigger : public DebuffTrigger {
+    public:
+        PyroblastTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "pyroblast") {}
+    };
+
+    class HotStreakTrigger : public HasAuraTrigger {
+    public:
+        HotStreakTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "hot streak") {}
+    };
+
+    class MissileBarrageTrigger : public HasAuraTrigger {
+    public:
+        MissileBarrageTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "missile barrage") {}
+    };
+
+    class ArcaneBlastTrigger : public BuffTrigger {
+    public:
+        ArcaneBlastTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "arcane blast") {}
+    };
+
+    class CounterspellInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        CounterspellInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "counterspell") {}
+    };
+
+    class CombustionTrigger : public BoostTrigger
+    {
+    public:
+        CombustionTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "combustion") {}
+    };
+
+    class IcyVeinsTrigger : public BoostTrigger
+    {
+    public:
+        IcyVeinsTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "icy veins") {}
+    };
+
+    class PolymorphTrigger : public HasCcTargetTrigger
+    {
+    public:
+        PolymorphTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "polymorph") {}
+    };
+
+    class RemoveCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        RemoveCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberRemoveCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberRemoveCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class SpellstealTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        SpellstealTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "spellsteal", DISPEL_MAGIC) {}
+    };
+
+    class CounterspellEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        CounterspellEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
new file mode 100644
index 0000000..f9c4407e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "DpsPaladinStrategy.h"
+
+using namespace ai;
+
+class DpsPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsPaladinStrategyActionNodeFactory()
+    {
+        creators["seal of vengeance"] = &seal_of_vengeance;
+        creators["seal of command"] = &seal_of_command;
+        creators["blessing of might"] = &blessing_of_might;
+        creators["crusader strike"] = &crusader_strike;
+    }
+
+private:
+    static ActionNode* seal_of_vengeance(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of vengeance",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of command"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* seal_of_command(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of command",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of wisdom"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* blessing_of_might(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of might",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* crusader_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("crusader strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsPaladinStrategy::DpsPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsPaladinStrategyActionNodeFactory());
+}
+
+NextAction** DpsPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("crusader strike", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine shield", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "judgement of wisdom",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of might", ACTION_HIGH + 8), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("divine storm", ACTION_HIGH + 1), new NextAction("consecration", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"art of war",
+		NextAction::array(0, new NextAction("exorcism", ACTION_HIGH + 2), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
new file mode 100644
index 0000000..cff5fd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class DpsPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        DpsPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
new file mode 100644
index 0000000..fda1619
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPaladinNonCombatStrategy::GenericPaladinNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "blessing of kings on party",
+        NextAction::array(0, new NextAction("blessing of kings on party", 11.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("redemption", 30.0f), NULL)));
+
+	 triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("holy light", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure magic",
+        NextAction::array(0, new NextAction("cleanse magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure magic",
+        NextAction::array(0, new NextAction("cleanse magic on party", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
new file mode 100644
index 0000000..3bcb4e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericPaladinNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+   };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
new file mode 100644
index 0000000..d218be1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
@@ -0,0 +1,77 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericPaladinStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+
+GenericPaladinStrategy::GenericPaladinStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine protection", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice interrupt",
+		NextAction::array(0, new NextAction("hammer of justice", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice on enemy healer",
+		NextAction::array(0, new NextAction("hammer of justice on enemy healer", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("lay on hands", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member critical health",
+		NextAction::array(0, new NextAction("lay on hands on party", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("hammer of wrath", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", ACTION_DISPEL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse cure magic",
+		NextAction::array(0, new NextAction("cleanse magic", ACTION_DISPEL + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse party member cure magic",
+		NextAction::array(0, new NextAction("cleanse magic on party", ACTION_DISPEL + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
new file mode 100644
index 0000000..000f785
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "PaladinAiObjectContext.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "paladin"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
new file mode 100644
index 0000000..560784d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
@@ -0,0 +1,142 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPaladinStrategyActionNodeFactory()
+        {
+            creators["seal of light"] = &seal_of_light;
+            creators["cleanse poison"] = &cleanse_poison;
+            creators["cleanse disease"] = &cleanse_disease;
+            creators["cleanse magic"] = &cleanse_magic;
+            creators["cleanse poison on party"] = &cleanse_poison_on_party;
+            creators["cleanse disease on party"] = &cleanse_disease_on_party;
+            creators["seal of wisdom"] = &seal_of_wisdom;
+            creators["seal of justice"] = &seal_of_justice;
+            creators["hand of reckoning"] = &hand_of_reckoning;
+            creators["judgement of wisdom"] = &judgement_of_wisdom;
+            creators["divine shield"] = &divine_shield;
+            creators["flash of light"] = &flash_of_light;
+            creators["flash of light on party"] = &flash_of_light_on_party;
+            creators["holy wrath"] = &holy_wrath;
+            creators["lay on hands"] = &lay_on_hands;
+            creators["lay on hands on party"] = &lay_on_hands_on_party;
+        }
+    private:
+        static ActionNode* lay_on_hands(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine shield"), new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lay_on_hands_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_magic(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse magic",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_justice(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of justice",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of righteousness"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* hand_of_reckoning(PlayerbotAI* ai)
+        {
+            return new ActionNode ("hand of reckoning",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* judgement_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("judgement of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine protection"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_wrath(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy wrath",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("consecration"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
new file mode 100644
index 0000000..47def40
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.h b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
new file mode 100644
index 0000000..78f782c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
@@ -0,0 +1,365 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastJudgementOfLightAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfLightAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of light") {}
+    };
+
+    class CastJudgementOfWisdomAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfWisdomAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of wisdom") {}
+    };
+
+    class CastJudgementOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of justice") {}
+    };
+
+	class CastRighteousFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastRighteousFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "righteous fury") {}
+	};
+
+	class CastDevotionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastDevotionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "devotion aura") {}
+	};
+
+	class CastRetributionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastRetributionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "retribution aura") {}
+	};
+
+	class CastConcentrationAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastConcentrationAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "concentration aura") {}
+	};
+
+	class CastDivineStormAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineStormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine storm") {}
+	};
+
+	class CastCrusaderStrikeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastCrusaderStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "crusader strike") {}
+	};
+
+	class CastShadowResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastShadowResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadow resistance aura") {}
+	};
+
+	class CastFrostResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFrostResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost resistance aura") {}
+	};
+
+	class CastFireResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFireResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fire resistance aura") {}
+	};
+
+	class CastCrusaderAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastCrusaderAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "crusader aura") {}
+	};
+
+	class CastSealOfRighteousnessAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfRighteousnessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of righteousness") {}
+	};
+
+	class CastSealOfJusticeAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfJusticeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of justice") {}
+	};
+
+
+	class CastSealOfLightAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfLightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of light") {}
+	};
+
+	class CastSealOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of wisdom") {}
+	};
+
+	class CastSealOfCommandAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfCommandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of command") {}
+	};
+
+	class CastSealOfVengeanceAction : public CastBuffSpellAction
+	{
+	public:
+	    CastSealOfVengeanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of vengeance") {}
+	};
+
+
+	class CastBlessingOfMightAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfMightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of might") {}
+	};
+
+	class CastBlessingOfMightOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfMightOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of might") {}
+        virtual string getName() { return "blessing of might on party";}
+	};
+
+	class CastBlessingOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of wisdom") {}
+	};
+
+	class CastBlessingOfWisdomOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfWisdomOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of wisdom") {}
+        virtual string getName() { return "blessing of wisdom on party";}
+	};
+
+	class CastBlessingOfKingsAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfKingsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of kings") {}
+	};
+
+	class CastBlessingOfKingsOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfKingsOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of kings") {}
+        virtual string getName() { return "blessing of kings on party";}
+	};
+
+	class CastBlessingOfSanctuaryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfSanctuaryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of sanctuary") {}
+	};
+
+	class CastBlessingOfSanctuaryOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfSanctuaryOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of sanctuary") {}
+        virtual string getName() { return "blessing of sanctuary on party";}
+	};
+
+    class CastHolyLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastHolyLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "holy light") {}
+    };
+
+    class CastHolyLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHolyLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "holy light") {}
+
+        virtual string getName() { return "holy light on party"; }
+    };
+
+    class CastFlashOfLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastFlashOfLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash of light") {}
+    };
+
+    class CastFlashOfLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashOfLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash of light") {}
+
+        virtual string getName() { return "flash of light on party"; }
+    };
+
+    class CastLayOnHandsAction : public CastHealingSpellAction
+    {
+    public:
+        CastLayOnHandsAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lay on hands") {}
+    };
+
+    class CastLayOnHandsOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLayOnHandsOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lay on hands") {}
+
+        virtual string getName() { return "lay on hands on party"; }
+    };
+
+	class CastDivineProtectionAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineProtectionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine protection") {}
+	};
+
+    class CastDivineProtectionOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastDivineProtectionOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "divine protection") {}
+
+        virtual string getName() { return "divine protection on party"; }
+    };
+
+	class CastDivineShieldAction: public CastBuffSpellAction
+	{
+	public:
+		CastDivineShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine shield") {}
+	};
+
+    class CastConsecrationAction : public CastMeleeSpellAction
+    {
+    public:
+	    CastConsecrationAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "consecration") {}
+    };
+
+    class CastHolyWrathAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHolyWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "holy wrath") {}
+    };
+
+    class CastHammerOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHammerOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of justice") {}
+    };
+
+	class CastHammerOfWrathAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of wrath") {}
+	};
+
+	class CastHammerOfTheRighteousAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfTheRighteousAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of the righteous") {}
+	};
+
+	class CastPurifyPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+	class CastPurifyDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+    class CastPurifyPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastPurifyPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_POISON) {}
+
+        virtual string getName() { return "purify poison on party"; }
+    };
+
+	class CastPurifyDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastPurifyDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "purify disease on party"; }
+	};
+
+	class CastHandOfReckoningAction : public CastSpellAction
+	{
+	public:
+		CastHandOfReckoningAction(PlayerbotAI* ai) : CastSpellAction(ai, "hand of reckoning") {}
+	};
+
+	class CastCleansePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCleansePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseMagicAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+    class CastCleansePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleansePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse poison on party"; }
+    };
+
+	class CastCleanseDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "cleanse disease on party"; }
+	};
+
+	class CastCleanseMagicOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_MAGIC) {}
+
+		virtual string getName() { return "cleanse magic on party"; }
+	};
+
+    BEGIN_SPELL_ACTION(CastAvengersShieldAction, "avenger's shield")
+    END_SPELL_ACTION()
+
+	BEGIN_SPELL_ACTION(CastExorcismAction, "exorcism")
+	END_SPELL_ACTION()
+
+	class CastHolyShieldAction : public CastBuffSpellAction
+	{
+	public:
+		CastHolyShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "holy shield") {}
+	};
+
+	class CastRedemptionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRedemptionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "redemption") {}
+	};
+
+    class CastHammerOfJusticeOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastHammerOfJusticeOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
new file mode 100644
index 0000000..37c7468
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
@@ -0,0 +1,279 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+#include "PaladinTriggers.h"
+#include "PaladinAiObjectContext.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "TankPaladinStrategy.h"
+#include "DpsPaladinStrategy.h"
+#include "PaladinBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &paladin::StrategyFactoryInternal::nc;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericPaladinNonCombatStrategy(ai); }
+        };
+
+        class ResistanceStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            ResistanceStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["rshadow"] = &paladin::ResistanceStrategyFactoryInternal::rshadow;
+                creators["rfrost"] = &paladin::ResistanceStrategyFactoryInternal::rfrost;
+                creators["rfire"] = &paladin::ResistanceStrategyFactoryInternal::rfire;
+            }
+
+        private:
+            static Strategy* rshadow(PlayerbotAI* ai) { return new PaladinShadowResistanceStrategy(ai); }
+            static Strategy* rfrost(PlayerbotAI* ai) { return new PaladinFrostResistanceStrategy(ai); }
+            static Strategy* rfire(PlayerbotAI* ai) { return new PaladinFireResistanceStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bhealth"] = &paladin::BuffStrategyFactoryInternal::bhealth;
+                creators["bmana"] = &paladin::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &paladin::BuffStrategyFactoryInternal::bdps;
+                creators["barmor"] = &paladin::BuffStrategyFactoryInternal::barmor;
+                creators["bspeed"] = &paladin::BuffStrategyFactoryInternal::bspeed;
+            }
+
+        private:
+            static Strategy* bhealth(PlayerbotAI* ai) { return new PaladinBuffHealthStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new PaladinBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new PaladinBuffDpsStrategy(ai); }
+            static Strategy* barmor(PlayerbotAI* ai) { return new PaladinBuffArmorStrategy(ai); }
+            static Strategy* bspeed(PlayerbotAI* ai) { return new PaladinBuffSpeedStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &paladin::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &paladin::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankPaladinStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsPaladinStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["judgement of wisdom"] = &TriggerFactoryInternal::judgement_of_wisdom;
+                creators["judgement of light"] = &TriggerFactoryInternal::judgement_of_light;
+                creators["blessing"] = &TriggerFactoryInternal::blessing;
+                creators["seal"] = &TriggerFactoryInternal::seal;
+                creators["art of war"] = &TriggerFactoryInternal::art_of_war;
+                creators["blessing of kings on party"] = &TriggerFactoryInternal::blessing_of_kings_on_party;
+                creators["crusader aura"] = &TriggerFactoryInternal::crusader_aura;
+                creators["retribution aura"] = &TriggerFactoryInternal::retribution_aura;
+                creators["devotion aura"] = &TriggerFactoryInternal::devotion_aura;
+                creators["shadow resistance aura"] = &TriggerFactoryInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &TriggerFactoryInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &TriggerFactoryInternal::fire_resistance_aura;
+                creators["hammer of justice snare"] = &TriggerFactoryInternal::hammer_of_justice_snare;
+                creators["hammer of justice interrupt"] = &TriggerFactoryInternal::hammer_of_justice_interrupt;
+                creators["cleanse cure disease"] = &TriggerFactoryInternal::CleanseCureDisease;
+                creators["cleanse party member cure disease"] = &TriggerFactoryInternal::CleanseCurePartyMemberDisease;
+                creators["cleanse cure poison"] = &TriggerFactoryInternal::CleanseCurePoison;
+                creators["cleanse party member cure poison"] = &TriggerFactoryInternal::CleanseCurePartyMemberPoison;
+                creators["cleanse cure magic"] = &TriggerFactoryInternal::CleanseCureMagic;
+                creators["cleanse party member cure magic"] = &TriggerFactoryInternal::CleanseCurePartyMemberMagic;
+                creators["righteous fury"] = &TriggerFactoryInternal::righteous_fury;
+                creators["holy shield"] = &TriggerFactoryInternal::holy_shield;
+                creators["hammer of justice on enemy healer"] = &TriggerFactoryInternal::hammer_of_justice_on_enemy_target;
+            }
+
+        private:
+            static Trigger* holy_shield(PlayerbotAI* ai) { return new HolyShieldTrigger(ai); }
+            static Trigger* righteous_fury(PlayerbotAI* ai) { return new RighteousFuryTrigger(ai); }
+            static Trigger* judgement_of_wisdom(PlayerbotAI* ai) { return new JudgementOfWisdomTrigger(ai); }
+            static Trigger* judgement_of_light(PlayerbotAI* ai) { return new JudgementOfLightTrigger(ai); }
+            static Trigger* blessing(PlayerbotAI* ai) { return new BlessingTrigger(ai); }
+            static Trigger* seal(PlayerbotAI* ai) { return new SealTrigger(ai); }
+            static Trigger* art_of_war(PlayerbotAI* ai) { return new ArtOfWarTrigger(ai); }
+            static Trigger* blessing_of_kings_on_party(PlayerbotAI* ai) { return new BlessingOfKingsOnPartyTrigger(ai); }
+            static Trigger* crusader_aura(PlayerbotAI* ai) { return new CrusaderAuraTrigger(ai); }
+            static Trigger* retribution_aura(PlayerbotAI* ai) { return new RetributionAuraTrigger(ai); }
+            static Trigger* devotion_aura(PlayerbotAI* ai) { return new DevotionAuraTrigger(ai); }
+            static Trigger* shadow_resistance_aura(PlayerbotAI* ai) { return new ShadowResistanceAuraTrigger(ai); }
+            static Trigger* frost_resistance_aura(PlayerbotAI* ai) { return new FrostResistanceAuraTrigger(ai); }
+            static Trigger* fire_resistance_aura(PlayerbotAI* ai) { return new FireResistanceAuraTrigger(ai); }
+            static Trigger* hammer_of_justice_snare(PlayerbotAI* ai) { return new HammerOfJusticeSnareTrigger(ai); }
+            static Trigger* hammer_of_justice_interrupt(PlayerbotAI* ai) { return new HammerOfJusticeInterruptSpellTrigger(ai); }
+            static Trigger* CleanseCureDisease(PlayerbotAI* ai) { return new CleanseCureDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberDisease(PlayerbotAI* ai) { return new CleanseCurePartyMemberDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePoison(PlayerbotAI* ai) { return new CleanseCurePoisonTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberPoison(PlayerbotAI* ai) { return new CleanseCurePartyMemberPoisonTrigger(ai); }
+            static Trigger* CleanseCureMagic(PlayerbotAI* ai) { return new CleanseCureMagicTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberMagic(PlayerbotAI* ai) { return new CleanseCurePartyMemberMagicTrigger(ai); }
+            static Trigger* hammer_of_justice_on_enemy_target(PlayerbotAI* ai) { return new HammerOfJusticeEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["seal of command"] = &AiObjectContextInternal::seal_of_command;
+                creators["seal of vengeance"] = &AiObjectContextInternal::seal_of_vengeance;
+                creators["blessing of might"] = &AiObjectContextInternal::blessing_of_might;
+                creators["divine storm"] = &AiObjectContextInternal::divine_storm;
+                creators["blessing of kings on party"] = &AiObjectContextInternal::blessing_of_kings_on_party;
+                creators["redemption"] = &AiObjectContextInternal::redemption;
+                creators["crusader strike"] = &AiObjectContextInternal::crusader_strike;
+                creators["crusader aura"] = &AiObjectContextInternal::crusader_aura;
+                creators["seal of light"] = &AiObjectContextInternal::seal_of_light;
+                creators["devotion aura"] = &AiObjectContextInternal::devotion_aura;
+                creators["holy wrath"] = &AiObjectContextInternal::holy_wrath;
+                creators["consecration"] = &AiObjectContextInternal::consecration;
+                creators["cleanse disease"] = &AiObjectContextInternal::cleanse_disease;
+                creators["cleanse poison"] = &AiObjectContextInternal::cleanse_poison;
+                creators["cleanse magic"] = &AiObjectContextInternal::cleanse_magic;
+                creators["purify disease"] = &AiObjectContextInternal::purify_disease;
+                creators["purify poison"] = &AiObjectContextInternal::purify_poison;
+                creators["cleanse poison on party"] = &AiObjectContextInternal::cleanse_poison_on_party;
+                creators["cleanse disease on party"] = &AiObjectContextInternal::cleanse_disease_on_party;
+                creators["cleanse magic on party"] = &AiObjectContextInternal::cleanse_magic_on_party;
+                creators["purify poison on party"] = &AiObjectContextInternal::purify_poison_on_party;
+                creators["purify disease on party"] = &AiObjectContextInternal::purify_disease_on_party;
+                creators["seal of wisdom"] = &AiObjectContextInternal::seal_of_wisdom;
+                creators["seal of justice"] = &AiObjectContextInternal::seal_of_justice;
+                creators["seal of righteousness"] = &AiObjectContextInternal::seal_of_righteousness;
+                creators["flash of light"] = &AiObjectContextInternal::flash_of_light;
+                creators["hand of reckoning"] = &AiObjectContextInternal::hand_of_reckoning;
+                creators["avenger's shield"] = &AiObjectContextInternal::avengers_shield;
+                creators["exorcism"] = &AiObjectContextInternal::exorcism;
+                creators["judgement of light"] = &AiObjectContextInternal::judgement_of_light;
+                creators["judgement of wisdom"] = &AiObjectContextInternal::judgement_of_wisdom;
+                creators["divine shield"] = &AiObjectContextInternal::divine_shield;
+                creators["divine protection"] = &AiObjectContextInternal::divine_protection;
+                creators["divine protection on party"] =&AiObjectContextInternal::divine_protection_on_party;
+                creators["hammer of justice"] = &AiObjectContextInternal::hammer_of_justice;
+                creators["flash of light on party"] = &AiObjectContextInternal::flash_of_light_on_party;
+                creators["holy light"] = &AiObjectContextInternal::holy_light;
+                creators["holy light on party"] = &AiObjectContextInternal::holy_light_on_party;
+                creators["lay on hands"] = &AiObjectContextInternal::lay_on_hands;
+                creators["lay on hands on party"] = &AiObjectContextInternal::lay_on_hands_on_party;
+                creators["judgement of justice"] = &AiObjectContextInternal::judgement_of_justice;
+                creators["hammer of wrath"] = &AiObjectContextInternal::hammer_of_wrath;
+                creators["holy shield"] = &AiObjectContextInternal::holy_shield;
+                creators["hammer of the righteous"] = &AiObjectContextInternal::hammer_of_the_righteous;
+                creators["blessing of kings"] = &AiObjectContextInternal::blessing_of_kings;
+                creators["retribution aura"] = &AiObjectContextInternal::retribution_aura;
+                creators["shadow resistance aura"] = &AiObjectContextInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &AiObjectContextInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &AiObjectContextInternal::fire_resistance_aura;
+                creators["righteous fury"] = &AiObjectContextInternal::righteous_fury;
+                creators["blessing of sanctuary"] = &AiObjectContextInternal::blessing_of_sanctuary;
+                creators["hammer of justice on enemy healer"] = &AiObjectContextInternal::hammer_of_justice_on_enemy_healer;
+            }
+
+        private:
+            static Action* righteous_fury(PlayerbotAI* ai) { return new CastRighteousFuryAction(ai); }
+            static Action* blessing_of_sanctuary(PlayerbotAI* ai) { return new CastBlessingOfSanctuaryAction(ai); }
+            static Action* seal_of_command(PlayerbotAI* ai) { return new CastSealOfCommandAction(ai); }
+            static Action* seal_of_vengeance(PlayerbotAI* ai) { return new CastSealOfVengeanceAction(ai); }
+            static Action* blessing_of_might(PlayerbotAI* ai) { return new CastBlessingOfMightAction(ai); }
+            static Action* divine_storm(PlayerbotAI* ai) { return new CastDivineStormAction(ai); }
+            static Action* blessing_of_kings_on_party(PlayerbotAI* ai) { return new CastBlessingOfKingsOnPartyAction(ai); }
+            static Action* redemption(PlayerbotAI* ai) { return new CastRedemptionAction(ai); }
+            static Action* crusader_strike(PlayerbotAI* ai) { return new CastCrusaderStrikeAction(ai); }
+            static Action* crusader_aura(PlayerbotAI* ai) { return new CastCrusaderAuraAction(ai); }
+            static Action* seal_of_light(PlayerbotAI* ai) { return new CastSealOfLightAction(ai); }
+            static Action* devotion_aura(PlayerbotAI* ai) { return new CastDevotionAuraAction(ai); }
+            static Action* holy_wrath(PlayerbotAI* ai) { return new CastHolyWrathAction(ai); }
+            static Action* consecration(PlayerbotAI* ai) { return new CastConsecrationAction(ai); }
+            static Action* cleanse_poison(PlayerbotAI* ai) { return new CastCleansePoisonAction(ai); }
+            static Action* cleanse_disease(PlayerbotAI* ai) { return new CastCleanseDiseaseAction(ai); }
+            static Action* cleanse_magic(PlayerbotAI* ai) { return new CastCleanseMagicAction(ai); }
+            static Action* purify_poison(PlayerbotAI* ai) { return new CastPurifyPoisonAction(ai); }
+            static Action* purify_disease(PlayerbotAI* ai) { return new CastPurifyDiseaseAction(ai); }
+            static Action* cleanse_poison_on_party(PlayerbotAI* ai) { return new CastCleansePoisonOnPartyAction(ai); }
+            static Action* cleanse_disease_on_party(PlayerbotAI* ai) { return new CastCleanseDiseaseOnPartyAction(ai); }
+            static Action* cleanse_magic_on_party(PlayerbotAI* ai) { return new CastCleanseMagicOnPartyAction(ai); }
+            static Action* purify_poison_on_party(PlayerbotAI* ai) { return new CastPurifyPoisonOnPartyAction(ai); }
+            static Action* purify_disease_on_party(PlayerbotAI* ai) { return new CastPurifyDiseaseOnPartyAction(ai); }
+            static Action* seal_of_wisdom(PlayerbotAI* ai) { return new CastSealOfWisdomAction(ai); }
+            static Action* seal_of_justice(PlayerbotAI* ai) { return new CastSealOfJusticeAction(ai); }
+            static Action* seal_of_righteousness(PlayerbotAI* ai) { return new CastSealOfRighteousnessAction(ai); }
+            static Action* flash_of_light(PlayerbotAI* ai) { return new CastFlashOfLightAction(ai); }
+            static Action* hand_of_reckoning(PlayerbotAI* ai) { return new CastHandOfReckoningAction(ai); }
+            static Action* avengers_shield(PlayerbotAI* ai) { return new CastAvengersShieldAction(ai); }
+            static Action* exorcism(PlayerbotAI* ai) { return new CastExorcismAction(ai); }
+            static Action* judgement_of_light(PlayerbotAI* ai) { return new CastJudgementOfLightAction(ai); }
+            static Action* judgement_of_wisdom(PlayerbotAI* ai) { return new CastJudgementOfWisdomAction(ai); }
+            static Action* divine_shield(PlayerbotAI* ai) { return new CastDivineShieldAction(ai); }
+            static Action* divine_protection(PlayerbotAI* ai) { return new CastDivineProtectionAction(ai); }
+            static Action* divine_protection_on_party(PlayerbotAI* ai) { return new CastDivineProtectionOnPartyAction(ai); }
+            static Action* hammer_of_justice(PlayerbotAI* ai) { return new CastHammerOfJusticeAction(ai); }
+            static Action* flash_of_light_on_party(PlayerbotAI* ai) { return new CastFlashOfLightOnPartyAction(ai); }
+            static Action* holy_light(PlayerbotAI* ai) { return new CastHolyLightAction(ai); }
+            static Action* holy_light_on_party(PlayerbotAI* ai) { return new CastHolyLightOnPartyAction(ai); }
+            static Action* lay_on_hands(PlayerbotAI* ai) { return new CastLayOnHandsAction(ai); }
+            static Action* lay_on_hands_on_party(PlayerbotAI* ai) { return new CastLayOnHandsOnPartyAction(ai); }
+            static Action* judgement_of_justice(PlayerbotAI* ai) { return new CastJudgementOfJusticeAction(ai); }
+            static Action* hammer_of_wrath(PlayerbotAI* ai) { return new CastHammerOfWrathAction(ai); }
+            static Action* holy_shield(PlayerbotAI* ai) { return new CastHolyShieldAction(ai); }
+            static Action* hammer_of_the_righteous(PlayerbotAI* ai) { return new CastHammerOfTheRighteousAction(ai); }
+            static Action* blessing_of_kings(PlayerbotAI* ai) { return new CastBlessingOfKingsAction(ai); }
+            static Action* retribution_aura(PlayerbotAI* ai) { return new CastRetributionAuraAction(ai); }
+            static Action* shadow_resistance_aura(PlayerbotAI* ai) { return new CastShadowResistanceAuraAction(ai); }
+            static Action* frost_resistance_aura(PlayerbotAI* ai) { return new CastFrostResistanceAuraAction(ai); }
+            static Action* fire_resistance_aura(PlayerbotAI* ai) { return new CastFireResistanceAuraAction(ai); }
+            static Action* hammer_of_justice_on_enemy_healer(PlayerbotAI* ai) { return new CastHammerOfJusticeOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+PaladinAiObjectContext::PaladinAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::paladin::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::BuffStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::ResistanceStrategyFactoryInternal());
+    actionContexts.Add(new ai::paladin::AiObjectContextInternal());
+    triggerContexts.Add(new ai::paladin::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
new file mode 100644
index 0000000..1af3343
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PaladinAiObjectContext : public AiObjectContext
+    {
+    public:
+        PaladinAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
new file mode 100644
index 0000000..5124024
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
@@ -0,0 +1,72 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinBuffStrategies.h"
+
+using namespace ai;
+
+void PaladinBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of wisdom", 90.0f), NULL)));
+}
+
+void PaladinBuffHealthStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 90.0f), NULL)));
+}
+
+void PaladinBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "crusader aura",
+        NextAction::array(0, new NextAction("crusader aura", 40.0f), NULL)));
+}
+
+void PaladinBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of vengeance", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"retribution aura",
+		NextAction::array(0, new NextAction("retribution aura", 90.0f), NULL)));
+}
+
+void PaladinShadowResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"shadow resistance aura",
+		NextAction::array(0, new NextAction("shadow resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFrostResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"frost resistance aura",
+		NextAction::array(0, new NextAction("frost resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFireResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"fire resistance aura",
+		NextAction::array(0, new NextAction("fire resistance aura", 90.0f), NULL)));
+}
+
+
+void PaladinBuffArmorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"devotion aura",
+		NextAction::array(0, new NextAction("devotion aura", 90.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
new file mode 100644
index 0000000..e5051a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class PaladinBuffManaStrategy : public Strategy
+    {
+    public:
+        PaladinBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class PaladinBuffHealthStrategy : public Strategy
+    {
+    public:
+        PaladinBuffHealthStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bhealth"; }
+    };
+
+    class PaladinBuffDpsStrategy : public Strategy
+    {
+    public:
+        PaladinBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+
+	class PaladinBuffArmorStrategy : public Strategy
+	{
+	public:
+		PaladinBuffArmorStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "barmor"; }
+	};
+
+	class PaladinBuffSpeedStrategy : public Strategy
+	{
+	public:
+		PaladinBuffSpeedStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "bspeed"; }
+	};
+
+	class PaladinShadowResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinShadowResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rshadow"; }
+	};
+
+	class PaladinFrostResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFrostResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfrost"; }
+	};
+
+	class PaladinFireResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFireResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfire"; }
+	};
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
new file mode 100644
index 0000000..3082abb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
new file mode 100644
index 0000000..5159dd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinTriggers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
+bool SealTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("seal of justice", target) &&
+        !ai->HasAura("seal of command", target) &&
+        !ai->HasAura("seal of vengeance", target) &&
+		!ai->HasAura("seal of righteousness", target) &&
+		!ai->HasAura("seal of light", target) &&
+		!ai->HasAura("seal of wisdom", target);
+}
+
+bool CrusaderAuraTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return AI_VALUE2(bool, "mounted", "self target") && !ai->HasAura("crusader aura", target);
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
new file mode 100644
index 0000000..3f53b4e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
@@ -0,0 +1,114 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	BUFF_TRIGGER(HolyShieldTrigger, "holy shield", "holy shield")
+    BUFF_TRIGGER(RighteousFuryTrigger, "righteous fury", "righteous fury")
+
+    BUFF_TRIGGER(RetributionAuraTrigger, "retribution aura", "retribution aura")
+
+	class CrusaderAuraTrigger : public BuffTrigger
+	{
+	public:
+		CrusaderAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "crusader aura") {}
+		virtual bool IsActive();
+	};
+
+	class SealTrigger : public BuffTrigger
+	{
+	public:
+		SealTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "seal of justice") {}
+		virtual bool IsActive();
+	};
+
+    DEBUFF_TRIGGER(JudgementOfLightTrigger, "judgement of light", "judgement of light")
+    DEBUFF_TRIGGER(JudgementOfWisdomTrigger, "judgement of wisdom", "judgement of wisdom")
+
+    BUFF_ON_PARTY_TRIGGER(BlessingOfKingsOnPartyTrigger, "blessing of kings", "blessing of kings on party")
+    BUFF_TRIGGER(BlessingTrigger, "blessing of sanctuary", "blessing of sanctuary")
+
+    class HammerOfJusticeInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        HammerOfJusticeInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "hammer of justice") {}
+    };
+
+    class HammerOfJusticeSnareTrigger : public SnareTargetTrigger
+    {
+    public:
+        HammerOfJusticeSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hammer of justice") {}
+    };
+
+    class ArtOfWarTrigger : public HasAuraTrigger
+    {
+    public:
+        ArtOfWarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "the art of war") {}
+    };
+
+    class ShadowResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        ShadowResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadow resistance aura") {}
+    };
+
+    class FrostResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FrostResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "frost resistance aura") {}
+    };
+
+    class FireResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FireResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "fire resistance aura") {}
+    };
+
+    class DevotionAuraTrigger : public BuffTrigger
+    {
+    public:
+        DevotionAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "devotion aura") {}
+    };
+
+    class CleanseCureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePartyMemberDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCurePartyMemberPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCureMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class CleanseCurePartyMemberMagicTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberMagicTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class HammerOfJusticeEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        HammerOfJusticeEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
new file mode 100644
index 0000000..6e6b51f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "TankPaladinStrategy.h"
+
+using namespace ai;
+
+class TankPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankPaladinStrategyActionNodeFactory()
+    {
+        creators["blessing of sanctuary"] = &blessing_of_sanctuary;
+    }
+private:
+    static ActionNode* blessing_of_sanctuary(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of sanctuary",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankPaladinStrategy::TankPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new TankPaladinStrategyActionNodeFactory());
+}
+
+NextAction** TankPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("melee", ACTION_NORMAL), NULL);
+}
+
+void TankPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "judgement of light",
+        NextAction::array(0, new NextAction("judgement of light", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium mana",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "righteous fury",
+        NextAction::array(0, new NextAction("righteous fury", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("hammer of the righteous", ACTION_HIGH + 6), new NextAction("avenger's shield", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("consecration", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("hand of reckoning", ACTION_HIGH + 7), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"holy shield",
+		NextAction::array(0, new NextAction("holy shield", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of sanctuary", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
new file mode 100644
index 0000000..d5cf955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class TankPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        TankPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
new file mode 100644
index 0000000..19103da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
@@ -0,0 +1,67 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+#include "GenericPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPriestStrategy::GenericPriestStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPriestStrategyActionNodeFactory());
+}
+
+void GenericPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash heal", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("flash heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("flash heal on party", 60.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("power word: shield", 60.0f), new NextAction("greater heal", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("power word: shield on party", 50.0f), new NextAction("greater heal on party", 50.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("psychic scream", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
new file mode 100644
index 0000000..4633e8d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericPriestStrategy : public CombatStrategy
+    {
+    public:
+        GenericPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..d3ef00b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
@@ -0,0 +1,173 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPriestStrategyActionNodeFactory()
+        {
+            creators["inner fire"] = &inner_fire;
+            creators["holy nova"] = &holy_nova;
+            creators["power word: fortitude"] = &power_word_fortitude;
+            creators["power word: fortitude on party"] = &power_word_fortitude_on_party;
+            creators["divine spirit"] = &divine_spirit;
+            creators["divine spirit on party"] = &divine_spirit_on_party;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["psychic scream"] = &psychic_scream;
+            creators["fade"] = &fade;
+        }
+    private:
+        static ActionNode* inner_fire(PlayerbotAI* ai)
+        {
+            return new ActionNode ("inner fire",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* psychic_scream(PlayerbotAI* ai)
+        {
+            return new ActionNode ("psychic scream",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("fade"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* fade(PlayerbotAI* ai)
+        {
+            return new ActionNode ("fade",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
new file mode 100644
index 0000000..68e6f37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+
+using namespace ai;
+
+NextAction** HealPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void HealPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("renew", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("renew on party", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("fade", 50.0f), new NextAction("flee", 49.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
new file mode 100644
index 0000000..7f5603f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPriestStrategy.h"
+
+namespace ai
+{
+    class HealPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        HealPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
new file mode 100644
index 0000000..abeea31
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HolyPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        HolyPriestStrategyActionNodeFactory()
+        {
+            creators["smite"] = &smite;
+        }
+    private:
+        static ActionNode* smite(PlayerbotAI* ai)
+        {
+            return new ActionNode ("smite",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
+
+using namespace ai;
+
+HolyPriestStrategy::HolyPriestStrategy(PlayerbotAI* ai) : HealPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new HolyPriestStrategyActionNodeFactory());
+}
+
+NextAction** HolyPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("holy fire", 10.0f), new NextAction("smite", 10.0f), NULL);
+}
+
+void HolyPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    HealPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
new file mode 100644
index 0000000..c21bcf1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategy : public HealPriestStrategy
+    {
+    public:
+        HolyPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "holy"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.cpp b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
new file mode 100644
index 0000000..8760005
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
+
+NextAction** CastAbolishDiseaseAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease"), NULL), CastSpellAction::getAlternatives());
+}
+
+NextAction** CastAbolishDiseaseOnPartyAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease on party"), NULL), CastSpellAction::getAlternatives());
+}
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.h b/src/plugins/playerbot/strategy/priest/PriestActions.h
new file mode 100644
index 0000000..bf2ea2d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.h
@@ -0,0 +1,246 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastGreaterHealAction : public CastHealingSpellAction {
+    public:
+        CastGreaterHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "greater heal") {}
+    };
+
+    class CastGreaterHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastGreaterHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "greater heal") {}
+
+        virtual string getName() { return "greater heal on party"; }
+    };
+
+    class CastLesserHealAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser heal") {}
+    };
+
+    class CastLesserHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser heal") {}
+
+        virtual string getName() { return "lesser heal on party"; }
+    };
+
+    class CastFlashHealAction : public CastHealingSpellAction {
+    public:
+        CastFlashHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash heal") {}
+    };
+
+    class CastFlashHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash heal") {}
+
+        virtual string getName() { return "flash heal on party"; }
+    };
+
+    class CastHealAction : public CastHealingSpellAction {
+    public:
+        CastHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "heal") {}
+    };
+
+    class CastHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "heal") {}
+
+        virtual string getName() { return "heal on party"; }
+    };
+
+    class CastRenewAction : public CastHealingSpellAction {
+    public:
+        CastRenewAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "renew") {}
+    };
+
+    class CastRenewOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRenewOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "renew") {}
+
+        virtual string getName() { return "renew on party"; }
+    };
+
+    class CastFadeAction : public CastBuffSpellAction {
+    public:
+        CastFadeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fade") {}
+    };
+
+    class CastShadowformAction : public CastBuffSpellAction {
+    public:
+        CastShadowformAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadowform") {}
+    };
+
+    class CastRemoveShadowformAction : public Action {
+    public:
+        CastRemoveShadowformAction(PlayerbotAI* ai) : Action(ai, "remove shadowform") {}
+        virtual bool isUseful() { return ai->HasAura("shadowform", AI_VALUE(Unit*, "self target")); }
+        virtual bool isPossible() { return true; }
+        virtual bool Execute(Event event) {
+            ai->RemoveAura("shadowform");
+            return true;
+        }
+    };
+
+	class CastVampiricEmbraceAction : public CastBuffSpellAction {
+	public:
+		CastVampiricEmbraceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vampiric embrace") {}
+	};
+
+	class CastPowerWordShieldAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: shield") {}
+	};
+
+    class CastPowerWordShieldOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastPowerWordShieldOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "power word: shield") {}
+
+        virtual string getName() { return "power word: shield on party"; }
+    };
+
+	class CastPowerWordFortitudeAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordFortitudeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritAction : public CastBuffSpellAction {
+	public:
+		CastDivineSpiritAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine spirit") {}
+	};
+
+	class CastInnerFireAction : public CastBuffSpellAction {
+	public:
+		CastInnerFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "inner fire") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastHolyNovaAction, "holy nova")
+    virtual bool isUseful() {
+        return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+    }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastHolyFireAction, "holy fire")
+        virtual bool isUseful() {
+            return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSmiteAction, "smite")
+        virtual bool isUseful() {
+			return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+	class CastPowerWordFortitudeOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastPowerWordFortitudeOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastDivineSpiritOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "divine spirit") {}
+	};
+
+	class CastPowerWordPainAction : public CastDebuffSpellAction
+	{
+    public:
+	    CastPowerWordPainAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "shadow word: pain") {}
+	};
+
+	class CastPowerWordPainOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+    public:
+	    CastPowerWordPainOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "shadow word: pain") {}
+	};
+
+    BEGIN_DEBUFF_ACTION(CastDevouringPlagueAction, "devouring plague")
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastVampiricTouchAction, "vampiric touch")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindBlastAction, "mind blast")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindFlayAction, "mind flay")
+    END_SPELL_ACTION()
+
+	class CastCureDiseaseAction : public CastCureSpellAction {
+	public:
+		CastCureDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure disease") {}
+	};
+
+    class CastCureDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCureDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "cure disease on party"; }
+    };
+
+	class CastAbolishDiseaseAction : public CastCureSpellAction {
+	public:
+		CastAbolishDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish disease") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "abolish disease on party"; }
+        virtual NextAction** getAlternatives();
+    };
+
+	class CastDispelMagicAction : public CastCureSpellAction {
+	public:
+		CastDispelMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "dispel magic") {}
+	};
+
+    class CastDispelMagicOnTargetAction : public CastSpellAction {
+    public:
+        CastDispelMagicOnTargetAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispel magic") {}
+    };
+
+    class CastDispelMagicOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastDispelMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "dispel magic", DISPEL_MAGIC) {}
+        virtual string getName() { return "dispel magic on party"; }
+    };
+
+	class CastResurrectionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastResurrectionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "resurrection") {}
+	};
+
+	class CastCircleOfHealingAction : public CastAoeHealSpellAction
+	{
+	public:
+		CastCircleOfHealingAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "circle of healing") {}
+	};
+
+	class CastPsychicScreamAction : public CastSpellAction
+	{
+	public:
+	    CastPsychicScreamAction(PlayerbotAI* ai) : CastSpellAction(ai, "psychic scream") {}
+	};
+
+	class CastDispersionAction : public CastSpellAction
+	{
+	public:
+	    CastDispersionAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispersion") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
new file mode 100644
index 0000000..8a40b2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
@@ -0,0 +1,217 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+#include "PriestAiObjectContext.h"
+#include "PriestNonCombatStrategy.h"
+#include "ShadowPriestStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "PriestTriggers.h"
+#include "../NamedObjectContext.h"
+#include "HolyPriestStrategy.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &priest::StrategyFactoryInternal::nc;
+                creators["pull"] = &priest::StrategyFactoryInternal::pull;
+                creators["aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["shadow aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["dps debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+                creators["shadow debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new PriestNonCombatStrategy(ai); }
+            static Strategy* shadow_aoe(PlayerbotAI* ai) { return new ShadowPriestAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* shadow_debuff(PlayerbotAI* ai) { return new ShadowPriestDebuffStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &priest::CombatStrategyFactoryInternal::heal;
+                creators["shadow"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["holy"] = &priest::CombatStrategyFactoryInternal::holy;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealPriestStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new ShadowPriestStrategy(ai); }
+            static Strategy* holy(PlayerbotAI* ai) { return new HolyPriestStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["devouring plague"] = &TriggerFactoryInternal::devouring_plague;
+                creators["shadow word: pain"] = &TriggerFactoryInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &TriggerFactoryInternal::shadow_word_pain_on_attacker;
+                creators["dispel magic"] = &TriggerFactoryInternal::dispel_magic;
+                creators["dispel magic on party"] = &TriggerFactoryInternal::dispel_magic_party_member;
+                creators["cure disease"] = &TriggerFactoryInternal::cure_disease;
+                creators["party member cure disease"] = &TriggerFactoryInternal::party_member_cure_disease;
+                creators["power word: fortitude"] = &TriggerFactoryInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &TriggerFactoryInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &TriggerFactoryInternal::divine_spirit;
+                creators["divine spirit on party"] = &TriggerFactoryInternal::divine_spirit_on_party;
+                creators["inner fire"] = &TriggerFactoryInternal::inner_fire;
+                creators["vampiric touch"] = &TriggerFactoryInternal::vampiric_touch;
+                creators["shadowform"] = &TriggerFactoryInternal::shadowform;
+                creators["vampiric embrace"] = &TriggerFactoryInternal::vampiric_embrace;
+
+            }
+
+        private:
+            static Trigger* vampiric_embrace(PlayerbotAI* ai) { return new VampiricEmbraceTrigger(ai); }
+            static Trigger* shadowform(PlayerbotAI* ai) { return new ShadowformTrigger(ai); }
+            static Trigger* vampiric_touch(PlayerbotAI* ai) { return new VampiricTouchTrigger(ai); }
+            static Trigger* devouring_plague(PlayerbotAI* ai) { return new DevouringPlagueTrigger(ai); }
+            static Trigger* shadow_word_pain(PlayerbotAI* ai) { return new PowerWordPainTrigger(ai); }
+            static Trigger* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new PowerWordPainOnAttackerTrigger(ai); }
+            static Trigger* dispel_magic(PlayerbotAI* ai) { return new DispelMagicTrigger(ai); }
+            static Trigger* dispel_magic_party_member(PlayerbotAI* ai) { return new DispelMagicPartyMemberTrigger(ai); }
+            static Trigger* cure_disease(PlayerbotAI* ai) { return new CureDiseaseTrigger(ai); }
+            static Trigger* party_member_cure_disease(PlayerbotAI* ai) { return new PartyMemberCureDiseaseTrigger(ai); }
+            static Trigger* power_word_fortitude(PlayerbotAI* ai) { return new PowerWordFortitudeTrigger(ai); }
+            static Trigger* power_word_fortitude_on_party(PlayerbotAI* ai) { return new PowerWordFortitudeOnPartyTrigger(ai); }
+            static Trigger* divine_spirit(PlayerbotAI* ai) { return new DivineSpiritTrigger(ai); }
+            static Trigger* divine_spirit_on_party(PlayerbotAI* ai) { return new DivineSpiritOnPartyTrigger(ai); }
+            static Trigger* inner_fire(PlayerbotAI* ai) { return new InnerFireTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["shadow word: pain"] = &AiObjectContextInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &AiObjectContextInternal::shadow_word_pain_on_attacker;
+                creators["devouring plague"] = &AiObjectContextInternal::devouring_plague;
+                creators["mind flay"] = &AiObjectContextInternal::mind_flay;
+                creators["holy fire"] = &AiObjectContextInternal::holy_fire;
+                creators["smite"] = &AiObjectContextInternal::smite;
+                creators["mind blast"] = &AiObjectContextInternal::mind_blast;
+                creators["shadowform"] = &AiObjectContextInternal::shadowform;
+                creators["remove shadowform"] = &AiObjectContextInternal::remove_shadowform;
+                creators["holy nova"] = &AiObjectContextInternal::holy_nova;
+                creators["power word: fortitude"] = &AiObjectContextInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &AiObjectContextInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &AiObjectContextInternal::divine_spirit;
+                creators["divine spirit on party"] = &AiObjectContextInternal::divine_spirit_on_party;
+                creators["power word: shield"] = &AiObjectContextInternal::power_word_shield;
+                creators["power word: shield on party"] = &AiObjectContextInternal::power_word_shield_on_party;
+                creators["renew"] = &AiObjectContextInternal::renew;
+                creators["renew on party"] = &AiObjectContextInternal::renew_on_party;
+                creators["greater heal"] = &AiObjectContextInternal::greater_heal;
+                creators["greater heal on party"] = &AiObjectContextInternal::greater_heal_on_party;
+                creators["heal"] = &AiObjectContextInternal::heal;
+                creators["heal on party"] = &AiObjectContextInternal::heal_on_party;
+                creators["lesser heal"] = &AiObjectContextInternal::lesser_heal;
+                creators["lesser heal on party"] = &AiObjectContextInternal::lesser_heal_on_party;
+                creators["flash heal"] = &AiObjectContextInternal::flash_heal;
+                creators["flash heal on party"] = &AiObjectContextInternal::flash_heal_on_party;
+                creators["dispel magic"] = &AiObjectContextInternal::dispel_magic;
+                creators["dispel magic on party"] = &AiObjectContextInternal::dispel_magic_on_party;
+                creators["dispel magic on target"] = &AiObjectContextInternal::dispel_magic_on_target;
+                creators["cure disease"] = &AiObjectContextInternal::cure_disease;
+                creators["cure disease on party"] = &AiObjectContextInternal::cure_disease_on_party;
+                creators["abolish disease"] = &AiObjectContextInternal::abolish_disease;
+                creators["abolish disease on party"] = &AiObjectContextInternal::abolish_disease_on_party;
+                creators["fade"] = &AiObjectContextInternal::fade;
+                creators["inner fire"] = &AiObjectContextInternal::inner_fire;
+                creators["resurrection"] = &AiObjectContextInternal::resurrection;
+                creators["circle of healing"] = &AiObjectContextInternal::circle_of_healing;
+                creators["psychic scream"] = &AiObjectContextInternal::psychic_scream;
+                creators["vampiric touch"] = &AiObjectContextInternal::vampiric_touch;
+                creators["vampiric embrace"] = &AiObjectContextInternal::vampiric_embrace;
+                creators["dispersion"] = &AiObjectContextInternal::dispersion;
+            }
+
+        private:
+            static Action* dispersion(PlayerbotAI* ai) { return new CastDispersionAction(ai); }
+            static Action* vampiric_embrace(PlayerbotAI* ai) { return new CastVampiricEmbraceAction(ai); }
+            static Action* vampiric_touch(PlayerbotAI* ai) { return new CastVampiricTouchAction(ai); }
+            static Action* psychic_scream(PlayerbotAI* ai) { return new CastPsychicScreamAction(ai); }
+            static Action* circle_of_healing(PlayerbotAI* ai) { return new CastCircleOfHealingAction(ai); }
+            static Action* resurrection(PlayerbotAI* ai) { return new CastResurrectionAction(ai); }
+            static Action* shadow_word_pain(PlayerbotAI* ai) { return new CastPowerWordPainAction(ai); }
+            static Action* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new CastPowerWordPainOnAttackerAction(ai); }
+            static Action* devouring_plague(PlayerbotAI* ai) { return new CastDevouringPlagueAction(ai); }
+            static Action* mind_flay(PlayerbotAI* ai) { return new CastMindFlayAction(ai); }
+            static Action* holy_fire(PlayerbotAI* ai) { return new CastHolyFireAction(ai); }
+            static Action* smite(PlayerbotAI* ai) { return new CastSmiteAction(ai); }
+            static Action* mind_blast(PlayerbotAI* ai) { return new CastMindBlastAction(ai); }
+            static Action* shadowform(PlayerbotAI* ai) { return new CastShadowformAction(ai); }
+            static Action* remove_shadowform(PlayerbotAI* ai) { return new CastRemoveShadowformAction(ai); }
+            static Action* holy_nova(PlayerbotAI* ai) { return new CastHolyNovaAction(ai); }
+            static Action* power_word_fortitude(PlayerbotAI* ai) { return new CastPowerWordFortitudeAction(ai); }
+            static Action* power_word_fortitude_on_party(PlayerbotAI* ai) { return new CastPowerWordFortitudeOnPartyAction(ai); }
+            static Action* divine_spirit(PlayerbotAI* ai) { return new CastDivineSpiritAction(ai); }
+            static Action* divine_spirit_on_party(PlayerbotAI* ai) { return new CastDivineSpiritOnPartyAction(ai); }
+            static Action* power_word_shield(PlayerbotAI* ai) { return new CastPowerWordShieldAction(ai); }
+            static Action* power_word_shield_on_party(PlayerbotAI* ai) { return new CastPowerWordShieldOnPartyAction(ai); }
+            static Action* renew(PlayerbotAI* ai) { return new CastRenewAction(ai); }
+            static Action* renew_on_party(PlayerbotAI* ai) { return new CastRenewOnPartyAction(ai); }
+            static Action* greater_heal(PlayerbotAI* ai) { return new CastGreaterHealAction(ai); }
+            static Action* greater_heal_on_party(PlayerbotAI* ai) { return new CastGreaterHealOnPartyAction(ai); }
+            static Action* heal(PlayerbotAI* ai) { return new CastHealAction(ai); }
+            static Action* heal_on_party(PlayerbotAI* ai) { return new CastHealOnPartyAction(ai); }
+            static Action* lesser_heal(PlayerbotAI* ai) { return new CastLesserHealAction(ai); }
+            static Action* lesser_heal_on_party(PlayerbotAI* ai) { return new CastLesserHealOnPartyAction(ai); }
+            static Action* flash_heal(PlayerbotAI* ai) { return new CastFlashHealAction(ai); }
+            static Action* flash_heal_on_party(PlayerbotAI* ai) { return new CastFlashHealOnPartyAction(ai); }
+            static Action* dispel_magic(PlayerbotAI* ai) { return new CastDispelMagicAction(ai); }
+            static Action* dispel_magic_on_party(PlayerbotAI* ai) { return new CastDispelMagicOnPartyAction(ai); }
+            static Action* dispel_magic_on_target(PlayerbotAI* ai) { return new CastDispelMagicOnTargetAction(ai); }
+            static Action* cure_disease(PlayerbotAI* ai) { return new CastCureDiseaseAction(ai); }
+            static Action* cure_disease_on_party(PlayerbotAI* ai) { return new CastCureDiseaseOnPartyAction(ai); }
+            static Action* abolish_disease(PlayerbotAI* ai) { return new CastAbolishDiseaseAction(ai); }
+            static Action* abolish_disease_on_party(PlayerbotAI* ai) { return new CastAbolishDiseaseOnPartyAction(ai); }
+            static Action* fade(PlayerbotAI* ai) { return new CastFadeAction(ai); }
+            static Action* inner_fire(PlayerbotAI* ai) { return new CastInnerFireAction(ai); }
+        };
+    };
+};
+
+PriestAiObjectContext::PriestAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::priest::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::priest::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::priest::AiObjectContextInternal());
+    triggerContexts.Add(new ai::priest::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
new file mode 100644
index 0000000..315c335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PriestAiObjectContext : public AiObjectContext
+    {
+    public:
+        PriestAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
new file mode 100644
index 0000000..fced53e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.h b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
new file mode 100644
index 0000000..a4d846b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestNonCombatStrategy.h"
+#include "PriestNonCombatStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+PriestNonCombatStrategy::PriestNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new PriestNonCombatStrategyActionNodeFactory());
+}
+
+void PriestNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude",
+        NextAction::array(0, new NextAction("power word: fortitude", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude on party",
+        NextAction::array(0, new NextAction("power word: fortitude on party", 11.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit",
+        NextAction::array(0, new NextAction("divine spirit", 14.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit on party",
+        NextAction::array(0, new NextAction("divine spirit on party", 13.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "inner fire",
+        NextAction::array(0, new NextAction("inner fire", 10.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("greater heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("greater heal on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("flash heal", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("resurrection", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
new file mode 100644
index 0000000..da82e1a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class PriestNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        PriestNonCombatStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "nc"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
new file mode 100644
index 0000000..05edd68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
@@ -0,0 +1,126 @@
+#pragma once
+
+namespace ai
+{
+    class PriestNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        PriestNonCombatStrategyActionNodeFactory()
+        {
+            creators["holy nova"] = &holy_nova;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["circle of healing"] = &circle_of_healing;
+        }
+    private:
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* circle_of_healing(PlayerbotAI* ai)
+        {
+            return new ActionNode ("circle of healing",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("flash heal on party"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
new file mode 100644
index 0000000..941041c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestTriggers.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.h b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
new file mode 100644
index 0000000..83b43c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
@@ -0,0 +1,54 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(PowerWordFortitudeOnPartyTrigger, "power word: fortitude", "power word: fortitude on party")
+    BUFF_TRIGGER(PowerWordFortitudeTrigger, "power word: fortitude", "power word: fortitude")
+
+    BUFF_ON_PARTY_TRIGGER(DivineSpiritOnPartyTrigger, "divine spirit", "divine spirit on party")
+    BUFF_TRIGGER(DivineSpiritTrigger, "divine spirit", "divine spirit")
+    BUFF_TRIGGER(InnerFireTrigger, "inner fire", "inner fire")
+    BUFF_TRIGGER(VampiricEmbraceTrigger, "vampiric embrace", "vampiric embrace")
+
+    class PowerWordPainOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        PowerWordPainOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "shadow word: pain") {}
+    };
+
+    DEBUFF_TRIGGER(PowerWordPainTrigger, "shadow word: pain", "shadow word: pain")
+    DEBUFF_TRIGGER(DevouringPlagueTrigger, "devouring plague", "devouring plague")
+    DEBUFF_TRIGGER(VampiricTouchTrigger, "vampiric touch", "vampiric touch")
+
+    class DispelMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        DispelMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class DispelMagicPartyMemberTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        DispelMagicPartyMemberTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class CureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCureDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCureDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class ShadowformTrigger : public BuffTrigger {
+    public:
+        ShadowformTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadowform") {}
+        virtual bool IsActive() { return !ai->HasAura("shadowform", bot); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
new file mode 100644
index 0000000..718794c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "ShadowPriestStrategy.h"
+#include "ShadowPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+ShadowPriestStrategy::ShadowPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new ShadowPriestStrategyActionNodeFactory());
+}
+
+NextAction** ShadowPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mind blast", 10.0f), NULL);
+}
+
+void ShadowPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadowform",
+        NextAction::array(0, new NextAction("shadowform", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("dispersion", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric embrace",
+        NextAction::array(0, new NextAction("vampiric embrace", 16.0f), NULL)));
+}
+
+void ShadowPriestAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain on attacker",
+        NextAction::array(0, new NextAction("shadow word: pain on attacker", 11.0f), NULL)));
+}
+
+void ShadowPriestDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "devouring plague",
+        NextAction::array(0, new NextAction("devouring plague", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric touch",
+        NextAction::array(0, new NextAction("vampiric touch", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain",
+        NextAction::array(0, new NextAction("shadow word: pain", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
new file mode 100644
index 0000000..3097f4a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class ShadowPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        ShadowPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+
+    class ShadowPriestAoeStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow aoe"; }
+    };
+
+    class ShadowPriestDebuffStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..1b9c533
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
@@ -0,0 +1,37 @@
+#pragma once
+
+namespace ai
+{
+    class ShadowPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShadowPriestStrategyActionNodeFactory()
+        {
+            creators["mind flay"] = &mind_flay;
+            creators["mind blast"] = &mind_blast;
+            creators["dispersion"] = &dispersion;
+        }
+    private:
+        static ActionNode* mind_flay(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind flay",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* mind_blast(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind blast",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mind flay"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* dispersion(PlayerbotAI* ai)
+        {
+            return new ActionNode ("dispersion",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
new file mode 100644
index 0000000..650ac60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
@@ -0,0 +1,110 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "DpsRogueStrategy.h"
+
+using namespace ai;
+
+class DpsRogueStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsRogueStrategyActionNodeFactory()
+    {
+        creators["riposte"] = &riposte;
+        creators["mutilate"] = &mutilate;
+        creators["sinister strike"] = &sinister_strike;
+        creators["kick"] = &kick;
+        creators["kidney shot"] = &kidney_shot;
+        creators["rupture"] = &rupture;
+        creators["backstab"] = &backstab;
+    }
+private:
+    static ActionNode* riposte(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riposte",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mutilate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mutilate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sinister strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* sinister_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("sinister strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kick(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kick",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("kidney shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kidney_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kidney shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rupture(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rupture",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("eviscerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* backstab(PlayerbotAI* ai)
+    {
+        return new ActionNode ("backstab",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsRogueStrategy::DpsRogueStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsRogueStrategyActionNodeFactory());
+}
+
+NextAction** DpsRogueStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("riposte", ACTION_NORMAL), NULL);
+}
+
+void DpsRogueStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("rupture", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium threat",
+		NextAction::array(0, new NextAction("vanish", ACTION_HIGH), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("evasion", ACTION_EMERGENCY), new NextAction("feint", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick",
+		NextAction::array(0, new NextAction("kick", ACTION_INTERRUPT + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick on enemy healer",
+		NextAction::array(0, new NextAction("kick on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "behind target",
+        NextAction::array(0, new NextAction("backstab", ACTION_NORMAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
new file mode 100644
index 0000000..77e2249
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class DpsRogueStrategy : public MeleeCombatStrategy
+    {
+    public:
+        DpsRogueStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
new file mode 100644
index 0000000..7fd4fbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueMultipliers.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
+void GenericRogueNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
new file mode 100644
index 0000000..a595f17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericRogueNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericRogueNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.cpp b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
new file mode 100644
index 0000000..aba6061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.h b/src/plugins/playerbot/strategy/rogue/RogueActions.h
new file mode 100644
index 0000000..a7a78eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "RogueComboActions.h"
+#include "RogueOpeningActions.h"
+#include "RogueFinishingActions.h"
+
+namespace ai
+{
+	class CastEvasionAction : public CastBuffSpellAction
+	{
+	public:
+		CastEvasionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "evasion") {}
+	};
+
+	class CastSprintAction : public CastBuffSpellAction
+	{
+	public:
+		CastSprintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "sprint") {}
+	};
+
+	class CastKickAction : public CastSpellAction
+	{
+	public:
+		CastKickAction(PlayerbotAI* ai) : CastSpellAction(ai, "kick") {}
+	};
+
+	class CastFeintAction : public CastBuffSpellAction
+	{
+	public:
+		CastFeintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feint") {}
+	};
+
+	class CastDismantleAction : public CastSpellAction
+	{
+	public:
+		CastDismantleAction(PlayerbotAI* ai) : CastSpellAction(ai, "dismantle") {}
+	};
+
+	class CastDistractAction : public CastSpellAction
+	{
+	public:
+		CastDistractAction(PlayerbotAI* ai) : CastSpellAction(ai, "distract") {}
+	};
+
+	class CastVanishAction : public CastBuffSpellAction
+	{
+	public:
+		CastVanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vanish") {}
+	};
+
+	class CastBlindAction : public CastDebuffSpellAction
+	{
+	public:
+		CastBlindAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "blind") {}
+	};
+
+
+	class CastBladeFlurryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBladeFlurryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blade flurry") {}
+	};
+
+	class CastAdrenalineRushAction : public CastBuffSpellAction
+	{
+	public:
+		CastAdrenalineRushAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "adrenaline rush") {}
+	};
+
+	class CastKillingSpreeAction : public CastBuffSpellAction
+	{
+	public:
+		CastKillingSpreeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "killing spree") {}
+	};
+
+    class CastKickOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastKickOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
new file mode 100644
index 0000000..fdca0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
@@ -0,0 +1,119 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+#include "RogueTriggers.h"
+#include "RogueAiObjectContext.h"
+#include "DpsRogueStrategy.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &rogue::StrategyFactoryInternal::dps;
+                creators["nc"] = &rogue::StrategyFactoryInternal::nc;
+                creators["pull"] = &rogue::StrategyFactoryInternal::pull;
+            }
+
+        private:
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsRogueStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericRogueNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["kick"] = &TriggerFactoryInternal::kick;
+                creators["rupture"] = &TriggerFactoryInternal::rupture;
+                creators["slice and dice"] = &TriggerFactoryInternal::slice_and_dice;
+                creators["expose armor"] = &TriggerFactoryInternal::expose_armor;
+                creators["kick on enemy healer"] = &TriggerFactoryInternal::kick_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* kick(PlayerbotAI* ai) { return new KickInterruptSpellTrigger(ai); }
+            static Trigger* rupture(PlayerbotAI* ai) { return new RuptureTrigger(ai); }
+            static Trigger* slice_and_dice(PlayerbotAI* ai) { return new SliceAndDiceTrigger(ai); }
+            static Trigger* expose_armor(PlayerbotAI* ai) { return new ExposeArmorTrigger(ai); }
+            static Trigger* kick_on_enemy_healer(PlayerbotAI* ai) { return new KickInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["riposte"] = &AiObjectContextInternal::riposte;
+                creators["mutilate"] = &AiObjectContextInternal::mutilate;
+                creators["sinister strike"] = &AiObjectContextInternal::sinister_strike;
+                creators["kidney shot"] = &AiObjectContextInternal::kidney_shot;
+                creators["rupture"] = &AiObjectContextInternal::rupture;
+                creators["slice and dice"] = &AiObjectContextInternal::slice_and_dice;
+                creators["eviscerate"] = &AiObjectContextInternal::eviscerate;
+                creators["vanish"] = &AiObjectContextInternal::vanish;
+                creators["evasion"] = &AiObjectContextInternal::evasion;
+                creators["kick"] = &AiObjectContextInternal::kick;
+                creators["feint"] = &AiObjectContextInternal::feint;
+                creators["backstab"] = &AiObjectContextInternal::backstab;
+                creators["expose armor"] = &AiObjectContextInternal::expose_armor;
+                creators["kick on enemy healer"] = &AiObjectContextInternal::kick_on_enemy_healer;
+            }
+
+        private:
+            static Action* riposte(PlayerbotAI* ai) { return new CastRiposteAction(ai); }
+            static Action* mutilate(PlayerbotAI* ai) { return new CastMutilateAction(ai); }
+            static Action* sinister_strike(PlayerbotAI* ai) { return new CastSinisterStrikeAction(ai); }
+            static Action* kidney_shot(PlayerbotAI* ai) { return new CastKidneyShotAction(ai); }
+            static Action* rupture(PlayerbotAI* ai) { return new CastRuptureAction(ai); }
+            static Action* slice_and_dice(PlayerbotAI* ai) { return new CastSliceAndDiceAction(ai); }
+            static Action* eviscerate(PlayerbotAI* ai) { return new CastEviscerateAction(ai); }
+            static Action* vanish(PlayerbotAI* ai) { return new CastVanishAction(ai); }
+            static Action* evasion(PlayerbotAI* ai) { return new CastEvasionAction(ai); }
+            static Action* kick(PlayerbotAI* ai) { return new CastKickAction(ai); }
+            static Action* feint(PlayerbotAI* ai) { return new CastFeintAction(ai); }
+            static Action* backstab(PlayerbotAI* ai) { return new CastBackstabAction(ai); }
+            static Action* expose_armor(PlayerbotAI* ai) { return new CastExposeArmorAction(ai); }
+            static Action* kick_on_enemy_healer(PlayerbotAI* ai) { return new CastKickOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+RogueAiObjectContext::RogueAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::rogue::StrategyFactoryInternal());
+    actionContexts.Add(new ai::rogue::AiObjectContextInternal());
+    triggerContexts.Add(new ai::rogue::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
new file mode 100644
index 0000000..ba34626
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class RogueAiObjectContext : public AiObjectContext
+    {
+    public:
+        RogueAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueComboActions.h b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
new file mode 100644
index 0000000..186e2eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
@@ -0,0 +1,45 @@
+#pragma once
+
+namespace ai
+{
+	class CastComboAction : public CastMeleeSpellAction
+	{
+	public:
+	    CastComboAction(PlayerbotAI* ai, string name) : CastMeleeSpellAction(ai, name) {}
+
+	    virtual bool isUseful()
+	    {
+	        return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "combo", "self target") < 5;
+	    }
+	};
+
+	class CastSinisterStrikeAction : public CastComboAction
+	{
+	public:
+		CastSinisterStrikeAction(PlayerbotAI* ai) : CastComboAction(ai, "sinister strike") {}
+	};
+
+    class CastMutilateAction : public CastComboAction
+    {
+    public:
+        CastMutilateAction(PlayerbotAI* ai) : CastComboAction(ai, "mutilate") {}
+    };
+
+    class CastRiposteAction : public CastComboAction
+    {
+    public:
+        CastRiposteAction(PlayerbotAI* ai) : CastComboAction(ai, "riposte") {}
+    };
+
+	class CastGougeAction : public CastComboAction
+	{
+	public:
+		CastGougeAction(PlayerbotAI* ai) : CastComboAction(ai, "gouge") {}
+	};
+
+    class CastBackstabAction : public CastComboAction
+    {
+    public:
+        CastBackstabAction(PlayerbotAI* ai) : CastComboAction(ai, "backstab") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
new file mode 100644
index 0000000..6538d18
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
@@ -0,0 +1,35 @@
+#pragma once
+
+namespace ai
+{
+	class CastEviscerateAction : public CastMeleeSpellAction
+	{
+	public:
+		CastEviscerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "eviscerate") {}
+	};
+
+	class CastSliceAndDiceAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSliceAndDiceAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slice and dice") {}
+	};
+
+	class CastExposeArmorAction : public CastMeleeSpellAction
+	{
+	public:
+		CastExposeArmorAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "expose armor") {}
+	};
+
+	class CastRuptureAction : public CastMeleeSpellAction
+	{
+	public:
+		CastRuptureAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rupture") {}
+	};
+
+	class CastKidneyShotAction : public CastMeleeSpellAction
+	{
+	public:
+		CastKidneyShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "kidney shot") {}
+	};
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
new file mode 100644
index 0000000..136fd0d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "RogueActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
new file mode 100644
index 0000000..c0960e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+	class CastSapAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSapAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "sap") {}
+	};
+
+	class CastGarroteAction : public CastMeleeSpellAction
+	{
+	public:
+		CastGarroteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "garrote") {}
+	};
+
+
+	class CastCheapShotAction : public CastMeleeSpellAction
+	{
+	public:
+		CastCheapShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cheap shot") {}
+	};
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
new file mode 100644
index 0000000..8f57d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.h b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
new file mode 100644
index 0000000..8d20e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+
+    class KickInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        KickInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "kick") {}
+    };
+
+    class SliceAndDiceTrigger : public BuffTrigger
+    {
+    public:
+        SliceAndDiceTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "slice and dice") {}
+    };
+
+    class RuptureTrigger : public DebuffTrigger
+    {
+    public:
+        RuptureTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rupture") {}
+    };
+
+    class ExposeArmorTrigger : public DebuffTrigger
+    {
+    public:
+        ExposeArmorTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "expose armor") {}
+    };
+
+    class KickInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        KickInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
new file mode 100644
index 0000000..aa1b6a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+class CasterShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterShamanStrategyActionNodeFactory()
+    {
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+CasterShamanStrategy::CasterShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterShamanStrategyActionNodeFactory());
+}
+
+NextAction** CasterShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("lightning bolt", 10.0f), NULL);
+}
+
+void CasterShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("flametongue weapon", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "frost shock snare",
+        NextAction::array(0, new NextAction("frost shock", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flametongue totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void CasterAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeAoeShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("chain lightning", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("thunderstorm", 26.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
new file mode 100644
index 0000000..f9444c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+
+namespace ai
+{
+    class CasterShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        CasterShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "caster"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterAoeShamanStrategy : public MeleeAoeShamanStrategy
+    {
+    public:
+        CasterAoeShamanStrategy(PlayerbotAI* ai) : MeleeAoeShamanStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
new file mode 100644
index 0000000..18a9c3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
@@ -0,0 +1,159 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class GenericShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericShamanStrategyActionNodeFactory()
+    {
+        creators["flametongue weapon"] = &flametongue_weapon;
+        creators["frostbrand weapon"] = &frostbrand_weapon;
+        creators["windfury weapon"] = &windfury_weapon;
+        creators["lesser healing wave"] = &lesser_healing_wave;
+        creators["lesser healing wave on party"] = &lesser_healing_wave_on_party;
+        creators["chain heal"] = &chain_heal;
+        creators["riptide"] = &riptide;
+        creators["chain heal on party"] = &chain_heal_on_party;
+        creators["riptide on party"] = &riptide_on_party;
+        creators["earth shock"] = &earth_shock;
+    }
+private:
+    static ActionNode* earth_shock(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earth shock",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flame shock"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flametongue_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flametongue weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frostbrand weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frostbrand_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbrand weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* windfury_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("windfury weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericShamanStrategy::GenericShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericShamanStrategyActionNodeFactory());
+}
+
+void GenericShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "wind shear",
+        NextAction::array(0, new NextAction("wind shear", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "wind shear on enemy healer",
+        NextAction::array(0, new NextAction("wind shear on enemy healer", 23.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "purge",
+		NextAction::array(0, new NextAction("purge", 10.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member medium health",
+		NextAction::array(0, new NextAction("lesser healing wave on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member low health",
+		NextAction::array(0, new NextAction("riptide on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium health",
+		NextAction::array(0, new NextAction("lesser healing wave", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("riptide", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"heroism",
+		NextAction::array(0, new NextAction("heroism", 31.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"bloodlust",
+		NextAction::array(0, new NextAction("bloodlust", 30.0f), NULL)));
+}
+
+void ShamanBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "lightning shield",
+        NextAction::array(0, new NextAction("lightning shield", 22.0f), NULL)));
+}
+
+void ShamanBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "water shield",
+        NextAction::array(0, new NextAction("water shield", 22.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
new file mode 100644
index 0000000..fdac460
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericShamanStrategy : public CombatStrategy
+    {
+    public:
+        GenericShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+    class ShamanBuffDpsStrategy : public Strategy
+    {
+    public:
+        ShamanBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+
+    };
+
+    class ShamanBuffManaStrategy : public Strategy
+    {
+    public:
+        ShamanBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
new file mode 100644
index 0000000..0d05326
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class HealShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealShamanStrategyActionNodeFactory()
+    {
+        creators["earthliving weapon"] = &earthliving_weapon;
+        creators["mana tide totem"] = &mana_tide_totem;
+    }
+private:
+    static ActionNode* earthliving_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earthliving weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flametongue weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_tide_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana tide totem",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+
+};
+
+HealShamanStrategy::HealShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new HealShamanStrategyActionNodeFactory());
+}
+
+void HealShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("earthliving weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("mana tide totem", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit poison on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit curse on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit disease on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("healing stream totem", ACTION_LIGHT_HEAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
new file mode 100644
index 0000000..e5d4ff1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class HealShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        HealShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
new file mode 100644
index 0000000..34eab8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
@@ -0,0 +1,93 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "MeleeShamanStrategy.h"
+
+using namespace ai;
+
+class MeleeShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    MeleeShamanStrategyActionNodeFactory()
+    {
+        creators["stormstrike"] = &stormstrike;
+        creators["lava lash"] = &lava_lash;
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* stormstrike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("stormstrike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lava lash"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lava_lash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lava lash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+MeleeShamanStrategy::MeleeShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new MeleeShamanStrategyActionNodeFactory());
+}
+
+NextAction** MeleeShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stormstrike", 10.0f), NULL);
+}
+
+void MeleeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("windfury weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("strength of earth totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void MeleeAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "magma totem",
+        NextAction::array(0, new NextAction("magma totem", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("fire nova", 25.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
new file mode 100644
index 0000000..6c18fb6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class MeleeShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        MeleeShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "melee"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class MeleeAoeShamanStrategy : public CombatStrategy
+    {
+    public:
+        MeleeAoeShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "melee aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
new file mode 100644
index 0000000..ab8b070
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.h b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
new file mode 100644
index 0000000..478d08a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
@@ -0,0 +1,304 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastLesserHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser healing wave") {}
+    };
+
+    class CastLesserHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser healing wave") {}
+    };
+
+
+    class CastHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing wave") {}
+    };
+
+    class CastHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing wave") {}
+    };
+
+    class CastChainHealAction : public CastAoeHealSpellAction {
+    public:
+        CastChainHealAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "chain heal") {}
+    };
+
+    class CastRiptideAction : public CastHealingSpellAction {
+    public:
+        CastRiptideAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "riptide") {}
+    };
+
+    class CastRiptideOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRiptideOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "riptide") {}
+    };
+
+
+    class CastEarthShieldAction : public CastBuffSpellAction {
+    public:
+        CastEarthShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "earth shield") {}
+    };
+
+    class CastEarthShieldOnPartyAction : public BuffOnPartyAction
+    {
+    public:
+        CastEarthShieldOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "earth shield") {}
+    };
+
+    class CastWaterShieldAction : public CastBuffSpellAction {
+    public:
+        CastWaterShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water shield") {}
+    };
+
+	class CastLightningShieldAction : public CastBuffSpellAction {
+	public:
+		CastLightningShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "lightning shield") {}
+	};
+
+    class CastEarthlivingWeaponAction : public CastEnchantItemAction {
+    public:
+        CastEarthlivingWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "earthliving weapon") {}
+    };
+
+    class CastRockbiterWeaponAction : public CastEnchantItemAction {
+    public:
+        CastRockbiterWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "rockbiter weapon") {}
+    };
+
+    class CastFlametongueWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFlametongueWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "flametongue weapon") {}
+    };
+
+    class CastFrostbrandWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFrostbrandWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "frostbrand weapon") {}
+    };
+
+    class CastWindfuryWeaponAction : public CastEnchantItemAction {
+    public:
+        CastWindfuryWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "windfury weapon") {}
+    };
+
+    class CastTotemAction : public CastBuffSpellAction
+    {
+    public:
+        CastTotemAction(PlayerbotAI* ai, string spell) : CastBuffSpellAction(ai, spell) {}
+        virtual bool isUseful() { return CastBuffSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastStoneskinTotemAction : public CastTotemAction
+    {
+    public:
+        CastStoneskinTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "stoneskin totem") {}
+    };
+
+    class CastEarthbindTotemAction : public CastTotemAction
+    {
+    public:
+        CastEarthbindTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "earthbind totem") {}
+    };
+
+    class CastStrengthOfEarthTotemAction : public CastTotemAction
+    {
+    public:
+        CastStrengthOfEarthTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "strength of earth totem") {}
+    };
+
+    class CastManaSpringTotemAction : public CastTotemAction
+    {
+    public:
+        CastManaSpringTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana spring totem") {}
+    };
+
+	class CastManaTideTotemAction : public CastTotemAction
+	{
+	public:
+		CastManaTideTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana tide totem") {}
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastHealingStreamTotemAction : public CastTotemAction
+	{
+	public:
+		CastHealingStreamTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "healing stream totem") {}
+	};
+
+    class CastCleansingTotemAction : public CastTotemAction
+    {
+    public:
+        CastCleansingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "cleansing totem") {}
+    };
+
+    class CastFlametongueTotemAction : public CastTotemAction
+    {
+    public:
+        CastFlametongueTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "flametongue totem") {}
+    };
+
+    class CastWindfuryTotemAction : public CastTotemAction
+    {
+    public:
+        CastWindfuryTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "windfury totem") {}
+    };
+
+    class CastSearingTotemAction : public CastTotemAction
+    {
+    public:
+        CastSearingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "searing totem") {}
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastMagmaTotemAction : public CastMeleeSpellAction
+    {
+    public:
+        CastMagmaTotemAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "magma totem") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastFireNovaAction : public CastSpellAction {
+    public:
+        CastFireNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire nova") {}
+    };
+
+    class CastWindShearAction : public CastSpellAction {
+    public:
+        CastWindShearAction(PlayerbotAI* ai) : CastSpellAction(ai, "wind shear") {}
+    };
+
+	class CastAncestralSpiritAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastAncestralSpiritAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "ancestral spirit") {}
+	};
+
+
+	class CastPurgeAction : public CastSpellAction
+	{
+	public:
+		CastPurgeAction(PlayerbotAI* ai) : CastSpellAction(ai, "purge") {}
+	};
+
+	class CastStormstrikeAction : public CastMeleeSpellAction {
+	public:
+		CastStormstrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "stormstrike") {}
+	};
+
+	class CastLavaLashAction : public CastMeleeSpellAction {
+	public:
+		CastLavaLashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lava lash") {}
+	};
+
+    class CastWaterBreathingAction : public CastBuffSpellAction {
+    public:
+        CastWaterBreathingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingAction : public CastBuffSpellAction {
+    public:
+        CastWaterWalkingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water walking") {}
+    };
+
+    class CastWaterBreathingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterBreathingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterWalkingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water walking") {}
+    };
+
+
+    class CastCleanseSpiritAction : public CastCureSpellAction {
+    public:
+        CastCleanseSpiritAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse spirit") {}
+    };
+
+    class CastCleanseSpiritPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse spirit poison on party"; }
+    };
+    class CastCleanseSpiritCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_CURSE) {}
+
+        virtual string getName() { return "cleanse spirit curse on party"; }
+    };
+    class CastCleanseSpiritDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_DISEASE) {}
+
+        virtual string getName() { return "cleanse spirit disease on party"; }
+    };
+
+    class CastFlameShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFlameShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "flame shock") {}
+    };
+
+    class CastEarthShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastEarthShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "earth shock") {}
+    };
+
+    class CastFrostShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFrostShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "frost shock") {}
+    };
+
+    class CastChainLightningAction : public CastSpellAction
+    {
+    public:
+        CastChainLightningAction(PlayerbotAI* ai) : CastSpellAction(ai, "chain lightning") {}
+    };
+
+    class CastLightningBoltAction : public CastSpellAction
+    {
+    public:
+        CastLightningBoltAction(PlayerbotAI* ai) : CastSpellAction(ai, "lightning bolt") {}
+    };
+
+    class CastThunderstormAction : public CastMeleeSpellAction
+    {
+    public:
+        CastThunderstormAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "thunderstorm") {}
+    };
+
+    class CastHeroismAction : public CastBuffSpellAction
+    {
+    public:
+        CastHeroismAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "heroism") {}
+    };
+
+    class CastBloodlustAction : public CastBuffSpellAction
+    {
+    public:
+        CastBloodlustAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodlust") {}
+    };
+
+    class CastWindShearOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastWindShearOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
new file mode 100644
index 0000000..cbd8ec3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
@@ -0,0 +1,268 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+#include "ShamanAiObjectContext.h"
+#include "ShamanNonCombatStrategy.h"
+#include "HealShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+#include "ShamanTriggers.h"
+#include "../NamedObjectContext.h"
+#include "TotemsShamanStrategy.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &shaman::StrategyFactoryInternal::nc;
+                creators["totems"] = &shaman::StrategyFactoryInternal::totems;
+                creators["melee aoe"] = &shaman::StrategyFactoryInternal::melee_aoe;
+                creators["caster aoe"] = &shaman::StrategyFactoryInternal::caster_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new ShamanNonCombatStrategy(ai); }
+            static Strategy* totems(PlayerbotAI* ai) { return new TotemsShamanStrategy(ai); }
+            static Strategy* melee_aoe(PlayerbotAI* ai) { return new MeleeAoeShamanStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterAoeShamanStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &shaman::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &shaman::BuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new ShamanBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new ShamanBuffDpsStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &shaman::CombatStrategyFactoryInternal::heal;
+                creators["melee"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["caster"] = &shaman::CombatStrategyFactoryInternal::caster;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealShamanStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new MeleeShamanStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterShamanStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["windfury totem"] = &TriggerFactoryInternal::windfury_totem;
+                creators["mana spring totem"] = &TriggerFactoryInternal::mana_spring_totem;
+                creators["flametongue totem"] = &TriggerFactoryInternal::flametongue_totem;
+                creators["strength of earth totem"] = &TriggerFactoryInternal::strength_of_earth_totem;
+                creators["magma totem"] = &TriggerFactoryInternal::magma_totem;
+                creators["searing totem"] = &TriggerFactoryInternal::searing_totem;
+                creators["wind shear"] = &TriggerFactoryInternal::wind_shear;
+                creators["purge"] = &TriggerFactoryInternal::purge;
+                creators["shaman weapon"] = &TriggerFactoryInternal::shaman_weapon;
+                creators["water shield"] = &TriggerFactoryInternal::water_shield;
+                creators["lightning shield"] = &TriggerFactoryInternal::lightning_shield;
+                creators["water breathing"] = &TriggerFactoryInternal::water_breathing;
+                creators["water walking"] = &TriggerFactoryInternal::water_walking;
+                creators["water breathing on party"] = &TriggerFactoryInternal::water_breathing_on_party;
+                creators["water walking on party"] = &TriggerFactoryInternal::water_walking_on_party;
+                creators["cleanse spirit poison"] = &TriggerFactoryInternal::cleanse_poison;
+                creators["cleanse spirit curse"] = &TriggerFactoryInternal::cleanse_curse;
+                creators["cleanse spirit disease"] = &TriggerFactoryInternal::cleanse_disease;
+                creators["party member cleanse spirit poison"] = &TriggerFactoryInternal::party_member_cleanse_poison;
+                creators["party member cleanse spirit curse"] = &TriggerFactoryInternal::party_member_cleanse_curse;
+                creators["party member cleanse spirit disease"] = &TriggerFactoryInternal::party_member_cleanse_disease;
+                creators["shock"] = &TriggerFactoryInternal::shock;
+                creators["frost shock snare"] = &TriggerFactoryInternal::frost_shock_snare;
+                creators["heroism"] = &TriggerFactoryInternal::heroism;
+                creators["bloodlust"] = &TriggerFactoryInternal::bloodlust;
+                creators["maelstrom weapon"] = &TriggerFactoryInternal::maelstrom_weapon;
+                creators["wind shear on enemy healer"] = &TriggerFactoryInternal::wind_shear_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* maelstrom_weapon(PlayerbotAI* ai) { return new MaelstromWeaponTrigger(ai); }
+            static Trigger* heroism(PlayerbotAI* ai) { return new HeroismTrigger(ai); }
+            static Trigger* bloodlust(PlayerbotAI* ai) { return new BloodlustTrigger(ai); }
+            static Trigger* party_member_cleanse_disease(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* party_member_cleanse_curse(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritCurseTrigger(ai); }
+            static Trigger* party_member_cleanse_poison(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritPoisonTrigger(ai); }
+            static Trigger* cleanse_disease(PlayerbotAI* ai) { return new CleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* cleanse_curse(PlayerbotAI* ai) { return new CleanseSpiritCurseTrigger(ai); }
+            static Trigger* cleanse_poison(PlayerbotAI* ai) { return new CleanseSpiritPoisonTrigger(ai); }
+            static Trigger* water_breathing(PlayerbotAI* ai) { return new WaterBreathingTrigger(ai); }
+            static Trigger* water_walking(PlayerbotAI* ai) { return new WaterWalkingTrigger(ai); }
+            static Trigger* water_breathing_on_party(PlayerbotAI* ai) { return new WaterBreathingOnPartyTrigger(ai); }
+            static Trigger* water_walking_on_party(PlayerbotAI* ai) { return new WaterWalkingOnPartyTrigger(ai); }
+            static Trigger* windfury_totem(PlayerbotAI* ai) { return new WindfuryTotemTrigger(ai); }
+            static Trigger* mana_spring_totem(PlayerbotAI* ai) { return new ManaSpringTotemTrigger(ai); }
+            static Trigger* flametongue_totem(PlayerbotAI* ai) { return new FlametongueTotemTrigger(ai); }
+            static Trigger* strength_of_earth_totem(PlayerbotAI* ai) { return new StrengthOfEarthTotemTrigger(ai); }
+            static Trigger* magma_totem(PlayerbotAI* ai) { return new MagmaTotemTrigger(ai); }
+            static Trigger* searing_totem(PlayerbotAI* ai) { return new SearingTotemTrigger(ai); }
+            static Trigger* wind_shear(PlayerbotAI* ai) { return new WindShearInterruptSpellTrigger(ai); }
+            static Trigger* purge(PlayerbotAI* ai) { return new PurgeTrigger(ai); }
+            static Trigger* shaman_weapon(PlayerbotAI* ai) { return new ShamanWeaponTrigger(ai); }
+            static Trigger* water_shield(PlayerbotAI* ai) { return new WaterShieldTrigger(ai); }
+            static Trigger* lightning_shield(PlayerbotAI* ai) { return new LightningShieldTrigger(ai); }
+            static Trigger* shock(PlayerbotAI* ai) { return new ShockTrigger(ai); }
+            static Trigger* frost_shock_snare(PlayerbotAI* ai) { return new FrostShockSnareTrigger(ai); }
+            static Trigger* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new WindShearInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["water shield"] = &AiObjectContextInternal::water_shield;
+                creators["lightning shield"] = &AiObjectContextInternal::lightning_shield;
+                creators["strength of earth totem"] = &AiObjectContextInternal::strength_of_earth_totem;
+                creators["flametongue totem"] = &AiObjectContextInternal::flametongue_totem;
+                creators["searing totem"] = &AiObjectContextInternal::searing_totem;
+                creators["magma totem"] = &AiObjectContextInternal::magma_totem;
+                creators["windfury totem"] = &AiObjectContextInternal::windfury_totem;
+                creators["mana spring totem"] = &AiObjectContextInternal::mana_spring_totem;
+                creators["mana tide totem"] = &AiObjectContextInternal::mana_tide_totem;
+                creators["healing stream totem"] = &AiObjectContextInternal::healing_stream_totem;
+                creators["wind shear"] = &AiObjectContextInternal::wind_shear;
+                creators["wind shear on enemy healer"] = &AiObjectContextInternal::wind_shear_on_enemy_healer;
+                creators["rockbiter weapon"] = &AiObjectContextInternal::rockbiter_weapon;
+                creators["flametongue weapon"] = &AiObjectContextInternal::flametongue_weapon;
+                creators["frostbrand weapon"] = &AiObjectContextInternal::frostbrand_weapon;
+                creators["windfury weapon"] = &AiObjectContextInternal::windfury_weapon;
+                creators["earthliving weapon"] = &AiObjectContextInternal::earthliving_weapon;
+                creators["purge"] = &AiObjectContextInternal::purge;
+                creators["healing wave"] = &AiObjectContextInternal::healing_wave;
+                creators["lesser healing wave"] = &AiObjectContextInternal::lesser_healing_wave;
+                creators["healing wave on party"] = &AiObjectContextInternal::healing_wave_on_party;
+                creators["lesser healing wave on party"] = &AiObjectContextInternal::lesser_healing_wave_on_party;
+                creators["earth shield"] = &AiObjectContextInternal::earth_shield;
+                creators["earth shield on party"] = &AiObjectContextInternal::earth_shield_on_party;
+                creators["chain heal"] = &AiObjectContextInternal::chain_heal;
+                creators["riptide"] = &AiObjectContextInternal::riptide;
+                creators["riptide on party"] = &AiObjectContextInternal::riptide_on_party;
+                creators["stormstrike"] = &AiObjectContextInternal::stormstrike;
+                creators["lava lash"] = &AiObjectContextInternal::lava_lash;
+                creators["fire nova"] = &AiObjectContextInternal::fire_nova;
+                creators["ancestral spirit"] = &AiObjectContextInternal::ancestral_spirit;
+                creators["water walking"] = &AiObjectContextInternal::water_walking;
+                creators["water breathing"] = &AiObjectContextInternal::water_breathing;
+                creators["water walking on party"] = &AiObjectContextInternal::water_walking_on_party;
+                creators["water breathing on party"] = &AiObjectContextInternal::water_breathing_on_party;
+                creators["cleanse spirit"] = &AiObjectContextInternal::cleanse_spirit;
+                creators["cleanse spirit poison on party"] = &AiObjectContextInternal::cleanse_spirit_poison_on_party;
+                creators["cleanse spirit disease on party"] = &AiObjectContextInternal::cleanse_spirit_disease_on_party;
+                creators["cleanse spirit curse on party"] = &AiObjectContextInternal::cleanse_spirit_curse_on_party;
+                creators["flame shock"] = &AiObjectContextInternal::flame_shock;
+                creators["earth shock"] = &AiObjectContextInternal::earth_shock;
+                creators["frost shock"] = &AiObjectContextInternal::frost_shock;
+                creators["chain lightning"] = &AiObjectContextInternal::chain_lightning;
+                creators["lightning bolt"] = &AiObjectContextInternal::lightning_bolt;
+                creators["thunderstorm"] = &AiObjectContextInternal::thunderstorm;
+                creators["heroism"] = &AiObjectContextInternal::heroism;
+                creators["bloodlust"] = &AiObjectContextInternal::bloodlust;
+            }
+
+        private:
+            static Action* heroism(PlayerbotAI* ai) { return new CastHeroismAction(ai); }
+            static Action* bloodlust(PlayerbotAI* ai) { return new CastBloodlustAction(ai); }
+            static Action* thunderstorm(PlayerbotAI* ai) { return new CastThunderstormAction(ai); }
+            static Action* lightning_bolt(PlayerbotAI* ai) { return new CastLightningBoltAction(ai); }
+            static Action* chain_lightning(PlayerbotAI* ai) { return new CastChainLightningAction(ai); }
+            static Action* frost_shock(PlayerbotAI* ai) { return new CastFrostShockAction(ai); }
+            static Action* earth_shock(PlayerbotAI* ai) { return new CastEarthShockAction(ai); }
+            static Action* flame_shock(PlayerbotAI* ai) { return new CastFlameShockAction(ai); }
+            static Action* cleanse_spirit_poison_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritPoisonOnPartyAction(ai); }
+            static Action* cleanse_spirit_disease_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritDiseaseOnPartyAction(ai); }
+            static Action* cleanse_spirit_curse_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritCurseOnPartyAction(ai); }
+            static Action* cleanse_spirit(PlayerbotAI* ai) { return new CastCleanseSpiritAction(ai); }
+            static Action* water_walking(PlayerbotAI* ai) { return new CastWaterWalkingAction(ai); }
+            static Action* water_breathing(PlayerbotAI* ai) { return new CastWaterBreathingAction(ai); }
+            static Action* water_walking_on_party(PlayerbotAI* ai) { return new CastWaterWalkingOnPartyAction(ai); }
+            static Action* water_breathing_on_party(PlayerbotAI* ai) { return new CastWaterBreathingOnPartyAction(ai); }
+            static Action* water_shield(PlayerbotAI* ai) { return new CastWaterShieldAction(ai); }
+            static Action* lightning_shield(PlayerbotAI* ai) { return new CastLightningShieldAction(ai); }
+            static Action* strength_of_earth_totem(PlayerbotAI* ai) { return new CastStrengthOfEarthTotemAction(ai); }
+            static Action* flametongue_totem(PlayerbotAI* ai) { return new CastFlametongueTotemAction(ai); }
+            static Action* magma_totem(PlayerbotAI* ai) { return new CastMagmaTotemAction(ai); }
+            static Action* searing_totem(PlayerbotAI* ai) { return new CastSearingTotemAction(ai); }
+            static Action* fire_nova(PlayerbotAI* ai) { return new CastFireNovaAction(ai); }
+            static Action* windfury_totem(PlayerbotAI* ai) { return new CastWindfuryTotemAction(ai); }
+            static Action* mana_spring_totem(PlayerbotAI* ai) { return new CastManaSpringTotemAction(ai); }
+            static Action* mana_tide_totem(PlayerbotAI* ai) { return new CastManaTideTotemAction(ai); }
+            static Action* healing_stream_totem(PlayerbotAI* ai) { return new CastHealingStreamTotemAction(ai); }
+            static Action* wind_shear(PlayerbotAI* ai) { return new CastWindShearAction(ai); }
+            static Action* rockbiter_weapon(PlayerbotAI* ai) { return new CastRockbiterWeaponAction(ai); }
+            static Action* flametongue_weapon(PlayerbotAI* ai) { return new CastFlametongueWeaponAction(ai); }
+            static Action* frostbrand_weapon(PlayerbotAI* ai) { return new CastFrostbrandWeaponAction(ai); }
+            static Action* windfury_weapon(PlayerbotAI* ai) { return new CastWindfuryWeaponAction(ai); }
+            static Action* earthliving_weapon(PlayerbotAI* ai) { return new CastEarthlivingWeaponAction(ai); }
+            static Action* purge(PlayerbotAI* ai) { return new CastPurgeAction(ai); }
+            static Action* healing_wave(PlayerbotAI* ai) { return new CastHealingWaveAction(ai); }
+            static Action* lesser_healing_wave(PlayerbotAI* ai) { return new CastLesserHealingWaveAction(ai); }
+            static Action* healing_wave_on_party(PlayerbotAI* ai) { return new CastHealingWaveOnPartyAction(ai); }
+            static Action* lesser_healing_wave_on_party(PlayerbotAI* ai) { return new CastLesserHealingWaveOnPartyAction(ai); }
+            static Action* earth_shield(PlayerbotAI* ai) { return new CastEarthShieldAction(ai); }
+            static Action* earth_shield_on_party(PlayerbotAI* ai) { return new CastEarthShieldOnPartyAction(ai); }
+            static Action* chain_heal(PlayerbotAI* ai) { return new CastChainHealAction(ai); }
+            static Action* riptide(PlayerbotAI* ai) { return new CastRiptideAction(ai); }
+            static Action* riptide_on_party(PlayerbotAI* ai) { return new CastRiptideOnPartyAction(ai); }
+            static Action* stormstrike(PlayerbotAI* ai) { return new CastStormstrikeAction(ai); }
+            static Action* lava_lash(PlayerbotAI* ai) { return new CastLavaLashAction(ai); }
+            static Action* ancestral_spirit(PlayerbotAI* ai) { return new CastAncestralSpiritAction(ai); }
+            static Action* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new CastWindShearOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+ShamanAiObjectContext::ShamanAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::shaman::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::shaman::AiObjectContextInternal());
+    triggerContexts.Add(new ai::shaman::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
new file mode 100644
index 0000000..718084a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class ShamanAiObjectContext : public AiObjectContext
+    {
+    public:
+        ShamanAiObjectContext(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
new file mode 100644
index 0000000..6c72f20
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
new file mode 100644
index 0000000..044c6bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanNonCombatStrategy.h"
+
+using namespace ai;
+
+void ShamanNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("ancestral spirit", 33.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water breathing",
+		NextAction::array(0, new NextAction("water breathing", 12.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water walking",
+		NextAction::array(0, new NextAction("water walking", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water breathing on party",
+        NextAction::array(0, new NextAction("water breathing on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water walking on party",
+        NextAction::array(0, new NextAction("water walking on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing wave", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("healing wave on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+}
+
+void ShamanNonCombatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    NonCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
new file mode 100644
index 0000000..a6859ee
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class ShamanNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        ShamanNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "nc"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
new file mode 100644
index 0000000..2a6c51e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanTriggers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
+list<string> ShamanWeaponTrigger::spells;
+
+bool ShamanWeaponTrigger::IsActive()
+{
+    if (spells.empty())
+    {
+        spells.push_back("frostbrand weapon");
+        spells.push_back("rockbiter weapon");
+        spells.push_back("flametongue weapon");
+        spells.push_back("earthliving weapon");
+        spells.push_back("windfury weapon");
+    }
+
+    for (list<string>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+        if (!spellId)
+            continue;
+
+        if (AI_VALUE2(Item*, "item for spell", spellId))
+            return true;
+    }
+
+    return false;
+}
+
+bool ShockTrigger::IsActive()
+{
+    return SpellTrigger::IsActive()
+            && !ai->HasAnyAuraOf(GetTarget(), "frost shock", "earth shock", "flame shock", NULL);
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
new file mode 100644
index 0000000..afa6d62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
@@ -0,0 +1,197 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    class ShamanWeaponTrigger : public BuffTrigger {
+    public:
+        ShamanWeaponTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "rockbiter weapon") {}
+        virtual bool IsActive();
+    private:
+        static list<string> spells;
+    };
+
+    class TotemTrigger : public Trigger {
+    public:
+        TotemTrigger(PlayerbotAI* ai, string spell, int attackerCount = 0) : Trigger(ai, spell), attackerCount(attackerCount) {}
+
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= attackerCount && !AI_VALUE2(bool, "has totem", name);
+        }
+
+    protected:
+        int attackerCount;
+    };
+
+    class WindfuryTotemTrigger : public TotemTrigger {
+    public:
+        WindfuryTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "windfury totem") {}
+    };
+
+    class ManaSpringTotemTrigger : public TotemTrigger {
+    public:
+        ManaSpringTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "mana spring totem") {}
+        virtual bool IsActive()
+        {
+            return AI_VALUE(uint8, "attacker count") >= attackerCount &&
+                    !AI_VALUE2(bool, "has totem", "mana tide totem") &&
+                    !AI_VALUE2(bool, "has totem", name);
+        }
+    };
+
+    class FlametongueTotemTrigger : public TotemTrigger {
+    public:
+        FlametongueTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "flametongue totem") {}
+    };
+
+    class StrengthOfEarthTotemTrigger : public TotemTrigger {
+    public:
+        StrengthOfEarthTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "strength of earth totem") {}
+    };
+
+    class MagmaTotemTrigger : public TotemTrigger {
+    public:
+        MagmaTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "magma totem", 3) {}
+    };
+
+    class SearingTotemTrigger : public TotemTrigger {
+    public:
+        SearingTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "searing totem", 1) {}
+    };
+
+    class WindShearInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        WindShearInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "wind shear") {}
+    };
+
+    class WaterShieldTrigger : public BuffTrigger
+    {
+    public:
+        WaterShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water shield") {}
+    };
+
+    class LightningShieldTrigger : public BuffTrigger
+    {
+    public:
+        LightningShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "lightning shield") {}
+    };
+
+    class PurgeTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        PurgeTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "purge", DISPEL_MAGIC) {}
+    };
+
+    class WaterWalkingTrigger : public BuffTrigger {
+    public:
+        WaterWalkingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water walking") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingTrigger : public BuffTrigger {
+    public:
+        WaterBreathingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water breathing") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterWalkingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterWalkingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water walking on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterBreathingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water breathing on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class CleanseSpiritPoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritPoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCleanseSpiritPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class CleanseSpiritCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberCleanseSpiritCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class CleanseSpiritDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCleanseSpiritDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class ShockTrigger : public DebuffTrigger {
+    public:
+        ShockTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "earth shock") {}
+        virtual bool IsActive();
+    };
+
+    class FrostShockSnareTrigger : public SnareTargetTrigger {
+    public:
+        FrostShockSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "frost shock") {}
+    };
+
+    class HeroismTrigger : public BoostTrigger
+    {
+    public:
+        HeroismTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "heroism") {}
+    };
+
+    class BloodlustTrigger : public BoostTrigger
+    {
+    public:
+        BloodlustTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "bloodlust") {}
+    };
+
+    class MaelstromWeaponTrigger : public HasAuraTrigger
+    {
+    public:
+        MaelstromWeaponTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "maelstrom weapon") {}
+    };
+
+    class WindShearInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        WindShearInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
new file mode 100644
index 0000000..e23c97d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "TotemsShamanStrategy.h"
+
+using namespace ai;
+
+TotemsShamanStrategy::TotemsShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+}
+
+void TotemsShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "windfury totem",
+        NextAction::array(0, new NextAction("windfury totem", 16.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mana spring totem",
+        NextAction::array(0, new NextAction("mana spring totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "strength of earth totem",
+        NextAction::array(0, new NextAction("strength of earth totem", 18.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flametongue totem",
+        NextAction::array(0, new NextAction("flametongue totem", 17.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
new file mode 100644
index 0000000..978fa26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class TotemsShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        TotemsShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "totems"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
new file mode 100644
index 0000000..0e43d16
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class ChatCommandTrigger : public Trigger {
+    public:
+        ChatCommandTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(string param, Player* owner = NULL)
+        {
+            this->param = param;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), param, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+   private:
+        string param;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
new file mode 100644
index 0000000..239e0ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
@@ -0,0 +1,140 @@
+#pragma once
+
+#include "ChatCommandTrigger.h"
+
+namespace ai
+{
+    class ChatTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        ChatTriggerContext()
+        {
+            creators["quests"] = &ChatTriggerContext::quests;
+            creators["stats"] = &ChatTriggerContext::stats;
+            creators["leave"] = &ChatTriggerContext::leave;
+            creators["rep"] = &ChatTriggerContext::reputation;
+            creators["reputation"] = &ChatTriggerContext::reputation;
+            creators["log"] = &ChatTriggerContext::log;
+            creators["los"] = &ChatTriggerContext::los;
+            creators["drop"] = &ChatTriggerContext::drop;
+            creators["q"] = &ChatTriggerContext::q;
+            creators["ll"] = &ChatTriggerContext::ll;
+            creators["loot all"] = &ChatTriggerContext::loot_all;
+            creators["add all loot"] = &ChatTriggerContext::loot_all;
+            creators["release"] = &ChatTriggerContext::release;
+            creators["teleport"] = &ChatTriggerContext::teleport;
+            creators["taxi"] = &ChatTriggerContext::taxi;
+            creators["repair"] = &ChatTriggerContext::repair;
+            creators["u"] = &ChatTriggerContext::use;
+            creators["use"] = &ChatTriggerContext::use;
+            creators["c"] = &ChatTriggerContext::item_count;
+            creators["e"] = &ChatTriggerContext::equip;
+            creators["ue"] = &ChatTriggerContext::uneqip;
+            creators["s"] = &ChatTriggerContext::sell;
+            creators["b"] = &ChatTriggerContext::buy;
+            creators["r"] = &ChatTriggerContext::reward;
+            creators["t"] = &ChatTriggerContext::trade;
+            creators["nt"] = &ChatTriggerContext::nontrade;
+            creators["talents"] = &ChatTriggerContext::talents;
+            creators["spells"] = &ChatTriggerContext::spells;
+            creators["co"] = &ChatTriggerContext::co;
+            creators["nc"] = &ChatTriggerContext::nc;
+            creators["dead"] = &ChatTriggerContext::dead;
+            creators["trainer"] = &ChatTriggerContext::trainer;
+            creators["attack"] = &ChatTriggerContext::attack;
+            creators["chat"] = &ChatTriggerContext::chat;
+            creators["accept"] = &ChatTriggerContext::accept;
+            creators["home"] = &ChatTriggerContext::home;
+            creators["reset ai"] = &ChatTriggerContext::reset_ai;
+            creators["destroy"] = &ChatTriggerContext::destroy;
+            creators["emote"] = &ChatTriggerContext::emote;
+            creators["buff"] = &ChatTriggerContext::buff;
+            creators["help"] = &ChatTriggerContext::help;
+            creators["gb"] = &ChatTriggerContext::gb;
+            creators["bank"] = &ChatTriggerContext::bank;
+            creators["follow"] = &ChatTriggerContext::follow;
+            creators["stay"] = &ChatTriggerContext::stay;
+            creators["flee"] = &ChatTriggerContext::flee;
+            creators["grind"] = &ChatTriggerContext::grind;
+            creators["tank attack"] = &ChatTriggerContext::tank_attack;
+            creators["talk"] = &ChatTriggerContext::talk;
+            creators["cast"] = &ChatTriggerContext::talk;
+            creators["invite"] = &ChatTriggerContext::invite;
+            creators["spell"] = &ChatTriggerContext::spell;
+            creators["rti"] = &ChatTriggerContext::rti;
+            creators["revive"] = &ChatTriggerContext::revive;
+            creators["runaway"] = &ChatTriggerContext::runaway;
+            creators["warning"] = &ChatTriggerContext::warning;
+            creators["position"] = &ChatTriggerContext::position;
+            creators["summon"] = &ChatTriggerContext::summon;
+            creators["who"] = &ChatTriggerContext::who;
+            creators["save mana"] = &ChatTriggerContext::save_mana;
+            creators["max dps"] = &ChatTriggerContext::max_dps;
+            creators["attackers"] = &ChatTriggerContext::attackers;
+            creators["formation"] = &ChatTriggerContext::formation;
+        }
+
+    private:
+        static Trigger* formation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "formation"); }
+        static Trigger* attackers(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attackers"); }
+        static Trigger* max_dps(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "max dps"); }
+        static Trigger* save_mana(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "save mana"); }
+        static Trigger* who(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "who"); }
+        static Trigger* summon(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "summon"); }
+        static Trigger* position(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "position"); }
+        static Trigger* runaway(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "runaway"); }
+        static Trigger* warning(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "warning"); }
+        static Trigger* revive(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "revive"); }
+        static Trigger* rti(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "rti"); }
+        static Trigger* invite(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "invite"); }
+        static Trigger* cast(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "cast"); }
+        static Trigger* talk(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talk"); }
+        static Trigger* flee(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "flee"); }
+        static Trigger* grind(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "grind"); }
+        static Trigger* tank_attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "tank attack"); }
+        static Trigger* stay(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stay"); }
+        static Trigger* follow(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "follow"); }
+        static Trigger* gb(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "gb"); }
+        static Trigger* bank(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "bank"); }
+        static Trigger* help(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "help"); }
+        static Trigger* buff(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "buff"); }
+        static Trigger* emote(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "emote"); }
+        static Trigger* destroy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "destroy"); }
+        static Trigger* home(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "home"); }
+        static Trigger* accept(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "accept"); }
+        static Trigger* chat(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "chat"); }
+        static Trigger* attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attack"); }
+        static Trigger* trainer(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "trainer"); }
+        static Trigger* co(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "co"); }
+        static Trigger* nc(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nc"); }
+        static Trigger* dead(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "dead"); }
+        static Trigger* spells(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spells"); }
+        static Trigger* talents(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talents"); }
+        static Trigger* equip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "e"); }
+        static Trigger* uneqip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ue"); }
+        static Trigger* sell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "s"); }
+        static Trigger* buy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "b"); }
+        static Trigger* reward(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "r"); }
+        static Trigger* trade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "t"); }
+        static Trigger* nontrade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nt"); }
+
+        static Trigger* item_count(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "c"); }
+        static Trigger* use(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "use"); }
+        static Trigger* repair(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "repair"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "taxi"); }
+        static Trigger* teleport(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "teleport"); }
+        static Trigger* q(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "q"); }
+        static Trigger* ll(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ll"); }
+        static Trigger* drop(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "drop"); }
+        static Trigger* quests(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "quests"); }
+        static Trigger* stats(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stats"); }
+        static Trigger* leave(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "leave"); }
+        static Trigger* reputation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reputation"); }
+        static Trigger* log(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "log"); }
+        static Trigger* los(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "los"); }
+        static Trigger* loot_all(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "add all loot"); }
+        static Trigger* release(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "release"); }
+        static Trigger* reset_ai(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reset ai"); }
+        static Trigger* spell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spell"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
new file mode 100644
index 0000000..1715234
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "CureTriggers.h"
+
+using namespace ai;
+
+bool NeedCureTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return target && ai->HasAuraToDispel(target, dispelType);
+}
+
+Value<Unit*>* PartyMemberNeedCureTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.h b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
new file mode 100644
index 0000000..8fd07f5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Trigger.h"
+
+namespace ai
+{
+	class SpellTrigger;
+
+    class NeedCureTrigger : public SpellTrigger {
+    public:
+        NeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : SpellTrigger(ai, spell)
+  	    {
+			this->dispelType = dispelType;
+        }
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+
+    protected:
+        uint32 dispelType;
+    };
+
+    class TargetAuraDispelTrigger : public NeedCureTrigger {
+    public:
+        TargetAuraDispelTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) :
+			NeedCureTrigger(ai, spell, dispelType) {}
+		virtual string GetTargetName() { return "current target"; }
+    };
+
+    class PartyMemberNeedCureTrigger : public NeedCureTrigger {
+    public:
+        PartyMemberNeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) :
+            NeedCureTrigger(ai, spell, dispelType) {}
+
+		virtual Value<Unit*>* GetTargetValue();
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
new file mode 100644
index 0000000..787e157
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
@@ -0,0 +1,245 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool LowManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+}
+
+bool MediumManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.mediumMana;
+}
+
+
+bool RageAvailable::IsActive()
+{
+    return AI_VALUE2(uint8, "rage", "self target") >= amount;
+}
+
+bool EnergyAvailable::IsActive()
+{
+	return AI_VALUE2(uint8, "energy", "self target") >= amount;
+}
+
+bool ComboPointsAvailableTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "combo", "current target") >= amount;
+}
+
+bool LoseAggroTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool HasAggroTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool PanicTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.criticalHealth &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana);
+}
+
+bool BuffTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+	return SpellTrigger::IsActive() &&
+		!ai->HasAura(spell, target) &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.lowMana);
+}
+
+Value<Unit*>* BuffOnPartyTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member without aura", spell);
+}
+
+Value<Unit*>* DebuffOnAttackerTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("attacker without aura", spell);
+}
+
+bool NoAttackersTrigger::IsActive()
+{
+    return !AI_VALUE(Unit*, "current target") && AI_VALUE(uint8, "attacker count") > 0;
+}
+
+bool InvalidTargetTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "invalid target", "current target");
+}
+
+bool NoTargetTrigger::IsActive()
+{
+	return !AI_VALUE(Unit*, "current target");
+}
+
+bool MyAttackerCountTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "my attacker count") >= amount;
+}
+
+bool AoeTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") >= amount;
+}
+
+bool DebuffTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE2(uint8, "health", "current target") > 25;
+}
+
+bool SpellTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool SpellCanBeCastTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return target && ai->CanCastSpell(spell, target);
+}
+
+bool RandomTrigger::IsActive()
+{
+    int vl  = rand() % (int)(1 + probability * 10 / sPlayerbotAIConfig.randomChangeMultiplier);
+    return vl == 0;
+}
+
+bool AndTrigger::IsActive()
+{
+    return ls->IsActive() && rs->IsActive();
+}
+
+string AndTrigger::getName()
+{
+    std::string name(ls->getName());
+    name = name + " and ";
+    name = name + rs->getName();
+    return name;
+}
+
+bool BoostTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE(uint8, "balance") <= balance;
+}
+
+bool SnareTargetTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return DebuffTrigger::IsActive() && AI_VALUE2(bool, "moving", "current target") && !ai->HasAura(spell, target);
+}
+
+bool ItemCountTrigger::IsActive()
+{
+	return AI_VALUE2(uint8, "item count", item) < count;
+}
+
+bool InterruptSpellTrigger::IsActive()
+{
+	return SpellTrigger::IsActive() && ai->IsInterruptableSpellCasting(GetTarget(), getName());
+}
+
+bool HasAuraTrigger::IsActive()
+{
+	return ai->HasAura(getName(), GetTarget());
+}
+
+bool TankAoeTrigger::IsActive()
+{
+    if (!AI_VALUE(uint8, "attacker count"))
+        return false;
+
+    Unit* currentTarget = AI_VALUE(Unit*, "current target");
+    if (!currentTarget)
+        return true;
+
+    Unit* tankTarget = AI_VALUE(Unit*, "tank target");
+    if (!tankTarget || currentTarget == tankTarget)
+        return false;
+
+    return currentTarget->GetVictim() == AI_VALUE(Unit*, "self target");
+}
+
+bool IsBehindTargetTrigger::IsActive()
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(bool, "behind", "current target");
+}
+
+bool IsNotFacingTargetTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
+
+bool HasCcTargetTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") > 2 && AI_VALUE2(Unit*, "cc target", getName()) &&
+        !AI_VALUE2(Unit*, "current cc target", getName());
+}
+
+bool NoMovementTrigger::IsActive()
+{
+	return !AI_VALUE2(bool, "moving", "self target");
+}
+
+bool NoPossibleTargetsTrigger::IsActive()
+{
+    // FEYZEE: bots join LFG when they are not in combat
+    //list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "possible targets");
+    //return !targets.size();
+    //return !bot->IsInCombat();
+    return 1;
+}
+
+bool NotLeastHpTargetActiveTrigger::IsActive()
+{
+    Unit* leastHp = AI_VALUE(Unit*, "least hp target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return leastHp && target != leastHp;
+}
+
+bool EnemyPlayerIsAttacking::IsActive()
+{
+    Unit* enemyPlayer = AI_VALUE(Unit*, "enemy player target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return enemyPlayer && target != enemyPlayer;
+}
+
+bool IsSwimmingTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "swimming", "self target");
+}
+
+bool HasNearestAddsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "nearest adds");
+    return targets.size();
+}
+
+bool HasItemForSpellTrigger::IsActive()
+{
+	string spell = getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+
+bool TargetChangedTrigger::IsActive()
+{
+    Unit* oldTarget = context->GetValue<Unit*>("old target")->Get();
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    return target && oldTarget != target;
+}
+
+Value<Unit*>* InterruptEnemyHealerTrigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>("enemy healer target", spell);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.h b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
new file mode 100644
index 0000000..f176429
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
@@ -0,0 +1,540 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffTrigger(ai, spell) {} \
+    };
+
+#define BUFF_ON_PARTY_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffOnPartyTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, spell) {}  \
+    };
+
+#define DEBUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public DebuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : DebuffTrigger(ai, spell) {} \
+    };
+
+namespace ai
+{
+	class StatAvailable : public Trigger
+	{
+	public:
+		StatAvailable(PlayerbotAI* ai, int amount, string name = "stat available") : Trigger(ai, name)
+		{
+			this->amount = amount;
+		}
+
+	protected:
+		int amount;
+	};
+
+	class RageAvailable : public StatAvailable
+    {
+    public:
+        RageAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "rage available") {}
+        virtual bool IsActive();
+    };
+
+    class LightRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        LightRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 20) {}
+    };
+
+    class MediumRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        MediumRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 40) {}
+    };
+
+    class HighRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        HighRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 60) {}
+    };
+
+	class EnergyAvailable : public StatAvailable
+	{
+	public:
+		EnergyAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "energy available") {}
+		virtual bool IsActive();
+	};
+
+    class LightEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        LightEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 20) {}
+    };
+
+    class MediumEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        MediumEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 40) {}
+    };
+
+    class HighEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        HighEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 60) {}
+    };
+
+	class ComboPointsAvailableTrigger : public StatAvailable
+	{
+	public:
+	    ComboPointsAvailableTrigger(PlayerbotAI* ai, int amount = 5) : StatAvailable(ai, amount, "combo points available") {}
+		virtual bool IsActive();
+	};
+
+	class LoseAggroTrigger : public Trigger {
+	public:
+		LoseAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "lose aggro") {}
+		virtual bool IsActive();
+	};
+
+	class HasAggroTrigger : public Trigger {
+	public:
+	    HasAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "have aggro") {}
+		virtual bool IsActive();
+	};
+
+	class SpellTrigger : public Trigger
+	{
+	public:
+		SpellTrigger(PlayerbotAI* ai, string spell, int checkInterval = 1) : Trigger(ai, spell, checkInterval)
+		{
+			this->spell = spell;
+		}
+
+		virtual string GetTargetName() { return "current target"; }
+		virtual string getName() { return spell; }
+		virtual bool IsActive();
+
+	protected:
+		string spell;
+	};
+
+	class SpellCanBeCastTrigger : public SpellTrigger
+	{
+	public:
+		SpellCanBeCastTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+		virtual bool IsActive();
+	};
+
+	// TODO: check other targets
+    class InterruptSpellTrigger : public SpellTrigger
+	{
+    public:
+        InterruptSpellTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+        virtual bool IsActive();
+    };
+
+
+    class AttackerCountTrigger : public Trigger
+    {
+    public:
+        AttackerCountTrigger(PlayerbotAI* ai, int amount, float distance = sPlayerbotAIConfig.sightDistance) : Trigger(ai)
+        {
+            this->amount = amount;
+            this->distance = distance;
+        }
+    public:
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= amount;
+        }
+        virtual string getName() { return "attacker count"; }
+
+    protected:
+        int amount;
+        float distance;
+    };
+
+    class HasAttackersTrigger : public AttackerCountTrigger
+    {
+    public:
+        HasAttackersTrigger(PlayerbotAI* ai) : AttackerCountTrigger(ai, 1) {}
+    };
+
+    class MyAttackerCountTrigger : public AttackerCountTrigger
+    {
+    public:
+        MyAttackerCountTrigger(PlayerbotAI* ai, int amount) : AttackerCountTrigger(ai, amount) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "my attacker count"; }
+    };
+
+    class MediumThreatTrigger : public MyAttackerCountTrigger
+    {
+    public:
+        MediumThreatTrigger(PlayerbotAI* ai) : MyAttackerCountTrigger(ai, 2) {}
+    };
+
+    class AoeTrigger : public AttackerCountTrigger
+    {
+    public:
+        AoeTrigger(PlayerbotAI* ai, int amount = 3, float range = 15.0f) : AttackerCountTrigger(ai, amount)
+        {
+            this->range = range;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "aoe"; }
+
+    private:
+        float range;
+    };
+
+    class NoFoodTrigger : public Trigger {
+    public:
+        NoFoodTrigger(PlayerbotAI* ai) : Trigger(ai, "no food trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "food").empty(); }
+    };
+
+    class NoDrinkTrigger : public Trigger {
+    public:
+        NoDrinkTrigger(PlayerbotAI* ai) : Trigger(ai, "no drink trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "drink").empty(); }
+    };
+
+    class LightAoeTrigger : public AoeTrigger
+    {
+    public:
+        LightAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 2, 15.0f) {}
+    };
+
+    class MediumAoeTrigger : public AoeTrigger
+    {
+    public:
+        MediumAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 3, 17.0f) {}
+    };
+
+    class HighAoeTrigger : public AoeTrigger
+    {
+    public:
+        HighAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 4, 20.0f) {}
+    };
+
+    class BuffTrigger : public SpellTrigger
+    {
+    public:
+        BuffTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell, 5) {}
+    public:
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class BuffOnPartyTrigger : public BuffTrigger
+    {
+    public:
+        BuffOnPartyTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+    };
+
+    BEGIN_TRIGGER(NoAttackersTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(NoTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(InvalidTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    class TargetInSightTrigger : public Trigger {
+    public:
+        TargetInSightTrigger(PlayerbotAI* ai) : Trigger(ai, "target in sight") {}
+        virtual bool IsActive() { return AI_VALUE(Unit*, "grind target"); }
+    };
+
+    class DebuffTrigger : public BuffTrigger
+    {
+    public:
+        DebuffTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {
+			checkInterval = 1;
+		}
+    public:
+		virtual string GetTargetName() { return "current target"; }
+        virtual bool IsActive();
+    };
+
+    class DebuffOnAttackerTrigger : public DebuffTrigger
+    {
+    public:
+        DebuffOnAttackerTrigger(PlayerbotAI* ai, string spell) : DebuffTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on attacker"; }
+    };
+
+	class BoostTrigger : public BuffTrigger
+	{
+	public:
+		BoostTrigger(PlayerbotAI* ai, string spell, float balance = 50) : BuffTrigger(ai, spell)
+		{
+			this->balance = balance;
+		}
+	public:
+		virtual bool IsActive();
+
+	protected:
+		float balance;
+	};
+
+    class RandomTrigger : public Trigger
+    {
+    public:
+        RandomTrigger(PlayerbotAI* ai, int probability = 200) : Trigger(ai)
+        {
+            this->probability = probability;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "random"; }
+
+    protected:
+        int probability;
+    };
+
+    class SeldomTrigger : public RandomTrigger
+    {
+    public:
+        SeldomTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 9000) {}
+        virtual string getName() { return "seldom"; }
+    };
+
+    class OftenTrigger : public RandomTrigger
+    {
+    public:
+        OftenTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 50) {}
+        virtual string getName() { return "often"; }
+    };
+
+    class AndTrigger : public Trigger
+    {
+    public:
+        AndTrigger(PlayerbotAI* ai, Trigger* ls, Trigger* rs) : Trigger(ai)
+        {
+            this->ls = ls;
+            this->rs = rs;
+        }
+        virtual ~AndTrigger()
+        {
+            delete ls;
+            delete rs;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName();
+
+    protected:
+        Trigger* ls;
+        Trigger* rs;
+    };
+
+    class SnareTargetTrigger : public DebuffTrigger
+    {
+    public:
+        SnareTargetTrigger(PlayerbotAI* ai, string aura) : DebuffTrigger(ai, aura) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "target is moving"; }
+    };
+
+	class LowManaTrigger : public Trigger
+	{
+	public:
+		LowManaTrigger(PlayerbotAI* ai) : Trigger(ai, "low mana") {}
+
+		virtual bool IsActive();
+	};
+
+	class MediumManaTrigger : public Trigger
+	{
+	public:
+		MediumManaTrigger(PlayerbotAI* ai) : Trigger(ai, "medium mana") {}
+
+		virtual bool IsActive();
+	};
+
+    BEGIN_TRIGGER(PanicTrigger, Trigger)
+        virtual string getName() { return "panic"; }
+    END_TRIGGER()
+
+
+	class NoPetTrigger : public Trigger
+	{
+	public:
+		NoPetTrigger(PlayerbotAI* ai) : Trigger(ai, "no pet", 5) {}
+
+		virtual bool IsActive() {
+			return !AI_VALUE(Unit*, "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+		}
+	};
+
+	class ItemCountTrigger : public Trigger {
+	public:
+		ItemCountTrigger(PlayerbotAI* ai, string item, int count) : Trigger(ai, item, 5) {
+			this->item = item;
+			this->count = count;
+		}
+	public:
+		virtual bool IsActive();
+		virtual string getName() { return "item count"; }
+
+	protected:
+		string item;
+		int count;
+	};
+
+	class HasAuraTrigger : public Trigger {
+	public:
+		HasAuraTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell, 5) {}
+
+		virtual string GetTargetName() { return "self target"; }
+		virtual bool IsActive();
+
+	};
+
+    class TimerTrigger : public Trigger
+    {
+    public:
+        TimerTrigger(PlayerbotAI* ai, int checkInterval = 5) : Trigger(ai, "timer", checkInterval) {}
+
+    public:
+        virtual bool IsActive() { return true; }
+    };
+
+	class TankAoeTrigger : public NoAttackersTrigger
+	{
+	public:
+		TankAoeTrigger(PlayerbotAI* ai) : NoAttackersTrigger(ai) {}
+
+	public:
+		virtual bool IsActive();
+
+	};
+
+    class IsBehindTargetTrigger : public Trigger
+    {
+    public:
+        IsBehindTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsNotFacingTargetTrigger : public Trigger
+    {
+    public:
+        IsNotFacingTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasCcTargetTrigger : public Trigger
+    {
+    public:
+        HasCcTargetTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+	class NoMovementTrigger : public Trigger
+	{
+	public:
+		NoMovementTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+	public:
+		virtual bool IsActive();
+	};
+
+
+    class NoPossibleTargetsTrigger : public Trigger
+    {
+    public:
+        NoPossibleTargetsTrigger(PlayerbotAI* ai) : Trigger(ai, "no possible targets") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class NotLeastHpTargetActiveTrigger : public Trigger
+    {
+    public:
+        NotLeastHpTargetActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "not least hp target active") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class EnemyPlayerIsAttacking : public Trigger
+    {
+    public:
+        EnemyPlayerIsAttacking(PlayerbotAI* ai) : Trigger(ai, "enemy player is attacking") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsSwimmingTrigger : public Trigger
+    {
+    public:
+        IsSwimmingTrigger(PlayerbotAI* ai) : Trigger(ai, "swimming") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasNearestAddsTrigger : public Trigger
+    {
+    public:
+        HasNearestAddsTrigger(PlayerbotAI* ai) : Trigger(ai, "has nearest adds") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasItemForSpellTrigger : public Trigger
+    {
+    public:
+        HasItemForSpellTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class TargetChangedTrigger : public Trigger
+    {
+    public:
+        TargetChangedTrigger(PlayerbotAI* ai) : Trigger(ai, "target changed") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class InterruptEnemyHealerTrigger : public SpellTrigger
+    {
+    public:
+        InterruptEnemyHealerTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+
+}
+
+#include "RangeTriggers.h"
+#include "HealthTriggers.h"
+#include "CureTriggers.h"
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
new file mode 100644
index 0000000..703f00c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HealthTriggers.h"
+
+using namespace ai;
+
+float HealthInRangeTrigger::GetValue()
+{
+    return AI_VALUE2(uint8, "health", GetTargetName());
+}
+
+bool PartyMemberDeadTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool DeadTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "dead", GetTargetName());
+}
+
+bool AoeHealTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "aoe heal", type) >= count;
+}
+
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.h b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
new file mode 100644
index 0000000..49dc17b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
@@ -0,0 +1,139 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ValueInRangeTrigger : public Trigger
+    {
+    public:
+        ValueInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue) : Trigger(ai, name) {
+            this->maxValue = maxValue;
+            this->minValue = minValue;
+        }
+    public:
+        virtual float GetValue() = 0;
+        virtual bool IsActive() {
+            float value = GetValue();
+            return value < maxValue && value >= minValue;
+        }
+
+    protected:
+        float maxValue, minValue;
+    };
+
+	class HealthInRangeTrigger : public ValueInRangeTrigger
+	{
+	public:
+		HealthInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue = 0) :
+		  ValueInRangeTrigger(ai, name, maxValue, minValue) {}
+
+		virtual bool IsActive()
+		{
+		    return ValueInRangeTrigger::IsActive() && !AI_VALUE2(bool, "dead", GetTargetName());
+		}
+
+		virtual float GetValue();
+	};
+
+    class LowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        LowHealthTrigger(PlayerbotAI* ai, string name = "low health",
+            float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+		virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CriticalHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        CriticalHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class MediumHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        MediumHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "medium health", sPlayerbotAIConfig.mediumHealth, sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class AlmostFullHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        AlmostFullHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "almost full health", sPlayerbotAIConfig.almostFullHealth, sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class PartyMemberLowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        PartyMemberLowHealthTrigger(PlayerbotAI* ai, string name = "party member low health", float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class PartyMemberCriticalHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberCriticalHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class PartyMemberMediumHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberMediumHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member medium health", sPlayerbotAIConfig.mediumHealth,sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class PartyMemberAlmostFullHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberAlmostFullHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member almost full health", sPlayerbotAIConfig.almostFullHealth,sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class TargetLowHealthTrigger : public HealthInRangeTrigger {
+    public:
+        TargetLowHealthTrigger(PlayerbotAI* ai, float value, float minValue = 0) :
+            HealthInRangeTrigger(ai, "target low health", value, minValue) {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class TargetCriticalHealthTrigger : public TargetLowHealthTrigger
+    {
+    public:
+        TargetCriticalHealthTrigger(PlayerbotAI* ai) : TargetLowHealthTrigger(ai, 20) {}
+    };
+
+	class PartyMemberDeadTrigger : public Trigger {
+	public:
+		PartyMemberDeadTrigger(PlayerbotAI* ai) : Trigger(ai, "resurrect", 10) {}
+        virtual string GetTargetName() { return "party member to resurrect"; }
+		virtual bool IsActive();
+	};
+
+    class DeadTrigger : public Trigger {
+    public:
+        DeadTrigger(PlayerbotAI* ai) : Trigger(ai, "dead", 10) {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class AoeHealTrigger : public Trigger {
+    public:
+    	AoeHealTrigger(PlayerbotAI* ai, string name, string type, int count) :
+    		Trigger(ai, name), type(type), count(count) {}
+    public:
+        virtual bool IsActive();
+
+    protected:
+        int count;
+        string type;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LfgTriggers.h b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
new file mode 100644
index 0000000..ec8133e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+class LfgProposalActiveTrigger : public Trigger
+{
+public:
+    LfgProposalActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "lfg proposal active", 5) {}
+
+    virtual bool IsActive()
+    {
+        return AI_VALUE(uint32, "lfg proposal");
+    }
+};
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
new file mode 100644
index 0000000..cac9b60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootTriggers.h"
+
+using namespace ai;
+
+bool LootAvailableTrigger::IsActive()
+{
+    return AI_VALUE(bool, "has available loot") && AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool FarFromCurrentLootTrigger::IsActive()
+{
+    return AI_VALUE2(float, "distance", "loot target") > INTERACTION_DISTANCE;
+}
+
+bool CanLootTrigger::IsActive()
+{
+    return AI_VALUE(bool, "can loot");
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.h b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
new file mode 100644
index 0000000..063456b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
@@ -0,0 +1,30 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class LootAvailableTrigger : public Trigger
+    {
+    public:
+        LootAvailableTrigger(PlayerbotAI* ai) : Trigger(ai, "loot available") {}
+
+        virtual bool IsActive();
+    };
+
+    class FarFromCurrentLootTrigger : public Trigger
+    {
+    public:
+        FarFromCurrentLootTrigger(PlayerbotAI* ai) : Trigger(ai, "far from current loot") {}
+
+        virtual bool IsActive();
+    };
+
+    class CanLootTrigger : public Trigger
+    {
+    public:
+        CanLootTrigger(PlayerbotAI* ai) : Trigger(ai, "can loot") {}
+
+        virtual bool IsActive();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/RangeTriggers.h b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
new file mode 100644
index 0000000..08aba8f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class EnemyTooCloseForSpellTrigger : public Trigger {
+    public:
+        EnemyTooCloseForSpellTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for spell") {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.spellDistance / 2;
+        }
+    };
+
+    class EnemyTooCloseForMeleeTrigger : public Trigger {
+    public:
+        EnemyTooCloseForMeleeTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for melee", 5) {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+        }
+    };
+
+    class OutOfRangeTrigger : public Trigger {
+    public:
+        OutOfRangeTrigger(PlayerbotAI* ai, string name, float distance) : Trigger(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, GetTargetName());
+			return target && AI_VALUE2(float, "distance", GetTargetName()) > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class EnemyOutOfMeleeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfMeleeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of melee range", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class EnemyOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of spell range", sPlayerbotAIConfig.spellDistance) {}
+    };
+
+    class PartyMemberToHealOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        PartyMemberToHealOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "party member to heal out of spell range", sPlayerbotAIConfig.spellDistance) {}
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class FarFromMasterTrigger : public Trigger {
+    public:
+        FarFromMasterTrigger(PlayerbotAI* ai, string name = "far from master", float distance = 12.0f, int checkInterval = 1) : Trigger(ai, name, checkInterval), distance(distance) {}
+
+        virtual bool IsActive()
+        {
+            return AI_VALUE2(float, "distance", "master target") > distance;
+        }
+
+    private:
+        float distance;
+    };
+
+    class OutOfReactRangeTrigger : public FarFromMasterTrigger
+    {
+    public:
+        OutOfReactRangeTrigger(PlayerbotAI* ai) : FarFromMasterTrigger(ai, "out of react range", sPlayerbotAIConfig.reactDistance / 2, 10) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/TriggerContext.h b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
new file mode 100644
index 0000000..9906cae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "HealthTriggers.h"
+#include "GenericTriggers.h"
+#include "LootTriggers.h"
+#include "../triggers/GenericTriggers.h"
+#include "LfgTriggers.h"
+
+namespace ai
+{
+
+    class TriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        TriggerContext()
+        {
+            creators["timer"] = &TriggerContext::Timer;
+            creators["random"] = &TriggerContext::Random;
+            creators["seldom"] = &TriggerContext::seldom;
+            creators["often"] = &TriggerContext::often;
+
+            creators["target critical health"] = &TriggerContext::TargetCriticalHealth;
+
+            creators["critical health"] = &TriggerContext::CriticalHealth;
+            creators["low health"] = &TriggerContext::LowHealth;
+            creators["medium health"] = &TriggerContext::MediumHealth;
+            creators["almost full health"] = &TriggerContext::AlmostFullHealth;
+
+            creators["low mana"] = &TriggerContext::LowMana;
+            creators["medium mana"] = &TriggerContext::MediumMana;
+
+            creators["party member critical health"] = &TriggerContext::PartyMemberCriticalHealth;
+            creators["party member low health"] = &TriggerContext::PartyMemberLowHealth;
+            creators["party member medium health"] = &TriggerContext::PartyMemberMediumHealth;
+            creators["party member almost full health"] = &TriggerContext::PartyMemberAlmostFullHealth;
+
+            creators["light rage available"] = &TriggerContext::LightRageAvailable;
+            creators["medium rage available"] = &TriggerContext::MediumRageAvailable;
+            creators["high rage available"] = &TriggerContext::HighRageAvailable;
+
+            creators["light energy available"] = &TriggerContext::LightEnergyAvailable;
+            creators["medium energy available"] = &TriggerContext::MediumEnergyAvailable;
+            creators["high energy available"] = &TriggerContext::HighEnergyAvailable;
+
+            creators["loot available"] = &TriggerContext::LootAvailable;
+            creators["no attackers"] = &TriggerContext::NoAttackers;
+            creators["no target"] = &TriggerContext::NoTarget;
+            creators["target in sight"] = &TriggerContext::TargetInSight;
+            creators["not least hp target active"] = &TriggerContext::not_least_hp_target_active;
+            creators["has nearest adds"] = &TriggerContext::has_nearest_adds;
+            creators["enemy player is attacking"] = &TriggerContext::enemy_player_is_attacking;
+
+            creators["tank aoe"] = &TriggerContext::TankAoe;
+            creators["lose aggro"] = &TriggerContext::LoseAggro;
+            creators["has aggro"] = &TriggerContext::HasAggro;
+
+            creators["light aoe"] = &TriggerContext::LightAoe;
+            creators["medium aoe"] = &TriggerContext::MediumAoe;
+            creators["high aoe"] = &TriggerContext::HighAoe;
+
+            creators["enemy out of melee"] = &TriggerContext::EnemyOutOfMelee;
+            creators["enemy out of spell"] = &TriggerContext::EnemyOutOfSpell;
+            creators["enemy too close for spell"] = &TriggerContext::enemy_too_close_for_spell;
+            creators["enemy too close for melee"] = &TriggerContext::enemy_too_close_for_melee;
+
+            creators["combo points available"] = &TriggerContext::ComboPointsAvailable;
+
+            creators["medium threat"] = &TriggerContext::MediumThreat;
+
+            creators["dead"] = &TriggerContext::Dead;
+            creators["party member dead"] = &TriggerContext::PartyMemberDead;
+            creators["no pet"] = &TriggerContext::no_pet;
+            creators["has attackers"] = &TriggerContext::has_attackers;
+            creators["no possible targets"] = &TriggerContext::no_possible_targets;
+
+            creators["no drink"] = &TriggerContext::no_drink;
+            creators["no food"] = &TriggerContext::no_food;
+
+            creators["panic"] = &TriggerContext::panic;
+            creators["behind target"] = &TriggerContext::behind_target;
+            creators["not facing target"] = &TriggerContext::not_facing_target;
+            creators["far from master"] = &TriggerContext::far_from_master;
+            creators["far from loot target"] = &TriggerContext::far_from_loot_target;
+            creators["can loot"] = &TriggerContext::can_loot;
+            creators["swimming"] = &TriggerContext::swimming;
+            creators["target changed"] = &TriggerContext::target_changed;
+
+            creators["critical aoe heal"] = &TriggerContext::critical_aoe_heal;
+            creators["low aoe heal"] = &TriggerContext::low_aoe_heal;
+            creators["medium aoe heal"] = &TriggerContext::medium_aoe_heal;
+            creators["invalid target"] = &TriggerContext::invalid_target;
+            creators["lfg proposal active"] = &TriggerContext::lfg_proposal_active;
+        }
+
+    private:
+        static Trigger* lfg_proposal_active(PlayerbotAI* ai) { return new LfgProposalActiveTrigger(ai); }
+        static Trigger* invalid_target(PlayerbotAI* ai) { return new InvalidTargetTrigger(ai); }
+        static Trigger* critical_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "critical aoe heal", "critical", 2); }
+        static Trigger* low_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "low aoe heal", "low", 2); }
+        static Trigger* medium_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "medium aoe heal", "medium", 2); }
+        static Trigger* target_changed(PlayerbotAI* ai) { return new TargetChangedTrigger(ai); }
+        static Trigger* swimming(PlayerbotAI* ai) { return new IsSwimmingTrigger(ai); }
+        static Trigger* no_possible_targets(PlayerbotAI* ai) { return new NoPossibleTargetsTrigger(ai); }
+        static Trigger* can_loot(PlayerbotAI* ai) { return new CanLootTrigger(ai); }
+        static Trigger* far_from_loot_target(PlayerbotAI* ai) { return new FarFromCurrentLootTrigger(ai); }
+        static Trigger* far_from_master(PlayerbotAI* ai) { return new FarFromMasterTrigger(ai); }
+        static Trigger* behind_target(PlayerbotAI* ai) { return new IsBehindTargetTrigger(ai); }
+        static Trigger* not_facing_target(PlayerbotAI* ai) { return new IsNotFacingTargetTrigger(ai); }
+        static Trigger* panic(PlayerbotAI* ai) { return new PanicTrigger(ai); }
+        static Trigger* no_drink(PlayerbotAI* ai) { return new NoDrinkTrigger(ai); }
+        static Trigger* no_food(PlayerbotAI* ai) { return new NoFoodTrigger(ai); }
+        static Trigger* LightAoe(PlayerbotAI* ai) { return new LightAoeTrigger(ai); }
+        static Trigger* MediumAoe(PlayerbotAI* ai) { return new MediumAoeTrigger(ai); }
+        static Trigger* HighAoe(PlayerbotAI* ai) { return new HighAoeTrigger(ai); }
+        static Trigger* LoseAggro(PlayerbotAI* ai) { return new LoseAggroTrigger(ai); }
+        static Trigger* HasAggro(PlayerbotAI* ai) { return new HasAggroTrigger(ai); }
+        static Trigger* LowHealth(PlayerbotAI* ai) { return new LowHealthTrigger(ai); }
+        static Trigger* MediumHealth(PlayerbotAI* ai) { return new MediumHealthTrigger(ai); }
+        static Trigger* AlmostFullHealth(PlayerbotAI* ai) { return new AlmostFullHealthTrigger(ai); }
+        static Trigger* CriticalHealth(PlayerbotAI* ai) { return new CriticalHealthTrigger(ai); }
+        static Trigger* TargetCriticalHealth(PlayerbotAI* ai) { return new TargetCriticalHealthTrigger(ai); }
+        static Trigger* LowMana(PlayerbotAI* ai) { return new LowManaTrigger(ai); }
+        static Trigger* MediumMana(PlayerbotAI* ai) { return new MediumManaTrigger(ai); }
+        static Trigger* LightRageAvailable(PlayerbotAI* ai) { return new LightRageAvailableTrigger(ai); }
+        static Trigger* MediumRageAvailable(PlayerbotAI* ai) { return new MediumRageAvailableTrigger(ai); }
+        static Trigger* HighRageAvailable(PlayerbotAI* ai) { return new HighRageAvailableTrigger(ai); }
+        static Trigger* LightEnergyAvailable(PlayerbotAI* ai) { return new LightEnergyAvailableTrigger(ai); }
+        static Trigger* MediumEnergyAvailable(PlayerbotAI* ai) { return new MediumEnergyAvailableTrigger(ai); }
+        static Trigger* HighEnergyAvailable(PlayerbotAI* ai) { return new HighEnergyAvailableTrigger(ai); }
+        static Trigger* LootAvailable(PlayerbotAI* ai) { return new LootAvailableTrigger(ai); }
+        static Trigger* NoAttackers(PlayerbotAI* ai) { return new NoAttackersTrigger(ai); }
+        static Trigger* TankAoe(PlayerbotAI* ai) { return new TankAoeTrigger(ai); }
+        static Trigger* Timer(PlayerbotAI* ai) { return new TimerTrigger(ai); }
+        static Trigger* NoTarget(PlayerbotAI* ai) { return new NoTargetTrigger(ai); }
+        static Trigger* TargetInSight(PlayerbotAI* ai) { return new TargetInSightTrigger(ai); }
+        static Trigger* not_least_hp_target_active(PlayerbotAI* ai) { return new NotLeastHpTargetActiveTrigger(ai); }
+        static Trigger* has_nearest_adds(PlayerbotAI* ai) { return new HasNearestAddsTrigger(ai); }
+        static Trigger* enemy_player_is_attacking(PlayerbotAI* ai) { return new EnemyPlayerIsAttacking(ai); }
+        static Trigger* Random(PlayerbotAI* ai) { return new RandomTrigger(ai); }
+        static Trigger* seldom(PlayerbotAI* ai) { return new SeldomTrigger(ai); }
+        static Trigger* often(PlayerbotAI* ai) { return new OftenTrigger(ai); }
+        static Trigger* EnemyOutOfMelee(PlayerbotAI* ai) { return new EnemyOutOfMeleeTrigger(ai); }
+        static Trigger* EnemyOutOfSpell(PlayerbotAI* ai) { return new EnemyOutOfSpellRangeTrigger(ai); }
+        static Trigger* enemy_too_close_for_spell(PlayerbotAI* ai) { return new EnemyTooCloseForSpellTrigger(ai); }
+        static Trigger* enemy_too_close_for_melee(PlayerbotAI* ai) { return new EnemyTooCloseForMeleeTrigger(ai); }
+        static Trigger* ComboPointsAvailable(PlayerbotAI* ai) { return new ComboPointsAvailableTrigger(ai); }
+        static Trigger* MediumThreat(PlayerbotAI* ai) { return new MediumThreatTrigger(ai); }
+        static Trigger* Dead(PlayerbotAI* ai) { return new DeadTrigger(ai); }
+        static Trigger* PartyMemberDead(PlayerbotAI* ai) { return new PartyMemberDeadTrigger(ai); }
+        static Trigger* PartyMemberLowHealth(PlayerbotAI* ai) { return new PartyMemberLowHealthTrigger(ai); }
+        static Trigger* PartyMemberMediumHealth(PlayerbotAI* ai) { return new PartyMemberMediumHealthTrigger(ai); }
+        static Trigger* PartyMemberAlmostFullHealth(PlayerbotAI* ai) { return new PartyMemberAlmostFullHealthTrigger(ai); }
+        static Trigger* PartyMemberCriticalHealth(PlayerbotAI* ai) { return new PartyMemberCriticalHealthTrigger(ai); }
+        static Trigger* no_pet(PlayerbotAI* ai) { return new NoPetTrigger(ai); }
+        static Trigger* has_attackers(PlayerbotAI* ai) { return new HasAttackersTrigger(ai); }
+
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
new file mode 100644
index 0000000..01c130a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
@@ -0,0 +1,76 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class WithinAreaTrigger : public Trigger {
+    public:
+        WithinAreaTrigger(PlayerbotAI* ai) : Trigger(ai, "within area trigger") {}
+
+        virtual bool IsActive()
+		{
+
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            if (!movement.lastAreaTrigger)
+                return false;
+
+            AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(movement.lastAreaTrigger);
+            if(!atEntry)
+                return false;
+
+            AreaTrigger const* at = sObjectMgr->GetAreaTrigger(movement.lastAreaTrigger);
+            if (!at)
+                return false;
+
+            return IsPointInAreaTriggerZone(atEntry, bot->GetMapId(), bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), 0.5f);
+        }
+
+    private:
+        bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, float x, float y, float z, float delta)
+        {
+            if (mapid != atEntry->mapid)
+                return false;
+
+            if (atEntry->radius > 0)
+            {
+                // if we have radius check it
+                float dist2 = (x - atEntry->x) * (x - atEntry->x) + (y - atEntry->y) * (y - atEntry->y) + (z - atEntry->z) * (z - atEntry->z);
+                if (dist2 > (atEntry->radius + delta) * (atEntry->radius + delta))
+                    return false;
+            }
+            else
+            {
+                // we have only extent
+
+                // rotate the players position instead of rotating the whole cube, that way we can make a simplified
+                // is-in-cube check and we have to calculate only one point instead of 4
+
+                // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
+                double rotation = 2 * M_PI - atEntry->box_orientation;
+                double sinVal = sin(rotation);
+                double cosVal = cos(rotation);
+
+                float playerBoxDistX = x - atEntry->x;
+                float playerBoxDistY = y - atEntry->y;
+
+                float rotPlayerX = float(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY * sinVal);
+                float rotPlayerY = float(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX * sinVal);
+
+                // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
+                float dz = z - atEntry->z;
+                float dx = rotPlayerX - atEntry->x;
+                float dy = rotPlayerY - atEntry->y;
+                if ((fabs(dx) > atEntry->box_x / 2 + delta) ||
+                        (fabs(dy) > atEntry->box_y / 2 + delta) ||
+                        (fabs(dz) > atEntry->box_z / 2 + delta))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
new file mode 100644
index 0000000..b0f8b87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class WorldPacketTrigger : public Trigger {
+    public:
+        WorldPacketTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL)
+        {
+            this->packet = packet;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), packet, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+    private:
+        WorldPacket packet;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
new file mode 100644
index 0000000..e1bda4f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
@@ -0,0 +1,85 @@
+#pragma once
+
+#include "WorldPacketTrigger.h"
+#include "WithinAreaTrigger.h"
+
+namespace ai
+{
+    class WorldPacketTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        WorldPacketTriggerContext()
+        {
+            creators["gossip hello"] = &WorldPacketTriggerContext::gossip_hello;
+            creators["group invite"] = &WorldPacketTriggerContext::group_invite;
+            creators["group set leader"] = &WorldPacketTriggerContext::group_set_leader;
+            creators["not enough money"] = &WorldPacketTriggerContext::no_money;
+            creators["not enough reputation"] = &WorldPacketTriggerContext::no_reputation;
+            creators["cannot equip"] = &WorldPacketTriggerContext::cannot_equip;
+            creators["use game object"] = &WorldPacketTriggerContext::use_game_object;
+            creators["complete quest"] = &WorldPacketTriggerContext::complete_quest;
+            creators["accept quest"] = &WorldPacketTriggerContext::accept_quest;
+            creators["quest share"] = &WorldPacketTriggerContext::quest_share;
+            creators["loot roll"] = &WorldPacketTriggerContext::loot_roll;
+            creators["resurrect request"] = &WorldPacketTriggerContext::resurrect_request;
+            creators["area trigger"] = &WorldPacketTriggerContext::area_trigger;
+            creators["within area trigger"] = &WorldPacketTriggerContext::within_area_trigger;
+            creators["check mount state"] = &WorldPacketTriggerContext::check_mount_state;
+            creators["activate taxi"] = &WorldPacketTriggerContext::taxi;
+            creators["trade status"] = &WorldPacketTriggerContext::trade_status;
+            creators["loot response"] = &WorldPacketTriggerContext::loot_response;
+            creators["out of react range"] = &WorldPacketTriggerContext::out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketTriggerContext::quest_objective_completed;
+            creators["item push result"] = &WorldPacketTriggerContext::item_push_result;
+            creators["party command"] = &WorldPacketTriggerContext::party_command;
+            creators["taxi done"] = &WorldPacketTriggerContext::taxi_done;
+            creators["cast failed"] = &WorldPacketTriggerContext::cast_failed;
+            creators["duel requested"] = &WorldPacketTriggerContext::duel_requested;
+            creators["ready check"] = &WorldPacketTriggerContext::ready_check;
+            creators["ready check finished"] = &WorldPacketTriggerContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketTriggerContext::uninvite;
+            creators["lfg join"] = &WorldPacketTriggerContext::lfg_update;
+            creators["lfg proposal"] = &WorldPacketTriggerContext::lfg_proposal;
+            creators["lfg role check"] = &WorldPacketTriggerContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketTriggerContext::lfg_leave;
+            creators["guild invite"] = &WorldPacketTriggerContext::guild_invite;
+            creators["lfg teleport"] = &WorldPacketTriggerContext::lfg_teleport;
+        }
+
+    private:
+        static Trigger* guild_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "guild invite"); }
+        static Trigger* lfg_teleport(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg teleport"); }
+        static Trigger* lfg_leave(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg leave"); }
+        static Trigger* lfg_proposal(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg proposal"); }
+        static Trigger* lfg_role_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg role check"); }
+        static Trigger* lfg_update(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg join"); }
+        static Trigger* uninvite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "uninvite"); }
+        static Trigger* ready_check_finished(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check finished"); }
+        static Trigger* ready_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check"); }
+        static Trigger* duel_requested(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "duel requested"); }
+        static Trigger* cast_failed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cast failed"); }
+        static Trigger* taxi_done(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "taxi done"); }
+        static Trigger* party_command(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "party command"); }
+        static Trigger* item_push_result(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "item push result"); }
+        static Trigger* quest_objective_completed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest objective completed"); }
+        static Trigger* out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeTrigger(ai); }
+        static Trigger* loot_response(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot response"); }
+        static Trigger* trade_status(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "trade status"); }
+        static Trigger* cannot_equip(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cannot equip"); }
+        static Trigger* check_mount_state(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "check mount state"); }
+        static Trigger* area_trigger(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "area trigger"); }
+        static Trigger* within_area_trigger(PlayerbotAI* ai) { return new WithinAreaTrigger(ai); }
+        static Trigger* resurrect_request(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "resurrect request"); }
+        static Trigger* gossip_hello(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "gossip hello"); }
+        static Trigger* group_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group invite"); }
+        static Trigger* group_set_leader(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group set leader"); }
+        static Trigger* no_money(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough money"); }
+        static Trigger* no_reputation(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough reputation"); }
+        static Trigger* use_game_object(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "use game object"); }
+        static Trigger* complete_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "complete quest"); }
+        static Trigger* accept_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "accept quest"); }
+        static Trigger* quest_share(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest share"); }
+        static Trigger* loot_roll(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot roll"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "activate taxi"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
new file mode 100644
index 0000000..22c2f3a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AlwaysLootListValue : public ManualSetValue<set<uint32>&>
+	{
+	public:
+        AlwaysLootListValue(PlayerbotAI* ai) : ManualSetValue<set<uint32>&>(ai, list) {}
+
+    private:
+        set<uint32> list;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.cpp b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
new file mode 100644
index 0000000..14c50b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AoeHealValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 AoeHealValue::Calculate()
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+    	return 0;
+
+    float range = 0;
+    if (qualifier == "low")
+    	range = sPlayerbotAIConfig.lowHealth;
+    else if (qualifier == "medium")
+    	range = sPlayerbotAIConfig.mediumHealth;
+    else if (qualifier == "critical")
+    	range = sPlayerbotAIConfig.criticalHealth;
+
+    uint8 count = 0;
+	Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+	for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+	{
+		Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+		if( !player || !player->IsAlive())
+			continue;
+
+	    float percent = (static_cast<float> (player->GetHealth()) / player->GetMaxHealth()) * 100;
+	    if (percent <= range)
+	    	count++;
+	}
+
+	return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.h b/src/plugins/playerbot/strategy/values/AoeHealValues.h
new file mode 100644
index 0000000..d7d52c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AoeHealValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+    	AoeHealValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
new file mode 100644
index 0000000..a406a90
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
@@ -0,0 +1,107 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerCountValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 MyAttackerCountValue::Calculate()
+{
+    return bot->getAttackers().size();
+}
+
+bool HasAggroValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return true;
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true; // simulate as target is not atacking anybody yet
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == bot && target == attacker)
+            return true;
+        ref = ref->next();
+    }
+    return false;
+}
+
+uint8 AttackerCountValue::Calculate()
+{
+    int count = 0;
+    float range = sPlayerbotAIConfig.sightDistance;
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        float distance = bot->GetDistance(unit);
+        if (distance <= range)
+            count++;
+    }
+
+    return count;
+}
+
+uint8 BalancePercentValue::Calculate()
+{
+    float playerLevel = 0,
+        attackerLevel = 0;
+
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !player || !player->IsAlive())
+                continue;
+
+            playerLevel += player->getLevel();
+        }
+    }
+
+    list<ObjectGuid> v = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+
+    for (list<ObjectGuid>::iterator i = v.begin(); i!=v.end(); i++)
+    {
+        Creature* creature = ai->GetCreature((*i));
+        if (!creature || !creature->IsAlive())
+            continue;
+
+        uint32 level = creature->getLevel();
+
+        switch (creature->GetCreatureTemplate()->rank) {
+        case CREATURE_ELITE_RARE:
+            level *= 2;
+            break;
+        case CREATURE_ELITE_ELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_RAREELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_WORLDBOSS:
+            level *= 5;
+            break;
+        }
+        attackerLevel += level;
+    }
+
+    if (!attackerLevel)
+        return 100;
+
+    float percent = playerLevel * 100 / attackerLevel;
+    return percent <= 200 ? (uint8)percent : 200;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.h b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
new file mode 100644
index 0000000..9c77a3f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
@@ -0,0 +1,59 @@
+#pragma once
+#include "StatsValues.h"
+
+namespace ai
+{
+
+    class AttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        AttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class MyAttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        MyAttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasAggroValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasAggroValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class BalancePercentValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        BalancePercentValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
new file mode 100644
index 0000000..10da8d2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* AttackerWithoutAuraTargetValue::Calculate()
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->HasAura(qualifier, unit))
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
new file mode 100644
index 0000000..70a8983
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AttackerWithoutAuraTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        AttackerWithoutAuraTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "attacker without aura") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.cpp b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
new file mode 100644
index 0000000..e24f99d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
@@ -0,0 +1,94 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackersValue.h"
+
+#include "../../../../server/game/Entities/Pet/Pet.h"
+
+using namespace ai;
+
+list<ObjectGuid> AttackersValue::Calculate()
+{
+    set<Unit*> targets;
+
+    AddAttackersOf(bot, targets);
+
+    Group* group = bot->GetGroup();
+    if (group)
+        AddAttackersOf(group, targets);
+
+    RemoveNonThreating(targets);
+
+    list<ObjectGuid> result;
+	for (set<Unit*>::iterator i = targets.begin(); i != targets.end(); i++)
+		result.push_back((*i)->GetGUID());
+
+    if (bot->duel && bot->duel->opponent)
+        result.push_back(bot->duel->opponent->GetGUID());
+
+	return result;
+}
+
+void AttackersValue::AddAttackersOf(Group* group, set<Unit*>& targets)
+{
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if (!member || !member->IsAlive() || member == bot)
+            continue;
+
+        if (member->IsBeingTeleported())
+            return;
+
+        AddAttackersOf(member, targets);
+
+        Pet* pet = member->GetPet();
+        if (pet)
+            AddAttackersOf(pet, targets);
+    }
+}
+
+void AttackersValue::AddAttackersOf(Unit* unit, set<Unit*>& targets)
+{
+    HostileRefManager& refManager = unit->getHostileRefManager();
+    HostileReference *ref = refManager.getFirst();
+    if (!ref)
+        return;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == unit)
+            targets.insert(attacker);
+        ref = ref->next();
+    }
+}
+
+void AttackersValue::RemoveNonThreating(set<Unit*>& targets)
+{
+    for(set<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        Unit* unit = *tIter;
+        if(!bot->IsWithinLOSInMap(unit) || bot->GetMapId() != unit->GetMapId() || !hasRealThreat(unit))
+        {
+            set<Unit *>::iterator tIter2 = tIter;
+            ++tIter;
+            targets.erase(tIter2);
+        }
+        else
+            ++tIter;
+    }
+}
+
+bool AttackersValue::hasRealThreat(Unit *attacker)
+{
+    return attacker &&
+        attacker->IsInWorld() &&
+        attacker->IsAlive() &&
+        !attacker->IsPolymorphed() &&
+        !attacker->isInRoots() &&
+        !attacker->IsFriendlyTo(bot) &&
+        (attacker->getThreatManager().getCurrentVictim() || dynamic_cast<Player*>(attacker));
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.h b/src/plugins/playerbot/strategy/values/AttackersValue.h
new file mode 100644
index 0000000..02f1b62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "NearestUnitsValue.h"
+
+namespace ai
+{
+    class AttackersValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        AttackersValue(PlayerbotAI* ai) : ObjectGuidListCalculatedValue(ai, "attackers", 5) {}
+        list<ObjectGuid> Calculate();
+
+	private:
+        void AddAttackersOf(Group* group, set<Unit*>& targets);
+        void AddAttackersOf(Unit* unit, set<Unit*>& targets);
+		void RemoveNonThreating(set<Unit*>& targets);
+		bool hasRealThreat(Unit* attacker);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AvailableLootValue.h b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
new file mode 100644
index 0000000..c8f460c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
@@ -0,0 +1,40 @@
+#pragma once
+#include "../Value.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+
+    class AvailableLootValue : public ManualSetValue<LootObjectStack*>
+	{
+	public:
+        AvailableLootValue(PlayerbotAI* ai) : ManualSetValue<LootObjectStack*>(ai, NULL)
+        {
+            value = new LootObjectStack(ai->GetBot());
+        }
+
+        virtual ~AvailableLootValue()
+        {
+            if (value)
+                delete value;
+        }
+    };
+
+    class LootTargetValue : public ManualSetValue<LootObject>
+    {
+    public:
+        LootTargetValue(PlayerbotAI* ai) : ManualSetValue<LootObject>(ai, LootObject()) {}
+    };
+
+    class CanLootValue : public BoolCalculatedValue
+    {
+    public:
+        CanLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            LootObject loot = AI_VALUE(LootObject, "loot target");
+            return !loot.IsEmpty() && loot.GetWorldObject(bot) && AI_VALUE2(float, "distance", "loot target") <= INTERACTION_DISTANCE;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
new file mode 100644
index 0000000..2660a81
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CcTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../Action.h"
+
+using namespace ai;
+
+class FindTargetForCcStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForCcStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+        maxDistance = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("current target") == creature)
+            return;
+
+        uint8 health = creature->GetHealthPct();
+        if (health < sPlayerbotAIConfig.mediumHealth)
+            return;
+
+        if (!ai->CanCastSpell(spell, creature))
+            return;
+
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("rti target") == creature)
+        {
+            result = creature;
+            return;
+        }
+
+        float minDistance = sPlayerbotAIConfig.spellDistance;
+        Group* group = bot->GetGroup();
+        if (!group)
+            return;
+
+        if (group->GetTargetIcon(4) == creature->GetGUID())
+        {
+            result = creature;
+            return;
+        }
+
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+        if (!tankCount || !dpsCount)
+        {
+            result = creature;
+            return;
+        }
+
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !member || !member->IsAlive() || member == bot)
+                continue;
+
+            if (!ai->IsTank(member))
+                continue;
+
+            float distance = member->GetDistance(creature);
+            if (distance < minDistance)
+                minDistance = distance;
+        }
+
+        if (!result || minDistance > maxDistance)
+        {
+            result = creature;
+            maxDistance = minDistance;
+        }
+    }
+
+private:
+    string spell;
+    float maxDistance;
+};
+
+Unit* CcTargetValue::Calculate()
+{
+    FindTargetForCcStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.h b/src/plugins/playerbot/strategy/values/CcTargetValue.h
new file mode 100644
index 0000000..9b59705
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class CcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ChatValue.h b/src/plugins/playerbot/strategy/values/ChatValue.h
new file mode 100644
index 0000000..b39a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ChatValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ChatValue : public ManualSetValue<ChatMsg>
+	{
+	public:
+        ChatValue(PlayerbotAI* ai) : ManualSetValue<ChatMsg>(ai, CHAT_MSG_WHISPER) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
new file mode 100644
index 0000000..932b0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentCcTargetValue.h"
+
+using namespace ai;
+
+class FindCurrentCcTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindCurrentCcTargetStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (ai->HasAura(spell, attacker))
+            result = attacker;
+    }
+
+private:
+    string spell;
+};
+
+
+Unit* CurrentCcTargetValue::Calculate()
+{
+    FindCurrentCcTargetStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
new file mode 100644
index 0000000..501b7bd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class CurrentCcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CurrentCcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
new file mode 100644
index 0000000..14accb1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
@@ -0,0 +1,22 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentTargetValue.h"
+
+using namespace ai;
+
+Unit* CurrentTargetValue::Get()
+{
+    if (selection.IsEmpty())
+        return NULL;
+
+    Unit* unit = sObjectAccessor->GetUnit(*bot, selection);
+    if (unit && !bot->IsWithinLOSInMap(unit))
+        return NULL;
+
+    return unit;
+}
+
+void CurrentTargetValue::Set(Unit* target)
+{
+    selection = target ? target->GetGUID() : ObjectGuid::Empty;
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
new file mode 100644
index 0000000..6b9fb69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class CurrentTargetValue : public UnitManualSetValue
+	{
+	public:
+        CurrentTargetValue(PlayerbotAI* ai) : UnitManualSetValue(ai, NULL) {}
+
+        virtual Unit* Get();
+        virtual void Set(Unit* unit);
+
+    private:
+        ObjectGuid selection;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DistanceValue.h b/src/plugins/playerbot/strategy/values/DistanceValue.h
new file mode 100644
index 0000000..43277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DistanceValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class DistanceValue : public FloatCalculatedValue, public Qualified
+	{
+	public:
+        DistanceValue(PlayerbotAI* ai) : FloatCalculatedValue(ai) {}
+
+    public:
+        float Calculate()
+        {
+            if (qualifier == "loot target")
+            {
+                LootObject loot = AI_VALUE(LootObject, qualifier);
+                if (loot.IsEmpty())
+                    return 0.0f;
+
+                WorldObject* obj = loot.GetWorldObject(bot);
+                if (!obj)
+                    return 0.0f;
+
+                return ai->GetBot()->GetDistance(obj);
+            }
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target || !target->IsInWorld())
+                return 0.0f;
+
+            return ai->GetBot()->GetDistance(target);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
new file mode 100644
index 0000000..afcdcbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForDpsStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForDpsStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        maxTankCount = 0;
+        minDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        float threat = threatManager->getThreat(ai->GetBot());
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            minThreat >= threat && (maxTankCount <= tankCount || minDpsCount >= dpsCount))
+        {
+            minThreat = threat;
+            maxTankCount = tankCount;
+            minDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int maxTankCount;
+    int minDpsCount;
+};
+
+
+Unit* DpsTargetValue::Calculate()
+{
+    FindTargetForDpsStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.h b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
new file mode 100644
index 0000000..3df1467
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class DpsTargetValue : public TargetValue
+	{
+	public:
+        DpsTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
new file mode 100644
index 0000000..06c9bf3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelTargetValue.h"
+
+using namespace ai;
+
+Unit* DuelTargetValue::Calculate()
+{
+    return bot->duel ? bot->duel->opponent : NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.h b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
new file mode 100644
index 0000000..9e7d2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class DuelTargetValue : public TargetValue
+	{
+	public:
+        DuelTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
new file mode 100644
index 0000000..d4df967
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyHealerTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* EnemyHealerTargetValue::Calculate()
+{
+    string spell = qualifier;
+
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->IsInterruptableSpellCasting(unit, spell))
+            continue;
+
+        Spell* spell = unit->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+
+        spell = unit->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
new file mode 100644
index 0000000..bea36c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class EnemyHealerTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        EnemyHealerTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "enemy healer target") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
new file mode 100644
index 0000000..5576e75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyPlayerValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindEnemyPlayerStrategy : public FindTargetStrategy
+{
+public:
+    FindEnemyPlayerStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result)
+        {
+            Player* enemy = dynamic_cast<Player*>(attacker);
+            if (enemy && ai->IsOpposing(enemy) && enemy->IsOutdoorPvPActive())
+                result = attacker;
+        }
+    }
+
+};
+
+
+Unit* EnemyPlayerValue::Calculate()
+{
+    FindEnemyPlayerStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
new file mode 100644
index 0000000..ea50739
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class EnemyPlayerValue : public TargetValue
+	{
+	public:
+        EnemyPlayerValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.cpp b/src/plugins/playerbot/strategy/values/Formations.cpp
new file mode 100644
index 0000000..9294253
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.cpp
@@ -0,0 +1,346 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "Formations.h"
+#include "formations/Arrow.h"
+
+using namespace ai;
+
+WorldLocation Formation::NullLocation = WorldLocation();
+
+namespace ai
+{
+    class MeleeFormation : public FollowFormation
+    {
+    public:
+        MeleeFormation(PlayerbotAI* ai) : FollowFormation(ai, "melee") {}
+        virtual string GetTargetName() { return "master target"; }
+    };
+
+    class QueueFormation : public FollowFormation
+    {
+    public:
+        QueueFormation(PlayerbotAI* ai) : FollowFormation(ai, "queue") {}
+        virtual string GetTargetName() { return "line target"; }
+    };
+
+    class ChaosFormation : public MoveFormation
+    {
+    public:
+        ChaosFormation(PlayerbotAI* ai) : MoveFormation(ai, "chaos") {}
+        virtual WorldLocation GetLocation()
+        {
+            Player* master = GetMaster();
+            if (!master)
+                return WorldLocation();
+
+            float range = sPlayerbotAIConfig.lootDistance * (float)(rand() % 10) / 10;
+			float angle = GetFollowAngle();
+            float x = master->GetPositionX() + cos(angle) * range;
+            float y = master->GetPositionY() + sin(angle) * range;
+            float z = master->GetPositionZ();
+            float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(master->GetMapId(), x, y, ground + 0.5f);
+        }
+
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.lootDistance; }
+    };
+
+    class CircleFormation : public MoveFormation
+    {
+    public:
+        CircleFormation(PlayerbotAI* ai) : MoveFormation(ai, "circle") {}
+        virtual WorldLocation GetLocation()
+        {
+            float range = 2.0f;
+
+            Unit* target = AI_VALUE(Unit*, "current target");
+            Player* master = GetMaster();
+            if (!target)
+                target = master;
+
+            if (!target)
+				return Formation::NullLocation;
+
+            switch (bot->getClass())
+            {
+            case CLASS_HUNTER:
+            case CLASS_MAGE:
+            case CLASS_PRIEST:
+            case CLASS_WARLOCK:
+                range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_DRUID:
+                if (!ai->IsTank(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_SHAMAN:
+                if (ai->IsHeal(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            }
+
+            float x = target->GetPositionX();
+            float y = target->GetPositionY();
+            float z = target->GetPositionZ();
+            float ground = target->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            float angle = GetFollowAngle();
+            return WorldLocation(bot->GetMapId(), x + cos(angle) * range, y + sin(angle) * range, ground + 0.5f);
+        }
+    };
+
+    class LineFormation : public MoveFormation
+    {
+    public:
+        LineFormation(PlayerbotAI* ai) : MoveFormation(ai, "line") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = 2.0f;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> players;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                    players.push_back(member);
+
+                gref = gref->next();
+            }
+
+            players.insert(players.begin() + group->GetMembersCount() / 2, master);
+
+            return MoveLine(players, 0.0f, x, y, z, orientation, range);
+        }
+    };
+
+    class ShieldFormation : public MoveFormation
+    {
+    public:
+        ShieldFormation(PlayerbotAI* ai) : MoveFormation(ai, "shield") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = sPlayerbotAIConfig.followDistance;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> tanks;
+            vector<Player*> dps;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                {
+                    if (ai->IsTank(member))
+                        tanks.push_back(member);
+                    else
+                        dps.push_back(member);
+                }
+
+                gref = gref->next();
+            }
+
+            if (ai->IsTank(master))
+                tanks.insert(tanks.begin() + (tanks.size() + 1) / 2, master);
+            else
+                dps.insert(dps.begin() + (dps.size() + 1) / 2, master);
+
+            if (ai->IsTank(bot) && ai->IsTank(master))
+            {
+                return MoveLine(tanks, 0.0f, x, y, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                return MoveLine(dps, 0.0f, x, y, z, orientation, range);
+            }
+            if (ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                float diff = tanks.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(tanks, diff, x + cos(orientation) * range, y + sin(orientation) * range, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && ai->IsTank(master))
+            {
+                float diff = dps.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(dps, diff, x - cos(orientation) * range, y - sin(orientation) * range, z, orientation, range);
+            }
+            return Formation::NullLocation;
+        }
+    };
+};
+
+float Formation::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+FormationValue::FormationValue(PlayerbotAI* ai) : ManualSetValue<Formation*>(ai, new MeleeFormation(ai), "formation")
+{
+}
+
+bool SetFormationAction::Execute(Event event)
+{
+    string formation = event.getParam();
+
+	Value<Formation*>* value = context->GetValue<Formation*>("formation");
+    if (formation == "?" || formation.empty())
+    {
+        ostringstream str; str << "Formation: |cff00ff00" << value->Get()->getName();
+        ai->TellMaster(str);
+        return true;
+    }
+
+    if (formation == "melee" || formation == "default")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new MeleeFormation(ai));
+    }
+    else if (formation == "queue")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new QueueFormation(ai));
+    }
+    else if (formation == "chaos")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ChaosFormation(ai));
+    }
+    else if (formation == "circle")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new CircleFormation(ai));
+    }
+    else if (formation == "line")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new LineFormation(ai));
+    }
+    else if (formation == "shield")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ShieldFormation(ai));
+    }
+    else if (formation == "arrow")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ArrowFormation(ai));
+    }
+    else
+    {
+        ostringstream str; str << "Invalid formation: |cffff0000" << formation;
+        ai->TellMaster(str);
+        ai->TellMaster("Please set to any of:|cffffffff melee (default), queue, chaos, circle, line, shield, arrow");
+        return false;
+    }
+
+    ostringstream str; str << "Formation set to: " << formation;
+    ai->TellMaster(str);
+    return true;
+}
+
+
+WorldLocation MoveFormation::MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    if (line.size() < 5)
+    {
+        return MoveSingleLine(line, diff, cx, cy, cz, orientation, range);
+    }
+
+    int lines = ceil((double)line.size() / 5.0);
+    for (int i = 0; i < lines; i++)
+    {
+        float radius = range * i;
+        float x = cx + cos(orientation) * radius;
+        float y = cy + sin(orientation) * radius;
+        vector<Player*> singleLine;
+        for (int j = 0; j < 5 && !line.empty(); j++)
+        {
+            singleLine.push_back(line[line.size() - 1]);
+            line.pop_back();
+        }
+
+        WorldLocation loc = MoveSingleLine(singleLine, diff, x, y,cz, orientation, range);
+        if (loc != Formation::NullLocation)
+            return loc;
+    }
+
+    return Formation::NullLocation;
+}
+
+WorldLocation MoveFormation::MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    float count = line.size();
+    float angle = orientation - M_PI / 2.0f;
+    float x = cx + cos(angle) * (range * floor(count / 2.0f) + diff);
+    float y = cy + sin(angle) * (range * floor(count / 2.0f) + diff);
+
+    int index = 0;
+    for (vector<Player*>::iterator i = line.begin(); i != line.end(); i++)
+    {
+        Player* member = *i;
+
+        if (member == bot)
+        {
+            float angle = orientation + M_PI / 2.0f;
+            float radius = range * index;
+
+            float lx = x + cos(angle) * radius;
+            float ly = y + sin(angle) * radius;
+            float lz = cz;
+            float ground = bot->GetMap()->GetHeight(lx, ly, lz + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(bot->GetMapId(), lx, ly, ground + 0.5f);
+        }
+
+        index++;
+    }
+
+    return Formation::NullLocation;
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.h b/src/plugins/playerbot/strategy/values/Formations.h
new file mode 100644
index 0000000..2589cd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.h
@@ -0,0 +1,52 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class Formation : public AiNamedObject
+    {
+    public:
+        Formation(PlayerbotAI* ai, string name) : AiNamedObject (ai, name) {}
+
+    public:
+        virtual string GetTargetName() { return ""; }
+        virtual WorldLocation GetLocation() { return NullLocation; }
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.followDistance; }
+        static WorldLocation NullLocation;
+
+    protected:
+        float GetFollowAngle();
+    };
+
+    class FollowFormation : public Formation
+    {
+    public:
+        FollowFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+    };
+
+    class MoveFormation : public Formation
+    {
+    public:
+        MoveFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+
+    protected:
+        WorldLocation MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+        WorldLocation MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+    };
+
+    class FormationValue : public ManualSetValue<Formation*>
+	{
+	public:
+        FormationValue(PlayerbotAI* ai);
+        ~FormationValue() { if (value) { delete value; value = NULL; } }
+    };
+
+    class SetFormationAction : public Action
+    {
+    public:
+        SetFormationAction(PlayerbotAI* ai) : Action(ai, "set formation") {}
+        virtual bool Execute(Event event);
+    };
+};
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
new file mode 100644
index 0000000..451dbf7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+Unit* GrindTargetValue::Calculate()
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    if (group)
+        memberCount = group->GetMembersCount();
+
+    Unit* target = NULL;
+    uint32 assistCount = 0;
+    while (!target && assistCount < memberCount)
+    {
+        target = FindTargetForGrinding(assistCount++);
+    }
+
+    return target;
+}
+
+
+Unit* GrindTargetValue::FindTargetForGrinding(int assistCount)
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    Player* master = GetMaster();
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        return unit;
+    }
+
+    list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+
+    if(targets.empty())
+        return NULL;
+
+    float distance = 0;
+    Unit* result = NULL;
+    for(list<ObjectGuid>::iterator tIter = targets.begin(); tIter != targets.end(); tIter++)
+    {
+        Unit* unit = ai->GetUnit(*tIter);
+        if (!unit)
+            continue;
+
+        if (abs(bot->GetPositionZ() - unit->GetPositionZ()) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (GetTargetingPlayerCount(unit) > assistCount)
+            continue;
+
+		if (master && master->GetDistance(unit) >= sPlayerbotAIConfig.grindDistance && !sRandomPlayerbotMgr.IsRandomBot(bot))
+            continue;
+
+		if ((int)unit->getLevel() - (int)bot->getLevel() > 4 && !unit->GetGUID().IsPlayer())
+		    continue;
+
+		Creature* creature = dynamic_cast<Creature*>(unit);
+		if (creature && creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->rank > CREATURE_ELITE_NORMAL)
+		    continue;
+
+        if (group)
+        {
+            Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                if( !member || !member->IsAlive())
+                    continue;
+
+                float d = member->GetDistance(unit);
+                if (!result || d < distance)
+                {
+                    distance = d;
+                    result = unit;
+                }
+            }
+        }
+        else
+        {
+            float d = bot->GetDistance(unit);
+            if (!result || d < distance)
+            {
+                distance = d;
+                result = unit;
+            }
+        }
+    }
+
+    return result;
+}
+
+
+int GrindTargetValue::GetTargetingPlayerCount( Unit* unit )
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    int count = 0;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !member || !member->IsAlive() || member == bot)
+            continue;
+
+        PlayerbotAI* ai = member->GetPlayerbotAI();
+        if ((ai && *ai->GetAiObjectContext()->GetValue<Unit*>("current target") == unit) ||
+            (!ai && member->GetSelectedUnit() == unit))
+            count++;
+    }
+
+    return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.h b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
new file mode 100644
index 0000000..3b2fbe0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class GrindTargetValue : public TargetValue
+	{
+	public:
+        GrindTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+
+    private:
+        int GetTargetingPlayerCount(Unit* unit);
+        Unit* FindTargetForGrinding(int assistCount);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
new file mode 100644
index 0000000..3dac17f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class HasAvailableLootValue : public BoolCalculatedValue
+	{
+	public:
+        HasAvailableLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        virtual bool Calculate()
+        {
+            return !AI_VALUE(bool, "can loot") &&
+                    AI_VALUE(LootObjectStack*, "available loot")->CanLoot(sPlayerbotAIConfig.lootDistance) &&
+                    !bot->IsMounted();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasTotemValue.h b/src/plugins/playerbot/strategy/values/HasTotemValue.h
new file mode 100644
index 0000000..a65b3a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasTotemValue.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class HasTotemValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        HasTotemValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        bool Calculate()
+        {
+            list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+            for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+            {
+                Unit* unit = ai->GetUnit(*i);
+                if (!unit)
+                    continue;
+
+                Creature* creature = dynamic_cast<Creature*>(unit);
+                if (!creature || !creature->IsTotem())
+                    continue;
+
+                if (strstri(creature->GetName().c_str(), qualifier.c_str()) && bot->GetDistance(creature) <= sPlayerbotAIConfig.spellDistance)
+                    return true;
+            }
+
+            return false;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
new file mode 100644
index 0000000..41440c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InvalidTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool InvalidTargetValue::Calculate()
+{
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    if (qualifier == "current target")
+    {
+        return !target ||
+                target->GetMapId() != bot->GetMapId() ||
+                target->isDead() ||
+                target->IsPolymorphed() ||
+                target->IsCharmed() ||
+                target->isFeared() ||
+                target->HasUnitState(UNIT_STATE_ISOLATED) ||
+                target->IsFriendlyTo(bot) ||
+                !bot->IsWithinDistInMap(target, sPlayerbotAIConfig.sightDistance) ||
+                !bot->IsWithinLOSInMap(target);
+    }
+
+    return !target;
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.h b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
new file mode 100644
index 0000000..5d277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class InvalidTargetValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        InvalidTargetValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+	public:
+        virtual bool Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsBehindValue.h b/src/plugins/playerbot/strategy/values/IsBehindValue.h
new file mode 100644
index 0000000..14c4dbd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsBehindValue.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsBehindValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsBehindValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+
+            float targetOrientation = target->GetOrientation();
+            float orientation = bot->GetOrientation();
+            float distance = bot->GetDistance(target);
+
+            return distance <= ATTACK_DISTANCE && abs(targetOrientation - orientation) < M_PI / 2;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsFacingValue.h b/src/plugins/playerbot/strategy/values/IsFacingValue.h
new file mode 100644
index 0000000..814014f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsFacingValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsFacingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsFacingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            return bot->isInFront(target, M_PI / 3.0f);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsMovingValue.h b/src/plugins/playerbot/strategy/values/IsMovingValue.h
new file mode 100644
index 0000000..bbee8bd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsMovingValue.h
@@ -0,0 +1,42 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsMovingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsMovingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            switch (target->GetMotionMaster()->GetCurrentMovementGeneratorType())
+            {
+            case IDLE_MOTION_TYPE:
+                return false;
+            }
+            return true;
+        }
+    };
+
+    class IsSwimmingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsSwimmingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            return target->IsUnderWater() || target->IsInWater();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.cpp b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
new file mode 100644
index 0000000..2b6c0a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemCountValue.h"
+
+using namespace ai;
+
+list<Item*> InventoryItemValueBase::Find(string qualifier)
+{
+    list<Item*> result;
+
+    Player* bot = InventoryAction::ai->GetBot();
+
+    list<Item*> items = InventoryAction::parseItems(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); i++)
+        result.push_back(*i);
+
+    return result;
+}
+
+
+uint8 ItemCountValue::Calculate()
+{
+    uint8 count = 0;
+    list<Item*> items = Find(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* item = *i;
+        count += item->GetCount();
+    }
+
+    return count;
+}
+
+list<Item*> InventoryItemValue::Calculate()
+{
+    return Find(qualifier);
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.h b/src/plugins/playerbot/strategy/values/ItemCountValue.h
new file mode 100644
index 0000000..f81d9b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "../ItemVisitors.h"
+#include "../actions/InventoryAction.h"
+
+namespace ai
+{
+    class InventoryItemValueBase : public InventoryAction
+    {
+    public:
+        InventoryItemValueBase(PlayerbotAI* ai) : InventoryAction(ai, "empty") {}
+        virtual bool Execute(Event event) { return false; }
+
+    protected:
+        list<Item*> Find(string qualifier);
+    };
+
+    class ItemCountValue : public Uint8CalculatedValue, public Qualified, InventoryItemValueBase
+	{
+	public:
+        ItemCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual uint8 Calculate();
+	};
+
+    class InventoryItemValue : public CalculatedValue<list<Item*> >, public Qualified, InventoryItemValueBase
+    {
+    public:
+        InventoryItemValue(PlayerbotAI* ai) : CalculatedValue<list<Item*> >(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual list<Item*> Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
new file mode 100644
index 0000000..671cd97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemForSpellValue.h"
+
+using namespace ai;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+Item* ItemForSpellValue::Calculate()
+{
+    uint32 spellid = atoi(qualifier.c_str());
+    if (!spellid)
+        return NULL;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+    if (!spellInfo)
+        return NULL;
+
+    Item* itemForSpell = NULL;
+    Player* trader = bot->GetTrader();
+    if (trader)
+    {
+        itemForSpell = trader->GetTradeData()->GetItem(TRADE_SLOT_NONTRADED);
+        if (itemForSpell && itemForSpell->IsFitToSpellRequirements(spellInfo))
+            return itemForSpell;
+    }
+
+    // Workaround as some spells have no item mask (e.g. shaman weapon enhancements)
+    if (!strcmpi(spellInfo->SpellName[0], "rockbiter weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "flametongue weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "earthliving weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "frostbrand weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "windfury weapon"))
+    {
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_MAINHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_OFFHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        return NULL;
+    }
+
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++ ) {
+        itemForSpell = GetItemFitsToSpellRequirements(slot, spellInfo);
+        if (itemForSpell)
+            return itemForSpell;
+    }
+    return NULL;
+}
+
+Item* ItemForSpellValue::GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo)
+{
+    Item* const itemForSpell = bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+    if (!itemForSpell || itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+        return NULL;
+
+    if (itemForSpell->IsFitToSpellRequirements(spellInfo))
+        return itemForSpell;
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.h b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
new file mode 100644
index 0000000..39ce6af
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class ItemForSpellValue : public CalculatedValue<Item*>, public Qualified
+	{
+	public:
+        ItemForSpellValue(PlayerbotAI* ai) : CalculatedValue<Item*>(ai) {}
+
+    public:
+        virtual Item* Calculate();
+
+    private:
+        Item* GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
new file mode 100644
index 0000000..b7fbcfc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
@@ -0,0 +1,146 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemUsageValue.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+ItemUsage ItemUsageValue::Calculate()
+{
+    uint32 itemId = atoi(qualifier.c_str());
+    if (!itemId)
+        return ITEM_USAGE_NONE;
+
+    const ItemTemplate* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return ITEM_USAGE_NONE;
+
+    if (IsItemUsefulForSkill(proto))
+        return ITEM_USAGE_SKILL;
+
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_KEY:
+    case ITEM_CLASS_CONSUMABLE:
+        return ITEM_USAGE_USE;
+    }
+
+    if (bot->GetGuildId() && sGuildTaskMgr.IsGuildTaskItem(itemId, bot->GetGuildId()))
+        return ITEM_USAGE_GUILD_TASK;
+
+    return QueryItemUsageForEquip(proto);
+}
+
+ItemUsage ItemUsageValue::QueryItemUsageForEquip(ItemTemplate const * item)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return ITEM_USAGE_NONE;
+
+    if (item->InventoryType == INVTYPE_NON_EQUIP)
+        return ITEM_USAGE_NONE;
+
+    Item *pItem = Item::CreateItem(item->ItemId, 1, bot);
+    if (!pItem)
+        return ITEM_USAGE_NONE;
+
+    uint16 dest;
+    InventoryResult result = bot->CanEquipItem(NULL_SLOT, dest, pItem, true, false);
+    pItem->RemoveFromUpdateQueueOf(bot);
+    delete pItem;
+
+    if( result != EQUIP_ERR_OK )
+        return ITEM_USAGE_NONE;
+
+    Item* existingItem = bot->GetItemByPos(dest);
+    if (!existingItem)
+        return ITEM_USAGE_EQUIP;
+
+    const ItemTemplate* oldItem = existingItem->GetTemplate();
+    if (oldItem->ItemLevel < item->ItemLevel && oldItem->ItemId != item->ItemId)
+    {
+        switch (item->Class)
+        {
+        case ITEM_CLASS_ARMOR:
+            if (oldItem->SubClass <= item->SubClass) {
+                return ITEM_USAGE_REPLACE;
+            }
+            break;
+        default:
+            return ITEM_USAGE_EQUIP;
+        }
+    }
+
+    return ITEM_USAGE_NONE;
+}
+
+bool ItemUsageValue::IsItemUsefulForSkill(ItemTemplate const * proto)
+{
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_GEM:
+        if (proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE && bot->HasSkill(SKILL_JEWELCRAFTING))
+            return true;
+        if (proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE)
+            return true;
+        break;
+    case ITEM_CLASS_TRADE_GOODS:
+        switch (proto->SubClass)
+        {
+        case ITEM_SUBCLASS_PARTS:
+        case ITEM_SUBCLASS_EXPLOSIVES:
+        case ITEM_SUBCLASS_DEVICES:
+            return bot->HasSkill(SKILL_ENGINEERING);
+        case ITEM_SUBCLASS_JEWELCRAFTING:
+            return bot->HasSkill(SKILL_JEWELCRAFTING);
+        case ITEM_SUBCLASS_CLOTH:
+            return bot->HasSkill(SKILL_TAILORING);
+        case ITEM_SUBCLASS_LEATHER:
+            return bot->HasSkill(SKILL_LEATHERWORKING) || bot->HasSkill(SKILL_SKINNING);
+        case ITEM_SUBCLASS_METAL_STONE:
+            return (bot->HasSkill(SKILL_BLACKSMITHING) ||
+                bot->HasSkill(SKILL_ENGINEERING) ||
+                bot->HasSkill(SKILL_MINING));
+        case ITEM_SUBCLASS_MEAT:
+            return bot->HasSkill(SKILL_COOKING);
+        case ITEM_SUBCLASS_HERB:
+            return (bot->HasSkill(SKILL_HERBALISM) ||
+                bot->HasSkill(SKILL_ALCHEMY) ||
+                bot->HasSkill(SKILL_INSCRIPTION));
+        case ITEM_SUBCLASS_ELEMENTAL:
+            return true;
+        case ITEM_SUBCLASS_ENCHANTING:
+            return bot->HasSkill(SKILL_ENCHANTING);
+        }
+        break;
+    case ITEM_CLASS_RECIPE:
+        {
+            if (bot->HasSpell(proto->Spells[2].SpellId))
+                break;
+
+            switch (proto->SubClass)
+            {
+            case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                return bot->HasSkill(SKILL_LEATHERWORKING);
+            case ITEM_SUBCLASS_TAILORING_PATTERN:
+                return bot->HasSkill(SKILL_TAILORING);
+            case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                return bot->HasSkill(SKILL_ENGINEERING);
+            case ITEM_SUBCLASS_BLACKSMITHING:
+                return bot->HasSkill(SKILL_BLACKSMITHING);
+            case ITEM_SUBCLASS_COOKING_RECIPE:
+                return bot->HasSkill(SKILL_COOKING);
+            case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                return bot->HasSkill(SKILL_ALCHEMY);
+            case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                return bot->HasSkill(SKILL_FIRST_AID);
+            case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                return bot->HasSkill(SKILL_ENCHANTING);
+            case ITEM_SUBCLASS_FISHING_MANUAL:
+                return bot->HasSkill(SKILL_FISHING);
+            case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                return bot->HasSkill(SKILL_JEWELCRAFTING);
+            }
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.h b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
new file mode 100644
index 0000000..95e0a52
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
@@ -0,0 +1,28 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    enum ItemUsage
+    {
+        ITEM_USAGE_NONE = 0,
+        ITEM_USAGE_EQUIP = 1,
+        ITEM_USAGE_REPLACE = 2,
+        ITEM_USAGE_SKILL = 3,
+        ITEM_USAGE_USE = 4,
+        ITEM_USAGE_GUILD_TASK = 5
+    };
+
+    class ItemUsageValue : public CalculatedValue<ItemUsage>, public Qualified
+	{
+	public:
+        ItemUsageValue(PlayerbotAI* ai) : CalculatedValue<ItemUsage>(ai) {}
+
+    public:
+        virtual ItemUsage Calculate();
+
+    private:
+        ItemUsage QueryItemUsageForEquip(ItemTemplate const * proto);
+        bool IsItemUsefulForSkill(ItemTemplate const * proto);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LastMovementValue.h b/src/plugins/playerbot/strategy/values/LastMovementValue.h
new file mode 100644
index 0000000..7709343
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastMovementValue.h
@@ -0,0 +1,61 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastMovement
+    {
+    public:
+        LastMovement()
+        {
+            lastMoveToX = 0;
+            lastMoveToY = 0;
+            lastMoveToZ = 0;
+            lastMoveToOri = 0;
+            lastFollow = NULL;
+        }
+
+        LastMovement(LastMovement& other)
+        {
+            taxiNodes = other.taxiNodes;
+            taxiMaster = other.taxiMaster;
+            lastFollow = other.lastFollow;
+            lastAreaTrigger = other.lastAreaTrigger;
+            lastMoveToX = other.lastMoveToX;
+            lastMoveToY = other.lastMoveToY;
+            lastMoveToZ = other.lastMoveToZ;
+            lastMoveToOri = other.lastMoveToOri;
+        }
+
+        void Set(Unit* lastFollow)
+        {
+            Set(0.0f, 0.0f, 0.0f, 0.0f);
+            this->lastFollow = lastFollow;
+        }
+
+        void Set(float x, float y, float z, float ori)
+        {
+            lastMoveToX = x;
+            lastMoveToY = y;
+            lastMoveToZ = z;
+            lastMoveToOri = ori;
+            lastFollow = NULL;
+        }
+
+    public:
+        vector<uint32> taxiNodes;
+        ObjectGuid taxiMaster;
+        Unit* lastFollow;
+        uint32 lastAreaTrigger;
+        float lastMoveToX, lastMoveToY, lastMoveToZ, lastMoveToOri;
+    };
+
+    class LastMovementValue : public ManualSetValue<LastMovement&>
+	{
+	public:
+        LastMovementValue(PlayerbotAI* ai) : ManualSetValue<LastMovement&>(ai, data) {}
+
+    private:
+        LastMovement data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
new file mode 100644
index 0000000..bf0a17e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCastTimeValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastSpellCastTimeValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, 0), Qualified() {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
new file mode 100644
index 0000000..92381de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCast
+    {
+    public:
+        LastSpellCast() : id(0),time(0) {}
+
+    public:
+        void Set(uint32 id, ObjectGuid target, time_t time)
+        {
+            this->id = id;
+            this->target = target;
+            this->time = time;
+        }
+
+        void Reset()
+        {
+            id = 0;
+            target.Set(0);
+            time = 0;
+        }
+    public:
+        uint32 id;
+        ObjectGuid target;
+        time_t time;
+    };
+
+    class LastSpellCastValue : public ManualSetValue<LastSpellCast&>
+	{
+	public:
+        LastSpellCastValue(PlayerbotAI* ai) : ManualSetValue<LastSpellCast&>(ai, data) {}
+
+    private:
+        LastSpellCast data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
new file mode 100644
index 0000000..39021c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LeastHpTargetValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindLeastHpTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindLeastHpTargetStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minHealth = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result || result->GetHealth() > attacker->GetHealth())
+            result = attacker;
+    }
+
+protected:
+    float minHealth;
+};
+
+
+Unit* LeastHpTargetValue::Calculate()
+{
+    FindLeastHpTargetStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
new file mode 100644
index 0000000..e748e7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class LeastHpTargetValue : public TargetValue
+	{
+	public:
+        LeastHpTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LfgValues.h b/src/plugins/playerbot/strategy/values/LfgValues.h
new file mode 100644
index 0000000..290a4c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LfgValues.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Value.h"
+
+namespace ai
+{
+class LfgProposalValue : public ManualSetValue<uint32>
+{
+public:
+    LfgProposalValue(PlayerbotAI* ai) : ManualSetValue<uint32>(ai, 0, "lfg proposal") {}
+};
+}
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.cpp b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
new file mode 100644
index 0000000..3546e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LineTargetValue.h"
+
+using namespace ai;
+
+Unit* LineTargetValue::Calculate()
+{
+    Player* master = GetMaster();
+    if (!master)
+        return NULL;
+
+    Group* group = master->GetGroup();
+    if (!group)
+        return NULL;
+
+    Player *prev = master;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == master)
+            continue;
+
+        if (player == bot)
+            return prev;
+
+        prev = player;
+    }
+
+    return master;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.h b/src/plugins/playerbot/strategy/values/LineTargetValue.h
new file mode 100644
index 0000000..57998fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LineTargetValue : public UnitCalculatedValue
+	{
+	public:
+        LineTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LogLevelValue.h b/src/plugins/playerbot/strategy/values/LogLevelValue.h
new file mode 100644
index 0000000..c5f9da9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LogLevelValue.h
@@ -0,0 +1,12 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LogLevelValue : public ManualSetValue<LogLevel>
+	{
+	public:
+        LogLevelValue(PlayerbotAI* ai) :
+            ManualSetValue<LogLevel>(ai, LOG_LEVEL_DEBUG) {}
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LootStrategyValue.h b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
new file mode 100644
index 0000000..210e518
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LootStrategyValue : public ManualSetValue<LootStrategy>
+	{
+	public:
+        LootStrategyValue(PlayerbotAI* ai) : ManualSetValue<LootStrategy>(ai, LOOTSTRATEGY_SKILL) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
new file mode 100644
index 0000000..6c29f1f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ManaSaveLevelValue : public ManualSetValue<double>
+	{
+	public:
+        ManaSaveLevelValue(PlayerbotAI* ai) : ManualSetValue<double>(ai, 1.0, "mana save level") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/MasterTargetValue.h b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
new file mode 100644
index 0000000..a137694
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class MasterTargetValue : public UnitCalculatedValue
+	{
+	public:
+        MasterTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetMaster(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
new file mode 100644
index 0000000..3370836
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestAdsValue.h"
+
+using namespace ai;
+
+bool NearestAdsValue::AcceptUnit(Unit* unit)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return unit != target;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.h b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
new file mode 100644
index 0000000..16e4a84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "PossibleTargetsValue.h"
+
+namespace ai
+{
+    class NearestAdsValue : public PossibleTargetsValue
+	{
+	public:
+        NearestAdsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.tooCloseDistance) :
+            PossibleTargetsValue(ai, range) {}
+
+    protected:
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
new file mode 100644
index 0000000..ad6e30a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestCorpsesValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyDeadUnitInObjectRangeCheck
+{
+public:
+    AnyDeadUnitInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(Unit* u)
+    {
+        return !u->IsAlive() && i_obj->IsWithinDistInMap(u, i_range);
+    }
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+void NearestCorpsesValue::FindUnits(list<Unit*> &targets)
+{
+    AnyDeadUnitInObjectRangeCheck u_check(bot, range);
+    UnitListSearcher<AnyDeadUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestCorpsesValue::AcceptUnit(Unit* unit)
+{
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
new file mode 100644
index 0000000..c23a5b8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestCorpsesValue : public NearestUnitsValue
+	{
+	public:
+        NearestCorpsesValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
new file mode 100644
index 0000000..405b1c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestGameObjects.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyGameObjectInObjectRangeCheck
+{
+public:
+    AnyGameObjectInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(GameObject* u)
+    {
+        if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo())
+            return true;
+
+        return false;
+    }
+
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+list<ObjectGuid> NearestGameObjects::Calculate()
+{
+    list<GameObject*> targets;
+
+    AnyGameObjectInObjectRangeCheck u_check(bot, range);
+    GameObjectListSearcher<AnyGameObjectInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+
+    list<ObjectGuid> result;
+    for(list<GameObject*>::iterator tIter = targets.begin(); tIter != targets.end(); ++tIter)
+    {
+		GameObject* go = *tIter;
+        if(bot->IsWithinLOSInMap(go))
+			result.push_back(go->GetGUID());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.h b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
new file mode 100644
index 0000000..78dcf57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestGameObjects : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestGameObjects(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai), range(range) {}
+
+    protected:
+        virtual list<ObjectGuid> Calculate();
+
+    private:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
new file mode 100644
index 0000000..9f82f10
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestNpcsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+
+using namespace ai;
+using namespace Trinity;
+
+void NearestNpcsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyFriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyFriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestNpcsValue::AcceptUnit(Unit* unit)
+{
+    return !dynamic_cast<Player*>(unit);
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.h b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
new file mode 100644
index 0000000..ebbbd75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestNpcsValue : public NearestUnitsValue
+	{
+	public:
+        NearestNpcsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestUnitsValue.h b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
new file mode 100644
index 0000000..c6d1ed5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestUnitsValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestUnitsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai, "nearest units", 5), range(range) {}
+
+	public:
+        list<ObjectGuid> Calculate()
+        {
+            list<Unit*> targets;
+            FindUnits(targets);
+
+            list<ObjectGuid> results;
+            for(list<Unit *>::iterator i = targets.begin(); i!= targets.end(); ++i)
+            {
+                Unit* unit = *i;
+                if(bot->IsWithinLOSInMap(unit) && AcceptUnit(unit))
+                    results.push_back(unit->GetGUID());
+            }
+            return results;
+        }
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets) = 0;
+        virtual bool AcceptUnit(Unit* unit) = 0;
+
+    protected:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
new file mode 100644
index 0000000..1f50b6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToDispel.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PartyMemberToDispelPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PartyMemberToDispelPredicate(PlayerbotAI* ai, uint32 dispelType) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), dispelType(dispelType) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && ai->HasAuraToDispel(unit, dispelType);
+    }
+
+private:
+    uint32 dispelType;
+};
+
+Unit* PartyMemberToDispel::Calculate()
+{
+    uint32 dispelType = atoi(qualifier.c_str());
+
+    PartyMemberToDispelPredicate predicate(ai, dispelType);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
new file mode 100644
index 0000000..1f87353
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToDispel : public PartyMemberValue, Qualified
+	{
+	public:
+        PartyMemberToDispel(PlayerbotAI* ai) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
new file mode 100644
index 0000000..2ef8e3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToHeal.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class IsTargetOfHealingSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell) {
+        for (int i=0; i<3; i++) {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_HEAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MAX_HEALTH ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MECHANICAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_PCT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+Unit* PartyMemberToHeal::Calculate()
+{
+
+    IsTargetOfHealingSpell predicate;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    bool isRaid = bot->GetGroup()->isRaidGroup();
+    MinValueCalculator calc(100);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (!Check(player) || !player->IsAlive())
+            continue;
+
+        uint8 health = player->GetHealthPct();
+        if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+            calc.probe(health, player);
+
+        Pet* pet = player->GetPet();
+        if (pet && CanHealPet(pet))
+        {
+            health = ((Unit*)pet)->GetHealthPct();
+            if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+                calc.probe(health, player);
+        }
+    }
+    return (Unit*)calc.param;
+}
+
+bool PartyMemberToHeal::CanHealPet(Pet* pet)
+{
+    return HUNTER_PET == pet->getPetType();
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
new file mode 100644
index 0000000..2f52265
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToHeal : public PartyMemberValue
+	{
+	public:
+        PartyMemberToHeal(PlayerbotAI* ai) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+        bool CanHealPet(Pet* pet);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
new file mode 100644
index 0000000..58dd203
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToResurrect.h"
+
+using namespace ai;
+
+class IsTargetOfResurrectSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell)
+    {
+        for (int i=0; i<3; i++)
+        {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT ||
+                spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT_NEW ||
+                spell->Effects[i].Effect == SPELL_EFFECT_SELF_RESURRECT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+class FindDeadPlayer : public FindPlayerPredicate
+{
+public:
+    FindDeadPlayer(PartyMemberValue* value) : value(value) {}
+
+    virtual bool Check(Unit* unit)
+    {
+        Player* player = dynamic_cast<Player*>(unit);
+        return player && player->getDeathState() == CORPSE && !value->IsTargetOfSpellCast(player, predicate);
+    }
+
+private:
+    PartyMemberValue* value;
+    IsTargetOfResurrectSpell predicate;
+};
+
+Unit* PartyMemberToResurrect::Calculate()
+{
+	FindDeadPlayer finder(this);
+    return FindPartyMember(finder);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
new file mode 100644
index 0000000..e170269
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToResurrect : public PartyMemberValue
+	{
+	public:
+        PartyMemberToResurrect(PlayerbotAI* ai) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
new file mode 100644
index 0000000..2f5bcc4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Unit* PartyMemberValue::FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate)
+{
+    for (list<Player*>::iterator i = party->begin(); i != party->end(); ++i)
+    {
+        Player* player = *i;
+
+        if (!player)
+            continue;
+
+        if (Check(player) && predicate.Check(player))
+            return player;
+
+        Pet* pet = player->GetPet();
+        if (!pet)
+            continue;
+
+        Unit* unit = (Unit*)pet;
+        if (unit && Check(unit) && predicate.Check(unit))
+            return unit;
+    }
+
+    return NULL;
+}
+
+Unit* PartyMemberValue::FindPartyMember(FindPlayerPredicate &predicate)
+{
+    Player* master = GetMaster();
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    list<Player*> healers, tanks, others, masters;
+    masters.push_back(master);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+
+        if (ai->IsHeal(player))
+            healers.push_back(player);
+        else if (ai->IsTank(player))
+            tanks.push_back(player);
+        else if (player != master)
+            others.push_back(player);
+    }
+
+    list<list<Player*>* > lists;
+    lists.push_back(&healers);
+    lists.push_back(&tanks);
+    lists.push_back(&masters);
+    lists.push_back(&others);
+
+    for (list<list<Player*>* >::iterator i = lists.begin(); i != lists.end(); ++i)
+    {
+        list<Player*>* party = *i;
+        Unit* target = FindPartyMember(party, predicate);
+        if (target)
+            return target;
+    }
+
+    return NULL;
+}
+
+bool PartyMemberValue::Check(Unit* player)
+{
+
+
+    return player && player != bot && player->GetMapId() == bot->GetMapId() &&
+        bot->GetDistance(player) < sPlayerbotAIConfig.spellDistance &&
+        bot->IsWithinLOS(player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+}
+
+bool PartyMemberValue::IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate)
+{
+
+    Group* group = bot->GetGroup();
+    ObjectGuid targetGuid = target ? target->GetGUID() : bot->GetGUID();
+    ObjectGuid corpseGuid = target && target->GetCorpse() ? target->GetCorpse()->GetGUID() : ObjectGuid();
+
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (player == bot)
+            continue;
+
+        if (player->IsNonMeleeSpellCast(true))
+        {
+            for (int type = CURRENT_GENERIC_SPELL; type < CURRENT_MAX_SPELL; type++) {
+                Spell* spell = player->GetCurrentSpell((CurrentSpellTypes)type);
+                if (spell && predicate.Check(spell->m_spellInfo)) {
+                    ObjectGuid unitTarget = spell->m_targets.GetUnitTargetGUID();
+                    if (unitTarget == targetGuid)
+                        return true;
+
+                    ObjectGuid corpseTarget = spell->m_targets.GetCorpseTargetGUID();
+                    if (corpseTarget == corpseGuid)
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.h b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
new file mode 100644
index 0000000..5229b46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
@@ -0,0 +1,31 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindPlayerPredicate
+    {
+    public:
+        virtual bool Check(Unit*) = 0;
+    };
+
+    class SpellEntryPredicate
+    {
+    public:
+        virtual bool Check(SpellInfo const*) = 0;
+    };
+
+    class PartyMemberValue : public UnitCalculatedValue
+	{
+	public:
+        PartyMemberValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        bool IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate);
+
+    protected:
+        Unit* FindPartyMember(FindPlayerPredicate &predicate);
+        Unit* FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate);
+        bool Check(Unit* player);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
new file mode 100644
index 0000000..63f7008
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PlayerWithoutAuraPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PlayerWithoutAuraPredicate(PlayerbotAI* ai, string aura) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), aura(aura) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && !ai->HasAura(aura, unit);
+    }
+
+private:
+    string aura;
+};
+
+Unit* PartyMemberWithoutAuraValue::Calculate()
+{
+	PlayerWithoutAuraPredicate predicate(ai, qualifier);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
new file mode 100644
index 0000000..63961de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PartyMemberWithoutAuraValue : public PartyMemberValue, public Qualified
+	{
+	public:
+        PartyMemberWithoutAuraValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PetTargetValue.h b/src/plugins/playerbot/strategy/values/PetTargetValue.h
new file mode 100644
index 0000000..35705c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PetTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class PetTargetValue : public UnitCalculatedValue
+	{
+	public:
+        PetTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return (Unit*)(ai->GetBot()->GetPet()); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.cpp b/src/plugins/playerbot/strategy/values/PositionValue.cpp
new file mode 100644
index 0000000..70424b0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionValue.h"
+
+using namespace ai;
+
+PositionValue::PositionValue(PlayerbotAI* ai)
+    : ManualSetValue<ai::Position&>(ai, position), Qualified()
+{
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.h b/src/plugins/playerbot/strategy/values/PositionValue.h
new file mode 100644
index 0000000..4d453e1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.h
@@ -0,0 +1,26 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class Position
+    {
+    public:
+        Position() : valueSet(false) {}
+        void Set(double x, double y, double z) { this->x = x; this->y = y; this->z = z; this->valueSet = true; }
+        void Reset() { valueSet = false; }
+        bool isSet() { return valueSet; }
+
+        double x, y, z;
+        bool valueSet;
+    };
+
+    class PositionValue : public ManualSetValue<Position&>, public Qualified
+	{
+	public:
+        PositionValue(PlayerbotAI* ai);
+
+	private:
+        Position position;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
new file mode 100644
index 0000000..17e1c27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PossibleTargetsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+void PossibleTargetsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyUnfriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool PossibleTargetsValue::AcceptUnit(Unit* unit)
+{
+    return !unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
+            (unit->IsHostileTo(bot) || (unit->getLevel() > 1 && !unit->IsFriendlyTo(bot)));
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
new file mode 100644
index 0000000..5a97a71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PossibleTargetsValue : public NearestUnitsValue
+	{
+	public:
+        PossibleTargetsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets);
+        virtual bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiTargetValue.h b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
new file mode 100644
index 0000000..01aac86
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
@@ -0,0 +1,51 @@
+#pragma once
+#include "../Value.h"
+#include "../../../Groups/Group.h"
+
+namespace ai
+{
+    class RtiTargetValue : public UnitCalculatedValue
+    {
+    public:
+        RtiTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai)
+        {}
+
+    public:
+        static int GetRtiIndex(string rti)
+        {
+            int index = -1;
+            if(rti == "star") index = 0;
+            else if(rti == "circle") index = 1;
+            else if(rti == "diamond") index = 2;
+            else if(rti == "triangle") index = 3;
+            else if(rti == "moon") index = 4;
+            else if(rti == "square") index = 5;
+            else if(rti == "cross") index = 6;
+            else if(rti == "skull") index = 7;
+            return index;
+        }
+
+        Unit *Calculate()
+        {
+            Group *group = bot->GetGroup();
+            if(!group)
+                return NULL;
+
+            string rti = AI_VALUE(string, "rti");
+            int index = GetRtiIndex(rti);
+
+            if (index == -1)
+                return NULL;
+
+            uint64 guid = group->GetTargetIcon(index);
+            if (!guid)
+                return NULL;
+
+            Unit* unit = ai->GetUnit(ObjectGuid(guid));
+            if (!unit || unit->isDead())
+                return NULL;
+
+            return unit;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.cpp b/src/plugins/playerbot/strategy/values/RtiValue.cpp
new file mode 100644
index 0000000..3698212
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RtiValue.h"
+
+using namespace ai;
+
+RtiValue::RtiValue(PlayerbotAI* ai)
+    : ManualSetValue<string>(ai, "none")
+{
+    switch (ai->GetBot()->getClass())
+    {
+    case CLASS_DRUID:
+        value = "circle";
+        break;
+    case CLASS_ROGUE:
+        value = "star";
+        break;
+    case CLASS_SHAMAN:
+        value = "square";
+        break;
+    case CLASS_HUNTER:
+        value = "triangle";
+        break;
+    case CLASS_WARLOCK:
+    case CLASS_PALADIN:
+        value = "diamond";
+        break;
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+        value = "moon";
+        break;
+    default:
+        value = "skull";
+        break;
+    }
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.h b/src/plugins/playerbot/strategy/values/RtiValue.h
new file mode 100644
index 0000000..760485e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class RtiValue : public ManualSetValue<string>
+	{
+	public:
+        RtiValue(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SelfTargetValue.h b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
new file mode 100644
index 0000000..f64a0fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class SelfTargetValue : public UnitCalculatedValue
+	{
+	public:
+        SelfTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetBot(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
new file mode 100644
index 0000000..dec5e9f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+
+using namespace ai;
+
+bool SpellCastUsefulValue::Calculate()
+{
+    uint32 spellid = AI_VALUE2(uint32, "spell id", qualifier);
+	if (!spellid)
+		return true; // there can be known alternatives
+
+	SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+	if (!spellInfo)
+		return true; // there can be known alternatives
+
+	if (spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING ||
+		spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING_2)
+	{
+		Spell* spell = bot->GetCurrentSpell(CURRENT_MELEE_SPELL);
+		if (spell && spell->m_spellInfo->Id == spellid && spell->IsNextMeleeSwingSpell())
+			return false;
+	}
+
+    uint32 lastSpellId = AI_VALUE(LastSpellCast&, "last spell cast").id;
+    if (spellid == lastSpellId)
+    {
+        Spell* const pSpell = bot->FindCurrentSpellBySpellId(lastSpellId);
+        if (pSpell)
+            return false;
+    }
+
+    // TODO: workaround
+    if (qualifier == "windfury weapon" || qualifier == "flametongue weapon" || qualifier == "frostbrand weapon" ||
+            qualifier == "rockbiter weapon" || qualifier == "earthliving weapon" || qualifier == "spellstone")
+    {
+        Item *item = AI_VALUE2(Item*, "item for spell", spellid);
+        if (item && item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+            return false;
+    }
+
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
new file mode 100644
index 0000000..e05254e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class SpellCastUsefulValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        SpellCastUsefulValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        virtual bool Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.cpp b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
new file mode 100644
index 0000000..61755b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellIdValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+SpellIdValue::SpellIdValue(PlayerbotAI* ai) :
+        CalculatedValue<uint32>(ai, "spell id", 5)
+{
+}
+
+uint32 SpellIdValue::Calculate()
+{
+    string namepart = qualifier;
+    wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+    char firstSymbol = tolower(qualifier[0]);
+    int spellLength = wnamepart.length();
+
+    int loc = bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+            continue;
+
+        char* spellName = pSpellInfo->SpellName[loc];
+        if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+            continue;
+
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0) {
+            if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell) {
+            foundSpellId = spellId;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    Pet* pet = bot->GetPet();
+    if (!foundSpellId && pet)
+    {
+        for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            if(itr->second.state == PETSPELL_REMOVED)
+                continue;
+
+            uint32 spellId = itr->first;
+            const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+                continue;
+
+            char* spellName = pSpellInfo->SpellName[loc];
+            if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+                continue;
+
+            foundSpellId = spellId;
+        }
+    }
+
+    return foundSpellId;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.h b/src/plugins/playerbot/strategy/values/SpellIdValue.h
new file mode 100644
index 0000000..1281b38
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class SpellIdValue : public CalculatedValue<uint32>, public Qualified
+	{
+	public:
+        SpellIdValue(PlayerbotAI* ai);
+
+    public:
+        virtual uint32 Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.cpp b/src/plugins/playerbot/strategy/values/StatsValues.cpp
new file mode 100644
index 0000000..5bbfc55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsValues.h"
+
+using namespace ai;
+
+uint8 HealthValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100;
+}
+
+bool IsDeadValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->getDeathState() != ALIVE;
+}
+
+
+uint8 RageValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_RAGE)));
+}
+
+uint8 EnergyValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_ENERGY)));
+}
+
+uint8 ManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetPower(POWER_MANA)) / target->GetMaxPower(POWER_MANA)) * 100;
+}
+
+bool HasManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->GetPower(POWER_MANA);
+}
+
+
+uint8 ComboPointsValue::Calculate()
+{
+    Unit *target = GetTarget();
+    if (!target || target->GetGUID() != bot->GetComboTarget())
+        return 0;
+
+    return bot->GetComboPoints();
+}
+
+bool IsMountedValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsMounted();
+}
+
+
+bool IsInCombatValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsInCombat();
+}
+
+uint8 BagSpaceValue::Calculate()
+{
+    uint32 totalused = 0, total = 16;
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        if (bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            totalused++;
+    }
+
+    uint32 totalfree = 16 - totalused;
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+    return (static_cast<float> (totalused) / total) * 100;
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.h b/src/plugins/playerbot/strategy/values/StatsValues.h
new file mode 100644
index 0000000..4fcdbaf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.h
@@ -0,0 +1,133 @@
+#pragma once
+#include "../Value.h"
+
+class Unit;
+
+namespace ai
+{
+    class HealthValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        HealthValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsDeadValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsDeadValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class RageValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        RageValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class EnergyValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        EnergyValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class ManaValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ManaValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasManaValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasManaValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class ComboPointsValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ComboPointsValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsMountedValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsMountedValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class IsInCombatValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsInCombatValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate() ;
+    };
+
+    class BagSpaceValue : public Uint8CalculatedValue
+    {
+    public:
+        BagSpaceValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.cpp b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
new file mode 100644
index 0000000..01967f8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForTankStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForTankStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        minTankCount = 0;
+        maxDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        float threat = threatManager->getThreat(bot);
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            (minThreat >= threat &&
+            (minTankCount >= tankCount || maxDpsCount <= dpsCount)))
+        {
+            minThreat = threat;
+            minTankCount = tankCount;
+            maxDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int minTankCount;
+    int maxDpsCount;
+};
+
+
+Unit* TankTargetValue::Calculate()
+{
+    FindTargetForTankStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.h b/src/plugins/playerbot/strategy/values/TankTargetValue.h
new file mode 100644
index 0000000..fa4b4f8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class TankTargetValue : public TargetValue
+	{
+	public:
+        TankTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.cpp b/src/plugins/playerbot/strategy/values/TargetValue.cpp
new file mode 100644
index 0000000..2586bad
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TargetValue.h"
+
+using namespace ai;
+
+Unit* TargetValue::FindTarget(FindTargetStrategy* strategy)
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit)
+            continue;
+
+        ThreatManager &threatManager = unit->getThreatManager();
+        strategy->CheckAttacker(unit, &threatManager);
+    }
+
+    return strategy->GetResult();
+}
+
+void FindTargetStrategy::GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount)
+{
+    Player* bot = ai->GetBot();
+    if (tankCountCache.find(creature) != tankCountCache.end())
+    {
+        *tankCount = tankCountCache[creature];
+        *dpsCount = dpsCountCache[creature];
+        return;
+    }
+
+    *tankCount = 0;
+    *dpsCount = 0;
+
+    for (HostileReference *ref = creature->getHostileRefManager().getFirst(); ref; ref = ref->next())
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        Player *player = dynamic_cast<Player*>(victim);
+
+        if (!player)
+            continue;
+
+        if (ai->IsTank(player))
+            (*tankCount)++;
+        else
+            (*dpsCount)++;
+    }
+
+    tankCountCache[creature] = *tankCount;
+    dpsCountCache[creature] = *dpsCount;
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.h b/src/plugins/playerbot/strategy/values/TargetValue.h
new file mode 100644
index 0000000..700d51d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindTargetStrategy
+    {
+    public:
+        FindTargetStrategy(PlayerbotAI* ai)
+        {
+            result = NULL;
+            this->ai = ai;
+        }
+
+    public:
+        Unit* GetResult() { return result; }
+
+    public:
+        virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager) = 0;
+        void GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount);
+
+    protected:
+        Unit* result;
+        PlayerbotAI* ai;
+
+    protected:
+        map<Unit*, int> tankCountCache;
+        map<Unit*, int> dpsCountCache;
+    };
+
+    class TargetValue : public UnitCalculatedValue
+	{
+	public:
+        TargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    protected:
+        Unit* FindTarget(FindTargetStrategy* strategy);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.cpp b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
new file mode 100644
index 0000000..b0e0a00
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatValues.h"
+
+using namespace ai;
+
+uint8 ThreatValue::Calculate()
+{
+    if (qualifier == "aoe")
+    {
+        uint8 maxThreat = 0;
+        list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+        for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+        {
+            Unit* unit = ai->GetUnit(*i);
+            if (!unit || !unit->IsAlive())
+                continue;
+
+            uint8 threat = Calculate(unit);
+            if (!maxThreat || threat > maxThreat)
+                maxThreat = threat;
+        }
+
+        return maxThreat;
+    }
+
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    return Calculate(target);
+}
+
+uint8 ThreatValue::Calculate(Unit* target)
+{
+    if (!target)
+        return 0;
+
+    if (dynamic_cast<Player*>(target))
+        return 0;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    float botThreat = target->getThreatManager().getThreat(bot);
+    float maxThreat = 0;
+
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == bot)
+            continue;
+
+        float threat = target->getThreatManager().getThreat(player);
+        if (maxThreat < threat)
+            maxThreat = threat;
+    }
+
+    if (maxThreat <= 0)
+        return 0;
+
+    return botThreat * 100 / maxThreat;
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.h b/src/plugins/playerbot/strategy/values/ThreatValues.h
new file mode 100644
index 0000000..7301f79
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ThreatValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+        ThreatValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+
+    protected:
+    	uint8 Calculate(Unit* target);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ValueContext.h b/src/plugins/playerbot/strategy/values/ValueContext.h
new file mode 100644
index 0000000..adad335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ValueContext.h
@@ -0,0 +1,225 @@
+#pragma once
+
+#include "NearestGameObjects.h"
+#include "LogLevelValue.h"
+#include "NearestNpcsValue.h"
+#include "PossibleTargetsValue.h"
+#include "NearestAdsValue.h"
+#include "NearestCorpsesValue.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "PartyMemberToHeal.h"
+#include "PartyMemberToResurrect.h"
+#include "CurrentTargetValue.h"
+#include "SelfTargetValue.h"
+#include "MasterTargetValue.h"
+#include "LineTargetValue.h"
+#include "TankTargetValue.h"
+#include "DpsTargetValue.h"
+#include "CcTargetValue.h"
+#include "CurrentCcTargetValue.h"
+#include "PetTargetValue.h"
+#include "GrindTargetValue.h"
+#include "RtiTargetValue.h"
+#include "PartyMemberToDispel.h"
+#include "StatsValues.h"
+#include "AttackerCountValues.h"
+#include "AttackersValue.h"
+#include "AvailableLootValue.h"
+#include "AlwaysLootListValue.h"
+#include "LootStrategyValue.h"
+#include "HasAvailableLootValue.h"
+#include "LastMovementValue.h"
+#include "DistanceValue.h"
+#include "IsMovingValue.h"
+#include "IsBehindValue.h"
+#include "IsFacingValue.h"
+#include "ItemCountValue.h"
+#include "SpellIdValue.h"
+#include "ItemForSpellValue.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+#include "ChatValue.h"
+#include "HasTotemValue.h"
+#include "LeastHpTargetValue.h"
+#include "AoeHealValues.h"
+#include "RtiValue.h"
+#include "PositionValue.h"
+#include "ThreatValues.h"
+#include "DuelTargetValue.h"
+#include "InvalidTargetValue.h"
+#include "EnemyPlayerValue.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "LastSpellCastTimeValue.h"
+#include "ManaSaveLevelValue.h"
+#include "LfgValues.h"
+#include "EnemyHealerTargetValue.h"
+#include "Formations.h"
+#include "ItemUsageValue.h"
+
+namespace ai
+{
+    class ValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        ValueContext()
+        {
+            creators["nearest game objects"] = &ValueContext::nearest_game_objects;
+            creators["nearest npcs"] = &ValueContext::nearest_npcs;
+            creators["possible targets"] = &ValueContext::possible_targets;
+            creators["nearest adds"] = &ValueContext::nearest_adds;
+            creators["nearest corpses"] = &ValueContext::nearest_corpses;
+            creators["log level"] = &ValueContext::log_level;
+            creators["party member without aura"] = &ValueContext::party_member_without_aura;
+            creators["attacker without aura"] = &ValueContext::attacker_without_aura;
+            creators["party member to heal"] = &ValueContext::party_member_to_heal;
+            creators["party member to resurrect"] = &ValueContext::party_member_to_resurrect;
+            creators["current target"] = &ValueContext::current_target;
+            creators["self target"] = &ValueContext::self_target;
+            creators["master target"] = &ValueContext::master;
+            creators["line target"] = &ValueContext::line_target;
+            creators["tank target"] = &ValueContext::tank_target;
+            creators["dps target"] = &ValueContext::dps_target;
+            creators["least hp target"] = &ValueContext::least_hp_target;
+            creators["enemy player target"] = &ValueContext::enemy_player_target;
+            creators["cc target"] = &ValueContext::cc_target;
+            creators["current cc target"] = &ValueContext::current_cc_target;
+            creators["pet target"] = &ValueContext::pet_target;
+            creators["old target"] = &ValueContext::old_target;
+            creators["grind target"] = &ValueContext::grind_target;
+            creators["rti target"] = &ValueContext::rti_target;
+            creators["duel target"] = &ValueContext::duel_target;
+            creators["party member to dispel"] = &ValueContext::party_member_to_dispel;
+            creators["health"] = &ValueContext::health;
+            creators["rage"] = &ValueContext::rage;
+            creators["energy"] = &ValueContext::energy;
+            creators["mana"] = &ValueContext::mana;
+            creators["combo"] = &ValueContext::combo;
+            creators["dead"] = &ValueContext::dead;
+            creators["has mana"] = &ValueContext::has_mana;
+            creators["attacker count"] = &ValueContext::attacker_count;
+            creators["my attacker count"] = &ValueContext::my_attacker_count;
+            creators["has aggro"] = &ValueContext::has_aggro;
+            creators["mounted"] = &ValueContext::mounted;
+
+            creators["can loot"] = &ValueContext::can_loot;
+            creators["loot target"] = &ValueContext::loot_target;
+            creators["available loot"] = &ValueContext::available_loot;
+            creators["has available loot"] = &ValueContext::has_available_loot;
+            creators["always loot list"] = &ValueContext::always_loot_list;
+            creators["loot strategy"] = &ValueContext::loot_strategy;
+            creators["last movement"] = &ValueContext::last_movement;
+            creators["distance"] = &ValueContext::distance;
+            creators["moving"] = &ValueContext::moving;
+            creators["swimming"] = &ValueContext::swimming;
+            creators["behind"] = &ValueContext::behind;
+            creators["facing"] = &ValueContext::facing;
+
+            creators["item count"] = &ValueContext::item_count;
+            creators["inventory items"] = &ValueContext::inventory_item;
+
+            creators["spell id"] = &ValueContext::spell_id;
+            creators["item for spell"] = &ValueContext::item_for_spell;
+            creators["spell cast useful"] = &ValueContext::spell_cast_useful;
+            creators["last spell cast"] = &ValueContext::last_spell_cast;
+            creators["last spell cast time"] = &ValueContext::last_spell_cast_time;
+            creators["chat"] = &ValueContext::chat;
+            creators["has totem"] = &ValueContext::has_totem;
+
+            creators["aoe heal"] = &ValueContext::aoe_heal;
+
+            creators["rti"] = &ValueContext::rti;
+            creators["position"] = &ValueContext::position;
+            creators["threat"] = &ValueContext::threat;
+
+            creators["balance"] = &ValueContext::balance;
+            creators["attackers"] = &ValueContext::attackers;
+            creators["invalid target"] = &ValueContext::invalid_target;
+            creators["mana save level"] = &ValueContext::mana_save_level;
+            creators["combat"] = &ValueContext::combat;
+            creators["lfg proposal"] = &ValueContext::lfg_proposal;
+            creators["bag space"] = &ValueContext::bag_space;
+            creators["enemy healer target"] = &ValueContext::enemy_healer_target;
+            creators["formation"] = &ValueContext::formation;
+            creators["item usage"] = &ValueContext::item_usage;
+        }
+
+    private:
+        static UntypedValue* item_usage(PlayerbotAI* ai) { return new ItemUsageValue(ai); }
+        static UntypedValue* formation(PlayerbotAI* ai) { return new FormationValue(ai); }
+        static UntypedValue* mana_save_level(PlayerbotAI* ai) { return new ManaSaveLevelValue(ai); }
+        static UntypedValue* invalid_target(PlayerbotAI* ai) { return new InvalidTargetValue(ai); }
+        static UntypedValue* balance(PlayerbotAI* ai) { return new BalancePercentValue(ai); }
+        static UntypedValue* attackers(PlayerbotAI* ai) { return new AttackersValue(ai); }
+
+        static UntypedValue* position(PlayerbotAI* ai) { return new PositionValue(ai); }
+        static UntypedValue* rti(PlayerbotAI* ai) { return new RtiValue(ai); }
+
+        static UntypedValue* aoe_heal(PlayerbotAI* ai) { return new AoeHealValue(ai); }
+
+        static UntypedValue* chat(PlayerbotAI* ai) { return new ChatValue(ai); }
+        static UntypedValue* last_spell_cast(PlayerbotAI* ai) { return new LastSpellCastValue(ai); }
+        static UntypedValue* last_spell_cast_time(PlayerbotAI* ai) { return new LastSpellCastTimeValue(ai); }
+        static UntypedValue* spell_cast_useful(PlayerbotAI* ai) { return new SpellCastUsefulValue(ai); }
+        static UntypedValue* item_for_spell(PlayerbotAI* ai) { return new ItemForSpellValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new SpellIdValue(ai); }
+        static UntypedValue* inventory_item(PlayerbotAI* ai) { return new InventoryItemValue(ai); }
+        static UntypedValue* item_count(PlayerbotAI* ai) { return new ItemCountValue(ai); }
+        static UntypedValue* behind(PlayerbotAI* ai) { return new IsBehindValue(ai); }
+        static UntypedValue* facing(PlayerbotAI* ai) { return new IsFacingValue(ai); }
+        static UntypedValue* moving(PlayerbotAI* ai) { return new IsMovingValue(ai); }
+        static UntypedValue* swimming(PlayerbotAI* ai) { return new IsSwimmingValue(ai); }
+        static UntypedValue* distance(PlayerbotAI* ai) { return new DistanceValue(ai); }
+        static UntypedValue* last_movement(PlayerbotAI* ai) { return new LastMovementValue(ai); }
+
+        static UntypedValue* can_loot(PlayerbotAI* ai) { return new CanLootValue(ai); }
+        static UntypedValue* available_loot(PlayerbotAI* ai) { return new AvailableLootValue(ai); }
+        static UntypedValue* loot_target(PlayerbotAI* ai) { return new LootTargetValue(ai); }
+        static UntypedValue* has_available_loot(PlayerbotAI* ai) { return new HasAvailableLootValue(ai); }
+        static UntypedValue* always_loot_list(PlayerbotAI* ai) { return new AlwaysLootListValue(ai); }
+        static UntypedValue* loot_strategy(PlayerbotAI* ai) { return new LootStrategyValue(ai); }
+
+        static UntypedValue* attacker_count(PlayerbotAI* ai) { return new AttackerCountValue(ai); }
+        static UntypedValue* my_attacker_count(PlayerbotAI* ai) { return new MyAttackerCountValue(ai); }
+        static UntypedValue* has_aggro(PlayerbotAI* ai) { return new HasAggroValue(ai); }
+        static UntypedValue* mounted(PlayerbotAI* ai) { return new IsMountedValue(ai); }
+        static UntypedValue* health(PlayerbotAI* ai) { return new HealthValue(ai); }
+        static UntypedValue* rage(PlayerbotAI* ai) { return new RageValue(ai); }
+        static UntypedValue* energy(PlayerbotAI* ai) { return new EnergyValue(ai); }
+        static UntypedValue* mana(PlayerbotAI* ai) { return new ManaValue(ai); }
+        static UntypedValue* combo(PlayerbotAI* ai) { return new ComboPointsValue(ai); }
+        static UntypedValue* dead(PlayerbotAI* ai) { return new IsDeadValue(ai); }
+        static UntypedValue* has_mana(PlayerbotAI* ai) { return new HasManaValue(ai); }
+        static UntypedValue* nearest_game_objects(PlayerbotAI* ai) { return new NearestGameObjects(ai); }
+        static UntypedValue* log_level(PlayerbotAI* ai) { return new LogLevelValue(ai); }
+        static UntypedValue* nearest_npcs(PlayerbotAI* ai) { return new NearestNpcsValue(ai); }
+        static UntypedValue* nearest_corpses(PlayerbotAI* ai) { return new NearestCorpsesValue(ai); }
+        static UntypedValue* possible_targets(PlayerbotAI* ai) { return new PossibleTargetsValue(ai); }
+        static UntypedValue* nearest_adds(PlayerbotAI* ai) { return new NearestAdsValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new PartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* attacker_without_aura(PlayerbotAI* ai) { return new AttackerWithoutAuraTargetValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new PartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_resurrect(PlayerbotAI* ai) { return new PartyMemberToResurrect(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new PartyMemberToDispel(ai); }
+        static UntypedValue* current_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* old_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* self_target(PlayerbotAI* ai) { return new SelfTargetValue(ai); }
+        static UntypedValue* master(PlayerbotAI* ai) { return new MasterTargetValue(ai); }
+        static UntypedValue* line_target(PlayerbotAI* ai) { return new LineTargetValue(ai); }
+        static UntypedValue* tank_target(PlayerbotAI* ai) { return new TankTargetValue(ai); }
+        static UntypedValue* dps_target(PlayerbotAI* ai) { return new DpsTargetValue(ai); }
+        static UntypedValue* least_hp_target(PlayerbotAI* ai) { return new LeastHpTargetValue(ai); }
+        static UntypedValue* enemy_player_target(PlayerbotAI* ai) { return new EnemyPlayerValue(ai); }
+        static UntypedValue* cc_target(PlayerbotAI* ai) { return new CcTargetValue(ai); }
+        static UntypedValue* current_cc_target(PlayerbotAI* ai) { return new CurrentCcTargetValue(ai); }
+        static UntypedValue* pet_target(PlayerbotAI* ai) { return new PetTargetValue(ai); }
+        static UntypedValue* grind_target(PlayerbotAI* ai) { return new GrindTargetValue(ai); }
+        static UntypedValue* rti_target(PlayerbotAI* ai) { return new RtiTargetValue(ai); }
+        static UntypedValue* duel_target(PlayerbotAI* ai) { return new DuelTargetValue(ai); }
+        static UntypedValue* has_totem(PlayerbotAI* ai) { return new HasTotemValue(ai); }
+        static UntypedValue* threat(PlayerbotAI* ai) { return new ThreatValue(ai); }
+        static UntypedValue* combat(PlayerbotAI* ai) { return new IsInCombatValue(ai); }
+        static UntypedValue* lfg_proposal(PlayerbotAI* ai) { return new LfgProposalValue(ai); }
+        static UntypedValue* bag_space(PlayerbotAI* ai) { return new BagSpaceValue(ai); }
+        static UntypedValue* enemy_healer_target(PlayerbotAI* ai) { return new EnemyHealerTargetValue(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.cpp b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
new file mode 100644
index 0000000..7b3a07f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
@@ -0,0 +1,162 @@
+#include "../../../../pchdef.h"
+#include "../../../playerbot.h"
+#include "../Formations.h"
+#include "Arrow.h"
+
+using namespace ai;
+
+WorldLocation ArrowFormation::GetLocation()
+{
+    Build();
+
+    int tankLines = 1 + tanks.Size() / 6;
+    int meleeLines = 1 + melee.Size() / 6;
+    int rangedLines = 1 + ranged.Size() / 6;
+    int healerLines = 1 + healers.Size() / 6;
+    float offset = 0;
+
+    Player* master = ai->GetMaster();
+    float orientation = master->GetOrientation();
+    MultiLineUnitPlacer placer(orientation);
+
+    tanks.PlaceUnits(&placer);
+
+    offset = tankLines * sPlayerbotAIConfig.followDistance;
+    melee.PlaceUnits(&placer);
+    melee.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += meleeLines * sPlayerbotAIConfig.followDistance + sPlayerbotAIConfig.tooCloseDistance;
+    ranged.PlaceUnits(&placer);
+    ranged.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += rangedLines * sPlayerbotAIConfig.followDistance;
+    healers.PlaceUnits(&placer);
+    healers.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    float x = master->GetPositionX() - masterUnit->GetX() + botUnit->GetX();
+    float y = master->GetPositionY() - masterUnit->GetY() + botUnit->GetY();
+    float z = master->GetPositionZ();
+
+    float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+    if (ground <= INVALID_HEIGHT)
+        return Formation::NullLocation;
+
+    return WorldLocation(master->GetMapId(), x, y, 0.05f + ground);
+
+
+}
+
+void ArrowFormation::Build()
+{
+    if (built)
+        return;
+
+    FillSlotsExceptMaster();
+    AddMasterToSlot();
+
+    built = true;
+}
+
+FormationSlot* ArrowFormation::FindSlot(Player* member)
+{
+    if (ai->IsTank(member))
+        return &tanks;
+    else if (ai->IsHeal(member))
+        return &healers;
+    else if (ai->IsRanged(member))
+        return &ranged;
+    else
+        return &melee;
+}
+
+void ArrowFormation::FillSlotsExceptMaster()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == bot)
+            FindSlot(member)->AddLast(botUnit = new FormationUnit(index, false));
+        else if (member != ai->GetMaster())
+            FindSlot(member)->AddLast(new FormationUnit(index, false));
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void ArrowFormation::AddMasterToSlot()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == ai->GetMaster())
+        {
+            FindSlot(member)->InsertAtCenter(masterUnit = new FormationUnit(index, true));
+            break;
+        }
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void FormationSlot::PlaceUnits(UnitPlacer* placer)
+{
+    uint32 index = 0;
+    uint32 count = units.size();
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(placer->Place(unit, index, count));
+        index++;
+    }
+}
+
+UnitPosition MultiLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    SingleLineUnitPlacer placer(orientation);
+    if (count <= 6)
+        return placer.Place(unit, index, count);
+
+    int lineNo = index / 6;
+    int indexInLine = index % 6;
+    int lineSize = max(count - lineNo * 6, uint32(6));
+    float x = cos(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    float y = sin(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    return placer.Place(unit, indexInLine, lineSize);
+}
+
+UnitPosition SingleLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    float angle = orientation - M_PI / 2.0f;
+    float x = cos(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    float y = sin(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    return UnitPosition(x, y);
+}
+
+void FormationSlot::Move(float dx, float dy)
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(unit->GetX() + dx, unit->GetY() + dy);
+    }
+}
+
+FormationSlot::~FormationSlot()
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        delete unit;
+    }
+    units.clear();
+}
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.h b/src/plugins/playerbot/strategy/values/formations/Arrow.h
new file mode 100644
index 0000000..e302c87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.h
@@ -0,0 +1,109 @@
+#pragma once
+
+namespace ai
+{
+    class UnitPosition
+    {
+    public:
+        UnitPosition(float x, float y) : x(x), y(y) {}
+        UnitPosition(const UnitPosition& other) { x = other.x; y = other.y; }
+        float x, y;
+    };
+
+    class FormationUnit
+    {
+    public:
+        FormationUnit(uint32 groupIndex, bool master) : groupIndex(groupIndex), master(master), position(0, 0) {}
+        FormationUnit(const FormationUnit& other) : position(other.position.x, other.position.y)
+        {
+            groupIndex = other.groupIndex;
+            master = other.master;
+        }
+
+    public:
+        uint32 GetGroupIdex() { return groupIndex; }
+        void SetLocation(UnitPosition pos) { position = pos; }
+        void SetLocation(float x, float y) { position.x = x; position.y = y; }
+        float GetX() { return position.x; }
+        float GetY() { return position.y; }
+
+    private:
+        uint32 groupIndex;
+        bool master;
+        UnitPosition position;
+    };
+
+    class UnitPlacer
+    {
+    public:
+        UnitPlacer() {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count) = 0;
+    };
+
+    class FormationSlot
+    {
+    public:
+        FormationSlot() {}
+        virtual ~FormationSlot();
+
+    public:
+        void AddLast(FormationUnit* unit) { units.push_back(unit); }
+        void InsertAtCenter(FormationUnit* unit) { units.insert(units.begin() + (units.size() + 1) / 2, unit); }
+        void PlaceUnits(UnitPlacer* placer);
+        void Move(float dx, float dy);
+        int Size() { return units.size(); }
+
+    private:
+        WorldLocation center;
+        vector<FormationUnit*> units;
+    };
+
+
+    class MultiLineUnitPlacer : public UnitPlacer
+    {
+    public:
+        MultiLineUnitPlacer(float orientation) : UnitPlacer(), orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class SingleLineUnitPlacer
+    {
+    public:
+        SingleLineUnitPlacer(float orientation) : orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class ArrowFormation : public MoveFormation
+    {
+    public:
+        ArrowFormation(PlayerbotAI* ai) : MoveFormation(ai, "arrow"), built(false), masterUnit(NULL), botUnit(NULL) {}
+
+    public:
+        virtual WorldLocation GetLocation();
+
+    private:
+        void Build();
+        void FillSlotsExceptMaster();
+        void AddMasterToSlot();
+        FormationSlot* FindSlot(Player* member);
+
+    private:
+        FormationSlot tanks, melee, ranged, healers;
+        FormationUnit *masterUnit, *botUnit;
+        bool built;
+    };
+
+}
+
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
new file mode 100644
index 0000000..039fd53
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
@@ -0,0 +1,76 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockMultipliers.h"
+#include "DpsWarlockStrategy.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+class DpsWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarlockStrategyActionNodeFactory()
+    {
+        creators["shadow bolt"] = &shadow_bolt;
+    }
+private:
+    static ActionNode* shadow_bolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shadow bolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarlockStrategy::DpsWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarlockStrategyActionNodeFactory());
+}
+
+
+NextAction** DpsWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("incinirate", 10.0f), new NextAction("shadow bolt", 10.0f), NULL);
+}
+
+void DpsWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"shadow trance",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"backlash",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+}
+
+void DpsAoeWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("rain of fire", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("seed of corruption", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("shadowfury", 29.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "corruption on attacker",
+        NextAction::array(0, new NextAction("corruption on attacker", 28.0f), NULL)));
+
+}
+
+void DpsWarlockDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "corruption",
+        NextAction::array(0, new NextAction("corruption", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
new file mode 100644
index 0000000..846f9df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        DpsWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "dps"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+
+    class DpsAoeWarlockStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeWarlockStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsWarlockDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarlockDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
new file mode 100644
index 0000000..3dc73c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockNonCombatStrategyActionNodeFactory()
+    {
+        creators["fel armor"] = &fel_armor;
+        creators["demon armor"] = &demon_armor;
+    }
+private:
+    static ActionNode* fel_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fel armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* demon_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demon armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon skin"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockNonCombatStrategy::GenericWarlockNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockNonCombatStrategyActionNodeFactory());
+}
+
+void GenericWarlockNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "demon armor",
+        NextAction::array(0, new NextAction("fel armor", 21.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no healthstone",
+		NextAction::array(0, new NextAction("create healthstone", 15.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no firestone",
+		NextAction::array(0, new NextAction("create firestone", 14.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no spellstone",
+		NextAction::array(0, new NextAction("create spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "spellstone",
+        NextAction::array(0, new NextAction("spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon imp", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
new file mode 100644
index 0000000..c5e483f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarlockNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
new file mode 100644
index 0000000..e880061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
@@ -0,0 +1,74 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["banish"] = &banish;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* banish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("banish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("fear"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockStrategy::GenericWarlockStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** GenericWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void GenericWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "curse of agony",
+        NextAction::array(0, new NextAction("curse of agony", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("drain life", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("life tap", ACTION_EMERGENCY + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("drain soul", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "banish",
+        NextAction::array(0, new NextAction("banish", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "fear",
+        NextAction::array(0, new NextAction("fear on cc", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "immolate",
+        NextAction::array(0, new NextAction("immolate", 19.0f), new NextAction("conflagrate", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
new file mode 100644
index 0000000..473da59
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "warlock"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
new file mode 100644
index 0000000..cb4f5a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "TankWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["summon felguard"] = &summon_felguard;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* summon_felguard(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon felguard",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("summon voidwalker"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarlockStrategy::TankWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** TankWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void TankWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon felguard", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
new file mode 100644
index 0000000..9cdd6e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+
+namespace ai
+{
+    class TankWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        TankWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "tank"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
new file mode 100644
index 0000000..0a01ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.h b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
new file mode 100644
index 0000000..fb1689a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
@@ -0,0 +1,176 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+	class CastDemonSkinAction : public CastBuffSpellAction {
+	public:
+		CastDemonSkinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon skin") {}
+	};
+
+	class CastDemonArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastDemonArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon armor") {}
+	};
+
+	class CastFelArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastFelArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fel armor") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastShadowBoltAction, "shadow bolt")
+    END_SPELL_ACTION()
+
+	class CastDrainSoulAction : public CastSpellAction
+	{
+	public:
+		CastDrainSoulAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain soul") {}
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(uint8, "item count", "soul shard") < 2;
+		}
+	};
+
+	class CastDrainManaAction : public CastSpellAction
+	{
+	public:
+		CastDrainManaAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain mana") {}
+	};
+
+	class CastDrainLifeAction : public CastSpellAction
+	{
+	public:
+		CastDrainLifeAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain life") {}
+	};
+
+	class CastCurseOfAgonyAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfAgonyAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of agony") {}
+	};
+
+	class CastCurseOfWeaknessAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfWeaknessAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of weakness") {}
+	};
+
+	class CastCorruptionAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "corruption") {}
+	};
+
+	class CastCorruptionOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+	public:
+	    CastCorruptionOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "corruption") {}
+	};
+
+
+	class CastSummonVoidwalkerAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonVoidwalkerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon voidwalker") {}
+	};
+
+	class CastSummonFelguardAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonFelguardAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon felguard") {}
+	};
+
+	class CastSummonImpAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonImpAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon imp") {}
+	};
+
+	class CastCreateHealthstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateHealthstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create healthstone") {}
+	};
+
+	class CastCreateFirestoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateFirestoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create firestone") {}
+	};
+
+	class CastCreateSpellstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateSpellstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create spellstone") {}
+	};
+
+    class CastBanishAction : public CastBuffSpellAction
+    {
+    public:
+        CastBanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "banish on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "banish"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("banish", GetTarget()); }
+    };
+
+    class CastSeedOfCorruptionAction : public CastDebuffSpellAction
+    {
+    public:
+        CastSeedOfCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "seed of corruption") {}
+    };
+
+    class CastRainOfFireAction : public CastSpellAction
+    {
+    public:
+        CastRainOfFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "rain of fire") {}
+    };
+
+    class CastShadowfuryAction : public CastSpellAction
+    {
+    public:
+        CastShadowfuryAction(PlayerbotAI* ai) : CastSpellAction(ai, "shadowfury") {}
+    };
+
+    class CastImmolateAction : public CastDebuffSpellAction
+    {
+    public:
+        CastImmolateAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "immolate") {}
+    };
+
+    class CastConflagrateAction : public CastSpellAction
+    {
+    public:
+        CastConflagrateAction(PlayerbotAI* ai) : CastSpellAction(ai, "conflagrate") {}
+    };
+
+    class CastIncinirateAction : public CastSpellAction
+    {
+    public:
+        CastIncinirateAction(PlayerbotAI* ai) : CastSpellAction(ai, "incinirate") {}
+    };
+
+    class CastFearAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFearAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "fear") {}
+    };
+
+    class CastFearOnCcAction : public CastBuffSpellAction
+    {
+    public:
+        CastFearOnCcAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fear on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "fear"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("fear", GetTarget()); }
+    };
+
+    class CastLifeTapAction: public CastSpellAction
+    {
+    public:
+        CastLifeTapAction(PlayerbotAI* ai) : CastSpellAction(ai, "life tap") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.lowHealth; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
new file mode 100644
index 0000000..8c25fd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
@@ -0,0 +1,183 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+#include "WarlockAiObjectContext.h"
+#include "DpsWarlockStrategy.h"
+#include "GenericWarlockNonCombatStrategy.h"
+#include "TankWarlockStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarlockTriggers.h"
+#include "../NamedObjectContext.h"
+#include "../actions/UseItemAction.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warlock::StrategyFactoryInternal::nc;
+                creators["pull"] = &warlock::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warlock::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &warlock::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarlockNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeWarlockStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsWarlockDebuffStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["dps"] = &warlock::CombatStrategyFactoryInternal::dps;
+                creators["tank"] = &warlock::CombatStrategyFactoryInternal::tank;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarlockStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarlockStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["shadow trance"] = &TriggerFactoryInternal::shadow_trance;
+                creators["demon armor"] = &TriggerFactoryInternal::demon_armor;
+                creators["no healthstone"] = &TriggerFactoryInternal::HasHealthstone;
+                creators["no firestone"] = &TriggerFactoryInternal::HasFirestone;
+                creators["no spellstone"] = &TriggerFactoryInternal::HasSpellstone;
+                creators["corruption"] = &TriggerFactoryInternal::corruption;
+                creators["corruption on attacker"] = &TriggerFactoryInternal::corruption_on_attacker;
+                creators["curse of agony"] = &TriggerFactoryInternal::curse_of_agony;
+                creators["banish"] = &TriggerFactoryInternal::banish;
+                creators["spellstone"] = &TriggerFactoryInternal::spellstone;
+                creators["backlash"] = &TriggerFactoryInternal::backlash;
+                creators["fear"] = &TriggerFactoryInternal::fear;
+                creators["immolate"] = &TriggerFactoryInternal::immolate;
+
+
+            }
+
+        private:
+            static Trigger* shadow_trance(PlayerbotAI* ai) { return new ShadowTranceTrigger(ai); }
+            static Trigger* demon_armor(PlayerbotAI* ai) { return new DemonArmorTrigger(ai); }
+            static Trigger* HasHealthstone(PlayerbotAI* ai) { return new HasHealthstoneTrigger(ai); }
+            static Trigger* HasFirestone(PlayerbotAI* ai) { return new HasFirestoneTrigger(ai); }
+            static Trigger* HasSpellstone(PlayerbotAI* ai) { return new HasSpellstoneTrigger(ai); }
+            static Trigger* corruption(PlayerbotAI* ai) { return new CorruptionTrigger(ai); }
+            static Trigger* corruption_on_attacker(PlayerbotAI* ai) { return new CorruptionOnAttackerTrigger(ai); }
+            static Trigger* curse_of_agony(PlayerbotAI* ai) { return new CurseOfAgonyTrigger(ai); }
+            static Trigger* banish(PlayerbotAI* ai) { return new BanishTrigger(ai); }
+            static Trigger* spellstone(PlayerbotAI* ai) { return new SpellstoneTrigger(ai); }
+            static Trigger* backlash(PlayerbotAI* ai) { return new BacklashTrigger(ai); }
+            static Trigger* fear(PlayerbotAI* ai) { return new FearTrigger(ai); }
+            static Trigger* immolate(PlayerbotAI* ai) { return new ImmolateTrigger(ai); }
+
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["summon imp"] = &AiObjectContextInternal::summon_imp;
+                creators["fel armor"] = &AiObjectContextInternal::fel_armor;
+                creators["demon armor"] = &AiObjectContextInternal::demon_armor;
+                creators["demon skin"] = &AiObjectContextInternal::demon_skin;
+                creators["create healthstone"] = &AiObjectContextInternal::create_healthstone;
+                creators["create firestone"] = &AiObjectContextInternal::create_firestone;
+                creators["create spellstone"] = &AiObjectContextInternal::create_spellstone;
+                creators["spellstone"] = &AiObjectContextInternal::spellstone;
+                creators["summon voidwalker"] = &AiObjectContextInternal::summon_voidwalker;
+                creators["summon felguard"] = &AiObjectContextInternal::summon_felguard;
+                creators["immolate"] = &AiObjectContextInternal::immolate;
+                creators["corruption"] = &AiObjectContextInternal::corruption;
+                creators["corruption on attacker"] = &AiObjectContextInternal::corruption_on_attacker;
+                creators["curse of agony"] = &AiObjectContextInternal::curse_of_agony;
+                creators["shadow bolt"] = &AiObjectContextInternal::shadow_bolt;
+                creators["drain soul"] = &AiObjectContextInternal::drain_soul;
+                creators["drain mana"] = &AiObjectContextInternal::drain_mana;
+                creators["drain life"] = &AiObjectContextInternal::drain_life;
+                creators["banish"] = &AiObjectContextInternal::banish;
+                creators["seed of corruption"] = &AiObjectContextInternal::seed_of_corruption;
+                creators["rain of fire"] = &AiObjectContextInternal::rain_of_fire;
+                creators["shadowfury"] = &AiObjectContextInternal::shadowfury;
+                creators["life tap"] = &AiObjectContextInternal::life_tap;
+                creators["fear"] = &AiObjectContextInternal::fear;
+                creators["fear on cc"] = &AiObjectContextInternal::fear_on_cc;
+                creators["incinirate"] = &AiObjectContextInternal::incinirate;
+                creators["conflagrate"] = &AiObjectContextInternal::conflagrate;
+            }
+
+        private:
+            static Action* conflagrate(PlayerbotAI* ai) { return new CastConflagrateAction(ai); }
+            static Action* incinirate(PlayerbotAI* ai) { return new CastIncinirateAction(ai); }
+            static Action* fear_on_cc(PlayerbotAI* ai) { return new CastFearOnCcAction(ai); }
+            static Action* fear(PlayerbotAI* ai) { return new CastFearAction(ai); }
+            static Action* immolate(PlayerbotAI* ai) { return new CastImmolateAction(ai); }
+            static Action* summon_imp(PlayerbotAI* ai) { return new CastSummonImpAction(ai); }
+            static Action* fel_armor(PlayerbotAI* ai) { return new CastFelArmorAction(ai); }
+            static Action* demon_armor(PlayerbotAI* ai) { return new CastDemonArmorAction(ai); }
+            static Action* demon_skin(PlayerbotAI* ai) { return new CastDemonSkinAction(ai); }
+            static Action* create_healthstone(PlayerbotAI* ai) { return new CastCreateHealthstoneAction(ai); }
+            static Action* create_firestone(PlayerbotAI* ai) { return new CastCreateFirestoneAction(ai); }
+            static Action* create_spellstone(PlayerbotAI* ai) { return new CastCreateSpellstoneAction(ai); }
+            static Action* spellstone(PlayerbotAI* ai) { return new UseSpellItemAction(ai, "spellstone", true); }
+            static Action* summon_voidwalker(PlayerbotAI* ai) { return new CastSummonVoidwalkerAction(ai); }
+            static Action* summon_felguard(PlayerbotAI* ai) { return new CastSummonFelguardAction(ai); }
+            static Action* corruption(PlayerbotAI* ai) { return new CastCorruptionAction(ai); }
+            static Action* corruption_on_attacker(PlayerbotAI* ai) { return new CastCorruptionOnAttackerAction(ai); }
+            static Action* curse_of_agony(PlayerbotAI* ai) { return new CastCurseOfAgonyAction(ai); }
+            static Action* shadow_bolt(PlayerbotAI* ai) { return new CastShadowBoltAction(ai); }
+            static Action* drain_soul(PlayerbotAI* ai) { return new CastDrainSoulAction(ai); }
+            static Action* drain_mana(PlayerbotAI* ai) { return new CastDrainManaAction(ai); }
+            static Action* drain_life(PlayerbotAI* ai) { return new CastDrainLifeAction(ai); }
+            static Action* banish(PlayerbotAI* ai) { return new CastBanishAction(ai); }
+            static Action* seed_of_corruption(PlayerbotAI* ai) { return new CastSeedOfCorruptionAction(ai); }
+            static Action* rain_of_fire(PlayerbotAI* ai) { return new CastRainOfFireAction(ai); }
+            static Action* shadowfury(PlayerbotAI* ai) { return new CastShadowfuryAction(ai); }
+            static Action* life_tap(PlayerbotAI* ai) { return new CastLifeTapAction(ai); }
+
+        };
+    };
+};
+
+
+
+WarlockAiObjectContext::WarlockAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warlock::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warlock::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warlock::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warlock::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
new file mode 100644
index 0000000..0d3fa27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarlockAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarlockAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
new file mode 100644
index 0000000..a75926a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
new file mode 100644
index 0000000..25e5130
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
@@ -0,0 +1,19 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+bool DemonArmorTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("demon skin", target) &&
+		!ai->HasAura("demon armor", target) &&
+		!ai->HasAura("fel armor", target);
+}
+
+bool SpellstoneTrigger::IsActive()
+{
+    return BuffTrigger::IsActive() && AI_VALUE2(uint8, "item count", getName()) > 0;
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
new file mode 100644
index 0000000..796f884
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	class DemonArmorTrigger : public BuffTrigger
+	{
+	public:
+		DemonArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "demon armor") {}
+		virtual bool IsActive();
+	};
+
+    class SpellstoneTrigger : public BuffTrigger
+    {
+    public:
+        SpellstoneTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "spellstone") {}
+        virtual bool IsActive();
+    };
+
+    DEBUFF_TRIGGER(CurseOfAgonyTrigger, "curse of agony", "curse of agony");
+    DEBUFF_TRIGGER(CorruptionTrigger, "corruption", "corruption");
+
+    class CorruptionOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        CorruptionOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "corruption") {}
+    };
+
+    DEBUFF_TRIGGER(ImmolateTrigger, "immolate", "immolate");
+
+    class ShadowTranceTrigger : public HasAuraTrigger
+    {
+    public:
+        ShadowTranceTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "shadow trance") {}
+    };
+
+    class BacklashTrigger : public HasAuraTrigger
+    {
+    public:
+        BacklashTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "backlash") {}
+    };
+
+    class BanishTrigger : public HasCcTargetTrigger
+    {
+    public:
+        BanishTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "banish") {}
+    };
+
+    class WarlockConjuredItemTrigger : public ItemCountTrigger
+    {
+    public:
+        WarlockConjuredItemTrigger(PlayerbotAI* ai, string item) : ItemCountTrigger(ai, item, 1) {}
+
+        virtual bool IsActive() { return ItemCountTrigger::IsActive() && AI_VALUE2(uint8, "item count", "soul shard") > 0; }
+    };
+
+    class HasSpellstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasSpellstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "spellstone") {}
+    };
+
+    class HasFirestoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasFirestoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "firestone") {}
+    };
+
+    class HasHealthstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasHealthstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "healthstone") {}
+    };
+
+    class FearTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FearTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "fear") {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
new file mode 100644
index 0000000..7b13bec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
@@ -0,0 +1,130 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "DpsWarriorStrategy.h"
+
+using namespace ai;
+
+class DpsWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarriorStrategyActionNodeFactory()
+    {
+        creators["overpower"] = &overpower;
+        creators["melee"] = &melee;
+        creators["charge"] = &charge;
+        creators["bloodthirst"] = &bloodthirst;
+        creators["rend"] = &rend;
+        creators["mocking blow"] = &mocking_blow;
+        creators["death wish"] = &death_wish;
+        creators["execute"] = &execute;
+    }
+private:
+    static ActionNode* overpower(PlayerbotAI* ai)
+    {
+        return new ActionNode ("overpower",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("charge"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* charge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("charge",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bloodthirst(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bloodthirst",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mocking_blow(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mocking blow",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* death_wish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("death wish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("berserker rage"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* execute(PlayerbotAI* ai)
+    {
+        return new ActionNode ("execute",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarriorStrategy::DpsWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarriorStrategyActionNodeFactory());
+}
+
+NextAction** DpsWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("bloodthirst", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("charge", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "target critical health",
+        NextAction::array(0, new NextAction("execute", ACTION_HIGH + 4), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hamstring",
+		NextAction::array(0, new NextAction("hamstring", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"victory rush",
+		NextAction::array(0, new NextAction("victory rush", ACTION_HIGH + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "death wish",
+        NextAction::array(0, new NextAction("death wish", ACTION_HIGH + 2), NULL)));
+}
+
+
+void DpsWarrirorAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "rend on attacker",
+        NextAction::array(0, new NextAction("rend on attacker", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("cleave", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
new file mode 100644
index 0000000..3ef29c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class DpsWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        DpsWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class DpsWarrirorAoeStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarrirorAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
new file mode 100644
index 0000000..6bd7d08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "GenericWarriorNonCombatStrategy.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
new file mode 100644
index 0000000..1041a2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarriorNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarriorNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+   };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
new file mode 100644
index 0000000..4d7b851
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericWarriorStrategy.h"
+#include "WarriorAiObjectContext.h"
+
+using namespace ai;
+
+class GenericWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarriorStrategyActionNodeFactory()
+    {
+        creators["hamstring"] = &hamstring;
+        creators["heroic strike"] = &heroic_strike;
+        creators["battle shout"] = &battle_shout;
+    }
+private:
+    static ActionNode* hamstring(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hamstring",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* heroic_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("heroic strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* battle_shout(PlayerbotAI* ai)
+    {
+        return new ActionNode ("battle shout",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarriorStrategy::GenericWarriorStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarriorStrategyActionNodeFactory());
+}
+
+void GenericWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "battle shout",
+        NextAction::array(0, new NextAction("battle shout", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rend",
+        NextAction::array(0, new NextAction("rend", ACTION_NORMAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bloodrage",
+        NextAction::array(0, new NextAction("bloodrage", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash",
+        NextAction::array(0, new NextAction("shield bash", ACTION_INTERRUPT + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash on enemy healer",
+        NextAction::array(0, new NextAction("shield bash on enemy healer", ACTION_INTERRUPT + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("intimidating shout", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
new file mode 100644
index 0000000..0ef2dcf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericWarriorStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "warrior"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
new file mode 100644
index 0000000..5bf206c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "TankWarriorStrategy.h"
+
+using namespace ai;
+
+class TankWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankWarriorStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["shield wall"] = &shield_wall;
+        creators["rend"] = &rend;
+        creators["revenge"] = &revenge;
+        creators["devastate"] = &devastate;
+        creators["shockwave"] = &shockwave;
+        creators["taunt"] = &taunt;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* shield_wall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shield wall",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shield block"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* revenge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("revenge",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* devastate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("devastate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sunder armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* shockwave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shockwave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("cleave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* taunt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("taunt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mocking blow"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarriorStrategy::TankWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new TankWarriorStrategyActionNodeFactory());
+}
+
+NextAction** TankWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("devastate", ACTION_NORMAL + 1), new NextAction("revenge", ACTION_NORMAL + 1), NULL);
+}
+
+void TankWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium rage available",
+        NextAction::array(0, new NextAction("shield slam", ACTION_NORMAL + 2), new NextAction("heroic strike", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "disarm",
+        NextAction::array(0, new NextAction("disarm", ACTION_NORMAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("taunt", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("shield wall", ACTION_MEDIUM_HEAL), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("last stand", ACTION_EMERGENCY + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("shockwave", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2),  new NextAction("cleave", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("challenging shout", ACTION_HIGH + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"concussion blow",
+		NextAction::array(0, new NextAction("concussion blow", ACTION_INTERRUPT), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "sword and board",
+        NextAction::array(0, new NextAction("shield slam", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
new file mode 100644
index 0000000..0f98946
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class TankWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        TankWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
new file mode 100644
index 0000000..b6d44fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
+NextAction** CastRendAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRendOnAttackerAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellOnAttackerAction::getPrerequisites());
+}
+
+NextAction** CastDisarmAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), new NextAction("defensive stance"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastSunderArmorAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRevengeAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.h b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
new file mode 100644
index 0000000..65ac0ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
@@ -0,0 +1,210 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    // battle
+    class CastBattleMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastBattleMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("battle stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastDefensiveMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastDefensiveMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // all
+    class CastHeroicStrikeAction : public CastMeleeSpellAction {
+    public:
+        CastHeroicStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "heroic strike") {}
+    };
+
+    // all
+    class CastCleaveAction : public CastMeleeSpellAction {
+    public:
+        CastCleaveAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cleave") {}
+    };
+
+    // battle, berserker
+    class CastMockingBlowAction : public CastMeleeSpellAction {
+    public:
+        CastMockingBlowAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mocking blow") {}
+    };
+
+    class CastBloodthirstAction : public CastMeleeSpellAction {
+    public:
+        CastBloodthirstAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bloodthirst") {}
+    };
+
+    // battle, berserker
+    class CastExecuteAction : public CastMeleeSpellAction {
+    public:
+        CastExecuteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "execute") {}
+    };
+
+    // battle
+    class CastOverpowerAction : public CastBattleMeleeSpellAction {
+    public:
+        CastOverpowerAction(PlayerbotAI* ai) : CastBattleMeleeSpellAction(ai, "overpower") {}
+    };
+
+    // battle, berserker
+    class CastHamstringAction : public CastMeleeSpellAction {
+    public:
+        CastHamstringAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hamstring") {}
+    };
+
+    // defensive
+    class CastTauntAction : public CastSpellAction {
+    public:
+        CastTauntAction(PlayerbotAI* ai) : CastSpellAction(ai, "taunt") {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastShieldBlockAction : public CastBuffSpellAction {
+    public:
+        CastShieldBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shield block") {}
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+		}
+    };
+
+    // defensive
+    class CastShieldWallAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastShieldWallAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shield wall") {}
+    };
+
+    class CastBloodrageAction : public CastBuffSpellAction {
+    public:
+        CastBloodrageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodrage") {}
+    };
+
+    // defensive
+    class CastDevastateAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastDevastateAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "devastate") {}
+    };
+
+    // all
+    class CastSlamAction : public CastMeleeSpellAction {
+    public:
+        CastSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slam") {}
+    };
+
+	// all
+	class CastShieldSlamAction : public CastMeleeSpellAction {
+	public:
+		CastShieldSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "shield slam") {}
+	};
+
+    // after dodge
+    BEGIN_MELEE_SPELL_ACTION(CastRevengeAction, "revenge")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+
+    //debuffs
+    BEGIN_DEBUFF_ACTION(CastRendAction, "rend")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastRendOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastRendOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "rend") {}
+        virtual NextAction** getPrerequisites();
+    };
+
+    BEGIN_DEBUFF_ACTION(CastDisarmAction, "disarm")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastSunderArmorAction, "sunder armor") // 5 times
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastDemoralizingShoutAction : public CastDebuffSpellAction {
+    public:
+        CastDemoralizingShoutAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing shout") {}
+    };
+
+    BEGIN_MELEE_SPELL_ACTION(CastChallengingShoutAction, "challenging shout")
+    END_SPELL_ACTION()
+
+    // stuns
+    BEGIN_MELEE_SPELL_ACTION(CastShieldBashAction, "shield bash")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastIntimidatingShoutAction, "intimidating shout")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastThunderClapAction, "thunder clap")
+    END_SPELL_ACTION()
+
+    // buffs
+	class CastBattleShoutAction : public CastBuffSpellAction {
+	public:
+		CastBattleShoutAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle shout") {}
+	};
+
+	class CastDefensiveStanceAction : public CastBuffSpellAction {
+	public:
+		CastDefensiveStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "defensive stance") {}
+	};
+
+	class CastBattleStanceAction : public CastBuffSpellAction {
+	public:
+		CastBattleStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle stance") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastChargeAction, "charge")
+    END_SPELL_ACTION()
+
+	class CastDeathWishAction : public CastBuffSpellAction {
+	public:
+		CastDeathWishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "death wish") {}
+	};
+
+	class CastBerserkerRageAction : public CastBuffSpellAction {
+	public:
+		CastBerserkerRageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserker rage") {}
+	};
+
+	class CastLastStandAction : public CastBuffSpellAction {
+	public:
+		CastLastStandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "last stand") {}
+	};
+
+	// defensive
+	class CastShockwaveAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastShockwaveAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shockwave") {}
+	};
+
+	// defensive
+	class CastConcussionBlowAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastConcussionBlowAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "concussion blow") {}
+	};
+
+	BEGIN_MELEE_SPELL_ACTION(CastVictoryRushAction, "victory rush")
+	END_SPELL_ACTION()
+
+    class CastShieldBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastShieldBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "shield bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
new file mode 100644
index 0000000..bc74075
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
@@ -0,0 +1,192 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+#include "WarriorAiObjectContext.h"
+#include "GenericWarriorNonCombatStrategy.h"
+#include "TankWarriorStrategy.h"
+#include "DpsWarriorStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarriorTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warrior::StrategyFactoryInternal::nc;
+                creators["pull"] = &warrior::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warrior::StrategyFactoryInternal::aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarriorNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsWarrirorAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &warrior::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &warrior::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarriorStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarriorStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["hamstring"] = &TriggerFactoryInternal::hamstring;
+                creators["victory rush"] = &TriggerFactoryInternal::victory_rush;
+                creators["death wish"] = &TriggerFactoryInternal::death_wish;
+                creators["battle shout"] = &TriggerFactoryInternal::battle_shout;
+                creators["rend"] = &TriggerFactoryInternal::rend;
+                creators["rend on attacker"] = &TriggerFactoryInternal::rend_on_attacker;
+                creators["bloodrage"] = &TriggerFactoryInternal::bloodrage;
+                creators["shield bash"] = &TriggerFactoryInternal::shield_bash;
+                creators["disarm"] = &TriggerFactoryInternal::disarm;
+                creators["concussion blow"] = &TriggerFactoryInternal::concussion_blow;
+                creators["sword and board"] = &TriggerFactoryInternal::SwordAndBoard;
+                creators["shield bash on enemy healer"] = &TriggerFactoryInternal::shield_bash_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hamstring(PlayerbotAI* ai) { return new HamstringTrigger(ai); }
+            static Trigger* victory_rush(PlayerbotAI* ai) { return new VictoryRushTrigger(ai); }
+            static Trigger* death_wish(PlayerbotAI* ai) { return new DeathWishTrigger(ai); }
+            static Trigger* battle_shout(PlayerbotAI* ai) { return new BattleShoutTrigger(ai); }
+            static Trigger* rend(PlayerbotAI* ai) { return new RendDebuffTrigger(ai); }
+            static Trigger* rend_on_attacker(PlayerbotAI* ai) { return new RendDebuffOnAttackerTrigger(ai); }
+            static Trigger* bloodrage(PlayerbotAI* ai) { return new BloodrageDebuffTrigger(ai); }
+            static Trigger* shield_bash(PlayerbotAI* ai) { return new ShieldBashInterruptSpellTrigger(ai); }
+            static Trigger* disarm(PlayerbotAI* ai) { return new DisarmDebuffTrigger(ai); }
+            static Trigger* concussion_blow(PlayerbotAI* ai) { return new ConcussionBlowTrigger(ai); }
+            static Trigger* SwordAndBoard(PlayerbotAI* ai) { return new SwordAndBoardTrigger(ai); }
+            static Trigger* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new ShieldBashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["devastate"] = &AiObjectContextInternal::devastate;
+                creators["overpower"] = &AiObjectContextInternal::overpower;
+                creators["charge"] = &AiObjectContextInternal::charge;
+                creators["bloodthirst"] = &AiObjectContextInternal::bloodthirst;
+                creators["rend"] = &AiObjectContextInternal::rend;
+                creators["rend on attacker"] = &AiObjectContextInternal::rend_on_attacker;
+                creators["mocking blow"] = &AiObjectContextInternal::mocking_blow;
+                creators["death wish"] = &AiObjectContextInternal::death_wish;
+                creators["berserker rage"] = &AiObjectContextInternal::berserker_rage;
+                creators["victory rush"] = &AiObjectContextInternal::victory_rush;
+                creators["execute"] = &AiObjectContextInternal::execute;
+                creators["defensive stance"] = &AiObjectContextInternal::defensive_stance;
+                creators["hamstring"] = &AiObjectContextInternal::hamstring;
+                creators["shield bash"] = &AiObjectContextInternal::shield_bash;
+                creators["shield block"] = &AiObjectContextInternal::shield_block;
+                creators["bloodrage"] = &AiObjectContextInternal::bloodrage;
+                creators["battle stance"] = &AiObjectContextInternal::battle_stance;
+                creators["heroic strike"] = &AiObjectContextInternal::heroic_strike;
+                creators["intimidating shout"] = &AiObjectContextInternal::intimidating_shout;
+                creators["demoralizing shout"] = &AiObjectContextInternal::demoralizing_shout;
+                creators["challenging shout"] = &AiObjectContextInternal::challenging_shout;
+                creators["shield wall"] = &AiObjectContextInternal::shield_wall;
+                creators["battle shout"] = &AiObjectContextInternal::battle_shout;
+                creators["thunder clap"] = &AiObjectContextInternal::thunder_clap;
+                creators["taunt"] = &AiObjectContextInternal::taunt;
+                creators["revenge"] = &AiObjectContextInternal::revenge;
+                creators["slam"] = &AiObjectContextInternal::slam;
+                creators["shield slam"] = &AiObjectContextInternal::shield_slam;
+                creators["disarm"] = &AiObjectContextInternal::disarm;
+                creators["sunder armor"] = &AiObjectContextInternal::sunder_armor;
+                creators["last stand"] = &AiObjectContextInternal::last_stand;
+                creators["shockwave"] = &AiObjectContextInternal::shockwave;
+                creators["cleave"] = &AiObjectContextInternal::cleave;
+                creators["concussion blow"] = &AiObjectContextInternal::concussion_blow;
+                creators["shield bash on enemy healer"] = &AiObjectContextInternal::shield_bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* devastate(PlayerbotAI* ai) { return new CastDevastateAction(ai); }
+            static Action* last_stand(PlayerbotAI* ai) { return new CastLastStandAction(ai); }
+            static Action* shockwave(PlayerbotAI* ai) { return new CastShockwaveAction(ai); }
+            static Action* cleave(PlayerbotAI* ai) { return new CastCleaveAction(ai); }
+            static Action* concussion_blow(PlayerbotAI* ai) { return new CastConcussionBlowAction(ai); }
+            static Action* taunt(PlayerbotAI* ai) { return new CastTauntAction(ai); }
+            static Action* revenge(PlayerbotAI* ai) { return new CastRevengeAction(ai); }
+            static Action* slam(PlayerbotAI* ai) { return new CastSlamAction(ai); }
+            static Action* shield_slam(PlayerbotAI* ai) { return new CastShieldSlamAction(ai); }
+            static Action* disarm(PlayerbotAI* ai) { return new CastDisarmAction(ai); }
+            static Action* sunder_armor(PlayerbotAI* ai) { return new CastSunderArmorAction(ai); }
+            static Action* overpower(PlayerbotAI* ai) { return new CastOverpowerAction(ai); }
+            static Action* charge(PlayerbotAI* ai) { return new CastChargeAction(ai); }
+            static Action* bloodthirst(PlayerbotAI* ai) { return new CastBloodthirstAction(ai); }
+            static Action* rend(PlayerbotAI* ai) { return new CastRendAction(ai); }
+            static Action* rend_on_attacker(PlayerbotAI* ai) { return new CastRendOnAttackerAction(ai); }
+            static Action* mocking_blow(PlayerbotAI* ai) { return new CastMockingBlowAction(ai); }
+            static Action* death_wish(PlayerbotAI* ai) { return new CastDeathWishAction(ai); }
+            static Action* berserker_rage(PlayerbotAI* ai) { return new CastBerserkerRageAction(ai); }
+            static Action* victory_rush(PlayerbotAI* ai) { return new CastVictoryRushAction(ai); }
+            static Action* execute(PlayerbotAI* ai) { return new CastExecuteAction(ai); }
+            static Action* defensive_stance(PlayerbotAI* ai) { return new CastDefensiveStanceAction(ai); }
+            static Action* hamstring(PlayerbotAI* ai) { return new CastHamstringAction(ai); }
+            static Action* shield_bash(PlayerbotAI* ai) { return new CastShieldBashAction(ai); }
+            static Action* shield_block(PlayerbotAI* ai) { return new CastShieldBlockAction(ai); }
+            static Action* bloodrage(PlayerbotAI* ai) { return new CastBloodrageAction(ai); }
+            static Action* battle_stance(PlayerbotAI* ai) { return new CastBattleStanceAction(ai); }
+            static Action* heroic_strike(PlayerbotAI* ai) { return new CastHeroicStrikeAction(ai); }
+            static Action* intimidating_shout(PlayerbotAI* ai) { return new CastIntimidatingShoutAction(ai); }
+            static Action* demoralizing_shout(PlayerbotAI* ai) { return new CastDemoralizingShoutAction(ai); }
+            static Action* challenging_shout(PlayerbotAI* ai) { return new CastChallengingShoutAction(ai); }
+            static Action* shield_wall(PlayerbotAI* ai) { return new CastShieldWallAction(ai); }
+            static Action* battle_shout(PlayerbotAI* ai) { return new CastBattleShoutAction(ai); }
+            static Action* thunder_clap(PlayerbotAI* ai) { return new CastThunderClapAction(ai); }
+            static Action* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new CastShieldBashOnEnemyHealerAction(ai); }
+
+        };
+    };
+};
+
+WarriorAiObjectContext::WarriorAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warrior::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warrior::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warrior::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warrior::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
new file mode 100644
index 0000000..bc1b5d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarriorAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarriorAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
new file mode 100644
index 0000000..0698aa1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
new file mode 100644
index 0000000..480768d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
new file mode 100644
index 0000000..0b8d183
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorTriggers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
new file mode 100644
index 0000000..72a1285
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
@@ -0,0 +1,78 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_TRIGGER(BattleShoutTrigger, "battle shout", "battle shout")
+
+    DEBUFF_TRIGGER(RendDebuffTrigger, "rend", "rend")
+    DEBUFF_TRIGGER(DisarmDebuffTrigger, "disarm", "disarm")
+    DEBUFF_TRIGGER(SunderArmorDebuffTrigger, "sunder armor", "sunder armor")
+
+    class RendDebuffOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        RendDebuffOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "rend") {}
+    };
+
+	class RevengeAvailableTrigger : public SpellCanBeCastTrigger
+	{
+	public:
+		RevengeAvailableTrigger(PlayerbotAI* ai) : SpellCanBeCastTrigger(ai, "revenge") {}
+	};
+
+    class BloodrageDebuffTrigger : public DebuffTrigger
+    {
+    public:
+        BloodrageDebuffTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "bloodrage") {}
+        virtual bool IsActive()
+        {
+            return DebuffTrigger::IsActive() &&
+                AI_VALUE2(uint8, "health", "self target") >= 75 &&
+                AI_VALUE2(uint8, "rage", "self target") < 20;
+        }
+    };
+
+    class ShieldBashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        ShieldBashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "shield bash") {}
+    };
+
+    class VictoryRushTrigger : public HasAuraTrigger
+    {
+    public:
+        VictoryRushTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "victory rush") {}
+    };
+
+    class SwordAndBoardTrigger : public HasAuraTrigger
+    {
+    public:
+        SwordAndBoardTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "sword and board") {}
+    };
+
+    class ConcussionBlowTrigger : public SnareTargetTrigger
+    {
+    public:
+        ConcussionBlowTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "concussion blow") {}
+    };
+
+    class HamstringTrigger : public SnareTargetTrigger
+    {
+    public:
+        HamstringTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hamstring") {}
+    };
+
+    class DeathWishTrigger : public BoostTrigger
+    {
+    public:
+        DeathWishTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "death wish") {}
+    };
+
+    class ShieldBashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        ShieldBashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "shield bash") {}
+    };
+
+}
diff --git a/src/server/database/Database/DatabaseWorkerPool.h b/src/server/database/Database/DatabaseWorkerPool.h
index f5002c6..8e15427 100644
--- a/src/server/database/Database/DatabaseWorkerPool.h
+++ b/src/server/database/Database/DatabaseWorkerPool.h
@@ -30,7 +30,11 @@
 #include "AdhocStatement.h"
 #include "StringFormat.h"
 
+#ifdef _WIN32
 #include <mysqld_error.h>
+#else
+#include </usr/include/mysql/mysqld_error.h>
+#endif
 #include <memory>
 
 #define MIN_MYSQL_SERVER_VERSION 50100u
diff --git a/src/server/database/Database/Field.h b/src/server/database/Database/Field.h
index 1bbd264..5a2a03f 100644
--- a/src/server/database/Database/Field.h
+++ b/src/server/database/Database/Field.h
@@ -21,7 +21,11 @@
 #include "Common.h"
 #include "Log.h"
 
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 
 class Field
 {
diff --git a/src/server/database/Database/MySQLConnection.cpp b/src/server/database/Database/MySQLConnection.cpp
index 10f4a7b..77ff991 100644
--- a/src/server/database/Database/MySQLConnection.cpp
+++ b/src/server/database/Database/MySQLConnection.cpp
@@ -21,7 +21,11 @@
 #ifdef _WIN32
   #include <winsock2.h>
 #endif
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 #include <errmsg.h>
 
 #include "MySQLConnection.h"
diff --git a/src/server/database/Database/QueryResult.h b/src/server/database/Database/QueryResult.h
index a61fb63..4540370 100644
--- a/src/server/database/Database/QueryResult.h
+++ b/src/server/database/Database/QueryResult.h
@@ -25,7 +25,11 @@
 #ifdef _WIN32
   #include <winsock2.h>
 #endif
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 
 class ResultSet
 {
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 4b48f1f..df6c534 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -31,6 +31,8 @@
 #include "Language.h"
 #include "Log.h"
 
+#include "../../plugins/ahbot/AhBot.h"
+
 enum eAuctionHouse
 {
     AH_MINIMUM_DEPOSIT = 100
@@ -187,6 +189,9 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
             .AddMoney(profit)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, sWorld->getIntConfig(CONFIG_MAIL_DELIVERY_DELAY));
+
+        // ahbot mod
+        auctionbot.Won(auction);
     }
 }
 
@@ -210,6 +215,9 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
             .AddItem(pItem)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, 0);
+
+        // ahbot mod
+        auctionbot.Expired(auction);
     }
     else
     {
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 6455e3a..418c3ca 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -207,6 +207,7 @@ add_library(game STATIC
   ${game_STAT_PCH_SRC}
 )
 
+add_dependencies(plugins revision.h)
 # Generate precompiled header
 if (USE_COREPCH)
   add_cxx_pch(game ${game_STAT_PCH_HDR} ${game_STAT_PCH_SRC})
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index 0d6816f..764dfe4 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -398,7 +398,8 @@ bool ChatHandler::SetDataForCommandInTable(ChatCommand* table, char const* text,
         // expected subcommand by full name DB content
         else if (*text)
         {
-            TC_LOG_ERROR("sql.sql", "Table `command` have unexpected subcommand '%s' in command '%s', skip.", text, fullcommand.c_str());
+            // FEYZEE: hide error caused by command table
+            //TC_LOG_ERROR("sql.sql", "Table `command` have unexpected subcommand '%s' in command '%s', skip.", text, fullcommand.c_str());
             return false;
         }
 
diff --git a/src/server/game/DungeonFinding/LFGQueue.cpp b/src/server/game/DungeonFinding/LFGQueue.cpp
index 86b010a..72167c6 100644
--- a/src/server/game/DungeonFinding/LFGQueue.cpp
+++ b/src/server/game/DungeonFinding/LFGQueue.cpp
@@ -520,6 +520,25 @@ LfgCompatibility LFGQueue::CheckCompatibility(GuidList check)
         return LFG_COMPATIBLES_WITH_LESS_PLAYERS;
     }
 
+    //FEYZEE: disable this code because it effect LFG while grouped
+    //FEYZEE: normally this code seems fine
+    /*
+    // playerbot mod
+    bool nonBotFound = false;
+    for (GuidList::const_iterator it = check.begin(); it != check.end(); ++it)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(*it);
+        if (player && !player->GetPlayerbotAI())
+        {
+            nonBotFound = true;
+            break;
+        }
+    }
+    if (!nonBotFound)
+        return LFG_INCOMPATIBLES_HAS_IGNORES;
+    // end of playerbot mod
+    */
+
     ObjectGuid gguid = *check.begin();
     proposal.queues = check;
     proposal.isNew = numLfgGroups != 1 || sLFGMgr->GetOldState(gguid) != LFG_STATE_DUNGEON;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index a5ed01a..7254ba6 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -100,7 +100,10 @@
 // 77
 // 78
 // 79
-// 80
+// Playerbot mod:
+#include "../../../../plugins/playerbot/playerbot.h"
+#include "../../../../plugins/playerbot/GuildTaskMgr.h"
+
 // Visit http://www.realmsofwarcraft.com/bb for forums and information
 //
 // End of prepatch
@@ -927,6 +930,10 @@ Player::Player(WorldSession* session): Unit(true)
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    // playerbot mod
+    m_playerbotAI = NULL;
+    m_playerbotMgr = NULL;
 }
 
 Player::~Player()
@@ -1923,6 +1930,12 @@ void Player::Update(uint32 p_time)
     //because we don't want player's ghost teleported from graveyard
     if (IsHasDelayedTeleport() && IsAlive())
         TeleportTo(m_teleport_dest, m_teleport_options);
+
+    // Playerbot mod
+    if (m_playerbotAI)
+       m_playerbotAI->UpdateAI(p_time);
+    if (m_playerbotMgr)
+       m_playerbotMgr->UpdateAI(p_time);
 }
 
 void Player::setDeathState(DeathState s)
@@ -15389,7 +15402,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     if (quest->GetRewSpellCast() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpellCast());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpellCast(), true);
@@ -15400,7 +15413,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     else if (quest->GetRewSpell() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpell());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpell(), true);
@@ -23709,6 +23722,9 @@ bool Player::GetsRecruitAFriendBonus(bool forXP)
 void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
 {
     KillRewarder(this, victim, isBattleGround).Reward();
+    // playerbot mod
+    sGuildTaskMgr.CheckKillTask(this, victim);
+    // end of playerbot mod
 }
 
 void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 91ba12b..c7200b9 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -55,6 +55,10 @@ class UpdateMask;
 
 struct CharacterCustomizeInfo;
 
+// Playerbot mod
+class PlayerbotAI;
+class PlayerbotMgr;
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2293,6 +2297,18 @@ class Player : public Unit, public GridObject<Player>
 
         bool CanFly() const override { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        EquipmentSets& GetEquipmentSets() { return m_EquipmentSets; }
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        PlayerTalentMap& GetTalentMap(uint8 spec) { return *m_talents[spec]; }
+        bool MinimalLoadFromDB( QueryResult result, uint32 guid );
+
         //! Return collision height sent to client
         float GetCollisionHeight(bool mounted) const;
 
@@ -2665,7 +2681,9 @@ class Player : public Unit, public GridObject<Player>
         // 37
         // 38
         // 39
-        // 40
+        // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
         // Visit http://www.realmsofwarcraft.com/bb for forums and information
         //
         // End of prepatch
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index 732afce..3f0e0b6 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -323,6 +323,11 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        // ai playerbot mod
+        ObjectGuid GetTargetIcon(int index) { return m_targetIcons[index]; }
+        Rolls* GetRolls() { return &RollId; }
+        // end
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index f3e3266..dba8ee6 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -46,6 +46,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+// Playerbot mod:
+#include "../../plugins/playerbot/playerbot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -60,6 +63,76 @@ class LoginQueryHolder : public SQLQueryHolder
         bool Initialize();
 };
 
+class PlayerbotLoginQueryHolder : public LoginQueryHolder
+{
+private:
+    uint32 masterAccountId;
+    PlayerbotHolder* playerbotHolder;
+
+public:
+    PlayerbotLoginQueryHolder(PlayerbotHolder* playerbotHolder, uint32 masterAccount, uint32 accountId, uint64 guid)
+        : LoginQueryHolder(accountId, ObjectGuid(guid)), masterAccountId(masterAccount), playerbotHolder(playerbotHolder) { }
+
+public:
+    uint32 GetMasterAccountId() const { return masterAccountId; }
+    PlayerbotHolder* GetPlayerbotHolder() { return playerbotHolder; }
+};
+
+void PlayerbotHolder::AddPlayerBot(uint64 playerGuid, uint32 masterAccount)
+{
+    // has bot already been added?
+	Player* bot = sObjectMgr->GetPlayerByLowGUID(playerGuid);
+
+	if (bot && bot->IsInWorld())
+        return;
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(ObjectGuid(playerGuid));
+    if (accountId == 0)
+        return;
+
+    PlayerbotLoginQueryHolder *holder = new PlayerbotLoginQueryHolder(this, masterAccount, accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+
+    QueryResultHolderFuture future = CharacterDatabase.DelayQueryHolder(holder);
+    future.get();
+
+    WorldSession* masterSession = masterAccount ? sWorld->FindSession(masterAccount) : NULL;
+    uint32 botAccountId = holder->GetAccountId();
+    WorldSession *botSession = new WorldSession(botAccountId, NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+
+    botSession->HandlePlayerLogin(holder); // will delete lqh
+
+	bot = botSession->GetPlayer();
+	if (!bot)
+		return;
+
+	PlayerbotMgr *mgr = bot->GetPlayerbotMgr();
+	bot->SetPlayerbotMgr(NULL);
+	delete mgr;
+	sRandomPlayerbotMgr.OnPlayerLogout(bot);
+
+    bool allowed = false;
+    if (botAccountId == masterAccount)
+        allowed = true;
+    else if (masterSession && sPlayerbotAIConfig.allowGuildBots && bot->GetGuildId() == masterSession->GetPlayer()->GetGuildId())
+        allowed = true;
+    else if (sPlayerbotAIConfig.IsInRandomAccountList(botAccountId))
+        allowed = true;
+
+    if (allowed)
+        OnBotLogin(bot);
+    else if (masterSession)
+    {
+        ChatHandler ch(masterSession);
+        ch.PSendSysMessage("You are not allowed to control bot %s...", bot->GetName().c_str());
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -991,6 +1064,14 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // Handle Login-Achievements (should be handled after loading)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
+    // playerbot mod
+    if (!_player->GetPlayerbotAI())
+    {
+        _player->SetPlayerbotMgr(new PlayerbotMgr(_player));
+        sRandomPlayerbotMgr.OnPlayerLogin(_player);
+    }
+    // end of playerbot mod
+
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
     // Prepatch by LordPsyan
     // 01
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index 2acbaba..063832b 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -39,6 +39,9 @@
 #include "ScriptMgr.h"
 #include "AccountMgr.h"
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 {
     uint32 type;
@@ -297,7 +300,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 (HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID())))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
-            GetPlayer()->Whisper(msg, Language(lang), receiver);
+            // Playerbot mod: handle whispered command to bot
+            if (receiver->GetPlayerbotAI() && lang != LANG_ADDON)
+            {
+                receiver->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                receiver->m_speakTime = 0;
+                receiver->m_speakCount = 0;
+            }
+            else
+            {
+                GetPlayer()->Whisper(msg, Language(lang), receiver);
+            }
+            // END Playerbot mod
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -314,6 +328,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (type == CHAT_MSG_PARTY_LEADER && !group->IsLeader(sender->GetGUID()))
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -330,6 +357,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
+                // Playerbot mod: broadcast message to bot members
+                PlayerbotMgr *mgr = GetPlayer()->GetPlayerbotMgr();
+                if (mgr && lang != LANG_ADDON)
+                {
+                    for (PlayerBotMap::const_iterator it = mgr->GetPlayerBotsBegin(); it != mgr->GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        if (bot->GetGuildId() == GetPlayer()->GetGuildId())
+                            bot->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    }
+                }
+                // END Playerbot mod
             }
         } break;
         case CHAT_MSG_OFFICER:
@@ -355,6 +394,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -372,6 +424,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -384,6 +449,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())) || group->isBGGroup())
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -432,6 +510,13 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             {
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
+                    // Playerbot mod: broadcast message to bot members
+                    if (_player->GetPlayerbotMgr() && lang != LANG_ADDON && chn->GetFlags() & 0x18)
+                    {
+                        _player->GetPlayerbotMgr()->HandleCommand(type, msg);
+                    }
+                    sRandomPlayerbotMgr.HandleCommand(type, msg, *_player);
+                    // END Playerbot mod
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
                     chn->Say(sender->GetGUID(), msg.c_str(), lang);
                 }
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index bb22d27..8c1cf98 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -46,6 +46,9 @@
 
 #include <zlib.h>
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -188,6 +191,14 @@ uint32 WorldSession::GetGuidLow() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
     if (!m_Socket)
         return;
 
@@ -258,6 +269,8 @@ void WorldSession::LogUnprocessedTail(WorldPacket* packet)
 /// Update the WorldSession (triggered by World update)
 bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 {
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI()) return true;
+
     /// Update Timeout timer.
     UpdateTimeOutTime(diff);
 
@@ -320,6 +333,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             sScriptMgr->OnPacketReceive(this, *packet);
                             (this->*opHandle.handler)(*packet);
                             LogUnprocessedTail(packet);
+
+                            // playerbot mod
+                            if (_player && _player->GetPlayerbotMgr())
+                                _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                            // playerbot mod end
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -399,6 +417,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
             break;
     }
 
+    // playerbot mod
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr())
+        GetPlayer()->GetPlayerbotMgr()->UpdateSessions(0);
+    // end of playerbot mod
+
     if (m_Socket && m_Socket->IsOpen() && _warden)
         _warden->Update();
 
@@ -448,6 +471,11 @@ void WorldSession::LogoutPlayer(bool save)
         if (ObjectGuid lguid = _player->GetLootGUID())
             DoLootRelease(lguid);
 
+        // Playerbot mod: log out all player bots owned by this toon
+        if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->LogoutAllBots();
+        sRandomPlayerbotMgr.OnPlayerLogout(_player);
+
         ///- If the player just died before logging out, make him appear as a ghost
         if (_player->GetDeathTimer())
         {
@@ -523,7 +551,8 @@ void WorldSession::LogoutPlayer(bool save)
         _player->CleanupChannels();
 
         ///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
-        _player->UninviteFromGroup();
+        // playerbot mod
+        //_player->UninviteFromGroup();
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
@@ -1523,3 +1552,14 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
 
     return maxPacketCounterAllowed;
 }
+
+void WorldSession::HandleBotPackets()
+{
+    WorldPacket* packet;
+    while (_recvQueue.next(packet))
+    {
+        OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+        (this->*opHandle.handler)(*packet);
+        delete packet;
+    }
+}
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 3753f79..658e0bf 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -190,7 +190,8 @@ class CharacterCreateInfo
     friend class WorldSession;
     friend class Player;
 
-    protected:
+    // playerbot mod
+    public:
         /// User specified variables
         std::string Name;
         uint8 Race       = 0;
@@ -816,6 +817,10 @@ class WorldSession
         void HandleBattlemasterJoinArena(WorldPacket& recvData);
         void HandleReportPvPAFK(WorldPacket& recvData);
 
+        // playerbot mod
+        void HandleBotPackets();
+        // end of playerbot mod
+
         // Battlefield
         void SendBfInvitePlayerToWar(uint32 battleId, uint32 zoneId, uint32 time);
         void SendBfInvitePlayerToQueue(uint32 battleId);
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 8476dcc..75e096e 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -65,6 +65,11 @@
 #include "WeatherMgr.h"
 #include "WorldSession.h"
 
+// playerbot mod
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/playerbot/RandomPlayerbotMgr.h"
+
 
 std::atomic<bool> World::m_stopEvent(false);
 uint8 World::m_ExitCode = SHUTDOWN_EXIT_CODE;
@@ -1938,6 +1943,11 @@ void World::SetInitialWorldSettings()
 
     if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
         sLog->SetRealmId(realmId);
+
+    TC_LOG_INFO("server.loading", "Initializing AuctionHouseBot...");
+    auctionbot.Init();
+
+    sPlayerbotAIConfig.Initialize();
 }
 
 void World::DetectDBCLang()
@@ -2107,14 +2117,22 @@ void World::Update(uint32 diff)
 
         ///- Handle expired auctions
         sAuctionMgr->Update();
+
+        // ahbot mod
+        auctionbot.Update();
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.UpdateAI(diff);
+    sRandomPlayerbotMgr.UpdateSessions(diff);
+
     /// <li> Handle AHBot operations
-    if (m_timers[WUPDATE_AHBOT].Passed())
-    {
-        sAuctionBot->Update();
-        m_timers[WUPDATE_AHBOT].Reset();
-    }
+    // if (m_timers[WUPDATE_AHBOT].Passed())
+    //{
+    //    sAuctionBot->Update();
+    //    m_timers[WUPDATE_AHBOT].Reset();
+    //}
+    // end of playerbot mod
 
     /// <li> Handle session updates when the timer has passed
     ResetTimeDiffRecord();
@@ -2676,6 +2694,10 @@ void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode, const std:
         ShutdownMsg(true, nullptr, reason);
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.LogoutAllBots();
+    // end of playerbot mod
+
     sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
 }
 
diff --git a/src/server/scripts/Commands/cs_ahbot.cpp b/src/server/scripts/Commands/cs_ahbot.cpp
index 559a775..a1e9be1 100644
--- a/src/server/scripts/Commands/cs_ahbot.cpp
+++ b/src/server/scripts/Commands/cs_ahbot.cpp
@@ -245,5 +245,6 @@ template bool ahbot_commandscript::HandleAHBotItemsRatioHouseCommand<AUCTION_HOU
 
 void AddSC_ahbot_commandscript()
 {
-    new ahbot_commandscript();
+    // playerbot mod
+    // new ahbot_commandscript();
 }
diff --git a/src/server/scripts/Commands/cs_misc.cpp b/src/server/scripts/Commands/cs_misc.cpp
index 7baef48..273ae9f 100644
--- a/src/server/scripts/Commands/cs_misc.cpp
+++ b/src/server/scripts/Commands/cs_misc.cpp
@@ -37,6 +37,10 @@
 #include "DisableMgr.h"
 #include "SpellHistory.h"
 
+#include "../../../plugins/ahbot/AhBot.h"
+#include "../../../plugins/playerbot/playerbot.h"
+#include "../../../plugins/playerbot/GuildTaskMgr.h"
+
 class misc_commandscript : public CommandScript
 {
 public:
@@ -97,6 +101,11 @@ public:
             { "unstuck",          rbac::RBAC_PERM_COMMAND_UNSTUCK,           true, &HandleUnstuckCommand,          "", NULL },
             { "wchange",          rbac::RBAC_PERM_COMMAND_WCHANGE,          false, &HandleChangeWeather,           "", NULL },
             { "mailbox",          rbac::RBAC_PERM_COMMAND_MAILBOX,          false, &HandleMailBoxCommand,          "", NULL },
+            // playerbot mod
+            { "ahbot",            rbac::RBAC_PERM_COMMAND_GM       ,          true,  &ahbot::AhBot::HandleAhBotCommand,                      "", NULL },
+            { "rndbot",           rbac::RBAC_PERM_COMMAND_GM       ,          true,  &RandomPlayerbotMgr::HandlePlayerbotConsoleCommand,     "", NULL },
+            { "bot",              195                              ,          false, &PlayerbotMgr::HandlePlayerbotMgrCommand,               "", NULL },
+            { "gtask",            rbac::RBAC_PERM_COMMAND_GM       ,          true,  &GuildTaskMgr::HandleConsoleCommand,           "", NULL },
             { NULL,               0,                                  false, NULL,                           "", NULL }
         };
         return commandTable;
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 78f39e0..a2c7596 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -134,6 +134,7 @@ target_link_libraries(worldserver
   common
   shared
   database
+  plugins
   scripts
   g3dlib
   gsoap
diff --git a/src/test/AcceptAllQuestStrategyTestCase.cpp b/src/test/AcceptAllQuestStrategyTestCase.cpp
new file mode 100644
index 0000000..3b1a20e
--- /dev/null
+++ b/src/test/AcceptAllQuestStrategyTestCase.cpp
@@ -0,0 +1,68 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class AcceptAllQuestStrategyTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( AcceptAllQuestStrategyTestCase );
+      CPPUNIT_TEST( turn_in_quest );
+      CPPUNIT_TEST( accept_quest );
+      CPPUNIT_TEST( quest_share );
+      CPPUNIT_TEST( useGameObject );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "accept all quests", NULL);
+    }
+
+protected:
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+        tick();
+
+        assertActions(">S:talk to quest giver>S:accept all quests");
+    }
+
+    void turn_in_quest()
+    {
+        trigger("complete quest");
+        tick();
+        tick();
+
+        trigger("gossip hello");
+        tick();
+        tick();
+
+        assertActions(">S:talk to quest giver>S:accept all quests>S:talk to quest giver>S:accept all quests");
+    }
+
+    void accept_quest()
+    {
+        trigger("accept quest");
+        tick();
+
+        assertActions(">S:accept quest");
+    }
+
+    void quest_share()
+    {
+        trigger("quest share");
+        tick();
+
+        assertActions(">S:accept quest share");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( AcceptAllQuestStrategyTestCase );
diff --git a/src/test/AiObjectContextWrapper.h b/src/test/AiObjectContextWrapper.h
new file mode 100644
index 0000000..226fa0e
--- /dev/null
+++ b/src/test/AiObjectContextWrapper.h
@@ -0,0 +1,287 @@
+#pragma once
+using namespace std;
+
+namespace ai
+{
+    class MockTargetValue : public ManualSetValue<Unit*>, public Qualified
+    {
+    public:
+        MockTargetValue(PlayerbotAI* const ai) : ManualSetValue<Unit*>(ai, NULL) {}
+    };
+
+    class MockStatsValue : public ManualSetValue<uint8>, public Qualified
+    {
+    public:
+        MockStatsValue(PlayerbotAI* const ai) : ManualSetValue<uint8>(ai, 0) {}
+    };
+
+    class MockFloatValue : public ManualSetValue<float>, public Qualified
+    {
+    public:
+        MockFloatValue(PlayerbotAI* const ai) : ManualSetValue<float>(ai, 0) {}
+    };
+
+    class MockStringValue : public ManualSetValue<string>, public Qualified
+    {
+    public:
+        MockStringValue(PlayerbotAI* const ai) : ManualSetValue<string>(ai, "") {}
+    };
+
+    class MockItemListValue : public ManualSetValue<list<Item*> >, public Qualified
+    {
+    public:
+        MockItemListValue(PlayerbotAI* const ai) : ManualSetValue<list<Item*> >(ai, list<Item*>()) {}
+    };
+
+    class MockItemValue : public ManualSetValue<Item*>, public Qualified
+    {
+    public:
+        MockItemValue(PlayerbotAI* const ai) : ManualSetValue<Item*>(ai, NULL) {}
+    };
+
+    class MockLogicalValue : public ManualSetValue<bool>, public Qualified
+    {
+    public:
+        MockLogicalValue(PlayerbotAI* const ai) : ManualSetValue<bool>(ai, false) {}
+    };
+
+    class AlwaysTrueValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        AlwaysTrueValue(PlayerbotAI* const ai) : BoolCalculatedValue(ai) {}
+        virtual bool Calculate() { return true; }
+    };
+
+    class MockPartyMemberWithoutAuraValue : public UnitCalculatedValue, public Qualified
+    {
+    public:
+        MockPartyMemberWithoutAuraValue(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            string  spell = qualifier;
+            Unit* target = MockedTargets::GetPartyMember();
+            return ai->HasAura(spell, target) ? NULL : target;
+        }
+    };
+
+    class MockPartyMemberToHeal : public UnitCalculatedValue
+    {
+    public:
+        MockPartyMemberToHeal(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            Unit* target = MockedTargets::GetPartyMember();
+            return AI_VALUE2(uint8, "health", "party member to heal") < 100.0f ? target : NULL;
+        }
+    };
+
+    class MockPartyMemberToDispel : public UnitCalculatedValue, public Qualified
+    {
+    public:
+        MockPartyMemberToDispel(PlayerbotAI* const ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate()
+        {
+            uint32 dispelType = atoi(qualifier.c_str());
+            Unit* target = MockedTargets::GetPartyMember();
+            return ai->HasAuraToDispel(target, dispelType) ? target : NULL;
+        }
+    };
+
+    class MockUnitListValue : public ManualSetValue<list<ObjectGuid>>
+    {
+    public:
+        MockUnitListValue(PlayerbotAI* const ai) : ManualSetValue<list<ObjectGuid>>(ai, list<ObjectGuid>()) {}
+    };
+
+    class MockSpellIdValue : public CalculatedValue<uint32>, public Qualified
+    {
+    public:
+        MockSpellIdValue(PlayerbotAI* ai) : CalculatedValue<uint32>(ai) {}
+
+    public:
+        virtual uint32 Calculate() { return 1; }
+
+    };
+
+    class MockValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        MockValueContext() : NamedObjectContext<UntypedValue>()
+        {
+            creators["attacker without aura"] = &MockValueContext::mock;
+            creators["party member without aura"] = &MockValueContext::party_member_without_aura;
+            creators["party member to heal"] = &MockValueContext::party_member_to_heal;
+            creators["party member to dispel"] = &MockValueContext::party_member_to_dispel;
+            creators["party member to resurrect"] = &MockValueContext::mock;
+            creators["current target"] = &MockValueContext::mock;
+            creators["old target"] = &MockValueContext::mock;
+            creators["self target"] = &MockValueContext::mock;
+            creators["master target"] = &MockValueContext::mock;
+            creators["line target"] = &MockValueContext::mock;
+            creators["tank target"] = &MockValueContext::mock;
+            creators["dps target"] = &MockValueContext::mock;
+            creators["cc target"] = &MockValueContext::mock;
+            creators["current cc target"] = &MockValueContext::mock;
+            creators["pet target"] = &MockValueContext::mock;
+            creators["grind target"] = &MockValueContext::mock;
+            creators["least hp target"] = &MockValueContext::mock;
+            creators["rti target"] = &MockValueContext::mock;
+            creators["duel target"] = &MockValueContext::mock;
+            creators["enemy player target"] = &MockValueContext::mock;
+            creators["enemy healer target"] = &MockValueContext::mock;
+
+            creators["health"] = &MockValueContext::stats;
+            creators["rage"] = &MockValueContext::stats;
+            creators["energy"] = &MockValueContext::stats;
+            creators["mana"] = &MockValueContext::stats;
+            creators["combo"] = &MockValueContext::stats;
+            creators["dead"] = &MockValueContext::logical;
+            creators["has mana"] = &MockValueContext::logical;
+            creators["combat"] = &MockValueContext::logical;
+
+            creators["attacker count"] = &MockValueContext::stats;
+            creators["my attacker count"] = &MockValueContext::stats;
+            creators["has aggro"] = &MockValueContext::logical;
+            creators["balance"] = &MockValueContext::stats;
+            creators["mounted"] = &MockValueContext::logical;
+            creators["has available loot"] = &MockValueContext::logical;
+            creators["distance"] = &MockValueContext::floating;
+            creators["moving"] = &MockValueContext::logical;
+            creators["swimming"] = &MockValueContext::logical;
+            creators["behind"] = &MockValueContext::logical;
+            creators["facing"] = &MockValueContext::logical;
+            creators["item count"] = &MockValueContext::stats;
+            creators["inventory items"] = &MockValueContext::itemlist;
+            creators["item for spell"] = &MockValueContext::item;
+            creators["spell cast useful"] = &MockValueContext::always_true;
+            creators["can loot"] = &MockValueContext::logical;
+            creators["invalid target"] = &MockValueContext::logical;
+
+            creators["possible targets"] = &MockValueContext::units;
+            creators["nearest adds"] = &MockValueContext::units;
+            creators["attackers"] = &MockValueContext::units;
+            creators["has totem"] = &MockValueContext::logical;
+            creators["aoe heal"] = &MockValueContext::stats;
+
+            creators["rti"] = &MockValueContext::str;
+            creators["spell id"] = &MockValueContext::spell_id;
+            creators["threat"] = &MockValueContext::stats;
+            creators["bag space"] = &MockValueContext::stats;
+        }
+
+    private:
+        static UntypedValue* always_true(PlayerbotAI* ai) { return new AlwaysTrueValue(ai); }
+        static UntypedValue* stats(PlayerbotAI* ai) { return new MockStatsValue(ai); }
+        static UntypedValue* itemlist(PlayerbotAI* ai) { return new MockItemListValue(ai); }
+        static UntypedValue* item(PlayerbotAI* ai) { return new MockItemValue(ai); }
+        static UntypedValue* floating(PlayerbotAI* ai) { return new MockFloatValue(ai); }
+        static UntypedValue* str(PlayerbotAI* ai) { return new MockStringValue(ai); }
+        static UntypedValue* logical(PlayerbotAI* ai) { return new MockLogicalValue(ai); }
+        static UntypedValue* mock(PlayerbotAI* ai) { return new MockTargetValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new MockPartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new MockPartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new MockPartyMemberToDispel(ai); }
+        static UntypedValue* units(PlayerbotAI* ai) { return new MockUnitListValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new MockSpellIdValue(ai); }
+    };
+
+    class AiObjectContextWrapper : public AiObjectContext
+    {
+    public:
+        AiObjectContextWrapper(PlayerbotAI* const ai, AiObjectContext *realContext) :
+          AiObjectContext(ai), realContext(realContext)
+          {
+              GetValue<Unit*>("self target")->Set(MockedTargets::GetSelf());
+              GetValue<Unit*>("master target")->Set(MockedTargets::GetMaster());
+              GetValue<Unit*>("line target")->Set(MockedTargets::GetLineTarget());
+              GetValue<Unit*>("tank target")->Set(MockedTargets::GetTargetForTank());
+              GetValue<Unit*>("dps target")->Set(MockedTargets::GetTargetForDps());
+              GetValue<Unit*>("current cc target")->Set(NULL);
+              GetValue<Unit*>("current target")->Set(MockedTargets::GetCurrentTarget());
+              GetValue<Unit*>("old target")->Set(MockedTargets::GetCurrentTarget());
+              GetValue<Unit*>("pet target")->Set(MockedTargets::GetPet());
+              GetValue<Unit*>("least hp target")->Set(MockedTargets::GetLeastHpTarget());
+              GetValue<Unit*>("rti target")->Set(MockedTargets::GetRtiTarget());
+              GetValue<Unit*>("enemy player target")->Set(MockedTargets::GetEnemyPlayer());
+              GetValue<Unit*>("attacker without aura")->Set(NULL);
+
+              GetValue<uint8>("health", "self target")->Set(100);
+              GetValue<uint8>("health", "current target")->Set(100);
+              GetValue<uint8>("health", "pet target")->Set(100);
+              GetValue<uint8>("health", "party member to heal")->Set(100);
+              GetValue<uint8>("health", "party member to resurrect")->Set(100);
+
+              GetValue<bool>("dead", "current target")->Set(false);
+              GetValue<bool>("dead", "self target")->Set(false);
+
+              GetValue<uint8>("mana", "self target")->Set(100);
+              GetValue<uint8>("mana", "current target")->Set(100);
+              GetValue<uint8>("mana", "pet target")->Set(100);
+              GetValue<uint8>("mana", "party member to heal")->Set(100);
+              GetValue<uint8>("mana", "party member to resurrect")->Set(100);
+
+              GetValue<bool>("has mana", "self target")->Set(true);
+              GetValue<bool>("has mana", "current target")->Set(true);
+              GetValue<bool>("has mana", "pet target")->Set(true);
+              GetValue<bool>("has mana", "party member to heal")->Set(true);
+              GetValue<bool>("has mana", "party member to resurrect")->Set(true);
+
+              GetValue<bool>("combat", "self target")->Set(false);
+
+              GetValue<uint8>("attacker count")->Set(1);
+              GetValue<uint8>("my attacker count")->Set(1);
+              GetValue<uint8>("balance")->Set(100);
+              GetValue<float>("distance", "current target")->Set(15.0f);
+              GetValue<float>("distance", "loot target")->Set(0.0f);
+
+              GetValue<bool>("has aggro", "current target")->Set(true);
+              GetValue<bool>("can loot")->Set(false);
+
+              GetValue<bool>("facing", "current target")->Set(true);
+
+              list<Item*> items; items.push_back((Item*)(void*)0x01);
+              GetValue<list<Item*> >("inventory items", "drink")->Set(items);
+              GetValue<list<Item*> >("inventory items", "food")->Set(items);
+
+              GetValue<uint8>("aoe heal", "low")->Set(0);
+              GetValue<uint8>("aoe heal", "medium")->Set(0);
+              GetValue<uint8>("aoe heal", "critical")->Set(0);
+
+              GetValue<uint8>("threat")->Set(0);
+              GetValue<uint8>("bag space")->Set(0);
+          }
+
+    public:
+        virtual UntypedValue* GetUntypedValue(string  name)
+        {
+            UntypedValue* value = mockValueContext.create(name, ai);
+            UntypedValue* real = realContext->GetUntypedValue(name);
+            if (!real)
+            {
+                std::cout << "\n===\n";
+                cout << "Value " << name << " not found in context";
+                std::cout << "\n===\n";
+
+                CPPUNIT_ASSERT(false);
+            }
+            return value ? value : real;
+        }
+        virtual Strategy* GetStrategy(string  name) { return realContext->GetStrategy(name); }
+        virtual set<string> GetSiblingStrategy(string name) { return realContext->GetSiblingStrategy(name); }
+        virtual Trigger* GetTrigger(string  name) { return realContext->GetTrigger(name); }
+        virtual Action* GetAction(string  name) { return realContext->GetAction(name); }
+        virtual void Update()
+        {
+            mockValueContext.Update();
+            realContext->Update();
+        }
+
+    private:
+        AiObjectContext *realContext;
+        MockValueContext mockValueContext;
+    };
+
+}
diff --git a/src/test/ArcaneMageTestCase.cpp b/src/test/ArcaneMageTestCase.cpp
new file mode 100644
index 0000000..b840d4f
--- /dev/null
+++ b/src/test/ArcaneMageTestCase.cpp
@@ -0,0 +1,48 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class ArcaneMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( ArcaneMageTestCase );
+      CPPUNIT_TEST( combatVsMelee );
+      CPPUNIT_TEST( avoid_melee );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "arcane", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+		addAura("arcane blast");
+
+        tick();
+
+        addAura("missile barrage");
+        tick();
+        tickWithSpellAvailable("arcane missiles");
+        tick();
+
+        assertActions(">T:arcane blast>T:arcane barrage>T:arcane missiles>T:arcane missiles>T:shoot");
+	}
+
+ 	void avoid_melee()
+ 	{
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:frost nova>S:flee");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ArcaneMageTestCase );
diff --git a/src/test/BearTankDruidTestCase.cpp b/src/test/BearTankDruidTestCase.cpp
new file mode 100644
index 0000000..620773e
--- /dev/null
+++ b/src/test/BearTankDruidTestCase.cpp
@@ -0,0 +1,215 @@
+#include "pch.h"
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+class BearTankDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( BearTankDruidTestCase );
+        CPPUNIT_TEST( startMeleeCombat );
+        CPPUNIT_TEST( meleeCombat );
+        CPPUNIT_TEST( druidMustHoldAggro );
+        CPPUNIT_TEST( bearFormIfDireNotAvailable );
+        CPPUNIT_TEST( healHimself );
+        CPPUNIT_TEST( intensiveHealing );
+        CPPUNIT_TEST( healOthers );
+        CPPUNIT_TEST( curePoison );
+        CPPUNIT_TEST( interruptSpells );
+        CPPUNIT_TEST( buff );
+        CPPUNIT_TEST( aoe );
+        CPPUNIT_TEST( incompatibles );
+        CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "bear", NULL);
+
+		addAura("thorns");
+        addTargetAura("faerie fire (feral)");
+        set<uint8>("rage", "self target", 100);
+    }
+
+protected:
+    void bearFormIfDireNotAvailable()
+    {
+		tickWithSpellUnavailable("dire bear form");
+
+		assertActions(">S:bear form");
+    }
+
+    void druidMustHoldAggro()
+    {
+        addAura("dire bear form");
+
+		tickWithNoAggro();
+
+		assertActions(">T:growl");
+    }
+
+    void startMeleeCombat()
+    {
+        removeTargetAura("faerie fire (feral)");
+
+        tick();
+        addAura("dire bear form");
+
+        tick();
+        tickInMeleeRange();
+
+        tickOutOfMeleeRange();
+        tickInMeleeRange();
+
+        assertActions(">S:dire bear form>T:feral charge - bear>T:faerie fire (feral)>T:reach melee>T:lacerate");
+    }
+
+    void meleeCombat()
+    {
+        addAura("dire bear form");
+
+        tickInMeleeRange();
+		tick();
+		tick();
+		tick();
+
+		tickWithSpellAvailable("lacerate");
+		tick();
+		tickWithSpellAvailable("lacerate");
+        tick();
+
+        spellAvailable("lacerate");
+        spellAvailable("mangle (bear)");
+        spellAvailable("maul");
+        spellAvailable("faerie fire (feral)");
+
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+		tickWithSpellAvailable("lacerate");
+
+        assertActions(">T:lacerate>T:mangle (bear)>T:maul>T:feral charge - bear>T:faerie fire (feral)>T:lacerate>T:lacerate>T:melee>T:faerie fire (feral)>T:lacerate>T:mangle (bear)>T:maul>T:lacerate");
+    }
+
+    void healHimself()
+    {
+        addAura("dire bear form");
+
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        addAura("dire bear form");
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">T:reach melee>T:lacerate>S:caster form>S:regrowth>S:survival instincts>S:barskin>S:caster form>S:regrowth>S:healing touch");
+    }
+
+    void intensiveHealing()
+    {
+        addAura("dire bear form");
+		tickWithLowHealth(1);
+
+		assertActions(">S:survival instincts");
+    }
+
+    void healOthers()
+    {
+        tick();
+        addAura("dire bear form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+		assertActions(">S:dire bear form>S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+    void curePoison()
+    {
+        tick();
+        addAura("dire bear form");
+
+		tickWithAuraToDispel(DISPEL_POISON);
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("abolish poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("cure poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		assertActions(">S:dire bear form>S:caster form>S:abolish poison>P:abolish poison on party>S:cure poison>P:cure poison on party");
+    }
+    void interruptSpells()
+    {
+        addAura("dire bear form");
+        tickInMeleeRange();
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        assertActions(">T:lacerate>T:bash");
+    }
+	void buff()
+	{
+        removeAura("thorns");
+        tick();
+
+        removeTargetAura("faerie fire (feral)");
+        tickInMeleeRange();
+		addAura("dire bear form");
+
+        assertActions(">S:thorns>S:dire bear form");
+	}
+
+    void aoe()
+    {
+        addAura("dire bear form");
+		tickInMeleeRange();
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(3);
+        spellAvailable("swipe (bear)");
+		tickWithAttackerCount(3);
+
+		assertActions(">T:lacerate>T:swipe (bear)>T:demoralizing roar>T:swipe (bear)");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("bear", "cat", "caster", "dps", "tank", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: bear");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("bash");
+        assertActions(">H:bash on enemy healer");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( BearTankDruidTestCase );
diff --git a/src/test/CMakeLists.txt b/src/test/CMakeLists.txt
new file mode 100644
index 0000000..9a008f2
--- /dev/null
+++ b/src/test/CMakeLists.txt
@@ -0,0 +1,163 @@
+# Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_cppunit cppunit/*.cpp cppunit/*.h)
+file(GLOB_RECURSE sources_efficiency efficiency/*.cpp efficiency/*.h)
+file(GLOB_RECURSE sources_main *.cpp *.h)
+
+# Create game-libary
+
+if (USE_COREPCH)
+  set(tests_STAT_PCH_HDR pch.h)
+  set(tests_STAT_PCH_SRC pch.cpp)
+endif ()
+
+set(tests_STAT_SRCS
+  ${tests_STAT_SRCS}
+  ${sources_cppunit}
+  ${sources_efficiency}
+  ${sources_main}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_SOURCE_DIR}/src/test
+  ${CMAKE_SOURCE_DIR}/src/test/cppunit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/game/Playerbot
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/test/cppunit
+)
+
+add_executable(tests
+  ${tests_STAT_SRCS}
+  ${tests_STAT_PCH_SRC}
+)
+
+add_dependencies(tests revision.h)
+
+target_link_libraries(tests
+  game
+  plugins
+  shared
+  scripts
+  collision
+  g3dlib
+  gsoap
+  Detour
+  ${JEMALLOC_LIBRARY}
+  ${READLINE_LIBRARY}
+  ${TERMCAP_LIBRARY}
+  ${MYSQL_LIBRARY}
+  ${OPENSSL_LIBRARIES}
+  ${ZLIB_LIBRARIES}
+  ${CMAKE_THREAD_LIBS_INIT}
+  ${Boost_LIBRARIES}
+)
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(tests ${tests_STAT_PCH_HDR} ${tests_STAT_PCH_SRC})
+endif ()
diff --git a/src/test/CasterDruidTestCase.cpp b/src/test/CasterDruidTestCase.cpp
new file mode 100644
index 0000000..e529a04
--- /dev/null
+++ b/src/test/CasterDruidTestCase.cpp
@@ -0,0 +1,166 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class CasterDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CasterDruidTestCase );
+    CPPUNIT_TEST( combat);
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+	CPPUNIT_TEST( curePoison );
+	CPPUNIT_TEST( resurrect );
+    CPPUNIT_TEST( cc );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "caster", "caster debuff", NULL);
+
+		addAura("moonkin form");
+    }
+
+protected:
+    void combat()
+    {
+		removeAura("moonkin form");
+		tick();
+		addAura("moonkin form");
+
+		tickOutOfSpellRange();
+
+		tickInSpellRange();
+		addTargetAura("faerie fire");
+
+		tick();
+		addTargetAura("insect swarm");
+
+		tick();
+		addTargetAura("moonfire");
+
+        tick();
+		tick();
+
+		spellAvailable("starfire");
+		tickInSpellRange();
+
+        tickWithBalancePercent(49);
+
+        spellAvailable("starfire");
+        spellAvailable("wrath");
+        addAura("eclipse (lunar)");
+        tick();
+
+        addAura("eclipse (solar)");
+        tick();
+
+		assertActions(">S:moonkin form>T:reach spell>T:faerie fire>T:insect swarm>T:moonfire>T:starfire>T:wrath>T:starfire>S:nature's grasp>T:starfire>T:wrath");
+    }
+
+	void healHimself()
+    {
+		tickWithLowHealth(79);
+		tickWithLowHealth(79);
+        addAura("moonkin form");
+        spellAvailable("rejuvenation");
+
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+		tickWithLowHealth(59);
+
+		addAura("moonkin form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:caster form>S:rejuvenation>S:caster form>S:regrowth>S:healing touch>S:caster form>S:regrowth>S:regrowth>S:healing touch");
+    }
+
+	void healOthers()
+    {
+        addAura("moonkin form");
+
+        tickWithPartyLowHealth(79);
+        tickWithPartyLowHealth(79);
+        addAura("moonkin form");
+        spellAvailable("rejuvenation");
+
+        tickWithPartyLowHealth(59);
+        tickWithPartyLowHealth(59);
+        tickWithPartyLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("moonkin form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">S:caster form>P:rejuvenation on party>S:caster form>P:regrowth on party>P:healing touch on party>S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+
+	void curePoison()
+	{
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("abolish poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		tickWithAuraToDispel(DISPEL_POISON);
+
+		spellAvailable("cure poison");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+
+		assertActions(">S:abolish poison>P:abolish poison on party>S:cure poison>P:cure poison on party");
+	}
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+		tickWithDeadPartyMember();
+
+		assertActions(">S:caster form>P:rebirth");
+	}
+
+    void cc()
+    {
+        tickWithCcTarget("entangling roots");
+
+        assertActions(">Cc:entangling roots on cc");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("caster aoe");
+        tickWithAttackerCount(4);
+        tickWithAttackerCount(4);
+
+		assertActions(">T:starfall>T:hurricane");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CasterDruidTestCase );
diff --git a/src/test/CasterShamanTestCase.cpp b/src/test/CasterShamanTestCase.cpp
new file mode 100644
index 0000000..12912aa
--- /dev/null
+++ b/src/test/CasterShamanTestCase.cpp
@@ -0,0 +1,86 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class CasterShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CasterShamanTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( snare );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "caster", NULL);
+
+        addAura("water shield");
+        addTargetAura("earth shock");
+    }
+
+protected:
+    void combat()
+    {
+        removeTargetAura("earth shock");
+
+		tick();
+        tick();
+        addTargetAura("flame shock");
+
+		tick();
+		tick();
+
+        assertActions(">T:earth shock>T:flame shock>S:searing totem>T:lightning bolt");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bmana");
+        removeAura("water shield");
+
+        tickWithItemForSpell("flametongue weapon");
+
+        tick();
+        addAura("water shield");
+
+        assertActions(">S:flametongue weapon>S:water shield");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("melee", "dps", "heal", "caster", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: caster");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("caster aoe");
+
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        assertActions(">S:flametongue totem>T:reach melee>S:magma totem>T:thunderstorm>T:fire nova>T:chain lightning");
+    }
+
+    void snare()
+    {
+        tickWithTargetIsMoving();
+
+        assertActions(">T:frost shock");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CasterShamanTestCase );
diff --git a/src/test/CatDpsDruidTestCase.cpp b/src/test/CatDpsDruidTestCase.cpp
new file mode 100644
index 0000000..07d2f9d
--- /dev/null
+++ b/src/test/CatDpsDruidTestCase.cpp
@@ -0,0 +1,133 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class CatDpsDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( CatDpsDruidTestCase );
+    CPPUNIT_TEST( combatVsMelee );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( intensiveHealing );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( cower );
+    CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "cat", NULL);
+
+		addAura("cat form");
+        addAura("thorns");
+		addTargetAura("faerie fire (feral)");
+    }
+
+protected:
+
+    void combatVsMelee()
+    {
+		tickInMeleeRange();
+
+		tick();
+
+        tickWithComboPoints(5);
+        tickWithComboPoints(5);
+
+		assertActions(">T:rake>T:mangle (cat)>T:ferocious bite>T:rip");
+    }
+
+	void healHimself()
+	{
+		addAura("cat form");
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:caster form>S:regrowth>S:survival instincts>S:barskin>S:regrowth>S:healing touch");
+	}
+
+    void intensiveHealing()
+    {
+		tickWithLowHealth(1);
+
+		assertActions(">S:survival instincts");
+    }
+
+    void healOthers()
+    {
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("dire bear form");
+        tickWithPartyLowHealth(39);
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        addAura("cat form");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">S:caster form>P:regrowth on party>S:caster form>P:regrowth on party>P:healing touch on party");
+    }
+
+    void boost()
+    {
+		tickWithBalancePercent(49);
+
+		assertActions(">S:tiger's fury");
+    }
+
+    void cower()
+    {
+		tickWithMyAttackerCount(2);
+
+		assertActions(">S:cower");
+    }
+
+    void buff()
+    {
+        removeAura("cat form");
+        removeAura("thorns");
+        tick();
+        addAura("cat form");
+
+        removeTargetAura("faerie fire (feral)");
+        tickInMeleeRange();
+
+        assertActions(">S:cat form>T:faerie fire (feral)");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("cat aoe");
+
+		tickInMeleeRange();
+		tickWithAttackerCount(3);
+
+		assertActions(">T:rake>T:swipe (cat)");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( CatDpsDruidTestCase );
diff --git a/src/test/ChatCommandTestCase.cpp b/src/test/ChatCommandTestCase.cpp
new file mode 100644
index 0000000..45e25c4
--- /dev/null
+++ b/src/test/ChatCommandTestCase.cpp
@@ -0,0 +1,454 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class ChatCommandTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( ChatCommandTestCase );
+      CPPUNIT_TEST( stats );
+      CPPUNIT_TEST( leave );
+      CPPUNIT_TEST( quests );
+      CPPUNIT_TEST( reputation );
+      CPPUNIT_TEST( log );
+      CPPUNIT_TEST( los );
+      CPPUNIT_TEST( drop );
+      CPPUNIT_TEST( query );
+      CPPUNIT_TEST( ll );
+      CPPUNIT_TEST( loot_all );
+      CPPUNIT_TEST( release );
+      CPPUNIT_TEST( teleport );
+      CPPUNIT_TEST( taxi );
+      CPPUNIT_TEST( repair );
+      CPPUNIT_TEST( use );
+      CPPUNIT_TEST( item_count );
+      CPPUNIT_TEST( reward );
+      CPPUNIT_TEST( trade );
+      CPPUNIT_TEST( equip );
+      CPPUNIT_TEST( unequip );
+      CPPUNIT_TEST( sell );
+      CPPUNIT_TEST( buy );
+      CPPUNIT_TEST( talents );
+      CPPUNIT_TEST( spells );
+      CPPUNIT_TEST( strategy );
+      CPPUNIT_TEST( trainer );
+      CPPUNIT_TEST( attack );
+      CPPUNIT_TEST( chat );
+      CPPUNIT_TEST( accept );
+      CPPUNIT_TEST( home );
+      CPPUNIT_TEST( destroy );
+      CPPUNIT_TEST( reset_ai );
+      CPPUNIT_TEST( emote );
+      CPPUNIT_TEST( buff );
+      CPPUNIT_TEST( help );
+      CPPUNIT_TEST( gb );
+      CPPUNIT_TEST( bank );
+      CPPUNIT_TEST( follow );
+      CPPUNIT_TEST( flee );
+      CPPUNIT_TEST( stay );
+      CPPUNIT_TEST( grind );
+      CPPUNIT_TEST( tank_attack );
+      CPPUNIT_TEST( talk );
+      CPPUNIT_TEST( cast );
+      CPPUNIT_TEST( invite );
+      CPPUNIT_TEST( spell );
+      CPPUNIT_TEST( rti );
+      CPPUNIT_TEST( revive );
+      CPPUNIT_TEST( runaway );
+      CPPUNIT_TEST( warning );
+      CPPUNIT_TEST( position );
+      CPPUNIT_TEST( summon );
+      CPPUNIT_TEST( who );
+      CPPUNIT_TEST( save_mana );
+      CPPUNIT_TEST( max_dps );
+      CPPUNIT_TEST( tell_attackers );
+      CPPUNIT_TEST( formation );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "chat", NULL);
+    }
+
+protected:
+ 	void stats()
+	{
+        assertCommand("stats");
+	}
+
+    void leave()
+    {
+        assertCommand("leave");
+    }
+
+    void reputation()
+    {
+        assertCommand("rep", "reputation");
+        assertCommand("reputation");
+    }
+
+    void quests()
+    {
+        assertCommand("quests");
+        assertParametrizedCommand("quests", "summary");
+        assertParametrizedCommand("quests", "completed");
+        assertParametrizedCommand("quests", "incompleted");
+    }
+
+    void log()
+    {
+        assertCommand("log");
+        assertParametrizedCommand("log", "debug");
+    }
+
+    void los()
+    {
+        assertCommand("los");
+        assertParametrizedCommand("los", "targets");
+        assertParametrizedCommand("los", "npcs");
+        assertParametrizedCommand("los", "gos");
+        assertParametrizedCommand("los", "game objects");
+        assertParametrizedCommand("los", "corpses");
+    }
+
+    void drop()
+    {
+        assertCommand("drop");
+    }
+
+    void query()
+    {
+        trigger("q");
+        tick();
+        tick();
+
+        assertActions(">S:query quest>S:query item usage");
+    }
+
+    void ll()
+    {
+        assertCommand("ll");
+        assertParametrizedCommand("ll", "?");
+        assertParametrizedCommand("ll", "[item]");
+        assertParametrizedCommand("ll", "-[item]");
+        assertParametrizedCommand("ll", "all");
+    }
+
+    void loot_all()
+    {
+        trigger("add all loot");
+        tick();
+        tick();
+
+        assertActions(">S:add all loot>S:loot");
+    }
+
+    void release()
+    {
+        assertCommand("release");
+    }
+
+    void teleport()
+    {
+        assertCommand("teleport");
+    }
+
+    void taxi()
+    {
+        assertCommand("taxi");
+    }
+
+    void repair()
+    {
+        assertCommand("repair");
+    }
+
+    void use()
+    {
+        trigger("u");
+        tick();
+
+        assertActions(">S:use");
+    }
+
+    void item_count()
+    {
+        trigger("c");
+        tick();
+
+        assertActions(">S:item count");
+    }
+
+    void reward()
+    {
+        trigger("r");
+        tick();
+
+        assertActions(">S:reward");
+    }
+    void trade()
+    {
+        trigger("t");
+        tick();
+        trigger("nt");
+        tick();
+
+        assertActions(">S:trade>S:trade");
+    }
+    void sell()
+    {
+        trigger("s");
+        tick();
+
+        assertActions(">S:sell");
+    }
+    void buy()
+    {
+        trigger("b");
+        tick();
+
+        assertActions(">S:buy");
+    }
+    void equip()
+    {
+        trigger("e");
+        tick();
+
+        assertActions(">S:equip");
+    }
+    void unequip()
+    {
+        trigger("ue");
+        tick();
+
+        assertActions(">S:unequip");
+    }
+
+    void talents()
+    {
+        assertParametrizedCommand("talents", "1");
+        assertParametrizedCommand("talents", "2");
+    }
+
+    void spells()
+    {
+        assertCommand("spells");
+    }
+
+    void strategy()
+    {
+        assertParametrizedCommand("co", "?");
+        assertParametrizedCommand("nc", "?");
+        assertParametrizedCommand("dead", "?");
+    }
+
+    void trainer()
+    {
+        assertParametrizedCommand("trainer", "?");
+        assertParametrizedCommand("trainer", "learn");
+    }
+
+    void attack()
+    {
+        trigger("attack");
+        tick();
+        assertActions(">S:attack my target");
+    }
+
+    void chat()
+    {
+        assertParametrizedCommand("chat", "?");
+        assertParametrizedCommand("chat", "raid");
+    }
+
+    void accept()
+    {
+        trigger("accept");
+        tick();
+        assertActions(">S:accept quest");
+    }
+
+    void home()
+    {
+        assertCommand("home");
+    }
+
+    void reset_ai()
+    {
+        assertCommand("reset ai");
+    }
+
+    void destroy()
+    {
+        assertCommand("destroy");
+    }
+
+    void emote()
+    {
+        assertCommand("emote");
+    }
+
+    void buff()
+    {
+        assertCommand("buff");
+        assertParametrizedCommand("buff", "?");
+    }
+
+    void help()
+    {
+        assertCommand("help");
+    }
+
+    void follow()
+    {
+        trigger("follow");
+        tick();
+        assertActions(">S:follow chat shortcut");
+    }
+
+    void stay()
+    {
+        trigger("stay");
+        tick();
+        assertActions(">S:stay chat shortcut");
+    }
+
+    void flee()
+    {
+        trigger("flee");
+        tick();
+        assertActions(">S:flee chat shortcut");
+    }
+
+    void grind()
+    {
+        trigger("grind");
+        tick();
+        assertActions(">S:grind chat shortcut");
+    }
+
+    void tank_attack()
+    {
+        trigger("tank attack");
+        tick();
+        tick();
+        assertActions(">S:tank attack chat shortcut>S:attack my target");
+    }
+
+    void gb()
+    {
+        assertParametrizedCommand("gb", "link");
+    }
+
+    void bank()
+    {
+        assertParametrizedCommand("bank", "link");
+    }
+
+    void talk()
+    {
+        trigger("talk");
+        tick();
+        assertActions(">S:gossip hello");
+    }
+
+    void cast()
+    {
+        trigger("cast");
+        tick();
+        assertActions(">S:cast custom spell");
+    }
+
+    void invite()
+    {
+        trigger("invite");
+        tick();
+        assertActions(">S:invite");
+    }
+
+    void spell()
+    {
+        trigger("spell");
+        tick();
+        assertActions(">S:spell");
+    }
+
+    void rti()
+    {
+        trigger("rti");
+        tick();
+        assertActions(">S:rti");
+    }
+
+    void revive()
+    {
+        trigger("revive");
+        tick();
+        assertActions(">S:spirit healer");
+    }
+
+    void runaway()
+    {
+        trigger("runaway");
+        tick();
+        assertActions(">S:runaway chat shortcut");
+    }
+
+    void warning()
+    {
+        trigger("warning");
+        tick();
+        assertActions(">S:runaway chat shortcut");
+    }
+
+    void position()
+    {
+        assertParametrizedCommand("position", "guard");
+    }
+
+    void summon()
+    {
+        assertParametrizedCommand("summon", "summon");
+    }
+
+    void who()
+    {
+        assertCommand("who", "who");
+    }
+
+    void save_mana()
+    {
+        assertParametrizedCommand("save mana", "save mana");
+    }
+
+    void max_dps()
+    {
+        trigger("max dps");
+        tick();
+        assertActions(">S:max dps chat shortcut");
+    }
+
+    void tell_attackers()
+    {
+        trigger("attackers");
+        tick();
+        assertActions(">S:tell attackers");
+    }
+
+    void formation()
+    {
+        trigger("formation");
+        tick();
+        assertActions(">S:formation");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ChatCommandTestCase );
diff --git a/src/test/ChatFilterTestCase.cpp b/src/test/ChatFilterTestCase.cpp
new file mode 100644
index 0000000..83e9604
--- /dev/null
+++ b/src/test/ChatFilterTestCase.cpp
@@ -0,0 +1,32 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/ChatFilter.h"
+
+using namespace ai;
+
+class ChatFilterTestCase : public CPPUNIT_NS::TestFixture
+{
+public:
+	ChatFilterTestCase() : filter(NULL) {}
+
+  CPPUNIT_TEST_SUITE( ChatFilterTestCase );
+      CPPUNIT_TEST( filter1 );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	ChatFilter filter;
+
+	void filter1()
+	{
+	    string message = filter.Filter("@some message for some");
+	    CPPUNIT_ASSERT(message == "message for some");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ChatFilterTestCase );
diff --git a/src/test/DpsHunterEngineTestCase.cpp b/src/test/DpsHunterEngineTestCase.cpp
new file mode 100644
index 0000000..59d3673
--- /dev/null
+++ b/src/test/DpsHunterEngineTestCase.cpp
@@ -0,0 +1,160 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+
+using namespace ai;
+
+class DpsHunterEngineTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( DpsHunterEngineTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( summonPet );
+  CPPUNIT_TEST( lowMana );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( cc );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( buff );
+  CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST( feign_death );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new HunterAiObjectContext(ai), "dps", "dps debuff", NULL);
+		engine->addStrategy("bdps");
+
+        addAura("aspect of the hawk");
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        removeAura("aspect of the hawk");
+
+		tick();
+        addAura("aspect of the hawk");
+
+		tick();
+        tick();
+		tick();
+		addTargetAura("serpent sting");
+
+		tick();
+		tick();
+
+		tickInMeleeRange();
+		spellAvailable("wing clip");
+		addTargetAura("wing clip");
+		tickInMeleeRange();
+		tickInSpellRange();
+
+		// resetSpells
+		tickWithSpellUnavailable("aimed shot");
+
+        tick();
+        tick();
+		tickWithSpellAvailable("auto shot");
+
+		assertActions(">S:aspect of the hawk>T:hunter's mark>T:black arrow>T:serpent sting>T:explosive shot>T:auto shot>T:wing clip>S:flee>T:concussive shot>T:wyvern sting>T:chimera shot>T:arcane shot>T:auto shot");
+
+	}
+
+    void lowMana()
+    {
+        spellUnavailable("serpent sting");
+        spellUnavailable("concussive shot");
+        removeAura("aspect of the hawk");
+
+		tickWithLowMana(30);
+
+		tick();
+
+		assertActions(">T:viper sting>S:aspect of the hawk");
+
+    }
+
+    void summonPet()
+    {
+        tickWithNoPet();
+		tickWithPetLowHealth(30);
+
+		assertActions(">S:call pet>Pet:mend pet");
+	}
+
+
+    void boost()
+    {
+		tick();
+        spellUnavailable("serpent sting");
+
+		tickWithBalancePercent(1);
+		tickWithBalancePercent(1);
+
+		assertActions(">T:hunter's mark>S:rapid fire>S:readiness");
+    }
+
+
+    void cc()
+    {
+        tickWithCcTarget("freezing trap");
+
+        assertActions(">Cc:freezing trap");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+		addTargetAura("hunter's mark");
+		addTargetAura("black arrow");
+		addTargetAura("serpent sting");
+        tickWithAttackerCount(3);
+		tickWithAttackerCount(4);
+
+        set<Unit*>("attacker without aura", "serpent sting", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "serpent sting", NULL);
+        tick();
+
+		assertActions(">T:multi-shot>T:volley>A:serpent sting on attacker>T:explosive shot");
+    }
+
+	void buff()
+	{
+		engine->removeStrategy("bdps");
+		engine->addStrategy("rnature");
+		removeAura("aspect of the hawk");
+
+		tick();
+		addAura("aspect of the wild");
+
+		assertActions(">S:aspect of the wild");
+
+	}
+
+    void incompatibles()
+    {
+        engine->removeStrategy("dps");
+        engine->removeStrategy("dps debuff");
+        engine->addStrategies("bdps", "bspeed", "rnature", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: rnature");
+    }
+
+    void feign_death()
+    {
+        tick();
+
+        tickWithMyAttackerCount(3);
+        set<float>("distance", "current target", 5);
+        tickWithMyAttackerCount(3);
+
+        assertActions(">T:hunter's mark>S:feign death>S:flee");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsHunterEngineTestCase );
diff --git a/src/test/DpsPaladinTestCase.cpp b/src/test/DpsPaladinTestCase.cpp
new file mode 100644
index 0000000..e0a6dea
--- /dev/null
+++ b/src/test/DpsPaladinTestCase.cpp
@@ -0,0 +1,73 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsPaladinTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsPaladinTestCase );
+    CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( combatVsMelee );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "dps", NULL);
+		engine->addStrategy("bdps");
+
+        addAura("retribution aura");
+        addAura("seal of vengeance");
+        addAura("blessing of might");
+
+        set<float>("distance", "current target", 0.0f);
+    }
+
+protected:
+    void buff()
+    {
+        removeAura("retribution aura");
+        removeAura("blessing of might");
+        removeAura("seal of vengeance");
+        removeAura("holy shield");
+
+        tick();
+        addAura("devotion aura");
+
+        tick();
+        tick();
+        tick();
+        tick();
+        addAura("seal of wisdom");
+
+        tick();
+        tick();
+        addAura("blessing of kings");
+
+        assertActions(">S:retribution aura>S:seal of vengeance>S:seal of command>S:seal of wisdom>S:seal of justice>S:blessing of might>S:blessing of kings");
+    }
+
+    void combatVsMelee()
+    {
+		tickOutOfMeleeRange();
+
+        tick();
+		tick();
+		addTargetAura("judgement of wisdom");
+
+		tick();
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		tickWithTargetLowHealth(19);
+
+		assertActions(">T:reach melee>T:judgement of wisdom>T:judgement of light>T:crusader strike>S:divine storm>T:consecration>T:hammer of wrath");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsPaladinTestCase );
diff --git a/src/test/DpsPriestTestCase.cpp b/src/test/DpsPriestTestCase.cpp
new file mode 100644
index 0000000..1f53d8e
--- /dev/null
+++ b/src/test/DpsPriestTestCase.cpp
@@ -0,0 +1,88 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsPriestTestCase );
+    CPPUNIT_TEST( combat );
+    CPPUNIT_TEST( low_mana );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "dps", "dps debuff", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void combat()
+    {
+        tick();
+        addAura("vampiric embrace");
+
+        tick();
+        addAura("shadowform");
+
+        tick();
+        tick();
+        tick();
+        tick();
+        tick();
+        tick();
+
+        tickWithLowHealth(39);
+        tickWithLowHealth(39);
+        tickWithLowHealth(39);
+
+        spellAvailable("power word: shield");
+        spellAvailable("greater heal");
+        addAura("shadowform");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:vampiric embrace>S:shadowform>T:devouring plague>T:shadow word: pain>T:vampiric touch>T:mind blast>T:mind flay>T:shoot>S:remove shadowform>S:power word: shield>S:greater heal>S:remove shadowform>S:power word: shield>S:flash heal");
+    }
+
+    void low_mana()
+    {
+        tickWithLowMana(1);
+
+        assertActions(">S:dispersion");
+    }
+
+    void aoe()
+    {
+        addAura("vampiric embrace");
+        addAura("shadowform");
+        addTargetAura("devouring plague");
+        addTargetAura("shadow word: pain");
+        addTargetAura("vampiric touch");
+
+        engine->addStrategy("aoe");
+
+        set<Unit*>("attacker without aura", "shadow word: pain", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "shadow word: pain", NULL);
+        tick();
+
+        assertActions(">A:shadow word: pain on attacker>T:mind blast");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsPriestTestCase );
diff --git a/src/test/DpsRogueTestCase.cpp b/src/test/DpsRogueTestCase.cpp
new file mode 100644
index 0000000..e0d5c6a
--- /dev/null
+++ b/src/test/DpsRogueTestCase.cpp
@@ -0,0 +1,74 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/rogue/RogueAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsRogueTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsRogueTestCase );
+		CPPUNIT_TEST( combatVsMelee );
+		CPPUNIT_TEST( healHimself );
+		CPPUNIT_TEST( interruptSpells );
+		CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new RogueAiObjectContext(ai), "dps", NULL);
+        addAura("slice and dice");
+        addTargetAura("rupture");
+    }
+
+protected:
+    void combatVsMelee()
+    {
+        removeTargetAura("rupture");
+
+		tickOutOfMeleeRange();
+		tickInMeleeRange();
+		tick();
+
+		tickWithEnergy(70);
+        tickWithEnergy(70);
+
+        tickWithComboPoints(5);
+        tickWithComboPoints(5);
+
+        tickBehindTarget();
+
+        assertActions(">T:reach melee>T:riposte>T:mutilate>T:sinister strike>T:melee>T:rupture>T:eviscerate>T:backstab");
+    }
+
+	void healHimself()
+	{
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithMyAttackerCount(3);
+
+		assertActions(">S:evasion>S:feint>S:vanish");
+	}
+
+	void interruptSpells()
+	{
+        tickInMeleeRange();
+
+		tickWithTargetIsCastingNonMeleeSpell();
+		tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:riposte>T:kick>T:kidney shot");
+	}
+
+	void interrupt_enemy_healer()
+	{
+	    tickWithEnemyHealerIsCastingInterruptableSpell("kick");
+
+		assertActions(">H:kick on enemy healer");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsRogueTestCase );
diff --git a/src/test/DpsWarlockTestCase.cpp b/src/test/DpsWarlockTestCase.cpp
new file mode 100644
index 0000000..2bb5e7b
--- /dev/null
+++ b/src/test/DpsWarlockTestCase.cpp
@@ -0,0 +1,93 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsWarlockTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( DpsWarlockTestCase );
+      CPPUNIT_TEST( combatVsMelee );
+      CPPUNIT_TEST( aoe );
+      CPPUNIT_TEST( low_mana );
+      CPPUNIT_TEST( cc );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "dps", "dps debuff", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+ 	    tick();
+ 	    addTargetAura("immolate");
+
+ 	    tick();
+
+        tick();
+        addTargetAura("corruption");
+        tick();
+        addTargetAura("curse of agony");
+
+        tick();
+
+        tickWithLowHealth(49);
+
+        tick();
+
+		tickWithTargetLowHealth(19);
+
+        set<uint8>("item count", "soul shard", 2);
+		spellAvailable("drain soul");
+		tick();
+
+		spellAvailable("shadow bolt");
+		addAura("shadow trance");
+		tick();
+
+        spellAvailable("shadow bolt");
+		addAura("backlash");
+		tick();
+
+		assertActions(">T:immolate>T:conflagrate>T:corruption>T:curse of agony>T:incinirate>T:drain life>T:shadow bolt>T:drain soul>T:shoot>T:shadow bolt>T:shadow bolt");
+	}
+
+    void low_mana()
+    {
+        tickWithLowMana(1);
+
+		assertActions(">S:life tap");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+        tickWithAttackerCount(2);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(4);
+
+        set<Unit*>("attacker without aura", "corruption", MockedTargets::GetAttackerWithoutAura());
+        tick();
+
+        set<Unit*>("attacker without aura", "corruption", NULL);
+        tick();
+
+		assertActions(">T:shadowfury>T:seed of corruption>T:rain of fire>A:corruption on attacker>T:immolate");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("fear");
+
+        assertActions(">Cc:fear on cc");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsWarlockTestCase );
diff --git a/src/test/DpsWarriorTestCase.cpp b/src/test/DpsWarriorTestCase.cpp
new file mode 100644
index 0000000..66554e1
--- /dev/null
+++ b/src/test/DpsWarriorTestCase.cpp
@@ -0,0 +1,127 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class DpsWarriorTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DpsWarriorTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( combatVsMelee );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( execute );
+    CPPUNIT_TEST( hamstring );
+	CPPUNIT_TEST( victoryRush );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarriorAiObjectContext(ai), "dps", NULL);
+
+		spellUnavailable("revenge");
+        addAura("battle shout");
+        set<uint8>("rage", "self target", 20);
+    }
+
+protected:
+    void buff()
+    {
+        removeAura("battle shout");
+
+        tickInSpellRange(); // reach melee
+		tickInMeleeRange();
+        tick();
+
+		assertActions(">S:battle shout>S:battle stance>T:charge");
+
+    }
+
+    void combatVsMelee()
+    {
+		tickInSpellRange();
+		tickInSpellRange();
+
+		tickInMeleeRange();
+
+		tickInSpellRange();
+
+		tickInMeleeRange();
+
+        tick();
+        addTargetAura("rend");
+
+        tick();
+
+        set<uint8>("rage", "self target", 0);
+        tick();
+
+		assertActions(">S:battle stance>T:charge>T:bloodthirst>T:reach melee>T:rend>T:heroic strike>T:melee>S:bloodrage");
+    }
+
+    void boost()
+    {
+        tickInMeleeRange(); // battle stance
+
+		tickWithBalancePercent(1);
+		tickWithBalancePercent(1);
+
+		assertActions(">S:battle stance>S:death wish>S:berserker rage");
+    }
+
+    void execute()
+    {
+        tickInMeleeRange(); // battle stance
+
+		tickWithTargetLowHealth(19);
+
+		assertActions(">S:battle stance>T:execute");
+    }
+
+
+    void hamstring ()
+    {
+		tickInMeleeRange(); // reach melee
+
+		tickWithTargetIsMoving();
+
+		assertActions(">S:battle stance>T:hamstring");
+    }
+
+
+	void victoryRush()
+	{
+		tickInMeleeRange();
+		addAura("victory rush");
+
+		tick();
+
+		assertActions(">S:battle stance>T:victory rush");
+	}
+
+    void aoe()
+    {
+        engine->addStrategy("aoe");
+
+        tickInMeleeRange();
+
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        set<Unit*>("attacker without aura", "rend", MockedTargets::GetAttackerWithoutAura());
+        tickInMeleeRange();
+
+        set<Unit*>("attacker without aura", "rend", NULL);
+        tickInMeleeRange();
+
+        assertActions(">S:battle stance>T:cleave>T:thunder clap>T:demoralizing shout>A:rend on attacker>T:bloodthirst");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DpsWarriorTestCase );
diff --git a/src/test/DruidNonCombatTestCase.cpp b/src/test/DruidNonCombatTestCase.cpp
new file mode 100644
index 0000000..27190fd
--- /dev/null
+++ b/src/test/DruidNonCombatTestCase.cpp
@@ -0,0 +1,70 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class DruidNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( DruidNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( low_mana );
+	CPPUNIT_TEST( resurrect );
+	CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+    void buff()
+    {
+		tick();
+		addAura("mark of the wild");
+
+		tickWithSpellAvailable("mark of the wild");
+
+		assertActions(">S:mark of the wild>P:mark of the wild on party");
+    }
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+
+		assertActions(">P:revive");
+	}
+
+	void low_mana()
+	{
+	    engine->addStrategy("flee");
+        set<uint8>("item count", "drink", 1);
+        tickWithLowMana(5);
+        tickWithLowMana(5);
+
+        set<uint8>("item count", "drink", 0);
+        tickWithLowMana(5);
+
+        assertActions(">S:innervate>S:drink>S:flee");
+    }
+
+    void dispel()
+    {
+        tickWithAuraToDispel(DISPEL_POISON);
+        tickWithAuraToDispel(DISPEL_POISON);
+
+        spellAvailable("abolish poison");
+        spellAvailable("cure poison");
+        tickWithPartyAuraToDispel(DISPEL_POISON);
+        tickWithPartyAuraToDispel(DISPEL_POISON);
+
+        assertActions(">S:abolish poison>S:cure poison>P:abolish poison on party>P:cure poison on party");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DruidNonCombatTestCase );
diff --git a/src/test/DuelTestCase.cpp b/src/test/DuelTestCase.cpp
new file mode 100644
index 0000000..f4aede4
--- /dev/null
+++ b/src/test/DuelTestCase.cpp
@@ -0,0 +1,44 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class DuelTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( DuelTestCase );
+      CPPUNIT_TEST( accept );
+      CPPUNIT_TEST( attack );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "default", "duel", NULL);
+    }
+
+protected:
+    void accept()
+    {
+        trigger("duel requested");
+        tick();
+
+        assertActions(">S:accept duel");
+    }
+    void attack()
+    {
+        trigger("no attackers");
+        context->GetValue<Unit*>("duel target")->Set(MockedTargets::GetDuelTarget());
+        tick();
+        context->GetValue<Unit*>("duel target")->Set(NULL);
+
+        assertActions(">S:attack duel opponent");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DuelTestCase );
diff --git a/src/test/EngineTestBase.cpp b/src/test/EngineTestBase.cpp
new file mode 100644
index 0000000..8cf4dec
--- /dev/null
+++ b/src/test/EngineTestBase.cpp
@@ -0,0 +1,479 @@
+#include "pch.h"
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "MockedTargets.h"
+#include "AiObjectContextWrapper.h"
+
+class TestActionExecutionListener : public ActionExecutionListener
+{
+public:
+    TestActionExecutionListener(MockPlayerbotAIBase *ai) : ai(ai) {}
+
+    virtual bool Before(Action* action, Event event) { return true; }
+    virtual bool AllowExecution(Action* action, Event event) { return false; }
+    virtual bool OverrideResult(Action* action, bool executed, Event event) { return executed; }
+    virtual void After(Action* action, bool executed, Event event)
+    {
+        string name = action->getName();
+
+        ai->buffer.append(">");
+        MockedTargets::Append(ai->buffer, action->GetTarget());
+        ai->buffer.append(":");
+        ai->buffer.append(name);
+
+        if (!event.getParam().empty())
+        {
+            ai->buffer.append("(");
+            ai->buffer.append(event.getParam());
+            ai->buffer.append(")");
+        }
+
+        if (name == "caster form")
+        {
+            ai->auras[MockedTargets::GetSelf()].remove("dire bear form");
+            ai->auras[MockedTargets::GetSelf()].remove("bear form");
+            ai->auras[MockedTargets::GetSelf()].remove("cat form");
+            ai->auras[MockedTargets::GetSelf()].remove("moonkin form");
+            ai->auras[MockedTargets::GetSelf()].remove("travel form");
+            ai->auras[MockedTargets::GetSelf()].remove("aquatic form");
+        }
+        if (name == "remove shadowform")
+        {
+            ai->auras[MockedTargets::GetSelf()].remove("shadowform");
+        }
+        if (name == "reach melee" ||
+                name == "feral charge - bear" || name == "feral charge - cat" ||
+                name == "charge")
+        {
+            ai->GetAiObjectContext()->GetValue<float>("distance", "current target")->Set(ATTACK_DISTANCE - 1);
+        }
+
+        remove(name, " on party");
+        remove(name, " on cc");
+        remove(name, " on enemy healer");
+        if (name.find("cleanse") != string ::npos)
+            name = "cleanse";
+        if (name.find("purify") != string ::npos)
+            name = "purify";
+
+        ai->spellCooldowns.push_back(name);
+    }
+
+    void remove(string & name, string pattern)
+    {
+        size_t pos = name.find(pattern);
+        if (pos != string ::npos)
+            name = name.substr(0, pos);
+    }
+
+private:
+    MockPlayerbotAIBase *ai;
+};
+
+
+void EngineTestBase::setUp()
+{
+	ai = new MockPlayerbotAIBase();
+}
+
+void EngineTestBase::tearDown()
+{
+    if (engine)
+        delete engine;
+    if (ai)
+        delete ai;
+}
+
+void EngineTestBase::va_generic(void (EngineTestBase::*callback)(const char*), va_list vl)
+{
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			(this->*callback)(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+
+void EngineTestBase::setupEngine(AiObjectContext* aiObjectContext, ...)
+{
+    context = new AiObjectContextWrapper(ai, aiObjectContext);
+    ai->SetContext(context);
+    engine = new Engine(ai, context);
+	engine->testMode = true;
+    engine->AddActionExecutionListener(new TestActionExecutionListener(ai));
+
+	va_list vl;
+	va_start(vl, aiObjectContext);
+
+	va_generic(&EngineTestBase::setupEngineCallback, vl);
+
+	engine->Init();
+}
+
+void EngineTestBase::setupEngineCallback(const char* name)
+{
+	engine->addStrategy(name);
+}
+
+void EngineTestBase::tick()
+{
+	engine->DoNextAction(NULL);
+}
+
+void EngineTestBase::assertActions(string  expected)
+{
+	bool pass = ai->buffer == expected;
+	if (!pass)
+	{
+		std::cout << "\n===\n";
+		std::cout << "Exp: " << expected << "\n";
+		std::cout << "Act: " << ai->buffer << "\n";
+		std::cout << "===\n";
+	}
+    CPPUNIT_ASSERT(pass);
+}
+
+void EngineTestBase::tickWithNoTarget()
+{
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    set<uint8>("my attacker count", 0);
+
+	tick();
+
+    set<uint8>("my attacker count", 1);
+    context->GetValue<Unit*>("current target")->Set(MockedTargets::GetCurrentTarget());
+}
+
+void EngineTestBase::spellUnavailable(string  spell)
+{
+	ai->spellCooldowns.push_back(spell);
+}
+
+void EngineTestBase::tickWithSpellUnavailable(string  spell)
+{
+	spellUnavailable(spell);
+	tick();
+}
+
+void EngineTestBase::tickWithSpellAvailable(string  spell)
+{
+	spellAvailable(spell);
+	tick();
+}
+
+void EngineTestBase::spellAvailable(string  spell)
+{
+    list<string > remove;
+    for (list<string >::iterator i = ai->spellCooldowns.begin(); i != ai->spellCooldowns.end(); i++)
+    {
+        if (i->find(spell) != string ::npos) remove.push_back(*i);
+    }
+    for (list<string >::iterator i = remove.begin(); i != remove.end(); i++)
+    {
+        ai->spellCooldowns.remove(*i);
+    }
+}
+
+void EngineTestBase::addAura(string  spell)
+{
+	ai->auras[MockedTargets::GetSelf()].push_back(spell);
+}
+
+void EngineTestBase::removeAura(string  spell)
+{
+	ai->auras[MockedTargets::GetSelf()].remove(spell);
+}
+
+void EngineTestBase::tickOutOfSpellRange()
+{
+    set<float>("distance", "current target", 49.0f);
+    tick();
+    set<float>("distance", "current target", 15.0f);
+}
+
+void EngineTestBase::tickOutOfMeleeRange()
+{
+    set<float>("distance", "current target", 15.0f);
+    tick();
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+}
+
+void EngineTestBase::setInMeleeRange()
+{
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+}
+
+void EngineTestBase::tickInMeleeRange()
+{
+    set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+	tick();
+}
+
+void EngineTestBase::tickWithNoAggro()
+{
+    set<bool>("has aggro", "current target", false);
+    tick();
+    set<bool>("has aggro", "current target", true);
+}
+
+void EngineTestBase::tickWithRage(int amount)
+{
+    set<uint8>("rage", "self target", amount);
+    tick();
+    set<uint8>("rage", "self target", 0);
+}
+
+void EngineTestBase::tickWithEnergy(int amount)
+{
+    set<uint8>("energy", "self target", amount);
+	tick();
+    set<uint8>("energy", "self target", 0);
+}
+
+void EngineTestBase::tickWithAttackerCount(int count)
+{
+    set<uint8>("attacker count", count);
+	tick();
+    set<uint8>("attacker count", 1);
+}
+
+void EngineTestBase::tickWithMyAttackerCount(int count)
+{
+    set<uint8>("my attacker count", count);
+	tickWithAttackerCount(count + 1);
+    set<uint8>("my attacker count", 1);
+}
+
+void EngineTestBase::tickWithLowHealth(int amount)
+{
+	lowHealth(amount);
+	tick();
+	healthRestored();
+}
+
+void EngineTestBase::tickWithPartyLowHealth(int amount)
+{
+    set<uint8>("health", "party member to heal", amount);
+	tick();
+    set<uint8>("health", "party member to heal", 100);
+}
+
+void EngineTestBase::tickWithAoeHeal(string type, int amount)
+{
+    set<uint8>("health", "party member to heal", 45);
+	set<uint8>("aoe heal", "medium", amount);
+	tick();
+	set<uint8>("aoe heal", "medium", 0);
+    set<uint8>("health", "party member to heal", 100);
+}
+
+void EngineTestBase::tickWithAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetSelf()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetSelf()] = 0;
+}
+
+void EngineTestBase::tickWithPartyAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetPartyMember()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetPartyMember()] = 0;
+}
+
+void EngineTestBase::tickWithTargetAuraToDispel(uint32 type)
+{
+	ai->dispels[MockedTargets::GetCurrentTarget()] = type;
+	tick();
+	ai->dispels[MockedTargets::GetCurrentTarget()] = 0;
+}
+
+void EngineTestBase::lowHealth(int amount)
+{
+    set<uint8>("health", "self target", amount);
+}
+
+void EngineTestBase::lowMana(int amount)
+{
+    set<uint8>("mana", "self target", amount);
+}
+
+void EngineTestBase::healthRestored()
+{
+    set<uint8>("health", "self target", 100);
+}
+
+void EngineTestBase::tickWithComboPoints(int amount)
+{
+    set<uint8>("combo", "current target", amount);
+	tick();
+    set<uint8>("combo", "current target", 0);
+}
+
+void EngineTestBase::tickWithTargetIsCastingNonMeleeSpell()
+{
+    ai->targetIsCastingNonMeleeSpell = true;
+    tick();
+    ai->targetIsCastingNonMeleeSpell = false;
+}
+
+void EngineTestBase::tickWithBalancePercent(int percent)
+{
+    set<uint8>("balance", percent);
+	tick();
+    set<uint8>("balance", 100);
+}
+
+void EngineTestBase::tickWithNoPet()
+{
+    context->GetValue<Unit*>("pet target")->Set(NULL);
+	tick();
+    context->GetValue<Unit*>("pet target")->Set(MockedTargets::GetPet());
+}
+
+void EngineTestBase::tickWithPetLowHealth(int amount)
+{
+    set<uint8>("health", "pet target", amount);
+	tick();
+    set<uint8>("health", "pet target", 100);
+}
+
+void EngineTestBase::tickWithPetDead()
+{
+    set<bool>("dead", "pet target", true);
+    tick();
+    set<bool>("dead", "pet target", false);
+}
+
+void EngineTestBase::tickWithLowMana(int amount)
+{
+    Value<float>* distance = context->GetValue<float>("distance", "current target");
+    float oldDistance = distance->Get();
+    distance->Set(5.0f);
+    set<uint8>("mana", "self target", amount);
+    tick();
+    set<uint8>("mana", "self target", 100);
+    distance->Set(oldDistance);
+}
+
+void EngineTestBase::tickWithTargetLowHealth(int amount)
+{
+    set<uint8>("health", "current target", amount);
+    tick();
+    set<uint8>("health", "current target", 100);
+}
+void EngineTestBase::tickWithTargetIsMoving()
+{
+    set<bool>("moving", "current target", true);
+    tick();
+    set<bool>("moving", "current target", false);
+}
+
+void EngineTestBase::tickInSpellRange()
+{
+    set<float>("distance", "current target", 15.0f);
+    tick();
+}
+
+void EngineTestBase::addTargetAura(string  spell)
+{
+	ai->auras[MockedTargets::GetCurrentTarget()].push_back(spell);
+}
+
+void EngineTestBase::removeTargetAura(string  spell)
+{
+    ai->auras[MockedTargets::GetCurrentTarget()].remove(spell);
+}
+
+void EngineTestBase::addPartyAura(string  spell)
+{
+    ai->auras[MockedTargets::GetPartyMember()].push_back(spell);
+}
+
+void EngineTestBase::removePartyAura(string  spell)
+{
+    ai->auras[MockedTargets::GetPartyMember()].remove(spell);
+}
+
+void EngineTestBase::tickWithLootAvailable()
+{
+    set<bool>("has available loot", true);
+	tick();
+    set<bool>("has available loot", false);
+}
+
+void EngineTestBase::tickWithNoDrink()
+{
+    list<Item*> items;
+    set<list<Item*> >("inventory items", "drink", items);
+
+	tick();
+
+	items.push_back((Item*)(void*)0x01);
+    set<list<Item*> >("inventory items", "drink", items);
+}
+
+void EngineTestBase::tickWithNoFood()
+{
+    list<Item*> items;
+    set<list<Item*> >("inventory items", "food", items);
+
+	tick();
+
+	items.push_back((Item*)(void*)0x01);
+    set<list<Item*> >("inventory items", "food", items);
+}
+
+void EngineTestBase::itemAvailable(string  item, int amount)
+{
+    set<uint8>("item count", item, 2);
+}
+
+void EngineTestBase::tickWithDeadPartyMember()
+{
+    context->GetValue<Unit*>("party member to resurrect")->Set(MockedTargets::GetPartyMember());
+	tick();
+    context->GetValue<Unit*>("party member to resurrect")->Set(NULL);
+}
+
+void EngineTestBase::tickBehindTarget()
+{
+    set<bool>("behind", "current target", true);
+    tick();
+    set<bool>("behind", "current target", false);
+}
+
+void EngineTestBase::tickWithCcTarget(string  spell)
+{
+    set<uint8>("attacker count", 3);
+    context->GetValue<Unit*>("cc target", spell)->Set(MockedTargets::GetCc());
+    tick();
+    set<uint8>("attacker count", 1);
+    context->GetValue<Unit*>("cc target", spell)->Set(NULL);
+}
+
+void EngineTestBase::tickWhileSwimming()
+{
+    set<bool>("swimming", "self target", true);
+    tick();
+    set<bool>("swimming", "self target", false);
+}
+
+void EngineTestBase::tickWithItemForSpell(string spell)
+{
+    set<Item*>("item for spell", "1", (Item*)(void*)0x01);
+    tick();
+    set<Item*>("item for spell", "1", NULL);
+}
+
+void EngineTestBase::tickWithEnemyHealerIsCastingInterruptableSpell(string interrupt)
+{
+    set<Unit*>("enemy healer target", interrupt, MockedTargets::GetEnemyHealer());
+    tick();
+    set<Unit*>("enemy healer target", interrupt, NULL);
+}
diff --git a/src/test/EngineTestBase.h b/src/test/EngineTestBase.h
new file mode 100644
index 0000000..16a086e
--- /dev/null
+++ b/src/test/EngineTestBase.h
@@ -0,0 +1,88 @@
+#pragma once
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class EngineTestBase : public CPPUNIT_NS::TestFixture
+{
+public:
+    virtual void setUp();
+    virtual void tearDown();
+
+private:
+	void va_generic(void (EngineTestBase::*callback)(const char*), va_list vl);
+
+protected:
+    template <class T>
+    void set(string  name, T value) { context->GetValue<T>(name)->Set(value); }
+    template <class T>
+    void set(string  name, string  param, T value) { context->GetValue<T>(name, param)->Set(value); }
+
+protected:
+	virtual void setupEngine(AiObjectContext* AiObjectContext, ...);
+	void setupEngineCallback(const char*  name);
+	void tick();
+	void assertActions(string  expected);
+
+	void tickWithNoTarget();
+	void spellUnavailable(string  spell);
+	void tickWithSpellUnavailable(string  spell);
+	void tickWithSpellAvailable(string  spell);
+	void spellAvailable(string  spell);
+	void addAura(string  spell);
+	void addTargetAura(string  spell);
+	void removeTargetAura(string  spell);
+	void addPartyAura(string  spell);
+	void removePartyAura(string  spell);
+	void removeAura(string  spell);
+	void tickOutOfSpellRange();
+	void tickOutOfMeleeRange();
+	void tickInMeleeRange();
+	void tickInSpellRange();
+	void tickWithNoAggro();
+	void tickWithRage(int amount);
+	void tickWithEnergy(int amount);
+	void tickWithAttackerCount(int count);
+	void tickWithMyAttackerCount(int count);
+	void tickWithLowHealth(int amount);
+	void tickWithPartyLowHealth(int amount);
+	void tickWithAuraToDispel(uint32 type);
+	void tickWithPartyAuraToDispel(uint32 type);
+	void tickWithTargetAuraToDispel(uint32 type);
+    void tickBehindTarget();
+	void lowHealth(int amount);
+	void lowMana(int amount);
+	void healthRestored();
+	void tickWithComboPoints(int amount);
+	void tickWithTargetIsCastingNonMeleeSpell();
+	void tickWithBalancePercent(int percent);
+	void tickWithNoPet();
+	void tickWithPetLowHealth(int amount);
+    void tickWithPetDead();
+	void tickWithLowMana(int amount);
+	void tickWithTargetLowHealth(int amount);
+	void tickWithTargetIsMoving();
+	void tickWithLootAvailable();
+	void tickWithNoFood();
+	void tickWithNoDrink();
+	void itemAvailable(string  item, int amount);
+	void tickWithDeadPartyMember();
+    void tickWithCcTarget(string   spell);
+    void tickWhileSwimming();
+    void setInMeleeRange();
+    void tickWithAoeHeal(string type, int amount = 2);
+    void tickWithItemForSpell(string spell);
+    void tickWithEnemyHealerIsCastingInterruptableSpell(string interrupt);
+
+protected:
+    MockPlayerbotAIBase *ai;
+    Engine *engine;
+    AiObjectContext *context;
+};
diff --git a/src/test/EngineTestCase.cpp b/src/test/EngineTestCase.cpp
new file mode 100644
index 0000000..2a5935f
--- /dev/null
+++ b/src/test/EngineTestCase.cpp
@@ -0,0 +1,321 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class PrerequisiteAction : public Action
+{
+public:
+    PrerequisiteAction(PlayerbotAI* const ai) : Action(ai) {}
+    virtual ~PrerequisiteAction() { destroyed = TRUE; }
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    virtual string getName() {return "PrerequisiteAction"; }
+
+    static int executed;
+    static int destroyed;
+};
+
+int PrerequisiteAction::executed = 0;
+int PrerequisiteAction::destroyed = 0;
+
+class AlternativeAction : public Action
+{
+public:
+    AlternativeAction(PlayerbotAI* const ai) : Action(ai) {}
+    virtual ~AlternativeAction() {destroyed = TRUE;}
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    string  getName() {return "AlternativeAction"; }
+
+    static int executed;
+    static int destroyed;
+};
+
+int AlternativeAction::executed = 0;
+int AlternativeAction::destroyed = 0;
+
+class RepeatingAction : public Action
+{
+public:
+	RepeatingAction(PlayerbotAI* const ai) : Action(ai) {}
+
+	virtual ~RepeatingAction()
+	{
+		destroyed++;
+	}
+
+    bool Execute(Event event) { executed++; return TRUE; }
+    string  getName() {return "RepeatingAction"; }
+    bool isPossible() { return available; }
+
+	static int destroyed;
+    static int executed;
+    static int available;
+};
+
+int RepeatingAction::available = TRUE;
+int RepeatingAction::destroyed = 0;
+int RepeatingAction::executed = 0;
+
+class TriggeredAction : public Action
+{
+public:
+	TriggeredAction(PlayerbotAI* const ai) : Action(ai) { fired = false; }
+	virtual ~TriggeredAction() {}
+
+    bool Execute(Event event) { param = event.getParam(); fired = TRUE; return true; }
+    string  getName() {return "TriggeredAction"; }
+
+	static int fired;
+    static string param;
+};
+
+int TriggeredAction::fired = 0;
+string TriggeredAction::param;
+
+class TestTrigger : public Trigger
+{
+public:
+	TestTrigger(PlayerbotAI* const ai) : Trigger(ai) {count = 0;}
+    virtual Event Check()
+    {
+        return IsActive() ? Event(getName(), "test") : Event();
+    }
+	virtual bool IsActive()
+	{
+		return ++count==3;
+	}
+
+private:
+	int count;
+};
+
+class TestMultiplier : public Multiplier
+{
+public:
+    TestMultiplier(PlayerbotAI* const ai) : Multiplier(ai, "test") { asked = 0; }
+    float GetValue(Action* action) { return asked = 1.0f; }
+
+    static int asked;
+};
+
+int TestMultiplier::asked;
+
+class TestStrategy : public Strategy
+{
+public:
+    TestStrategy(PlayerbotAI* const ai) : Strategy(ai) {}
+
+    virtual string  getName() { return "TestStrategy"; }
+
+    virtual NextAction** getDefaultActions() { return NextAction::array(0, new NextAction("RepeatingAction", 1.0f), NULL); }
+
+    virtual void InitMultipliers(std::list<Multiplier*> &multipliers)
+    {
+        multipliers.push_back(new TestMultiplier(ai));
+    }
+
+    virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+    {
+        triggers.push_back(new TriggerNode(
+            "TestTrigger",
+            NextAction::array(0, new NextAction("TriggeredAction", 10.0f), NULL)));
+    }
+
+    virtual ActionNode* GetAction(string  name)
+    {
+        if (name == "TriggeredAction")
+        {
+            return new ActionNode ("TriggeredAction",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else if (name == "RepeatingAction")
+        {
+            return new ActionNode ("RepeatingAction",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("AlternativeAction", 1.0f), NULL),
+                /*C*/ NextAction::array(0, new NextAction("RepeatingAction", 1.0f), NULL));
+        }
+        else if (name == "AlternativeAction")
+        {
+            return new ActionNode ("AlternativeAction",
+                /*P*/ NextAction::array(0, new NextAction("PrerequisiteAction", 1.0f), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else if (name == "PrerequisiteAction")
+        {
+            return new ActionNode ("PrerequisiteAction",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        else return NULL;
+    }
+};
+
+class AnotherTestStrategy : public Strategy
+{
+public:
+    AnotherTestStrategy(PlayerbotAI* const ai) : Strategy(ai) {}
+
+    virtual string  getName() { return "AnotherTestStrategy"; }
+};
+
+class TestStrategyContext : public NamedObjectContext<Strategy>
+{
+public:
+    TestStrategyContext() : NamedObjectContext(false, true)
+    {
+        creators["TestStrategy"] = &TestStrategyContext::Test;
+        creators["AnotherTestStrategy"] = &TestStrategyContext::AnotherTest;
+    }
+
+private:
+    static Strategy* Test(PlayerbotAI* ai) { return new TestStrategy(ai); }
+    static Strategy* AnotherTest(PlayerbotAI* ai) { return new AnotherTestStrategy(ai); }
+};
+
+class TestTriggerContext : public NamedObjectContext<Trigger>
+{
+public:
+    TestTriggerContext()
+    {
+        creators["TestTrigger"] = &TestTriggerContext::Test;
+    }
+
+private:
+    static Trigger* Test(PlayerbotAI* ai) { return new TestTrigger(ai); }
+};
+
+
+class TestActionContext : public NamedObjectContext<Action>
+{
+public:
+    TestActionContext()
+    {
+        creators["TriggeredAction"] = &TestActionContext::Triggered;
+        creators["RepeatingAction"] = &TestActionContext::Repeating;
+        creators["AlternativeAction"] = &TestActionContext::Alternative;
+        creators["PrerequisiteAction"] = &TestActionContext::Prerequisite;
+    }
+
+private:
+    static Action* Triggered(PlayerbotAI* ai) { return new TriggeredAction(ai); }
+    static Action* Repeating(PlayerbotAI* ai) { return new RepeatingAction(ai); }
+    static Action* Alternative(PlayerbotAI* ai) { return new AlternativeAction(ai); }
+    static Action* Prerequisite(PlayerbotAI* ai) { return new PrerequisiteAction(ai); }
+};
+
+class TestAiObjectContext : public AiObjectContext
+{
+public:
+    TestAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        strategyContexts.Add(new TestStrategyContext());
+        triggerContexts.Add(new TestTriggerContext());
+        actionContexts.Add(new TestActionContext());
+    }
+};
+
+class EngineTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( EngineTestCase );
+      CPPUNIT_TEST( engineMustRepeatActions );
+      CPPUNIT_TEST( addRemoveStrategies );
+      CPPUNIT_TEST( listStrategies );
+      CPPUNIT_TEST( eventMustPassToAction );
+      CPPUNIT_TEST( siblings );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void engineMustRepeatActions()
+	{
+		MockPlayerbotAIBase mock;
+		Engine engine(&mock, new TestAiObjectContext(&mock));
+		engine.testMode = true;
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+		for (int i=0; i<6; i++)
+			engine.DoNextAction(NULL);
+
+		CPPUNIT_ASSERT(TriggeredAction::fired);
+        CPPUNIT_ASSERT(TestMultiplier::asked);
+        CPPUNIT_ASSERT_EQUAL(5, RepeatingAction::executed);
+
+        RepeatingAction::available = FALSE;
+        engine.DoNextAction(NULL);
+        engine.DoNextAction(NULL);
+        CPPUNIT_ASSERT(AlternativeAction::executed);
+        CPPUNIT_ASSERT(PrerequisiteAction::executed);
+	}
+
+    void addRemoveStrategies()
+    {
+		MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("AnotherTestStrategy");
+        engine.removeStrategy("AnotherTestStrategy");
+        engine.Init();
+
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        engine.DoNextAction(NULL);
+        CPPUNIT_ASSERT(TriggeredAction::fired);
+    }
+
+    void listStrategies()
+    {
+		MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("AnotherTestStrategy");
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        std::string s = engine.ListStrategies();
+        CPPUNIT_ASSERT(s == "Strategies: TestStrategy");
+    }
+
+    void eventMustPassToAction()
+    {
+        MockPlayerbotAIBase mock;
+        Engine engine(&mock, new TestAiObjectContext(&mock));
+        engine.testMode = true;
+        engine.addStrategy("TestStrategy");
+        engine.Init();
+
+        for (int i=0; i<6; i++)
+            engine.DoNextAction(NULL);
+
+        CPPUNIT_ASSERT(TriggeredAction::param == "test");
+    }
+
+    void siblings()
+    {
+        MockPlayerbotAIBase mock;
+        TestAiObjectContext * context = new TestAiObjectContext(&mock);
+
+        set<string> siblings = context->GetSiblingStrategy("TestStrategy");
+
+        CPPUNIT_ASSERT(siblings.size() == 1);
+        CPPUNIT_ASSERT(*siblings.begin() == "AnotherTestStrategy");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( EngineTestCase );
diff --git a/src/test/EventTestCase.cpp b/src/test/EventTestCase.cpp
new file mode 100644
index 0000000..a293b90
--- /dev/null
+++ b/src/test/EventTestCase.cpp
@@ -0,0 +1,59 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+char *strstri(const char *haystack, const char *needle);
+
+class EventTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( EventTestCase );
+      CPPUNIT_TEST( emptyEvent );
+      CPPUNIT_TEST( eventHandling );
+      CPPUNIT_TEST( strstriTest1 );
+      CPPUNIT_TEST( strstriTest2 );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void emptyEvent()
+	{
+        Event event;
+        CPPUNIT_ASSERT(!event);
+	}
+
+    void eventHandling()
+    {
+        Event event("source", "param");
+
+        Event event2 = event;
+
+        CPPUNIT_ASSERT(!!event2);
+        CPPUNIT_ASSERT(event2.getParam() == "param");
+        CPPUNIT_ASSERT(event2.getSource() == "source");
+    }
+
+    void strstriTest1()
+    {
+        string a = "Mana Spring Totem V";
+        string b = "strength of earth totem";
+        CPPUNIT_ASSERT(!strstri(a.c_str(), b.c_str()));
+    }
+
+    void strstriTest2()
+    {
+        string a = "mana spring Totem V";
+        string b = "mana Spring totem";
+        CPPUNIT_ASSERT(strstri(a.c_str(), b.c_str()));
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( EventTestCase );
diff --git a/src/test/EverythingUnavailableAiManagerRegistry.h b/src/test/EverythingUnavailableAiManagerRegistry.h
new file mode 100644
index 0000000..7bc4f90
--- /dev/null
+++ b/src/test/EverythingUnavailableAiManagerRegistry.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class EverythingUnavailablePlayerbotAI : public MockPlayerbotAIBase
+    {
+    public:
+        EverythingUnavailablePlayerbotAI() : MockPlayerbotAIBase()
+		{
+			managers[AiSpellManagerType] = new EverythingUnavailableAiSpellManager(ai, this, &buffer);
+		}
+        virtual bool CanCastSpell(string  name, Unit* target) { return false; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/test/ExternalEventHelperTestCase.cpp b/src/test/ExternalEventHelperTestCase.cpp
new file mode 100644
index 0000000..5108eda
--- /dev/null
+++ b/src/test/ExternalEventHelperTestCase.cpp
@@ -0,0 +1,81 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "../../plugins/playerbot/strategy/triggers/ChatCommandTrigger.h"
+#include "../../plugins/playerbot/strategy/ExternalEventHelper.h"
+
+using namespace ai;
+
+class ExternalEventTestTriggerContext : public NamedObjectContext<Trigger>
+{
+public:
+    ExternalEventTestTriggerContext()
+    {
+        creators["message"] = &ExternalEventTestTriggerContext::message;
+        creators["message from"] = &ExternalEventTestTriggerContext::message_from;
+    }
+
+private:
+    static Trigger* message(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "message"); }
+    static Trigger* message_from(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "message from"); }
+};
+
+
+
+class ExternalEventTestAiObjectContext : public AiObjectContext
+{
+public:
+    ExternalEventTestAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        triggerContexts.Add(new ExternalEventTestTriggerContext());
+    }
+};
+
+
+class ExternalEventHelperTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( ExternalEventHelperTestCase );
+      CPPUNIT_TEST( externalEvent );
+      CPPUNIT_TEST( emptyExternalEvent );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void externalEvent()
+	{
+        MockPlayerbotAIBase ai;
+        ExternalEventTestAiObjectContext aiObjectContext(&ai);
+        ExternalEventHelper helper(&aiObjectContext);
+
+        helper.ParseChatCommand("message from chat");
+
+        Event event = aiObjectContext.GetTrigger("message from")->Check();
+        CPPUNIT_ASSERT(event);
+        CPPUNIT_ASSERT(event.getParam() == "chat");
+
+        event = aiObjectContext.GetTrigger("message")->Check();
+        CPPUNIT_ASSERT(!event);
+    }
+
+    void emptyExternalEvent()
+    {
+        MockPlayerbotAIBase ai;
+        ExternalEventTestAiObjectContext aiObjectContext(&ai);
+        ExternalEventHelper helper(&aiObjectContext);
+
+        helper.ParseChatCommand("message from");
+
+        Event event = aiObjectContext.GetTrigger("message from")->Check();
+        CPPUNIT_ASSERT(event);
+        CPPUNIT_ASSERT(event.getParam() == "");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ExternalEventHelperTestCase );
diff --git a/src/test/FireMageTestCase.cpp b/src/test/FireMageTestCase.cpp
new file mode 100644
index 0000000..c098bbb
--- /dev/null
+++ b/src/test/FireMageTestCase.cpp
@@ -0,0 +1,103 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class FireMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( FireMageTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( avoid_melee );
+  CPPUNIT_TEST( avoid_melee_low_level );
+  CPPUNIT_TEST( panic );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( invisibility );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "fire", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+		addTargetAura("pyroblast");
+
+        tick();
+		tick();
+		tick();
+
+        addAura("hot streak");
+        spellAvailable("pyroblast");
+        tick();
+        tick();
+
+        assertActions(">T:pyroblast>T:scorch>T:fireball>T:fire blast>T:pyroblast>T:shoot");
+	}
+
+ 	void avoid_melee()
+ 	{
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("flamestrike");
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:dragon's breath>T:flamestrike>T:blast wave>T:flamestrike>T:frost nova>S:flee");
+	}
+
+ 	void avoid_melee_low_level()
+ 	{
+ 	    spellUnavailable("dragon's breath");
+ 	    spellUnavailable("blast wave");
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		assertActions(">T:frost nova>S:flee");
+	}
+
+ 	void panic()
+ 	{
+        tickWithLowHealth(19);
+
+        assertActions(">S:ice block");
+ 	}
+
+    void boost()
+    {
+		tickWithBalancePercent(1);
+
+		assertActions(">S:combustion");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("fire aoe");
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		assertActions(">T:living bomb>T:flamestrike");
+    }
+
+    void invisibility()
+    {
+		tickWithMyAttackerCount(3);
+
+		assertActions(">S:invisibility");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( FireMageTestCase );
diff --git a/src/test/FrostMageTestCase.cpp b/src/test/FrostMageTestCase.cpp
new file mode 100644
index 0000000..73e6001
--- /dev/null
+++ b/src/test/FrostMageTestCase.cpp
@@ -0,0 +1,138 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class FrostMageTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( FrostMageTestCase );
+  CPPUNIT_TEST( combatVsMelee );
+  CPPUNIT_TEST( dispel );
+  CPPUNIT_TEST( boost );
+  CPPUNIT_TEST( interruptSpells );
+  CPPUNIT_TEST( cc );
+  CPPUNIT_TEST( aoe );
+  CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST( low_mana );
+  CPPUNIT_TEST( interrupt_enemy_healer );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+    }
+
+protected:
+ 	void combatVsMelee()
+	{
+        tick();
+        spellAvailable("frostbolt");
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("frostbolt");
+		tickInSpellRange();
+        tick();
+
+		tickWithLowHealth(19);
+
+		assertActions(">T:frostbolt>T:frost nova>S:flee>T:frostbolt>T:shoot>S:ice block");
+	}
+
+    void dispel()
+    {
+        tick();
+
+		tickWithAuraToDispel(DISPEL_CURSE);
+
+		spellAvailable("remove curse");
+		tickWithPartyAuraToDispel(DISPEL_CURSE);
+
+        tick();
+
+		tickWithTargetAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">T:frostbolt>S:remove curse>P:remove curse on party>T:shoot>T:spellsteal");
+    }
+
+    void boost()
+    {
+        tick(); // frostbolt
+
+		tickWithBalancePercent(1);
+
+        spellAvailable("frostbolt");
+        tick(); // frostbolt
+
+        tick(); // shoot
+
+		assertActions(">T:frostbolt>S:icy veins>T:frostbolt>T:shoot");
+    }
+
+    void interruptSpells()
+    {
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        tick(); // frostbolt
+
+        assertActions(">T:counterspell>T:frostbolt");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("polymorph");
+
+        assertActions(">Cc:polymorph");
+    }
+
+   	void aoe()
+	{
+        engine->addStrategy("frost aoe");
+
+		tick();
+		tickWithAttackerCount(4);
+		tick();
+
+		assertActions(">T:frostbolt>T:blizzard>T:shoot");
+	}
+
+   	void incompatibles()
+   	{
+        engine->addStrategies("frost", "fire", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: fire");
+   	}
+
+    void low_mana()
+    {
+        engine->addStrategy("flee");
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+        addAura("mage armor");
+
+        tickWithLowMana(5);
+
+        set<uint8>("item count", "drink", 0);
+        set<float>("distance", "current target", 5);
+        tickWithLowMana(5);
+        tickWithLowMana(5);
+
+        assertActions(">S:evocation>T:frost nova>S:flee");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("counterspell");
+
+        assertActions(">H:counterspell on enemy healer");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( FrostMageTestCase );
diff --git a/src/test/GenericTestCase.cpp b/src/test/GenericTestCase.cpp
new file mode 100644
index 0000000..fc65367
--- /dev/null
+++ b/src/test/GenericTestCase.cpp
@@ -0,0 +1,139 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( GenericTestCase );
+	CPPUNIT_TEST( flee );
+	CPPUNIT_TEST( adds );
+	CPPUNIT_TEST( potions );
+	CPPUNIT_TEST( guard );
+	CPPUNIT_TEST( threat );
+	CPPUNIT_TEST( facing );
+	CPPUNIT_TEST( drop_target );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "bear", "flee", NULL);
+    }
+
+protected:
+	void flee()
+	{
+	    list<Item*> items;
+        set<list<Item*> >("inventory items", "drink", items);
+	    set<list<Item*> >("inventory items", "food", items);
+
+        set<float>("distance", "current target", 5);
+		lowHealth(1);
+		lowMana(1);
+		tick();
+
+		assertActions(">S:flee");
+	}
+
+	void adds()
+	{
+	    engine->addStrategy("flee from adds");
+
+	    list<ObjectGuid> adds;
+	    adds.push_front(ObjectGuid(uint64(1)));
+	    set<list<ObjectGuid> >("nearest adds", adds);
+
+	    tick();
+
+		assertActions(">S:runaway");
+	}
+
+	void potions()
+	{
+        engine->addStrategy("flee");
+	    engine->addStrategy("potions");
+
+        set<uint8>("item count", "mana potion", 1);
+        set<uint8>("item count", "drink", 1);
+        set<uint8>("item count", "healing potion", 1);
+        set<uint8>("item count", "food", 1);
+
+        spellUnavailable("innervate");
+        spellUnavailable("barskin");
+        spellUnavailable("survival instincts");
+
+        spellUnavailable("regrowth");
+        spellUnavailable("healing touch");
+        spellUnavailable("rejuvenation");
+
+	    tickWithLowMana(1);
+
+	    set<bool>("combat", "self target", true);
+	    tickWithLowMana(1);
+        set<uint8>("item count", "mana potion", 0);
+	    tickWithLowMana(1);
+        set<uint8>("item count", "drink", 0);
+        set<float>("distance", "current target", 5);
+	    tickWithLowMana(1);
+
+	    tickWithLowHealth(1);
+        set<uint8>("item count", "healing potion", 0);
+	    tickWithLowHealth(1);
+        set<uint8>("item count", "food", 0);
+        set<float>("distance", "current target", 5);
+	    tickWithLowHealth(1);
+
+		assertActions(">S:flee>S:mana potion>S:drink>S:flee>S:healing potion>S:food>S:flee");
+	}
+
+	void guard()
+	{
+	    engine->removeStrategy("bear");
+	    engine->addStrategy("guard");
+
+	    tick();
+
+		assertActions(">S:move to position");
+	}
+
+	void threat()
+	{
+	    engine->addStrategy("threat");
+
+        set<uint8>("threat", "current target", 100);
+	    tick();
+
+		assertActions(">T:reach melee");
+	}
+
+	void facing()
+	{
+        addAura("dire bear form");
+        addAura("thorns");
+        addTargetAura("faerie fire (feral)");
+
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+        set<bool>("facing", "current target", false);
+	    tick();
+        set<bool>("facing", "current target", true);
+
+		assertActions(">S:set facing");
+	}
+
+    void drop_target()
+    {
+        set<bool>("invalid target", "current target", true);
+        tick();
+        set<bool>("invalid target", "current target", false);
+
+        assertActions(">S:drop target");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( GenericTestCase );
diff --git a/src/test/HealDruidTestCase.cpp b/src/test/HealDruidTestCase.cpp
new file mode 100644
index 0000000..d58d290
--- /dev/null
+++ b/src/test/HealDruidTestCase.cpp
@@ -0,0 +1,91 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealDruidTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealDruidTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+	CPPUNIT_TEST( aoe );
+	CPPUNIT_TEST( range );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new DruidAiObjectContext(ai), "heal", NULL);
+
+		addAura("moonkin form");
+    }
+
+protected:
+
+	void healHimself()
+    {
+	    tick();
+        addAura("tree of life");
+
+		tickWithLowHealth(79);
+        spellAvailable("rejuvenation");
+
+		tickWithLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+		tickWithLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithLowHealth(1);
+        tickWithLowHealth(1);
+
+        assertActions(">S:tree of life>S:rejuvenation>S:regrowth>S:regrowth>S:regrowth>S:healing touch");
+    }
+
+	void healOthers()
+    {
+        addAura("tree of life");
+
+        tickWithPartyLowHealth(79);
+        spellAvailable("rejuvenation");
+
+        tickWithPartyLowHealth(59);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithPartyLowHealth(39);
+
+        spellAvailable("healing touch");
+        spellAvailable("regrowth");
+        spellAvailable("rejuvenation");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+        assertActions(">P:rejuvenation on party>P:regrowth on party>P:regrowth on party>P:regrowth on party>P:healing touch on party");
+    }
+
+    void aoe()
+    {
+        tickWithAoeHeal("medium");
+
+		assertActions(">P:tranquility");
+    }
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealDruidTestCase );
diff --git a/src/test/HealPriestTestCase.cpp b/src/test/HealPriestTestCase.cpp
new file mode 100644
index 0000000..d86532e
--- /dev/null
+++ b/src/test/HealPriestTestCase.cpp
@@ -0,0 +1,195 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealPriestTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST( flee );
+    CPPUNIT_TEST( cc );
+    CPPUNIT_TEST( enemyTooClose );
+	CPPUNIT_TEST( racials );
+	CPPUNIT_TEST( incompatibles );
+	CPPUNIT_TEST( range );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "heal", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void healHimself()
+    {
+        addPartyAura("power word: fortitude");
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+		tick();
+
+		tickWithLowHealth(59);
+
+        spellAvailable("renew");
+        tickWithLowHealth(79);
+
+		tickWithSpellAvailable("shoot");
+
+		assertActions(">S:power word: shield>S:greater heal>S:renew>S:heal>S:lesser heal>T:shoot>S:flash heal>S:renew>T:shoot");
+    }
+
+	void racials()
+	{
+		engine->addStrategy("racials");
+		addPartyAura("power word: fortitude");
+
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+		tick();
+
+		tickWithLowHealth(59);
+
+		tickWithSpellAvailable("shoot");
+
+		assertActions(">S:lifeblood>S:gift of the naaru>S:power word: shield>S:greater heal>S:renew>S:heal>S:lesser heal>T:shoot>S:flash heal>T:shoot");
+	}
+
+    void healOthers()
+    {
+        tick(); // shoot
+
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+		tickWithPartyLowHealth(39);
+
+        spellAvailable("greater heal");
+        spellAvailable("renew");
+        spellAvailable("flash heal");
+        spellAvailable("lesser heal");
+        spellAvailable("power word: shield");
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+        tickWithPartyLowHealth(1);
+
+		tickWithSpellAvailable("shoot");
+
+        spellAvailable("flash heal");
+		tickWithPartyLowHealth(59);
+
+        spellAvailable("renew");
+        tickWithPartyLowHealth(79);
+
+        tickWithSpellAvailable("shoot"); // shoot
+
+
+		assertActions(">T:shoot>P:power word: shield on party>P:greater heal on party>P:renew on party>P:heal on party>P:lesser heal on party>P:power word: shield on party>P:flash heal on party>P:renew on party>P:greater heal on party>T:shoot>P:flash heal on party>P:renew on party>T:shoot");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+        tickWithAoeHeal("medium");
+
+        assertActions(">P:circle of healing>P:flash heal on party");
+    }
+
+    void flee()
+    {
+        tickInMeleeRange();
+        tickInMeleeRange();
+
+		assertActions(">S:fade>S:flee");
+    }
+
+    void cc()
+    {
+		tickWithMyAttackerCount(3);
+		tickWithMyAttackerCount(3);
+        set<float>("distance", "current target", 5);
+		tickWithMyAttackerCount(3);
+
+		assertActions(">T:psychic scream>S:fade>S:flee");
+    }
+
+    void enemyTooClose()
+    {
+        tick();
+
+		tickInMeleeRange();
+		tickInMeleeRange();
+
+		spellAvailable("shoot");
+		tickInSpellRange();
+
+		assertActions(">T:shoot>S:fade>S:flee>T:shoot");
+    }
+
+    void dispel()
+    {
+        tick(); // shoot
+
+		tickWithAuraToDispel(DISPEL_MAGIC);
+
+		spellAvailable("dispel magic");
+		tickWithPartyAuraToDispel(DISPEL_MAGIC);
+
+		tickWithAuraToDispel(DISPEL_DISEASE);
+
+		spellAvailable("abolish disease");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+		tickWithAuraToDispel(DISPEL_DISEASE);
+
+		spellAvailable("cure disease");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+        tickWithSpellAvailable("shoot");
+
+		assertActions(">T:shoot>S:dispel magic>P:dispel magic on party>S:abolish disease>P:abolish disease on party>S:cure disease>P:cure disease on party>T:shoot");
+    }
+
+
+    void incompatibles()
+    {
+        engine->addStrategies("heal", "shadow", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: shadow");
+    }
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealPriestTestCase );
diff --git a/src/test/HealShamanTestCase.cpp b/src/test/HealShamanTestCase.cpp
new file mode 100644
index 0000000..1783ca6
--- /dev/null
+++ b/src/test/HealShamanTestCase.cpp
@@ -0,0 +1,136 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class HealShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HealShamanTestCase );
+    CPPUNIT_TEST( healHimself );
+    CPPUNIT_TEST( healOthers );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( interruptSpell );
+	CPPUNIT_TEST( dispel );
+	CPPUNIT_TEST( cure );
+	CPPUNIT_TEST( lowMana );
+	CPPUNIT_TEST( range );
+	CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "heal", NULL);
+
+        addAura("water shield");
+    }
+
+protected:
+    void healHimself()
+    {
+        tickWithLowHealth(45);
+		tickWithLowHealth(35);
+        tickWithLowHealth(35);
+
+        assertActions(">S:lesser healing wave>S:riptide>S:healing wave");
+    }
+
+    void healOthers()
+    {
+        tickWithPartyLowHealth(45);
+        tickWithPartyLowHealth(35);
+		tickWithPartyLowHealth(35);
+
+        assertActions(">P:lesser healing wave on party>P:riptide on party>P:healing wave on party");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+        tickWithAoeHeal("medium");
+
+        assertActions(">P:chain heal>P:lesser healing wave on party");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bmana");
+        removeAura("water shield");
+
+        tick();
+        addAura("water shield");
+
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+        tickWithItemForSpell("earthliving weapon");
+
+        engine->addStrategy("totems");
+        tick();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:water shield>S:earthliving weapon>S:flametongue weapon>S:frostbrand weapon>S:rockbiter weapon>S:mana spring totem>S:strength of earth totem>S:flametongue totem>S:windfury totem");
+    }
+
+    void interruptSpell()
+    {
+        tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:wind shear");
+    }
+
+	void dispel()
+	{
+		tickWithTargetAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">T:purge");
+	}
+
+	void cure()
+	{
+		tickWithAuraToDispel(DISPEL_CURSE);
+		spellAvailable("cleanse spirit");
+		tickWithAuraToDispel(DISPEL_DISEASE);
+        spellAvailable("cleanse spirit");
+		tickWithAuraToDispel(DISPEL_POISON);
+        spellAvailable("cleanse spirit");
+
+        tickWithPartyAuraToDispel(DISPEL_CURSE);
+		spellAvailable("cleanse spirit");
+		tickWithPartyAuraToDispel(DISPEL_DISEASE);
+        spellAvailable("cleanse spirit");
+		tickWithPartyAuraToDispel(DISPEL_POISON);
+        spellAvailable("cleanse spirit");
+
+		assertActions(">S:cleanse spirit>S:cleanse spirit>S:cleanse spirit>P:cleanse spirit curse on party>P:cleanse spirit disease on party>P:cleanse spirit poison on party");
+	}
+
+	void lowMana()
+	{
+	    tickWithLowMana(1);
+		assertActions(">S:mana tide totem");
+	}
+
+    void range()
+    {
+        tickOutOfSpellRange();
+
+        assertActions(">T:reach spell");
+    }
+
+    void aoe()
+    {
+        tickWithAttackerCount(3);
+
+        assertActions(">S:healing stream totem");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HealShamanTestCase );
diff --git a/src/test/HolyPriestTestCase.cpp b/src/test/HolyPriestTestCase.cpp
new file mode 100644
index 0000000..49993ac
--- /dev/null
+++ b/src/test/HolyPriestTestCase.cpp
@@ -0,0 +1,56 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class HolyPriestTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HolyPriestTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( incompatibles );
+	CPPUNIT_TEST( flee );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "holy", NULL);
+
+        addAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void combat()
+    {
+		tick();
+		tick();
+		tick();
+
+		assertActions(">T:holy fire>T:smite>T:shoot");
+    }
+
+    void flee()
+    {
+        tickInMeleeRange();
+        tickInMeleeRange();
+
+        assertActions(">S:fade>S:flee");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("shadow", "holy", NULL);
+
+        CPPUNIT_ASSERT_EQUAL(engine->ListStrategies(), string("Strategies: holy"));
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HolyPriestTestCase );
diff --git a/src/test/HunterNonCombatTestCase.cpp b/src/test/HunterNonCombatTestCase.cpp
new file mode 100644
index 0000000..bea7f5b
--- /dev/null
+++ b/src/test/HunterNonCombatTestCase.cpp
@@ -0,0 +1,75 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+
+using namespace ai;
+
+
+class HunterNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( HunterNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( lowMana );
+    CPPUNIT_TEST( summonPet );
+	CPPUNIT_TEST( buffIfPackUnavailable );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new HunterAiObjectContext(ai), "nc", NULL);
+
+        set<uint8>("attacker count", 0);
+    }
+
+protected:
+    void buff()
+    {
+		engine->addStrategy("bspeed");
+
+		tick();
+        addAura("aspect of the pack");
+        tick();
+
+        engine->addStrategy("bdps");
+		tickWithAttackerCount(1);
+
+        assertActions(">S:aspect of the pack>S:trueshot aura>S:aspect of the hawk");
+    }
+
+    void lowMana()
+    {
+        addAura("trueshot aura");
+
+        engine->addStrategy("bmana");
+
+		tick();
+        addAura("aspect of the viper");
+
+        assertActions(">S:aspect of the viper");
+    }
+
+    void summonPet()
+    {
+        tickWithNoPet();
+
+		tickWithPetDead();
+		tickWithPetLowHealth(30);
+
+		assertActions(">S:call pet>S:revive pet>Pet:mend pet");
+	}
+
+    void buffIfPackUnavailable()
+    {
+		engine->addStrategy("bspeed");
+
+        tickWithSpellUnavailable("aspect of the pack");
+
+		assertActions(">S:aspect of the cheetah");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( HunterNonCombatTestCase );
diff --git a/src/test/KiteTestCase.cpp b/src/test/KiteTestCase.cpp
new file mode 100644
index 0000000..2425ed1
--- /dev/null
+++ b/src/test/KiteTestCase.cpp
@@ -0,0 +1,39 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class KiteTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( KiteTestCase );
+    CPPUNIT_TEST( kite );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+		engine->addStrategy("kite");
+        set<float>("distance", "current target", 0.0f);
+
+		addAura("battle shout");
+		addAura("defensive stance");
+    }
+
+protected:
+    void kite()
+    {
+        set<bool>("has aggro", "current target", true);
+		tick();
+
+        assertActions(">S:runaway");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( KiteTestCase );
diff --git a/src/test/LootObjectStackTestCase.cpp b/src/test/LootObjectStackTestCase.cpp
new file mode 100644
index 0000000..1cf2426
--- /dev/null
+++ b/src/test/LootObjectStackTestCase.cpp
@@ -0,0 +1,52 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "../../plugins/playerbot/LootObjectStack.h"
+
+using namespace ai;
+using namespace std;
+
+class LootObjectStackTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( LootObjectStackTestCase );
+      CPPUNIT_TEST( duplicates );
+      CPPUNIT_TEST( shrink );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void duplicates()
+	{
+	    LootTargetList data;
+	    data.insert(LootTarget(ObjectGuid(uint64(2))));
+	    data.insert(LootTarget(ObjectGuid(uint64(2))));
+
+	    CPPUNIT_ASSERT(data.size() == 1);
+	}
+
+	void shrink()
+	{
+	    LootTargetList data;
+	    LootTarget t1 = LootTarget(ObjectGuid(uint64(2)));
+	    t1.asOfTime = 10;
+	    LootTarget t2 = LootTarget(ObjectGuid(uint64(3)));
+	    t2.asOfTime = 5;
+
+	    data.insert(t1);
+	    data.insert(t2);
+	    CPPUNIT_ASSERT(data.size() == 2);
+
+	    data.shrink(7);
+        CPPUNIT_ASSERT(data.size() == 1);
+	    CPPUNIT_ASSERT(data.begin()->asOfTime == 10);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( LootObjectStackTestCase );
diff --git a/src/test/MageNonCombatTestCase.cpp b/src/test/MageNonCombatTestCase.cpp
new file mode 100644
index 0000000..14d0dea
--- /dev/null
+++ b/src/test/MageNonCombatTestCase.cpp
@@ -0,0 +1,87 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+
+using namespace ai;
+
+
+class MageNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( MageNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( bdps );
+    CPPUNIT_TEST( bmana );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new MageAiObjectContext(ai), "nc", NULL);
+		set<uint8>("item count", "food", 1);
+		set<uint8>("item count", "drink", 1);
+    }
+
+protected:
+    void buff()
+    {
+		tick();
+        addAura("arcane intellect");
+
+		tickWithSpellAvailable("arcane intellect");
+        addPartyAura("arcane intellect");
+
+		tickWithNoDrink();
+		tickWithNoFood();
+
+        assertActions(">S:arcane intellect>P:arcane intellect on party>S:conjure water>S:conjure food");
+    }
+
+    void bmana()
+    {
+        engine->addStrategy("bmana");
+
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:mage armor>S:ice armor>S:frost armor");
+    }
+
+    void bdps()
+    {
+        engine->addStrategy("bdps");
+
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+
+        tick();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">S:molten armor>S:mage armor>S:ice armor>S:frost armor");
+    }
+
+    void dispel()
+    {
+        addAura("arcane intellect");
+        addPartyAura("arcane intellect");
+        addAura("mage armor");
+
+        tickWithAuraToDispel(DISPEL_CURSE);
+
+        spellAvailable("remove curse");
+        tickWithPartyAuraToDispel(DISPEL_CURSE);
+
+        assertActions(">S:remove curse>P:remove curse on party");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MageNonCombatTestCase );
diff --git a/src/test/MeleeShamanTestCase.cpp b/src/test/MeleeShamanTestCase.cpp
new file mode 100644
index 0000000..391ae70
--- /dev/null
+++ b/src/test/MeleeShamanTestCase.cpp
@@ -0,0 +1,103 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class MeleeShamanTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( MeleeShamanTestCase );
+    CPPUNIT_TEST( combat );
+	CPPUNIT_TEST( buff );
+	CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( boost );
+    CPPUNIT_TEST( interruptSpell );
+    CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "melee", NULL);
+
+        addAura("lightning shield");
+    }
+
+protected:
+    void combat()
+    {
+		tickInMeleeRange();
+
+        tick();
+        tick();
+        addTargetAura("earth shock");
+
+        tick();
+		tick();
+		tick();
+
+        assertActions(">S:searing totem>T:earth shock>T:flame shock>T:stormstrike>T:lava lash>T:melee");
+    }
+
+    void buff()
+    {
+        engine->addStrategy("bdps");
+        removeAura("lightning shield");
+        tickInMeleeRange();
+
+        tick();
+        addAura("lightning shield");
+
+        tickWithItemForSpell("windfury weapon");
+        tickWithItemForSpell("windfury weapon");
+
+        assertActions(">S:lightning shield>S:searing totem>S:windfury weapon>S:rockbiter weapon");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("melee", "dps", "heal", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: heal");
+    }
+
+    void aoe()
+    {
+        engine->addStrategy("melee aoe");
+
+        tickInMeleeRange();
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+        tickWithAttackerCount(3);
+
+        assertActions(">S:searing totem>S:strength of earth totem>S:magma totem>T:fire nova");
+    }
+
+    void boost()
+    {
+        tickWithBalancePercent(1);
+        tickWithBalancePercent(1);
+
+        assertActions(">S:heroism>S:bloodlust");
+    }
+
+    void interruptSpell()
+    {
+        tickWithTargetIsCastingNonMeleeSpell();
+
+        assertActions(">T:wind shear");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("wind shear");
+
+        assertActions(">H:wind shear on enemy healer");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MeleeShamanTestCase );
diff --git a/src/test/MockAiObjectContext.cpp b/src/test/MockAiObjectContext.cpp
new file mode 100644
index 0000000..10918ee
--- /dev/null
+++ b/src/test/MockAiObjectContext.cpp
@@ -0,0 +1,114 @@
+#include "pch.h"
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+
+using namespace std;
+using namespace ai;
+
+class MockTrigger : public Trigger
+{
+public:
+    MockTrigger(PlayerbotAI* const ai) : Trigger(ai)
+    {
+    }
+
+public:
+    virtual Event Check()
+    {
+        Event copy = event;
+        event = Event();
+        return copy;
+    }
+
+    virtual void ExternalEvent(string param, Player* owner = NULL)
+    {
+        this->event = Event("mock", param);
+    }
+
+private:
+    Event event;
+};
+
+class MockAction : public Action
+{
+public:
+    MockAction(PlayerbotAI* const ai, string* buffer, string  name) : Action(ai, name), buffer(buffer)
+    {
+
+    }
+
+    virtual bool Execute(Event event)
+    {
+        buffer->append(">");
+        buffer->append(getName());
+        if (event.getParam().empty())
+            return true;
+
+        buffer->append("(");
+        buffer->append(event.getParam());
+        buffer->append(")");
+        return true;
+    }
+
+    virtual bool ExecuteResult()
+    {
+        buffer->append(getName());
+        return true;
+    }
+
+private:
+    string* buffer;
+};
+
+MockAiObjectContext::MockAiObjectContext(PlayerbotAI* const ai, AiObjectContext *realContext, string* buffer) :
+    AiObjectContext(ai), buffer(buffer), realContext(realContext)
+{
+}
+
+void MockAiObjectContext::reportNotFound(string  what, string  name)
+{
+    std::cout << "\n===\n";
+    cout << what << " " << name << " not found in context";
+    std::cout << "\n===\n";
+}
+
+Strategy* MockAiObjectContext::GetStrategy(string  name)
+{
+    if (!realContext->GetStrategy(name))
+    {
+        reportNotFound("Strategy", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    return realContext->GetStrategy(name);
+}
+
+Trigger* MockAiObjectContext::GetTrigger(string  name)
+{
+    if (!realContext->GetTrigger(name))
+    {
+        reportNotFound("Trigger", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    Trigger* trigger = triggers[name];
+    if (trigger)
+        return trigger;
+
+    return triggers[name] = new MockTrigger(ai);
+}
+
+Action* MockAiObjectContext::GetAction(string  name)
+{
+    if (!realContext->GetAction(name))
+    {
+        reportNotFound("Action", name);
+        CPPUNIT_ASSERT(false);
+    }
+
+    Action* action = actions[name];
+    if (action)
+        return action;
+
+    return actions[name] = new MockAction(ai, buffer, name);
+}
diff --git a/src/test/MockAiObjectContext.h b/src/test/MockAiObjectContext.h
new file mode 100644
index 0000000..0e1cdf4
--- /dev/null
+++ b/src/test/MockAiObjectContext.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "string "
+
+using namespace std;
+
+#include "MockedTargets.h"
+
+namespace ai
+{
+    class MockAiObjectContext : public AiObjectContext
+    {
+    public:
+        MockAiObjectContext(PlayerbotAI* const ai, AiObjectContext *realContext, string* buffer);
+
+    public:
+        virtual Strategy* GetStrategy(string  name);
+        virtual Trigger* GetTrigger(string  name);
+        virtual Action* GetAction(string  name);
+
+    private:
+        void reportNotFound(string  what, string  name);
+
+	private:
+		string* buffer;
+        AiObjectContext *realContext;
+        map<string , Trigger*> triggers;
+        map<string , Action*> actions;
+    };
+
+}
\ No newline at end of file
diff --git a/src/test/MockPlayerbotAIBase.cpp b/src/test/MockPlayerbotAIBase.cpp
new file mode 100644
index 0000000..faaae89
--- /dev/null
+++ b/src/test/MockPlayerbotAIBase.cpp
@@ -0,0 +1,79 @@
+#include "pch.h"
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+#include "MockedTargets.h"
+
+using namespace std;
+using namespace ai;
+
+void MockPlayerbotAIBase::InterruptSpell()
+{
+}
+
+void MockPlayerbotAIBase::RemoveAura(string name)
+{
+    Unit* target = MockedTargets::GetSelf();
+    if (HasAura(name, target)) {
+        auras[target].remove(name);
+        buffer.append(">-");
+        buffer.append(name);
+    }
+}
+
+bool MockPlayerbotAIBase::CanCastSpell(string name, Unit* target)
+{
+    for (list<string >::iterator i = spellCooldowns.begin(); i != spellCooldowns.end(); i++)
+    {
+        string s = *i;
+        if (s == name)
+            return false;
+    }
+    return true;
+}
+
+bool MockPlayerbotAIBase::IsSpellCastUseful(string name, Unit* target)
+{
+    return true;
+}
+
+bool MockPlayerbotAIBase::CastSpell(string name, Unit* target)
+{
+    buffer.append(">");
+    if (target == MockedTargets::GetPartyMember())
+        buffer.append("P:");
+    if (target == MockedTargets::GetCurrentTarget())
+        buffer.append("T:");
+    if (target == MockedTargets::GetSelf())
+        buffer.append("S:");
+    if (target == MockedTargets::GetPet())
+        buffer.append("Pet:");
+    if (target == MockedTargets::GetCc())
+        buffer.append("Cc:");
+    buffer.append(name);
+
+    spellCooldowns.push_back(name);
+    auras[target].push_back(name);
+
+    return true;
+}
+
+bool MockPlayerbotAIBase::HasAura(string spellName, Unit* player)
+{
+    for (list<string >::iterator i = auras[player].begin(); i != auras[player].end(); i++)
+    {
+        string s = *i;
+        if (s == spellName)
+            return TRUE;
+    }
+    return false;
+
+}
+bool MockPlayerbotAIBase::IsInterruptableSpellCasting(Unit* player, string spell)
+{
+    return targetIsCastingNonMeleeSpell;
+}
+
+bool MockPlayerbotAIBase::HasAuraToDispel(Unit* player, uint32 dispelType)
+{
+    return dispels[player] == dispelType;
+}
diff --git a/src/test/MockPlayerbotAIBase.h b/src/test/MockPlayerbotAIBase.h
new file mode 100644
index 0000000..d80bac0
--- /dev/null
+++ b/src/test/MockPlayerbotAIBase.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#include "MockedTargets.h"
+
+namespace ai
+{
+	class MockPlayerbotAIBase : public PlayerbotAI
+	{
+	public:
+		MockPlayerbotAIBase() : PlayerbotAI()
+        {
+            targetIsCastingNonMeleeSpell = false;
+        }
+        void SetContext(AiObjectContext* context) { this->aiObjectContext = context; }
+
+        virtual uint32 GetSpellId(string args) { return 1; }
+        virtual void InterruptSpell();
+        virtual void RemoveAura(string name);
+        virtual bool CanCastSpell(string name, Unit* target);
+        virtual bool CastSpell(string name, Unit* target);
+        virtual bool HasAura(string spellName, Unit* player);
+        virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+        virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+        virtual bool IsSpellCastUseful(string name, Unit* target);
+
+    public:
+        void resetSpells() {spellCooldowns.clear(); }
+
+    public:
+        string buffer;
+
+    public:
+        list<string > spellCooldowns;
+
+        map<Unit*, list<string >> auras;
+        map<Unit*, uint32> dispels;
+
+        bool targetIsCastingNonMeleeSpell;
+    };
+
+}
diff --git a/src/test/MockedAiObjectContextTestCase.h b/src/test/MockedAiObjectContextTestCase.h
new file mode 100644
index 0000000..3ce0d1d
--- /dev/null
+++ b/src/test/MockedAiObjectContextTestCase.h
@@ -0,0 +1,54 @@
+#include "MockAiObjectContext.h"
+
+using namespace ai;
+
+
+class MockedAiObjectContextTestCase : public EngineTestBase
+{
+
+protected:
+    MockAiObjectContext* context;
+
+
+protected:
+    void assertCommand(string  trigger)
+    {
+        assertCommand(trigger, trigger);
+    }
+
+    void assertCommand(string  trigger, string  expectedAction)
+    {
+        ai->buffer.clear();
+
+        context->GetTrigger(trigger)->ExternalEvent("");
+        tick();
+
+        assertActions(string(">S:") + expectedAction);
+    }
+
+    void assertParametrizedCommand(string  trigger, string  param)
+    {
+        ai->buffer.clear();
+
+        context->GetTrigger(trigger)->ExternalEvent(param);
+        tick();
+
+        assertActions(string (">S:") + trigger + "(" + param + ")");
+    }
+
+    void trigger(string  name)
+    {
+        context->GetTrigger(name)->ExternalEvent("");
+    }
+
+    void trigger(string  name, string  param)
+    {
+        context->GetTrigger(name)->ExternalEvent(param);
+    }
+
+    void tickWithTrigger(string  name)
+    {
+        trigger(name);
+        tick();
+    }
+};
diff --git a/src/test/MockedTargets.h b/src/test/MockedTargets.h
new file mode 100644
index 0000000..812b670
--- /dev/null
+++ b/src/test/MockedTargets.h
@@ -0,0 +1,65 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class MockedTargets
+    {
+	public:
+		static Unit* GetPartyMember() { return (Unit*)1; }
+		static Unit* GetCurrentTarget()  { return (Unit*)7; }
+		static Player* GetSelf() { return (Player*)9; }
+		static Unit* GetPet() { return (Unit*)10; }
+		static Player* GetMaster() { return (Player*)2; }
+        static Player* GetTargetForDps() { return (Player*)3; }
+        static Player* GetTargetForTank() { return (Player*)4; }
+        static Player* GetCc() { return (Player*)12; }
+		static Player* GetLineTarget() { return (Player*)14; }
+		static Unit* GetLeastHpTarget() { return (Unit*)15; }
+		static Unit* GetLeastHpPartyMember() { return (Unit*)16; }
+		static Unit* GetRtiTarget() { return (Unit*)17; }
+		static Unit* GetDuelTarget() { return (Unit*)18; }
+		static Unit* GetGridTarget() { return (Unit*)19; }
+		static Unit* GetEnemyPlayer() { return (Unit*)20; }
+		static Unit* GetAttackerWithoutAura() { return (Unit*)21; }
+		static Unit* GetEnemyHealer() { return (Unit*)22; }
+
+        static void Append(string &buffer, Unit* unit)
+        {
+            if (unit == GetPartyMember())
+                buffer.append("P");
+            if (unit == GetCurrentTarget())
+                buffer.append("T");
+            if (unit == GetSelf())
+                buffer.append("S");
+            if (unit == GetPet())
+                buffer.append("Pet");
+            if (unit == GetMaster())
+                buffer.append("M");
+            if (unit == GetTargetForDps())
+                buffer.append("Dps");
+            if (unit == GetTargetForTank())
+                buffer.append("Tank");
+            if (unit == GetCc())
+                buffer.append("Cc");
+            if (unit == GetLineTarget())
+                buffer.append("Line");
+            if (unit == GetLeastHpTarget())
+                buffer.append("LeastHp");
+            if (unit == GetRtiTarget())
+                buffer.append("Rti");
+            if (unit == GetDuelTarget())
+                buffer.append("Duel");
+            if (unit == GetGridTarget())
+                buffer.append("Grind");
+            if (unit == GetEnemyPlayer())
+                buffer.append("Enemy");
+            if (unit == GetAttackerWithoutAura())
+                buffer.append("A");
+            if (unit == GetEnemyHealer())
+                buffer.append("H");
+        }
+   };
+
+}
diff --git a/src/test/NextActionTestCase.cpp b/src/test/NextActionTestCase.cpp
new file mode 100644
index 0000000..be94d98
--- /dev/null
+++ b/src/test/NextActionTestCase.cpp
@@ -0,0 +1,82 @@
+#include "pch.h"
+
+#include "aitest.h"
+
+using namespace ai;
+
+class NextActionTestCase : public CPPUNIT_NS::TestFixture
+{
+	CPPUNIT_TEST_SUITE( NextActionTestCase );
+	CPPUNIT_TEST( array );
+    CPPUNIT_TEST( clone );
+    CPPUNIT_TEST( merge );
+    CPPUNIT_TEST( cloneNull );
+    CPPUNIT_TEST( mergeWithNull );
+	CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void array()
+    {
+        NextAction** actions = NextAction::array(0, new NextAction("1", 1), NULL);
+        CPPUNIT_ASSERT(actions[0]->getName() == "1");
+        CPPUNIT_ASSERT(!actions[1]);
+        NextAction::destroy(actions);
+    }
+
+	void clone()
+	{
+		NextAction** actions = new NextAction*[3];
+        actions[0] = new NextAction("1", 1);
+        actions[1] = new NextAction("2", 2);
+        actions[2] = NULL;
+
+        NextAction** cloned = NextAction::clone(actions);
+
+		CPPUNIT_ASSERT(!cloned[2]);
+		CPPUNIT_ASSERT(cloned[0]->getName() == "1");
+        CPPUNIT_ASSERT(cloned[1]->getName() == "2");
+
+        // check memory
+        NextAction::destroy(cloned);
+	}
+
+    void merge()
+    {
+        NextAction** left = NextAction::array(0, new NextAction("1", 1),  new NextAction("2", 2), NULL);
+        NextAction** right = NextAction::array(0, new NextAction("3", 3), NULL);
+
+        NextAction** merged = NextAction::merge(left, right);
+
+        CPPUNIT_ASSERT(!merged[3]);
+        CPPUNIT_ASSERT(merged[0]->getName() == "1");
+        CPPUNIT_ASSERT(merged[1]->getName() == "2");
+        CPPUNIT_ASSERT(merged[2]->getName() == "3");
+
+        // check memory
+        NextAction::destroy(merged);
+    }
+
+    void cloneNull()
+    {
+        NextAction** cloned = NextAction::clone(NULL);
+        CPPUNIT_ASSERT(!cloned);
+    }
+
+    void mergeWithNull()
+    {
+        NextAction** left = NextAction::array(0, new NextAction("1", 1), NULL);
+        NextAction** merged = NextAction::merge(left, NULL);
+
+        CPPUNIT_ASSERT(!merged[1]);
+        CPPUNIT_ASSERT(merged[0]->getName() == "1");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NextActionTestCase );
diff --git a/src/test/NonCombatEngineTestCase.cpp b/src/test/NonCombatEngineTestCase.cpp
new file mode 100644
index 0000000..5e84eaa
--- /dev/null
+++ b/src/test/NonCombatEngineTestCase.cpp
@@ -0,0 +1,300 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+
+using namespace ai;
+
+
+class NonCombatEngineTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( NonCombatEngineTestCase );
+      CPPUNIT_TEST( followMaster );
+      CPPUNIT_TEST( stay );
+      CPPUNIT_TEST( eatDrink );
+      CPPUNIT_TEST( dpsAssist );
+      CPPUNIT_TEST( tankAssist );
+      CPPUNIT_TEST( attackWeak );
+      CPPUNIT_TEST( doNotGrindIfLowMpHp );
+      CPPUNIT_TEST( grindIfNoMana );
+      CPPUNIT_TEST( attackRti );
+      CPPUNIT_TEST( loot );
+      CPPUNIT_TEST( loot_failed );
+      CPPUNIT_TEST( gather );
+      CPPUNIT_TEST( runaway );
+      CPPUNIT_TEST( passive );
+      CPPUNIT_TEST( movementStrategies );
+      CPPUNIT_TEST( assistStrategies );
+      CPPUNIT_TEST( out_of_react );
+      CPPUNIT_TEST( tell_target );
+      CPPUNIT_TEST( pvp );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new AiObjectContext(ai), NULL);
+	}
+
+protected:
+    void runaway()
+    {
+        engine->addStrategy("runaway");
+		tickWithAttackerCount(0);
+		tickInMeleeRange();
+        assertActions(">S:runaway>S:runaway");
+    }
+
+    void followMaster()
+    {
+        engine->addStrategy("follow");
+
+        set<float>("distance", "master target", 20);
+		tickWithAttackerCount(0);
+		assertActions(">S:follow");
+    }
+
+    void stay()
+    {
+		engine->addStrategy("stay");
+
+		tickWithAttackerCount(0);
+		assertActions(">S:stay");
+    }
+
+    void dpsAssist()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("dps assist");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Dps:dps assist");
+    }
+
+
+	void tankAssist()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("tank assist");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Tank:tank assist");
+	}
+
+	void attackRti()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("attack rti");
+
+		tick();
+		tickWithNoTarget();
+
+		assertActions(">S:stay>Rti:attack rti target");
+	}
+
+	void attackWeak()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("attack weak");
+
+		set<Unit*>("current target", MockedTargets::GetLeastHpTarget());
+		tick();
+
+		tickWithNoTarget();
+
+		set<Unit*>("current target", MockedTargets::GetCurrentTarget()); // means any other
+		tick();
+
+		assertActions(">S:stay>LeastHp:attack least hp target>LeastHp:attack least hp target");
+	}
+
+	void pvp()
+	{
+		engine->addStrategy("stay");
+		engine->addStrategy("pvp");
+
+        set<Unit*>("current target", MockedTargets::GetEnemyPlayer());
+		tick();
+
+		tickWithNoTarget();
+
+		set<Unit*>("current target", MockedTargets::GetCurrentTarget()); // means any other
+		tick();
+
+		assertActions(">S:stay>Enemy:attack enemy player>Enemy:attack enemy player");
+	}
+
+    void loot()
+    {
+		engine->addStrategy("stay");
+		engine->addStrategy("loot");
+
+		tickWithLootAvailable();
+
+        set<float>("distance", "loot target", 15.0f);
+        tick();
+
+        set<float>("distance", "loot target", 0.0f);
+        set<bool>("can loot", true);
+        tick();
+
+        set<bool>("can loot", false);
+        tick();
+
+        set<uint8>("bag space", 99);
+        tickWithLootAvailable();
+        set<uint8>("bag space", 0);
+
+        assertActions(">S:loot>S:move to loot>S:open loot>S:stay>S:check mount state");
+    }
+
+    void loot_failed()
+    {
+		engine->addStrategy("follow");
+		engine->addStrategy("loot");
+
+		tickWithLootAvailable();
+
+        set<float>("distance", "loot target", 15.0f);
+        tick();
+        set<float>("distance", "loot target", 0.0f);
+
+        set<bool>("can loot", true);
+        tick();
+
+        spellAvailable("open loot");
+        tick();
+
+        assertActions(">S:loot>S:move to loot>S:open loot>S:open loot");
+    }
+
+    void gather()
+    {
+		engine->addStrategy("stay");
+		engine->addStrategy("gather");
+		engine->addStrategy("loot");
+
+		set<list<ObjectGuid>>("possible targets", list<ObjectGuid>());
+		tick();
+
+        tickWithLootAvailable();
+
+        set<bool>("can loot", true);
+        tick();
+
+        assertActions(">S:add gathering loot>S:loot>S:open loot");
+    }
+
+    void eatDrink()
+    {
+        engine->addStrategy("food");
+        set<uint8>("item count", "food", 1);
+        set<uint8>("item count", "drink", 1);
+
+        tickWithLowHealth(1);
+        tickWithLowMana(1);
+
+        assertActions(">S:food>S:drink");
+    }
+
+    void passive()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("passive");
+
+        tick();
+		tickWithNoTarget();
+
+        assertActions(">S:stay>S:check mount state");
+    }
+
+    void movementStrategies()
+    {
+        engine->addStrategy("follow");
+        engine->addStrategy("follow line");
+        engine->addStrategy("be near");
+        engine->addStrategy("runaway");
+        engine->addStrategy("stay");
+
+        cout << engine->ListStrategies();
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: stay");
+    }
+
+    void assistStrategies()
+    {
+        engine->addStrategy("dps assist");
+        engine->addStrategy("tank asssist");
+        engine->addStrategy("dps aoe");
+        engine->addStrategy("tank asssist");
+        engine->addStrategy("grind");
+
+        cout << engine->ListStrategies();
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: grind");
+    }
+
+    void out_of_react()
+    {
+        engine->addStrategy("follow");
+        set<float>("distance", "master target", 100.0f / 2 + 10);
+        tick();
+        assertActions(">S:tell out of react range");
+    }
+
+    void tell_target()
+    {
+        engine->addStrategy("tell target");
+        set<Unit*>("old target", MockedTargets::GetPet());
+        tick();
+        set<Unit*>("current target", NULL);
+        tick();
+        assertActions(">S:tell target");
+    }
+
+    void doNotGrindIfLowMpHp()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("grind");
+        context->GetValue<Unit*>("grind target")->Set(MockedTargets::GetGridTarget());
+
+        tick();
+        set<uint8>("health", "self target", 1);
+        tickWithNoTarget();
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 1);
+        tickWithNoTarget();
+
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 100);
+        tickWithNoTarget();
+
+        set<uint8>("health", "self target", 1);
+        set<bool>("combat", "self target", true);
+        tickWithNoTarget();
+
+        set<bool>("combat", "self target", false);
+        tickWithNoTarget();
+
+        assertActions(">S:stay>S:check mount state>S:check mount state>Grind:attack anything>Grind:attack anything>S:check mount state");
+    }
+
+    void grindIfNoMana()
+    {
+        engine->addStrategy("stay");
+        engine->addStrategy("grind");
+        context->GetValue<Unit*>("grind target")->Set(MockedTargets::GetGridTarget());
+
+        tick();
+        set<uint8>("health", "self target", 100);
+        set<uint8>("mana", "self target", 0);
+        tickWithNoTarget();
+
+        assertActions(">S:stay>Grind:attack anything");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NonCombatEngineTestCase );
diff --git a/src/test/NonCombatEngineTestCase2.cpp b/src/test/NonCombatEngineTestCase2.cpp
new file mode 100644
index 0000000..e053286
--- /dev/null
+++ b/src/test/NonCombatEngineTestCase2.cpp
@@ -0,0 +1,42 @@
+#include "pch.h"
+#include "aitest.h"
+
+#include "EngineTestBase.h"
+#include "MockedAiObjectContextTestCase.h"
+
+using namespace ai;
+
+
+class NonCombatEngineTestCase2 : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( NonCombatEngineTestCase2 );
+      CPPUNIT_TEST( emote );
+      CPPUNIT_TEST( ready_check );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+	void setUp()
+	{
+		EngineTestBase::setUp();
+        setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "emote", NULL);
+	}
+
+protected:
+    void emote()
+    {
+        tickWithTrigger("random");
+        tickWithTrigger("seldom");
+
+        assertActions(">S:emote>S:suggest what to do");
+    }
+
+    void ready_check()
+    {
+        engine->addStrategy("ready check");
+        tickWithTrigger("timer");
+
+        assertActions(">S:ready check");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( NonCombatEngineTestCase2 );
diff --git a/src/test/PaladinNonCombatTestCase.cpp b/src/test/PaladinNonCombatTestCase.cpp
new file mode 100644
index 0000000..31c5bcb
--- /dev/null
+++ b/src/test/PaladinNonCombatTestCase.cpp
@@ -0,0 +1,97 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class PaladinNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PaladinNonCombatTestCase );
+        CPPUNIT_TEST( buff );
+		CPPUNIT_TEST( resurrect );
+		CPPUNIT_TEST( healing );
+        CPPUNIT_TEST( curePoison );
+        CPPUNIT_TEST( cureMagic );
+        CPPUNIT_TEST( cureDisease );
+    CPPUNIT_TEST_SUITE_END();
+
+
+public:
+    virtual void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "nc", NULL);
+
+        set<uint8>("attacker count", 0);
+    }
+
+protected:
+    void buff()
+    {
+        tick();
+
+        engine->addStrategy("bspeed");
+        set<bool>("mounted", "self target", true);
+		tick();
+        set<bool>("mounted", "self target", false);
+
+		assertActions(">P:blessing of kings on party>S:crusader aura");
+    }
+
+	void resurrect()
+	{
+		tickWithDeadPartyMember();
+		assertActions(">P:redemption");
+	}
+
+    void healing()
+    {
+        tickWithLowHealth(50);
+        tickWithLowHealth(30);
+
+        spellAvailable("flash of light");
+        spellAvailable("holy light");
+        tickWithPartyLowHealth(50);
+        tickWithPartyLowHealth(30);
+
+        assertActions(">S:flash of light>S:holy light>P:flash of light on party>P:holy light on party");
+    }
+
+
+    void cureDisease()
+    {
+        cureKind(DISPEL_DISEASE);
+        assertActions(">S:cleanse>P:cleanse disease on party>S:purify>P:purify disease on party");
+    }
+
+    void curePoison()
+    {
+        cureKind(DISPEL_POISON);
+        assertActions(">S:cleanse>P:cleanse poison on party>S:purify>P:purify poison on party");
+    }
+
+    void cureMagic()
+    {
+        cureKind(DISPEL_MAGIC);
+        assertActions(">S:cleanse>P:cleanse magic on party>P:blessing of kings on party>S:check mount state");
+    }
+
+    void cureKind(DispelType type)
+    {
+        spellAvailable("cleanse");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("cleanse");
+        tickWithPartyAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithPartyAuraToDispel(type);
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PaladinNonCombatTestCase );
diff --git a/src/test/PerformanceTestCase.cpp b/src/test/PerformanceTestCase.cpp
new file mode 100644
index 0000000..0113db1
--- /dev/null
+++ b/src/test/PerformanceTestCase.cpp
@@ -0,0 +1,177 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/druid/DruidAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/hunter/HunterAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+
+using namespace ai;
+
+#define MAX_TICKS 20
+
+class EverythingFailedActionExecutionListener : public ActionExecutionListener
+{
+public:
+    EverythingFailedActionExecutionListener(MockPlayerbotAIBase *ai) : ai(ai) {}
+
+    virtual bool Before(Action* action, Event event)
+    {
+        string name = action->getName();
+        if (name == "melee" ||
+                name == "shoot" ||
+                name == "auto shot" ||
+                name == "reach melee" ||
+                name == "reach spell")
+            return true;
+
+        return false;
+    }
+
+    virtual bool AllowExecution(Action* action, Event event) { return false; }
+    virtual bool OverrideResult(Action* action, bool executed, Event event) { return executed; }
+    virtual void After(Action* action, bool executed, Event event) {}
+
+private:
+    MockPlayerbotAIBase *ai;
+};
+
+
+
+class PerformanceTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PerformanceTestCase );
+        CPPUNIT_TEST( druidBear );
+        CPPUNIT_TEST( druidCat );
+        CPPUNIT_TEST( paladin );
+        CPPUNIT_TEST( warrior );
+        CPPUNIT_TEST( warlock );
+        CPPUNIT_TEST( priest );
+        CPPUNIT_TEST( mage );
+        CPPUNIT_TEST( hunter );
+        CPPUNIT_TEST( shaman );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new AiObjectContext(ai), "melee", NULL);
+    }
+
+protected:
+    void run()
+    {
+        time_t timestamp = time(0);
+        int i = 0;
+        for (; i<sPlayerbotAIConfig.iterationsPerTick; ++i)
+        {
+            tick();
+
+            if (!ai->buffer.empty())
+                break;
+        }
+
+        CPPUNIT_ASSERT(!ai->buffer.empty());
+
+        cout << ai->buffer << " - " << i << "ticks, time: " << (time(0) - timestamp);
+    }
+
+    void druidBear()
+    {
+        setupEngine(new DruidAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void paladin()
+    {
+        setupEngine(new PaladinAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void priest()
+    {
+        setupEngine(new PriestAiObjectContext(ai), "heal", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void mage()
+    {
+        setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void hunter()
+    {
+        setupEngine(new HunterAiObjectContext(ai), "dps", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void warrior()
+    {
+        setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void druidCat()
+    {
+        setupEngine(new DruidAiObjectContext(ai), "cat", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void warlock()
+    {
+        setupEngine(new WarlockAiObjectContext(ai), "dps", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+
+    void shaman()
+    {
+        setupEngine(new ShamanAiObjectContext(ai), "melee", NULL);
+        engine->AddActionExecutionListener(new EverythingFailedActionExecutionListener(ai));
+
+        sPlayerbotAIConfig.iterationsPerTick = MAX_TICKS;
+        run();
+        sPlayerbotAIConfig.iterationsPerTick = 10;
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PerformanceTestCase );
diff --git a/src/test/PriestNonCombatTestCase.cpp b/src/test/PriestNonCombatTestCase.cpp
new file mode 100644
index 0000000..584c403
--- /dev/null
+++ b/src/test/PriestNonCombatTestCase.cpp
@@ -0,0 +1,112 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/priest/PriestAiObjectContext.h"
+
+using namespace ai;
+
+
+class PriestNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( PriestNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( healing );
+    CPPUNIT_TEST( aoe_heal );
+    CPPUNIT_TEST( nonCombat );
+    CPPUNIT_TEST( dispel );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new PriestAiObjectContext(ai), "nc", NULL);
+
+        addAura("power word: fortitude");
+        addPartyAura("power word: fortitude");
+        addAura("divine spirit");
+        addAura("inner fire");
+        addPartyAura("power word: fortitude");
+        addPartyAura("divine spirit");
+    }
+
+protected:
+    void nonCombat()
+    {
+		tickWithDeadPartyMember();
+
+		assertActions(">P:resurrection");
+    }
+
+    void aoe_heal()
+    {
+        tickWithAoeHeal("medium");
+
+		assertActions(">P:circle of healing");
+    }
+
+    void healing()
+    {
+		tickWithLowHealth(30);
+
+		spellAvailable("flash heal");
+		tickWithPartyLowHealth(30);
+
+		tickWithLowHealth(10);
+		addAura("power word: shield");
+		tickWithLowHealth(10);
+
+		spellAvailable("power word: shield");
+		spellAvailable("greater heal");
+		tickWithPartyLowHealth(10);
+        addPartyAura("power word: shield");
+		tickWithPartyLowHealth(10);
+
+		assertActions(">S:flash heal>P:flash heal on party>S:power word: shield>S:greater heal>P:power word: shield on party>P:greater heal on party");
+    }
+
+    void buff()
+    {
+		removeAura("power word: fortitude");
+        removeAura("divine spirit");
+        removeAura("inner fire");
+        removePartyAura("power word: fortitude");
+        removePartyAura("divine spirit");
+
+        tick();
+        addAura("divine spirit");
+
+        tickWithSpellAvailable("divine spirit");
+        addPartyAura("divine spirit");
+
+        tick();
+        addAura("power word: fortitude");
+
+        tickWithSpellAvailable("power word: fortitude");
+        addPartyAura("power word: fortitude");
+
+        tick();
+
+		assertActions(">S:divine spirit>P:divine spirit on party>S:power word: fortitude>P:power word: fortitude on party>S:inner fire");
+    }
+
+    void dispel()
+    {
+        tickWithAuraToDispel(DISPEL_DISEASE);
+        tickWithAuraToDispel(DISPEL_DISEASE);
+
+        spellAvailable("abolish disease");
+        spellAvailable("cure disease");
+        tickWithPartyAuraToDispel(DISPEL_DISEASE);
+        tickWithPartyAuraToDispel(DISPEL_DISEASE);
+
+        tickWithAuraToDispel(DISPEL_MAGIC);
+
+        spellAvailable("dispel magic");
+        tickWithPartyAuraToDispel(DISPEL_MAGIC);
+
+		assertActions(">S:abolish disease>S:cure disease>P:abolish disease on party>P:cure disease on party>S:dispel magic>P:dispel magic on party");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PriestNonCombatTestCase );
diff --git a/src/test/QualifiedValueTestCase.cpp b/src/test/QualifiedValueTestCase.cpp
new file mode 100644
index 0000000..e4d64c4
--- /dev/null
+++ b/src/test/QualifiedValueTestCase.cpp
@@ -0,0 +1,84 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class TestQualifiedValue : public ManualSetValue<string >, public Qualified
+{
+public:
+    TestQualifiedValue(PlayerbotAI* ai) : ManualSetValue<string >(ai, "", "name"), Qualified() {}
+    virtual string Get() { return qualifier; }
+};
+
+class TestQualifiedValueContext : public NamedObjectContext<UntypedValue>
+{
+public:
+    TestQualifiedValueContext()
+    {
+        creators["value"] = &TestQualifiedValueContext::value;
+    }
+
+private:
+    static UntypedValue* value(PlayerbotAI* ai) { return new TestQualifiedValue(ai); }
+};
+
+class TestQualifiedValueAiObjectContext : public AiObjectContext
+{
+public:
+    TestQualifiedValueAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        valueContexts.Add(new TestQualifiedValueContext());
+    }
+};
+
+
+class QualifiedValueTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( QualifiedValueTestCase );
+      CPPUNIT_TEST( empty );
+      CPPUNIT_TEST( qualifier );
+      CPPUNIT_TEST( number );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void qualifier()
+	{
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+
+        Value<string > *value = context.GetValue<string >("value", "data");
+        CPPUNIT_ASSERT(value->Get() == "data");
+	}
+
+    void empty()
+    {
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+
+        Value<string > *value = context.GetValue<string >("value");
+        CPPUNIT_ASSERT(value->Get().empty());
+    }
+
+    void number()
+    {
+        MockPlayerbotAIBase ai;
+        TestQualifiedValueAiObjectContext context(&ai);
+
+        Value<string > *value = context.GetValue<string >("value", 5);
+        CPPUNIT_ASSERT(value->Get() == "5");
+
+        value = context.GetValue<string >("value", "5");
+        CPPUNIT_ASSERT(value->Get() == "5");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QualifiedValueTestCase );
diff --git a/src/test/QuestStrategyTestCase.cpp b/src/test/QuestStrategyTestCase.cpp
new file mode 100644
index 0000000..2faf831
--- /dev/null
+++ b/src/test/QuestStrategyTestCase.cpp
@@ -0,0 +1,73 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class QuestStrategyTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( QuestStrategyTestCase );
+      CPPUNIT_TEST( turn_in_quest );
+      CPPUNIT_TEST( accept_quest );
+      CPPUNIT_TEST( quest_share );
+      CPPUNIT_TEST( useGameObject );
+      CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "quest", NULL);
+    }
+
+protected:
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+
+        assertActions(">S:talk to quest giver");
+    }
+
+    void turn_in_quest()
+    {
+        trigger("complete quest");
+        tick();
+
+        trigger("gossip hello");
+        tick();
+
+        assertActions(">S:talk to quest giver>S:talk to quest giver");
+    }
+
+    void accept_quest()
+    {
+        trigger("accept quest");
+        tick();
+
+        assertActions(">S:accept quest");
+    }
+
+    void quest_share()
+    {
+        trigger("quest share");
+        tick();
+
+        assertActions(">S:accept quest share");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("quest", "accept all quests", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: accept all quests");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QuestStrategyTestCase );
diff --git a/src/test/QueueTestCase.cpp b/src/test/QueueTestCase.cpp
new file mode 100644
index 0000000..d607bac
--- /dev/null
+++ b/src/test/QueueTestCase.cpp
@@ -0,0 +1,40 @@
+#include "pch.h"
+#include "aitest.h"
+#include "../plugins/playerbot/strategy/actions/GenericSpellActions.h"
+
+using namespace ai;
+
+class QueueTestCase : public CPPUNIT_NS::TestFixture
+{
+	CPPUNIT_TEST_SUITE( QueueTestCase );
+	CPPUNIT_TEST( queueMustHaveOrder );
+	CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+	void queueMustHaveOrder()
+	{
+		MockPlayerbotAIBase mock;
+		CastSpellAction action1(&mock, "1");
+        CastSpellAction action2(&mock, "2");
+        CastSpellAction action3(&mock, "3");
+
+		Queue q;
+		q.Push(new ActionBasket(new ActionNode("action1", NULL, NULL, NULL), 0.5f, false, Event()));
+		q.Push(new ActionBasket(new ActionNode("action2", NULL, NULL, NULL), 0.7f, false, Event()));
+		q.Push(new ActionBasket(new ActionNode("action3", NULL, NULL, NULL), 0.3f, false, Event()));
+
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action2");
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action1");
+		CPPUNIT_ASSERT(string (q.Pop()->getName()) == "action3");
+		CPPUNIT_ASSERT(q.Pop() == NULL);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( QueueTestCase );
diff --git a/src/test/RacialsTestCase.cpp b/src/test/RacialsTestCase.cpp
new file mode 100644
index 0000000..f23bca2
--- /dev/null
+++ b/src/test/RacialsTestCase.cpp
@@ -0,0 +1,41 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "EngineTestBase.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class RacialsTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( RacialsTestCase );
+    CPPUNIT_TEST( healing );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+		engine->addStrategy("racials");
+        set<float>("distance", "current target", 0.0f);
+
+		addAura("battle shout");
+		addAura("defensive stance");
+    }
+
+protected:
+    void healing()
+    {
+		tickWithLowHealth(39);
+		tickWithLowHealth(39);
+
+        tickWithLowMana(39);
+
+        assertActions(">S:lifeblood>S:gift of the naaru>S:arcane torrent");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( RacialsTestCase );
diff --git a/src/test/RandomItemMgrTestCase.cpp b/src/test/RandomItemMgrTestCase.cpp
new file mode 100644
index 0000000..9e7f3d7
--- /dev/null
+++ b/src/test/RandomItemMgrTestCase.cpp
@@ -0,0 +1,84 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../plugins/playerbot/RandomItemMgr.h"
+#include "cppunit/extensions/HelperMacros.h"
+#include "cppunit/TestFixture.h"
+
+using namespace ai;
+
+
+class RandomItemMgrTestCase : public CPPUNIT_NS::TestFixture
+{
+
+    void Show(uint32 id)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        cout << proto->ItemId << " = " << proto->Name1 << endl;
+    }
+
+  CPPUNIT_TEST_SUITE( RandomItemMgrTestCase );
+      CPPUNIT_TEST( guildTaskItems );
+      CPPUNIT_TEST( guildTaskRewardItems );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        TC_LOG_INFO("server.loading", "Loading SpellInfo store...");
+        sSpellMgr->LoadSpellInfoStore();
+
+        TC_LOG_INFO("server.loading", "Loading SpellInfo corrections...");
+        sSpellMgr->LoadSpellInfoCorrections();
+
+        TC_LOG_INFO("server.loading", "Loading SkillLineAbilityMultiMap Data...");
+        sSpellMgr->LoadSkillLineAbilityMap();
+
+        TC_LOG_INFO("server.loading", "Loading SpellInfo custom attributes...");
+        sSpellMgr->LoadSpellInfoCustomAttributes();
+
+        TC_LOG_INFO("server.loading", "Loading Item Random Enchantments Table...");
+        LoadRandomEnchantmentsTable();
+
+        TC_LOG_INFO("server.loading", "Loading Items...");                         // must be after LoadRandomEnchantmentsTable and LoadPageTexts
+        sObjectMgr->LoadItemTemplates();
+    }
+    virtual void tearDown()
+    {
+    }
+
+protected:
+ 	void checkRandomItems(RandomItemType type)
+	{
+        RandomItemList const& list = sRandomItemMgr.Query(type, NULL);
+        CPPUNIT_ASSERT(!list.empty());
+
+        for (RandomItemList::const_iterator i = list.begin(); i != list.end(); ++i)
+        {
+            uint32 id = *i;
+            Show(id);
+        }
+
+        cout << "Picking randoms" << endl;
+
+        for (int i = 0; i < 10; i++)
+        {
+            uint32 id = sRandomItemMgr.GetRandomItem(type, NULL);
+            CPPUNIT_ASSERT(id);
+            Show(id);
+        }
+	}
+
+ 	void guildTaskItems()
+ 	{
+ 	   checkRandomItems(RANDOM_ITEM_GUILD_TASK);
+	}
+
+ 	void guildTaskRewardItems()
+ 	{
+ 	   checkRandomItems(RANDOM_ITEM_GUILD_TASK_REWARD);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( RandomItemMgrTestCase );
diff --git a/src/test/ShamanNonCombatTestCase.cpp b/src/test/ShamanNonCombatTestCase.cpp
new file mode 100644
index 0000000..d0c8dc1
--- /dev/null
+++ b/src/test/ShamanNonCombatTestCase.cpp
@@ -0,0 +1,69 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+
+using namespace ai;
+
+
+class ShamanNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( ShamanNonCombatTestCase );
+        CPPUNIT_TEST( ressurect );
+        CPPUNIT_TEST( swimming );
+        CPPUNIT_TEST( healing );
+        CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(new ShamanAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+	void ressurect()
+	{
+		tickWithDeadPartyMember();
+
+		assertActions(">P:ancestral spirit");
+	}
+
+	void healing()
+	{
+	    tickWithLowHealth(10);
+	    spellAvailable("healing wave");
+	    tickWithPartyLowHealth(10);
+
+		assertActions(">S:healing wave>P:healing wave on party");
+	}
+
+	void aoe()
+	{
+	    tickWithAoeHeal("medium");
+
+		assertActions(">P:chain heal");
+	}
+
+	void swimming()
+	{
+	    tickWhileSwimming();
+	    addAura("water breathing");
+
+	    tickWhileSwimming();
+        addAura("water walking");
+
+        spellAvailable("water breathing");
+        tickWhileSwimming();
+        addPartyAura("water breathing");
+
+        spellAvailable("water walking");
+        tickWhileSwimming();
+        addPartyAura("water walking");
+
+		assertActions(">S:water breathing>S:water walking>P:water breathing on party>P:water walking on party");
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ShamanNonCombatTestCase );
diff --git a/src/test/TankPaladinTestCase.cpp b/src/test/TankPaladinTestCase.cpp
new file mode 100644
index 0000000..e8c9261
--- /dev/null
+++ b/src/test/TankPaladinTestCase.cpp
@@ -0,0 +1,224 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankPaladinTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( TankPaladinTestCase );
+		CPPUNIT_TEST( combatVsMelee );
+		CPPUNIT_TEST( paladinMustHoldAggro );
+		CPPUNIT_TEST( healing );
+		CPPUNIT_TEST( buff );
+		CPPUNIT_TEST( bmana );
+		CPPUNIT_TEST( curePoison );
+		CPPUNIT_TEST( cureMagic );
+		CPPUNIT_TEST( cureDisease );
+		CPPUNIT_TEST( interruptSpells );
+		CPPUNIT_TEST( resistances );
+		CPPUNIT_TEST( combatIncompatibles );
+		CPPUNIT_TEST( buffIncompatibles );
+		CPPUNIT_TEST( resistanceIncompatibles );
+		CPPUNIT_TEST( lowMana );
+		CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+	virtual void setUp()
+	{
+		EngineTestBase::setUp();
+		setupEngine(new PaladinAiObjectContext(ai), "tank", NULL);
+		engine->addStrategy("barmor");
+
+        addAura("devotion aura");
+        addAura("seal of justice");
+        addAura("blessing of sanctuary");
+        addAura("righteous fury");
+
+		addAura("holy shield");
+
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+    }
+
+protected:
+    void bmana()
+    {
+		engine->removeStrategy("bhealth");
+		engine->addStrategy("bmana");
+
+        removeAura("seal of justice");
+        tick();
+
+		assertActions(">S:seal of wisdom");
+	}
+
+    void buff()
+    {
+        removeAura("devotion aura");
+        removeAura("righteous fury");
+        removeAura("blessing of sanctuary");
+        removeAura("seal of justice");
+        removeAura("holy shield");
+
+        tick();
+        addAura("devotion aura");
+
+        tick();
+        tick();
+        addAura("seal of light");
+
+        tick();
+        tick();
+        addAura("blessing of kings");
+
+        tick();
+        addAura("righteous fury");
+
+        tick();
+        addAura("holy shield");
+
+        assertActions(">S:devotion aura>S:seal of light>S:seal of justice>S:blessing of sanctuary>S:blessing of kings>S:righteous fury>S:holy shield");
+    }
+
+    void healing()
+    {
+		tickWithLowHealth(50);
+
+		tickWithLowHealth(30);
+        tickWithLowHealth(30);
+
+		tickWithLowHealth(19);
+
+		spellAvailable("lay on hands");
+		tickWithPartyLowHealth(20);
+        tickWithLowHealth(19);
+        spellAvailable("flash of light");
+        tickWithLowHealth(19);
+
+        assertActions(">S:flash of light>S:divine protection>S:holy light>S:lay on hands>P:lay on hands on party>S:divine shield>S:flash of light");
+    }
+
+    void paladinMustHoldAggro()
+    {
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+
+		tickWithAttackerCount(3);
+
+		tickWithNoAggro();
+		tickWithNoAggro();
+
+		assertActions(">T:hammer of the righteous>T:avenger's shield>T:consecration>T:hand of reckoning>T:judgement of justice");
+    }
+
+    void combatVsMelee()
+    {
+		tickOutOfMeleeRange();
+
+        tick();
+
+		tickWithTargetLowHealth(19);
+
+        assertActions(">T:reach melee>T:judgement of light>T:hammer of wrath");
+    }
+
+    void lowMana()
+    {
+        tickWithLowMana(10);
+
+        assertActions(">T:judgement of wisdom");
+    }
+
+	void interruptSpells()
+	{
+		tickWithTargetIsCastingNonMeleeSpell();
+
+		assertActions(">T:hammer of justice");
+	}
+
+    void cureDisease()
+    {
+        cureKind(DISPEL_DISEASE);
+		assertActions(">S:cleanse>P:cleanse disease on party>S:purify>P:purify disease on party");
+    }
+
+	void curePoison()
+	{
+		cureKind(DISPEL_POISON);
+		assertActions(">S:cleanse>P:cleanse poison on party>S:purify>P:purify poison on party");
+	}
+
+	void cureMagic()
+	{
+        cureKind(DISPEL_MAGIC);
+        assertActions(">S:cleanse>P:cleanse magic on party>T:judgement of light>T:melee");
+	}
+
+    void cureKind(DispelType type)
+    {
+        spellAvailable("cleanse");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("cleanse");
+        tickWithPartyAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithAuraToDispel(type);
+
+        spellAvailable("purify");
+        tickWithPartyAuraToDispel(type);
+    }
+
+	void resistances()
+	{
+		engine->addStrategy("rshadow");
+		tick();
+
+		engine->addStrategy("rfrost");
+		tick();
+
+		engine->addStrategy("rfire");
+		tick();
+
+		assertActions(">S:shadow resistance aura>S:frost resistance aura>S:fire resistance aura");
+	}
+
+    void combatIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("dps", "tank", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: tank");
+    }
+
+    void buffIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("bhealth", "bmana", "bdps", "barmor", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: barmor");
+    }
+
+    void resistanceIncompatibles()
+    {
+        engine->removeStrategy("barmor");
+        engine->removeStrategy("tank");
+        engine->addStrategies("rshadow", "rfrost", "rfire", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: rfire");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("hammer of justice");
+
+        assertActions(">H:hammer of justice on enemy healer");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankPaladinTestCase );
diff --git a/src/test/TankWarlockTestCase.cpp b/src/test/TankWarlockTestCase.cpp
new file mode 100644
index 0000000..4136096
--- /dev/null
+++ b/src/test/TankWarlockTestCase.cpp
@@ -0,0 +1,51 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankWarlockTestCase : public EngineTestBase
+{
+  CPPUNIT_TEST_SUITE( TankWarlockTestCase );
+      CPPUNIT_TEST( summonPet );
+      CPPUNIT_TEST( cc );
+      CPPUNIT_TEST( incompatibles );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "tank", NULL);
+    }
+
+protected:
+
+    void summonPet()
+    {
+        itemAvailable("soul shard", 2);
+        tickWithNoPet();
+        tickWithNoPet();
+
+		assertActions(">S:summon felguard>S:summon voidwalker");
+    }
+
+    void cc()
+    {
+        tickWithCcTarget("banish");
+        tickWithCcTarget("fear");
+
+        assertActions(">Cc:banish on cc>Cc:fear on cc");
+    }
+
+    void incompatibles()
+    {
+        engine->addStrategies("tank", "dps", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: dps");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankWarlockTestCase );
diff --git a/src/test/TankWarriorTestCase.cpp b/src/test/TankWarriorTestCase.cpp
new file mode 100644
index 0000000..29e7d62
--- /dev/null
+++ b/src/test/TankWarriorTestCase.cpp
@@ -0,0 +1,168 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class TankWarriorTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( TankWarriorTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST( startMeleeCombat );
+    CPPUNIT_TEST( melee );
+    CPPUNIT_TEST( warriorMustHoldAggro );
+    CPPUNIT_TEST( aoe );
+    CPPUNIT_TEST( healing );
+	CPPUNIT_TEST( snare );
+    CPPUNIT_TEST( interruptSpells );
+    CPPUNIT_TEST( incompatibles );
+    CPPUNIT_TEST( interrupt_enemy_healer );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarriorAiObjectContext(ai), "tank", NULL);
+
+        // this buff is combat-only, so skip for most test cases
+        addAura("battle shout");
+        set<uint8>("rage", "self target", 20);
+        set<float>("distance", "current target", ATTACK_DISTANCE - 1);
+    }
+
+protected:
+    void interruptSpells()
+    {
+		tickWithTargetIsCastingNonMeleeSpell();
+
+        tick(); // rend
+
+        assertActions(">T:shield bash>S:defensive stance");
+    }
+
+    void healing()
+    {
+        tickWithLowHealth(50); // defensive stance
+        tickWithLowHealth(50); // shield wall
+        tickWithLowHealth(50); // shield block
+
+		tickWithLowHealth(4);
+		tickWithLowHealth(4);
+
+		assertActions(">S:defensive stance>T:shield wall>S:shield block>S:last stand>T:intimidating shout");
+    }
+
+    void buff()
+    {
+        set<uint8>("rage", "self target", 0);
+        removeAura("battle shout");
+
+        tickInSpellRange();
+        addAura("battle shout");
+
+        tickInSpellRange();
+
+		assertActions(">S:battle shout>S:bloodrage");
+
+    }
+
+    void aoe()
+    {
+        addAura("defensive stance");
+
+		tickWithAttackerCount(3);
+		tickWithAttackerCount(3);
+
+		spellAvailable("cleave");
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+		tickWithAttackerCount(2);
+
+        assertActions(">T:shockwave>T:thunder clap>T:demoralizing shout>T:cleave>T:devastate");
+    }
+
+    void warriorMustHoldAggro()
+    {
+        addAura("defensive stance");
+
+		tickWithNoAggro();
+		tickWithNoAggro();
+
+		assertActions(">T:taunt>T:mocking blow");
+    }
+
+    void startMeleeCombat()
+    {
+        tickOutOfMeleeRange();
+        tickWithRage(0);
+        tickInMeleeRange();
+        tick();
+        tick();
+        tick();
+
+        assertActions(">T:reach melee>S:bloodrage>S:defensive stance>T:devastate>T:revenge>T:rend");
+    }
+
+    void melee()
+    {
+        addAura("defensive stance");
+        tickInMeleeRange();
+        tick();
+        tick();
+        tick();
+        tick();
+        spellAvailable("rend");
+        addTargetAura("rend");
+
+        tickWithRage(31);
+
+        set<uint8>("rage", "self target", 41);
+        tick();
+
+        tickWithSpellAvailable("heroic strike");
+
+        addAura("sword and board");
+		tickWithSpellAvailable("devastate");
+        tickWithSpellAvailable("shield slam");
+
+		assertActions(">T:devastate>T:revenge>T:rend>T:disarm>T:sunder armor>T:melee>T:shield slam>T:heroic strike>T:melee>T:shield slam");
+    }
+
+    void revengeIfDodge()
+    {
+        tick(); // melee
+        spellAvailable("revenge");
+        tick(); // defensive stance
+        tick(); // revenge
+
+		assertActions(">T:melee>S:defensive stance>T:revenge");
+    }
+
+	void snare()
+	{
+		tick();
+		tickWithTargetIsMoving();
+
+		assertActions(">S:defensive stance>T:concussion blow");
+	}
+
+
+    void incompatibles()
+    {
+        engine->addStrategies("tank", "dps", NULL);
+
+        CPPUNIT_ASSERT(engine->ListStrategies() == "Strategies: dps");
+    }
+
+    void interrupt_enemy_healer()
+    {
+        tickWithEnemyHealerIsCastingInterruptableSpell("shield bash");
+
+        assertActions(">H:shield bash on enemy healer");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( TankWarriorTestCase );
diff --git a/src/test/ValueTestCase.cpp b/src/test/ValueTestCase.cpp
new file mode 100644
index 0000000..fd959d6
--- /dev/null
+++ b/src/test/ValueTestCase.cpp
@@ -0,0 +1,121 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class TestValue : public CalculatedValue<int>
+{
+public:
+    TestValue(PlayerbotAI* ai) : CalculatedValue<int>(ai, "name", 2), increment(0) {}
+    virtual int Calculate() { return ++increment; }
+
+private:
+    int increment;
+};
+
+class TestManualValue : public ManualSetValue<int>
+{
+public:
+    TestManualValue(PlayerbotAI* ai) : ManualSetValue<int>(ai, 0, "name") {}
+};
+
+class TestValueContext : public NamedObjectContext<UntypedValue>
+{
+public:
+    TestValueContext()
+    {
+        creators["value"] = &TestValueContext::value;
+        creators["manual value"] = &TestValueContext::manual_value;
+    }
+
+private:
+    static UntypedValue* value(PlayerbotAI* ai) { return new TestValue(ai); }
+    static UntypedValue* manual_value(PlayerbotAI* ai) { return new TestManualValue(ai); }
+};
+
+class TestValueAiObjectContext : public AiObjectContext
+{
+public:
+    TestValueAiObjectContext(PlayerbotAI* const ai) : AiObjectContext(ai)
+    {
+        valueContexts.Add(new TestValueContext());
+    }
+};
+
+
+class ValueTestCase : public CPPUNIT_NS::TestFixture
+{
+  CPPUNIT_TEST_SUITE( ValueTestCase );
+      CPPUNIT_TEST( empty );
+      CPPUNIT_TEST( calculate );
+      CPPUNIT_TEST( manual );
+      CPPUNIT_TEST( fromContext );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+
+public:
+	void setUp()
+	{
+	}
+
+protected:
+    void empty()
+	{
+        MockPlayerbotAIBase ai;
+        TestValue value(&ai);
+        CPPUNIT_ASSERT(value == 1);
+	}
+
+    void calculate()
+    {
+        MockPlayerbotAIBase ai;
+        TestValue value(&ai);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 1);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 1);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 2);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 2);
+    }
+
+    void manual()
+    {
+        MockPlayerbotAIBase ai;
+        TestManualValue value(&ai);
+        CPPUNIT_ASSERT(value == 0);
+
+        value.Set(3);
+        CPPUNIT_ASSERT(value == 3);
+
+        value.Update();
+        CPPUNIT_ASSERT(value == 3);
+    }
+
+    void fromContext()
+    {
+        MockPlayerbotAIBase ai;
+        TestValueAiObjectContext context(&ai);
+        Value<int> *value = context.GetValue<int>("manual value");
+        CPPUNIT_ASSERT(value);
+
+        value->Set(3);
+        CPPUNIT_ASSERT(3 == value->Get());
+
+        value = context.GetValue<int>("value");
+        context.Update();
+        context.Update();
+        CPPUNIT_ASSERT(1 == value->Get());
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ValueTestCase );
diff --git a/src/test/WarlockNonCombatTestCase.cpp b/src/test/WarlockNonCombatTestCase.cpp
new file mode 100644
index 0000000..eb37021
--- /dev/null
+++ b/src/test/WarlockNonCombatTestCase.cpp
@@ -0,0 +1,50 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h"
+
+using namespace ai;
+
+
+class WarlockNonCombatTestCase : public EngineTestBase
+{
+    CPPUNIT_TEST_SUITE( WarlockNonCombatTestCase );
+    CPPUNIT_TEST( buff );
+    CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+        EngineTestBase::setUp();
+        setupEngine(new WarlockAiObjectContext(ai), "nc", NULL);
+    }
+
+protected:
+    void buff()
+    {
+        tick();
+        tick();
+        tick();
+        addAura("fel armor");
+
+		itemAvailable("soul shard", 2);
+		tick();
+		itemAvailable("healthstone", 1);
+
+		tick();
+		itemAvailable("firestone", 1);
+
+		tick();
+		itemAvailable("spellstone", 1);
+
+        tick();
+        addAura("spellstone");
+
+        tickWithNoPet();
+
+        assertActions(">S:fel armor>S:demon armor>S:demon skin>S:create healthstone>S:create firestone>S:create spellstone>S:spellstone>S:summon imp");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarlockNonCombatTestCase );
diff --git a/src/test/WarrirorNonCombatTestCase.cpp b/src/test/WarrirorNonCombatTestCase.cpp
new file mode 100644
index 0000000..b73ad56
--- /dev/null
+++ b/src/test/WarrirorNonCombatTestCase.cpp
@@ -0,0 +1,40 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "../../plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h"
+
+using namespace ai;
+
+
+class WarriorNonCombatTestCase : public CPPUNIT_NS::TestFixture
+{
+    CPPUNIT_TEST_SUITE( WarriorNonCombatTestCase );
+    //CPPUNIT_TEST( buff );
+    CPPUNIT_TEST_SUITE_END();
+
+protected:
+    MockPlayerbotAIBase *ai;
+
+public:
+    void setUp()
+    {
+    }
+
+protected:
+    void buff()
+    {
+        ai = new MockPlayerbotAIBase();
+
+        Engine engine(ai, new WarriorAiObjectContext(ai));
+        engine.addStrategy("nc");
+        engine.Init();
+
+        engine.DoNextAction(NULL);
+        engine.DoNextAction(NULL);
+
+        std::cout << ai->buffer;
+		CPPUNIT_ASSERT(ai->buffer == ">S:defensive stance");
+    }
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarriorNonCombatTestCase );
diff --git a/src/test/WorldPacketHandlerTestCase.cpp b/src/test/WorldPacketHandlerTestCase.cpp
new file mode 100644
index 0000000..715cace
--- /dev/null
+++ b/src/test/WorldPacketHandlerTestCase.cpp
@@ -0,0 +1,278 @@
+#include "pch.h"
+
+#include "aitest.h"
+#include "MockAiObjectContext.h"
+#include "MockedAiObjectContextTestCase.h"
+#include "../../plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+
+class WorldPacketHandlerTestCase : public MockedAiObjectContextTestCase
+{
+  CPPUNIT_TEST_SUITE( WorldPacketHandlerTestCase );
+      CPPUNIT_TEST( groupInvite );
+      CPPUNIT_TEST( groupSetLeader );
+      CPPUNIT_TEST( notEnoughMoney );
+      CPPUNIT_TEST( notEnoughReputation );
+      CPPUNIT_TEST( gossip_hello );
+      CPPUNIT_TEST( useGameObject );
+      CPPUNIT_TEST( roll );
+      CPPUNIT_TEST( revive );
+      CPPUNIT_TEST( resurrect_request );
+      CPPUNIT_TEST( area_trigger );
+      CPPUNIT_TEST( mount );
+      CPPUNIT_TEST( taxi );
+      CPPUNIT_TEST( cannot_equip );
+      CPPUNIT_TEST( trade_status );
+      CPPUNIT_TEST( loot );
+      CPPUNIT_TEST( item_push_result );
+      CPPUNIT_TEST( quest_objective_completed );
+      CPPUNIT_TEST( party_command );
+      CPPUNIT_TEST( taxi_done );
+      CPPUNIT_TEST( ready_check );
+      CPPUNIT_TEST( uninvite );
+      CPPUNIT_TEST( lfg );
+      CPPUNIT_TEST( lfg_leave );
+      CPPUNIT_TEST( security_check );
+      CPPUNIT_TEST( guild_accept );
+      CPPUNIT_TEST( lfg_teleport );
+  CPPUNIT_TEST_SUITE_END();
+
+public:
+    void setUp()
+    {
+		EngineTestBase::setUp();
+		setupEngine(context = new MockAiObjectContext(ai, new AiObjectContext(ai), &ai->buffer), "default", NULL);
+    }
+
+protected:
+    void groupInvite()
+    {
+        trigger("group invite");
+        tick();
+
+        assertActions(">S:accept invitation");
+    }
+    void groupSetLeader()
+    {
+        trigger("group set leader");
+        tick();
+
+        assertActions(">S:leader");
+    }
+    void notEnoughMoney()
+    {
+        trigger("not enough money");
+        tick();
+        assertActions(">S:tell not enough money");
+    }
+    void notEnoughReputation()
+    {
+        trigger("not enough reputation");
+        tick();
+        assertActions(">S:tell not enough reputation");
+    }
+
+    void useGameObject()
+    {
+        trigger("use game object");
+        tick();
+        tick();
+
+        assertActions(">S:add loot>S:use meeting stone");
+    }
+
+    void gossip_hello()
+    {
+        trigger("gossip hello");
+        tick();
+
+        assertActions(">S:trainer");
+    }
+
+    void roll()
+    {
+        trigger("loot roll");
+        tick();
+
+        assertActions(">S:loot roll");
+    }
+
+    void revive()
+    {
+        engine->addStrategy("dead");
+
+        trigger("dead");
+        tick();
+
+        assertActions(">S:revive from corpse");
+    }
+
+    void resurrect_request()
+    {
+        engine->addStrategy("dead");
+
+        trigger("resurrect request");
+        tick();
+
+        assertActions(">S:accept resurrect");
+    }
+
+    void area_trigger()
+    {
+        trigger("area trigger");
+        tick();
+        trigger("within area trigger");
+        tick();
+
+        assertActions(">S:reach area trigger>S:area trigger");
+    }
+
+    void mount()
+    {
+        trigger("check mount state");
+        tick();
+
+        assertActions(">S:check mount state");
+    }
+
+    void taxi()
+    {
+        trigger("activate taxi");
+        tick();
+        tick();
+
+        assertActions(">S:remember taxi>S:taxi");
+    }
+    void cannot_equip()
+    {
+        trigger("cannot equip");
+        tick();
+        assertActions(">S:tell cannot equip");
+    }
+
+    void trade_status()
+    {
+        trigger("trade status");
+        tick();
+        assertActions(">S:accept trade");
+    }
+
+    void loot()
+    {
+        trigger("loot response");
+        tick();
+        assertActions(">S:store loot");
+    }
+
+    void quest_objective_completed()
+    {
+        trigger("quest objective completed");
+        tick();
+
+        assertActions(">S:quest objective completed");
+    }
+
+    void item_push_result()
+    {
+        trigger("item push result");
+        tick();
+
+        assertActions(">S:query item usage");
+    }
+
+    void party_command()
+    {
+        trigger("party command");
+        tick();
+
+        assertActions(">S:party command");
+    }
+
+    void taxi_done()
+    {
+        trigger("taxi done");
+        tick();
+
+        assertActions(">S:taxi");
+    }
+
+    void ready_check()
+    {
+        trigger("ready check");
+        tick();
+
+        assertActions(">S:ready check");
+    }
+
+    void ready_check_finished()
+    {
+        trigger("ready check finished");
+        tick();
+
+        assertActions(">S:finish ready check");
+    }
+
+    void uninvite()
+    {
+        trigger("uninvite");
+        tick();
+
+        assertActions(">S:uninvite");
+    }
+
+    void lfg()
+    {
+        engine->addStrategy("lfg");
+        trigger("no possible targets");
+        tick();
+
+        trigger("lfg role check");
+        tick();
+
+        trigger("lfg proposal");
+        tick();
+
+        trigger("lfg proposal active");
+        tick();
+
+        assertActions(">S:lfg join>S:lfg role check>S:lfg accept>S:lfg accept");
+    }
+
+    void lfg_leave()
+    {
+        trigger("seldom");
+        tick();
+
+        assertActions(">S:lfg leave");
+    }
+
+    void security_check()
+    {
+        trigger("often");
+        tick();
+        tick();
+
+        assertActions(">S:security check>S:check mail");
+    }
+
+    void guild_accept()
+    {
+        trigger("guild invite");
+        tick();
+
+        assertActions(">S:guild accept");
+    }
+
+    void lfg_teleport()
+    {
+        trigger("lfg teleport");
+        tick();
+
+        assertActions(">S:lfg teleport");
+    }
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WorldPacketHandlerTestCase );
diff --git a/src/test/aitest.h b/src/test/aitest.h
new file mode 100644
index 0000000..ee45191
--- /dev/null
+++ b/src/test/aitest.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../../plugins/playerbot/PlayerbotAIAware.h"
+#include "../../plugins/playerbot/PlayerbotMgr.h"
+#include "../../plugins/playerbot/ChatHelper.h"
+#include "../../plugins/playerbot/PlayerbotAI.h"
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "EngineTestBase.h"
diff --git a/src/test/cppunit/AdditionalMessage.cpp b/src/test/cppunit/AdditionalMessage.cpp
new file mode 100644
index 0000000..9f3da13
--- /dev/null
+++ b/src/test/cppunit/AdditionalMessage.cpp
@@ -0,0 +1,41 @@
+#include <cppunit/AdditionalMessage.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+AdditionalMessage::AdditionalMessage()
+{
+}
+
+
+AdditionalMessage::AdditionalMessage( const std::string &detail1 )
+{
+  if ( !detail1.empty() )
+    addDetail( detail1 );
+}
+
+
+AdditionalMessage::AdditionalMessage( const char *detail1 )
+{
+  if ( detail1  &&  !std::string( detail1 ).empty() )
+    addDetail( std::string(detail1) );
+}
+
+
+AdditionalMessage::AdditionalMessage( const Message &other )
+    : SuperClass( other )
+{
+}
+
+
+AdditionalMessage &
+AdditionalMessage::operator =( const Message &other )
+{
+  SuperClass::operator =( other );
+
+  return *this;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/AdditionalMessage.h b/src/test/cppunit/AdditionalMessage.h
new file mode 100644
index 0000000..1b925fc
--- /dev/null
+++ b/src/test/cppunit/AdditionalMessage.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_ADDITIONALMESSAGE_H
+#define CPPUNIT_ADDITIONALMESSAGE_H
+
+#include <cppunit/Message.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief An additional Message for assertions.
+ * \ingroup CreatingNewAssertions
+ *
+ * Provides a implicit constructor that takes a single string. This allow this
+ * class to be used as the message arguments in macros.
+ *
+ * The constructed object is either a Message with a single detail string if
+ * a string was passed to the macro, or a copy of the Message passed to the macro.
+ *
+ * Here is an example of usage:
+ * \code
+ *
+ *   void checkStringEquals( const std::string &expected,
+ *                          const std::string &actual,
+ *                           const CppUnit::SourceLine &sourceLine,
+ *                           const CppUnit::AdditionalMessage &message );
+ *
+ *   #define XTLUT_ASSERT_STRING_EQUAL_MESSAGE( expected, actual, message )  \
+ *     ::XtlUt::Impl::checkStringEquals( ::Xtl::toString(expected),        \
+ *                                       ::Xtl::toString(actual),          \
+ *                                       CPPUNIT_SOURCELINE(),             \
+ *                                       message )
+ * \endcode
+ *
+ * In the previous example, the user can specify a simple string for \a message,
+ * or a complex Message object.
+ *
+ * \see Message
+ */
+class CPPUNIT_API AdditionalMessage : public Message
+{
+public:
+  typedef Message SuperClass;
+
+  /// Constructs an empty Message.
+  AdditionalMessage();
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const std::string &detail1 );
+
+  /*! \brief Constructs a Message with the specified detail string.
+   * \param detail1 Detail string of the message. If empty, then it is not added.
+   */
+  AdditionalMessage( const char *detail1 );
+
+  /*! \brief Constructs a copy of the specified message.
+   * \param other Message to copy.
+   */
+  AdditionalMessage( const Message &other );
+
+  /*! \brief Assignment operator.
+   * \param other Message to copy.
+   * \return Reference on this object.
+   */
+  AdditionalMessage &operator =( const Message &other );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+
+
+#endif  // CPPUNIT_ADDITIONALMESSAGE_H
diff --git a/src/test/cppunit/Asserter.cpp b/src/test/cppunit/Asserter.cpp
new file mode 100644
index 0000000..24c78da
--- /dev/null
+++ b/src/test/cppunit/Asserter.cpp
@@ -0,0 +1,101 @@
+#include <cppunit/Asserter.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Message.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+void
+Asserter::fail( std::string message,
+                const SourceLine &sourceLine )
+{
+  fail( Message( "assertion failed", message ), sourceLine );
+}
+
+
+void
+Asserter::fail( const Message &message,
+                const SourceLine &sourceLine )
+{
+  throw Exception( message, sourceLine );
+}
+
+
+void
+Asserter::failIf( bool shouldFail,
+                  const Message &message,
+                  const SourceLine &sourceLine )
+{
+  if ( shouldFail )
+    fail( message, sourceLine );
+}
+
+
+void
+Asserter::failIf( bool shouldFail,
+                  std::string message,
+                  const SourceLine &sourceLine )
+{
+  failIf( shouldFail, Message( "assertion failed", message ), sourceLine );
+}
+
+
+std::string
+Asserter::makeExpected( const std::string &expectedValue )
+{
+  return "Expected: " + expectedValue;
+}
+
+
+std::string
+Asserter::makeActual( const std::string &actualValue )
+{
+  return "Actual  : " + actualValue;
+}
+
+
+Message
+Asserter::makeNotEqualMessage( const std::string &expectedValue,
+                               const std::string &actualValue,
+                               const AdditionalMessage &additionalMessage,
+                               const std::string &shortDescription )
+{
+  Message message( shortDescription,
+                   makeExpected( expectedValue ),
+                   makeActual( actualValue ) );
+  message.addDetail( additionalMessage );
+
+  return message;
+}
+
+
+void
+Asserter::failNotEqual( std::string expected,
+                        std::string actual,
+                        const SourceLine &sourceLine,
+                        const AdditionalMessage &additionalMessage,
+                        std::string shortDescription )
+{
+  fail( makeNotEqualMessage( expected,
+                             actual,
+                             additionalMessage,
+                             shortDescription ),
+        sourceLine );
+}
+
+
+void
+Asserter::failNotEqualIf( bool shouldFail,
+                          std::string expected,
+                          std::string actual,
+                          const SourceLine &sourceLine,
+                          const AdditionalMessage &additionalMessage,
+                          std::string shortDescription )
+{
+  if ( shouldFail )
+    failNotEqual( expected, actual, sourceLine, additionalMessage, shortDescription );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Asserter.h b/src/test/cppunit/Asserter.h
new file mode 100644
index 0000000..684739f
--- /dev/null
+++ b/src/test/cppunit/Asserter.h
@@ -0,0 +1,143 @@
+#ifndef CPPUNIT_ASSERTER_H
+#define CPPUNIT_ASSERTER_H
+
+#include <cppunit/AdditionalMessage.h>
+#include <cppunit/SourceLine.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Message;
+
+
+/*! \brief A set of functions to help writing assertion macros.
+ * \ingroup CreatingNewAssertions
+ *
+ * Here is an example of assertion, a simplified version of the
+ * actual assertion implemented in examples/cppunittest/XmlUniformiser.h:
+ * \code
+ * #include <cppunit/SourceLine.h>
+ * #include <cppunit/TestAssert.h>
+ *
+ * void
+ * checkXmlEqual( std::string expectedXml,
+ *                std::string actualXml,
+ *                CppUnit::SourceLine sourceLine )
+ * {
+ *   std::string expected = XmlUniformiser( expectedXml ).stripped();
+ *   std::string actual = XmlUniformiser( actualXml ).stripped();
+ *
+ *   if ( expected == actual )
+ *     return;
+ *
+ *   ::CppUnit::Asserter::failNotEqual( expected,
+ *                                      actual,
+ *                                      sourceLine );
+ * }
+ *
+ * /// Asserts that two XML strings are equivalent.
+ * #define CPPUNITTEST_ASSERT_XML_EQUAL( expected, actual ) \
+ *     checkXmlEqual( expected, actual,                     \
+ *                    CPPUNIT_SOURCELINE() )
+ * \endcode
+ */
+struct Asserter
+{
+  /*! \brief Throws a Exception with the specified message and location.
+   */
+  static void CPPUNIT_API fail( const Message &message,
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use fail( Message, SourceLine ) instead.
+   */
+  static void CPPUNIT_API fail( std::string message,
+                                const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail,
+                                  const Message &message,
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Throws a Exception with the specified message and location.
+   * \deprecated Use failIf( bool, Message, SourceLine ) instead.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param message Message explaining the assertion failiure.
+   * \param sourceLine Location of the assertion.
+   */
+  static void CPPUNIT_API failIf( bool shouldFail,
+                                  std::string message,
+                                  const SourceLine &sourceLine = SourceLine() );
+
+  /*! \brief Returns a expected value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom
+   * assertions.
+   *
+   * \param expectedValue String that represents the expected value.
+   * \return \a expectedValue prefixed with "Expected: ".
+   * \see makeActual().
+   */
+  static std::string CPPUNIT_API makeExpected( const std::string &expectedValue );
+
+  /*! \brief Returns an actual value string for a message.
+   * Typically used to create 'not equal' message, or to check that a message
+   * contains the expected content when writing unit tests for your custom
+   * assertions.
+   *
+   * \param actualValue String that represents the actual value.
+   * \return \a actualValue prefixed with "Actual  : ".
+   * \see makeExpected().
+   */
+  static std::string CPPUNIT_API makeActual( const std::string &actualValue );
+
+  static Message CPPUNIT_API makeNotEqualMessage( const std::string &expectedValue,
+                                                  const std::string &actualValue,
+                                                  const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                                  const std::string &shortDescription = "equality assertion failed");
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          what are the differences between the expected and actual value.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqual( std::string expected,
+                                        std::string actual,
+                                        const SourceLine &sourceLine,
+                                        const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                        std::string shortDescription = "equality assertion failed" );
+
+  /*! \brief Throws an Exception with the specified message and location.
+   * \param shouldFail if \c true then the exception is thrown. Otherwise
+   *                   nothing happen.
+   * \param expected Text describing the expected value.
+   * \param actual Text describing the actual value.
+   * \param sourceLine Location of the assertion.
+   * \param additionalMessage Additional message. Usually used to report
+   *                          where the "difference" is located.
+   * \param shortDescription Short description for the failure message.
+   */
+  static void CPPUNIT_API failNotEqualIf( bool shouldFail,
+                                          std::string expected,
+                                          std::string actual,
+                                          const SourceLine &sourceLine,
+                                          const AdditionalMessage &additionalMessage = AdditionalMessage(),
+                                          std::string shortDescription = "equality assertion failed" );
+
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_ASSERTER_H
diff --git a/src/test/cppunit/BeOsDynamicLibraryManager.cpp b/src/test/cppunit/BeOsDynamicLibraryManager.cpp
new file mode 100644
index 0000000..5373082
--- /dev/null
+++ b/src/test/cppunit/BeOsDynamicLibraryManager.cpp
@@ -0,0 +1,49 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_BEOS_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <kernel/image.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return (LibraryHandle)::load_add_on( libraryName.c_str() );
+}
+
+
+void
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::unload_add_on( (image_id)m_libraryHandle );
+}
+
+
+DynamicLibraryManager::Symbol
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  void *symbolPointer;
+  if ( ::get_image_symbol( (image_id)m_libraryHandle,
+                           symbol.c_str(),
+                           B_SYMBOL_TYPE_TEXT,
+                           &symbolPointer ) == B_OK )
+    return symnolPointer;
+  return NULL;
+}
+
+
+std::string
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_BEOS_DLL_LOADER)
diff --git a/src/test/cppunit/BriefTestProgressListener.cpp b/src/test/cppunit/BriefTestProgressListener.cpp
new file mode 100644
index 0000000..9e72694
--- /dev/null
+++ b/src/test/cppunit/BriefTestProgressListener.cpp
@@ -0,0 +1,49 @@
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+BriefTestProgressListener::BriefTestProgressListener()
+    : m_lastTestFailed( false )
+{
+}
+
+
+BriefTestProgressListener::~BriefTestProgressListener()
+{
+}
+
+
+void
+BriefTestProgressListener::startTest( Test *test )
+{
+  stdCOut() << test->getName();
+  stdCOut().flush();
+
+  m_lastTestFailed = false;
+}
+
+
+void
+BriefTestProgressListener::addFailure( const TestFailure &failure )
+{
+  stdCOut() << " : " << (failure.isError() ? "error" : "assertion");
+  m_lastTestFailed  = true;
+}
+
+
+void
+BriefTestProgressListener::endTest( Test *test )
+{
+  if ( !m_lastTestFailed )
+    stdCOut()  <<  " : OK";
+  stdCOut() << "\n";
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/BriefTestProgressListener.h b/src/test/cppunit/BriefTestProgressListener.h
new file mode 100644
index 0000000..137ca44
--- /dev/null
+++ b/src/test/cppunit/BriefTestProgressListener.h
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+#define CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that prints the name of each test before running it.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API BriefTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a BriefTestProgressListener object.
+   */
+  BriefTestProgressListener();
+
+  /// Destructor.
+  virtual ~BriefTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  BriefTestProgressListener( const BriefTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const BriefTestProgressListener &copy );
+
+private:
+  bool m_lastTestFailed;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_BRIEFTESTPROGRESSLISTENER_H
diff --git a/src/test/cppunit/CompilerOutputter.cpp b/src/test/cppunit/CompilerOutputter.cpp
new file mode 100644
index 0000000..990d231
--- /dev/null
+++ b/src/test/cppunit/CompilerOutputter.cpp
@@ -0,0 +1,216 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/Exception.h>
+#include <cppunit/SourceLine.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/CompilerOutputter.h>
+#include <algorithm>
+#include <cppunit/tools/StringTools.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+CompilerOutputter::CompilerOutputter( TestResultCollector *result,
+                                      OStream &stream,
+                                      const std::string &locationFormat )
+    : m_result( result )
+    , m_stream( stream )
+    , m_locationFormat( locationFormat )
+    , m_wrapColumn( CPPUNIT_WRAP_COLUMN )
+{
+}
+
+
+CompilerOutputter::~CompilerOutputter()
+{
+}
+
+
+void
+CompilerOutputter::setLocationFormat( const std::string &locationFormat )
+{
+  m_locationFormat = locationFormat;
+}
+
+
+CompilerOutputter *
+CompilerOutputter::defaultOutputter( TestResultCollector *result,
+                                     OStream &stream )
+{
+  return new CompilerOutputter( result, stream );
+}
+
+
+void
+CompilerOutputter::write()
+{
+  if ( m_result->wasSuccessful() )
+    printSuccess();
+  else
+    printFailureReport();
+}
+
+
+void
+CompilerOutputter::printSuccess()
+{
+  m_stream  << "OK (" << m_result->runTests()  << ")\n";
+}
+
+
+void
+CompilerOutputter::printFailureReport()
+{
+  printFailuresList();
+  printStatistics();
+}
+
+
+void
+CompilerOutputter::printFailuresList()
+{
+  for ( int index =0; index < m_result->testFailuresTotal(); ++index)
+  {
+    printFailureDetail( m_result->failures()[ index ] );
+  }
+}
+
+
+void
+CompilerOutputter::printFailureDetail( TestFailure *failure )
+{
+  printFailureLocation( failure->sourceLine() );
+  printFailureType( failure );
+  printFailedTestName( failure );
+  printFailureMessage( failure );
+}
+
+
+void
+CompilerOutputter::printFailureLocation( SourceLine sourceLine )
+{
+  if ( !sourceLine.isValid() )
+  {
+    m_stream  <<  "##Failure Location unknown## : ";
+    return;
+  }
+
+  std::string location;
+  for ( unsigned int index = 0; index < m_locationFormat.length(); ++index )
+  {
+    char c = m_locationFormat[ index ];
+    if ( c == '%'  &&  ( index+1 < m_locationFormat.length() ) )
+    {
+      char command = m_locationFormat[index+1];
+      if ( processLocationFormatCommand( command, sourceLine ) )
+      {
+        ++index;
+        continue;
+      }
+    }
+
+    m_stream  << c;
+  }
+}
+
+
+bool
+CompilerOutputter::processLocationFormatCommand( char command,
+                                                 const SourceLine &sourceLine )
+{
+  switch ( command )
+  {
+  case 'p':
+    m_stream  <<  sourceLine.fileName();
+    return true;
+  case 'l':
+    m_stream  <<  sourceLine.lineNumber();
+    return true;
+  case 'f':
+    m_stream  <<  extractBaseName( sourceLine.fileName() );
+    return true;
+  }
+
+  return false;
+}
+
+
+std::string
+CompilerOutputter::extractBaseName( const std::string &fileName ) const
+{
+  int indexLastDirectorySeparator = fileName.find_last_of( '/' );
+
+  if ( indexLastDirectorySeparator < 0 )
+    indexLastDirectorySeparator = fileName.find_last_of( '\\' );
+
+  if ( indexLastDirectorySeparator < 0 )
+    return fileName;
+
+  return fileName.substr( indexLastDirectorySeparator +1 );
+}
+
+
+void
+CompilerOutputter::printFailureType( TestFailure *failure )
+{
+  m_stream  <<  (failure->isError() ? "Error" : "Assertion");
+}
+
+
+void
+CompilerOutputter::printFailedTestName( TestFailure *failure )
+{
+  m_stream  <<  "\nTest name: "  <<  failure->failedTestName();
+}
+
+
+void
+CompilerOutputter::printFailureMessage( TestFailure *failure )
+{
+  m_stream  <<  "\n";
+  Exception *thrownException = failure->thrownException();
+  m_stream  << thrownException->message().shortDescription()  <<  "\n";
+
+  std::string message = thrownException->message().details();
+  if ( m_wrapColumn > 0 )
+    message = StringTools::wrap( message, m_wrapColumn );
+
+  m_stream  <<  message  <<  "\n";
+}
+
+
+void
+CompilerOutputter::printStatistics()
+{
+  m_stream  <<  "Failures !!!\n";
+  m_stream  <<  "Run: "  <<  m_result->runTests()  << "   "
+            <<  "Failure total: "  <<  m_result->testFailuresTotal()  << "   "
+            <<  "Failures: "  <<  m_result->testFailures()  << "   "
+            <<  "Errors: "  <<  m_result->testErrors()
+            <<  "\n";
+}
+
+
+void
+CompilerOutputter::setWrapColumn( int wrapColumn )
+{
+  m_wrapColumn = wrapColumn;
+}
+
+
+void
+CompilerOutputter::setNoWrap()
+{
+  m_wrapColumn = 0;
+}
+
+
+int
+CompilerOutputter::wrapColumn() const
+{
+  return m_wrapColumn;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/CompilerOutputter.h b/src/test/cppunit/CompilerOutputter.h
new file mode 100644
index 0000000..599c030
--- /dev/null
+++ b/src/test/cppunit/CompilerOutputter.h
@@ -0,0 +1,146 @@
+#ifndef CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+#define CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+class TestFailure;
+class TestResultCollector;
+
+/*!
+ * \brief Outputs a TestResultCollector in a compiler compatible format.
+ * \ingroup WritingTestResult
+ *
+ * Printing the test results in a compiler compatible format (assertion
+ * location has the same format as compiler error), allow you to use your
+ * IDE to jump to the assertion failure. Location format can be customized (see
+ * setLocationFormat() ).
+ *
+ * For example, when running the test in a post-build with VC++, if an assertion
+ * fails, you can jump to the assertion by pressing F4 (jump to next error).
+ *
+ * Heres is an example of usage (from examples/cppunittest/CppUnitTestMain.cpp):
+ * \code
+ * int main( int argc, char* argv[] ) {
+ *   // if command line contains "-selftest" then this is the post build check
+ *   // => the output must be in the compiler error format.
+ *   bool selfTest = (argc > 1)  &&
+ *                   (std::string("-selftest") == argv[1]);
+ *
+ *   CppUnit::TextUi::TestRunner runner;
+ *   runner.addTest( CppUnitTest::suite() );   // Add the top suite to the test runner
+ *
+ *  if ( selfTest )
+ *   { // Change the default outputter to a compiler error format outputter
+ *     // The test runner owns the new outputter.
+ *     runner.setOutputter( new CppUnit::CompilerOutputter( &runner.result(),
+ *                                                          std::cerr ) );
+ *   }
+ *
+ *  // Run the test and don't wait a key if post build check.
+ *   bool wasSuccessful = runner.run( "", !selfTest );
+ *
+ *   // Return error code 1 if the one of test failed.
+ *   return wasSuccessful ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API CompilerOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a CompilerOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output test result.
+   * \param locationFormat Error location format used by your compiler. Default
+   *                       to \c CPPUNIT_COMPILER_LOCATION_FORMAT which is defined
+   *                       in the configuration file. See setLocationFormat() for detail.
+   * \see setLocationFormat().
+   */
+  CompilerOutputter( TestResultCollector *result,
+                     OStream &stream,
+                     const std::string &locationFormat = CPPUNIT_COMPILER_LOCATION_FORMAT );
+
+  /// Destructor.
+  virtual ~CompilerOutputter();
+
+  /*! \brief Sets the error location format.
+   *
+   * Indicates the format used to report location of failed assertion. This format should
+   * match the one used by your compiler.
+   *
+   * The location format is a string in which the occurence of the following character
+   * sequence are replaced:
+   *
+   * - "%l" => replaced by the line number
+   * - "%p" => replaced by the full path name of the file ("G:\prg\vc\cppunit\MyTest.cpp")
+   * - "%f" => replaced by the base name of the file ("MyTest.cpp")
+   *
+   * Some examples:
+   *
+   * - VC++ error location format: "%p(%l):" => produce "G:\prg\MyTest.cpp(43):"
+   * - GCC error location format: "%f:%l:" => produce "MyTest.cpp:43:"
+   *
+   * Thoses are the two compilers currently <em>supported</em> (gcc format is used if
+   * VC++ is not detected). If you want your compiler to be automatically supported by
+   * CppUnit, send a mail to the mailing list (preferred), or submit a feature request
+   * that indicates how to detect your compiler with the preprocessor (\#ifdef...) and
+   * your compiler location format.
+   */
+  void setLocationFormat( const std::string &locationFormat );
+
+  /*! \brief Creates an instance of an outputter that matches your current compiler.
+   * \deprecated This class is specialized through parameterization instead of subclassing...
+   *             Use CompilerOutputter::CompilerOutputter instead.
+   */
+  static CompilerOutputter *defaultOutputter( TestResultCollector *result,
+                                              OStream &stream );
+
+  void write();
+
+  void setNoWrap();
+
+  void setWrapColumn( int wrapColumn );
+
+  int wrapColumn() const;
+
+  virtual void printSuccess();
+  virtual void printFailureReport();
+  virtual void printFailuresList();
+  virtual void printStatistics();
+  virtual void printFailureDetail( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailedTestName( TestFailure *failure );
+  virtual void printFailureMessage( TestFailure *failure );
+
+private:
+  /// Prevents the use of the copy constructor.
+  CompilerOutputter( const CompilerOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const CompilerOutputter &copy );
+
+  virtual bool processLocationFormatCommand( char command,
+                                             const SourceLine &sourceLine );
+
+  virtual std::string extractBaseName( const std::string &fileName ) const;
+
+private:
+  TestResultCollector *m_result;
+  OStream &m_stream;
+  std::string m_locationFormat;
+  int m_wrapColumn;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_COMPILERTESTRESULTOUTPUTTER_H
diff --git a/src/test/cppunit/DefaultProtector.cpp b/src/test/cppunit/DefaultProtector.cpp
new file mode 100644
index 0000000..6f21be7
--- /dev/null
+++ b/src/test/cppunit/DefaultProtector.cpp
@@ -0,0 +1,42 @@
+#include <cppunit/Exception.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+#include "DefaultProtector.h"
+
+
+CPPUNIT_NS_BEGIN
+
+
+bool
+DefaultProtector::protect( const Functor &functor,
+                           const ProtectorContext &context )
+{
+  try
+  {
+    return functor();
+  }
+  catch ( Exception &failure )
+  {
+    reportFailure( context, failure );
+  }
+  catch ( std::exception &e )
+  {
+    std::string shortDescription( "uncaught exception of type " );
+#if CPPUNIT_USE_TYPEINFO_NAME
+    shortDescription += TypeInfoHelper::getClassName( typeid(e) );
+#else
+    shortDescription += "std::exception (or derived).";
+#endif
+    Message message( shortDescription, e.what() );
+    reportError( context, message );
+  }
+  catch ( ... )
+  {
+    reportError( context,
+                 Message( "uncaught exception of unknown type") );
+  }
+
+  return false;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/DefaultProtector.h b/src/test/cppunit/DefaultProtector.h
new file mode 100644
index 0000000..4a76ea0
--- /dev/null
+++ b/src/test/cppunit/DefaultProtector.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_DEFAULTPROTECTOR_H
+#define CPPUNIT_DEFAULTPROTECTOR_H
+
+#include <cppunit/Protector.h>
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Default protector that catch all exceptions (Implementation).
+ *
+ * Implementation detail.
+ * \internal This protector catch and generate a failure for the following
+ * exception types:
+ * - Exception
+ * - std::exception
+ * - ...
+ */
+class DefaultProtector : public Protector
+{
+public:
+  bool protect( const Functor &functor,
+                const ProtectorContext &context );
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_DEFAULTPROTECTOR_H
+
diff --git a/src/test/cppunit/DllMain.cpp b/src/test/cppunit/DllMain.cpp
new file mode 100644
index 0000000..b79040e
--- /dev/null
+++ b/src/test/cppunit/DllMain.cpp
@@ -0,0 +1,16 @@
+#define WIN32_LEAN_AND_MEAN
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define BLENDFUNCTION void    // for mingw & gcc
+
+#include <windows.h>
+
+BOOL APIENTRY
+DllMain( HANDLE hModule,
+         DWORD  ul_reason_for_call,
+         LPVOID lpReserved )
+{
+  return TRUE;
+}
diff --git a/src/test/cppunit/DynamicLibraryManager.cpp b/src/test/cppunit/DynamicLibraryManager.cpp
new file mode 100644
index 0000000..642e136
--- /dev/null
+++ b/src/test/cppunit/DynamicLibraryManager.cpp
@@ -0,0 +1,77 @@
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <cppunit/plugin/DynamicLibraryManagerException.h>
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::DynamicLibraryManager( const std::string &libraryFileName )
+    : m_libraryHandle( NULL )
+    , m_libraryName( libraryFileName )
+{
+  loadLibrary( libraryFileName );
+}
+
+
+DynamicLibraryManager::~DynamicLibraryManager()
+{
+  releaseLibrary();
+}
+
+
+DynamicLibraryManager::Symbol
+DynamicLibraryManager::findSymbol( const std::string &symbol )
+{
+  try
+  {
+    Symbol symbolPointer = doFindSymbol( symbol );
+    if ( symbolPointer != NULL )
+      return symbolPointer;
+  }
+  catch ( ... )
+  {
+  }
+
+  throw DynamicLibraryManagerException( m_libraryName,
+                                        symbol,
+                                        DynamicLibraryManagerException::symbolNotFound );
+  return NULL;    // keep compiler happy
+}
+
+
+void
+DynamicLibraryManager::loadLibrary( const std::string &libraryName )
+{
+  try
+  {
+    releaseLibrary();
+    m_libraryHandle = doLoadLibrary( libraryName );
+    if ( m_libraryHandle != NULL )
+      return;
+  }
+  catch (...)
+  {
+  }
+
+  throw DynamicLibraryManagerException( m_libraryName,
+                                        getLastErrorDetail(),
+                                        DynamicLibraryManagerException::loadingFailed );
+}
+
+
+void
+DynamicLibraryManager::releaseLibrary()
+{
+  if ( m_libraryHandle != NULL )
+  {
+    doReleaseLibrary();
+    m_libraryHandle = NULL;
+  }
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/DynamicLibraryManagerException.cpp b/src/test/cppunit/DynamicLibraryManagerException.cpp
new file mode 100644
index 0000000..2601ef1
--- /dev/null
+++ b/src/test/cppunit/DynamicLibraryManagerException.cpp
@@ -0,0 +1,41 @@
+#include <cppunit/plugin/DynamicLibraryManagerException.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManagerException::DynamicLibraryManagerException(
+                                         const std::string &libraryName,
+                                         const std::string &errorDetail,
+                                         Cause cause )
+    : std::runtime_error( "" ),
+      m_cause( cause )
+{
+  if ( cause == loadingFailed )
+    m_message = "Failed to load dynamic library: " + libraryName + "\n" +
+                errorDetail;
+  else
+    m_message = "Symbol [" + errorDetail + "] not found in dynamic libary:" +
+                libraryName;
+}
+
+
+DynamicLibraryManagerException::Cause
+DynamicLibraryManagerException::getCause() const
+{
+  return m_cause;
+}
+
+
+const char *
+DynamicLibraryManagerException::what() const throw()
+{
+  return m_message.c_str();
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/Exception.cpp b/src/test/cppunit/Exception.cpp
new file mode 100644
index 0000000..f90c60c
--- /dev/null
+++ b/src/test/cppunit/Exception.cpp
@@ -0,0 +1,126 @@
+#include <cppunit/Exception.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+/*!
+ * \deprecated Use SourceLine::isValid() instead.
+ */
+const std::string Exception::UNKNOWNFILENAME = "<unknown>";
+
+/*!
+ * \deprecated Use SourceLine::isValid() instead.
+ */
+const long Exception::UNKNOWNLINENUMBER = -1;
+#endif
+
+
+Exception::Exception( const Exception &other )
+   : std::exception( other )
+{
+  m_message = other.m_message;
+  m_sourceLine = other.m_sourceLine;
+}
+
+
+Exception::Exception( const Message &message,
+                      const SourceLine &sourceLine )
+    : m_message( message )
+    , m_sourceLine( sourceLine )
+{
+}
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+Exception::Exception( std::string message,
+                      long lineNumber,
+                      std::string fileName )
+    : m_message( message )
+    , m_sourceLine( fileName, lineNumber )
+{
+}
+#endif
+
+
+Exception::~Exception() throw()
+{
+}
+
+
+Exception &
+Exception::operator =( const Exception& other )
+{
+// Don't call superclass operator =(). VC++ STL implementation
+// has a bug. It calls the destructor and copy constructor of
+// std::exception() which reset the virtual table to std::exception.
+//  SuperClass::operator =(other);
+
+  if ( &other != this )
+  {
+    m_message = other.m_message;
+    m_sourceLine = other.m_sourceLine;
+  }
+
+  return *this;
+}
+
+
+const char*
+Exception::what() const throw()
+{
+  Exception *mutableThis = CPPUNIT_CONST_CAST( Exception *, this );
+  mutableThis->m_whatMessage = m_message.shortDescription() + "\n" +
+                               m_message.details();
+  return m_whatMessage.c_str();
+}
+
+
+SourceLine
+Exception::sourceLine() const
+{
+  return m_sourceLine;
+}
+
+
+Message
+Exception::message() const
+{
+  return m_message;
+}
+
+
+void
+Exception::setMessage( const Message &message )
+{
+  m_message = message;
+}
+
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+long
+Exception::lineNumber() const
+{
+  return m_sourceLine.isValid() ? m_sourceLine.lineNumber() :
+                                  UNKNOWNLINENUMBER;
+}
+
+
+std::string
+Exception::fileName() const
+{
+  return m_sourceLine.isValid() ? m_sourceLine.fileName() :
+                                  UNKNOWNFILENAME;
+}
+#endif
+
+
+Exception *
+Exception::clone() const
+{
+  return new Exception( *this );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Exception.h b/src/test/cppunit/Exception.h
new file mode 100644
index 0000000..9661eb7
--- /dev/null
+++ b/src/test/cppunit/Exception.h
@@ -0,0 +1,90 @@
+#ifndef CPPUNIT_EXCEPTION_H
+#define CPPUNIT_EXCEPTION_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Message.h>
+#include <cppunit/SourceLine.h>
+#include <exception>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exceptions thrown by failed assertions.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Exception is an exception that serves
+ * descriptive strings through its what() method
+ */
+class CPPUNIT_API Exception : public std::exception
+{
+public:
+  /*! \brief Constructs the exception with the specified message and source location.
+   * \param message Message associated to the exception.
+   * \param sourceLine Source location related to the exception.
+   */
+  Exception( const Message &message = Message(),
+             const SourceLine &sourceLine = SourceLine() );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /*!
+   * \deprecated Use other constructor instead.
+   */
+  Exception( std::string  message,
+	     long lineNumber,
+	     std::string fileName );
+#endif
+
+  /*! \brief Constructs a copy of an exception.
+   * \param other Exception to copy.
+   */
+  Exception( const Exception &other );
+
+  /// Destructs the exception
+  virtual ~Exception() throw();
+
+  /// Performs an assignment
+  Exception &operator =( const Exception &other );
+
+  /// Returns descriptive message
+  const char *what() const throw();
+
+  /// Location where the error occured
+  SourceLine sourceLine() const;
+
+  /// Message related to the exception.
+  Message message() const;
+
+  /// Set the message.
+  void setMessage( const Message &message );
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+  /// The line on which the error occurred
+  long lineNumber() const;
+
+  /// The file in which the error occurred
+  std::string fileName() const;
+
+  static const std::string UNKNOWNFILENAME;
+  static const long UNKNOWNLINENUMBER;
+#endif
+
+  /// Clones the exception.
+  virtual Exception *clone() const;
+
+protected:
+  // VC++ does not recognize call to parent class when prefixed
+  // with a namespace. This is a workaround.
+  typedef std::exception SuperClass;
+
+  Message m_message;
+  SourceLine m_sourceLine;
+  std::string m_whatMessage;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXCEPTION_H
+
diff --git a/src/test/cppunit/Makefile.am b/src/test/cppunit/Makefile.am
new file mode 100644
index 0000000..d5a60bf
--- /dev/null
+++ b/src/test/cppunit/Makefile.am
@@ -0,0 +1,67 @@
+#
+# $Id: Makefile.am,v 1.44 2005/06/14 21:28:46 blep Exp $
+#
+
+EXTRA_DIST = cppunit.dsp cppunit_dll.dsp DllMain.cpp
+INCLUDES = -I$(top_builddir)/include -I$(top_srcdir)/include
+
+lib_LTLIBRARIES = libcppunit.la
+
+libcppunit_la_SOURCES = \
+  AdditionalMessage.cpp \
+  Asserter.cpp \
+  BeOsDynamicLibraryManager.cpp \
+  BriefTestProgressListener.cpp \
+  CompilerOutputter.cpp \
+  DefaultProtector.h \
+  DefaultProtector.cpp \
+  DynamicLibraryManager.cpp \
+  DynamicLibraryManagerException.cpp \
+  Exception.cpp \
+  Message.cpp \
+  RepeatedTest.cpp \
+  PlugInManager.cpp \
+  PlugInParameters.cpp \
+  Protector.cpp \
+  ProtectorChain.h \
+  ProtectorContext.h \
+  ProtectorChain.cpp \
+  SourceLine.cpp \
+  StringTools.cpp \
+  SynchronizedObject.cpp \
+  Test.cpp \
+  TestAssert.cpp \
+  TestCase.cpp \
+  TestCaseDecorator.cpp \
+  TestComposite.cpp \
+  TestDecorator.cpp \
+  TestFactoryRegistry.cpp \
+  TestFailure.cpp \
+  TestLeaf.cpp \
+  TestNamer.cpp \
+  TestPath.cpp \
+  TestPlugInDefaultImpl.cpp \
+  TestResult.cpp \
+  TestResultCollector.cpp \
+  TestRunner.cpp \
+  TestSetUp.cpp \
+  TestSuccessListener.cpp \
+  TestSuite.cpp \
+  TestSuiteBuilderContext.cpp \
+  TextOutputter.cpp \
+  TextTestProgressListener.cpp \
+  TextTestResult.cpp \
+  TextTestRunner.cpp \
+  TypeInfoHelper.cpp \
+  UnixDynamicLibraryManager.cpp \
+  ShlDynamicLibraryManager.cpp \
+  XmlDocument.cpp \
+  XmlElement.cpp \
+  XmlOutputter.cpp \
+  XmlOutputterHook.cpp \
+  Win32DynamicLibraryManager.cpp
+
+libcppunit_la_LDFLAGS= \
+ -no-undefined -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+ -release $(LT_RELEASE)
+
diff --git a/src/test/cppunit/Makefile.in b/src/test/cppunit/Makefile.in
new file mode 100644
index 0000000..dde824d
--- /dev/null
+++ b/src/test/cppunit/Makefile.in
@@ -0,0 +1,632 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+#
+# $Id: Makefile.am,v 1.44 2005/06/14 21:28:46 blep Exp $
+#
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = src/cppunit
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libdir)"
+libLTLIBRARIES_INSTALL = $(INSTALL)
+LTLIBRARIES = $(lib_LTLIBRARIES)
+libcppunit_la_LIBADD =
+am_libcppunit_la_OBJECTS = AdditionalMessage.lo Asserter.lo \
+	BeOsDynamicLibraryManager.lo BriefTestProgressListener.lo \
+	CompilerOutputter.lo DefaultProtector.lo \
+	DynamicLibraryManager.lo DynamicLibraryManagerException.lo \
+	Exception.lo Message.lo RepeatedTest.lo PlugInManager.lo \
+	PlugInParameters.lo Protector.lo ProtectorChain.lo \
+	SourceLine.lo StringTools.lo SynchronizedObject.lo Test.lo \
+	TestAssert.lo TestCase.lo TestCaseDecorator.lo \
+	TestComposite.lo TestDecorator.lo TestFactoryRegistry.lo \
+	TestFailure.lo TestLeaf.lo TestNamer.lo TestPath.lo \
+	TestPlugInDefaultImpl.lo TestResult.lo TestResultCollector.lo \
+	TestRunner.lo TestSetUp.lo TestSuccessListener.lo TestSuite.lo \
+	TestSuiteBuilderContext.lo TextOutputter.lo \
+	TextTestProgressListener.lo TextTestResult.lo \
+	TextTestRunner.lo TypeInfoHelper.lo \
+	UnixDynamicLibraryManager.lo ShlDynamicLibraryManager.lo \
+	XmlDocument.lo XmlElement.lo XmlOutputter.lo \
+	XmlOutputterHook.lo Win32DynamicLibraryManager.lo
+libcppunit_la_OBJECTS = $(am_libcppunit_la_OBJECTS)
+libcppunit_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \
+	$(CXXFLAGS) $(libcppunit_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/config
+depcomp = $(SHELL) $(top_srcdir)/config/depcomp
+am__depfiles_maybe = depfiles
+CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)
+CXXLD = $(CXX)
+CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+CCLD = $(CC)
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
+SOURCES = $(libcppunit_la_SOURCES)
+DIST_SOURCES = $(libcppunit_la_SOURCES)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+EXTRA_DIST = cppunit.dsp cppunit_dll.dsp DllMain.cpp
+INCLUDES = -I$(top_builddir)/include -I$(top_srcdir)/include
+lib_LTLIBRARIES = libcppunit.la
+libcppunit_la_SOURCES = \
+  AdditionalMessage.cpp \
+  Asserter.cpp \
+  BeOsDynamicLibraryManager.cpp \
+  BriefTestProgressListener.cpp \
+  CompilerOutputter.cpp \
+  DefaultProtector.h \
+  DefaultProtector.cpp \
+  DynamicLibraryManager.cpp \
+  DynamicLibraryManagerException.cpp \
+  Exception.cpp \
+  Message.cpp \
+  RepeatedTest.cpp \
+  PlugInManager.cpp \
+  PlugInParameters.cpp \
+  Protector.cpp \
+  ProtectorChain.h \
+  ProtectorContext.h \
+  ProtectorChain.cpp \
+  SourceLine.cpp \
+  StringTools.cpp \
+  SynchronizedObject.cpp \
+  Test.cpp \
+  TestAssert.cpp \
+  TestCase.cpp \
+  TestCaseDecorator.cpp \
+  TestComposite.cpp \
+  TestDecorator.cpp \
+  TestFactoryRegistry.cpp \
+  TestFailure.cpp \
+  TestLeaf.cpp \
+  TestNamer.cpp \
+  TestPath.cpp \
+  TestPlugInDefaultImpl.cpp \
+  TestResult.cpp \
+  TestResultCollector.cpp \
+  TestRunner.cpp \
+  TestSetUp.cpp \
+  TestSuccessListener.cpp \
+  TestSuite.cpp \
+  TestSuiteBuilderContext.cpp \
+  TextOutputter.cpp \
+  TextTestProgressListener.cpp \
+  TextTestResult.cpp \
+  TextTestRunner.cpp \
+  TypeInfoHelper.cpp \
+  UnixDynamicLibraryManager.cpp \
+  ShlDynamicLibraryManager.cpp \
+  XmlDocument.cpp \
+  XmlElement.cpp \
+  XmlOutputter.cpp \
+  XmlOutputterHook.cpp \
+  Win32DynamicLibraryManager.cpp
+
+libcppunit_la_LDFLAGS = \
+ -no-undefined -version-info $(LT_CURRENT):$(LT_REVISION):$(LT_AGE) \
+ -release $(LT_RELEASE)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .cpp .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  src/cppunit/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  src/cppunit/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+install-libLTLIBRARIES: $(lib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(libdir)" || $(MKDIR_P) "$(DESTDIR)$(libdir)"
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  if test -f $$p; then \
+	    f=$(am__strip_dir) \
+	    echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) '$$p' '$(DESTDIR)$(libdir)/$$f'"; \
+	    $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(libLTLIBRARIES_INSTALL) $(INSTALL_STRIP_FLAG) "$$p" "$(DESTDIR)$(libdir)/$$f"; \
+	  else :; fi; \
+	done
+
+uninstall-libLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  p=$(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(libdir)/$$p'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(libdir)/$$p"; \
+	done
+
+clean-libLTLIBRARIES:
+	-test -z "$(lib_LTLIBRARIES)" || rm -f $(lib_LTLIBRARIES)
+	@list='$(lib_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libcppunit.la: $(libcppunit_la_OBJECTS) $(libcppunit_la_DEPENDENCIES)
+	$(libcppunit_la_LINK) -rpath $(libdir) $(libcppunit_la_OBJECTS) $(libcppunit_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/AdditionalMessage.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Asserter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BeOsDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/BriefTestProgressListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/CompilerOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DefaultProtector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/DynamicLibraryManagerException.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Exception.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Message.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/PlugInManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/PlugInParameters.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Protector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ProtectorChain.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/RepeatedTest.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ShlDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SourceLine.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/StringTools.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/SynchronizedObject.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Test.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestAssert.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestCase.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestCaseDecorator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestComposite.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestDecorator.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestFactoryRegistry.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestFailure.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestLeaf.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestNamer.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestPath.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestPlugInDefaultImpl.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestResult.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestResultCollector.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestRunner.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSetUp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuccessListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuite.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TestSuiteBuilderContext.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestProgressListener.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestResult.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TextTestRunner.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/TypeInfoHelper.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/UnixDynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/Win32DynamicLibraryManager.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlDocument.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlElement.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlOutputter.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/XmlOutputterHook.Plo@am__quote@
+
+.cpp.o:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ $<
+
+.cpp.obj:
+@am__fastdepCXX_TRUE@	$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.cpp.lo:
+@am__fastdepCXX_TRUE@	$(LTCXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCXX_TRUE@	mv -f $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCXX_FALSE@	DEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCXX_FALSE@	$(LTCXXCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(libdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libLTLIBRARIES clean-libtool \
+	mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-am
+
+install-exec-am: install-libLTLIBRARIES
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libLTLIBRARIES clean-libtool ctags distclean \
+	distclean-compile distclean-generic distclean-libtool \
+	distclean-tags distdir dvi dvi-am html html-am info info-am \
+	install install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am \
+	install-libLTLIBRARIES install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libLTLIBRARIES
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/Message.cpp b/src/test/cppunit/Message.cpp
new file mode 100644
index 0000000..ab045aa
--- /dev/null
+++ b/src/test/cppunit/Message.cpp
@@ -0,0 +1,170 @@
+#include <cppunit/Message.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+Message::Message()
+{
+}
+
+Message::Message( const Message &other )
+{
+   *this = other;
+}
+
+
+Message::Message( const std::string &shortDescription )
+    : m_shortDescription( shortDescription )
+{
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1 );
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1,
+                  const std::string &detail2 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1, detail2 );
+}
+
+
+Message::Message( const std::string &shortDescription,
+                  const std::string &detail1,
+                  const std::string &detail2,
+                  const std::string &detail3 )
+    : m_shortDescription( shortDescription )
+{
+  addDetail( detail1, detail2, detail3 );
+}
+
+Message &
+Message::operator =( const Message &other )
+{
+   if ( this != &other )
+   {
+      m_shortDescription = other.m_shortDescription.c_str();
+      m_details.clear();
+      Details::const_iterator it = other.m_details.begin();
+      Details::const_iterator itEnd = other.m_details.end();
+      while ( it != itEnd )
+         m_details.push_back( (*it++).c_str() );
+   }
+
+   return *this;
+}
+
+
+const std::string &
+Message::shortDescription() const
+{
+  return m_shortDescription;
+}
+
+
+int
+Message::detailCount() const
+{
+  return m_details.size();
+}
+
+
+std::string
+Message::detailAt( int index ) const
+{
+  if ( index < 0  ||  index >= detailCount() )
+    throw std::invalid_argument( "Message::detailAt() : invalid index" );
+
+  return m_details[ index ];
+}
+
+
+std::string
+Message::details() const
+{
+  std::string details;
+  for ( Details::const_iterator it = m_details.begin(); it != m_details.end(); ++it )
+  {
+    details += "- ";
+    details += *it;
+    details += '\n';
+  }
+  return details;
+}
+
+
+void
+Message::clearDetails()
+{
+  m_details.clear();
+}
+
+
+void
+Message::addDetail( const std::string &detail )
+{
+  m_details.push_back( detail );
+}
+
+
+void
+Message::addDetail( const std::string &detail1,
+                    const std::string &detail2 )
+{
+  addDetail( detail1 );
+  addDetail( detail2 );
+}
+
+
+void
+Message::addDetail( const std::string &detail1,
+                    const std::string &detail2,
+                    const std::string &detail3 )
+{
+  addDetail( detail1, detail2 );
+  addDetail( detail3 );
+}
+
+
+void
+Message::addDetail( const Message &message )
+{
+  m_details.insert( m_details.end(),
+                    message.m_details.begin(),
+                    message.m_details.end() );
+}
+
+
+void
+Message::setShortDescription( const std::string &shortDescription )
+{
+  m_shortDescription = shortDescription;
+}
+
+
+bool
+Message::operator ==( const Message &other ) const
+{
+  return m_shortDescription == other.m_shortDescription  &&
+         m_details == other.m_details;
+}
+
+
+bool
+Message::operator !=( const Message &other ) const
+{
+  return !( *this == other );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/Message.h b/src/test/cppunit/Message.h
new file mode 100644
index 0000000..1ae51cc
--- /dev/null
+++ b/src/test/cppunit/Message.h
@@ -0,0 +1,156 @@
+#ifndef CPPUNIT_MESSAGE_H
+#define CPPUNIT_MESSAGE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<std::string>;
+#endif
+
+/*! \brief Message associated to an Exception.
+ * \ingroup CreatingNewAssertions
+ *  A message is composed of two items:
+ *  - a short description (~20/30 characters)
+ *  - a list of detail strings
+ *
+ *  The short description is used to indicate how the detail strings should be
+ *  interpreted. It usually indicates the failure types, such as
+ *  "assertion failed", "forced failure", "unexpected exception caught",
+ *  "equality assertion failed"... It should not contains new line character (\n).
+ *
+ *  Detail strings are used to provide more information about the failure. It
+ *  can contains the asserted expression, the expected and actual values in an
+ *  equality assertion, some addional messages... Detail strings can contains
+ *  new line characters (\n).
+ */
+class CPPUNIT_API Message
+{
+public:
+  Message();
+
+  // Ensure thread-safe copy by detaching the string.
+  Message( const Message &other );
+
+  explicit Message( const std::string &shortDescription );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2 );
+
+  Message( const std::string &shortDescription,
+           const std::string &detail1,
+           const std::string &detail2,
+           const std::string &detail3 );
+
+  Message &operator =( const Message &other );
+
+  /*! \brief Returns the short description.
+   * \return Short description.
+   */
+  const std::string &shortDescription() const;
+
+  /*! \brief Returns the number of detail string.
+   * \return Number of detail string.
+   */
+  int detailCount() const;
+
+  /*! \brief Returns the detail at the specified index.
+   * \param index Zero based index of the detail string to return.
+   * \returns Detail string at the specified index.
+   * \exception std::invalid_argument if \a index < 0 or index >= detailCount().
+   */
+  std::string detailAt( int index ) const;
+
+  /*! \brief Returns a string that represents a list of the detail strings.
+   *
+   * Example:
+   * \code
+   * Message message( "not equal", "Expected: 3", "Actual: 7" );
+   * std::string details = message.details();
+   * // details contains:
+   * // "- Expected: 3\n- Actual: 7\n"  \endcode
+   *
+   * \return A string that is a concatenation of all the detail strings. Each detail
+   *         string is prefixed with '- ' and suffixed with '\n' before being
+   *         concatenated to the other.
+   */
+  std::string details() const;
+
+  /*! \brief Removes all detail strings.
+   */
+  void clearDetails();
+
+  /*! \brief Adds a single detail string.
+   * \param detail Detail string to add.
+   */
+  void addDetail( const std::string &detail );
+
+  /*! \brief Adds two detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2 );
+
+  /*! \brief Adds three detail strings.
+   * \param detail1 Detail string to add.
+   * \param detail2 Detail string to add.
+   * \param detail3 Detail string to add.
+   */
+  void addDetail( const std::string &detail1,
+                  const std::string &detail2,
+                  const std::string &detail3 );
+
+  /*! \brief Adds the detail strings of the specified message.
+   * \param message All the detail strings of this message are added to this one.
+   */
+  void addDetail( const Message &message );
+
+  /*! \brief Sets the short description.
+   * \param shortDescription New short description.
+   */
+  void setShortDescription( const std::string &shortDescription );
+
+  /*! \brief Tests if a message is identical to another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are identical, \c false otherwise.
+   */
+  bool operator ==( const Message &other ) const;
+
+  /*! \brief Tests if a message is different from another one.
+   * \param other Message this message is compared to.
+   * \return \c true if the two message are not identical, \c false otherwise.
+   */
+  bool operator !=( const Message &other ) const;
+
+private:
+  std::string m_shortDescription;
+
+  typedef CppUnitDeque<std::string> Details;
+  Details m_details;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_MESSAGE_H
diff --git a/src/test/cppunit/Outputter.h b/src/test/cppunit/Outputter.h
new file mode 100644
index 0000000..f31d681
--- /dev/null
+++ b/src/test/cppunit/Outputter.h
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_OUTPUTTER_H
+#define CPPUNIT_OUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Abstract outputter to print test result summary.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API Outputter
+{
+public:
+  /// Destructor.
+  virtual ~Outputter() {}
+
+  virtual void write() =0;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNIT_OUTPUTTER_H
diff --git a/src/test/cppunit/PlugInManager.cpp b/src/test/cppunit/PlugInManager.cpp
new file mode 100644
index 0000000..471646e
--- /dev/null
+++ b/src/test/cppunit/PlugInManager.cpp
@@ -0,0 +1,110 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/XmlOutputterHook.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/plugin/PlugInManager.h>
+#include <cppunit/plugin/TestPlugIn.h>
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+PlugInManager::PlugInManager()
+{
+}
+
+
+PlugInManager::~PlugInManager()
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    unload( *it );
+}
+
+
+void
+PlugInManager::load( const std::string &libraryFileName,
+                     const PlugInParameters &parameters )
+{
+  PlugInInfo info;
+  info.m_fileName = libraryFileName;
+  info.m_manager = new DynamicLibraryManager( libraryFileName );
+
+  TestPlugInSignature plug = (TestPlugInSignature)info.m_manager->findSymbol(
+        CPPUNIT_STRINGIZE( CPPUNIT_PLUGIN_EXPORTED_NAME ) );
+  info.m_interface = (*plug)();
+
+  m_plugIns.push_back( info );
+
+  info.m_interface->initialize( &TestFactoryRegistry::getRegistry(), parameters );
+}
+
+
+void
+PlugInManager::unload( const std::string &libraryFileName )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+  {
+    if ( (*it).m_fileName == libraryFileName )
+    {
+      unload( *it );
+      m_plugIns.erase( it );
+      break;
+    }
+  }
+}
+
+
+void
+PlugInManager::addListener( TestResult *eventManager )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->addListener( eventManager );
+}
+
+
+void
+PlugInManager::removeListener( TestResult *eventManager )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->removeListener( eventManager );
+}
+
+
+void
+PlugInManager::unload( PlugInInfo &plugIn )
+{
+  try
+  {
+    plugIn.m_interface->uninitialize( &TestFactoryRegistry::getRegistry() );
+    delete plugIn.m_manager;
+  }
+  catch (...)
+  {
+    delete plugIn.m_manager;
+    plugIn.m_manager = NULL;
+    throw;
+  }
+}
+
+
+void
+PlugInManager::addXmlOutputterHooks( XmlOutputter *outputter )
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->addXmlOutputterHooks( outputter );
+}
+
+
+void
+PlugInManager::removeXmlOutputterHooks()
+{
+  for ( PlugIns::iterator it = m_plugIns.begin(); it != m_plugIns.end(); ++it )
+    (*it).m_interface->removeXmlOutputterHooks();
+}
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/PlugInParameters.cpp b/src/test/cppunit/PlugInParameters.cpp
new file mode 100644
index 0000000..7bb789f
--- /dev/null
+++ b/src/test/cppunit/PlugInParameters.cpp
@@ -0,0 +1,28 @@
+#include <cppunit/plugin/PlugInParameters.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+PlugInParameters::PlugInParameters( const std::string &commandLine )
+    : m_commandLine( commandLine )
+{
+}
+
+
+PlugInParameters::~PlugInParameters()
+{
+}
+
+
+std::string
+PlugInParameters::getCommandLine() const
+{
+  return m_commandLine;
+}
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/Portability.h b/src/test/cppunit/Portability.h
new file mode 100644
index 0000000..e0c2045
--- /dev/null
+++ b/src/test/cppunit/Portability.h
@@ -0,0 +1,177 @@
+#ifndef CPPUNIT_PORTABILITY_H
+#define CPPUNIT_PORTABILITY_H
+
+#if defined(_WIN32) && !defined(WIN32)
+# define WIN32 1
+#endif
+
+/* include platform specific config */
+#if defined(__BORLANDC__)
+#  include <cppunit/config/config-bcb5.h>
+#elif defined (_MSC_VER)
+#  if _MSC_VER == 1200 && defined(_WIN32_WCE) //evc4
+#    include <cppunit/config/config-evc4.h>
+#  else
+#    include <cppunit/config/config-msvc6.h>
+#  endif
+#else
+#    include <cppunit/config-auto.h>
+#endif
+
+// Version number of package
+#ifndef CPPUNIT_VERSION
+#define CPPUNIT_VERSION  "1.12.0"
+#endif
+
+#include <cppunit/config/CppUnitApi.h>    // define CPPUNIT_API & CPPUNIT_NEED_DLL_DECL
+#include <cppunit/config/SelectDllLoader.h>
+
+
+/* Options that the library user may switch on or off.
+ * If the user has not done so, we chose default values.
+ */
+
+
+/* Define to 1 if you wish to have the old-style macros
+   assert(), assertEqual(), assertDoublesEqual(), and assertLongsEqual() */
+#if !defined(CPPUNIT_ENABLE_NAKED_ASSERT)
+# define CPPUNIT_ENABLE_NAKED_ASSERT          0
+#endif
+
+/* Define to 1 if you wish to have the old-style CU_TEST family
+   of macros. */
+#if !defined(CPPUNIT_ENABLE_CU_TEST_MACROS)
+# define CPPUNIT_ENABLE_CU_TEST_MACROS        0
+#endif
+
+/* Define to 1 if the preprocessor expands (#foo) to "foo" (quotes incl.)
+   I don't think there is any C preprocess that does NOT support this! */
+#if !defined(CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION)
+# define CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION   1
+#endif
+
+/* Assumes that STL and CppUnit are in global space if the compiler does not
+   support namespace. */
+#if !defined(CPPUNIT_HAVE_NAMESPACES)
+# if !defined(CPPUNIT_NO_NAMESPACE)
+#  define CPPUNIT_NO_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_NAMESPACE)
+# if !defined(CPPUNIT_NO_STD_NAMESPACE)
+#  define CPPUNIT_NO_STD_NAMESPACE 1
+# endif // !defined(CPPUNIT_NO_STD_NAMESPACE)
+#endif // !defined(CPPUNIT_HAVE_NAMESPACES)
+
+/* Define CPPUNIT_STD_NEED_ALLOCATOR to 1 if you need to specify
+ * the allocator you used when instantiating STL container. Typically
+ * used for compilers that do not support template default parameter.
+ * CPPUNIT_STD_ALLOCATOR will be used as the allocator. Default is
+ * std::allocator. On some compilers, you may need to change this to
+ * std::allocator<T>.
+ */
+#if CPPUNIT_STD_NEED_ALLOCATOR
+# if !defined(CPPUNIT_STD_ALLOCATOR)
+#  define CPPUNIT_STD_ALLOCATOR std::allocator
+# endif // !defined(CPPUNIT_STD_ALLOCATOR)
+#endif // defined(CPPUNIT_STD_NEED_ALLOCATOR)
+
+
+// Compiler error location format for CompilerOutputter
+// If not define, assumes that it's gcc
+// See class CompilerOutputter for format.
+#if !defined(CPPUNIT_COMPILER_LOCATION_FORMAT)
+#if defined(__GNUC__) && ( defined(__APPLE_CPP__) || defined(__APPLE_CC__) )
+// gcc/Xcode integration on Mac OS X
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p:%l: "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%f:%l:"
+#endif
+#endif
+
+// If CPPUNIT_HAVE_CPP_CAST is defined, then c++ style cast will be used,
+// otherwise, C style cast are used.
+#if defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    const_cast<TargetType>( pointer )
+
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    static_cast<TargetType>( pointer )
+#else // defined( CPPUNIT_HAVE_CPP_CAST )
+# define CPPUNIT_CONST_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+# define CPPUNIT_STATIC_CAST( TargetType, pointer ) \
+    ((TargetType)( pointer ))
+#endif // defined( CPPUNIT_HAVE_CPP_CAST )
+
+// If CPPUNIT_NO_STD_NAMESPACE is defined then STL are in the global space.
+// => Define macro 'std' to nothing
+#if defined(CPPUNIT_NO_STD_NAMESPACE)
+# undef std
+# define std
+#endif  // defined(CPPUNIT_NO_STD_NAMESPACE)
+
+// If CPPUNIT_NO_NAMESPACE is defined, then put CppUnit classes in the
+// global namespace: the compiler does not support namespace.
+#if defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN
+# define CPPUNIT_NS_END
+# define CPPUNIT_NS
+#else   // defined(CPPUNIT_NO_NAMESPACE)
+# define CPPUNIT_NS_BEGIN namespace CppUnit {
+# define CPPUNIT_NS_END }
+# define CPPUNIT_NS CppUnit
+#endif  // defined(CPPUNIT_NO_NAMESPACE)
+
+/*! Stringize a symbol.
+ *
+ * Use this macro to convert a preprocessor symbol to a string.
+ *
+ * Example of usage:
+ * \code
+ * #define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+ * const char *name = CPPUNIT_STRINGIZE( CPPUNIT_PLUGIN_EXPORTED_NAME );
+ * \endcode
+ */
+#define CPPUNIT_STRINGIZE( symbol ) _CPPUNIT_DO_STRINGIZE( symbol )
+
+/// \internal
+#define _CPPUNIT_DO_STRINGIZE( symbol ) #symbol
+
+/*! Joins to symbol after expanding them into string.
+ *
+ * Use this macro to join two symbols. Example of usage:
+ *
+ * \code
+ * #define MAKE_UNIQUE_NAME(prefix) CPPUNIT_JOIN( prefix, __LINE__ )
+ * \endcode
+ *
+ * The macro defined in the example concatenate a given prefix with the line number
+ * to obtain a 'unique' identifier.
+ *
+ * \internal From boost documentation:
+ * The following piece of macro magic joins the two
+ * arguments together, even when one of the arguments is
+ * itself a macro (see 16.3.1 in C++ standard).  The key
+ * is that macro expansion of macro arguments does not
+ * occur in CPPUNIT_JOIN2 but does in CPPUNIT_JOIN.
+ */
+#define CPPUNIT_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN( symbol1, symbol2 ) _CPPUNIT_DO_JOIN2( symbol1, symbol2 )
+
+/// \internal
+#define _CPPUNIT_DO_JOIN2( symbol1, symbol2 ) symbol1##symbol2
+
+/*! Adds the line number to the specified string to create a unique identifier.
+ * \param prefix Prefix added to the line number to create a unique identifier.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION for an example of usage.
+ */
+#define CPPUNIT_MAKE_UNIQUE_NAME( prefix ) CPPUNIT_JOIN( prefix, __LINE__ )
+
+/*! Defines wrap colunm for %CppUnit. Used by CompilerOuputter.
+ */
+#if !defined(CPPUNIT_WRAP_COLUMN)
+# define CPPUNIT_WRAP_COLUMN 79
+#endif
+
+#endif // CPPUNIT_PORTABILITY_H
diff --git a/src/test/cppunit/Protector.cpp b/src/test/cppunit/Protector.cpp
new file mode 100644
index 0000000..bc7105c
--- /dev/null
+++ b/src/test/cppunit/Protector.cpp
@@ -0,0 +1,86 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Message.h>
+#include <cppunit/Protector.h>
+#include <cppunit/TestResult.h>
+#include "ProtectorContext.h"
+#include <memory>
+
+CPPUNIT_NS_BEGIN
+
+Functor::~Functor()
+{
+}
+
+
+Protector::~Protector()
+{
+}
+
+
+void
+Protector::reportError( const ProtectorContext &context,
+                        const Exception &error ) const
+{
+  std::auto_ptr<Exception> actualError( error.clone() );
+  actualError->setMessage( actualMessage( actualError->message(), context ) );
+  context.m_result->addError( context.m_test,
+                              actualError.release() );
+}
+
+
+
+void
+Protector::reportError( const ProtectorContext &context,
+                        const Message &message,
+                        const SourceLine &sourceLine ) const
+{
+  reportError( context, Exception( message, sourceLine ) );
+}
+
+
+void
+Protector::reportFailure( const ProtectorContext &context,
+                          const Exception &failure ) const
+{
+  std::auto_ptr<Exception> actualFailure( failure.clone() );
+  actualFailure->setMessage( actualMessage( actualFailure->message(), context ) );
+  context.m_result->addFailure( context.m_test,
+                                actualFailure.release() );
+}
+
+
+Message
+Protector::actualMessage( const Message &message,
+                          const ProtectorContext &context ) const
+{
+  Message theActualMessage;
+  if ( context.m_shortDescription.empty() )
+    theActualMessage = message;
+  else
+  {
+    theActualMessage = Message( context.m_shortDescription,
+                                message.shortDescription() );
+    theActualMessage.addDetail( message );
+  }
+
+  return theActualMessage;
+}
+
+
+
+
+ProtectorGuard::ProtectorGuard( TestResult *result,
+                                              Protector *protector )
+    : m_result( result )
+{
+  m_result->pushProtector( protector );
+}
+
+
+ProtectorGuard::~ProtectorGuard()
+{
+  m_result->popProtector();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Protector.h b/src/test/cppunit/Protector.h
new file mode 100644
index 0000000..5e549ea
--- /dev/null
+++ b/src/test/cppunit/Protector.h
@@ -0,0 +1,94 @@
+#ifndef CPPUNIT_PROTECTOR_H
+#define CPPUNIT_PROTECTOR_H
+
+#include <cppunit/SourceLine.h>
+
+CPPUNIT_NS_BEGIN
+
+class Exception;
+class Message;
+class ProtectorContext;
+class TestResult;
+
+
+class CPPUNIT_API Functor
+{
+public:
+  virtual ~Functor();
+
+  virtual bool operator()() const =0;
+};
+
+
+/*! \brief Protects one or more test case run.
+ *
+ * Protector are used to globably 'decorate' a test case. The most common
+ * usage of Protector is to catch exception that do not subclass std::exception,
+ * such as MFC CException class or Rogue Wave RWXMsg class, and capture the
+ * message associated to the exception. In fact, CppUnit capture message from
+ * Exception and std::exception using a Protector.
+ *
+ * Protector are chained. When you add a Protector using
+ * TestResult::pushProtector(), your protector is in fact passed as a Functor
+ * to the first protector of the chain.
+ *
+ * TestCase protects call to setUp(), runTest() and tearDown() by calling
+ * TestResult::protect().
+ *
+ * Because the protector chain is handled by TestResult, a protector can be
+ * active for a single test, or a complete test run.
+ *
+ * Here are some possible usages:
+ * - run all test case in a separate thread and assumes the test failed if it
+ *   did not finish in a given time (infinite loop work around)
+ * - performance tracing : time only the runTest() time.
+ * \sa TestResult, TestCase, TestListener.
+ */
+class CPPUNIT_API Protector
+{
+public:
+  virtual ~Protector();
+
+  virtual bool protect( const Functor &functor,
+                        const ProtectorContext &context ) =0;
+
+protected:
+  void reportError( const ProtectorContext &context,
+                    const Exception &error ) const;
+
+  void reportError( const ProtectorContext &context,
+                    const Message &message,
+                    const SourceLine &sourceLine = SourceLine() ) const;
+
+  void reportFailure( const ProtectorContext &context,
+                      const Exception &failure ) const;
+
+  Message actualMessage( const Message &message,
+                         const ProtectorContext &context ) const;
+};
+
+
+/*! \brief Scoped protector push to TestResult.
+ *
+ * Adds the specified Protector to the specified TestResult for the object
+ * life-time.
+ */
+class CPPUNIT_API ProtectorGuard
+{
+public:
+  /// Pushes the specified protector.
+  ProtectorGuard( TestResult *result,
+                  Protector *protector );
+
+  /// Pops the protector.
+  ~ProtectorGuard();
+
+private:
+  TestResult *m_result;
+};
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_PROTECTOR_H
+
diff --git a/src/test/cppunit/ProtectorChain.cpp b/src/test/cppunit/ProtectorChain.cpp
new file mode 100644
index 0000000..6bea269
--- /dev/null
+++ b/src/test/cppunit/ProtectorChain.cpp
@@ -0,0 +1,86 @@
+#include "ProtectorChain.h"
+
+CPPUNIT_NS_BEGIN
+
+
+class ProtectorChain::ProtectFunctor : public Functor
+{
+public:
+  ProtectFunctor( Protector *protector,
+                  const Functor &functor,
+                  const ProtectorContext &context )
+      : m_protector( protector )
+      , m_functor( functor )
+      , m_context( context )
+  {
+  }
+
+  bool operator()() const
+  {
+    return m_protector->protect( m_functor, m_context );
+  }
+
+private:
+  Protector *m_protector;
+  const Functor &m_functor;
+  const ProtectorContext &m_context;
+};
+
+
+ProtectorChain::~ProtectorChain()
+{
+  while ( count() > 0 )
+    pop();
+}
+
+
+void
+ProtectorChain::push( Protector *protector )
+{
+  m_protectors.push_back( protector );
+}
+
+
+void
+ProtectorChain::pop()
+{
+  delete m_protectors.back();
+  m_protectors.pop_back();
+}
+
+int
+ProtectorChain::count() const
+{
+  return m_protectors.size();
+}
+
+
+bool
+ProtectorChain::protect( const Functor &functor,
+                         const ProtectorContext &context )
+{
+  if ( m_protectors.empty() )
+    return functor();
+
+  Functors functors;
+  for ( int index = m_protectors.size()-1; index >= 0; --index )
+  {
+    const Functor &protectedFunctor =
+              functors.empty() ? functor : *functors.back();
+
+    functors.push_back( new ProtectFunctor( m_protectors[index],
+                                            protectedFunctor,
+                                            context ) );
+  }
+
+  const Functor &outermostFunctor = *functors.back();
+  bool succeed = outermostFunctor();
+
+  for ( unsigned int deletingIndex = 0; deletingIndex < m_protectors.size(); ++deletingIndex )
+    delete functors[deletingIndex];
+
+  return succeed;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/ProtectorChain.h b/src/test/cppunit/ProtectorChain.h
new file mode 100644
index 0000000..711b56f
--- /dev/null
+++ b/src/test/cppunit/ProtectorChain.h
@@ -0,0 +1,51 @@
+#ifndef CPPUNIT_PROTECTORCHAIN_H
+#define CPPUNIT_PROTECTORCHAIN_H
+
+#include <cppunit/Protector.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Protector chain (Implementation).
+ * Implementation detail.
+ * \internal Protector that protect a Functor using a chain of nested Protector.
+ */
+class CPPUNIT_API ProtectorChain : public Protector
+{
+public:
+  ~ProtectorChain();
+
+  void push( Protector *protector );
+
+  void pop();
+
+  int count() const;
+
+  bool protect( const Functor &functor,
+                const ProtectorContext &context );
+
+private:
+  class ProtectFunctor;
+
+private:
+  typedef CppUnitDeque<Protector *> Protectors;
+  Protectors m_protectors;
+
+  typedef CppUnitDeque<Functor *> Functors;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_PROTECTORCHAIN_H
+
diff --git a/src/test/cppunit/ProtectorContext.h b/src/test/cppunit/ProtectorContext.h
new file mode 100644
index 0000000..c3d496c
--- /dev/null
+++ b/src/test/cppunit/ProtectorContext.h
@@ -0,0 +1,38 @@
+#ifndef CPPUNIT_PROTECTORCONTEXT_H
+#define CPPUNIT_PROTECTORCONTEXT_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+class Test;
+class TestResult;
+
+
+/*! \brief Protector context (Implementation).
+ * Implementation detail.
+ * \internal Context use to report failure in Protector.
+ */
+class CPPUNIT_API ProtectorContext
+{
+public:
+  ProtectorContext( Test *test,
+                    TestResult *result,
+                    const std::string &shortDescription )
+      : m_test( test )
+      , m_result( result )
+      , m_shortDescription( shortDescription )
+  {
+  }
+
+  Test *m_test;
+  TestResult *m_result;
+  std::string m_shortDescription;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_PROTECTORCONTEXT_H
+
diff --git a/src/test/cppunit/RepeatedTest.cpp b/src/test/cppunit/RepeatedTest.cpp
new file mode 100644
index 0000000..05abb00
--- /dev/null
+++ b/src/test/cppunit/RepeatedTest.cpp
@@ -0,0 +1,29 @@
+#include <cppunit/extensions/RepeatedTest.h>
+#include <cppunit/TestResult.h>
+
+CPPUNIT_NS_BEGIN
+
+
+// Counts the number of test cases that will be run by this test.
+int
+RepeatedTest::countTestCases() const
+{
+  return TestDecorator::countTestCases() * m_timesRepeat;
+}
+
+
+// Runs a repeated test
+void
+RepeatedTest::run( TestResult *result )
+{
+  for ( int n = 0; n < m_timesRepeat; n++ )
+  {
+    if ( result->shouldStop() )
+        break;
+
+    TestDecorator::run( result );
+  }
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/ShlDynamicLibraryManager.cpp b/src/test/cppunit/ShlDynamicLibraryManager.cpp
new file mode 100644
index 0000000..7ec9d5d
--- /dev/null
+++ b/src/test/cppunit/ShlDynamicLibraryManager.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <dl.h>
+#include <unistd.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+   return ::shl_load(libraryName.c_str(), BIND_IMMEDIATE, 0L);
+}
+
+
+void
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::shl_unload( (shl_t)m_libraryHandle);
+}
+
+
+DynamicLibraryManager::Symbol
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+   DynamicLibraryManager::Symbol L_symaddr = 0;
+   if ( ::shl_findsym( (shl_t*)(&m_libraryHandle),
+                       symbol.c_str(),
+                       TYPE_UNDEFINED,
+                       &L_symaddr ) == 0 )
+   {
+      return L_symaddr;
+   }
+
+   return 0;
+}
+
+
+std::string
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
diff --git a/src/test/cppunit/SourceLine.cpp b/src/test/cppunit/SourceLine.cpp
new file mode 100644
index 0000000..f0eda79
--- /dev/null
+++ b/src/test/cppunit/SourceLine.cpp
@@ -0,0 +1,81 @@
+#include <cppunit/SourceLine.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+SourceLine::SourceLine() :
+    m_lineNumber( -1 )
+{
+}
+
+
+SourceLine::SourceLine( const SourceLine &other )
+   : m_fileName( other.m_fileName.c_str() )
+   , m_lineNumber( other.m_lineNumber )
+{
+}
+
+
+SourceLine::SourceLine( const std::string &fileName,
+                        int lineNumber )
+   : m_fileName( fileName.c_str() )
+   , m_lineNumber( lineNumber )
+{
+}
+
+
+SourceLine &
+SourceLine::operator =( const SourceLine &other )
+{
+   if ( this != &other )
+   {
+      m_fileName = other.m_fileName.c_str();
+      m_lineNumber = other.m_lineNumber;
+   }
+   return *this;
+}
+
+
+SourceLine::~SourceLine()
+{
+}
+
+
+bool
+SourceLine::isValid() const
+{
+  return !m_fileName.empty();
+}
+
+
+int
+SourceLine::lineNumber() const
+{
+  return m_lineNumber;
+}
+
+
+std::string
+SourceLine::fileName() const
+{
+  return m_fileName;
+}
+
+
+bool
+SourceLine::operator ==( const SourceLine &other ) const
+{
+  return m_fileName == other.m_fileName  &&
+         m_lineNumber == other.m_lineNumber;
+}
+
+
+bool
+SourceLine::operator !=( const SourceLine &other ) const
+{
+  return !( *this == other );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/SourceLine.h b/src/test/cppunit/SourceLine.h
new file mode 100644
index 0000000..85efca5
--- /dev/null
+++ b/src/test/cppunit/SourceLine.h
@@ -0,0 +1,63 @@
+#ifndef CPPUNIT_SOURCELINE_H
+#define CPPUNIT_SOURCELINE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+/*! \brief Constructs a SourceLine object initialized with the location where the macro is expanded.
+ * \ingroup CreatingNewAssertions
+ * \relates CppUnit::SourceLine
+ * Used to write your own assertion macros.
+ * \see Asserter for example of usage.
+ */
+#define CPPUNIT_SOURCELINE() CPPUNIT_NS::SourceLine( __FILE__, __LINE__ )
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Represents a source line location.
+ * \ingroup CreatingNewAssertions
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * Used to capture the failure location in assertion.
+ *
+ * Use the CPPUNIT_SOURCELINE() macro to construct that object. Typically used when
+ * writing an assertion macro in association with Asserter.
+ *
+ * \see Asserter.
+ */
+class CPPUNIT_API SourceLine
+{
+public:
+  SourceLine();
+
+  // Ensure thread-safe copy by detaching the string buffer.
+  SourceLine( const SourceLine &other );
+
+  SourceLine( const std::string &fileName,
+              int lineNumber );
+
+  SourceLine &operator =( const SourceLine &other );
+
+  /// Destructor.
+  virtual ~SourceLine();
+
+  bool isValid() const;
+
+  int lineNumber() const;
+
+  std::string fileName() const;
+
+  bool operator ==( const SourceLine &other ) const;
+  bool operator !=( const SourceLine &other ) const;
+
+private:
+  std::string m_fileName;
+  int m_lineNumber;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SOURCELINE_H
diff --git a/src/test/cppunit/StringTools.cpp b/src/test/cppunit/StringTools.cpp
new file mode 100644
index 0000000..1b05ae1
--- /dev/null
+++ b/src/test/cppunit/StringTools.cpp
@@ -0,0 +1,80 @@
+#include <cppunit/tools/StringTools.h>
+#include <cppunit/portability/Stream.h>
+#include <algorithm>
+
+
+CPPUNIT_NS_BEGIN
+
+
+std::string
+StringTools::toString( int value )
+{
+  OStringStream stream;
+  stream << value;
+  return stream.str();
+}
+
+
+std::string
+StringTools::toString( double value )
+{
+  OStringStream stream;
+  stream << value;
+  return stream.str();
+}
+
+
+StringTools::Strings
+StringTools::split( const std::string &text,
+                    char separator )
+{
+  Strings splittedText;
+
+  std::string::const_iterator itStart = text.begin();
+  while ( !text.empty() )
+  {
+    std::string::const_iterator itSeparator = std::find( itStart,
+                                                         text.end(),
+                                                         separator );
+    splittedText.push_back( text.substr( itStart - text.begin(),
+                                         itSeparator - itStart ) );
+    if ( itSeparator == text.end() )
+      break;
+    itStart = itSeparator +1;
+  }
+
+  return splittedText;
+}
+
+
+std::string
+StringTools::wrap( const std::string &text,
+                   int wrapColumn )
+{
+  const char lineBreak = '\n';
+  Strings lines = split( text, lineBreak );
+
+  std::string wrapped;
+  for ( Strings::const_iterator it = lines.begin(); it != lines.end(); ++it )
+  {
+    if ( it != lines.begin() )
+      wrapped += lineBreak;
+
+    const std::string &line = *it;
+    unsigned int index =0;
+    while ( index < line.length() )
+    {
+      std::string lineSlice( line.substr( index, wrapColumn ) );
+      wrapped += lineSlice;
+      index += wrapColumn;
+      if ( index < line.length() )
+        wrapped += lineBreak;
+    }
+  }
+
+  return wrapped;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/SynchronizedObject.cpp b/src/test/cppunit/SynchronizedObject.cpp
new file mode 100644
index 0000000..cea6653
--- /dev/null
+++ b/src/test/cppunit/SynchronizedObject.cpp
@@ -0,0 +1,32 @@
+#include <cppunit/SynchronizedObject.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+SynchronizedObject::SynchronizedObject( SynchronizationObject *syncObject )
+    : m_syncObject( syncObject == 0 ? new SynchronizationObject() :
+                                      syncObject )
+{
+}
+
+
+SynchronizedObject::~SynchronizedObject()
+{
+  delete m_syncObject;
+}
+
+
+/** Accept a new synchronization object for protection of this instance
+ * TestResult assumes ownership of the object
+ */
+void
+SynchronizedObject::setSynchronizationObject( SynchronizationObject *syncObject )
+{
+  delete m_syncObject;
+  m_syncObject = syncObject;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/SynchronizedObject.h b/src/test/cppunit/SynchronizedObject.h
new file mode 100644
index 0000000..d697d1d
--- /dev/null
+++ b/src/test/cppunit/SynchronizedObject.h
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_SYNCHRONIZEDOBJECT_H
+#define CPPUNIT_SYNCHRONIZEDOBJECT_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Base class for synchronized object.
+ *
+ * Synchronized object are object which members are used concurrently by mutiple
+ * threads.
+ *
+ * This class define the class SynchronizationObject which must be subclassed
+ * to implement an actual lock.
+ *
+ * Each instance of this class holds a pointer on a lock object.
+ *
+ * See src/msvc6/MfcSynchronizedObject.h for an example.
+ */
+class CPPUNIT_API SynchronizedObject
+{
+public:
+  /*! \brief Abstract synchronization object (mutex)
+   */
+  class SynchronizationObject
+  {
+    public:
+      SynchronizationObject() {}
+      virtual ~SynchronizationObject() {}
+
+      virtual void lock() {}
+      virtual void unlock() {}
+  };
+
+  /*! Constructs a SynchronizedObject object.
+   */
+  SynchronizedObject( SynchronizationObject *syncObject =0 );
+
+  /// Destructor.
+  virtual ~SynchronizedObject();
+
+protected:
+  /*! \brief Locks a synchronization object in the current scope.
+   */
+  class ExclusiveZone
+  {
+    SynchronizationObject *m_syncObject;
+
+  public:
+    ExclusiveZone( SynchronizationObject *syncObject )
+        : m_syncObject( syncObject )
+    {
+      m_syncObject->lock();
+    }
+
+    ~ExclusiveZone()
+    {
+      m_syncObject->unlock ();
+    }
+  };
+
+  virtual void setSynchronizationObject( SynchronizationObject *syncObject );
+
+protected:
+  SynchronizationObject *m_syncObject;
+
+private:
+  /// Prevents the use of the copy constructor.
+  SynchronizedObject( const SynchronizedObject &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const SynchronizedObject &copy );
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_SYNCHRONIZEDOBJECT_H
diff --git a/src/test/cppunit/Test.cpp b/src/test/cppunit/Test.cpp
new file mode 100644
index 0000000..e477244
--- /dev/null
+++ b/src/test/cppunit/Test.cpp
@@ -0,0 +1,97 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+Test *
+Test::getChildTestAt( int index ) const
+{
+  checkIsValidIndex( index );
+  return doGetChildTestAt( index );
+}
+
+
+Test *
+Test::findTest( const std::string &testName ) const
+{
+  TestPath path;
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  mutableThis->findTestPath( testName, path );
+  if ( !path.isValid() )
+    throw std::invalid_argument( "No test named <" + testName + "> found in test <"
+                                 + getName() + ">." );
+  return path.getChildTest();
+}
+
+
+bool
+Test::findTestPath( const std::string &testName,
+                    TestPath &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  if ( getName() == testName )
+  {
+    testPath.add( mutableThis );
+    return true;
+  }
+
+  int childCount = getChildTestCount();
+  for ( int childIndex =0; childIndex < childCount; ++childIndex )
+  {
+    if ( getChildTestAt( childIndex )->findTestPath( testName, testPath ) )
+    {
+      testPath.insert( mutableThis, 0 );
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+bool
+Test::findTestPath( const Test *test,
+                    TestPath &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  if ( this == test )
+  {
+    testPath.add( mutableThis );
+    return true;
+  }
+
+  int childCount = getChildTestCount();
+  for ( int childIndex =0; childIndex < childCount; ++childIndex )
+  {
+    if ( getChildTestAt( childIndex )->findTestPath( test, testPath ) )
+    {
+      testPath.insert( mutableThis, 0 );
+      return true;
+    }
+  }
+
+  return false;
+}
+
+
+TestPath
+Test::resolveTestPath( const std::string &testPath ) const
+{
+  Test *mutableThis = CPPUNIT_CONST_CAST( Test *, this );
+  return TestPath( mutableThis, testPath );
+}
+
+
+void
+Test::checkIsValidIndex( int index ) const
+{
+  if ( index < 0  ||  index >= getChildTestCount() )
+    throw std::out_of_range( "Test::checkValidIndex(): invalid index" );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/Test.h b/src/test/cppunit/Test.h
new file mode 100644
index 0000000..78a67c3
--- /dev/null
+++ b/src/test/cppunit/Test.h
@@ -0,0 +1,117 @@
+#ifndef CPPUNIT_TEST_H
+#define CPPUNIT_TEST_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+class TestPath;
+
+/*! \brief Base class for all test objects.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * All test objects should be a subclass of Test.  Some test objects,
+ * TestCase for example, represent one individual test.  Other test
+ * objects, such as TestSuite, are comprised of several tests.
+ *
+ * When a Test is run, the result is collected by a TestResult object.
+ *
+ * \see TestCase
+ * \see TestSuite
+ */
+class CPPUNIT_API Test
+{
+public:
+  virtual ~Test() {};
+
+  /*! \brief Run the test, collecting results.
+   */
+  virtual void run( TestResult *result ) =0;
+
+  /*! \brief Return the number of test cases invoked by run().
+   *
+   * The base unit of testing is the class TestCase.  This
+   * method returns the number of TestCase objects invoked by
+   * the run() method.
+   */
+  virtual int countTestCases () const =0;
+
+  /*! \brief Returns the number of direct child of the test.
+   */
+  virtual int getChildTestCount() const =0;
+
+  /*! \brief Returns the child test of the specified index.
+   *
+   * This method test if the index is valid, then call doGetChildTestAt() if
+   * the index is valid. Otherwise std::out_of_range exception is thrown.
+   *
+   * You should override doGetChildTestAt() method.
+   *
+   * \param index Zero based index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual Test *getChildTestAt( int index ) const;
+
+  /*! \brief Returns the test name.
+   *
+   * Each test has a name.  This name may be used to find the
+   * test in a suite or registry of tests.
+   */
+  virtual std::string getName () const =0;
+
+  /*! \brief Finds the test with the specified name and its parents test.
+   * \param testName Name of the test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if a test with the specified name is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const std::string &testName,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the specified test and its parents test.
+   * \param test Test to find.
+   * \param testPath If the test is found, then all the tests traversed to access
+   *                 \a test are added to \a testPath, including \c this and \a test.
+   * \return \c true if the specified test is found, \c false otherwise.
+   */
+  virtual bool findTestPath( const Test *test,
+                             TestPath &testPath ) const;
+
+  /*! \brief Finds the test with the specified name in the hierarchy.
+   * \param testName Name of the test to find.
+   * \return Pointer on the first test found that is named \a testName. Never \c NULL.
+   * \exception std::invalid_argument if no test named \a testName is found.
+   */
+  virtual Test *findTest( const std::string &testName ) const;
+
+  /*! \brief Resolved the specified test path with this test acting as 'root'.
+   * \param testPath Test path string to resolve.
+   * \return Resolved TestPath.
+   * \exception std::invalid_argument if \a testPath could not be resolved.
+   * \see TestPath.
+   */
+  virtual TestPath resolveTestPath( const std::string &testPath ) const;
+
+protected:
+  /*! Throws an exception if the specified index is invalid.
+   * \param index Zero base index of a child test.
+   * \exception std::out_of_range is \a index is < 0 or >= getChildTestCount().
+   */
+  virtual void checkIsValidIndex( int index ) const;
+
+  /*! \brief Returns the child test of the specified valid index.
+   * \param index Zero based valid index of the child test to return.
+   * \return Pointer on the test. Never \c NULL.
+   */
+  virtual Test *doGetChildTestAt( int index ) const =0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEST_H
+
diff --git a/src/test/cppunit/TestAssert.cpp b/src/test/cppunit/TestAssert.cpp
new file mode 100644
index 0000000..be81d80
--- /dev/null
+++ b/src/test/cppunit/TestAssert.cpp
@@ -0,0 +1,46 @@
+#include <cppunit/TestAssert.h>
+#include <cppunit/portability/FloatingPoint.h>
+
+CPPUNIT_NS_BEGIN
+
+
+void
+assertDoubleEquals( double expected,
+                    double actual,
+                    double delta,
+                    SourceLine sourceLine,
+                    const std::string &message )
+{
+  AdditionalMessage msg( "Delta   : " +
+                         assertion_traits<double>::toString(delta) );
+  msg.addDetail( AdditionalMessage(message) );
+
+  bool equal;
+  if ( floatingPointIsFinite(expected)  &&  floatingPointIsFinite(actual) )
+      equal = fabs( expected - actual ) <= delta;
+  else
+  {
+    // If expected or actual is not finite, it may be +inf, -inf or NaN (Not a Number).
+    // Value of +inf or -inf leads to a true equality regardless of delta if both
+    // expected and actual have the same value (infinity sign).
+    // NaN Value should always lead to a failed equality.
+    if ( floatingPointIsUnordered(expected)  ||  floatingPointIsUnordered(actual) )
+    {
+       equal = false;  // expected or actual is a NaN
+    }
+    else // ordered values, +inf or -inf comparison
+    {
+       equal = expected == actual;
+    }
+  }
+
+  Asserter::failNotEqualIf( !equal,
+                            assertion_traits<double>::toString(expected),
+                            assertion_traits<double>::toString(actual),
+                            sourceLine,
+                            msg,
+                            "double equality assertion failed" );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestAssert.h b/src/test/cppunit/TestAssert.h
new file mode 100644
index 0000000..a78924a
--- /dev/null
+++ b/src/test/cppunit/TestAssert.h
@@ -0,0 +1,428 @@
+#ifndef CPPUNIT_TESTASSERT_H
+#define CPPUNIT_TESTASSERT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Asserter.h>
+#include <cppunit/portability/Stream.h>
+#include <stdio.h>
+#include <float.h> // For struct assertion_traits<double>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Traits used by CPPUNIT_ASSERT_EQUAL().
+ *
+ * Here is an example of specialising these traits:
+ *
+ * \code
+ * template<>
+ * struct assertion_traits<std::string>   // specialization for the std::string type
+ * {
+ *   static bool equal( const std::string& x, const std::string& y )
+ *   {
+ *     return x == y;
+ *   }
+ *
+ *   static std::string toString( const std::string& x )
+ *   {
+ *     std::string text = '"' + x + '"';    // adds quote around the string to see whitespace
+ *     OStringStream ost;
+ *     ost << text;
+ *     return ost.str();
+ *   }
+ * };
+ * \endcode
+ */
+template <class T>
+struct assertion_traits
+{
+    static bool equal( const T& x, const T& y )
+    {
+        return x == y;
+    }
+
+    static std::string toString( const T& x )
+    {
+        OStringStream ost;
+        ost << x;
+        return ost.str();
+    }
+};
+
+
+/*! \brief Traits used by CPPUNIT_ASSERT_DOUBLES_EQUAL().
+ *
+ * This specialisation from @c struct @c assertion_traits<> ensures that
+ * doubles are converted in full, instead of being rounded to the default
+ * 6 digits of precision. Use the system defined ISO C99 macro DBL_DIG
+ * within float.h is available to define the maximum precision, otherwise
+ * use the hard-coded maximum precision of 15.
+ */
+template <>
+struct assertion_traits<double>
+{
+    static bool equal( double x, double y )
+    {
+        return x == y;
+    }
+
+    static std::string toString( double x )
+    {
+#ifdef DBL_DIG
+       const int precision = DBL_DIG;
+#else
+       const int precision = 15;
+#endif  // #ifdef DBL_DIG
+       char buffer[128];
+#ifdef __STDC_SECURE_LIB__ // Use secure version with visual studio 2005 to avoid warning.
+       sprintf_s(buffer, sizeof(buffer), "%.*g", precision, x);
+#else
+       sprintf(buffer, "%.*g", precision, x);
+#endif
+       return buffer;
+    }
+};
+
+
+/*! \brief (Implementation) Asserts that two objects of the same type are equals.
+ * Use CPPUNIT_ASSERT_EQUAL instead of this function.
+ * \sa assertion_traits, Asserter::failNotEqual().
+ */
+template <class T>
+void assertEquals( const T& expected,
+                   const T& actual,
+                   SourceLine sourceLine,
+                   const std::string &message )
+{
+  if ( !assertion_traits<T>::equal(expected,actual) ) // lazy toString conversion...
+  {
+    Asserter::failNotEqual( assertion_traits<T>::toString(expected),
+                            assertion_traits<T>::toString(actual),
+                            sourceLine,
+                            message );
+  }
+}
+
+
+/*! \brief (Implementation) Asserts that two double are equals given a tolerance.
+ * Use CPPUNIT_ASSERT_DOUBLES_EQUAL instead of this function.
+ * \sa Asserter::failNotEqual().
+ * \sa CPPUNIT_ASSERT_DOUBLES_EQUAL for detailed semantic of the assertion.
+ */
+void CPPUNIT_API assertDoubleEquals( double expected,
+                                     double actual,
+                                     double delta,
+                                     SourceLine sourceLine,
+                                     const std::string &message );
+
+
+/* A set of macros which allow us to get the line number
+ * and file name at the point of an error.
+ * Just goes to show that preprocessors do have some
+ * redeeming qualities.
+ */
+#if CPPUNIT_HAVE_CPP_SOURCE_ANNOTATION
+/** Assertions that a condition is \c true.
+ * \ingroup Assertions
+ */
+#define CPPUNIT_ASSERT(condition)                                                 \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                                   \
+                                 CPPUNIT_NS::Message( "assertion failed",         \
+                                                      "Expression: " #condition), \
+                                 CPPUNIT_SOURCELINE() ) )
+#else
+#define CPPUNIT_ASSERT(condition)                                            \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                              \
+                                  CPPUNIT_NS::Message( "assertion failed" ), \
+                                  CPPUNIT_SOURCELINE() ) )
+#endif
+
+/** Assertion with a user specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic if \a condition evaluates
+ *                to \c false.
+ * \param condition If this condition evaluates to \c false then the
+ *                  test failed.
+ */
+#define CPPUNIT_ASSERT_MESSAGE(message,condition)                          \
+  ( CPPUNIT_NS::Asserter::failIf( !(condition),                            \
+                                  CPPUNIT_NS::Message( "assertion failed", \
+                                                       "Expression: "      \
+                                                       #condition,         \
+                                                       message ),          \
+                                  CPPUNIT_SOURCELINE() ) )
+
+/** Fails with the specified message.
+ * \ingroup Assertions
+ * \param message Message reported in diagnostic.
+ */
+#define CPPUNIT_FAIL( message )                                         \
+  ( CPPUNIT_NS::Asserter::fail( CPPUNIT_NS::Message( "forced failure",  \
+                                                     message ),         \
+                                CPPUNIT_SOURCELINE() ) )
+
+#ifdef CPPUNIT_ENABLE_SOURCELINE_DEPRECATED
+/// Generalized macro for primitive value comparisons
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)                     \
+  ( CPPUNIT_NS::assertEquals( (expected),             \
+                              (actual),               \
+                              __LINE__, __FILE__ ) )
+#else
+/** Asserts that two values are equals.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate CppUnit::assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==.
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL(expected,actual)          \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              "" ) )
+
+/** Asserts that two values are equals, provides additional message on failure.
+ * \ingroup Assertions
+ *
+ * Equality and string representation can be defined with
+ * an appropriate assertion_traits class.
+ *
+ * A diagnostic is printed if actual and expected values disagree.
+ * The message is printed in addition to the expected and actual value
+ * to provide additional information.
+ *
+ * Requirement for \a expected and \a actual parameters:
+ * - They are exactly of the same type
+ * - They are serializable into a std::strstream using operator <<.
+ * - They can be compared using operator ==.
+ *
+ * The last two requirements (serialization and comparison) can be
+ * removed by specializing the CppUnit::assertion_traits.
+ */
+#define CPPUNIT_ASSERT_EQUAL_MESSAGE(message,expected,actual)      \
+  ( CPPUNIT_NS::assertEquals( (expected),              \
+                              (actual),                \
+                              CPPUNIT_SOURCELINE(),    \
+                              (message) ) )
+#endif
+
+/*! \brief Macro for primitive double value comparisons.
+ * \ingroup Assertions
+ *
+ * The assertion pass if both expected and actual are finite and
+ * \c fabs( \c expected - \c actual ) <= \c delta.
+ * If either \c expected or actual are infinite (+/- inf), the
+ * assertion pass if \c expected == \c actual.
+ * If either \c expected or \c actual is a NaN (not a number), then
+ * the assertion fails.
+ */
+#define CPPUNIT_ASSERT_DOUBLES_EQUAL(expected,actual,delta)        \
+  ( CPPUNIT_NS::assertDoubleEquals( (expected),            \
+                                    (actual),              \
+                                    (delta),               \
+                                    CPPUNIT_SOURCELINE(),  \
+                                    "" ) )
+
+
+/*! \brief Macro for primitive double value comparisons, setting a
+ * user-supplied message in case of failure.
+ * \ingroup Assertions
+ * \sa CPPUNIT_ASSERT_DOUBLES_EQUAL for detailed semantic of the assertion.
+ */
+#define CPPUNIT_ASSERT_DOUBLES_EQUAL_MESSAGE(message,expected,actual,delta)  \
+  ( CPPUNIT_NS::assertDoubleEquals( (expected),            \
+                                    (actual),              \
+                                    (delta),               \
+                                    CPPUNIT_SOURCELINE(),  \
+                                    (message) ) )
+
+
+/** Asserts that the given expression throws an exception of the specified type.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *  CPPUNIT_ASSERT_THROW( v.at( 50 ), std::out_of_range );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_THROW( expression, ExceptionType )              \
+   CPPUNIT_ASSERT_THROW_MESSAGE( CPPUNIT_NS::AdditionalMessage(),       \
+                                 expression,                            \
+                                 ExceptionType )
+
+
+// implementation detail
+#if CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   CPPUNIT_NS::TypeInfoHelper::getClassName( typeid(exception) )
+#else
+#define CPPUNIT_EXTRACT_EXCEPTION_TYPE_( exception, no_rtti_message ) \
+   std::string( no_rtti_message )
+#endif // CPPUNIT_USE_TYPEINFO_NAME
+
+// implementation detail
+#define CPPUNIT_GET_PARAMETER_STRING( parameter ) #parameter
+
+/** Asserts that the given expression throws an exception of the specified type,
+ * setting a user supplied message in case of failure.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *  CPPUNIT_ASSERT_THROW_MESSAGE( "- std::vector<int> v;", v.at( 50 ), std::out_of_range );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_THROW_MESSAGE( message, expression, ExceptionType )   \
+   do {                                                                       \
+      bool cpputCorrectExceptionThrown_ = false;                              \
+      CPPUNIT_NS::Message cpputMsg_( "expected exception not thrown" );       \
+      cpputMsg_.addDetail( message );                                         \
+      cpputMsg_.addDetail( "Expected: "                                       \
+                           CPPUNIT_GET_PARAMETER_STRING( ExceptionType ) );   \
+                                                                              \
+      try {                                                                   \
+         expression;                                                          \
+      } catch ( const ExceptionType & ) {                                     \
+         cpputCorrectExceptionThrown_ = true;                                 \
+      } catch ( const std::exception &e) {                                    \
+         cpputMsg_.addDetail( "Actual  : " +                                  \
+                              CPPUNIT_EXTRACT_EXCEPTION_TYPE_( e,             \
+                                          "std::exception or derived") );     \
+         cpputMsg_.addDetail( std::string("What()  : ") + e.what() );         \
+      } catch ( ... ) {                                                       \
+         cpputMsg_.addDetail( "Actual  : unknown.");                          \
+      }                                                                       \
+                                                                              \
+      if ( cpputCorrectExceptionThrown_ )                                     \
+         break;                                                               \
+                                                                              \
+      CPPUNIT_NS::Asserter::fail( cpputMsg_,                                  \
+                                  CPPUNIT_SOURCELINE() );                     \
+   } while ( false )
+
+
+/** Asserts that the given expression does not throw any exceptions.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *   v.push_back( 10 );
+ *  CPPUNIT_ASSERT_NO_THROW( v.at( 0 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_NO_THROW( expression )                             \
+   CPPUNIT_ASSERT_NO_THROW_MESSAGE( CPPUNIT_NS::AdditionalMessage(),       \
+                                    expression )
+
+
+/** Asserts that the given expression does not throw any exceptions,
+ * setting a user supplied message in case of failure.
+ * \ingroup Assertions
+ * Example of usage:
+ * \code
+ *   std::vector<int> v;
+ *   v.push_back( 10 );
+ *  CPPUNIT_ASSERT_NO_THROW( "std::vector<int> v;", v.at( 0 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_NO_THROW_MESSAGE( message, expression )               \
+   do {                                                                       \
+      CPPUNIT_NS::Message cpputMsg_( "unexpected exception caught" );         \
+      cpputMsg_.addDetail( message );                                         \
+                                                                              \
+      try {                                                                   \
+         expression;                                                          \
+      } catch ( const std::exception &e ) {                                   \
+         cpputMsg_.addDetail( "Caught: " +                                    \
+                              CPPUNIT_EXTRACT_EXCEPTION_TYPE_( e,             \
+                                          "std::exception or derived" ) );    \
+         cpputMsg_.addDetail( std::string("What(): ") + e.what() );           \
+         CPPUNIT_NS::Asserter::fail( cpputMsg_,                               \
+                                     CPPUNIT_SOURCELINE() );                  \
+      } catch ( ... ) {                                                       \
+         cpputMsg_.addDetail( "Caught: unknown." );                           \
+         CPPUNIT_NS::Asserter::fail( cpputMsg_,                               \
+                                     CPPUNIT_SOURCELINE() );                  \
+      }                                                                       \
+   } while ( false )
+
+
+/** Asserts that an assertion fail.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_FAIL( CPPUNIT_ASSERT( 1 == 2 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_FAIL( assertion )                 \
+   CPPUNIT_ASSERT_THROW( assertion, CPPUNIT_NS::Exception )
+
+
+/** Asserts that an assertion fail, with a user-supplied message in
+ * case of error.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_FAIL_MESSAGE( "1 == 2", CPPUNIT_ASSERT( 1 == 2 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_FAIL_MESSAGE( message, assertion )    \
+   CPPUNIT_ASSERT_THROW_MESSAGE( message, assertion, CPPUNIT_NS::Exception )
+
+
+/** Asserts that an assertion pass.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_PASS( CPPUNIT_ASSERT( 1 == 1 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_PASS( assertion )                 \
+   CPPUNIT_ASSERT_NO_THROW( assertion )
+
+
+/** Asserts that an assertion pass, with a user-supplied message in
+ * case of failure.
+ * \ingroup Assertions
+ * Use to test assertions.
+ * Example of usage:
+ * \code
+ *   CPPUNIT_ASSERT_ASSERTION_PASS_MESSAGE( "1 != 1", CPPUNIT_ASSERT( 1 == 1 ) );
+ * \endcode
+ */
+# define CPPUNIT_ASSERT_ASSERTION_PASS_MESSAGE( message, assertion )    \
+   CPPUNIT_ASSERT_NO_THROW_MESSAGE( message, assertion )
+
+
+
+
+// Backwards compatibility
+
+#if CPPUNIT_ENABLE_NAKED_ASSERT
+
+#undef assert
+#define assert(c)                 CPPUNIT_ASSERT(c)
+#define assertEqual(e,a)          CPPUNIT_ASSERT_EQUAL(e,a)
+#define assertDoublesEqual(e,a,d) CPPUNIT_ASSERT_DOUBLES_EQUAL(e,a,d)
+#define assertLongsEqual(e,a)     CPPUNIT_ASSERT_EQUAL(e,a)
+
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTASSERT_H
diff --git a/src/test/cppunit/TestCaller.h b/src/test/cppunit/TestCaller.h
new file mode 100644
index 0000000..204f43f
--- /dev/null
+++ b/src/test/cppunit/TestCaller.h
@@ -0,0 +1,204 @@
+#ifndef CPPUNIT_TESTCALLER_H    // -*- C++ -*-
+#define CPPUNIT_TESTCALLER_H
+
+#include <cppunit/Exception.h>
+#include <cppunit/TestCase.h>
+
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  include <cppunit/extensions/TypeInfoHelper.h>
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+#if 0
+/*! \brief Marker class indicating that no exception is expected by TestCaller.
+ * This class is an implementation detail. You should never use this class directly.
+ */
+class CPPUNIT_API NoExceptionExpected
+{
+private:
+  //! Prevent class instantiation.
+  NoExceptionExpected();
+};
+
+
+/*! \brief (Implementation) Traits used by TestCaller to expect an exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<class ExceptionType>
+struct ExpectedExceptionTraits
+{
+  static void expectedException()
+  {
+#if CPPUNIT_USE_TYPEINFO_NAME
+    throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " +
+                           TypeInfoHelper::getClassName( typeid( ExceptionType ) ) ) );
+#else
+    throw Exception( "expected exception not thrown" );
+#endif
+  }
+};
+
+
+/*! \brief (Implementation) Traits specialization used by TestCaller to
+ * expect no exception.
+ *
+ * This class is an implementation detail. You should never use this class directly.
+ */
+template<>
+struct ExpectedExceptionTraits<NoExceptionExpected>
+{
+  static void expectedException()
+  {
+  }
+};
+
+
+#endif
+
+//*** FIXME: rework this when class Fixture is implemented. ***//
+
+
+/*! \brief Generate a test case from a fixture method.
+ * \ingroup WritingTestFixture
+ *
+ * A test caller provides access to a test case method
+ * on a test fixture class.  Test callers are useful when
+ * you want to run an individual test or add it to a
+ * suite.
+ * Test Callers invoke only one Test (i.e. test method) on one
+ * Fixture of a TestFixture.
+ *
+ * Here is an example:
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ *         ...
+ *     public:
+ *         void         setUp();
+ *         void         tearDown();
+ *
+ *         void         testAdd();
+ *         void         testSubtract();
+ * };
+ *
+ * CppUnit::Test *MathTest::suite() {
+ *     CppUnit::TestSuite *suite = new CppUnit::TestSuite;
+ *
+ *     suite->addTest( new CppUnit::TestCaller<MathTest>( "testAdd", testAdd ) );
+ *     return suite;
+ * }
+ * \endcode
+ *
+ * You can use a TestCaller to bind any test method on a TestFixture
+ * class, as long as it accepts void and returns void.
+ *
+ * \see TestCase
+ */
+
+template <class Fixture>
+class TestCaller : public TestCase
+{
+  typedef void (Fixture::*TestMethod)();
+
+public:
+  /*!
+   * Constructor for TestCaller. This constructor builds a new Fixture
+   * instance owned by the TestCaller.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   */
+  TestCaller( std::string name, TestMethod test ) :
+	    TestCase( name ),
+	    m_ownFixture( true ),
+	    m_fixture( new Fixture() ),
+	    m_test( test )
+  {
+  }
+
+  /*!
+   * Constructor for TestCaller.
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will not own the
+   * Fixture object.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture& fixture) :
+	    TestCase( name ),
+	    m_ownFixture( false ),
+	    m_fixture( &fixture ),
+	    m_test( test )
+  {
+  }
+
+  /*!
+   * Constructor for TestCaller.
+   * This constructor does not create a new Fixture instance but accepts
+   * an existing one as parameter. The TestCaller will own the
+   * Fixture object and delete it in its destructor.
+   * \param name name of this TestCaller
+   * \param test the method this TestCaller calls in runTest()
+   * \param fixture the Fixture to invoke the test method on.
+   */
+  TestCaller(std::string name, TestMethod test, Fixture* fixture) :
+	    TestCase( name ),
+	    m_ownFixture( true ),
+	    m_fixture( fixture ),
+	    m_test( test )
+  {
+  }
+
+  ~TestCaller()
+  {
+    if (m_ownFixture)
+      delete m_fixture;
+  }
+
+  void runTest()
+  {
+//	  try {
+	    (m_fixture->*m_test)();
+//	  }
+//	  catch ( ExpectedException & ) {
+//	    return;
+//	  }
+
+//  	ExpectedExceptionTraits<ExpectedException>::expectedException();
+  }
+
+  void setUp()
+  {
+  	m_fixture->setUp ();
+  }
+
+  void tearDown()
+  {
+	  m_fixture->tearDown ();
+  }
+
+  std::string toString() const
+  {
+  	return "TestCaller " + getName();
+  }
+
+private:
+  TestCaller( const TestCaller &other );
+  TestCaller &operator =( const TestCaller &other );
+
+private:
+  bool m_ownFixture;
+  Fixture *m_fixture;
+  TestMethod m_test;
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCALLER_H
diff --git a/src/test/cppunit/TestCase.cpp b/src/test/cppunit/TestCase.cpp
new file mode 100644
index 0000000..8ef3938
--- /dev/null
+++ b/src/test/cppunit/TestCase.cpp
@@ -0,0 +1,137 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/Protector.h>
+#include <cppunit/TestCase.h>
+#include <cppunit/TestResult.h>
+#include <stdexcept>
+
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  include <typeinfo>
+#endif
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Functor to call test case method (Implementation).
+ *
+ * Implementation detail.
+ */
+class TestCaseMethodFunctor : public Functor
+{
+public:
+  typedef void (TestCase::*Method)();
+
+  TestCaseMethodFunctor( TestCase *target,
+                         Method method )
+     : m_target( target )
+     , m_method( method )
+  {
+  }
+
+  bool operator()() const
+  {
+    (m_target->*m_method)();
+    return true;
+  }
+
+private:
+  TestCase *m_target;
+  Method m_method;
+};
+
+
+/** Constructs a test case.
+ *  \param name the name of the TestCase.
+ **/
+TestCase::TestCase( const std::string &name )
+    : m_name(name)
+{
+}
+
+
+/// Run the test and catch any exceptions that are triggered by it
+void
+TestCase::run( TestResult *result )
+{
+  result->startTest(this);
+/*
+  try {
+    setUp();
+
+    try {
+      runTest();
+    }
+    catch ( Exception &e ) {
+      Exception *copy = e.clone();
+      result->addFailure( this, copy );
+    }
+    catch ( std::exception &e ) {
+      result->addError( this, new Exception( Message( "uncaught std::exception",
+                                                      e.what() ) ) );
+    }
+    catch (...) {
+      Exception *e = new Exception( Message( "uncaught unknown exception" ) );
+      result->addError( this, e );
+    }
+
+    try {
+      tearDown();
+    }
+    catch (...) {
+      result->addError( this, new Exception( Message( "tearDown() failed" ) ) );
+    }
+  }
+  catch (...) {
+    result->addError( this, new Exception( Message( "setUp() failed" ) ) );
+  }
+*/
+  if ( result->protect( TestCaseMethodFunctor( this, &TestCase::setUp ),
+                        this,
+                       "setUp() failed" ) )
+  {
+    result->protect( TestCaseMethodFunctor( this, &TestCase::runTest ),
+                     this );
+  }
+
+  result->protect( TestCaseMethodFunctor( this, &TestCase::tearDown ),
+                   this,
+                   "tearDown() failed" );
+
+  result->endTest( this );
+}
+
+
+/// All the work for runTest is deferred to subclasses
+void
+TestCase::runTest()
+{
+}
+
+
+/** Constructs a test case for a suite.
+ * \deprecated This constructor was used by fixture when TestFixture did not exist.
+ *             Have your fixture inherits TestFixture instead of TestCase.
+ * \internal
+ *  This TestCase was intended for use by the TestCaller and should not
+ *  be used by a test case for which run() is called.
+ **/
+TestCase::TestCase()
+    : m_name( "" )
+{
+}
+
+
+/// Destructs a test case
+TestCase::~TestCase()
+{
+}
+
+
+/// Returns the name of the test case
+std::string
+TestCase::getName() const
+{
+  return m_name;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestCase.h b/src/test/cppunit/TestCase.h
new file mode 100644
index 0000000..f1d8067
--- /dev/null
+++ b/src/test/cppunit/TestCase.h
@@ -0,0 +1,55 @@
+#ifndef CPPUNIT_TESTCASE_H
+#define CPPUNIT_TESTCASE_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestLeaf.h>
+#include <cppunit/TestAssert.h>
+#include <cppunit/TestFixture.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief A single test object.
+ *
+ * This class is used to implement a simple test case: define a subclass
+ * that overrides the runTest method.
+ *
+ * You don't usually need to use that class, but TestFixture and TestCaller instead.
+ *
+ * You are expected to subclass TestCase is you need to write a class similiar
+ * to TestCaller.
+ */
+class CPPUNIT_API TestCase : public TestLeaf,
+                             public TestFixture
+{
+public:
+
+    TestCase( const std::string &name );
+
+    TestCase();
+
+    ~TestCase();
+
+    virtual void run(TestResult *result);
+
+    std::string getName() const;
+
+    //! FIXME: this should probably be pure virtual.
+    virtual void runTest();
+
+private:
+    TestCase( const TestCase &other );
+    TestCase &operator=( const TestCase &other );
+
+private:
+    const std::string m_name;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCASE_H
diff --git a/src/test/cppunit/TestCaseDecorator.cpp b/src/test/cppunit/TestCaseDecorator.cpp
new file mode 100644
index 0000000..850d649
--- /dev/null
+++ b/src/test/cppunit/TestCaseDecorator.cpp
@@ -0,0 +1,47 @@
+#include <cppunit/extensions/TestCaseDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestCaseDecorator::TestCaseDecorator( TestCase *test )
+    : TestCase( test->getName() ),
+      m_test( test )
+{
+}
+
+
+TestCaseDecorator::~TestCaseDecorator()
+{
+  delete m_test;
+}
+
+
+std::string
+TestCaseDecorator::getName() const
+{
+  return m_test->getName();
+}
+
+
+void
+TestCaseDecorator::setUp()
+{
+  m_test->setUp();
+}
+
+
+void
+TestCaseDecorator::tearDown()
+{
+  m_test->tearDown();
+}
+
+
+void
+TestCaseDecorator::runTest()
+{
+  m_test->runTest();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestComposite.cpp b/src/test/cppunit/TestComposite.cpp
new file mode 100644
index 0000000..1f26be8
--- /dev/null
+++ b/src/test/cppunit/TestComposite.cpp
@@ -0,0 +1,77 @@
+#include <cppunit/TestComposite.h>
+#include <cppunit/TestResult.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestComposite::TestComposite( const std::string &name )
+    : m_name( name )
+{
+}
+
+
+TestComposite::~TestComposite()
+{
+}
+
+
+void
+TestComposite::run( TestResult *result )
+{
+  doStartSuite( result );
+  doRunChildTests( result );
+  doEndSuite( result );
+}
+
+
+int
+TestComposite::countTestCases() const
+{
+  int count = 0;
+
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+    count += getChildTestAt( index )->countTestCases();
+
+  return count;
+}
+
+
+std::string
+TestComposite::getName() const
+{
+  return m_name;
+}
+
+
+void
+TestComposite::doStartSuite( TestResult *controller )
+{
+  controller->startSuite( this );
+}
+
+
+void
+TestComposite::doRunChildTests( TestResult *controller )
+{
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+  {
+    if ( controller->shouldStop() )
+      break;
+
+    getChildTestAt( index )->run( controller );
+  }
+}
+
+
+void
+TestComposite::doEndSuite( TestResult *controller )
+{
+  controller->endSuite( this );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestComposite.h b/src/test/cppunit/TestComposite.h
new file mode 100644
index 0000000..e9fbfab
--- /dev/null
+++ b/src/test/cppunit/TestComposite.h
@@ -0,0 +1,45 @@
+#ifndef CPPUNIT_TESTCOMPSITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTCOMPSITE_H
+
+#include <cppunit/Test.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A Composite of Tests.
+ *
+ * Base class for all test composites. Subclass this class if you need to implement
+ * a custom TestSuite.
+ *
+ * \see Test, TestSuite.
+ */
+class CPPUNIT_API TestComposite : public Test
+{
+public:
+  TestComposite( const std::string &name = "" );
+
+  ~TestComposite();
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+
+  std::string getName() const;
+
+private:
+  TestComposite( const TestComposite &other );
+  TestComposite &operator =( const TestComposite &other );
+
+  virtual void doStartSuite( TestResult *controller );
+  virtual void doRunChildTests( TestResult *controller );
+  virtual void doEndSuite( TestResult *controller );
+
+private:
+  const std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTCOMPSITE_H
diff --git a/src/test/cppunit/TestDecorator.cpp b/src/test/cppunit/TestDecorator.cpp
new file mode 100644
index 0000000..701f7d8
--- /dev/null
+++ b/src/test/cppunit/TestDecorator.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestDecorator::TestDecorator( Test *test )
+    : m_test( test)
+{
+}
+
+
+TestDecorator::~TestDecorator()
+{
+  delete m_test;
+}
+
+
+int
+TestDecorator::countTestCases() const
+{
+  return m_test->countTestCases();
+}
+
+
+void
+TestDecorator::run( TestResult *result )
+{
+  m_test->run(result);
+}
+
+
+std::string
+TestDecorator::getName() const
+{
+  return m_test->getName();
+}
+
+
+int
+TestDecorator::getChildTestCount() const
+{
+  return m_test->getChildTestCount();
+}
+
+
+Test *
+TestDecorator::doGetChildTestAt( int index ) const
+{
+  return m_test->getChildTestAt( index );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFactoryRegistry.cpp b/src/test/cppunit/TestFactoryRegistry.cpp
new file mode 100644
index 0000000..ca42e7e
--- /dev/null
+++ b/src/test/cppunit/TestFactoryRegistry.cpp
@@ -0,0 +1,161 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <cppunit/TestSuite.h>
+#include <assert.h>
+
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief (INTERNAL) List of all TestFactoryRegistry.
+ */
+class TestFactoryRegistryList
+{
+private:
+  typedef CppUnitMap<std::string, TestFactoryRegistry *, std::less<std::string> > Registries;
+  Registries m_registries;
+
+  enum State {
+    doNotChange =0,
+    notCreated,
+    exist,
+    destroyed
+  };
+
+  static State stateFlag( State newState = doNotChange )
+  {
+    static State state = notCreated;
+    if ( newState != doNotChange )
+      state = newState;
+    return state;
+  }
+
+  static TestFactoryRegistryList *getInstance()
+  {
+    static TestFactoryRegistryList list;
+    return &list;
+  }
+
+  TestFactoryRegistry *getInternalRegistry( const std::string &name )
+  {
+    Registries::const_iterator foundIt = m_registries.find( name );
+    if ( foundIt == m_registries.end() )
+    {
+      TestFactoryRegistry *factory = new TestFactoryRegistry( name );
+      m_registries.insert( std::pair<const std::string, TestFactoryRegistry*>( name, factory ) );
+      return factory;
+    }
+    return (*foundIt).second;
+  }
+
+public:
+  TestFactoryRegistryList()
+  {
+    stateFlag( exist );
+  }
+
+  ~TestFactoryRegistryList()
+  {
+    for ( Registries::iterator it = m_registries.begin(); it != m_registries.end(); ++it )
+      delete (*it).second;
+
+    stateFlag( destroyed );
+  }
+
+  static TestFactoryRegistry *getRegistry( const std::string &name )
+  {
+    // If the following assertion failed, then TestFactoryRegistry::getRegistry()
+    // was called during static variable destruction without checking the registry
+    // validity beforehand using TestFactoryRegistry::isValid() beforehand.
+    assert( isValid() );
+    if ( !isValid() )         // release mode
+      return NULL;            // => force CRASH
+
+    return getInstance()->getInternalRegistry( name );
+  }
+
+  static bool isValid()
+  {
+    return stateFlag() != destroyed;
+  }
+};
+
+
+
+TestFactoryRegistry::TestFactoryRegistry( std::string name ) :
+    m_name( name )
+{
+}
+
+
+TestFactoryRegistry::~TestFactoryRegistry()
+{
+}
+
+
+TestFactoryRegistry &
+TestFactoryRegistry::getRegistry( const std::string &name )
+{
+  return *TestFactoryRegistryList::getRegistry( name );
+}
+
+
+void
+TestFactoryRegistry::registerFactory( const std::string &name,
+                                      TestFactory *factory )
+{
+  registerFactory( factory );
+}
+
+
+void
+TestFactoryRegistry::registerFactory( TestFactory *factory )
+{
+  m_factories.insert( factory );
+}
+
+
+void
+TestFactoryRegistry::unregisterFactory( TestFactory *factory )
+{
+  m_factories.erase( factory );
+}
+
+
+void
+TestFactoryRegistry::addRegistry( const std::string &name )
+{
+  registerFactory( &getRegistry( name ) );
+}
+
+
+Test *
+TestFactoryRegistry::makeTest()
+{
+  TestSuite *suite = new TestSuite( m_name );
+  addTestToSuite( suite );
+  return suite;
+}
+
+
+void
+TestFactoryRegistry::addTestToSuite( TestSuite *suite )
+{
+  for ( Factories::iterator it = m_factories.begin();
+        it != m_factories.end();
+        ++it )
+  {
+    TestFactory *factory = *it;
+    suite->addTest( factory->makeTest() );
+  }
+}
+
+
+bool
+TestFactoryRegistry::isValid()
+{
+  return TestFactoryRegistryList::isValid();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFailure.cpp b/src/test/cppunit/TestFailure.cpp
new file mode 100644
index 0000000..20a0ecf
--- /dev/null
+++ b/src/test/cppunit/TestFailure.cpp
@@ -0,0 +1,71 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/// Constructs a TestFailure with the given test and exception.
+TestFailure::TestFailure( Test *failedTest,
+                          Exception *thrownException,
+                          bool isError ) :
+    m_failedTest( failedTest ),
+    m_thrownException( thrownException ),
+    m_isError( isError )
+{
+}
+
+/// Deletes the owned exception.
+TestFailure::~TestFailure()
+{
+  delete m_thrownException;
+}
+
+/// Gets the failed test.
+Test *
+TestFailure::failedTest() const
+{
+  return m_failedTest;
+}
+
+
+/// Gets the thrown exception. Never \c NULL.
+Exception *
+TestFailure::thrownException() const
+{
+  return m_thrownException;
+}
+
+
+/// Gets the failure location.
+SourceLine
+TestFailure::sourceLine() const
+{
+  return m_thrownException->sourceLine();
+}
+
+
+/// Indicates if the failure is a failed assertion or an error.
+bool
+TestFailure::isError() const
+{
+  return m_isError;
+}
+
+
+/// Gets the name of the failed test.
+std::string
+TestFailure::failedTestName() const
+{
+  return m_failedTest->getName();
+}
+
+
+TestFailure *
+TestFailure::clone() const
+{
+  return new TestFailure( m_failedTest, m_thrownException->clone(), m_isError );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestFailure.h b/src/test/cppunit/TestFailure.h
new file mode 100644
index 0000000..1b8fc00
--- /dev/null
+++ b/src/test/cppunit/TestFailure.h
@@ -0,0 +1,58 @@
+#ifndef CPPUNIT_TESTFAILURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFAILURE_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class Test;
+
+
+/*! \brief Record of a failed Test execution.
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * A TestFailure collects a failed test together with
+ * the caught exception.
+ *
+ * TestFailure assumes lifetime control for any exception
+ * passed to it.
+ */
+class CPPUNIT_API TestFailure
+{
+public:
+  TestFailure( Test *failedTest,
+               Exception *thrownException,
+               bool isError );
+
+  virtual ~TestFailure ();
+
+  virtual Test *failedTest() const;
+
+  virtual Exception *thrownException() const;
+
+  virtual SourceLine sourceLine() const;
+
+  virtual bool isError() const;
+
+  virtual std::string failedTestName() const;
+
+  virtual TestFailure *clone() const;
+
+protected:
+  Test *m_failedTest;
+  Exception *m_thrownException;
+  bool m_isError;
+
+private:
+  TestFailure( const TestFailure &other );
+  TestFailure &operator =( const TestFailure& other );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTFAILURE_H
diff --git a/src/test/cppunit/TestFixture.h b/src/test/cppunit/TestFixture.h
new file mode 100644
index 0000000..a99c1d7
--- /dev/null
+++ b/src/test/cppunit/TestFixture.h
@@ -0,0 +1,99 @@
+#ifndef CPPUNIT_TESTFIXTURE_H    // -*- C++ -*-
+#define CPPUNIT_TESTFIXTURE_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Wraps a test case with setUp and tearDown methods.
+ * \ingroup WritingTestFixture
+ *
+ * A TestFixture is used to provide a common environment for a set
+ * of test cases.
+ *
+ * To define a test fixture, do the following:
+ * - implement a subclass of TestCase
+ * - the fixture is defined by instance variables
+ * - initialize the fixture state by overriding setUp
+ *   (i.e. construct the instance variables of the fixture)
+ * - clean-up after a test by overriding tearDown.
+ *
+ * Each test runs in its own fixture so there
+ * can be no side effects among test runs.
+ * Here is an example:
+ *
+ * \code
+ * class MathTest : public CppUnit::TestFixture {
+ * protected:
+ *   int m_value1, m_value2;
+ *
+ * public:
+ *   MathTest() {}
+ *
+ *   void setUp () {
+ *     m_value1 = 2;
+ *     m_value2 = 3;
+ *   }
+ * }
+ * \endcode
+ *
+ * For each test implement a method which interacts
+ * with the fixture. Verify the expected results with assertions specified
+ * by calling CPPUNIT_ASSERT on the expression you want to test:
+ *
+ * \code
+ * public:
+ *   void testAdd () {
+ *     int result = m_value1 + m_value2;
+ *     CPPUNIT_ASSERT( result == 5 );
+ *   }
+ * \endcode
+ *
+ * Once the methods are defined you can run them. To do this, use
+ * a TestCaller.
+ *
+ * \code
+ * CppUnit::Test *test = new CppUnit::TestCaller<MathTest>( "testAdd",
+ *                                                          &MathTest::testAdd );
+ * test->run();
+ * \endcode
+ *
+ *
+ * The tests to be run can be collected into a TestSuite.
+ *
+ * \code
+ * public:
+ *   static CppUnit::TestSuite *MathTest::suite () {
+ *      CppUnit::TestSuite *suiteOfTests = new CppUnit::TestSuite;
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testAdd", &MathTest::testAdd));
+ *      suiteOfTests->addTest(new CppUnit::TestCaller<MathTest>(
+ *                              "testDivideByZero", &MathTest::testDivideByZero));
+ *      return suiteOfTests;
+ *  }
+ * \endcode
+ *
+ * A set of macros have been created for convenience. They are located in HelperMacros.h.
+ *
+ * \see TestResult, TestSuite, TestCaller,
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END,
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+class CPPUNIT_API TestFixture
+{
+public:
+  virtual ~TestFixture() {};
+
+  //! \brief Set up context before running a test.
+  virtual void setUp() {};
+
+  //! Clean up after the test run.
+  virtual void tearDown() {};
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif
diff --git a/src/test/cppunit/TestLeaf.cpp b/src/test/cppunit/TestLeaf.cpp
new file mode 100644
index 0000000..be9d32d
--- /dev/null
+++ b/src/test/cppunit/TestLeaf.cpp
@@ -0,0 +1,28 @@
+#include <cppunit/TestLeaf.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+int
+TestLeaf::countTestCases() const
+{
+  return 1;
+}
+
+
+int
+TestLeaf::getChildTestCount() const
+{
+  return 0;
+}
+
+
+Test *
+TestLeaf::doGetChildTestAt( int index ) const
+{
+  checkIsValidIndex( index );
+  return NULL;    // never called, checkIsValidIndex() always throw.
+}
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestLeaf.h b/src/test/cppunit/TestLeaf.h
new file mode 100644
index 0000000..fb0a503
--- /dev/null
+++ b/src/test/cppunit/TestLeaf.h
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TESTLEAF_H
+#define CPPUNIT_TESTLEAF_H
+
+#include <cppunit/Test.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief A single test object.
+ *
+ * Base class for single test case: a test that doesn't have any children.
+ *
+ */
+class CPPUNIT_API TestLeaf: public Test
+{
+public:
+  /*! Returns 1 as the default number of test cases invoked by run().
+   *
+   * You may override this method when many test cases are invoked (RepeatedTest
+   * for example).
+   *
+   * \return 1.
+   * \see Test::countTestCases().
+   */
+  int countTestCases() const;
+
+  /*! Returns the number of child of this test case: 0.
+   *
+   * You should never override this method: a TestLeaf as no children by definition.
+   *
+   * \return 0.
+   */
+  int getChildTestCount() const;
+
+  /*! Always throws std::out_of_range.
+   * \see Test::doGetChildTestAt().
+   */
+  Test *doGetChildTestAt( int index ) const;
+};
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLEAF_H
diff --git a/src/test/cppunit/TestListener.h b/src/test/cppunit/TestListener.h
new file mode 100644
index 0000000..a6554e5
--- /dev/null
+++ b/src/test/cppunit/TestListener.h
@@ -0,0 +1,148 @@
+#ifndef CPPUNIT_TESTLISTENER_H    // -*- C++ -*-
+#define CPPUNIT_TESTLISTENER_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Test;
+class TestFailure;
+class TestResult;
+
+
+/*! \brief Listener for test progress and result.
+ * \ingroup TrackingTestExecution
+ *
+ * Implementing the Observer pattern a TestListener may be registered
+ * to a TestResult to obtain information on the testing progress. Use
+ * specialized sub classes of TestListener for text output
+ * (TextTestProgressListener). Do not use the Listener for the test
+ * result output, use a subclass of Outputter instead.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ *
+ * Here is an example to track test time:
+ *
+ *
+ * \code
+ * #include <cppunit/TestListener.h>
+ * #include <cppunit/Test.h>
+ * #include <time.h>    // for clock()
+ *
+ * class TimingListener : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.start();
+ *   }
+ *
+ *   void endTest( CppUnit::Test *test )
+ *   {
+ *     _chronometer.end();
+ *     addTest( test, _chronometer.elapsedTime() );
+ *   }
+ *
+ *   // ... (interface to add/read test timing result)
+ *
+ * private:
+ *   Clock _chronometer;
+ * };
+ * \endcode
+ *
+ * And another example that track failure/success at test suite level and captures
+ * the TestPath of each suite:
+ * \code
+ * class SuiteTracker : public CppUnit::TestListener
+ * {
+ * public:
+ *   void startSuite( CppUnit::Test *suite )
+ *   {
+ *     m_currentPath.add( suite );
+ *   }
+ *
+ *   void addFailure( const TestFailure &failure )
+ *   {
+ *     m_suiteFailure.top() = false;
+ *   }
+ *
+ *   void endSuite( CppUnit::Test *suite )
+ *   {
+ *     m_suiteStatus.insert( std::make_pair( suite, m_suiteFailure.top() ) );
+ *     m_suitePaths.insert( std::make_pair( suite, m_currentPath ) );
+ *
+ *     m_currentPath.up();
+ *     m_suiteFailure.pop();
+ *   }
+ *
+ * private:
+ *   std::stack<bool> m_suiteFailure;
+ *   CppUnit::TestPath m_currentPath;
+ *   std::map<CppUnit::Test *, bool> m_suiteStatus;
+ *   std::map<CppUnit::Test *, CppUnit::TestPath> m_suitePaths;
+ * };
+ * \endcode
+ *
+ * \see TestResult
+ */
+class CPPUNIT_API TestListener
+{
+public:
+  virtual ~TestListener() {}
+
+  /// Called when just before a TestCase is run.
+  virtual void startTest( Test * /*test*/ ) {}
+
+  /*! \brief Called when a failure occurs while running a test.
+   * \see TestFailure.
+   * \warning \a failure is a temporary object that is destroyed after the
+   *          method call. Use TestFailure::clone() to create a duplicate.
+   */
+  virtual void addFailure( const TestFailure & /*failure*/ ) {}
+
+  /// Called just after a TestCase was run (even if a failure occured).
+  virtual void endTest( Test * /*test*/ ) {}
+
+  /*! \brief Called by a TestComposite just before running its child tests.
+   */
+  virtual void startSuite( Test * /*suite*/ ) {}
+
+  /*! \brief Called by a TestComposite after running its child tests.
+   */
+  virtual void endSuite( Test * /*suite*/ ) {}
+
+  /*! \brief Called by a TestRunner before running the test.
+   *
+   * You can use this to do some global initialisation. A listener
+   * could also use to output a 'prolog' to the test run.
+   *
+   * \param test Test that is going to be run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void startTestRun( Test * /*test*/,
+                             TestResult * /*eventManager*/ ) {}
+
+  /*! \brief Called by a TestRunner after running the test.
+   *
+   * TextTestProgressListener use this to emit a line break. You can also use this
+   * to do some global uninitialisation.
+   *
+   * \param test Test that was run.
+   * \param eventManager Event manager used for the test run.
+   */
+  virtual void endTestRun( Test * /*test*/,
+                           TestResult * /*eventManager*/ ) {}
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTLISTENER_H
+
+
diff --git a/src/test/cppunit/TestNamer.cpp b/src/test/cppunit/TestNamer.cpp
new file mode 100644
index 0000000..4a6bb7e
--- /dev/null
+++ b/src/test/cppunit/TestNamer.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_HAVE_RTTI
+TestNamer::TestNamer( const std::type_info &typeInfo )
+{
+  m_fixtureName = TypeInfoHelper::getClassName( typeInfo );
+}
+#endif
+
+
+TestNamer::TestNamer( const std::string &fixtureName )
+  : m_fixtureName( fixtureName )
+{
+}
+
+
+TestNamer::~TestNamer()
+{
+}
+
+
+std::string
+TestNamer::getFixtureName() const
+{
+  return m_fixtureName;
+}
+
+
+std::string
+TestNamer::getTestNameFor( const std::string &testMethodName ) const
+{
+  return getFixtureName() + "::" + testMethodName;
+}
+
+
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestPath.cpp b/src/test/cppunit/TestPath.cpp
new file mode 100644
index 0000000..2cd19d9
--- /dev/null
+++ b/src/test/cppunit/TestPath.cpp
@@ -0,0 +1,254 @@
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestPath::TestPath()
+{
+}
+
+
+TestPath::TestPath( Test *root )
+{
+  add( root );
+}
+
+
+TestPath::TestPath( const TestPath &other,
+                    int indexFirst,
+                    int count )
+{
+  int countAdjustment = 0;
+  if ( indexFirst < 0 )
+  {
+    countAdjustment = indexFirst;
+    indexFirst = 0;
+  }
+
+  if ( count < 0 )
+    count = other.getTestCount();
+  else
+    count += countAdjustment;
+
+  int index = indexFirst;
+  while ( count-- > 0  &&  index < other.getTestCount() )
+    add( other.getTestAt( index++ ) );
+}
+
+
+TestPath::TestPath( Test *searchRoot,
+                    const std::string &pathAsString )
+{
+  PathTestNames testNames;
+
+  Test *parentTest = findActualRoot( searchRoot, pathAsString, testNames );
+  add( parentTest );
+
+  for ( unsigned int index = 1; index < testNames.size(); ++index )
+  {
+    bool childFound = false;
+    for ( int childIndex =0; childIndex < parentTest->getChildTestCount(); ++childIndex )
+    {
+      if ( parentTest->getChildTestAt( childIndex )->getName() == testNames[index] )
+      {
+        childFound = true;
+        parentTest = parentTest->getChildTestAt( childIndex );
+        break;
+      }
+    }
+
+    if ( !childFound )
+      throw std::invalid_argument( "TestPath::TestPath(): failed to resolve test name <"+
+                                   testNames[index] + "> of path <" + pathAsString + ">" );
+
+    add( parentTest );
+  }
+}
+
+
+TestPath::TestPath( const TestPath &other )
+  : m_tests( other.m_tests )
+{
+}
+
+
+TestPath::~TestPath()
+{
+}
+
+
+TestPath &
+TestPath::operator =( const TestPath &other )
+{
+  if ( &other != this )
+    m_tests = other.m_tests;
+  return *this;
+}
+
+
+bool
+TestPath::isValid() const
+{
+  return getTestCount() > 0;
+}
+
+
+void
+TestPath::add( Test *test )
+{
+  m_tests.push_back( test );
+}
+
+
+void
+TestPath::add( const TestPath &path )
+{
+  for ( int index =0; index < path.getTestCount(); ++index )
+    add( path.getTestAt( index ) );
+}
+
+
+void
+TestPath::insert( Test *test,
+                  int index )
+{
+  if ( index < 0  ||  index > getTestCount() )
+    throw std::out_of_range( "TestPath::insert(): index out of range" );
+  m_tests.insert( m_tests.begin() + index, test );
+}
+
+void
+TestPath::insert( const TestPath &path,
+                  int index )
+{
+  int itemIndex = path.getTestCount() -1;
+  while ( itemIndex >= 0 )
+    insert( path.getTestAt( itemIndex-- ), index );
+}
+
+
+void
+TestPath::removeTests()
+{
+  while ( isValid() )
+    removeTest( 0 );
+}
+
+
+void
+TestPath::removeTest( int index )
+{
+  checkIndexValid( index );
+  m_tests.erase( m_tests.begin() + index );
+}
+
+
+void
+TestPath::up()
+{
+  checkIndexValid( 0 );
+  removeTest( getTestCount() -1 );
+}
+
+
+int
+TestPath::getTestCount() const
+{
+  return m_tests.size();
+}
+
+
+Test *
+TestPath::getTestAt( int index ) const
+{
+  checkIndexValid( index );
+  return m_tests[index];
+}
+
+
+Test *
+TestPath::getChildTest() const
+{
+  return getTestAt( getTestCount() -1 );
+}
+
+
+void
+TestPath::checkIndexValid( int index ) const
+{
+  if ( index < 0  ||  index >= getTestCount() )
+    throw std::out_of_range( "TestPath::checkIndexValid(): index out of range" );
+}
+
+
+std::string
+TestPath::toString() const
+{
+  std::string asString( "/" );
+  for ( int index =0; index < getTestCount(); ++index )
+  {
+    if ( index > 0 )
+      asString += '/';
+    asString += getTestAt(index)->getName();
+  }
+
+  return asString;
+}
+
+
+Test *
+TestPath::findActualRoot( Test *searchRoot,
+                          const std::string &pathAsString,
+                          PathTestNames &testNames )
+{
+  bool isRelative = splitPathString( pathAsString, testNames );
+
+  if ( isRelative  &&  pathAsString.empty() )
+    return searchRoot;
+
+  if ( testNames.empty() )
+    throw std::invalid_argument( "TestPath::TestPath(): invalid root or root name in absolute path" );
+
+  Test *root = isRelative ? searchRoot->findTest( testNames[0] )  // throw if bad test name
+                          : searchRoot;
+  if ( root->getName() != testNames[0] )
+    throw std::invalid_argument( "TestPath::TestPath(): searchRoot does not match path root name" );
+
+  return root;
+}
+
+
+bool
+TestPath::splitPathString( const std::string &pathAsString,
+                           PathTestNames &testNames )
+{
+  if ( pathAsString.empty() )
+    return true;
+
+  bool isRelative = pathAsString[0] != '/';
+
+  int index = (isRelative ? 0 : 1);
+  while ( true )
+  {
+    int separatorIndex = pathAsString.find( '/', index );
+    if ( separatorIndex >= 0 )
+    {
+      testNames.push_back( pathAsString.substr( index, separatorIndex - index ) );
+      index = separatorIndex + 1;
+    }
+    else
+    {
+      testNames.push_back( pathAsString.substr( index ) );
+      break;
+    }
+  }
+
+  return isRelative;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestPath.h b/src/test/cppunit/TestPath.h
new file mode 100644
index 0000000..b4ca86e
--- /dev/null
+++ b/src/test/cppunit/TestPath.h
@@ -0,0 +1,211 @@
+#ifndef CPPUNIT_TESTPATH_H
+#define CPPUNIT_TESTPATH_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief A List of Test representing a path to access a Test.
+ * \ingroup ExecutingTest
+ *
+ * The path can be converted to a string and resolved from a string with toString()
+ * and TestPath( Test *root, const std::string &pathAsString ).
+ *
+ * Pointed tests are not owned by the class.
+ *
+ * \see Test::resolvedTestPath()
+ */
+class CPPUNIT_API TestPath
+{
+public:
+  /*! \brief Constructs an invalid path.
+   *
+   * The path is invalid until a test is added with add().
+   */
+  TestPath();
+
+  /*! \brief Constructs a valid path.
+   *
+   * \param root Test to add.
+   */
+  TestPath( Test *root );
+
+  /*! \brief Constructs a path using a slice of another path.
+   * \param otherPath Path the test are copied from.
+   * \param indexFirst Zero based index of the first test to copy. Adjusted to be in valid
+   *                   range. \a count is adjusted with \a indexFirst.
+   * \param count Number of tests to copy. If < 0 then all test starting from index
+   *              \a indexFirst are copied.
+   */
+  TestPath( const TestPath &otherPath,
+            int indexFirst,
+            int count = -1 );
+
+  /*! \brief Resolves a path from a string returned by toString().
+   *
+   * If \a pathAsString is an absolute path (begins with '/'), then the first test name
+   * of the path must be the name of \a searchRoot. Otherwise, \a pathAsString is a
+   * relative path, and the first test found using Test::findTest() matching the first
+   * test name is used as root. An empty string resolve to a path containing
+   * \a searchRoot.
+   *
+   * The resolved path is always valid.
+   *
+   * \param searchRoot Test used to resolve the path.
+   * \param pathAsString String that contains the path as a string created by toString().
+   * \exception std::invalid_argument if one of the test names can not be resolved.
+   * \see toString().
+   */
+  TestPath( Test *searchRoot,
+            const std::string &pathAsString );
+
+  /*! \brief Copy constructor.
+   * \param other Object to copy.
+   */
+  TestPath( const TestPath &other );
+
+  virtual ~TestPath();
+
+  /*! \brief Tests if the path contains at least one test.
+   * \return \c true if the path contains at least one test, otherwise returns \c false.
+   */
+  virtual bool isValid() const;
+
+  /*! \brief Adds a test to the path.
+   * \param test Pointer on the test to add. Must not be \c NULL.
+   */
+  virtual void add( Test *test );
+
+  /*! \brief Adds all the tests of the specified path.
+   * \param path Path that contains the test to add.
+   */
+  virtual void add( const TestPath &path );
+
+  /*! \brief Inserts a test at the specified index.
+   * \param test Pointer on the test to insert. Must not be \c NULL.
+   * \param index Zero based index indicating where the test is inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount().
+   */
+  virtual void insert( Test *test, int index );
+
+  /*! \brief Inserts all the tests at the specified path at a given index.
+   * \param path Path that contains the test to insert.
+   * \param index Zero based index indicating where the tests are inserted.
+   * \exception std::out_of_range is \a index < 0 or \a index > getTestCount(), and
+   *            \a path is valid.
+   */
+  virtual void insert( const TestPath &path, int index );
+
+  /*! \brief Removes all the test from the path.
+   *
+   * The path becomes invalid after this call.
+   */
+  virtual void removeTests();
+
+  /*! \brief Removes the test at the specified index of the path.
+   * \param index Zero based index of the test to remove.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual void removeTest( int index );
+
+  /*! \brief Removes the last test.
+   * \exception std::out_of_range is the path is invalid.
+   * \see isValid().
+   */
+  virtual void up();
+
+  /*! \brief Returns the number of tests in the path.
+   * \return Number of tests in the path.
+   */
+  virtual int getTestCount() const;
+
+  /*! \brief Returns the test of the specified index.
+   * \param index Zero based index of the test to return.
+   * \return Pointer on the test at index \a index. Never \c NULL.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  virtual Test *getTestAt( int index ) const;
+
+  /*! \brief Get the last test of the path.
+   * \return Pointer on the last test (test at the bottom of the hierarchy). Never \c NULL.
+   * \exception std::out_of_range if the path is not valid ( isValid() returns \c false ).
+   */
+  virtual Test *getChildTest() const;
+
+  /*! \brief Returns the path as a string.
+   *
+   * For example, if a path is composed of three tests named "All Tests", "Math" and
+   * "Math::testAdd", toString() will return:
+   *
+   * "All Tests/Math/Math::testAdd".
+   *
+   * \return A string composed of the test names separated with a '/'. It is a relative
+   *         path.
+   */
+  virtual std::string toString() const;
+
+  /*! \brief Assignment operator.
+   * \param other Object to copy.
+   * \return This object.
+   */
+  TestPath &operator =( const TestPath &other );
+
+protected:
+  /*! \brief Checks that the specified test index is within valid range.
+   * \param index Zero based index to check.
+   * \exception std::out_of_range is \a index < 0 or \a index >= getTestCount().
+   */
+  void checkIndexValid( int index ) const;
+
+  /// A list of test names.
+  typedef CppUnitDeque<std::string> PathTestNames;
+
+  /*! \brief Splits a path string into its test name components.
+   * \param pathAsString Path string created with toString().
+   * \param testNames Test name components are added to that container.
+   * \return \c true if the path is relative (does not begin with '/'), \c false
+   *         if it is absolute (begin with '/').
+   */
+  bool splitPathString( const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+  /*! \brief Finds the actual root of a path string and get the path string name components.
+   * \param searchRoot Test used as root if the path string is absolute, or to search
+   *                   the root test if the path string is relative.
+   * \param pathAsString Path string. May be absolute or relative.
+   * \param testNames Test name components are added to that container.
+   * \return Pointer on the resolved root test. Never \c NULL.
+   * \exception std::invalid_argument if either the root name can not be resolved or if
+   *            pathAsString contains no name components.
+   */
+  Test *findActualRoot( Test *searchRoot,
+                        const std::string &pathAsString,
+                        PathTestNames &testNames );
+
+protected:
+  typedef CppUnitDeque<Test *> Tests;
+  Tests m_tests;
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TESTPATH_H
+
diff --git a/src/test/cppunit/TestPlugInDefaultImpl.cpp b/src/test/cppunit/TestPlugInDefaultImpl.cpp
new file mode 100644
index 0000000..f4bb6b2
--- /dev/null
+++ b/src/test/cppunit/TestPlugInDefaultImpl.cpp
@@ -0,0 +1,63 @@
+#include <cppunit/config/SourcePrefix.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/plugin/TestPlugInDefaultImpl.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestPlugInDefaultImpl::TestPlugInDefaultImpl()
+{
+}
+
+
+TestPlugInDefaultImpl::~TestPlugInDefaultImpl()
+{
+}
+
+
+void
+TestPlugInDefaultImpl::initialize( TestFactoryRegistry *registry,
+                                   const PlugInParameters &parameters )
+{
+}
+
+
+void
+TestPlugInDefaultImpl::addListener( TestResult *eventManager )
+{
+}
+
+
+void
+TestPlugInDefaultImpl::removeListener( TestResult *eventManager )
+{
+}
+
+
+void
+TestPlugInDefaultImpl::addXmlOutputterHooks( XmlOutputter *outputter )
+{
+}
+
+
+void
+TestPlugInDefaultImpl::removeXmlOutputterHooks()
+{
+}
+
+
+void
+TestPlugInDefaultImpl::uninitialize( TestFactoryRegistry *registry )
+{
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
diff --git a/src/test/cppunit/TestResult.cpp b/src/test/cppunit/TestResult.cpp
new file mode 100644
index 0000000..7435501
--- /dev/null
+++ b/src/test/cppunit/TestResult.cpp
@@ -0,0 +1,196 @@
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestListener.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/tools/Algorithm.h>
+#include <algorithm>
+#include "DefaultProtector.h"
+#include "ProtectorChain.h"
+#include "ProtectorContext.h"
+
+CPPUNIT_NS_BEGIN
+
+
+TestResult::TestResult( SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject )
+    , m_protectorChain( new ProtectorChain() )
+    , m_stop( false )
+{
+  m_protectorChain->push( new DefaultProtector() );
+}
+
+
+TestResult::~TestResult()
+{
+  delete m_protectorChain;
+}
+
+
+void
+TestResult::reset()
+{
+  ExclusiveZone zone( m_syncObject );
+  m_stop = false;
+}
+
+
+void
+TestResult::addError( Test *test,
+                      Exception *e )
+{
+  TestFailure failure( test, e, true );
+  addFailure( failure );
+}
+
+
+void
+TestResult::addFailure( Test *test, Exception *e )
+{
+  TestFailure failure( test, e, false );
+  addFailure( failure );
+}
+
+
+void
+TestResult::addFailure( const TestFailure &failure )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->addFailure( failure );
+}
+
+
+void
+TestResult::startTest( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->startTest( test );
+}
+
+
+void
+TestResult::endTest( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->endTest( test );
+}
+
+
+void
+TestResult::startSuite( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->startSuite( test );
+}
+
+
+void
+TestResult::endSuite( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->endSuite( test );
+}
+
+
+bool
+TestResult::shouldStop() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_stop;
+}
+
+
+void
+TestResult::stop()
+{
+  ExclusiveZone zone( m_syncObject );
+  m_stop = true;
+}
+
+
+void
+TestResult::addListener( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject );
+  m_listeners.push_back( listener );
+}
+
+
+void
+TestResult::removeListener ( TestListener *listener )
+{
+  ExclusiveZone zone( m_syncObject );
+  removeFromSequence( m_listeners, listener );
+}
+
+
+void
+TestResult::runTest( Test *test )
+{
+  startTestRun( test );
+  test->run( this );
+  endTestRun( test );
+}
+
+
+void
+TestResult::startTestRun( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->startTestRun( test, this );
+}
+
+
+void
+TestResult::endTestRun( Test *test )
+{
+  ExclusiveZone zone( m_syncObject );
+  for ( TestListeners::iterator it = m_listeners.begin();
+        it != m_listeners.end();
+        ++it )
+    (*it)->endTestRun( test, this );
+}
+
+
+bool
+TestResult::protect( const Functor &functor,
+                     Test *test,
+                     const std::string &shortDescription )
+{
+  ProtectorContext context( test, this, shortDescription );
+  return m_protectorChain->protect( functor, context );
+}
+
+
+void
+TestResult::pushProtector( Protector *protector )
+{
+  m_protectorChain->push( protector );
+}
+
+
+void
+TestResult::popProtector()
+{
+  m_protectorChain->pop();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestResult.h b/src/test/cppunit/TestResult.h
new file mode 100644
index 0000000..f672dde
--- /dev/null
+++ b/src/test/cppunit/TestResult.h
@@ -0,0 +1,156 @@
+#ifndef CPPUNIT_TESTRESULT_H
+#define CPPUNIT_TESTRESULT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class Functor;
+class Protector;
+class ProtectorChain;
+class Test;
+class TestFailure;
+class TestListener;
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestListener *>;
+#endif
+
+/*! \brief Manages TestListener.
+ * \ingroup TrackingTestExecution
+ *
+ * A single instance of this class is used when running the test. It is usually
+ * created by the test runner (TestRunner).
+ *
+ * This class shouldn't have to be inherited from. Use a TestListener
+ * or one of its subclasses to be informed of the ongoing tests.
+ * Use a Outputter to receive a test summary once it has finished
+ *
+ * TestResult supplies a template method 'setSynchronizationObject()'
+ * so that subclasses can provide mutual exclusion in the face of multiple
+ * threads.  This can be useful when tests execute in one thread and
+ * they fill a subclass of TestResult which effects change in another
+ * thread.  To have mutual exclusion, override setSynchronizationObject()
+ * and make sure that you create an instance of ExclusiveZone at the
+ * beginning of each method.
+ *
+ * \see Test, TestListener, TestResultCollector, Outputter.
+ */
+class CPPUNIT_API TestResult : protected SynchronizedObject
+{
+public:
+  /// Construct a TestResult
+  TestResult( SynchronizationObject *syncObject = 0 );
+
+  /// Destroys a test result
+  virtual ~TestResult();
+
+  virtual void addListener( TestListener *listener );
+
+  virtual void removeListener( TestListener *listener );
+
+  /// Resets the stop flag.
+  virtual void reset();
+
+  /// Stop testing
+  virtual void stop();
+
+  /// Returns whether testing should be stopped
+  virtual bool shouldStop() const;
+
+  /// Informs TestListener that a test will be started.
+  virtual void startTest( Test *test );
+
+  /*! \brief Adds an error to the list of errors.
+   *  The passed in exception
+   *  caused the error
+   */
+  virtual void addError( Test *test, Exception *e );
+
+  /*! \brief Adds a failure to the list of failures. The passed in exception
+   * caused the failure.
+   */
+  virtual void addFailure( Test *test, Exception *e );
+
+  /// Informs TestListener that a test was completed.
+  virtual void endTest( Test *test );
+
+  /// Informs TestListener that a test suite will be started.
+  virtual void startSuite( Test *test );
+
+  /// Informs TestListener that a test suite was completed.
+  virtual void endSuite( Test *test );
+
+  /*! \brief Run the specified test.
+   *
+   * Calls startTestRun(), test->run(this), and finally endTestRun().
+   */
+  virtual void runTest( Test *test );
+
+  /*! \brief Protects a call to the specified functor.
+   *
+   * See Protector to understand how protector works. A default protector is
+   * always present. It captures CppUnit::Exception, std::exception and
+   * any other exceptions, retrieving as much as possible information about
+   * the exception as possible.
+   *
+   * Additional Protector can be added to the chain to support other exception
+   * types using pushProtector() and popProtector().
+   *
+   * \param functor Functor to call (typically a call to setUp(), runTest() or
+   *                tearDown().
+   * \param test Test the functor is associated to (used for failure reporting).
+   * \param shortDescription Short description override for the failure message.
+   */
+  virtual bool protect( const Functor &functor,
+                        Test *test,
+                        const std::string &shortDescription = std::string("") );
+
+  /// Adds the specified protector to the protector chain.
+  virtual void pushProtector( Protector *protector );
+
+  /// Removes the last protector from the protector chain.
+  virtual void popProtector();
+
+protected:
+  /*! \brief Called to add a failure to the list of failures.
+   */
+  void addFailure( const TestFailure &failure );
+
+  virtual void startTestRun( Test *test );
+  virtual void endTestRun( Test *test );
+
+protected:
+  typedef CppUnitDeque<TestListener *> TestListeners;
+  TestListeners m_listeners;
+  ProtectorChain *m_protectorChain;
+  bool m_stop;
+
+private:
+  TestResult( const TestResult &other );
+  TestResult &operator =( const TestResult &other );
+};
+
+
+CPPUNIT_NS_END
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTRESULT_H
+
+
diff --git a/src/test/cppunit/TestResultCollector.cpp b/src/test/cppunit/TestResultCollector.cpp
new file mode 100644
index 0000000..869c14d
--- /dev/null
+++ b/src/test/cppunit/TestResultCollector.cpp
@@ -0,0 +1,117 @@
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestResultCollector::TestResultCollector( SynchronizationObject *syncObject )
+    : TestSuccessListener( syncObject )
+{
+  reset();
+}
+
+
+TestResultCollector::~TestResultCollector()
+{
+  freeFailures();
+}
+
+
+void
+TestResultCollector::freeFailures()
+{
+  TestFailures::iterator itFailure = m_failures.begin();
+  while ( itFailure != m_failures.end() )
+    delete *itFailure++;
+  m_failures.clear();
+}
+
+
+void
+TestResultCollector::reset()
+{
+  TestSuccessListener::reset();
+
+  ExclusiveZone zone( m_syncObject );
+  freeFailures();
+  m_testErrors = 0;
+  m_tests.clear();
+}
+
+
+void
+TestResultCollector::startTest( Test *test )
+{
+  ExclusiveZone zone (m_syncObject);
+  m_tests.push_back( test );
+}
+
+
+void
+TestResultCollector::addFailure( const TestFailure &failure )
+{
+  TestSuccessListener::addFailure( failure );
+
+  ExclusiveZone zone( m_syncObject );
+  if ( failure.isError() )
+    ++m_testErrors;
+  m_failures.push_back( failure.clone() );
+}
+
+
+/// Gets the number of run tests.
+int
+TestResultCollector::runTests() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_tests.size();
+}
+
+
+/// Gets the number of detected errors (uncaught exception).
+int
+TestResultCollector::testErrors() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_testErrors;
+}
+
+
+/// Gets the number of detected failures (failed assertion).
+int
+TestResultCollector::testFailures() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_failures.size() - m_testErrors;
+}
+
+
+/// Gets the total number of detected failures.
+int
+TestResultCollector::testFailuresTotal() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_failures.size();
+}
+
+
+/// Returns a the list failures (random access collection).
+const TestResultCollector::TestFailures &
+TestResultCollector::failures() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_failures;
+}
+
+
+const TestResultCollector::Tests &
+TestResultCollector::tests() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_tests;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestResultCollector.h b/src/test/cppunit/TestResultCollector.h
new file mode 100644
index 0000000..469ea6b
--- /dev/null
+++ b/src/test/cppunit/TestResultCollector.h
@@ -0,0 +1,87 @@
+#ifndef CPPUNIT_TESTRESULTCOLLECTOR_H
+#define CPPUNIT_TESTRESULTCOLLECTOR_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 4660 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestSuccessListener.h>
+#include <cppunit/portability/CppUnitDeque.h>
+
+
+CPPUNIT_NS_BEGIN
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<TestFailure *>;
+//  template class CPPUNIT_API std::deque<Test *>;
+#endif
+
+
+/*! \brief Collects test result.
+ * \ingroup WritingTestResult
+ * \ingroup BrowsingCollectedTestResult
+ *
+ * A TestResultCollector is a TestListener which collects the results of executing
+ * a test case. It is an instance of the Collecting Parameter pattern.
+ *
+ * The test framework distinguishes between failures and errors.
+ * A failure is anticipated and checked for with assertions. Errors are
+ * unanticipated problems signified by exceptions that are not generated
+ * by the framework.
+ * \see TestListener, TestFailure.
+ */
+class CPPUNIT_API TestResultCollector : public TestSuccessListener
+{
+public:
+  typedef CppUnitDeque<TestFailure *> TestFailures;
+  typedef CppUnitDeque<Test *> Tests;
+
+
+  /*! Constructs a TestResultCollector object.
+   */
+  TestResultCollector( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestResultCollector();
+
+  void startTest( Test *test );
+  void addFailure( const TestFailure &failure );
+
+  virtual void reset();
+
+  virtual int runTests() const;
+  virtual int testErrors() const;
+  virtual int testFailures() const;
+  virtual int testFailuresTotal() const;
+
+  virtual const TestFailures& failures() const;
+  virtual const Tests &tests() const;
+
+protected:
+  void freeFailures();
+
+  Tests m_tests;
+  TestFailures m_failures;
+  int m_testErrors;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestResultCollector( const TestResultCollector &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestResultCollector &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TESTRESULTCOLLECTOR_H
diff --git a/src/test/cppunit/TestRunner.cpp b/src/test/cppunit/TestRunner.cpp
new file mode 100644
index 0000000..4e00553
--- /dev/null
+++ b/src/test/cppunit/TestRunner.cpp
@@ -0,0 +1,101 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestRunner.h>
+#include <cppunit/TestPath.h>
+#include <cppunit/TestResult.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestRunner::WrappingSuite::WrappingSuite( const std::string &name )
+    : TestSuite( name )
+{
+}
+
+
+int
+TestRunner::WrappingSuite::getChildTestCount() const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getChildTestCount();
+  return TestSuite::getChildTestCount();
+}
+
+
+std::string
+TestRunner::WrappingSuite::getName() const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getName();
+  return TestSuite::getName();
+}
+
+
+Test *
+TestRunner::WrappingSuite::doGetChildTestAt( int index ) const
+{
+  if ( hasOnlyOneTest() )
+    return getUniqueChildTest()->getChildTestAt( index );
+  return TestSuite::doGetChildTestAt( index );
+}
+
+
+void
+TestRunner::WrappingSuite::run( TestResult *result )
+{
+  if ( hasOnlyOneTest() )
+    getUniqueChildTest()->run( result );
+  else
+    TestSuite::run( result );
+}
+
+
+bool
+TestRunner::WrappingSuite::hasOnlyOneTest() const
+{
+  return TestSuite::getChildTestCount() == 1;
+}
+
+
+Test *
+TestRunner::WrappingSuite::getUniqueChildTest() const
+{
+  return TestSuite::doGetChildTestAt( 0 );
+}
+
+
+
+
+
+TestRunner::TestRunner()
+    : m_suite( new WrappingSuite() )
+{
+}
+
+
+TestRunner::~TestRunner()
+{
+  delete m_suite;
+}
+
+
+void
+TestRunner::addTest( Test *test )
+{
+  m_suite->addTest( test );
+}
+
+
+void
+TestRunner::run( TestResult &controller,
+                 const std::string &testPath )
+{
+  TestPath path = m_suite->resolveTestPath( testPath );
+  Test *testToRun = path.getChildTest();
+
+  controller.runTest( testToRun );
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestRunner.h b/src/test/cppunit/TestRunner.h
new file mode 100644
index 0000000..15839c7
--- /dev/null
+++ b/src/test/cppunit/TestRunner.h
@@ -0,0 +1,135 @@
+#ifndef CPPUNIT_TESTRUNNER_H
+#define CPPUNIT_TESTRUNNER_H
+
+#include <cppunit/TestSuite.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Generic test runner.
+ * \ingroup ExecutingTest
+ *
+ * The TestRunner assumes ownership of all added tests: you can not add test
+ * or suite that are local variable since they can't be deleted.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/CompilerOutputter.h>
+ * #include <cppunit/TestResult.h>
+ * #include <cppunit/TestResultCollector.h>
+ * #include <cppunit/TestRunner.h>
+ * #include <cppunit/TextTestProgressListener.h>
+ *
+ *
+ * int
+ * main( int argc, char* argv[] )
+ * {
+ *   std::string testPath = (argc > 1) ? std::string(argv[1]) : "";
+ *
+ *   // Create the event manager and test controller
+ *   CppUnit::TestResult controller;
+ *
+ *   // Add a listener that colllects test result
+ *   CppUnit::TestResultCollector result;
+ *   controller.addListener( &result );
+ *
+ *   // Add a listener that print dots as test run.
+ *   CppUnit::TextTestProgressListener progress;
+ *   controller.addListener( &progress );
+ *
+ *   // Add the top suite to the test runner
+ *   CppUnit::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *   try
+ *   {
+ *     std::cout << "Running "  <<  testPath;
+ *     runner.run( controller, testPath );
+ *
+ *     std::cerr << std::endl;
+ *
+ *     // Print test in a compiler compatible format.
+ *     CppUnit::CompilerOutputter outputter( &result, std::cerr );
+ *     outputter.write();
+ *   }
+ *   catch ( std::invalid_argument &e )  // Test path not resolved
+ *   {
+ *     std::cerr  <<  std::endl
+ *                <<  "ERROR: "  <<  e.what()
+ *                << std::endl;
+ *     return 0;
+ *   }
+ *
+ *   return result.wasSuccessful() ? 0 : 1;
+ * }
+ * \endcode
+ */
+class CPPUNIT_API TestRunner
+{
+public:
+  /*! \brief Constructs a TestRunner object.
+   */
+  TestRunner(  );
+
+  /// Destructor.
+  virtual ~TestRunner();
+
+  /*! \brief Adds the specified test.
+   * \param test Test to add. The TestRunner takes ownership of the test.
+   */
+  virtual void addTest( Test *test );
+
+  /*! \brief Runs a test using the specified controller.
+   * \param controller Event manager and controller used for testing
+   * \param testPath Test path string. See Test::resolveTestPath() for detail.
+   * \exception std::invalid_argument if no test matching \a testPath is found.
+   *                                  see TestPath::TestPath( Test*, const std::string &)
+   *                                  for detail.
+   */
+  virtual void run( TestResult &controller,
+                    const std::string &testPath = "" );
+
+protected:
+  /*! \brief (INTERNAL) Mutating test suite.
+   */
+  class CPPUNIT_API WrappingSuite : public TestSuite
+  {
+  public:
+    WrappingSuite( const std::string &name = "All Tests" );
+
+    int getChildTestCount() const;
+
+    std::string getName() const;
+
+    void run( TestResult *result );
+
+  protected:
+    Test *doGetChildTestAt( int index ) const;
+
+    bool hasOnlyOneTest() const;
+
+    Test *getUniqueChildTest() const;
+  };
+
+protected:
+  WrappingSuite *m_suite;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TestRunner( const TestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TestRunner &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTRUNNER_H
diff --git a/src/test/cppunit/TestSetUp.cpp b/src/test/cppunit/TestSetUp.cpp
new file mode 100644
index 0000000..814d89d
--- /dev/null
+++ b/src/test/cppunit/TestSetUp.cpp
@@ -0,0 +1,32 @@
+#include <cppunit/extensions/TestSetUp.h>
+
+CPPUNIT_NS_BEGIN
+
+
+TestSetUp::TestSetUp( Test *test ) : TestDecorator( test )
+{
+}
+
+
+void
+TestSetUp::setUp()
+{
+}
+
+
+void
+TestSetUp::tearDown()
+{
+}
+
+
+void
+TestSetUp::run( TestResult *result )
+{
+  setUp();
+  TestDecorator::run(result);
+  tearDown();
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TestSuccessListener.cpp b/src/test/cppunit/TestSuccessListener.cpp
new file mode 100644
index 0000000..6909347
--- /dev/null
+++ b/src/test/cppunit/TestSuccessListener.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/TestSuccessListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TestSuccessListener::TestSuccessListener( SynchronizationObject *syncObject )
+    : SynchronizedObject( syncObject )
+    , m_success( true )
+{
+}
+
+
+TestSuccessListener::~TestSuccessListener()
+{
+}
+
+
+void
+TestSuccessListener::reset()
+{
+  ExclusiveZone zone( m_syncObject );
+  m_success = true;
+}
+
+
+void
+TestSuccessListener::addFailure( const TestFailure &failure )
+{
+  ExclusiveZone zone( m_syncObject );
+  m_success = false;
+}
+
+
+bool
+TestSuccessListener::wasSuccessful() const
+{
+  ExclusiveZone zone( m_syncObject );
+  return m_success;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestSuccessListener.h b/src/test/cppunit/TestSuccessListener.h
new file mode 100644
index 0000000..60c5ff5
--- /dev/null
+++ b/src/test/cppunit/TestSuccessListener.h
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TESTSUCCESSLISTENER_H
+#define CPPUNIT_TESTSUCCESSLISTENER_H
+
+#include <cppunit/SynchronizedObject.h>
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief TestListener that checks if any test case failed.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TestSuccessListener : public TestListener,
+                                        public SynchronizedObject
+{
+public:
+  /*! Constructs a TestSuccessListener object.
+   */
+  TestSuccessListener( SynchronizationObject *syncObject = 0 );
+
+  /// Destructor.
+  virtual ~TestSuccessListener();
+
+  virtual void reset();
+
+  void addFailure( const TestFailure &failure );
+
+  /// Returns whether the entire test was successful or not.
+  virtual bool wasSuccessful() const;
+
+private:
+  bool m_success;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TESTSUCCESSLISTENER_H
diff --git a/src/test/cppunit/TestSuite.cpp b/src/test/cppunit/TestSuite.cpp
new file mode 100644
index 0000000..b345adc
--- /dev/null
+++ b/src/test/cppunit/TestSuite.cpp
@@ -0,0 +1,64 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TestResult.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/// Default constructor
+TestSuite::TestSuite( std::string name )
+    : TestComposite( name )
+{
+}
+
+
+/// Destructor
+TestSuite::~TestSuite()
+{
+  deleteContents();
+}
+
+
+/// Deletes all tests in the suite.
+void
+TestSuite::deleteContents()
+{
+  int childCount = getChildTestCount();
+  for ( int index =0; index < childCount; ++index )
+    delete getChildTestAt( index );
+
+  m_tests.clear();
+}
+
+
+/// Adds a test to the suite.
+void
+TestSuite::addTest( Test *test )
+{
+  m_tests.push_back( test );
+}
+
+
+const CppUnitVector<Test *> &
+TestSuite::getTests() const
+{
+  return m_tests;
+}
+
+
+int
+TestSuite::getChildTestCount() const
+{
+  return m_tests.size();
+}
+
+
+Test *
+TestSuite::doGetChildTestAt( int index ) const
+{
+  return m_tests[index];
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TestSuite.h b/src/test/cppunit/TestSuite.h
new file mode 100644
index 0000000..6c43a21
--- /dev/null
+++ b/src/test/cppunit/TestSuite.h
@@ -0,0 +1,80 @@
+#ifndef CPPUNIT_TESTSUITE_H    // -*- C++ -*-
+#define CPPUNIT_TESTSUITE_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/TestComposite.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+CPPUNIT_NS_BEGIN
+
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::vector<Test *>;
+#endif
+
+
+/*! \brief A Composite of Tests.
+ * \ingroup CreatingTestSuite
+ *
+ * It runs a collection of test cases. Here is an example.
+ * \code
+ * CppUnit::TestSuite *suite= new CppUnit::TestSuite();
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testAdd", testAdd));
+ * suite->addTest(new CppUnit::TestCaller<MathTest> (
+ *                  "testDivideByZero", testDivideByZero));
+ * \endcode
+ * Note that \link TestSuite TestSuites \endlink assume lifetime
+ * control for any tests added to them.
+ *
+ * TestSuites do not register themselves in the TestRegistry.
+ * \see Test
+ * \see TestCaller
+ */
+class CPPUNIT_API TestSuite : public TestComposite
+{
+public:
+  /*! Constructs a test suite with the specified name.
+   */
+  TestSuite( std::string name = "" );
+
+  ~TestSuite();
+
+  /*! Adds the specified test to the suite.
+   * \param test Test to add. Must not be \c NULL.
+    */
+  void addTest( Test *test );
+
+  /*! Returns the list of the tests (DEPRECATED).
+   * \deprecated Use getChildTestCount() & getChildTestAt() of the
+   *             TestComposite interface instead.
+   * \return Reference on a vector that contains the tests of the suite.
+   */
+  const CppUnitVector<Test *> &getTests() const;
+
+  /*! Destroys all the tests of the suite.
+   */
+  virtual void deleteContents();
+
+  int getChildTestCount() const;
+
+  Test *doGetChildTestAt( int index ) const;
+
+private:
+  CppUnitVector<Test *> m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_TESTSUITE_H
diff --git a/src/test/cppunit/TestSuiteBuilderContext.cpp b/src/test/cppunit/TestSuiteBuilderContext.cpp
new file mode 100644
index 0000000..037ed5c
--- /dev/null
+++ b/src/test/cppunit/TestSuiteBuilderContext.cpp
@@ -0,0 +1,85 @@
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/TestFixtureFactory.h>
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TestSuiteBuilderContext.h>
+
+
+CPPUNIT_NS_BEGIN
+
+TestSuiteBuilderContextBase::TestSuiteBuilderContextBase(
+                                 TestSuite &suite,
+                                 const TestNamer &namer,
+                                 TestFixtureFactory &factory )
+  : m_suite( suite )
+  , m_namer( namer )
+  , m_factory( factory )
+{
+}
+
+
+TestSuiteBuilderContextBase::~TestSuiteBuilderContextBase()
+{
+}
+
+
+void
+TestSuiteBuilderContextBase::addTest( Test *test )
+{
+  m_suite.addTest( test );
+}
+
+
+std::string
+TestSuiteBuilderContextBase::getFixtureName() const
+{
+  return m_namer.getFixtureName();
+}
+
+
+std::string
+TestSuiteBuilderContextBase::getTestNameFor(
+                                 const std::string &testMethodName ) const
+{
+  return m_namer.getTestNameFor( testMethodName );
+}
+
+
+TestFixture *
+TestSuiteBuilderContextBase::makeTestFixture() const
+{
+  return m_factory.makeFixture();
+}
+
+
+void
+TestSuiteBuilderContextBase::addProperty( const std::string &key,
+                                          const std::string &value )
+{
+  Properties::iterator it = m_properties.begin();
+  for ( ; it != m_properties.end(); ++it )
+  {
+    if ( (*it).first == key )
+    {
+      (*it).second = value;
+      return;
+    }
+  }
+
+  Property property( key, value );
+  m_properties.push_back( property );
+}
+
+const std::string
+TestSuiteBuilderContextBase::getStringProperty( const std::string &key ) const
+{
+  Properties::const_iterator it = m_properties.begin();
+  for ( ; it != m_properties.end(); ++it )
+  {
+    if ( (*it).first == key )
+      return (*it).second;
+  }
+  return "";
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextOutputter.cpp b/src/test/cppunit/TextOutputter.cpp
new file mode 100644
index 0000000..f7653d3
--- /dev/null
+++ b/src/test/cppunit/TextOutputter.cpp
@@ -0,0 +1,140 @@
+#include <cppunit/Exception.h>
+#include <cppunit/SourceLine.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/TestResultCollector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextOutputter::TextOutputter( TestResultCollector *result,
+                              OStream &stream )
+    : m_result( result )
+    , m_stream( stream )
+{
+}
+
+
+TextOutputter::~TextOutputter()
+{
+}
+
+
+void
+TextOutputter::write()
+{
+  printHeader();
+  m_stream << "\n";
+  printFailures();
+  m_stream << "\n";
+}
+
+
+void
+TextOutputter::printFailures()
+{
+  TestResultCollector::TestFailures::const_iterator itFailure = m_result->failures().begin();
+  int failureNumber = 1;
+  while ( itFailure != m_result->failures().end() )
+  {
+    m_stream  <<  "\n";
+    printFailure( *itFailure++, failureNumber++ );
+  }
+}
+
+
+void
+TextOutputter::printFailure( TestFailure *failure,
+                             int failureNumber )
+{
+  printFailureListMark( failureNumber );
+  m_stream << ' ';
+  printFailureTestName( failure );
+  m_stream << ' ';
+  printFailureType( failure );
+  m_stream << ' ';
+  printFailureLocation( failure->sourceLine() );
+  m_stream << "\n";
+  printFailureDetail( failure->thrownException() );
+  m_stream << "\n";
+}
+
+
+void
+TextOutputter::printFailureListMark( int failureNumber )
+{
+  m_stream << failureNumber << ")";
+}
+
+
+void
+TextOutputter::printFailureTestName( TestFailure *failure )
+{
+  m_stream << "test: " << failure->failedTestName();
+}
+
+
+void
+TextOutputter::printFailureType( TestFailure *failure )
+{
+  m_stream << "("
+           << (failure->isError() ? "E" : "F")
+           << ")";
+}
+
+
+void
+TextOutputter::printFailureLocation( SourceLine sourceLine )
+{
+  if ( !sourceLine.isValid() )
+    return;
+
+  m_stream << "line: " << sourceLine.lineNumber()
+           << ' ' << sourceLine.fileName();
+}
+
+
+void
+TextOutputter::printFailureDetail( Exception *thrownException )
+{
+  m_stream  <<  thrownException->message().shortDescription()  <<  "\n";
+  m_stream  <<  thrownException->message().details();
+}
+
+
+void
+TextOutputter::printHeader()
+{
+  if ( m_result->wasSuccessful() )
+    m_stream << "\nOK (" << m_result->runTests () << " tests)\n" ;
+  else
+  {
+    m_stream << "\n";
+    printFailureWarning();
+    printStatistics();
+  }
+}
+
+
+void
+TextOutputter::printFailureWarning()
+{
+  m_stream  << "!!!FAILURES!!!\n";
+}
+
+
+void
+TextOutputter::printStatistics()
+{
+  m_stream  << "Test Results:\n";
+
+  m_stream  <<  "Run:  "  <<  m_result->runTests()
+            <<  "   Failures: "  <<  m_result->testFailures()
+            <<  "   Errors: "  <<  m_result->testErrors()
+            <<  "\n";
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TextOutputter.h b/src/test/cppunit/TextOutputter.h
new file mode 100644
index 0000000..6bd9cea
--- /dev/null
+++ b/src/test/cppunit/TextOutputter.h
@@ -0,0 +1,59 @@
+#ifndef CPPUNIT_TEXTOUTPUTTER_H
+#define CPPUNIT_TEXTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Exception;
+class SourceLine;
+class TestResultCollector;
+class TestFailure;
+
+
+/*! \brief Prints a TestResultCollector to a text stream.
+ * \ingroup WritingTestResult
+ */
+class CPPUNIT_API TextOutputter : public Outputter
+{
+public:
+  TextOutputter( TestResultCollector *result,
+                 OStream &stream );
+
+  /// Destructor.
+  virtual ~TextOutputter();
+
+  void write();
+  virtual void printFailures();
+  virtual void printHeader();
+
+  virtual void printFailure( TestFailure *failure,
+                             int failureNumber );
+  virtual void printFailureListMark( int failureNumber );
+  virtual void printFailureTestName( TestFailure *failure );
+  virtual void printFailureType( TestFailure *failure );
+  virtual void printFailureLocation( SourceLine sourceLine );
+  virtual void printFailureDetail( Exception *thrownException );
+  virtual void printFailureWarning();
+  virtual void printStatistics();
+
+protected:
+  TestResultCollector *m_result;
+  OStream &m_stream;
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextOutputter( const TextOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextOutputter &copy );
+};
+
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTOUTPUTTER_H
diff --git a/src/test/cppunit/TextTestProgressListener.cpp b/src/test/cppunit/TextTestProgressListener.cpp
new file mode 100644
index 0000000..21d370d
--- /dev/null
+++ b/src/test/cppunit/TextTestProgressListener.cpp
@@ -0,0 +1,43 @@
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextTestProgressListener::TextTestProgressListener()
+{
+}
+
+
+TextTestProgressListener::~TextTestProgressListener()
+{
+}
+
+
+void
+TextTestProgressListener::startTest( Test *test )
+{
+  stdCOut() << ".";
+}
+
+
+void
+TextTestProgressListener::addFailure( const TestFailure &failure )
+{
+  stdCOut() << ( failure.isError() ? "E" : "F" );
+}
+
+
+void
+TextTestProgressListener::endTestRun( Test *test,
+                                      TestResult *eventManager )
+{
+  stdCOut()  <<  "\n";
+  stdCOut().flush();
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/TextTestProgressListener.h b/src/test/cppunit/TextTestProgressListener.h
new file mode 100644
index 0000000..0bc5838
--- /dev/null
+++ b/src/test/cppunit/TextTestProgressListener.h
@@ -0,0 +1,44 @@
+#ifndef CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+#define CPPUNIT_TEXTTESTPROGRESSLISTENER_H
+
+#include <cppunit/TestListener.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*!
+ * \brief TestListener that show the status of each TestCase test result.
+ * \ingroup TrackingTestExecution
+ */
+class CPPUNIT_API TextTestProgressListener : public TestListener
+{
+public:
+  /*! Constructs a TextTestProgressListener object.
+   */
+  TextTestProgressListener();
+
+  /// Destructor.
+  virtual ~TextTestProgressListener();
+
+  void startTest( Test *test );
+
+  void addFailure( const TestFailure &failure );
+
+  void endTestRun( Test *test,
+                   TestResult *eventManager );
+
+private:
+  /// Prevents the use of the copy constructor.
+  TextTestProgressListener( const TextTestProgressListener &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const TextTestProgressListener &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TEXTTESTPROGRESSLISTENER_H
diff --git a/src/test/cppunit/TextTestResult.cpp b/src/test/cppunit/TextTestResult.cpp
new file mode 100644
index 0000000..3420204
--- /dev/null
+++ b/src/test/cppunit/TextTestResult.cpp
@@ -0,0 +1,50 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TextTestResult.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+TextTestResult::TextTestResult()
+{
+  addListener( this );
+}
+
+
+void
+TextTestResult::addFailure( const TestFailure &failure )
+{
+  TestResultCollector::addFailure( failure );
+  stdCOut() << ( failure.isError() ? "E" : "F" );
+}
+
+
+void
+TextTestResult::startTest( Test *test )
+{
+  TestResultCollector::startTest (test);
+  stdCOut() << ".";
+}
+
+
+void
+TextTestResult::print( OStream &stream )
+{
+  TextOutputter outputter( this, stream );
+  outputter.write();
+}
+
+
+OStream &
+operator <<( OStream &stream,
+             TextTestResult &result )
+{
+  result.print (stream); return stream;
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextTestResult.h b/src/test/cppunit/TextTestResult.h
new file mode 100644
index 0000000..32ebc51
--- /dev/null
+++ b/src/test/cppunit/TextTestResult.h
@@ -0,0 +1,39 @@
+#ifndef CPPUNIT_TEXTTESTRESULT_H
+#define CPPUNIT_TEXTTESTRESULT_H
+
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/portability/Stream.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class SourceLine;
+class Exception;
+class Test;
+
+/*! \brief Holds printable test result (DEPRECATED).
+ * \ingroup TrackingTestExecution
+ *
+ * deprecated Use class TextTestProgressListener and TextOutputter instead.
+ */
+class CPPUNIT_API TextTestResult : public TestResult,
+                                   public TestResultCollector
+{
+public:
+  TextTestResult();
+
+  virtual void addFailure( const TestFailure &failure );
+  virtual void startTest( Test *test );
+  virtual void print( OStream &stream );
+};
+
+/** insertion operator for easy output */
+CPPUNIT_API OStream &operator <<( OStream &stream,
+                                  TextTestResult &result );
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_TEXTTESTRESULT_H
+
+
diff --git a/src/test/cppunit/TextTestRunner.cpp b/src/test/cppunit/TextTestRunner.cpp
new file mode 100644
index 0000000..d57a121
--- /dev/null
+++ b/src/test/cppunit/TextTestRunner.cpp
@@ -0,0 +1,144 @@
+// ==> Implementation of cppunit/ui/text/TestRunner.h
+
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TextTestResult.h>
+#include <cppunit/TextOutputter.h>
+#include <cppunit/TextTestProgressListener.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/ui/text/TextTestRunner.h>
+#include <cppunit/portability/Stream.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! Constructs a new text runner.
+ * \param outputter used to print text result. Owned by the runner.
+ */
+TextTestRunner::TextTestRunner( Outputter *outputter )
+    : m_result( new TestResultCollector() )
+    , m_eventManager( new TestResult() )
+    , m_outputter( outputter )
+{
+  if ( !m_outputter )
+    m_outputter = new TextOutputter( m_result, stdCOut() );
+  m_eventManager->addListener( m_result );
+}
+
+
+TextTestRunner::~TextTestRunner()
+{
+  delete m_eventManager;
+  delete m_outputter;
+  delete m_result;
+}
+
+
+/*! Runs the named test case.
+ *
+ * \param testName Name of the test case to run. If an empty is given, then
+ *                 all added tests are run. The name can be the name of any
+ *                 test in the hierarchy.
+ * \param doWait if \c true then the user must press the RETURN key
+ *               before the run() method exit.
+ * \param doPrintResult if \c true (default) then the test result are printed
+ *                      on the standard output.
+ * \param doPrintProgress if \c true (default) then TextTestProgressListener is
+ *                        used to show the progress.
+ * \return \c true is the test was successful, \c false if the test
+ *         failed or was not found.
+ */
+bool
+TextTestRunner::run( std::string testName,
+                       bool doWait,
+                       bool doPrintResult,
+                       bool doPrintProgress )
+{
+  TextTestProgressListener progress;
+  if ( doPrintProgress )
+    m_eventManager->addListener( &progress );
+
+  TestRunner *pThis = this;
+  pThis->run( *m_eventManager, testName );
+
+  if ( doPrintProgress )
+    m_eventManager->removeListener( &progress );
+
+  printResult( doPrintResult );
+  wait( doWait );
+
+  return m_result->wasSuccessful();
+}
+
+
+void
+TextTestRunner::wait( bool doWait )
+{
+#if !defined( CPPUNIT_NO_STREAM )
+  if ( doWait )
+  {
+    stdCOut() << "<RETURN> to continue\n";
+    stdCOut().flush();
+    std::cin.get ();
+  }
+#endif
+}
+
+
+void
+TextTestRunner::printResult( bool doPrintResult )
+{
+  stdCOut() << "\n";
+  if ( doPrintResult )
+    m_outputter->write();
+}
+
+
+/*! Returns the result of the test run.
+ * Use this after calling run() to access the result of the test run.
+ */
+TestResultCollector &
+TextTestRunner::result() const
+{
+  return *m_result;
+}
+
+
+/*! Returns the event manager.
+ * The instance of TestResult results returned is the one that is used to run the
+ * test. Use this to register additional TestListener before running the tests.
+ */
+TestResult &
+TextTestRunner::eventManager() const
+{
+  return *m_eventManager;
+}
+
+
+/*! Specifies an alternate outputter.
+ *
+ * Notes that the outputter will be use after the test run only if \a printResult was
+ * \c true.
+ * \param outputter New outputter to use. The previous outputter is destroyed.
+ *                  The TextTestRunner assumes ownership of the outputter.
+ * \see CompilerOutputter, XmlOutputter, TextOutputter.
+ */
+void
+TextTestRunner::setOutputter( Outputter *outputter )
+{
+  delete m_outputter;
+  m_outputter = outputter;
+}
+
+
+void
+TextTestRunner::run( TestResult &controller,
+                     const std::string &testPath )
+{
+  TestRunner::run( controller, testPath );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/TextTestRunner.h b/src/test/cppunit/TextTestRunner.h
new file mode 100644
index 0000000..23890e0
--- /dev/null
+++ b/src/test/cppunit/TextTestRunner.h
@@ -0,0 +1,6 @@
+#ifndef CPPUNIT_TEXTTESTRUNNER_H
+#define CPPUNIT_TEXTTESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+#endif  // CPPUNIT_TEXTTESTRUNNER_H
diff --git a/src/test/cppunit/TypeInfoHelper.cpp b/src/test/cppunit/TypeInfoHelper.cpp
new file mode 100644
index 0000000..804a85a
--- /dev/null
+++ b/src/test/cppunit/TypeInfoHelper.cpp
@@ -0,0 +1,53 @@
+#include <cppunit/Portability.h>
+#include <cppunit/extensions/TypeInfoHelper.h>
+
+#if CPPUNIT_HAVE_RTTI
+
+#include <string>
+
+#if CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+#include <cxxabi.h>
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+
+std::string
+TypeInfoHelper::getClassName( const std::type_info &info )
+{
+#if defined(CPPUNIT_HAVE_GCC_ABI_DEMANGLE)  &&  CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  int status = 0;
+  char* c_name = 0;
+
+  c_name = abi::__cxa_demangle( info.name(), 0, 0, &status );
+
+  std::string name( c_name );
+  free( c_name );
+
+#else   // CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  static std::string classPrefix( "class " );
+  std::string name( info.name() );
+
+  // Work around gcc 3.0 bug: strip number before type name.
+  unsigned int firstNotDigitIndex = 0;
+  while ( firstNotDigitIndex < name.length()  &&
+          name[firstNotDigitIndex] >= '0'  &&
+          name[firstNotDigitIndex] <= '9' )
+    ++firstNotDigitIndex;
+  name = name.substr( firstNotDigitIndex );
+
+  if ( name.substr( 0, classPrefix.length() ) == classPrefix )
+    return name.substr( classPrefix.length() );
+
+#endif  // CPPUNIT_HAVE_GCC_ABI_DEMANGLE
+
+  return name;
+}
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_HAVE_RTTI
diff --git a/src/test/cppunit/UnixDynamicLibraryManager.cpp b/src/test/cppunit/UnixDynamicLibraryManager.cpp
new file mode 100644
index 0000000..936447e
--- /dev/null
+++ b/src/test/cppunit/UnixDynamicLibraryManager.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_UNIX_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#include <dlfcn.h>
+#include <unistd.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return ::dlopen( libraryName.c_str(), RTLD_NOW | RTLD_GLOBAL );
+}
+
+
+void
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::dlclose( m_libraryHandle);
+}
+
+
+DynamicLibraryManager::Symbol
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  return ::dlsym ( m_libraryHandle, symbol.c_str() );
+}
+
+
+std::string
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  return "";
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_UNIX_DLL_LOADER)
diff --git a/src/test/cppunit/Win32DynamicLibraryManager.cpp b/src/test/cppunit/Win32DynamicLibraryManager.cpp
new file mode 100644
index 0000000..f4473de
--- /dev/null
+++ b/src/test/cppunit/Win32DynamicLibraryManager.cpp
@@ -0,0 +1,73 @@
+#include <cppunit/Portability.h>
+
+#if defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
+#include <cppunit/plugin/DynamicLibraryManager.h>
+
+#define WIN32_LEAN_AND_MEAN
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define NOMINMAX
+#define BLENDFUNCTION void    // for mingw & gcc
+#include <windows.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+DynamicLibraryManager::LibraryHandle
+DynamicLibraryManager::doLoadLibrary( const std::string &libraryName )
+{
+  return ::LoadLibraryA( libraryName.c_str() );
+}
+
+
+void
+DynamicLibraryManager::doReleaseLibrary()
+{
+  ::FreeLibrary( (HINSTANCE)m_libraryHandle );
+}
+
+
+DynamicLibraryManager::Symbol
+DynamicLibraryManager::doFindSymbol( const std::string &symbol )
+{
+  return (DynamicLibraryManager::Symbol)::GetProcAddress(
+     (HINSTANCE)m_libraryHandle,
+     symbol.c_str() );
+}
+
+
+std::string
+DynamicLibraryManager::getLastErrorDetail() const
+{
+  LPVOID lpMsgBuf;
+  ::FormatMessageA(
+      FORMAT_MESSAGE_ALLOCATE_BUFFER |
+      FORMAT_MESSAGE_FROM_SYSTEM |
+      FORMAT_MESSAGE_IGNORE_INSERTS,
+      NULL,
+      GetLastError(),
+      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
+      (LPSTR) &lpMsgBuf,
+      0,
+      NULL
+  );
+
+  std::string message = (LPCSTR)lpMsgBuf;
+
+  // Display the string.
+//  ::MessageBoxA( NULL, (LPCSTR)lpMsgBuf, "Error", MB_OK | MB_ICONINFORMATION );
+
+  // Free the buffer.
+  ::LocalFree( lpMsgBuf );
+
+  return message;
+}
+
+
+CPPUNIT_NS_END
+
+
+#endif // defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
diff --git a/src/test/cppunit/XmlDocument.cpp b/src/test/cppunit/XmlDocument.cpp
new file mode 100644
index 0000000..c379eee
--- /dev/null
+++ b/src/test/cppunit/XmlDocument.cpp
@@ -0,0 +1,106 @@
+#include <cppunit/config/SourcePrefix.h>
+#include <cppunit/tools/XmlDocument.h>
+#include <cppunit/tools/XmlElement.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+XmlDocument::XmlDocument( const std::string &encoding,
+                          const std::string &styleSheet )
+  : m_styleSheet( styleSheet )
+  , m_rootElement( new XmlElement( "DummyRoot" ) )
+  , m_standalone( true )
+{
+  setEncoding( encoding );
+}
+
+
+XmlDocument::~XmlDocument()
+{
+  delete m_rootElement;
+}
+
+
+
+std::string
+XmlDocument::encoding() const
+{
+  return m_encoding;
+}
+
+
+void
+XmlDocument::setEncoding( const std::string &encoding )
+{
+  m_encoding = encoding.empty() ? std::string("ISO-8859-1") : encoding;
+}
+
+
+std::string
+XmlDocument::styleSheet() const
+{
+  return m_styleSheet;
+}
+
+
+void
+XmlDocument::setStyleSheet( const std::string &styleSheet )
+{
+  m_styleSheet = styleSheet;
+}
+
+
+bool
+XmlDocument::standalone() const
+{
+  return m_standalone;
+}
+
+
+void
+XmlDocument::setStandalone( bool standalone )
+{
+  m_standalone = standalone;
+}
+
+
+void
+XmlDocument::setRootElement( XmlElement *rootElement )
+{
+  if ( rootElement == m_rootElement )
+    return;
+
+  delete m_rootElement;
+  m_rootElement = rootElement;
+}
+
+
+XmlElement &
+XmlDocument::rootElement() const
+{
+  return *m_rootElement;
+}
+
+
+std::string
+XmlDocument::toString() const
+{
+  std::string asString = "<?xml version=\"1.0\" "
+                         "encoding='" + m_encoding + "'";
+  if ( m_standalone )
+      asString += " standalone='yes'";
+
+  asString += " ?>\n";
+
+  if ( !m_styleSheet.empty() )
+    asString += "<?xml-stylesheet type=\"text/xsl\" href=\"" + m_styleSheet + "\"?>\n";
+
+  asString += m_rootElement->toString();
+
+  return asString;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlElement.cpp b/src/test/cppunit/XmlElement.cpp
new file mode 100644
index 0000000..76bfd35
--- /dev/null
+++ b/src/test/cppunit/XmlElement.cpp
@@ -0,0 +1,226 @@
+#include <cppunit/tools/StringTools.h>
+#include <cppunit/tools/XmlElement.h>
+#include <stdexcept>
+
+
+CPPUNIT_NS_BEGIN
+
+
+XmlElement::XmlElement( std::string elementName,
+                        std::string content )
+  : m_name( elementName )
+  , m_content( content )
+{
+}
+
+
+XmlElement::XmlElement( std::string elementName,
+                        int numericContent )
+  : m_name( elementName )
+{
+  setContent( numericContent );
+}
+
+
+XmlElement::~XmlElement()
+{
+  Elements::iterator itNode = m_elements.begin();
+  while ( itNode != m_elements.end() )
+  {
+    XmlElement *element = *itNode++;
+    delete element;
+  }
+}
+
+
+std::string
+XmlElement::name() const
+{
+  return m_name;
+}
+
+
+std::string
+XmlElement::content() const
+{
+  return m_content;
+}
+
+
+void
+XmlElement::setName( const std::string &name )
+{
+  m_name = name;
+}
+
+
+void
+XmlElement::setContent( const std::string &content )
+{
+  m_content = content;
+}
+
+
+void
+XmlElement::setContent( int numericContent )
+{
+  m_content = StringTools::toString( numericContent );
+}
+
+
+void
+XmlElement::addAttribute( std::string attributeName,
+                          std::string value  )
+{
+  m_attributes.push_back( Attribute( attributeName, value ) );
+}
+
+
+void
+XmlElement::addAttribute( std::string attributeName,
+                          int numericValue )
+{
+  addAttribute( attributeName, StringTools::toString( numericValue ) );
+}
+
+
+void
+XmlElement::addElement( XmlElement *node )
+{
+  m_elements.push_back( node );
+}
+
+
+int
+XmlElement::elementCount() const
+{
+  return m_elements.size();
+}
+
+
+XmlElement *
+XmlElement::elementAt( int index ) const
+{
+  if ( index < 0  ||  index >= elementCount() )
+    throw std::invalid_argument( "XmlElement::elementAt(), out of range index" );
+
+  return m_elements[ index ];
+}
+
+
+XmlElement *
+XmlElement::elementFor( const std::string &name ) const
+{
+  Elements::const_iterator itElement = m_elements.begin();
+  for ( ; itElement != m_elements.end(); ++itElement )
+  {
+    if ( (*itElement)->name() == name )
+      return *itElement;
+  }
+
+  throw std::invalid_argument( "XmlElement::elementFor(), not matching child element found" );
+  return NULL;  // make some compilers happy.
+}
+
+
+std::string
+XmlElement::toString( const std::string &indent ) const
+{
+  std::string element( indent );
+  element += "<";
+  element += m_name;
+  if ( !m_attributes.empty() )
+  {
+    element += " ";
+    element += attributesAsString();
+  }
+  element += ">";
+
+  if ( !m_elements.empty() )
+  {
+    element += "\n";
+
+    std::string subNodeIndent( indent + "  " );
+    Elements::const_iterator itNode = m_elements.begin();
+    while ( itNode != m_elements.end() )
+    {
+      const XmlElement *node = *itNode++;
+      element += node->toString( subNodeIndent );
+    }
+
+    element += indent;
+  }
+
+  if ( !m_content.empty() )
+  {
+    element += escape( m_content );
+    if ( !m_elements.empty() )
+    {
+      element += "\n";
+      element += indent;
+    }
+  }
+
+  element += "</";
+  element += m_name;
+  element += ">\n";
+
+  return element;
+}
+
+
+std::string
+XmlElement::attributesAsString() const
+{
+  std::string attributes;
+  Attributes::const_iterator itAttribute = m_attributes.begin();
+  while ( itAttribute != m_attributes.end() )
+  {
+    if ( !attributes.empty() )
+       attributes += " ";
+
+    const Attribute &attribute = *itAttribute++;
+    attributes += attribute.first;
+    attributes += "=\"";
+    attributes += escape( attribute.second );
+    attributes += "\"";
+  }
+  return attributes;
+}
+
+
+std::string
+XmlElement::escape( std::string value ) const
+{
+  std::string escaped;
+  for ( unsigned int index =0; index < value.length(); ++index )
+  {
+    char c = value[index ];
+    switch ( c )    // escape all predefined XML entity (safe?)
+    {
+    case '<':
+      escaped += "&lt;";
+      break;
+    case '>':
+      escaped += "&gt;";
+      break;
+    case '&':
+      escaped += "&amp;";
+      break;
+    case '\'':
+      escaped += "&apos;";
+      break;
+    case '"':
+      escaped += "&quot;";
+      break;
+    default:
+      escaped += c;
+    }
+  }
+
+  return escaped;
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlOutputter.cpp b/src/test/cppunit/XmlOutputter.cpp
new file mode 100644
index 0000000..e2b550d
--- /dev/null
+++ b/src/test/cppunit/XmlOutputter.cpp
@@ -0,0 +1,205 @@
+#include <cppunit/Exception.h>
+#include <cppunit/Test.h>
+#include <cppunit/TestFailure.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/XmlOutputter.h>
+#include <cppunit/XmlOutputterHook.h>
+#include <cppunit/tools/XmlDocument.h>
+#include <cppunit/tools/XmlElement.h>
+#include <stdlib.h>
+#include <algorithm>
+
+
+CPPUNIT_NS_BEGIN
+
+
+XmlOutputter::XmlOutputter( TestResultCollector *result,
+                            OStream &stream,
+                            std::string encoding )
+  : m_result( result )
+  , m_stream( stream )
+  , m_xml( new XmlDocument( encoding ) )
+{
+}
+
+
+XmlOutputter::~XmlOutputter()
+{
+  delete m_xml;
+}
+
+
+void
+XmlOutputter::addHook( XmlOutputterHook *hook )
+{
+  m_hooks.push_back( hook );
+}
+
+
+void
+XmlOutputter::removeHook( XmlOutputterHook *hook )
+{
+  m_hooks.erase( std::find( m_hooks.begin(), m_hooks.end(), hook ) );
+}
+
+
+void
+XmlOutputter::write()
+{
+  setRootNode();
+  m_stream  <<  m_xml->toString();
+}
+
+
+void
+XmlOutputter::setStyleSheet( const std::string &styleSheet )
+{
+  m_xml->setStyleSheet( styleSheet );
+}
+
+
+void
+XmlOutputter::setStandalone( bool standalone )
+{
+  m_xml->setStandalone( standalone );
+}
+
+
+void
+XmlOutputter::setRootNode()
+{
+  XmlElement *rootNode = new XmlElement( "TestRun" );
+  m_xml->setRootElement( rootNode );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->beginDocument( m_xml );
+
+  FailedTests failedTests;
+  fillFailedTestsMap( failedTests );
+
+  addFailedTests( failedTests, rootNode );
+  addSuccessfulTests( failedTests, rootNode );
+  addStatistics( rootNode );
+
+  for ( Hooks::iterator itEnd = m_hooks.begin(); itEnd != m_hooks.end(); ++itEnd )
+    (*itEnd)->endDocument( m_xml );
+}
+
+
+void
+XmlOutputter::fillFailedTestsMap( FailedTests &failedTests )
+{
+  const TestResultCollector::TestFailures &failures = m_result->failures();
+  TestResultCollector::TestFailures::const_iterator itFailure = failures.begin();
+  while ( itFailure != failures.end() )
+  {
+    TestFailure *failure = *itFailure++;
+    failedTests.insert( std::pair<Test* const, TestFailure*>(failure->failedTest(), failure ) );
+  }
+}
+
+
+void
+XmlOutputter::addFailedTests( FailedTests &failedTests,
+                              XmlElement *rootNode )
+{
+  XmlElement *testsNode = new XmlElement( "FailedTests" );
+  rootNode->addElement( testsNode );
+
+  const TestResultCollector::Tests &tests = m_result->tests();
+  for ( unsigned int testNumber = 0; testNumber < tests.size(); ++testNumber )
+  {
+    Test *test = tests[testNumber];
+    if ( failedTests.find( test ) != failedTests.end() )
+      addFailedTest( test, failedTests[test], testNumber+1, testsNode );
+  }
+}
+
+
+void
+XmlOutputter::addSuccessfulTests( FailedTests &failedTests,
+                                           XmlElement *rootNode )
+{
+  XmlElement *testsNode = new XmlElement( "SuccessfulTests" );
+  rootNode->addElement( testsNode );
+
+  const TestResultCollector::Tests &tests = m_result->tests();
+  for ( unsigned int testNumber = 0; testNumber < tests.size(); ++testNumber )
+  {
+    Test *test = tests[testNumber];
+    if ( failedTests.find( test ) == failedTests.end() )
+      addSuccessfulTest( test, testNumber+1, testsNode );
+  }
+}
+
+
+void
+XmlOutputter::addStatistics( XmlElement *rootNode )
+{
+  XmlElement *statisticsElement = new XmlElement( "Statistics" );
+  rootNode->addElement( statisticsElement );
+  statisticsElement->addElement( new XmlElement( "Tests", m_result->runTests() ) );
+  statisticsElement->addElement( new XmlElement( "FailuresTotal",
+                                                 m_result->testFailuresTotal() ) );
+  statisticsElement->addElement( new XmlElement( "Errors", m_result->testErrors() ) );
+  statisticsElement->addElement( new XmlElement( "Failures", m_result->testFailures() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->statisticsAdded( m_xml, statisticsElement );
+}
+
+
+void
+XmlOutputter::addFailedTest( Test *test,
+                             TestFailure *failure,
+                             int testNumber,
+                             XmlElement *testsNode )
+{
+  Exception *thrownException = failure->thrownException();
+
+  XmlElement *testElement = new XmlElement( "FailedTest" );
+  testsNode->addElement( testElement );
+  testElement->addAttribute( "id", testNumber );
+  testElement->addElement( new XmlElement( "Name", test->getName() ) );
+  testElement->addElement( new XmlElement( "FailureType",
+                                           failure->isError() ? "Error" :
+                                                                "Assertion" ) );
+
+  if ( failure->sourceLine().isValid() )
+    addFailureLocation( failure, testElement );
+
+  testElement->addElement( new XmlElement( "Message", thrownException->what() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->failTestAdded( m_xml, testElement, test, failure );
+}
+
+
+void
+XmlOutputter::addFailureLocation( TestFailure *failure,
+                                  XmlElement *testElement )
+{
+  XmlElement *locationNode = new XmlElement( "Location" );
+  testElement->addElement( locationNode );
+  SourceLine sourceLine = failure->sourceLine();
+  locationNode->addElement( new XmlElement( "File", sourceLine.fileName() ) );
+  locationNode->addElement( new XmlElement( "Line", sourceLine.lineNumber() ) );
+}
+
+
+void
+XmlOutputter::addSuccessfulTest( Test *test,
+                                 int testNumber,
+                                 XmlElement *testsNode )
+{
+  XmlElement *testElement = new XmlElement( "Test" );
+  testsNode->addElement( testElement );
+  testElement->addAttribute( "id", testNumber );
+  testElement->addElement( new XmlElement( "Name", test->getName() ) );
+
+  for ( Hooks::iterator it = m_hooks.begin(); it != m_hooks.end(); ++it )
+    (*it)->successfulTestAdded( m_xml, testElement, test );
+}
+
+
+CPPUNIT_NS_END
diff --git a/src/test/cppunit/XmlOutputter.h b/src/test/cppunit/XmlOutputter.h
new file mode 100644
index 0000000..55e5214
--- /dev/null
+++ b/src/test/cppunit/XmlOutputter.h
@@ -0,0 +1,167 @@
+#ifndef CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+#define CPPUNIT_XMLTESTRESULTOUTPUTTER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/Outputter.h>
+#include <cppunit/portability/CppUnitDeque.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <cppunit/portability/Stream.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class TestResultCollector;
+class XmlDocument;
+class XmlElement;
+class XmlOutputterHook;
+
+
+/*! \brief Outputs a TestResultCollector in XML format.
+ * \ingroup WritingTestResult
+ *
+ * Save the test result as a XML stream.
+ *
+ * Additional datas can be added to the XML document using XmlOutputterHook.
+ * Hook are not owned by the XmlOutputter. They should be valid until
+ * destruction of the XmlOutputter. They can be removed with removeHook().
+ *
+ * \see XmlDocument, XmlElement, XmlOutputterHook.
+ */
+class CPPUNIT_API XmlOutputter : public Outputter
+{
+public:
+  /*! \brief Constructs a XmlOutputter object.
+   * \param result Result of the test run.
+   * \param stream Stream used to output the XML output.
+   * \param encoding Encoding used in the XML file (default is Latin-1).
+   */
+  XmlOutputter( TestResultCollector *result,
+                OStream &stream,
+                std::string encoding = std::string("ISO-8859-1") );
+
+  /// Destructor.
+  virtual ~XmlOutputter();
+
+  /*! \brief Adds the specified hook to the outputter.
+   * \param hook Hook to add. Must not be \c NULL.
+   */
+  virtual void addHook( XmlOutputterHook *hook );
+
+  /*! \brief Removes the specified hook from the outputter.
+   * \param hook Hook to remove.
+   */
+  virtual void removeHook( XmlOutputterHook *hook );
+
+  /*! \brief Writes the specified result as an XML document to the stream.
+   *
+   * Refer to examples/cppunittest/XmlOutputterTest.cpp for example
+   * of use and XML document structure.
+   */
+  virtual void write();
+
+  /*! \brief Sets the XSL style sheet used.
+   *
+   * \param styleSheet Name of the style sheet used. If empty, then no style sheet
+   *                   is used (default).
+   */
+  virtual void setStyleSheet( const std::string &styleSheet );
+
+  /*! \brief set the output document as standalone or not.
+   *
+   *  For the output document, specify wether it's a standalone XML
+   *  document, or not.
+   *
+   *  \param standalone if true, the output will be specified as standalone.
+   *         if false, it will be not.
+   */
+  virtual void setStandalone( bool standalone );
+
+  typedef CppUnitMap<Test *,TestFailure*, std::less<Test*> > FailedTests;
+
+  /*! \brief Sets the root element and adds its children.
+   *
+   * Set the root element of the XML Document and add its child elements.
+   *
+   * For all hooks, call beginDocument() just after creating the root element (it
+   * is empty at this time), and endDocument() once all the datas have been added
+   * to the root element.
+   */
+  virtual void setRootNode();
+
+  virtual void addFailedTests( FailedTests &failedTests,
+                               XmlElement *rootNode );
+
+  virtual void addSuccessfulTests( FailedTests &failedTests,
+                                   XmlElement *rootNode );
+
+  /*! \brief Adds the statics element to the root node.
+   *
+   * Creates a new element containing statistics data and adds it to the root element.
+   * Then, for all hooks, call statisticsAdded().
+   * \param rootNode Root element.
+   */
+  virtual void addStatistics( XmlElement *rootNode );
+
+  /*! \brief Adds a failed test to the failed tests node.
+   * Creates a new element containing datas about the failed test, and adds it to
+   * the failed tests element.
+   * Then, for all hooks, call failTestAdded().
+   */
+  virtual void addFailedTest( Test *test,
+                              TestFailure *failure,
+                              int testNumber,
+                              XmlElement *testsNode );
+
+  virtual void addFailureLocation( TestFailure *failure,
+                                   XmlElement *testElement );
+
+
+  /*! \brief Adds a successful test to the successful tests node.
+   * Creates a new element containing datas about the successful test, and adds it to
+   * the successful tests element.
+   * Then, for all hooks, call successfulTestAdded().
+   */
+  virtual void addSuccessfulTest( Test *test,
+                                  int testNumber,
+                                  XmlElement *testsNode );
+protected:
+  virtual void fillFailedTestsMap( FailedTests &failedTests );
+
+protected:
+  typedef CppUnitDeque<XmlOutputterHook *> Hooks;
+
+  TestResultCollector *m_result;
+  OStream &m_stream;
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlDocument *m_xml;
+  Hooks m_hooks;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlOutputter( const XmlOutputter &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlOutputter &copy );
+
+private:
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_XMLTESTRESULTOUTPUTTER_H
diff --git a/src/test/cppunit/XmlOutputterHook.cpp b/src/test/cppunit/XmlOutputterHook.cpp
new file mode 100644
index 0000000..fc59b88
--- /dev/null
+++ b/src/test/cppunit/XmlOutputterHook.cpp
@@ -0,0 +1,44 @@
+#include <cppunit/XmlOutputterHook.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+void
+XmlOutputterHook::beginDocument( XmlDocument *document )
+{
+}
+
+
+void
+XmlOutputterHook::endDocument( XmlDocument *document )
+{
+}
+
+
+void
+XmlOutputterHook::failTestAdded( XmlDocument *document,
+                                 XmlElement *testElement,
+                                 Test *test,
+                                 TestFailure *failure )
+{
+}
+
+
+void
+XmlOutputterHook::successfulTestAdded( XmlDocument *document,
+                                       XmlElement *testElement,
+                                       Test *test )
+{
+}
+
+
+void
+XmlOutputterHook::statisticsAdded( XmlDocument *document,
+                                   XmlElement *statisticsElement )
+{
+}
+
+
+CPPUNIT_NS_END
+
diff --git a/src/test/cppunit/XmlOutputterHook.h b/src/test/cppunit/XmlOutputterHook.h
new file mode 100644
index 0000000..373b061
--- /dev/null
+++ b/src/test/cppunit/XmlOutputterHook.h
@@ -0,0 +1,163 @@
+#ifndef CPPUNIT_XMLOUTPUTTERHOOK_H
+#define CPPUNIT_XMLOUTPUTTERHOOK_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFailure;
+class XmlDocument;
+class XmlElement;
+
+
+
+/*! \brief Hook to customize Xml output.
+ *
+ * XmlOutputterHook can be passed to XmlOutputter to customize the XmlDocument.
+ *
+ * Common customizations are:
+ * - adding some datas to successfull or failed test with
+ *   failTestAdded() and successfulTestAdded(),
+ * - adding some statistics with statisticsAdded(),
+ * - adding other datas with beginDocument() or endDocument().
+ *
+ * See examples/ClockerPlugIn which makes use of most the hook.
+ *
+ * Another simple example of an outputter hook is shown below. It may be
+ * used to add some meta information to your result files. In the example,
+ * the author name as well as the project name and test creation date is
+ * added to the head of the xml file.
+ *
+ * In order to make this information stored within the xml file, the virtual
+ * member function beginDocument() is overriden where a new
+ * XmlElement object is created.
+ *
+ * This element is simply added to the root node of the document which
+ * makes the information automatically being stored when the xml file
+ * is written.
+ *
+ * \code
+ * #include <cppunit/XmlOutputterHook.h>
+ * #include <cppunit/XmlElement.h>
+ * #include <cppunit/tools/StringTools.h>
+ *
+ * ...
+ *
+ * class MyXmlOutputterHook : public CppUnit::XmlOutputterHook
+ * {
+ * public:
+ *   MyXmlOutputterHook(const std::string projectName,
+ *                      const std::string author)
+ *   {
+ *      m_projectName = projectName;
+ *      m_author      = author;
+ *   };
+ *
+ *   virtual ~MyXmlOutputterHook()
+ *   {
+ *   };
+ *
+ *   void beginDocument(CppUnit::XmlDocument* document)
+ *   {
+ *     if (!document)
+ *       return;
+ *
+ *     // dump current time
+ *     std::string szDate          = CppUnit::StringTools::toString( (int)time(0) );
+ *     CppUnit::XmlElement* metaEl = new CppUnit::XmlElement("SuiteInfo",
+ *                                                           "");
+ *
+ *     metaEl->addElement( new CppUnit::XmlElement("Author", m_author) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Project", m_projectName) );
+ *     metaEl->addElement( new CppUnit::XmlElement("Date", szDate ) );
+ *
+ *     document->rootElement().addElement(metaEl);
+ *   };
+ * private:
+ *   std::string m_projectName;
+ *   std::string m_author;
+ * };
+ * \endcode
+ *
+ * Within your application's main code, you need to snap the hook
+ * object into your xml outputter object like shown below:
+ *
+ * \code
+ * CppUnit::TextUi::TestRunner runner;
+ * std::ofstream outputFile("testResults.xml");
+ *
+ * CppUnit::XmlOutputter* outputter = new CppUnit::XmlOutputter( &runner.result(),
+ *                                                               outputFile );
+ * MyXmlOutputterHook hook("myProject", "meAuthor");
+ * outputter->addHook(&hook);
+ * runner.setOutputter(outputter);
+ * runner.addTest( VectorFixture::suite() );
+ * runner.run();
+ * outputFile.close();
+ * \endcode
+ *
+ * This results into the following output:
+ *
+ * \code
+ * <TestRun>
+ *   <suiteInfo>
+ *     <author>meAuthor</author>
+ *     <project>myProject</project>
+ *     <date>1028143912</date>
+ *   </suiteInfo>
+ *   <FailedTests>
+ *    ...
+ * \endcode
+ *
+ * \see XmlOutputter, CppUnitTestPlugIn.
+ */
+class CPPUNIT_API XmlOutputterHook
+{
+public:
+  /*! Called before any elements is added to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void beginDocument( XmlDocument *document );
+
+  /*! Called after adding all elements to the root element.
+   * \param document XML Document being created.
+   */
+  virtual void endDocument( XmlDocument *document );
+
+  /*! Called after adding a fail test element.
+   * \param document XML Document being created.
+   * \param testElement \<FailedTest\> element.
+   * \param test Test that failed.
+   * \param failure Test failure data.
+   */
+  virtual void failTestAdded( XmlDocument *document,
+                              XmlElement *testElement,
+                              Test *test,
+                              TestFailure *failure );
+
+  /*! Called after adding a successful test element.
+   * \param document XML Document being created.
+   * \param testElement \<Test\> element.
+   * \param test Test that was successful.
+   */
+  virtual void successfulTestAdded( XmlDocument *document,
+                                    XmlElement *testElement,
+                                    Test *test );
+
+  /*! Called after adding the statistic element.
+   * \param document XML Document being created.
+   * \param statisticsElement \<Statistics\> element.
+   */
+  virtual void statisticsAdded( XmlDocument *document,
+                                XmlElement *statisticsElement );
+
+  virtual ~XmlOutputterHook() {}
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_XMLOUTPUTTERHOOK_H
diff --git a/src/test/cppunit/config/CppUnitApi.h b/src/test/cppunit/config/CppUnitApi.h
new file mode 100644
index 0000000..991b2bc
--- /dev/null
+++ b/src/test/cppunit/config/CppUnitApi.h
@@ -0,0 +1,33 @@
+#ifndef CPPUNIT_CONFIG_CPPUNITAPI
+#define CPPUNIT_CONFIG_CPPUNITAPI
+
+#undef CPPUNIT_API
+
+#ifdef WIN32
+
+// define CPPUNIT_DLL_BUILD when building CppUnit dll.
+#ifdef CPPUNIT_BUILD_DLL
+#define CPPUNIT_API __declspec(dllexport)
+#endif
+
+// define CPPUNIT_DLL when linking to CppUnit dll.
+#ifdef CPPUNIT_DLL
+#define CPPUNIT_API __declspec(dllimport)
+#endif
+
+#ifdef CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 1
+#endif
+
+#endif
+
+
+#ifndef CPPUNIT_API
+#define CPPUNIT_API
+#undef CPPUNIT_NEED_DLL_DECL
+#define CPPUNIT_NEED_DLL_DECL 0
+#endif
+
+
+#endif  // CPPUNIT_CONFIG_CPPUNITAPI
diff --git a/src/test/cppunit/config/Makefile.am b/src/test/cppunit/config/Makefile.am
new file mode 100644
index 0000000..2f0b1f8
--- /dev/null
+++ b/src/test/cppunit/config/Makefile.am
@@ -0,0 +1,10 @@
+libcppunitincludedir = $(includedir)/cppunit/config
+
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-evc4.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h \
+  SourcePrefix.h
diff --git a/src/test/cppunit/config/Makefile.in b/src/test/cppunit/config/Makefile.in
new file mode 100644
index 0000000..4c21edb
--- /dev/null
+++ b/src/test/cppunit/config/Makefile.in
@@ -0,0 +1,438 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/config
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/config
+libcppunitinclude_HEADERS = \
+	config-bcb5.h \
+	config-evc4.h \
+	config-mac.h \
+	config-msvc6.h \
+	SelectDllLoader.h \
+	CppUnitApi.h \
+  SourcePrefix.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/config/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/config/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/config/SelectDllLoader.h b/src/test/cppunit/config/SelectDllLoader.h
new file mode 100644
index 0000000..96c9eec
--- /dev/null
+++ b/src/test/cppunit/config/SelectDllLoader.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNIT_CONFIG_SELECTDLLLOADER_H
+#define CPPUNIT_CONFIG_SELECTDLLLOADER_H
+
+/*! \file
+ * Selects DynamicLibraryManager implementation.
+ *
+ * Don't include this file directly. Include Portability.h instead.
+ */
+
+/*!
+ * \def CPPUNIT_NO_TESTPLUGIN
+ * \brief If defined, then plug-in related classes and functions will not be compiled.
+ *
+ * \internal
+ * CPPUNIT_HAVE_WIN32_DLL_LOADER
+ * If defined, Win32 implementation of DynamicLibraryManager will be used.
+ *
+ * CPPUNIT_HAVE_BEOS_DLL_LOADER
+ * If defined, BeOs implementation of DynamicLibraryManager will be used.
+ *
+ * CPPUNIT_HAVE_UNIX_DLL_LOADER
+ * If defined, Unix implementation (dlfcn.h) of DynamicLibraryManager will be used.
+ */
+
+/*!
+ * \def CPPUNIT_PLUGIN_EXPORT
+ * \ingroup WritingTestPlugIn
+ * \brief A macro to export a function from a dynamic library
+ *
+ * This macro export the C function following it from a dynamic library.
+ * Exporting the function makes it accessible to the DynamicLibraryManager.
+ *
+ * Example of usage:
+ * \code
+ * #include <cppunit/include/plugin/TestPlugIn.h>
+ *
+ * CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)
+ * {
+ *   ...
+ *   return &myPlugInInterface;
+ * }
+ * \endcode
+ */
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+// Is WIN32 platform ?
+#if defined(WIN32)
+#define CPPUNIT_HAVE_WIN32_DLL_LOADER 1
+#undef CPPUNIT_PLUGIN_EXPORT
+#define CPPUNIT_PLUGIN_EXPORT extern "C" __declspec(dllexport)
+
+// Is BeOS platform ?
+#elif defined(__BEOS__)
+#define CPPUNIT_HAVE_BEOS_DLL_LOADER 1
+
+// Is Unix platform and have shl_load() (hp-ux)
+#elif defined(CPPUNIT_HAVE_SHL_LOAD)
+#define CPPUNIT_HAVE_UNIX_SHL_LOADER 1
+
+// Is Unix platform and have include <dlfcn.h>
+#elif defined(CPPUNIT_HAVE_LIBDL)
+#define CPPUNIT_HAVE_UNIX_DLL_LOADER 1
+
+// Otherwise, disable support for DllLoader
+#else
+#define CPPUNIT_NO_TESTPLUGIN 1
+#endif
+
+#if !defined(CPPUNIT_PLUGIN_EXPORT)
+#define CPPUNIT_PLUGIN_EXPORT extern "C"
+#endif // !defined(CPPUNIT_PLUGIN_EXPORT)
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_CONFIG_SELECTDLLLOADER_H
diff --git a/src/test/cppunit/config/SourcePrefix.h b/src/test/cppunit/config/SourcePrefix.h
new file mode 100644
index 0000000..2334601
--- /dev/null
+++ b/src/test/cppunit/config/SourcePrefix.h
@@ -0,0 +1,14 @@
+#ifndef CPPUNIT_CONFIG_H_INCLUDED
+#define CPPUNIT_CONFIG_H_INCLUDED
+
+#include <cppunit/Portability.h>
+
+#ifdef _MSC_VER
+#pragma warning(disable: 4018 4284 4146)
+#if _MSC_VER >= 1400
+#pragma warning(disable: 4996)		// sprintf is deprecated
+#endif
+#endif
+
+
+#endif // CPPUNIT_CONFIG_H_INCLUDED
diff --git a/src/test/cppunit/config/config-bcb5.h b/src/test/cppunit/config/config-bcb5.h
new file mode 100644
index 0000000..bbff4cf
--- /dev/null
+++ b/src/test/cppunit/config/config-bcb5.h
@@ -0,0 +1,47 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_BCB5_H
+#define _INCLUDE_CPPUNIT_CONFIG_BCB5_H 1
+
+#define HAVE_CMATH 1
+
+/* include/cppunit/config-bcb5.h. Manually adapted from
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifndef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#define CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST  0
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI
+#define CPPUNIT_HAVE_RTTI  1
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE
+#define CPPUNIT_PACKAGE  "cppunit"
+#endif
+
+/* _INCLUDE_CPPUNIT_CONFIG_BCB5_H */
+#endif
diff --git a/src/test/cppunit/config/config-evc4.h b/src/test/cppunit/config/config-evc4.h
new file mode 100644
index 0000000..746f988
--- /dev/null
+++ b/src/test/cppunit/config/config-evc4.h
@@ -0,0 +1,78 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_EVC4_H
+#define _INCLUDE_CPPUNIT_CONFIG_EVC4_H 1
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+#define HAVE_CMATH 1
+
+/* include/cppunit/config-msvc6.h. Manually adapted from
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI
+#define CPPUNIT_HAVE_RTTI  0
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI
+#endif
+
+#define CPPUNIT_NO_STREAM 1
+#define CPPUNIT_NO_ASSERT 1
+
+#define CPPUNIT_HAVE_SSTREAM 0
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE
+#define CPPUNIT_PACKAGE  "cppunit"
+#endif
+
+
+// Compiler error location format for CompilerOutputter
+// See class CompilerOutputter for format.
+#undef CPPUNIT_COMPILER_LOCATION_FORMAT
+#if _MSC_VER >= 1300    // VS 7.0
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l) : error : "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l):"
+#endif
+
+/* define to 1 if the compiler has _finite() */
+#ifndef CPPUNIT_HAVE__FINITE
+#define CPPUNIT_HAVE__FINITE 1
+#endif
+
+// Uncomment to turn on STL wrapping => use this to test compilation.
+// This will make CppUnit subclass std::vector & co to provide default
+// parameter.
+/*#define CPPUNIT_STD_NEED_ALLOCATOR 1
+#define CPPUNIT_STD_ALLOCATOR std::allocator<T>
+//#define CPPUNIT_NO_NAMESPACE 1
+*/
+
+
+/* _INCLUDE_CPPUNIT_CONFIG_EVC4_H */
+#endif
diff --git a/src/test/cppunit/config/config-mac.h b/src/test/cppunit/config/config-mac.h
new file mode 100644
index 0000000..7dc0be2
--- /dev/null
+++ b/src/test/cppunit/config/config-mac.h
@@ -0,0 +1,58 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MAC_H
+#define _INCLUDE_CPPUNIT_CONFIG_MAC_H 1
+
+/* MacOS X should be installed using the configure script.
+   This file is for other macs.
+
+   It is not integrated into <cppunit/Portability.h> because we don't
+   know a suitable preprocessor symbol that will distinguish MacOS X
+   from other MacOS versions.  Email us if you know the answer.
+*/
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* define if the library defines strstream */
+#ifndef CPPUNIT_HAVE_CLASS_STRSTREAM
+#define CPPUNIT_HAVE_CLASS_STRSTREAM  1
+#endif
+
+/* Define if you have the <cmath> header file. */
+#ifdef CPPUNIT_HAVE_CMATH
+#undef CPPUNIT_HAVE_CMATH
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI
+#define CPPUNIT_HAVE_RTTI  1
+#endif
+
+/* define if the compiler has stringstream */
+#ifndef CPPUNIT_HAVE_SSTREAM
+#define CPPUNIT_HAVE_SSTREAM  1
+#endif
+
+/* Define if you have the <strstream> header file. */
+#ifndef CPPUNIT_HAVE_STRSTREAM
+#define CPPUNIT_HAVE_STRSTREAM  1
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI
+#endif
+
+/* _INCLUDE_CPPUNIT_CONFIG_MAC_H */
+#endif
diff --git a/src/test/cppunit/config/config-msvc6.h b/src/test/cppunit/config/config-msvc6.h
new file mode 100644
index 0000000..cc55485
--- /dev/null
+++ b/src/test/cppunit/config/config-msvc6.h
@@ -0,0 +1,83 @@
+#ifndef _INCLUDE_CPPUNIT_CONFIG_MSVC6_H
+#define _INCLUDE_CPPUNIT_CONFIG_MSVC6_H 1
+
+#if _MSC_VER > 1000     // VC++
+#pragma warning( disable : 4786 )   // disable warning debug symbol > 255...
+#endif // _MSC_VER > 1000
+
+#define HAVE_CMATH 1
+
+/* include/cppunit/config-msvc6.h. Manually adapted from
+   include/cppunit/config-auto.h */
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if library uses std::string::compare(string,pos,n) */
+#ifdef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#undef CPPUNIT_FUNC_STRING_COMPARE_STRING_FIRST
+#endif
+
+/* Define if you have the <dlfcn.h> header file. */
+#ifdef CPPUNIT_HAVE_DLFCN_H
+#undef CPPUNIT_HAVE_DLFCN_H
+#endif
+
+/* define to 1 if the compiler implements namespaces */
+#ifndef CPPUNIT_HAVE_NAMESPACES
+#define CPPUNIT_HAVE_NAMESPACES  1
+#endif
+
+/* define if the compiler supports Run-Time Type Identification */
+#ifndef CPPUNIT_HAVE_RTTI
+# ifdef _CPPRTTI // Defined by the compiler option /GR
+#  define CPPUNIT_HAVE_RTTI 1
+# else
+#  define CPPUNIT_HAVE_RTTI 0
+# endif
+#endif
+
+/* Define to 1 to use type_info::name() for class names */
+#ifndef CPPUNIT_USE_TYPEINFO_NAME
+#define CPPUNIT_USE_TYPEINFO_NAME  CPPUNIT_HAVE_RTTI
+#endif
+
+#define CPPUNIT_HAVE_SSTREAM 1
+
+/* Name of package */
+#ifndef CPPUNIT_PACKAGE
+#define CPPUNIT_PACKAGE  "cppunit"
+#endif
+
+
+// Compiler error location format for CompilerOutputter
+// See class CompilerOutputter for format.
+#undef CPPUNIT_COMPILER_LOCATION_FORMAT
+#if _MSC_VER >= 1300    // VS 7.0
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l) : error : "
+#else
+# define CPPUNIT_COMPILER_LOCATION_FORMAT "%p(%l):"
+#endif
+
+// Define to 1 if the compiler support C++ style cast.
+#define CPPUNIT_HAVE_CPP_CAST 1
+
+/* define to 1 if the compiler has _finite() */
+#ifndef CPPUNIT_HAVE__FINITE
+#define CPPUNIT_HAVE__FINITE 1
+#endif
+
+
+// Uncomment to turn on STL wrapping => use this to test compilation.
+// This will make CppUnit subclass std::vector & co to provide default
+// parameter.
+/*#define CPPUNIT_STD_NEED_ALLOCATOR 1
+#define CPPUNIT_STD_ALLOCATOR std::allocator<T>
+//#define CPPUNIT_NO_NAMESPACE 1
+*/
+
+
+/* _INCLUDE_CPPUNIT_CONFIG_MSVC6_H */
+#endif
diff --git a/src/test/cppunit/cppunit.dsp b/src/test/cppunit/cppunit.dsp
new file mode 100644
index 0000000..1372aed
--- /dev/null
+++ b/src/test/cppunit/cppunit.dsp
@@ -0,0 +1,707 @@
+# Microsoft Developer Studio Project File - Name="cppunit" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=CPPUNIT - WIN32 DEBUG
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE
+!MESSAGE NMAKE /f "cppunit.mak".
+!MESSAGE
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE
+!MESSAGE NMAKE /f "cppunit.mak" CFG="CPPUNIT - WIN32 DEBUG"
+!MESSAGE
+!MESSAGE Possible choices for configuration are:
+!MESSAGE
+!MESSAGE "cppunit - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "cppunit - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "cppunit - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GR /GX /Zd /O2 /I "..\..\include" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "WIN32" /YX /FD /c
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+# Begin Special Build Tool
+TargetPath=.\Release\cppunit.lib
+TargetName=cppunit
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "cppunit - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GR /GX /Zi /Od /I "..\..\include" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "WIN32" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\cppunitd.lib"
+# Begin Special Build Tool
+TargetPath=.\Debug\cppunitd.lib
+TargetName=cppunitd
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ENDIF
+
+# Begin Target
+
+# Name "cppunit - Win32 Release"
+# Name "cppunit - Win32 Debug"
+# Begin Group "documentation"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\ChangeLog
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\CodingGuideLines.txt
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\cookbook.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\FAQ
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\INSTALL-unix"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\INSTALL-WIN32.txt"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\Money.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\NEWS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\other_documentation.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\THANKS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\TODO
+# End Source File
+# End Group
+# Begin Group "listener"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BriefTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\BriefTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResultCollector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResultCollector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuccessListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestResult.h
+# End Source File
+# End Group
+# Begin Group "textui"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TextTestRunner.h
+# End Source File
+# End Group
+# Begin Group "portability"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-bcb5.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-evc4.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-mac.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-msvc6.h"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\CppUnitApi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitDeque.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitMap.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitSet.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitStack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitVector.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\FloatingPoint.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Portability.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SelectDllLoader.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SourcePrefix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\Stream.h
+# End Source File
+# End Group
+# Begin Group "output"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\CompilerOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\CompilerOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Outputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputter.cpp
+
+!IF  "$(CFG)" == "cppunit - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "cppunit - Win32 Debug"
+
+# ADD CPP /W3
+
+!ENDIF
+
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputterHook.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputterHook.h
+# End Source File
+# End Group
+# Begin Group "core"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\AdditionalMessage.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\AdditionalMessage.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Asserter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Asserter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Exception.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Exception.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Message.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Message.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SourceLine.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SourceLine.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SynchronizedObject.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SynchronizedObject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Test.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Test.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestAssert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestAssert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCase.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCase.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestComposite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestComposite.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFailure.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFailure.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFixture.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestLeaf.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestLeaf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestPath.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResult.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestSuite.h
+# End Source File
+# End Group
+# Begin Group "helper"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\AutoRegisterSuite.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\HelperMacros.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCaller.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFactoryRegistry.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactoryRegistry.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFixtureFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestNamer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestNamer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuiteBuilderContext.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilderContext.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TypeInfoHelper.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TypeInfoHelper.h
+# End Source File
+# End Group
+# Begin Group "extension"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\ExceptionTestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\Orthodox.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\RepeatedTest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\RepeatedTest.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCaseDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSetUp.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSetUp.h
+# End Source File
+# End Group
+# Begin Group "plugin"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BeOsDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManagerException.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManagerException.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInParameters.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInParameters.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ShlDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPlugInDefaultImpl.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugInDefaultImpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\UnixDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\Win32DynamicLibraryManager.cpp
+# End Source File
+# End Group
+# Begin Group "tools"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\Algorithm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\StringTools.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\StringTools.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlDocument.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlDocument.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlElement.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlElement.h
+# End Source File
+# End Group
+# Begin Group "protector"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DefaultProtector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DefaultProtector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Protector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Protector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorContext.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE=..\..\configure.in
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=.\Makefile.am
+# End Source File
+# End Target
+# End Project
diff --git a/src/test/cppunit/cppunit_dll.dsp b/src/test/cppunit/cppunit_dll.dsp
new file mode 100644
index 0000000..287bf36
--- /dev/null
+++ b/src/test/cppunit/cppunit_dll.dsp
@@ -0,0 +1,682 @@
+# Microsoft Developer Studio Project File - Name="cppunit_dll" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=cppunit_dll - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE
+!MESSAGE NMAKE /f "cppunit_dll.mak".
+!MESSAGE
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE
+!MESSAGE NMAKE /f "cppunit_dll.mak" CFG="cppunit_dll - Win32 Debug"
+!MESSAGE
+!MESSAGE Possible choices for configuration are:
+!MESSAGE
+!MESSAGE "cppunit_dll - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "cppunit_dll - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "cppunit_dll - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "cppunit_dll___Win32_Release"
+# PROP BASE Intermediate_Dir "cppunit_dll___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "ReleaseDll"
+# PROP Intermediate_Dir "ReleaseDll"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_DLL_EXPORTS" /YX /FD /c
+# ADD CPP /nologo /MD /W3 /GR /GX /Zd /O2 /I "..\..\include" /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_BUILD_DLL" /YX /FD /c
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /pdb:"..\..\lib\cppunit_dll.pdb" /machine:I386
+# SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+TargetDir=.\ReleaseDll
+TargetPath=.\ReleaseDll\cppunit_dll.dll
+TargetName=cppunit_dll
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).dll	copy "$(TargetDir)\$(TargetName).lib" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "cppunit_dll - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "cppunit_dll___Win32_Debug"
+# PROP BASE Intermediate_Dir "cppunit_dll___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "DebugDll"
+# PROP Intermediate_Dir "DebugDll"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_DLL_EXPORTS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GR /GX /Zi /Od /I "..\..\include" /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "CPPUNIT_BUILD_DLL" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /pdb:"..\..\lib\cppunitd_dll.pdb" /debug /machine:I386 /out:"DebugDll\cppunitd_dll.dll" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+TargetDir=.\DebugDll
+TargetPath=.\DebugDll\cppunitd_dll.dll
+TargetName=cppunitd_dll
+SOURCE="$(InputPath)"
+PostBuild_Desc=Copying target to lib/
+PostBuild_Cmds=copy "$(TargetPath)" ..\..\lib\$(TargetName).dll	copy "$(TargetDir)\$(TargetName).lib" ..\..\lib\$(TargetName).lib
+# End Special Build Tool
+
+!ENDIF
+
+# Begin Target
+
+# Name "cppunit_dll - Win32 Release"
+# Name "cppunit_dll - Win32 Debug"
+# Begin Group "DllSpecific"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DllMain.cpp
+# End Source File
+# End Group
+# Begin Group "extension"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\ExceptionTestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\Orthodox.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\RepeatedTest.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\RepeatedTest.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCaseDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestCaseDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestDecorator.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestDecorator.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSetUp.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSetUp.h
+# End Source File
+# End Group
+# Begin Group "helper"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\AutoRegisterSuite.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\HelperMacros.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCaller.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFactoryRegistry.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFactoryRegistry.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestFixtureFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestNamer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestNamer.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilder.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuiteBuilderContext.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteBuilderContext.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TestSuiteFactory.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TypeInfoHelper.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\TypeInfoHelper.h
+# End Source File
+# End Group
+# Begin Group "core"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\AdditionalMessage.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\AdditionalMessage.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Asserter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Asserter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Exception.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Exception.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Message.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Message.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SourceLine.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SourceLine.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\SynchronizedObject.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\SynchronizedObject.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Test.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Test.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestAssert.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestAssert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestCase.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestCase.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestComposite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestComposite.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestFailure.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFailure.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestFixture.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestLeaf.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestLeaf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPath.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestPath.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResult.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuite.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestSuite.h
+# End Source File
+# End Group
+# Begin Group "output"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\CompilerOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\CompilerOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Outputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestResultCollector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TestResultCollector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputter.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputter.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlOutputterHook.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\XmlOutputterHook.h
+# End Source File
+# End Group
+# Begin Group "portability"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-bcb5.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-mac.h"
+# End Source File
+# Begin Source File
+
+SOURCE="..\..\include\cppunit\config\config-msvc6.h"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\CppUnitApi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitDeque.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitMap.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitSet.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitStack.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\portability\CppUnitVector.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Portability.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SelectDllLoader.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\config\SourcePrefix.h
+# End Source File
+# End Group
+# Begin Group "textui"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestRunner.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestRunner.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\ui\text\TextTestRunner.h
+# End Source File
+# End Group
+# Begin Group "listener"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BriefTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\BriefTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestSuccessListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestProgressListener.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestProgressListener.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TextTestResult.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\TextTestResult.h
+# End Source File
+# End Group
+# Begin Group "documentation"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\..\ChangeLog
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\cookbook.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\FAQ
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\NEWS
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\doc\other_documentation.dox
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\TODO
+# End Source File
+# End Group
+# Begin Group "plugin"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\BeosDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\DynamicLibraryManagerException.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\DynamicLibraryManagerException.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInManager.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\PlugInParameters.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\PlugInParameters.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugIn.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\TestPlugInDefaultImpl.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\plugin\TestPlugInDefaultImpl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\UnixDynamicLibraryManager.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\Win32DynamicLibraryManager.cpp
+# End Source File
+# End Group
+# Begin Group "tools"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\StringTools.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\StringTools.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlDocument.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlDocument.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\XmlElement.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\tools\XmlElement.h
+# End Source File
+# End Group
+# Begin Group "protector"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\DefaultProtector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\DefaultProtector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\Protector.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Protector.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorChain.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\ProtectorContext.h
+# End Source File
+# End Group
+# Begin Source File
+
+SOURCE="..\..\INSTALL-WIN32.txt"
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=.\Makefile.am
+# End Source File
+# Begin Source File
+
+SOURCE=..\..\include\cppunit\extensions\XmlInputHelper.h
+# End Source File
+# End Target
+# End Project
diff --git a/src/test/cppunit/extensions/AutoRegisterSuite.h b/src/test/cppunit/extensions/AutoRegisterSuite.h
new file mode 100644
index 0000000..e04adb5
--- /dev/null
+++ b/src/test/cppunit/extensions/AutoRegisterSuite.h
@@ -0,0 +1,83 @@
+#ifndef CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+#define CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
+
+#include <cppunit/extensions/TestSuiteFactory.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief (Implementation) Automatically register the test suite of the specified type.
+ *
+ * You should not use this class directly. Instead, use the following macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION()
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION()
+ *
+ * This object will register the test returned by TestCaseType::suite()
+ * when constructed to the test registry.
+ *
+ * This object is intented to be used as a static variable.
+ *
+ *
+ * \param TestCaseType Type of the test case which suite is registered.
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CppUnit::TestFactoryRegistry.
+ */
+template<class TestCaseType>
+class AutoRegisterSuite
+{
+public:
+  /** Auto-register the suite factory in the global registry.
+   */
+  AutoRegisterSuite()
+      : m_registry( &TestFactoryRegistry::getRegistry() )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  /** Auto-register the suite factory in the specified registry.
+   * \param name Name of the registry.
+   */
+  AutoRegisterSuite( const std::string &name )
+      : m_registry( &TestFactoryRegistry::getRegistry( name ) )
+  {
+    m_registry->registerFactory( &m_factory );
+  }
+
+  ~AutoRegisterSuite()
+  {
+    if ( TestFactoryRegistry::isValid() )
+      m_registry->unregisterFactory( &m_factory );
+  }
+
+private:
+  TestFactoryRegistry *m_registry;
+  TestSuiteFactory<TestCaseType> m_factory;
+};
+
+
+/*! \brief (Implementation) Automatically adds a registry into another registry.
+ *
+ * Don't use this class. Use the macros CPPUNIT_REGISTRY_ADD() and
+ * CPPUNIT_REGISTRY_ADD_TO_DEFAULT() instead.
+ */
+class AutoRegisterRegistry
+{
+public:
+  AutoRegisterRegistry( const std::string &which,
+                        const std::string &to )
+  {
+    TestFactoryRegistry::getRegistry( to ).addRegistry( which );
+  }
+
+  AutoRegisterRegistry( const std::string &which )
+  {
+    TestFactoryRegistry::getRegistry().addRegistry( which );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_AUTOREGISTERSUITE_H
diff --git a/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h b/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
new file mode 100644
index 0000000..1969c8c
--- /dev/null
+++ b/src/test/cppunit/extensions/ExceptionTestCaseDecorator.h
@@ -0,0 +1,104 @@
+#ifndef CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Exception.h>
+#include <cppunit/extensions/TestCaseDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Expected exception test case decorator.
+ *
+ * A decorator used to assert that a specific test case should throw an
+ * exception of a given type.
+ *
+ * You should use this class only if you need to check the exception object
+ * state (that a specific cause is set for example). If you don't need to
+ * do that, you might consider using CPPUNIT_TEST_EXCEPTION() instead.
+ *
+ * Intended use is to subclass and override checkException(). Example:
+ *
+ * \code
+ *
+ * class NetworkErrorTestCaseDecorator :
+ *           public ExceptionTestCaseDecorator<NetworkError>
+ * {
+ * public:
+ *   NetworkErrorTestCaseDecorator( NetworkError::Cause expectedCause )
+ *       : m_expectedCause( expectedCause )
+ *   {
+ *   }
+ * private:
+ *   void checkException( ExpectedExceptionType &e )
+ *   {
+ *     CPPUNIT_ASSERT_EQUAL( m_expectedCause, e.getCause() );
+ *   }
+ *
+ *   NetworkError::Cause m_expectedCause;
+ * };
+ * \endcode
+ *
+ */
+template<class ExpectedException>
+class ExceptionTestCaseDecorator : public TestCaseDecorator
+{
+public:
+  typedef ExpectedException ExpectedExceptionType;
+
+  /*! \brief Decorates the specified test.
+   * \param test TestCase to decorate. Assumes ownership of the test.
+   */
+  ExceptionTestCaseDecorator( TestCase *test )
+      : TestCaseDecorator( test )
+  {
+  }
+
+  /*! \brief Checks that the expected exception is thrown by the decorated test.
+   * is thrown.
+   *
+   * Calls the decorated test runTest() and checks that an exception of
+   * type ExpectedException is thrown. Call checkException() passing the
+   * exception that was caught so that some assertions can be made if
+   * needed.
+   */
+  void runTest()
+  {
+    try
+    {
+      TestCaseDecorator::runTest();
+    }
+    catch ( ExpectedExceptionType &e )
+    {
+      checkException( e );
+      return;
+    }
+
+    // Moved outside the try{} statement to handle the case where the
+    // expected exception type is Exception (expecting assertion failure).
+#if CPPUNIT_USE_TYPEINFO_NAME
+      throw Exception( Message(
+                         "expected exception not thrown",
+                         "Expected exception type: " +
+                           TypeInfoHelper::getClassName(
+                               typeid( ExpectedExceptionType ) ) ) );
+#else
+      throw Exception( Message("expected exception not thrown") );
+#endif
+  }
+
+private:
+  /*! \brief Called when the exception is caught.
+   *
+   * Should be overriden to check the exception.
+   */
+  virtual void checkException( ExpectedExceptionType &e )
+  {
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_EXCEPTIONTESTCASEDECORATOR_H
+
diff --git a/src/test/cppunit/extensions/HelperMacros.h b/src/test/cppunit/extensions/HelperMacros.h
new file mode 100644
index 0000000..bd5b621
--- /dev/null
+++ b/src/test/cppunit/extensions/HelperMacros.h
@@ -0,0 +1,541 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file HelperMacros.h
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/04/15
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_EXTENSIONS_HELPERMACROS_H
+#define CPPUNIT_EXTENSIONS_HELPERMACROS_H
+
+#include <cppunit/TestCaller.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/extensions/AutoRegisterSuite.h>
+#include <cppunit/extensions/ExceptionTestCaseDecorator.h>
+#include <cppunit/extensions/TestFixtureFactory.h>
+#include <cppunit/extensions/TestNamer.h>
+#include <cppunit/extensions/TestSuiteBuilderContext.h>
+#include <memory>
+
+
+/*! \addtogroup WritingTestFixture Writing test fixture
+ */
+/** @{
+ */
+
+
+/** \file
+ * Macros intended to ease the definition of test suites.
+ *
+ * The macros
+ * CPPUNIT_TEST_SUITE(), CPPUNIT_TEST(), and CPPUNIT_TEST_SUITE_END()
+ * are designed to facilitate easy creation of a test suite.
+ * For example,
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST( testEquality );
+ *   CPPUNIT_TEST( testSetName );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testEquality();
+ *   void testSetName();
+ * };
+ * \endcode
+ *
+ * The effect of these macros is to define two methods in the
+ * class MyTest.  The first method is an auxiliary function
+ * named registerTests that you will not need to call directly.
+ * The second function
+ * \code static CppUnit::TestSuite *suite()\endcode
+ * returns a pointer to the suite of tests defined by the CPPUNIT_TEST()
+ * macros.
+ *
+ * Rather than invoking suite() directly,
+ * the macro CPPUNIT_TEST_SUITE_REGISTRATION() is
+ * used to create a static variable that automatically
+ * registers its test suite in a global registry.
+ * The registry yields a Test instance containing all the
+ * registered suites.
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( MyTest );
+ * CppUnit::Test* tp =
+ *   CppUnit::TestFactoryRegistry::getRegistry().makeTest();
+ * \endcode
+ *
+ * The test suite macros can even be used with templated test classes.
+ * For example:
+ *
+ * \code
+ * template<typename CharType>
+ * class StringTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( StringTest );
+ *   CPPUNIT_TEST( testAppend );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   ...
+ * };
+ * \endcode
+ *
+ * You need to add in an implementation file:
+ *
+ * \code
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<char> );
+ * CPPUNIT_TEST_SUITE_REGISTRATION( StringTest<wchar_t> );
+ * \endcode
+ */
+
+
+/*! \brief Begin test suite
+ *
+ * This macro starts the declaration of a new test suite.
+ * Use CPPUNIT_TEST_SUB_SUITE() instead, if you wish to include the
+ * test suite of the parent class.
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \see CPPUNIT_TEST_SUB_SUITE, CPPUNIT_TEST, CPPUNIT_TEST_SUITE_END,
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_EXCEPTION, CPPUNIT_TEST_FAIL.
+ */
+#define CPPUNIT_TEST_SUITE( ATestFixtureType )                              \
+  public:                                                                   \
+    typedef ATestFixtureType TestFixtureType;                               \
+                                                                            \
+  private:                                                                  \
+    static const CPPUNIT_NS::TestNamer &getTestNamer__()                    \
+    {                                                                       \
+      static CPPUNIT_TESTNAMER_DECL( testNamer, ATestFixtureType );         \
+      return testNamer;                                                     \
+    }                                                                       \
+                                                                            \
+  public:                                                                   \
+    typedef CPPUNIT_NS::TestSuiteBuilderContext<TestFixtureType>            \
+                TestSuiteBuilderContextType;                                \
+                                                                            \
+    static void                                                             \
+    addTestsToSuite( CPPUNIT_NS::TestSuiteBuilderContextBase &baseContext ) \
+    {                                                                       \
+      TestSuiteBuilderContextType context( baseContext )
+
+
+/*! \brief Begin test suite (includes parent suite)
+ *
+ * This macro may only be used in a class whose parent class
+ * defines a test suite using CPPUNIT_TEST_SUITE() or CPPUNIT_TEST_SUB_SUITE().
+ *
+ * This macro begins the declaration of a test suite, in the same
+ * manner as CPPUNIT_TEST_SUITE().  In addition, the test suite of the
+ * parent is automatically inserted in the test suite being
+ * defined.
+ *
+ * Here is an example:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class MySubTest : public MyTest {
+ *   CPPUNIT_TEST_SUB_SUITE( MySubTest, MyTest );
+ *   CPPUNIT_TEST( testAdd );
+ *   CPPUNIT_TEST( testSub );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testAdd();
+ *   void testSub();
+ * };
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class. This type \b MUST
+ *                         be derived from TestFixture.
+ * \param ASuperClass   Type of the parent class.
+ * \see CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST_SUB_SUITE( ATestFixtureType, ASuperClass )  \
+  public:                                                        \
+    typedef ASuperClass ParentTestFixtureType;                   \
+  private:                                                       \
+    CPPUNIT_TEST_SUITE( ATestFixtureType );                      \
+      ParentTestFixtureType::addTestsToSuite( baseContext )
+
+
+/*! \brief End declaration of the test suite.
+ *
+ * After this macro, member access is set to "private".
+ *
+ * \see  CPPUNIT_TEST_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END()                                               \
+    }                                                                          \
+                                                                               \
+    static CPPUNIT_NS::TestSuite *suite()                                      \
+    {                                                                          \
+      const CPPUNIT_NS::TestNamer &namer = getTestNamer__();                   \
+      std::auto_ptr<CPPUNIT_NS::TestSuite> suite(                              \
+             new CPPUNIT_NS::TestSuite( namer.getFixtureName() ));             \
+      CPPUNIT_NS::ConcretTestFixtureFactory<TestFixtureType> factory;          \
+      CPPUNIT_NS::TestSuiteBuilderContextBase context( *suite.get(),           \
+                                                       namer,                  \
+                                                       factory );              \
+      TestFixtureType::addTestsToSuite( context );                             \
+      return suite.release();                                                  \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+/*! \brief End declaration of an abstract test suite.
+ *
+ * Use this macro to indicate that the %TestFixture is abstract. No
+ * static suite() method will be declared.
+ *
+ * After this macro, member access is set to "private".
+ *
+ * Here is an example of usage:
+ *
+ * The abstract test fixture:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * class AbstractDocument;
+ * class AbstractDocumentTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertText );
+ *   CPPUNIT_TEST_SUITE_END_ABSTRACT();
+ * public:
+ *   void testInsertText();
+ *
+ *   void setUp()
+ *   {
+ *     m_document = makeDocument();
+ *   }
+ *
+ *   void tearDown()
+ *   {
+ *     delete m_document;
+ *   }
+ * protected:
+ *   virtual AbstractDocument *makeDocument() =0;
+ *
+ *   AbstractDocument *m_document;
+ * };\endcode
+ *
+ * The concret test fixture:
+ * \code
+ * class RichTextDocumentTest : public AbstractDocumentTest {
+ *   CPPUNIT_TEST_SUB_SUITE( RichTextDocumentTest, AbstractDocumentTest );
+ *   CPPUNIT_TEST( testInsertFormatedText );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testInsertFormatedText();
+ * protected:
+ *   AbstractDocument *makeDocument()
+ *   {
+ *     return new RichTextDocument();
+ *   }
+ * };\endcode
+ *
+ * \see  CPPUNIT_TEST_SUB_SUITE.
+ * \see  CPPUNIT_TEST_SUITE_REGISTRATION.
+ */
+#define CPPUNIT_TEST_SUITE_END_ABSTRACT()                                      \
+    }                                                                          \
+  private: /* dummy typedef so that the macro can still end with ';'*/         \
+    typedef int CppUnitDummyTypedefForSemiColonEnding__
+
+
+/*! \brief Add a test to the suite (for custom test macro).
+ *
+ * The specified test will be added to the test suite being declared. This macro
+ * is intended for \e advanced usage, to extend %CppUnit by creating new macro such
+ * as CPPUNIT_TEST_EXCEPTION()...
+ *
+ * Between macro CPPUNIT_TEST_SUITE() and CPPUNIT_TEST_SUITE_END(), you can assume
+ * that the following variables can be used:
+ * \code
+ * typedef TestSuiteBuilder<TestFixtureType> TestSuiteBuilderType;
+ * TestSuiteBuilderType &context;
+ * \endcode
+ *
+ * \c context can be used to name test case, create new test fixture instance,
+ * or add test case to the test fixture suite.
+ *
+ * Below is an example that show how to use this macro to create new macro to add
+ * test to the fixture suite. The macro below show how you would add a new type
+ * of test case which fails if the execution last more than a given time limit.
+ * It relies on an imaginary TimeOutTestCaller class which has an interface similar
+ * to TestCaller.
+ *
+ * \code
+ * #define CPPUNITEX_TEST_TIMELIMIT( testMethod, timeLimit )            \
+ *      CPPUNIT_TEST_SUITE_ADD_TEST( (new TimeOutTestCaller<TestFixtureType>(  \
+ *                  namer.getTestNameFor( #testMethod ),                \
+ *                  &TestFixtureType::testMethod,                   \
+ *                  factory.makeFixture(),                              \
+ *                  timeLimit ) ) )
+ *
+ * class PerformanceTest : CppUnit::TestFixture
+ * {
+ * public:
+ *   CPPUNIT_TEST_SUITE( PerformanceTest );
+ *   CPPUNITEX_TEST_TIMELIMIT( testSortReverseOrder, 5.0 );
+ *   CPPUNIT_TEST_SUITE_END();
+ *
+ *   void testSortReverseOrder();
+ * };
+ * \endcode
+ *
+ * \param test Test to add to the suite. Must be a subclass of Test. The test name
+ *             should have been obtained using TestNamer::getTestNameFor().
+ */
+#define CPPUNIT_TEST_SUITE_ADD_TEST( test ) \
+      context.addTest( test )
+
+/*! \brief Add a method to the suite.
+ * \param testMethod Name of the method of the test case to add to the
+ *                   suite. The signature of the method must be of
+ *                   type: void testMethod();
+ * \see  CPPUNIT_TEST_SUITE.
+ */
+#define CPPUNIT_TEST( testMethod )                        \
+    CPPUNIT_TEST_SUITE_ADD_TEST(                           \
+        ( new CPPUNIT_NS::TestCaller<TestFixtureType>(    \
+                  context.getTestNameFor( #testMethod),   \
+                  &TestFixtureType::testMethod,           \
+                  context.makeFixture() ) ) )
+
+/*! \brief Add a test which fail if the specified exception is not caught.
+ *
+ * Example:
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ * #include <vector>
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_EXCEPTION( testVectorAtThrow, std::invalid_argument );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   void testVectorAtThrow()
+ *   {
+ *     std::vector<int> v;
+ *     v.at( 1 );     // must throw exception std::invalid_argument
+ *   }
+ * };
+ * \endcode
+ *
+ * \param testMethod Name of the method of the test case to add to the suite.
+ * \param ExceptionType Type of the exception that must be thrown by the test
+ *                      method.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_THROW instead.
+ */
+#define CPPUNIT_TEST_EXCEPTION( testMethod, ExceptionType )          \
+  CPPUNIT_TEST_SUITE_ADD_TEST(                                        \
+      (new CPPUNIT_NS::ExceptionTestCaseDecorator< ExceptionType >(  \
+          new CPPUNIT_NS::TestCaller< TestFixtureType >(             \
+                               context.getTestNameFor( #testMethod ),  \
+                               &TestFixtureType::testMethod,         \
+                               context.makeFixture() ) ) ) )
+
+/*! \brief Adds a test case which is excepted to fail.
+ *
+ * The added test case expect an assertion to fail. You usually used that type
+ * of test case when testing custom assertion macros.
+ *
+ * \code
+ * CPPUNIT_TEST_FAIL( testAssertFalseFail );
+ *
+ * void testAssertFalseFail()
+ * {
+ *   CPPUNIT_ASSERT( false );
+ * }
+ * \endcode
+ * \see CreatingNewAssertions.
+ * \deprecated Use the assertion macro CPPUNIT_ASSERT_ASSERTION_FAIL instead.
+ */
+#define CPPUNIT_TEST_FAIL( testMethod ) \
+              CPPUNIT_TEST_EXCEPTION( testMethod, CPPUNIT_NS::Exception )
+
+/*! \brief Adds some custom test cases.
+ *
+ * Use this to add one or more test cases to the fixture suite. The specified
+ * method is called with a context parameter that can be used to name,
+ * instantiate fixture, and add instantiated test case to the fixture suite.
+ * The specified method must have the following signature:
+ * \code
+ * static void aMethodName( TestSuiteBuilderContextType &context );
+ * \endcode
+ *
+ * \c TestSuiteBuilderContextType is typedef to
+ * TestSuiteBuilderContext<TestFixtureType> declared by CPPUNIT_TEST_SUITE().
+ *
+ * Here is an example that add two custom tests:
+ *
+ * \code
+ * #include <cppunit/extensions/HelperMacros.h>
+ *
+ * class MyTest : public CppUnit::TestFixture {
+ *   CPPUNIT_TEST_SUITE( MyTest );
+ *   CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( addTimeOutTests );
+ *   CPPUNIT_TEST_SUITE_END();
+ * public:
+ *   static void addTimeOutTests( TestSuiteBuilderContextType &context )
+ *   {
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test1" ) ),
+ *                                             &MyTest::test1,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *     context.addTest( new TimeOutTestCaller( context.getTestNameFor( "test2" ) ),
+ *                                             &MyTest::test2,
+ *                                             context.makeFixture(),
+ *                                             5.0 );
+ *   }
+ *
+ *   void test1()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ *
+ *   void test2()
+ *   {
+ *     // Do some test that may never end...
+ *   }
+ * };
+ * \endcode
+ * @param testAdderMethod Name of the method called to add the test cases.
+ */
+#define CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS( testAdderMethod ) \
+      testAdderMethod( context )
+
+/*! \brief Adds a property to the test suite builder context.
+ * \param APropertyKey   Key of the property to add.
+ * \param APropertyValue Value for the added property.
+ * Example:
+ * \code
+ * CPPUNIT_TEST_SUITE_PROPERTY("XmlFileName", "paraTest.xml"); \endcode
+ */
+#define CPPUNIT_TEST_SUITE_PROPERTY( APropertyKey, APropertyValue ) \
+    context.addProperty( std::string(APropertyKey),                 \
+                         std::string(APropertyValue) )
+
+/** @}
+ */
+
+
+/*! Adds the specified fixture suite to the unnamed registry.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in a global registry
+ * of such factories.  The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ *
+ * \param ATestFixtureType Type of the test case class.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite,
+ *      CppUnit::TestFactoryRegistry.
+ */
+#define CPPUNIT_TEST_SUITE_REGISTRATION( ATestFixtureType )      \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >       \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )
+
+
+/** Adds the specified fixture suite to the specified registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro declares a static variable whose construction
+ * causes a test suite factory to be inserted in the global registry
+ * suite of the specified name. The registry is available by calling
+ * the static function CppUnit::TestFactoryRegistry::getRegistry().
+ *
+ * For the suite name, use a string returned by a static function rather
+ * than a hardcoded string. That way, you can know what are the name of
+ * named registry and you don't risk mistyping the registry name.
+ *
+ * \code
+ * // MySuites.h
+ * namespace MySuites {
+ *   std::string math() {
+ *     return "Math";
+ *   }
+ * }
+ *
+ * // ComplexNumberTest.cpp
+ * #include "MySuites.h"
+ *
+ * CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ComplexNumberTest, MySuites::math() );
+ * \endcode
+ *
+ * \param ATestFixtureType Type of the test case class.
+ * \param suiteName Name of the global registry suite the test suite is
+ *                  registered into.
+ * \warning This macro should be used only once per line of code (the line
+ *          number is used to name a hidden static variable).
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT
+ * \see CPPUNIT_REGISTRY_ADD
+ * \see CPPUNIT_TEST_SUITE, CppUnit::AutoRegisterSuite,
+ *      CppUnit::TestFactoryRegistry..
+ */
+#define CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ATestFixtureType, suiteName ) \
+  static CPPUNIT_NS::AutoRegisterSuite< ATestFixtureType >                   \
+             CPPUNIT_MAKE_UNIQUE_NAME(autoRegisterRegistry__ )(suiteName)
+
+/*! Adds that the specified registry suite to another registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * Use this macros to automatically create test registry suite hierarchy. For example,
+ * if you want to create the following hierarchy:
+ * - Math
+ *   - IntegerMath
+ *   - FloatMath
+ *     - FastFloat
+ *     - StandardFloat
+ *
+ * You can do this automatically with:
+ * \code
+ * CPPUNIT_REGISTRY_ADD( "FastFloat", "FloatMath" );
+ * CPPUNIT_REGISTRY_ADD( "IntegerMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "FloatMath", "Math" );
+ * CPPUNIT_REGISTRY_ADD( "StandardFloat", "FloatMath" );
+ * \endcode
+ *
+ * There is no specific order of declaration. Think of it as declaring links.
+ *
+ * You register the test in each suite using CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ *
+ * \param which Name of the registry suite to add to the registry suite named \a to.
+ * \param to Name of the registry suite \a which is added to.
+ * \see CPPUNIT_REGISTRY_ADD_TO_DEFAULT, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION.
+ */
+#define CPPUNIT_REGISTRY_ADD( which, to )                                     \
+  static CPPUNIT_NS::AutoRegisterRegistry                                     \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which, to )
+
+/*! Adds that the specified registry suite to the default registry suite.
+ * \ingroup CreatingTestSuite
+ *
+ * This macro is just like CPPUNIT_REGISTRY_ADD except the specified registry
+ * suite is added to the default suite (root suite).
+ *
+ * \param which Name of the registry suite to add to the default registry suite.
+ * \see CPPUNIT_REGISTRY_ADD.
+ */
+#define CPPUNIT_REGISTRY_ADD_TO_DEFAULT( which )                         \
+  static CPPUNIT_NS::AutoRegisterRegistry                                \
+             CPPUNIT_MAKE_UNIQUE_NAME( autoRegisterRegistry__ )( which )
+
+// Backwards compatibility
+// (Not tested!)
+
+#if CPPUNIT_ENABLE_CU_TEST_MACROS
+
+#define CU_TEST_SUITE(tc) CPPUNIT_TEST_SUITE(tc)
+#define CU_TEST_SUB_SUITE(tc,sc) CPPUNIT_TEST_SUB_SUITE(tc,sc)
+#define CU_TEST(tm) CPPUNIT_TEST(tm)
+#define CU_TEST_SUITE_END() CPPUNIT_TEST_SUITE_END()
+#define CU_TEST_SUITE_REGISTRATION(tc) CPPUNIT_TEST_SUITE_REGISTRATION(tc)
+
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_HELPERMACROS_H
diff --git a/src/test/cppunit/extensions/Makefile.am b/src/test/cppunit/extensions/Makefile.am
new file mode 100644
index 0000000..ff96de3
--- /dev/null
+++ b/src/test/cppunit/extensions/Makefile.am
@@ -0,0 +1,19 @@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
diff --git a/src/test/cppunit/extensions/Makefile.in b/src/test/cppunit/extensions/Makefile.in
new file mode 100644
index 0000000..c088904
--- /dev/null
+++ b/src/test/cppunit/extensions/Makefile.in
@@ -0,0 +1,446 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/extensions
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/extensions
+libcppunitinclude_HEADERS = \
+	TestFactory.h \
+	AutoRegisterSuite.h \
+	HelperMacros.h \
+	Orthodox.h \
+	RepeatedTest.h \
+	ExceptionTestCaseDecorator.h \
+	TestCaseDecorator.h \
+	TestDecorator.h \
+	TestFactoryRegistry.h \
+	TestFixtureFactory.h \
+	TestNamer.h \
+	TestSetUp.h \
+	TestSuiteBuilderContext.h \
+	TestSuiteFactory.h \
+	TypeInfoHelper.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/extensions/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/extensions/Orthodox.h b/src/test/cppunit/extensions/Orthodox.h
new file mode 100644
index 0000000..82970ef
--- /dev/null
+++ b/src/test/cppunit/extensions/Orthodox.h
@@ -0,0 +1,95 @@
+#ifndef CPPUNIT_EXTENSIONS_ORTHODOX_H
+#define CPPUNIT_EXTENSIONS_ORTHODOX_H
+
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*
+ * Orthodox performs a simple set of tests on an arbitary
+ * class to make sure that it supports at least the
+ * following operations:
+ *
+ *      default construction    - constructor
+ *      equality/inequality     - operator== && operator!=
+ *      assignment              - operator=
+ *      negation                - operator!
+ *      safe passage            - copy construction
+ *
+ * If operations for each of these are not declared
+ * the template will not instantiate.  If it does
+ * instantiate, tests are performed to make sure
+ * that the operations have correct semantics.
+ *
+ * Adding an orthodox test to a suite is very
+ * easy:
+ *
+ * public: Test *suite ()  {
+ *     TestSuite *suiteOfTests = new TestSuite;
+ *     suiteOfTests->addTest (new ComplexNumberTest ("testAdd");
+ *     suiteOfTests->addTest (new TestCaller<Orthodox<Complex> > ());
+ *     return suiteOfTests;
+ *  }
+ *
+ * Templated test cases be very useful when you are want to
+ * make sure that a group of classes have the same form.
+ *
+ * see TestSuite
+ */
+
+
+template <class ClassUnderTest> class Orthodox : public TestCase
+{
+public:
+                    Orthodox () : TestCase ("Orthodox") {}
+
+protected:
+    ClassUnderTest  call (ClassUnderTest object);
+    void            runTest ();
+
+
+};
+
+
+// Run an orthodoxy test
+template <class ClassUnderTest> void Orthodox<ClassUnderTest>::runTest ()
+{
+    // make sure we have a default constructor
+    ClassUnderTest   a, b, c;
+
+    // make sure we have an equality operator
+    CPPUNIT_ASSERT (a == b);
+
+    // check the inverse
+    b.operator= (a.operator! ());
+    CPPUNIT_ASSERT (a != b);
+
+    // double inversion
+    b = !!a;
+    CPPUNIT_ASSERT (a == b);
+
+    // invert again
+    b = !a;
+
+    // check calls
+    c = a;
+    CPPUNIT_ASSERT (c == call (a));
+
+    c = b;
+    CPPUNIT_ASSERT (c == call (b));
+
+}
+
+
+// Exercise a call
+template <class ClassUnderTest>
+ClassUnderTest Orthodox<ClassUnderTest>::call (ClassUnderTest object)
+{
+    return object;
+}
+
+
+CPPUNIT_NS_END
+
+#endif
diff --git a/src/test/cppunit/extensions/RepeatedTest.h b/src/test/cppunit/extensions/RepeatedTest.h
new file mode 100644
index 0000000..48f0ea6
--- /dev/null
+++ b/src/test/cppunit/extensions/RepeatedTest.h
@@ -0,0 +1,43 @@
+#ifndef CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+#define CPPUNIT_EXTENSIONS_REPEATEDTEST_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+
+/*! \brief Decorator that runs a test repeatedly.
+ *
+ * Does not assume ownership of the test it decorates
+ */
+class CPPUNIT_API RepeatedTest : public TestDecorator
+{
+public:
+  RepeatedTest( Test *test,
+                int timesRepeat ) :
+      TestDecorator( test ),
+      m_timesRepeat(timesRepeat)
+  {
+  }
+
+  void run( TestResult *result );
+
+  int countTestCases() const;
+
+private:
+  RepeatedTest( const RepeatedTest & );
+  void operator=( const RepeatedTest & );
+
+  const int m_timesRepeat;
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_REPEATEDTEST_H
diff --git a/src/test/cppunit/extensions/TestCaseDecorator.h b/src/test/cppunit/extensions/TestCaseDecorator.h
new file mode 100644
index 0000000..ea62b08
--- /dev/null
+++ b/src/test/cppunit/extensions/TestCaseDecorator.h
@@ -0,0 +1,40 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTCASEDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/TestCase.h>
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief  Decorator for Test cases.
+ *
+ * TestCaseDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */
+class CPPUNIT_API TestCaseDecorator : public TestCase
+{
+public:
+  TestCaseDecorator( TestCase *test );
+  ~TestCaseDecorator();
+
+  std::string getName() const;
+
+  void setUp();
+
+  void tearDown();
+
+  void runTest();
+
+protected:
+  TestCase *m_test;
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+
diff --git a/src/test/cppunit/extensions/TestDecorator.h b/src/test/cppunit/extensions/TestDecorator.h
new file mode 100644
index 0000000..8e0b428
--- /dev/null
+++ b/src/test/cppunit/extensions/TestDecorator.h
@@ -0,0 +1,49 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+#define CPPUNIT_EXTENSIONS_TESTDECORATOR_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/Test.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestResult;
+
+
+/*! \brief  Decorator for Tests.
+ *
+ * TestDecorator provides an alternate means to extend functionality
+ * of a test class without subclassing the test.  Instead, one can
+ * subclass the decorater and use it to wrap the test class.
+ *
+ * Does not assume ownership of the test it decorates
+ */
+class CPPUNIT_API TestDecorator : public Test
+{
+public:
+  TestDecorator( Test *test );
+  ~TestDecorator();
+
+  int countTestCases() const;
+
+  std::string getName() const;
+
+  void run( TestResult *result );
+
+  int getChildTestCount() const;
+
+protected:
+  Test *doGetChildTestAt( int index ) const;
+
+  Test *m_test;
+
+private:
+  TestDecorator( const TestDecorator &);
+  void operator =( const TestDecorator & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif
+
diff --git a/src/test/cppunit/extensions/TestFactory.h b/src/test/cppunit/extensions/TestFactory.h
new file mode 100644
index 0000000..b7f87c4
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFactory.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORY_H
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+
+/*! \brief Abstract Test factory.
+ */
+class CPPUNIT_API TestFactory
+{
+public:
+  virtual ~TestFactory() {}
+
+  /*! Makes a new test.
+   * \return A new Test.
+   */
+  virtual Test* makeTest() = 0;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORY_H
diff --git a/src/test/cppunit/extensions/TestFactoryRegistry.h b/src/test/cppunit/extensions/TestFactoryRegistry.h
new file mode 100644
index 0000000..f38e452
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFactoryRegistry.h
@@ -0,0 +1,182 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+#define CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251)  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitSet.h>
+#include <cppunit/extensions/TestFactory.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::set<TestFactory *>;
+#endif
+
+
+/*! \brief Registry for TestFactory.
+ * \ingroup CreatingTestSuite
+ *
+ * Notes that the registry \b DON'T assumes lifetime control for any registered tests
+ * anymore.
+ *
+ * The <em>default</em> registry is the registry returned by getRegistry() with the
+ * default name parameter value.
+ *
+ * To register tests, use the macros:
+ * - CPPUNIT_TEST_SUITE_REGISTRATION(): to add tests in the default registry.
+ * - CPPUNIT_TEST_SUITE_NAMED_REGISTRATION(): to add tests in a named registry.
+ *
+ * Example 1: retreiving a suite that contains all the test registered with
+ * CPPUNIT_TEST_SUITE_REGISTRATION().
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Example 2: retreiving a suite that contains all the test registered with
+ * \link CPPUNIT_TEST_SUITE_NAMED_REGISTRATION() CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )\endlink.
+ * \code
+ * CppUnit::TestFactoryRegistry &mathRegistry = CppUnit::TestFactoryRegistry::getRegistry( "Math" );
+ * CppUnit::TestSuite *mathSuite = mathRegistry.makeTest();
+ * \endcode
+ *
+ * Example 3: creating a test suite hierarchy composed of unnamed registration and
+ * named registration:
+ * - All Tests
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Graph" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_NAMED_REGISTRATION( ..., "Math" )
+ *   - tests registered with CPPUNIT_TEST_SUITE_REGISTRATION
+ *
+ * \code
+ * CppUnit::TestSuite *rootSuite = new CppUnit::TestSuite( "All tests" );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Graph" ).makeTest() );
+ * rootSuite->addTest( CppUnit::TestFactoryRegistry::getRegistry( "Math" ).makeTest() );
+ * CppUnit::TestFactoryRegistry::getRegistry().addTestToSuite( rootSuite );
+ * \endcode
+ *
+ * The same result can be obtained with:
+ * \code
+ * CppUnit::TestFactoryRegistry &registry = CppUnit::TestFactoryRegistry::getRegistry();
+ * registry.addRegistry( "Graph" );
+ * registry.addRegistry( "Math" );
+ * CppUnit::TestSuite *suite = registry.makeTest();
+ * \endcode
+ *
+ * Since a TestFactoryRegistry is a TestFactory, the named registries can be
+ * registered in the unnamed registry, creating the hierarchy links.
+ *
+ * \see TestSuiteFactory, AutoRegisterSuite
+ * \see CPPUNIT_TEST_SUITE_REGISTRATION, CPPUNIT_TEST_SUITE_NAMED_REGISTRATION
+ */
+class CPPUNIT_API TestFactoryRegistry : public TestFactory
+{
+public:
+  /** Constructs the registry with the specified name.
+   * \param name Name of the registry. It is the name of TestSuite returned by
+   *             makeTest().
+   */
+  TestFactoryRegistry( std::string name );
+
+  /// Destructor.
+  virtual ~TestFactoryRegistry();
+
+  /** Returns a new TestSuite that contains the registered test.
+   * \return A new TestSuite which contains all the test added using
+   * registerFactory(TestFactory *).
+   */
+  virtual Test *makeTest();
+
+  /** Returns a named registry.
+   *
+   * If the \a name is left to its default value, then the registry that is returned is
+   * the one used by CPPUNIT_TEST_SUITE_REGISTRATION(): the 'top' level registry.
+   *
+   * \param name Name of the registry to return.
+   * \return Registry. If the registry does not exist, it is created with the
+   *         specified name.
+   */
+  static TestFactoryRegistry &getRegistry( const std::string &name = "All Tests" );
+
+  /** Adds the registered tests to the specified suite.
+   * \param suite Suite the tests are added to.
+   */
+  void addTestToSuite( TestSuite *suite );
+
+  /** Adds the specified TestFactory to the registry.
+   *
+   * \param factory Factory to register.
+   */
+  void registerFactory( TestFactory *factory );
+
+  /*! Removes the specified TestFactory from the registry.
+   *
+   * The specified factory is not destroyed.
+   * \param factory Factory to remove from the registry.
+   * \todo Address case when trying to remove a TestRegistryFactory.
+   */
+  void unregisterFactory( TestFactory *factory );
+
+  /*! Adds a registry to the registry.
+   *
+   * Convenience method to help create test hierarchy. See TestFactoryRegistry detail
+   * for examples of use. Calling this method is equivalent to:
+   * \code
+   * this->registerFactory( TestFactoryRegistry::getRegistry( name ) );
+   * \endcode
+   *
+   * \param name Name of the registry to add.
+   */
+  void addRegistry( const std::string &name );
+
+  /*! Tests if the registry is valid.
+   *
+   * This method should be used when unregistering test factory on static variable
+   * destruction to ensure that the registry has not been already destroyed (in
+   * that case there is no need to unregister the test factory).
+   *
+   * You should not concern yourself with this method unless you are writing a class
+   * like AutoRegisterSuite.
+   *
+   * \return \c true if the specified registry has not been destroyed,
+   *         otherwise returns \c false.
+   * \see AutoRegisterSuite.
+   */
+  static bool isValid();
+
+  /** Adds the specified TestFactory with a specific name (DEPRECATED).
+   * \param name Name associated to the factory.
+   * \param factory Factory to register.
+   * \deprecated Use registerFactory( TestFactory *) instead.
+   */
+  void registerFactory( const std::string &name,
+                        TestFactory *factory );
+
+private:
+  TestFactoryRegistry( const TestFactoryRegistry &copy );
+  void operator =( const TestFactoryRegistry &copy );
+
+private:
+  typedef CppUnitSet<TestFactory *, std::less<TestFactory*> > Factories;
+  Factories m_factories;
+
+  std::string m_name;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_EXTENSIONS_TESTFACTORYREGISTRY_H
diff --git a/src/test/cppunit/extensions/TestFixtureFactory.h b/src/test/cppunit/extensions/TestFixtureFactory.h
new file mode 100644
index 0000000..a96ff15
--- /dev/null
+++ b/src/test/cppunit/extensions/TestFixtureFactory.h
@@ -0,0 +1,50 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+
+#include <cppunit/Portability.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class TestFixture;
+
+/*! \brief Abstract TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+class TestFixtureFactory
+{
+public:
+  //! Creates a new TestFixture instance.
+  virtual TestFixture *makeFixture() =0;
+
+  virtual ~TestFixtureFactory() {}
+};
+
+
+/*! \brief Concret TestFixture factory (Implementation).
+ *
+ * Implementation detail. Use by HelperMacros to handle TestFixture hierarchy.
+ */
+template<class TestFixtureType>
+class ConcretTestFixtureFactory : public CPPUNIT_NS::TestFixtureFactory
+{
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type
+   *         is that of the fixture on which the static method suite()
+   *         was called.
+   */
+  TestFixture *makeFixture()
+  {
+    return new TestFixtureType();
+  }
+};
+
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_EXTENSIONS_TESTFIXTUREFACTORY_H
+
diff --git a/src/test/cppunit/extensions/TestNamer.h b/src/test/cppunit/extensions/TestNamer.h
new file mode 100644
index 0000000..8191a11
--- /dev/null
+++ b/src/test/cppunit/extensions/TestNamer.h
@@ -0,0 +1,89 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTNAMER_H
+#define CPPUNIT_EXTENSIONS_TESTNAMER_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+#if CPPUNIT_HAVE_RTTI
+#  include <typeinfo>
+#endif
+
+
+
+/*! \def CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )
+ * \brief Declares a TestNamer.
+ *
+ * Declares a TestNamer for the specified type, using RTTI if enabled, otherwise
+ * using macro string expansion.
+ *
+ * RTTI is used if CPPUNIT_USE_TYPEINFO_NAME is defined and not null.
+ *
+ * \code
+ * void someMethod()
+ * {
+ *   CPPUNIT_TESTNAMER_DECL( namer, AFixtureType );
+ *   std::string fixtureName = namer.getFixtureName();
+ *   ...
+ * \endcode
+ *
+ * \relates TestNamer
+ * \see TestNamer
+ */
+#if CPPUNIT_USE_TYPEINFO_NAME
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( typeid(FixtureType) )
+#else
+#  define CPPUNIT_TESTNAMER_DECL( variableName, FixtureType )       \
+              CPPUNIT_NS::TestNamer variableName( std::string(#FixtureType) )
+#endif
+
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Names a test or a fixture suite.
+ *
+ * TestNamer is usually instantiated using CPPUNIT_TESTNAMER_DECL.
+ *
+ */
+class CPPUNIT_API TestNamer
+{
+public:
+#if CPPUNIT_HAVE_RTTI
+  /*! \brief Constructs a namer using the fixture's type-info.
+   * \param typeInfo Type-info of the fixture type. Use to name the fixture suite.
+   */
+  TestNamer( const std::type_info &typeInfo );
+#endif
+
+  /*! \brief Constructs a namer using the specified fixture name.
+   * \param fixtureName Name of the fixture suite. Usually extracted using a macro.
+   */
+  TestNamer( const std::string &fixtureName );
+
+  virtual ~TestNamer();
+
+  /*! \brief Returns the name of the fixture.
+   * \return Name of the fixture.
+   */
+  virtual std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name
+   *         (returned by getFixtureName()) and\a testMethodName,
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  virtual std::string getTestNameFor( const std::string &testMethodName ) const;
+
+protected:
+  std::string m_fixtureName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTNAMER_H
+
diff --git a/src/test/cppunit/extensions/TestSetUp.h b/src/test/cppunit/extensions/TestSetUp.h
new file mode 100644
index 0000000..4425ca3
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSetUp.h
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSETUP_H
+#define CPPUNIT_EXTENSIONS_TESTSETUP_H
+
+#include <cppunit/extensions/TestDecorator.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestResult;
+
+/*! \brief Decorates a test by providing a specific setUp() and tearDown().
+ */
+class CPPUNIT_API TestSetUp : public TestDecorator
+{
+public:
+  TestSetUp( Test *test );
+
+  void run( TestResult *result );
+
+protected:
+  virtual void setUp();
+  virtual void tearDown();
+
+private:
+  TestSetUp( const TestSetUp & );
+  void operator =( const TestSetUp & );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_EXTENSIONS_TESTSETUP_H
+
diff --git a/src/test/cppunit/extensions/TestSuiteBuilderContext.h b/src/test/cppunit/extensions/TestSuiteBuilderContext.h
new file mode 100644
index 0000000..99b74ea
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSuiteBuilderContext.h
@@ -0,0 +1,131 @@
+#ifndef CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+#define CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitMap.h>
+#include <string>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+
+CPPUNIT_NS_BEGIN
+
+class TestSuite;
+class TestFixture;
+class TestFixtureFactory;
+class TestNamer;
+
+/*! \brief Context used when creating test suite in HelperMacros.
+ *
+ * Base class for all context used when creating test suite. The
+ * actual context type during test suite creation is TestSuiteBuilderContext.
+ *
+ * \sa CPPUNIT_TEST_SUITE, CPPUNIT_TEST_SUITE_ADD_TEST,
+ *     CPPUNIT_TEST_SUITE_ADD_CUSTOM_TESTS.
+ */
+class CPPUNIT_API TestSuiteBuilderContextBase
+{
+public:
+  /*! \brief Constructs a new context.
+   *
+   * You should not use this. The context is created in
+   * CPPUNIT_TEST_SUITE().
+   */
+  TestSuiteBuilderContextBase( TestSuite &suite,
+                               const TestNamer &namer,
+                               TestFixtureFactory &factory );
+
+  virtual ~TestSuiteBuilderContextBase();
+
+  /*! \brief Adds a test to the fixture suite.
+   *
+   * \param test Test to add to the fixture suite. Must not be \c NULL.
+   */
+  void addTest( Test *test );
+
+  /*! \brief Returns the fixture name.
+   * \return Fixture name. It is the name used to name the fixture
+   *         suite.
+   */
+  std::string getFixtureName() const;
+
+  /*! \brief Returns the name of the test for the specified method.
+   *
+   * \param testMethodName Name of the method that implements a test.
+   * \return A string that is the concatenation of the test fixture name
+   *         (returned by getFixtureName()) and\a testMethodName,
+   *         separated using '::'. This provides a fairly unique name for a given
+   *         test.
+   */
+  std::string getTestNameFor( const std::string &testMethodName ) const;
+
+  /*! \brief Adds property pair.
+   * \param key   PropertyKey string to add.
+   * \param value PropertyValue string to add.
+   */
+  void addProperty( const std::string &key,
+                    const std::string &value );
+
+  /*! \brief Returns property value assigned to param key.
+   * \param key PropertyKey string.
+   */
+  const std::string getStringProperty( const std::string &key ) const;
+
+protected:
+  TestFixture *makeTestFixture() const;
+
+  // Notes: we use a vector here instead of a map to work-around the
+  // shared std::map in dll bug in VC6.
+  // See http://www.dinkumware.com/vc_fixes.html for detail.
+  typedef std::pair<std::string,std::string> Property;
+  typedef CppUnitVector<Property> Properties;
+
+  TestSuite &m_suite;
+  const TestNamer &m_namer;
+  TestFixtureFactory &m_factory;
+
+private:
+  Properties m_properties;
+};
+
+
+/*! \brief Type-sage context used when creating test suite in HelperMacros.
+ *
+ * \sa TestSuiteBuilderContextBase.
+ */
+template<class Fixture>
+class TestSuiteBuilderContext : public TestSuiteBuilderContextBase
+{
+public:
+  typedef Fixture FixtureType;
+
+  TestSuiteBuilderContext( TestSuiteBuilderContextBase &contextBase )
+      : TestSuiteBuilderContextBase( contextBase )
+  {
+  }
+
+  /*! \brief Returns a new TestFixture instance.
+   * \return A new fixture instance. The fixture instance is returned by
+   *         the TestFixtureFactory passed on construction. The actual type
+   *         is that of the fixture on which the static method suite()
+   *         was called.
+   */
+  FixtureType *makeFixture() const
+  {
+    return CPPUNIT_STATIC_CAST( FixtureType *,
+                                TestSuiteBuilderContextBase::makeTestFixture() );
+  }
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // CPPUNIT_HELPER_TESTSUITEBUILDERCONTEXT_H
+
diff --git a/src/test/cppunit/extensions/TestSuiteFactory.h b/src/test/cppunit/extensions/TestSuiteFactory.h
new file mode 100644
index 0000000..260b483
--- /dev/null
+++ b/src/test/cppunit/extensions/TestSuiteFactory.h
@@ -0,0 +1,27 @@
+#ifndef CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+#define CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
+
+#include <cppunit/extensions/TestFactory.h>
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+
+  /*! \brief TestFactory for TestFixture that implements a static suite() method.
+   * \see AutoRegisterSuite.
+   */
+  template<class TestCaseType>
+  class TestSuiteFactory : public TestFactory
+  {
+  public:
+    virtual Test *makeTest()
+    {
+      return TestCaseType::suite();
+    }
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_EXTENSIONS_TESTSUITEFACTORY_H
diff --git a/src/test/cppunit/extensions/TypeInfoHelper.h b/src/test/cppunit/extensions/TypeInfoHelper.h
new file mode 100644
index 0000000..c0ecdbc
--- /dev/null
+++ b/src/test/cppunit/extensions/TypeInfoHelper.h
@@ -0,0 +1,33 @@
+#ifndef CPPUNIT_TYPEINFOHELPER_H
+#define CPPUNIT_TYPEINFOHELPER_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_HAVE_RTTI
+
+#include <typeinfo>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+
+  /**! \brief Helper to use type_info.
+   */
+  class CPPUNIT_API TypeInfoHelper
+  {
+  public:
+    /*! \brief Get the class name of the specified type_info.
+     * \param info Info which the class name is extracted from.
+     * \return The string returned by type_info::name() without
+     *         the "class" prefix. If the name is not prefixed
+     *         by "class", it is returned as this.
+     */
+    static std::string getClassName( const std::type_info &info );
+  };
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_HAVE_RTTI
+
+#endif  // CPPUNIT_TYPEINFOHELPER_H
diff --git a/src/test/cppunit/plugin/DynamicLibraryManager.h b/src/test/cppunit/plugin/DynamicLibraryManager.h
new file mode 100644
index 0000000..42ee3be
--- /dev/null
+++ b/src/test/cppunit/plugin/DynamicLibraryManager.h
@@ -0,0 +1,121 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
+
+#include <cppunit/Portability.h>
+#include <string>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Manages dynamic libraries.
+ *
+ * The Dynamic Library Manager provides a platform independent way to work with
+ * dynamic library. It load a specific dynamic library, and can returns specific
+ * symbol exported by the dynamic library.
+ *
+ * If an error occurs, a DynamicLibraryManagerException is thrown.
+ *
+ * \internal Implementation of the OS independent methods is in
+ * DynamicLibraryManager.cpp.
+ *
+ * \internal Porting to a new platform:
+ * - Adds platform detection in config/SelectDllLoader.h. Should define a specific
+ *   macro for that platform of the form: CPPUNIT_HAVE_XYZ_DLL_LOADER, where
+ *   XYZ is the platform.
+ * - Makes a copy of UnixDynamicLibraryManager.cpp and named it after the platform.
+ * - Updated the 'guard' in your file (CPPUNIT_HAVE_XYZ_DLL_LOADER) so that it is
+ *   only processed if the matching platform has been detected.
+ * - Change the implementation of methods doLoadLibrary(), doReleaseLibrary(),
+ *   doFindSymbol() in your copy. Those methods usually maps directly to OS calls.
+ * - Adds the file to the project.
+ */
+class DynamicLibraryManager
+{
+public:
+  typedef void *Symbol;
+  typedef void *LibraryHandle;
+
+  /*! \brief Loads the specified library.
+   * \param libraryFileName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  DynamicLibraryManager( const std::string &libraryFileName );
+
+  /// Releases the loaded library..
+  ~DynamicLibraryManager();
+
+  /*! \brief Returns a pointer on the specified symbol exported by the library.
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. Should be casted to the actual type. Never \c NULL.
+   * \exception DynamicLibraryManagerException if the symbol is not found.
+   */
+  Symbol findSymbol( const std::string &symbol );
+
+private:
+  /*! Loads the specified library.
+   * \param libraryName Name of the library to load.
+   * \exception DynamicLibraryManagerException if a failure occurs while loading
+   *            the library (fail to found or load the library).
+   */
+  void loadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   *
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void releaseLibrary();
+
+  /*! Loads the specified library.
+   *
+   * May throw any exceptions (indicates failure).
+   * \param libraryName Name of the library to load.
+   * \return Handle of the loaded library. \c NULL indicates failure.
+   */
+  LibraryHandle doLoadLibrary( const std::string &libraryName );
+
+  /*! Releases the loaded library.
+   *
+   * The handle of the library to free is in \c m_libraryHandle. It is never
+   * \c NULL.
+   * \warning Must NOT throw any exceptions (called from destructor).
+   */
+  void doReleaseLibrary();
+
+  /*! Returns a pointer on the specified symbol exported by the library.
+   *
+   * May throw any exceptions (indicates failure).
+   * \param symbol Name of the symbol exported by the library.
+   * \return Pointer on the symbol. \c NULL indicates failure.
+   */
+  Symbol doFindSymbol( const std::string &symbol );
+
+  /*! Returns detailed information about doLoadLibrary() failure.
+   *
+   * Called just after a failed call to doLoadLibrary() to get extra
+   * error information.
+   *
+   * \return Detailed information about the failure of the call to
+   *         doLoadLibrary() that just failed.
+   */
+  std::string getLastErrorDetail() const;
+
+  /// Prevents the use of the copy constructor.
+  DynamicLibraryManager( const DynamicLibraryManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const DynamicLibraryManager &copy );
+
+private:
+  LibraryHandle m_libraryHandle;
+  std::string m_libraryName;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGER_H
diff --git a/src/test/cppunit/plugin/DynamicLibraryManagerException.h b/src/test/cppunit/plugin/DynamicLibraryManagerException.h
new file mode 100644
index 0000000..11ebbd9
--- /dev/null
+++ b/src/test/cppunit/plugin/DynamicLibraryManagerException.h
@@ -0,0 +1,53 @@
+#ifndef CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+#define CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+#include <stdexcept>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Exception thrown by DynamicLibraryManager when a failure occurs.
+ *
+ * Use getCause() to know what function caused the failure.
+ *
+ */
+class DynamicLibraryManagerException : public std::runtime_error
+{
+public:
+  enum Cause
+  {
+    /// Failed to load the dynamic library
+    loadingFailed =0,
+    /// Symbol not found in the dynamic library
+    symbolNotFound
+  };
+
+  /// Failed to load the dynamic library or Symbol not found in the dynamic library.
+  DynamicLibraryManagerException( const std::string &libraryName,
+                                  const std::string &errorDetail,
+                                  Cause cause );
+
+  ~DynamicLibraryManagerException() throw()
+  {
+  }
+
+  Cause getCause() const;
+
+  const char *what() const throw();
+
+private:
+  std::string m_message;
+  Cause m_cause;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif  // CPPUNIT_PLUGIN_DYNAMICLIBRARYMANAGEREXCEPTION_H
diff --git a/src/test/cppunit/plugin/Makefile.am b/src/test/cppunit/plugin/Makefile.am
new file mode 100644
index 0000000..5221a66
--- /dev/null
+++ b/src/test/cppunit/plugin/Makefile.am
@@ -0,0 +1,9 @@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
diff --git a/src/test/cppunit/plugin/Makefile.in b/src/test/cppunit/plugin/Makefile.in
new file mode 100644
index 0000000..c97e6e4
--- /dev/null
+++ b/src/test/cppunit/plugin/Makefile.in
@@ -0,0 +1,437 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/plugin
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/plugin
+libcppunitinclude_HEADERS = \
+	DynamicLibraryManager.h \
+	DynamicLibraryManagerException.h \
+	TestPlugIn.h \
+	TestPlugInDefaultImpl.h \
+	PlugInManager.h \
+	PlugInParameters.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/plugin/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/plugin/PlugInManager.h b/src/test/cppunit/plugin/PlugInManager.h
new file mode 100644
index 0000000..01aa505
--- /dev/null
+++ b/src/test/cppunit/plugin/PlugInManager.h
@@ -0,0 +1,113 @@
+#ifndef CPPUNIT_PLUGIN_PLUGINMANAGER_H
+#define CPPUNIT_PLUGIN_PLUGINMANAGER_H
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/plugin/PlugInParameters.h>
+struct CppUnitTestPlugIn;
+
+CPPUNIT_NS_BEGIN
+
+
+class DynamicLibraryManager;
+class TestResult;
+class XmlOutputter;
+
+
+/*! \brief Manges TestPlugIn.
+ */
+class CPPUNIT_API PlugInManager
+{
+public:
+  /*! Constructs a PlugInManager object.
+   */
+  PlugInManager();
+
+  /// Destructor.
+  virtual ~PlugInManager();
+
+  /*! \brief Loads the specified plug-in.
+   *
+   * After being loaded, the CppUnitTestPlugIn::initialize() is called.
+   *
+   * \param libraryFileName Name of the file that contains the TestPlugIn.
+   * \param parameters List of string passed to the plug-in.
+   * \return Pointer on the DynamicLibraryManager associated to the library.
+   *         Valid until the library is unloaded. Never \c NULL.
+   * \exception DynamicLibraryManagerException is thrown if an error occurs during loading.
+   */
+  void load( const std::string &libraryFileName,
+             const PlugInParameters &parameters = PlugInParameters() );
+
+  /*! \brief Unloads the specified plug-in.
+   * \param libraryFileName Name of the file that contains the TestPlugIn passed
+   *                        to a previous call to load().
+   */
+  void unload( const std::string &libraryFileName );
+
+  /*! \brief Gives a chance to each loaded plug-in to register TestListener.
+   *
+   * For each plug-in, call CppUnitTestPlugIn::addListener().
+   */
+  void addListener( TestResult *eventManager );
+
+  /*! \brief Gives a chance to each loaded plug-in to unregister TestListener.
+   * For each plug-in, call CppUnitTestPlugIn::removeListener().
+   */
+  void removeListener( TestResult *eventManager );
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   *
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  void removeXmlOutputterHooks();
+
+protected:
+  /*! \brief (INTERNAL) Information about a specific plug-in.
+   */
+  struct PlugInInfo
+  {
+    std::string m_fileName;
+    DynamicLibraryManager *m_manager;
+    CppUnitTestPlugIn *m_interface;
+  };
+
+  /*! Unloads the specified plug-in.
+   * \param plugIn Information about the plug-in.
+   */
+  void unload( PlugInInfo &plugIn );
+
+private:
+  /// Prevents the use of the copy constructor.
+  PlugInManager( const PlugInManager &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const PlugInManager &copy );
+
+private:
+  typedef CppUnitDeque<PlugInInfo> PlugIns;
+  PlugIns m_plugIns;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif  // CPPUNIT_PLUGIN_PLUGINMANAGER_H
diff --git a/src/test/cppunit/plugin/PlugInParameters.h b/src/test/cppunit/plugin/PlugInParameters.h
new file mode 100644
index 0000000..c67d0f1
--- /dev/null
+++ b/src/test/cppunit/plugin/PlugInParameters.h
@@ -0,0 +1,36 @@
+#ifndef CPPUNIT_PLUGIN_PARAMETERS
+#define CPPUNIT_PLUGIN_PARAMETERS
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+CPPUNIT_NS_BEGIN
+
+/*! \brief Test plug-ins parameters.
+ */
+class CPPUNIT_API PlugInParameters
+{
+public:
+  /// Constructs plug-in parameters from the specified command-line.
+  PlugInParameters( const std::string &commandLine = "" );
+
+  virtual ~PlugInParameters();
+
+  /// Returns the command line that was passed on construction.
+  std::string getCommandLine() const;
+
+private:
+  std::string m_commandLine;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_PARAMETERS
diff --git a/src/test/cppunit/plugin/TestPlugIn.h b/src/test/cppunit/plugin/TestPlugIn.h
new file mode 100644
index 0000000..76c0b77
--- /dev/null
+++ b/src/test/cppunit/plugin/TestPlugIn.h
@@ -0,0 +1,200 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGIN
+#define CPPUNIT_PLUGIN_TESTPLUGIN
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/PlugInParameters.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Test;
+class TestFactoryRegistry;
+class TestResult;
+class XmlOutputter;
+
+CPPUNIT_NS_END
+
+/*! \file
+ */
+
+
+/*! \brief Test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This class define the interface implemented by test plug-in. A pointer to that
+ * interface is returned by the function exported by the test plug-in.
+ *
+ * Plug-in are loaded/unloaded by PlugInManager. When a plug-in is loaded,
+ * initialize() is called. Before unloading the plug-in, the PlugInManager
+ * call uninitialize().
+ *
+ * addListener() and removeListener() are called respectively before and after
+ * the test run.
+ *
+ * addXmlOutputterHooks() and removeXmlOutputterHooks() are called respectively
+ * before and after writing the XML output using a XmlOutputter.
+ *
+ * \see CPPUNIT_PLUGIN_IMPLEMENT, CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL
+ * \see CppUnit::TestPlugInDefaultImpl, CppUnit::XmlOutputter.
+ */
+struct CppUnitTestPlugIn
+{
+  /*! \brief Called just after loading the dynamic library.
+   *
+   * Override this method to add additional suite to the registry, though this
+   * is preferably done using the macros (CPPUNIT_TEST_SUITE_REGISTRATION...).
+   * If you are creating a custom listener to extends the plug-in runner,
+   * you can use this to configure the listener using the \a parameters.
+   *
+   * You could also use the parameters to specify some global parameter, such
+   * as test datas location, database name...
+   *
+   * N.B.: Parameters interface is not define yet, and the plug-in runner does
+   * not yet support plug-in parameter.
+   */
+  virtual void initialize( CPPUNIT_NS::TestFactoryRegistry *registry,
+                           const CPPUNIT_NS::PlugInParameters &parameters ) =0;
+
+  /*! \brief Gives a chance to the plug-in to register TestListener.
+   *
+   * Override this method to add a TestListener for the test run. This is useful
+   * if you are writing a custom TestListener, but also if you need to
+   * setUp some global resource: listen to TestListener::startTestRun(),
+   * and TestListener::endTestRun().
+   */
+  virtual void addListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Gives a chance to the plug-in to remove its registered TestListener.
+   *
+   * Override this method to remove a TestListener that has been added.
+   */
+  virtual void removeListener( CPPUNIT_NS::TestResult *eventManager ) =0;
+
+  /*! \brief Provides a way for the plug-in to register some XmlOutputterHook.
+   */
+  virtual void addXmlOutputterHooks( CPPUNIT_NS::XmlOutputter *outputter ) =0;
+
+  /*! \brief Called when the XmlOutputter is destroyed.
+   *
+   * Can be used to free some resources allocated by addXmlOutputterHooks().
+   */
+  virtual void removeXmlOutputterHooks() = 0;
+
+  /*! \brief Called just before unloading the dynamic library.
+   *
+   * Override this method to unregister test factory added in initialize().
+   * This is necessary to keep the TestFactoryRegistry 'clean'. When
+   * the plug-in is unloaded from memory, the TestFactoryRegistry will hold
+   * reference on test that are no longer available if they are not
+   * unregistered.
+   */
+  virtual void uninitialize( CPPUNIT_NS::TestFactoryRegistry *registry ) =0;
+
+  virtual ~CppUnitTestPlugIn() {}
+};
+
+
+
+/*! \brief Name of the function exported by a test plug-in.
+ * \ingroup WritingTestPlugIn
+ *
+ * The signature of the exported function is:
+ * \code
+ * CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void);
+ * \endcode
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_NAME cppunitTestPlugIn
+
+/*! \brief Type of the function exported by a plug-in.
+ * \ingroup WritingTestPlugIn
+ */
+typedef CppUnitTestPlugIn *(*TestPlugInSignature)();
+
+
+/*! \brief Implements the function exported by the test plug-in
+ * \ingroup WritingTestPlugIn
+ */
+#define CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( TestPlugInInterfaceType )       \
+  CPPUNIT_PLUGIN_EXPORT CppUnitTestPlugIn *CPPUNIT_PLUGIN_EXPORTED_NAME(void)  \
+  {                                                                            \
+    static TestPlugInInterfaceType plugIn;                                     \
+    return &plugIn;                                                            \
+  }                                                                            \
+  typedef char __CppUnitPlugInExportFunctionDummyTypeDef  // dummy typedef so it can end with ';'
+
+
+// Note: This include should remain after definition of CppUnitTestPlugIn
+#include <cppunit/plugin/TestPlugInDefaultImpl.h>
+
+
+/*! \def CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+ * \brief Implements the 'main' function for the plug-in.
+ *
+ * This macros implements the main() function for dynamic library.
+ * For example, WIN32 requires a DllMain function, while some Unix
+ * requires a main() function. This macros takes care of the implementation.
+ */
+
+// Win32
+#if defined(CPPUNIT_HAVE_WIN32_DLL_LOADER)
+#if !defined(APIENTRY)
+#define WIN32_LEAN_AND_MEAN
+#define NOGDI
+#define NOUSER
+#define NOKERNEL
+#define NOSOUND
+#define NOMINMAX
+#define BLENDFUNCTION void    // for mingw & gcc
+#include <windows.h>
+#endif
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  BOOL APIENTRY DllMain( HANDLE hModule,              \
+                         DWORD  ul_reason_for_call,   \
+                         LPVOID lpReserved )          \
+  {                                                   \
+      return TRUE;                                    \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+// Unix
+#elif defined(CPPUNIT_HAVE_UNIX_DLL_LOADER) || defined(CPPUNIT_HAVE_UNIX_SHL_LOADER)
+#define CPPUNIT_PLUGIN_IMPLEMENT_MAIN()               \
+  int main( int argc, char *argv[] )                  \
+  {                                                   \
+    return 0;                                         \
+  }                                                   \
+  typedef char __CppUnitPlugInImplementMainDummyTypeDef
+
+
+// Other
+#else     // other platforms don't require anything specifics
+#endif
+
+
+
+/*! \brief Implements and exports the test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * This macro exports the test plug-in function using the subclass,
+ * and implements the 'main' function for the plug-in using
+ * CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ *
+ * When using this macro, CppUnit must be linked as a DLL (shared library).
+ * Otherwise, tests registered to the TestFactoryRegistry in the DLL will
+ * not be visible to the DllPlugInTester.
+ *
+ * \see CppUnitTestPlugIn
+ * \see CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL(), CPPUNIT_PLUGIN_IMPLEMENT_MAIN().
+ */
+#define CPPUNIT_PLUGIN_IMPLEMENT()                                          \
+  CPPUNIT_PLUGIN_EXPORTED_FUNCTION_IMPL( CPPUNIT_NS::TestPlugInDefaultImpl );  \
+  CPPUNIT_PLUGIN_IMPLEMENT_MAIN()
+
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGIN
diff --git a/src/test/cppunit/plugin/TestPlugInDefaultImpl.h b/src/test/cppunit/plugin/TestPlugInDefaultImpl.h
new file mode 100644
index 0000000..7c67804
--- /dev/null
+++ b/src/test/cppunit/plugin/TestPlugInDefaultImpl.h
@@ -0,0 +1,52 @@
+#ifndef CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+#define CPPUNIT_PLUGIN_TESTPLUGINADAPTER
+
+#include <cppunit/Portability.h>
+
+#if !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#include <cppunit/plugin/TestPlugIn.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class TestSuite;
+
+
+/*! \brief Default implementation of test plug-in interface.
+ * \ingroup WritingTestPlugIn
+ *
+ * Override getSuiteName() to specify the suite name. Default is "All Tests".
+ *
+ * CppUnitTestPlugIn::getTestSuite() returns a suite that contains
+ * all the test registered to the default test factory registry
+ * ( TestFactoryRegistry::getRegistry() ).
+ *
+ */
+class CPPUNIT_API TestPlugInDefaultImpl : public CppUnitTestPlugIn
+{
+public:
+  TestPlugInDefaultImpl();
+
+  virtual ~TestPlugInDefaultImpl();
+
+  void initialize( TestFactoryRegistry *registry,
+                   const PlugInParameters &parameters );
+
+  void addListener( TestResult *eventManager );
+
+  void removeListener( TestResult *eventManager );
+
+  void addXmlOutputterHooks( XmlOutputter *outputter );
+
+  void removeXmlOutputterHooks();
+
+  void uninitialize( TestFactoryRegistry *registry );
+};
+
+
+CPPUNIT_NS_END
+
+#endif // !defined(CPPUNIT_NO_TESTPLUGIN)
+
+#endif // CPPUNIT_PLUGIN_TESTPLUGINADAPTER
diff --git a/src/test/cppunit/portability/CppUnitDeque.h b/src/test/cppunit/portability/CppUnitDeque.h
new file mode 100644
index 0000000..62e1e35
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitDeque.h
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+#define CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+
+// The technic used is similar to the wrapper of STLPort.
+
+#include <cppunit/Portability.h>
+#include <deque>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitDeque : public std::deque<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitDeque std::deque
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITDEQUE_H
+
diff --git a/src/test/cppunit/portability/CppUnitMap.h b/src/test/cppunit/portability/CppUnitMap.h
new file mode 100644
index 0000000..526bc4c
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitMap.h
@@ -0,0 +1,29 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITMAP_H
+#define CPPUNIT_PORTABILITY_CPPUNITMAP_H
+
+// The technic used is similar to the wrapper of STLPort.
+
+#include <cppunit/Portability.h>
+#include <functional>
+#include <map>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class Key, class T>
+class CppUnitMap : public std::map<Key
+                                  ,T
+                                  ,std::less<Key>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitMap std::map
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITMAP_H
+
diff --git a/src/test/cppunit/portability/CppUnitSet.h b/src/test/cppunit/portability/CppUnitSet.h
new file mode 100644
index 0000000..73ed0b9
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitSet.h
@@ -0,0 +1,28 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSET_H
+#define CPPUNIT_PORTABILITY_CPPUNITSET_H
+
+// The technic used is similar to the wrapper of STLPort.
+
+#include <cppunit/Portability.h>
+#include <functional>
+#include <set>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitSet : public std::set<T
+                                  ,std::less<T>
+                                  ,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitSet std::set
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSET_H
+
diff --git a/src/test/cppunit/portability/CppUnitStack.h b/src/test/cppunit/portability/CppUnitStack.h
new file mode 100644
index 0000000..1f6e507
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitStack.h
@@ -0,0 +1,26 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+#define CPPUNIT_PORTABILITY_CPPUNITSTACK_H
+
+// The technic used is similar to the wrapper of STLPort.
+
+#include <cppunit/Portability.h>
+#include <deque>
+#include <stack>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitStack : public std::stack<T
+                                      ,std::deque<T,CPPUNIT_STD_ALLOCATOR> >
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitStack std::stack
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITSTACK_H
\ No newline at end of file
diff --git a/src/test/cppunit/portability/CppUnitVector.h b/src/test/cppunit/portability/CppUnitVector.h
new file mode 100644
index 0000000..b5bcde8
--- /dev/null
+++ b/src/test/cppunit/portability/CppUnitVector.h
@@ -0,0 +1,25 @@
+#ifndef CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+#define CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+
+// The technic used is similar to the wrapper of STLPort.
+
+#include <cppunit/Portability.h>
+#include <vector>
+
+
+#if CPPUNIT_STD_NEED_ALLOCATOR
+
+template<class T>
+class CppUnitVector : public std::vector<T,CPPUNIT_STD_ALLOCATOR>
+{
+public:
+};
+
+#else // CPPUNIT_STD_NEED_ALLOCATOR
+
+#define CppUnitVector std::vector
+
+#endif
+
+#endif // CPPUNIT_PORTABILITY_CPPUNITVECTOR_H
+
diff --git a/src/test/cppunit/portability/FloatingPoint.h b/src/test/cppunit/portability/FloatingPoint.h
new file mode 100644
index 0000000..791aad5
--- /dev/null
+++ b/src/test/cppunit/portability/FloatingPoint.h
@@ -0,0 +1,54 @@
+#ifndef CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
+#define CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
+
+#include <cppunit/Portability.h>
+#include <math.h>
+
+CPPUNIT_NS_BEGIN
+
+/// \brief Tests if a floating-point is a NaN.
+// According to IEEE-754 floating point standard,
+// (see e.g. page 8 of
+// http://www.cs.berkeley.edu/~wkahan/ieee754status/ieee754.ps)
+// all comparisons with NaN are false except "x != x", which is true.
+//
+// At least Microsoft Visual Studio 6 is known not to implement this test correctly.
+// It emits the following code to test equality:
+//  fcomp       qword ptr [nan]
+//  fnstsw      ax                        // copie fp (floating-point) status register to ax
+//  test        ah,40h                    // test bit 14 of ax (0x4000) => C3 of fp status register
+// According to the following documentation on the x86 floating point status register,
+// the C2 bit should be tested to test for NaN value.
+// http://webster.cs.ucr.edu/AoA/Windows/HTML/RealArithmetic.html#1000117
+// In Microsoft Visual Studio 2003 & 2005, the test is implemented with:
+//  test        ah,44h         // Visual Studio 2005 test both C2 & C3...
+//
+// To work around this, a NaN is assumed to be detected if no strict ordering is found.
+inline bool floatingPointIsUnordered( double x )
+{
+   // x != x will detect a NaN on conformant platform
+   // (2.0 < x  &&  x < 1.0) will detect a NaN on non conformant platform:
+   // => no ordering can be found for x.
+   return  (x != x) ||  (2.0 < x  &&  x < 1.0);
+}
+
+
+/// \brief Tests if a floating-point is finite.
+/// @return \c true if x is neither a NaN, nor +inf, nor -inf, \c false otherwise.
+inline int floatingPointIsFinite( double x )
+{
+#if defined(CPPUNIT_HAVE_ISFINITE)
+   return isfinite( x );
+#elif defined(CPPUNIT_HAVE_FINITE)
+   return finite( x );
+#elif defined(CPPUNIT_HAVE__FINITE)
+   return _finite(x);
+#else
+   double testInf = x * 0.0;  // Produce 0.0 if x is finite, a NaN otherwise.
+   return testInf == 0.0  &&  !floatingPointIsUnordered(testInf);
+#endif
+}
+
+CPPUNIT_NS_END
+
+#endif // CPPUNIT_PORTABILITY_FLOATINGPOINT_H_INCLUDED
diff --git a/src/test/cppunit/portability/Makefile.am b/src/test/cppunit/portability/Makefile.am
new file mode 100644
index 0000000..2caeb32
--- /dev/null
+++ b/src/test/cppunit/portability/Makefile.am
@@ -0,0 +1,10 @@
+libcppunitincludedir = $(includedir)/cppunit/portability
+
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h  \
+	CppUnitMap.h    \
+	CppUnitSet.h    \
+	CppUnitStack.h  \
+	CppUnitVector.h \
+   FloatingPoint.h \
+   Stream.h
diff --git a/src/test/cppunit/portability/Makefile.in b/src/test/cppunit/portability/Makefile.in
new file mode 100644
index 0000000..80278e9
--- /dev/null
+++ b/src/test/cppunit/portability/Makefile.in
@@ -0,0 +1,438 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/portability
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/portability
+libcppunitinclude_HEADERS = \
+	CppUnitDeque.h  \
+	CppUnitMap.h    \
+	CppUnitSet.h    \
+	CppUnitStack.h  \
+	CppUnitVector.h \
+   FloatingPoint.h \
+   Stream.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/portability/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/portability/Stream.h b/src/test/cppunit/portability/Stream.h
new file mode 100644
index 0000000..866483c
--- /dev/null
+++ b/src/test/cppunit/portability/Stream.h
@@ -0,0 +1,347 @@
+#ifndef CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+#define CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+
+// This module define:
+// Type CppUT::Stream (either std::stream or a custom type)
+// Type CppUT::OStringStream (eitjer std::ostringstream, older alternate or a custom type)
+// Functions stdCOut() & stdCErr() which returns a reference on cout & cerr stream (or our
+// custom stream).
+
+#include <cppunit/Portability.h>
+
+
+#if defined( CPPUNIT_NO_STREAM )
+
+#include <string>
+#include <stdio.h>
+#include <string.h>
+
+CPPUNIT_NS_BEGIN
+
+class StreamBuffer
+{
+public:
+   virtual ~StreamBuffer() {}
+
+   virtual void write( const char *text, unsigned int length ) = 0;
+
+   virtual void flush() {}
+};
+
+
+class StringStreamBuffer : public StreamBuffer
+{
+public:
+   std::string str() const
+   {
+      return str_;
+   }
+
+public: // overridden from StreamBuffer
+   void write( const char *text, unsigned int length )
+   {
+      str_.append( text, length );
+   }
+
+private:
+   std::string str_;
+};
+
+
+class FileStreamBuffer : public StreamBuffer
+{
+public:
+   FileStreamBuffer( FILE *file )
+      : file_( file )
+   {
+   }
+
+   FILE *file() const
+   {
+      return file_;
+   }
+
+public: // overridden from StreamBuffer
+   void write( const char *text, unsigned int length )
+   {
+      if ( file_ )
+         fwrite( text, sizeof(char), length, file_ );
+   }
+
+   void flush()
+   {
+      if ( file_ )
+         fflush( file_ );
+   }
+
+private:
+   FILE *file_;
+};
+
+
+class OStream
+{
+public:
+   OStream()
+      : buffer_( 0 )
+   {
+   }
+
+   OStream( StreamBuffer *buffer )
+      : buffer_( buffer )
+   {
+   }
+
+   virtual ~OStream()
+   {
+     flush();
+   }
+
+   OStream &flush()
+   {
+	   if ( buffer_ )
+		    buffer_->flush();
+	   return *this;
+   }
+
+   void setBuffer( StreamBuffer *buffer )
+   {
+      buffer_ = buffer;
+   }
+
+   OStream &write( const char *text, unsigned int length )
+   {
+      if ( buffer_ )
+         buffer_->write( text, length );
+      return *this;
+   }
+
+   OStream &write( const char *text )
+   {
+      return write( text, strlen(text) );
+   }
+
+   OStream &operator <<( bool v )
+   {
+      const char *out = v ? "true" : "false";
+      return write( out );
+   }
+
+   OStream &operator <<( short v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%hd", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned short v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%hu", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( int v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%d", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned int v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%u", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( long v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%ld", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( unsigned long v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%lu", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( float v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", double(v) );
+      return write( buffer );
+   }
+
+   OStream &operator <<( double v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( long double v )
+   {
+      char buffer[128];
+      sprintf( buffer, "%.16g", double(v) );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const void *v )
+   {
+      char buffer[64];
+      sprintf( buffer, "%p", v );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const char *v )
+   {
+      return write( v ? v : "NULL" );
+   }
+
+   OStream &operator <<( char c )
+   {
+      char buffer[16];
+      sprintf( buffer, "%c", c );
+      return write( buffer );
+   }
+
+   OStream &operator <<( const std::string &s )
+   {
+      return write( s.c_str(), s.length() );
+   }
+
+private:
+   StreamBuffer *buffer_;
+};
+
+
+class OStringStream : public OStream
+{
+public:
+	OStringStream()
+		: OStream( &buffer_ )
+	{
+	}
+
+	std::string str() const
+	{
+		return buffer_.str();
+	}
+
+private:
+	StringStreamBuffer buffer_;
+};
+
+
+class OFileStream : public OStream
+{
+public:
+   OFileStream( FILE *file )
+      : OStream( &buffer_ )
+      , buffer_( file )
+      , ownFile_( false )
+   {
+   }
+
+   OFileStream( const char *path )
+      : OStream( &buffer_ )
+      , buffer_( fopen( path, "wt" ) )
+      , ownFile_( true )
+   {
+   }
+
+   virtual ~OFileStream()
+   {
+      if ( ownFile_  &&  buffer_.file() )
+         fclose( buffer_.file() );
+   }
+
+private:
+   FileStreamBuffer buffer_;
+   bool ownFile_;
+};
+
+inline OStream &stdCOut()
+{
+   static OFileStream stream( stdout );
+   return stream;
+}
+
+inline OStream &stdCErr()
+{
+   static OFileStream stream( stderr );
+   return stream;
+}
+
+CPPUNIT_NS_END
+
+#elif CPPUNIT_HAVE_SSTREAM // #if defined( CPPUNIT_NO_STREAM )
+# include <sstream>
+# include <fstream>
+
+    CPPUNIT_NS_BEGIN
+    typedef std::ostringstream OStringStream;      // The standard C++ way
+    typedef std::ofstream OFileStream;
+    CPPUNIT_NS_END
+
+
+#elif CPPUNIT_HAVE_CLASS_STRSTREAM
+# include <string>
+# if CPPUNIT_HAVE_STRSTREAM
+#   include <strstream>
+# else // CPPUNIT_HAVE_STRSTREAM
+#  include <strstream.h>
+# endif // CPPUNIT_HAVE_CLASS_STRSTREAM
+
+    CPPUNIT_NS_BEGIN
+
+    class OStringStream : public std::ostrstream
+    {
+    public:
+        std::string str()
+        {
+//            (*this) << '\0';
+//            std::string msg(std::ostrstream::str());
+//            std::ostrstream::freeze(false);
+//            return msg;
+// Alternative implementation that don't rely on freeze which is not
+// available on some platforms:
+            return std::string( std::ostrstream::str(), pcount() );
+        }
+    };
+
+    CPPUNIT_NS_END
+#else // CPPUNIT_HAVE_CLASS_STRSTREAM
+#   error Cannot define CppUnit::OStringStream.
+#endif // #if defined( CPPUNIT_NO_STREAM )
+
+
+
+#if !defined( CPPUNIT_NO_STREAM )
+
+#include <iostream>
+
+    CPPUNIT_NS_BEGIN
+
+    typedef std::ostream OStream;
+
+    inline OStream &stdCOut()
+    {
+        return std::cout;
+    }
+
+    inline OStream &stdCErr()
+    {
+       return std::cerr;
+    }
+
+    CPPUNIT_NS_END
+
+#endif // #if !defined( CPPUNIT_NO_STREAM )
+
+#endif // CPPUNIT_PORTABILITY_STREAM_H_INCLUDED
+
diff --git a/src/test/cppunit/tools/Algorithm.h b/src/test/cppunit/tools/Algorithm.h
new file mode 100644
index 0000000..1342b6a
--- /dev/null
+++ b/src/test/cppunit/tools/Algorithm.h
@@ -0,0 +1,23 @@
+#ifndef CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+#define CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
+
+#include <cppunit/Portability.h>
+
+CPPUNIT_NS_BEGIN
+
+template<class SequenceType, class ValueType>
+void
+removeFromSequence( SequenceType &sequence,
+                    const ValueType &valueToRemove )
+{
+   for ( unsigned int index =0; index < sequence.size(); ++index )
+   {
+      if ( sequence[ index ] == valueToRemove )
+         sequence.erase( sequence.begin() + index );
+   }
+}
+
+CPPUNIT_NS_END
+
+
+#endif // CPPUNIT_TOOLS_ALGORITHM_H_INCLUDED
diff --git a/src/test/cppunit/tools/Makefile.am b/src/test/cppunit/tools/Makefile.am
new file mode 100644
index 0000000..8ce08086
--- /dev/null
+++ b/src/test/cppunit/tools/Makefile.am
@@ -0,0 +1,7 @@
+libcppunitincludedir = $(includedir)/cppunit/tools
+
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
\ No newline at end of file
diff --git a/src/test/cppunit/tools/Makefile.in b/src/test/cppunit/tools/Makefile.in
new file mode 100644
index 0000000..5b7d3e6
--- /dev/null
+++ b/src/test/cppunit/tools/Makefile.in
@@ -0,0 +1,435 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/tools
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/tools
+libcppunitinclude_HEADERS = \
+	Algorithm.h		\
+	StringTools.h \
+	XmlElement.h \
+	XmlDocument.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/tools/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/tools/StringTools.h b/src/test/cppunit/tools/StringTools.h
new file mode 100644
index 0000000..d5b93a6
--- /dev/null
+++ b/src/test/cppunit/tools/StringTools.h
@@ -0,0 +1,34 @@
+#ifndef CPPUNIT_TOOLS_STRINGTOOLS_H
+#define CPPUNIT_TOOLS_STRINGTOOLS_H
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/portability/CppUnitVector.h>
+
+
+CPPUNIT_NS_BEGIN
+
+
+/*! \brief Tool functions to manipulate string.
+ */
+struct StringTools
+{
+
+  typedef CppUnitVector<std::string> Strings;
+
+  static std::string CPPUNIT_API toString( int value );
+
+  static std::string CPPUNIT_API toString( double value );
+
+  static Strings CPPUNIT_API split( const std::string &text,
+                                    char separator );
+
+  static std::string CPPUNIT_API wrap( const std::string &text,
+                                       int wrapColumn = CPPUNIT_WRAP_COLUMN );
+
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_STRINGTOOLS_H
diff --git a/src/test/cppunit/tools/XmlDocument.h b/src/test/cppunit/tools/XmlDocument.h
new file mode 100644
index 0000000..bc02f60
--- /dev/null
+++ b/src/test/cppunit/tools/XmlDocument.h
@@ -0,0 +1,86 @@
+#ifndef CPPUNIT_TOOLS_XMLDOCUMENT_H
+#define CPPUNIT_TOOLS_XMLDOCUMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+
+/*! \brief A XML Document.
+ *
+ * A XmlDocument represents a XML file. It holds a pointer on the root XmlElement
+ * of the document. It also holds the encoding and style sheet used.
+ *
+ * By default, the XML document is stand-alone and tagged with enconding "ISO-8859-1".
+ */
+class CPPUNIT_API XmlDocument
+{
+public:
+  /*! \brief Constructs a XmlDocument object.
+   * \param encoding Encoding used in the XML file (default is Latin-1, ISO-8859-1 ).
+   * \param styleSheet Name of the XSL style sheet file used. If empty then no
+   *                   style sheet will be specified in the output.
+   */
+  XmlDocument( const std::string &encoding = "",
+               const std::string &styleSheet = "" );
+
+  /// Destructor.
+  virtual ~XmlDocument();
+
+  std::string encoding() const;
+  void setEncoding( const std::string &encoding = "" );
+
+  std::string styleSheet() const;
+  void setStyleSheet( const std::string &styleSheet = "" );
+
+  bool standalone() const;
+
+  /*! \brief set the output document as standalone or not.
+   *
+   *  For the output document, specify wether it's a standalone XML
+   *  document, or not.
+   *
+   *  \param standalone if true, the output will be specified as standalone.
+   *         if false, it will be not.
+   */
+  void setStandalone( bool standalone );
+
+  void setRootElement( XmlElement *rootElement );
+  XmlElement &rootElement() const;
+
+  std::string toString() const;
+
+private:
+  /// Prevents the use of the copy constructor.
+  XmlDocument( const XmlDocument &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const XmlDocument &copy );
+
+protected:
+  std::string m_encoding;
+  std::string m_styleSheet;
+  XmlElement *m_rootElement;
+  bool m_standalone;
+};
+
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_TOOLS_XMLDOCUMENT_H
diff --git a/src/test/cppunit/tools/XmlElement.h b/src/test/cppunit/tools/XmlElement.h
new file mode 100644
index 0000000..e6f03dd
--- /dev/null
+++ b/src/test/cppunit/tools/XmlElement.h
@@ -0,0 +1,149 @@
+#ifndef CPPUNIT_TOOLS_XMLELEMENT_H
+#define CPPUNIT_TOOLS_XMLELEMENT_H
+
+#include <cppunit/Portability.h>
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( push )
+#pragma warning( disable: 4251 )  // X needs to have dll-interface to be used by clients of class Z
+#endif
+
+#include <cppunit/portability/CppUnitDeque.h>
+#include <string>
+
+
+CPPUNIT_NS_BEGIN
+
+
+class XmlElement;
+
+#if CPPUNIT_NEED_DLL_DECL
+//  template class CPPUNIT_API std::deque<XmlElement *>;
+#endif
+
+
+/*! \brief A XML Element.
+ *
+ * A XML element has:
+ * - a name, specified on construction,
+ * - a content, specified on construction (may be empty),
+ * - zero or more attributes, added with addAttribute(),
+ * - zero or more child elements, added with addElement().
+ */
+class CPPUNIT_API XmlElement
+{
+public:
+  /*! \brief Constructs an element with the specified name and string content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param content Content of the element.
+   */
+  XmlElement( std::string elementName,
+              std::string content ="" );
+
+  /*! \brief Constructs an element with the specified name and numeric content.
+   * \param elementName Name of the element. Must not be empty.
+   * \param numericContent Content of the element.
+   */
+  XmlElement( std::string elementName,
+              int numericContent );
+
+  /*! \brief Destructs the element and its child elements.
+   */
+  virtual ~XmlElement();
+
+  /*! \brief Returns the name of the element.
+   * \return Name of the element.
+   */
+  std::string name() const;
+
+  /*! \brief Returns the content of the element.
+   * \return Content of the element.
+   */
+  std::string content() const;
+
+  /*! \brief Sets the name of the element.
+   * \param name New name for the element.
+   */
+  void setName( const std::string &name );
+
+  /*! \brief Sets the content of the element.
+   * \param content New content for the element.
+   */
+  void setContent( const std::string &content );
+
+  /*! \overload void setContent( const std::string &content )
+   */
+  void setContent( int numericContent );
+
+  /*! \brief Adds an attribute with the specified string value.
+   * \param attributeName Name of the attribute. Must not be an empty.
+   * \param value Value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     std::string value );
+
+  /*! \brief Adds an attribute with the specified numeric value.
+   * \param attributeName Name of the attribute. Must not be empty.
+   * \param numericValue Numeric value of the attribute.
+   */
+  void addAttribute( std::string attributeName,
+                     int numericValue );
+
+  /*! \brief Adds a child element to the element.
+   * \param element Child element to add. Must not be \c NULL.
+   */
+  void addElement( XmlElement *element );
+
+  /*! \brief Returns the number of child elements.
+   * \return Number of child elements (element added with addElement()).
+   */
+  int elementCount() const;
+
+  /*! \brief Returns the child element at the specified index.
+   * \param index Zero based index of the element to return.
+   * \returns Element at the specified index. Never \c NULL.
+   * \exception std::invalid_argument if \a index < 0 or index >= elementCount().
+   */
+  XmlElement *elementAt( int index ) const;
+
+  /*! \brief Returns the first child element with the specified name.
+   * \param name Name of the child element to return.
+   * \return First child element found which is named \a name.
+   * \exception std::invalid_argument if there is no child element with the specified
+   *            name.
+   */
+  XmlElement *elementFor( const std::string &name ) const;
+
+  /*! \brief Returns a XML string that represents the element.
+   * \param indent String of spaces representing the amount of 'indent'.
+   * \return XML string that represents the element, its attributes and its
+   *         child elements.
+   */
+  std::string toString( const std::string &indent = "" ) const;
+
+private:
+  typedef std::pair<std::string,std::string> Attribute;
+
+  std::string attributesAsString() const;
+  std::string escape( std::string value ) const;
+
+private:
+  std::string m_name;
+  std::string m_content;
+
+  typedef CppUnitDeque<Attribute> Attributes;
+  Attributes m_attributes;
+
+  typedef CppUnitDeque<XmlElement *> Elements;
+  Elements m_elements;
+};
+
+
+CPPUNIT_NS_END
+
+#if CPPUNIT_NEED_DLL_DECL
+#pragma warning( pop )
+#endif
+
+
+#endif  // CPPUNIT_TOOLS_XMLELEMENT_H
diff --git a/src/test/cppunit/ui/Makefile.am b/src/test/cppunit/ui/Makefile.am
new file mode 100644
index 0000000..1b9f08e
--- /dev/null
+++ b/src/test/cppunit/ui/Makefile.am
@@ -0,0 +1 @@
+SUBDIRS = text mfc qt
diff --git a/src/test/cppunit/ui/Makefile.in b/src/test/cppunit/ui/Makefile.in
new file mode 100644
index 0000000..e8a9d59
--- /dev/null
+++ b/src/test/cppunit/ui/Makefile.in
@@ -0,0 +1,511 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
+	html-recursive info-recursive install-data-recursive \
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+ETAGS = etags
+CTAGS = ctags
+DIST_SUBDIRS = $(SUBDIRS)
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+SUBDIRS = text mfc qt
+all: all-recursive
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run `make' without going through this Makefile.
+# To change the values of `make' variables: instead of editing Makefiles,
+# (1) if the variable is set in `config.status', edit `config.status'
+#     (which will cause the Makefiles to be regenerated when you run `make');
+# (2) otherwise, pass the desired values on the `make' command line.
+$(RECURSIVE_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+$(RECURSIVE_CLEAN_TARGETS):
+	@failcom='exit 1'; \
+	for f in x $$MAKEFLAGS; do \
+	  case $$f in \
+	    *=* | --[!k]*);; \
+	    *k*) failcom='fail=yes';; \
+	  esac; \
+	done; \
+	dot_seen=no; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	rev=''; for subdir in $$list; do \
+	  if test "$$subdir" = "."; then :; else \
+	    rev="$$subdir $$rev"; \
+	  fi; \
+	done; \
+	rev="$$rev ."; \
+	target=`echo $@ | sed s/-recursive//`; \
+	for subdir in $$rev; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done && test -z "$$fail"
+tags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) tags); \
+	done
+ctags-recursive:
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  test "$$subdir" = . || (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) ctags); \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS: tags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      tags="$$tags $$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS: ctags-recursive $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+	list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test -d "$(distdir)/$$subdir" \
+	    || $(MKDIR_P) "$(distdir)/$$subdir" \
+	    || exit 1; \
+	    distdir=`$(am__cd) $(distdir) && pwd`; \
+	    top_distdir=`$(am__cd) $(top_distdir) && pwd`; \
+	    (cd $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$top_distdir" \
+	        distdir="$$distdir/$$subdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-recursive
+all-am: Makefile
+installdirs: installdirs-recursive
+installdirs-am:
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+info: info-recursive
+
+info-am:
+
+install-data-am:
+
+install-dvi: install-dvi-recursive
+
+install-exec-am:
+
+install-html: install-html-recursive
+
+install-info: install-info-recursive
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am:
+
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
+
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am check check-am clean clean-generic clean-libtool \
+	ctags ctags-recursive distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-ps install-ps-am install-strip installcheck \
+	installcheck-am installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-generic \
+	mostlyclean-libtool pdf pdf-am ps ps-am tags tags-recursive \
+	uninstall uninstall-am
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/mfc/Makefile.am b/src/test/cppunit/ui/mfc/Makefile.am
new file mode 100644
index 0000000..1ea8b5e
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/Makefile.am
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
diff --git a/src/test/cppunit/ui/mfc/Makefile.in b/src/test/cppunit/ui/mfc/Makefile.in
new file mode 100644
index 0000000..abe488a
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/Makefile.in
@@ -0,0 +1,433 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/mfc
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/mfc
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  MfcTestRunner.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/mfc/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/mfc/MfcTestRunner.h b/src/test/cppunit/ui/mfc/MfcTestRunner.h
new file mode 100644
index 0000000..d41bebd
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/MfcTestRunner.h
@@ -0,0 +1,76 @@
+#ifndef CPPUNITUI_MFC_MFCTESTRUNNER_H
+#define CPPUNITUI_MFC_MFCTESTRUNNER_H
+
+#if _MSC_VER >= 1000
+#pragma once
+#endif // _MSC_VER >= 1000
+
+#include <cppunit/Portability.h>
+#include <cppunit/portability/CppUnitVector.h>
+
+/* Refer to MSDN documentation to know how to write and use MFC extension DLL:
+   mk:@MSITStore:h:\DevStudio\MSDN\98VSa\1036\vcmfc.chm::/html/_mfcnotes_tn033.htm#_mfcnotes_how_to_write_an_mfc_extension_dll
+
+   This can be found in the index with "mfc extension"
+   The basic:
+   Using:
+   - your application must use MFC DLL
+   - memory allocation is done using the same heap
+   - you must define the symbol _AFX_DLL
+
+   Building:
+   - you must define the symbol _AFX_DLL and _AFX_EXT
+   - export class using AFX_EXT_CLASS
+ */
+
+CPPUNIT_NS_BEGIN
+
+  class Test;
+  class TestSuite;
+
+
+/*! \brief MFC test runner.
+ * \ingroup ExecutingTest
+ *
+ * Use this to launch the MFC TestRunner. Usually called from you CWinApp subclass:
+ *
+ * \code
+ * #include <cppunit/ui/mfc/MfcTestRunner.h>
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ *
+ * void
+ * CHostAppApp::RunUnitTests()
+ * {
+ *   CppUnit::MfcTestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *
+ *   runner.run();
+ * }
+ * \endcode
+ * \see CppUnit::TextTestRunner, CppUnit::TestFactoryRegistry.
+ */
+class AFX_EXT_CLASS MfcTestRunner
+{
+public:
+  MfcTestRunner();
+  virtual ~MfcTestRunner();
+
+  void run();
+
+  void addTest( Test *test );
+
+  void addTests( const CppUnitVector<Test *> &tests );
+
+protected:
+  Test *getRootTest();
+
+  TestSuite *m_suite;
+
+  typedef CppUnitVector<Test *> Tests;
+  Tests m_tests;
+};
+
+
+CPPUNIT_NS_END
+
+#endif // CPPUNITUI_MFC_MFCTESTRUNNER_H
\ No newline at end of file
diff --git a/src/test/cppunit/ui/mfc/TestRunner.h b/src/test/cppunit/ui/mfc/TestRunner.h
new file mode 100644
index 0000000..c4d6aff
--- /dev/null
+++ b/src/test/cppunit/ui/mfc/TestRunner.h
@@ -0,0 +1,21 @@
+#ifndef CPPUNITUI_MFC_TESTRUNNER_H
+#define CPPUNITUI_MFC_TESTRUNNER_H
+
+#include <cppunit/ui/mfc/MfcTestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+namespace MfcUi
+{
+  /*! Mfc TestRunner (DEPRECATED).
+   * \deprecated Use CppUnit::MfcTestRunner instead.
+   */
+  typedef CPPUNIT_NS::MfcTestRunner TestRunner;
+}
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_END
+
+
+#endif  // CPPUNITUI_MFC_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/qt/Config.h b/src/test/cppunit/ui/qt/Config.h
new file mode 100644
index 0000000..beaf9ad
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Config.h
@@ -0,0 +1,21 @@
+#ifndef CPPUNIT_QTUI_CONFIG_H
+#define CPPUNIT_QTUI_CONFIG_H
+
+/*! Macro to export symbol to DLL with VC++.
+ *
+ * - QTTESTRUNNER_DLL_BUILD must be defined when building the DLL.
+ * - QTTESTRUNNER_DLL must be defined if linking against the DLL.
+ * - If none of the above are defined then you are building or linking against
+ *   the static library.
+ */
+
+#if defined( QTTESTRUNNER_DLL_BUILD )
+#  define QTTESTRUNNER_API __declspec(dllexport)
+#elif defined ( QTTESTRUNNER_DLL )
+#  define QTTESTRUNNER_API __declspec(dllimport)
+#else
+#  define QTTESTRUNNER_API
+#endif
+
+
+#endif // CPPUNIT_QTUI_CONFIG_H
diff --git a/src/test/cppunit/ui/qt/Makefile.am b/src/test/cppunit/ui/qt/Makefile.am
new file mode 100644
index 0000000..7d4fb46
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Makefile.am
@@ -0,0 +1,6 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
diff --git a/src/test/cppunit/ui/qt/Makefile.in b/src/test/cppunit/ui/qt/Makefile.in
new file mode 100644
index 0000000..1154d40
--- /dev/null
+++ b/src/test/cppunit/ui/qt/Makefile.in
@@ -0,0 +1,434 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/qt
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/qt
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+	QtTestRunner.h \
+	Config.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/qt/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/qt/QtTestRunner.h b/src/test/cppunit/ui/qt/QtTestRunner.h
new file mode 100644
index 0000000..c3bbae3
--- /dev/null
+++ b/src/test/cppunit/ui/qt/QtTestRunner.h
@@ -0,0 +1,85 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_QTTESTRUNNER_H
+#define CPPUNIT_QTUI_QTTESTRUNNER_H
+
+#include <cppunit/portability/CppUnitVector.h>
+#include "Config.h"
+
+CPPUNIT_NS_BEGIN
+
+
+  class Test;
+  class TestSuite;
+
+
+/*!
+ * \brief QT test runner.
+ * \ingroup ExecutingTest
+ *
+ * Here is an example of usage:
+ * \code
+ * #include <cppunit/extensions/TestFactoryRegistry.h>
+ * #include <cppunit/ui/qt/TestRunner.h>
+ *
+ * [...]
+ *
+ * void
+ * QDepWindow::runTests()
+ * {
+ *   CppUnit::QtUi::TestRunner runner;
+ *   runner.addTest( CppUnit::TestFactoryRegistry::getRegistry().makeTest() );
+ *   runner.run( true );
+ * }
+ * \endcode
+ *
+ */
+class QTTESTRUNNER_API QtTestRunner
+{
+public:
+  /*! Constructs a TestRunner object.
+   */
+  QtTestRunner();
+
+  /*! Destructor.
+   */
+  virtual ~QtTestRunner();
+
+  void run( bool autoRun =false );
+
+  void addTest( Test *test );
+
+private:
+  /// Prevents the use of the copy constructor.
+  QtTestRunner( const QtTestRunner &copy );
+
+  /// Prevents the use of the copy operator.
+  void operator =( const QtTestRunner &copy );
+
+  Test *getRootTest();
+
+private:
+  typedef CppUnitVector<Test *> Tests;
+  Tests *_tests;
+
+  TestSuite *_suite;
+};
+
+
+#if CPPUNIT_HAVE_NAMESPACES
+  namespace QtUi
+  {
+    /*! Qt TestRunner (DEPRECATED).
+     * \deprecated Use CppUnit::QtTestRunner instead.
+     */
+    typedef CPPUNIT_NS::QtTestRunner TestRunner;
+  }
+#endif
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_QTUI_QTTESTRUNNER_H
diff --git a/src/test/cppunit/ui/qt/TestRunner.h b/src/test/cppunit/ui/qt/TestRunner.h
new file mode 100644
index 0000000..9c53e4b
--- /dev/null
+++ b/src/test/cppunit/ui/qt/TestRunner.h
@@ -0,0 +1,11 @@
+// //////////////////////////////////////////////////////////////////////////
+// Header file TestRunner.h for class TestRunner
+// (c)Copyright 2000, Baptiste Lepilleur.
+// Created: 2001/09/19
+// //////////////////////////////////////////////////////////////////////////
+#ifndef CPPUNIT_QTUI_TESTRUNNER_H
+#define CPPUNIT_QTUI_TESTRUNNER_H
+
+#include <cppunit/ui/qt/QtTestRunner.h>
+
+#endif  // CPPUNIT_QTUI_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/text/Makefile.am b/src/test/cppunit/ui/text/Makefile.am
new file mode 100644
index 0000000..5f01d81
--- /dev/null
+++ b/src/test/cppunit/ui/text/Makefile.am
@@ -0,0 +1,5 @@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
diff --git a/src/test/cppunit/ui/text/Makefile.in b/src/test/cppunit/ui/text/Makefile.in
new file mode 100644
index 0000000..db794f6
--- /dev/null
+++ b/src/test/cppunit/ui/text/Makefile.in
@@ -0,0 +1,433 @@
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = include/cppunit/ui/text
+DIST_COMMON = $(libcppunitinclude_HEADERS) $(srcdir)/Makefile.am \
+	$(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps =  \
+	$(top_srcdir)/config/ac_create_prefix_config_h.m4 \
+	$(top_srcdir)/config/ac_cxx_have_sstream.m4 \
+	$(top_srcdir)/config/ac_cxx_have_strstream.m4 \
+	$(top_srcdir)/config/ac_cxx_namespaces.m4 \
+	$(top_srcdir)/config/ac_cxx_rtti.m4 \
+	$(top_srcdir)/config/ac_cxx_string_compare_string_first.m4 \
+	$(top_srcdir)/config/ac_dll.m4 \
+	$(top_srcdir)/config/ax_cxx_gcc_abi_demangle.m4 \
+	$(top_srcdir)/config/ax_cxx_have_isfinite.m4 \
+	$(top_srcdir)/config/bb_enable_doxygen.m4 \
+	$(top_srcdir)/configure.in
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = $(top_builddir)/config/config.h
+CONFIG_CLEAN_FILES =
+SOURCES =
+DIST_SOURCES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
+am__installdirs = "$(DESTDIR)$(libcppunitincludedir)"
+libcppunitincludeHEADERS_INSTALL = $(INSTALL_HEADER)
+HEADERS = $(libcppunitinclude_HEADERS)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+AMTAR = @AMTAR@
+AR = @AR@
+AS = @AS@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CPPUNIT_BINARY_AGE = @CPPUNIT_BINARY_AGE@
+CPPUNIT_INTERFACE_AGE = @CPPUNIT_INTERFACE_AGE@
+CPPUNIT_MAJOR_VERSION = @CPPUNIT_MAJOR_VERSION@
+CPPUNIT_MICRO_VERSION = @CPPUNIT_MICRO_VERSION@
+CPPUNIT_MINOR_VERSION = @CPPUNIT_MINOR_VERSION@
+CPPUNIT_VERSION = @CPPUNIT_VERSION@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+ECHO = @ECHO@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+F77 = @F77@
+FFLAGS = @FFLAGS@
+GREP = @GREP@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LDFLAGS = @LDFLAGS@
+LIBADD_DL = @LIBADD_DL@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_AGE = @LT_AGE@
+LT_CURRENT = @LT_CURRENT@
+LT_RELEASE = @LT_RELEASE@
+LT_REVISION = @LT_REVISION@
+MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+RANLIB = @RANLIB@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_F77 = @ac_ct_F77@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dot = @enable_dot@
+enable_html_docs = @enable_html_docs@
+enable_latex_docs = @enable_latex_docs@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+libcppunitincludedir = $(includedir)/cppunit/ui/text
+libcppunitinclude_HEADERS = \
+	TestRunner.h \
+  TextTestRunner.h
+
+all: all-am
+
+.SUFFIXES:
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile'; \
+	cd $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu  include/cppunit/ui/text/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+install-libcppunitincludeHEADERS: $(libcppunitinclude_HEADERS)
+	@$(NORMAL_INSTALL)
+	test -z "$(libcppunitincludedir)" || $(MKDIR_P) "$(DESTDIR)$(libcppunitincludedir)"
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(libcppunitincludeHEADERS_INSTALL) '$$d$$p' '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  $(libcppunitincludeHEADERS_INSTALL) "$$d$$p" "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+uninstall-libcppunitincludeHEADERS:
+	@$(NORMAL_UNINSTALL)
+	@list='$(libcppunitinclude_HEADERS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(libcppunitincludedir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(libcppunitincludedir)/$$f"; \
+	done
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	    $$tags $$unique; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	tags=; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$tags$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$tags $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && cd $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) $$here
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -pR $(srcdir)/$$file $(distdir)$$dir || exit 1; \
+	    fi; \
+	    cp -pR $$d/$$file $(distdir)$$dir || exit 1; \
+	  else \
+	    test -f $(distdir)/$$file \
+	    || cp -p $$d/$$file $(distdir)/$$file \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(HEADERS)
+installdirs:
+	for dir in "$(DESTDIR)$(libcppunitincludedir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool mostlyclean-am
+
+distclean: distclean-am
+	-rm -f Makefile
+distclean-am: clean-am distclean-generic distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+info: info-am
+
+info-am:
+
+install-data-am: install-libcppunitincludeHEADERS
+
+install-dvi: install-dvi-am
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-info: install-info-am
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-ps: install-ps-am
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-generic mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-libcppunitincludeHEADERS
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool ctags distclean distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-libcppunitincludeHEADERS install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
+	install-strip installcheck installcheck-am installdirs \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-libcppunitincludeHEADERS
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff --git a/src/test/cppunit/ui/text/TestRunner.h b/src/test/cppunit/ui/text/TestRunner.h
new file mode 100644
index 0000000..023eb83
--- /dev/null
+++ b/src/test/cppunit/ui/text/TestRunner.h
@@ -0,0 +1,24 @@
+#ifndef CPPUNIT_UI_TEXT_TESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TESTRUNNER_H
+
+#include <cppunit/ui/text/TextTestRunner.h>
+
+
+#if defined(CPPUNIT_HAVE_NAMESPACES)
+
+CPPUNIT_NS_BEGIN
+namespace TextUi
+{
+
+  /*! Text TestRunner (DEPRECATED).
+   * \deprecated Use TextTestRunner instead.
+   */
+  typedef TextTestRunner TestRunner;
+
+}
+CPPUNIT_NS_END
+
+#endif // defined(CPPUNIT_HAVE_NAMESPACES)
+
+
+#endif  // CPPUNIT_UI_TEXT_TESTRUNNER_H
diff --git a/src/test/cppunit/ui/text/TextTestRunner.h b/src/test/cppunit/ui/text/TextTestRunner.h
new file mode 100644
index 0000000..c8f7894
--- /dev/null
+++ b/src/test/cppunit/ui/text/TextTestRunner.h
@@ -0,0 +1,97 @@
+#ifndef CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+#define CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
+
+
+#include <cppunit/Portability.h>
+#include <string>
+#include <cppunit/TestRunner.h>
+
+CPPUNIT_NS_BEGIN
+
+
+class Outputter;
+class Test;
+class TestSuite;
+class TextOutputter;
+class TestResult;
+class TestResultCollector;
+
+
+
+/*!
+ * \brief A text mode test runner.
+ * \ingroup WritingTestResult
+ * \ingroup ExecutingTest
+ *
+ * The test runner manage the life cycle of the added tests.
+ *
+ * The test runner can run only one of the added tests or all the tests.
+ *
+ * TestRunner prints out a trace as the tests are executed followed by a
+ * summary at the end. The trace and summary print are optional.
+ *
+ * Here is an example of use:
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * The trace is printed using a TextTestProgressListener. The summary is printed
+ * using a TextOutputter.
+ *
+ * You can specify an alternate Outputter at construction
+ * or later with setOutputter().
+ *
+ * After construction, you can register additional TestListener to eventManager(),
+ * for a custom progress trace, for example.
+ *
+ * \code
+ * CppUnit::TextTestRunner runner;
+ * runner.addTest( ExampleTestCase::suite() );
+ * runner.setOutputter( CppUnit::CompilerOutputter::defaultOutputter(
+ *                          &runner.result(),
+ *                          std::cerr ) );
+ * MyCustomProgressTestListener progress;
+ * runner.eventManager().addListener( &progress );
+ * runner.run( "", true );    // Run all tests and wait
+ * \endcode
+ *
+ * \see CompilerOutputter, XmlOutputter, TextOutputter.
+ */
+class CPPUNIT_API TextTestRunner : public CPPUNIT_NS::TestRunner
+{
+public:
+  TextTestRunner( Outputter *outputter =NULL );
+
+  virtual ~TextTestRunner();
+
+  bool run( std::string testPath ="",
+            bool doWait = false,
+            bool doPrintResult = true,
+            bool doPrintProgress = true );
+
+  void setOutputter( Outputter *outputter );
+
+  TestResultCollector &result() const;
+
+  TestResult &eventManager() const;
+
+public: // overridden from TestRunner (to avoid hidden virtual function warning)
+  virtual void run( TestResult &controller,
+                    const std::string &testPath = "" );
+
+protected:
+  virtual void wait( bool doWait );
+  virtual void printResult( bool doPrintResult );
+
+  TestResultCollector *m_result;
+  TestResult *m_eventManager;
+  Outputter *m_outputter;
+};
+
+
+CPPUNIT_NS_END
+
+#endif  // CPPUNIT_UI_TEXT_TEXTTESTRUNNER_H
diff --git a/src/test/efficiency/AbstractEfficiencyTestCase.h b/src/test/efficiency/AbstractEfficiencyTestCase.h
new file mode 100644
index 0000000..b1554d3
--- /dev/null
+++ b/src/test/efficiency/AbstractEfficiencyTestCase.h
@@ -0,0 +1,40 @@
+#pragma once
+
+#include "../EngineTestBase.h"
+#include "EfficiencyActionExecutionListener.h"
+
+using namespace std;
+
+namespace ai
+{
+    class AbstractEfficiencyTestCase : public EngineTestBase
+    {
+    public:
+        void setUp()
+        {
+            EngineTestBase::setUp();
+        }
+
+    protected:
+        void refresh(map<string, SpellInfo> spellInfo)
+        {
+            for (map<string, SpellInfo>::iterator i = spellInfo.begin(); i != spellInfo.end(); ++i)
+            {
+                spellAvailable(i->first);
+            }
+        }
+
+        void run(map<string, SpellInfo> spellInfo, double mana)
+        {
+            EfficiencyActionExecutionListener* listener = new EfficiencyActionExecutionListener(ai, spellInfo, mana);
+            engine->AddActionExecutionListener(listener);
+            while (listener->CanContinue())
+            {
+                tick();
+                refresh(spellInfo);
+            }
+            listener->Report();
+        }
+    };
+
+}
diff --git a/src/test/efficiency/DruidEfficiencyTestCase.cpp b/src/test/efficiency/DruidEfficiencyTestCase.cpp
new file mode 100644
index 0000000..9a096f0
--- /dev/null
+++ b/src/test/efficiency/DruidEfficiencyTestCase.cpp
@@ -0,0 +1,39 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Druid/DruidAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class DruidEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+
+CPPUNIT_TEST_SUITE( DruidEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_caster );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["entangling roots"] = SpellInfo(23, 1.5, 15, 50);
+        spellInfo["faerie fire"] = SpellInfo(26, 0, 0, 0);
+        spellInfo["hibernate"] = SpellInfo(23, 1.5, 0, 0);
+        spellInfo["moonfire"] = SpellInfo(69, 0, 12, 28 + 52);
+        spellInfo["wrath"] = SpellInfo(36, 2, 0, 53);
+        return spellInfo;
+    }
+
+ 	void lvl19_caster()
+	{
+        setupEngine(new DruidAiObjectContext(ai), "caster", "aoe", NULL);
+        addTargetAura("faerie fire");
+        run(lvl19(), 600);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( DruidEfficiencyTestCase );
diff --git a/src/test/efficiency/EfficiencyActionExecutionListener.cpp b/src/test/efficiency/EfficiencyActionExecutionListener.cpp
new file mode 100644
index 0000000..9b3c3f2
--- /dev/null
+++ b/src/test/efficiency/EfficiencyActionExecutionListener.cpp
@@ -0,0 +1,88 @@
+#include "pch.h"
+#include "../aitest.h"
+#include "../EngineTestBase.h"
+#include "../MockedTargets.h"
+#include "../AiObjectContextWrapper.h"
+#include "EfficiencyActionExecutionListener.h"
+
+
+EfficiencyActionExecutionListener::EfficiencyActionExecutionListener(MockPlayerbotAIBase *ai, map<string, SpellInfo> spellInfo, double mana) :
+    ai(ai), spellInfo(spellInfo), mana(mana), castTime(0), damage(0), fullMana(mana), log("")
+{
+}
+
+bool EfficiencyActionExecutionListener::Before(Action* action, Event event)
+{
+    return true;
+}
+
+bool EfficiencyActionExecutionListener::AllowExecution(Action* action, Event event)
+{
+    return false;
+}
+
+bool EfficiencyActionExecutionListener::OverrideResult(Action* action, bool executed, Event event)
+{
+    if (!executed)
+        return false;
+
+    string name = action->getName();
+    if (!spellInfo.count(name))
+        return false;
+
+    SpellInfo spell = spellInfo[name];
+
+    string sharedCooldown = spell.sharedCooldown.empty() ? name : spell.sharedCooldown;
+    if (cooldown.count(sharedCooldown) && cooldown[sharedCooldown] > 0)
+        return false;
+
+    if (mana < spell.mana)
+        return false;
+
+    return true;
+}
+
+void EfficiencyActionExecutionListener::After(Action* action, bool executed, Event event)
+{
+    string name = action->getName();
+    if (!spellInfo.count(name))
+        return;
+
+    SpellInfo spell = spellInfo[name];
+
+    double elapsed = max(executed ? 1.5 : 0.1, spell.castTime);
+    for (map<string, double>::iterator i = cooldown.begin(); i != cooldown.end(); ++i)
+    {
+        int value = i->second - elapsed;
+        string sharedCooldown = spell.sharedCooldown.empty() ? i->first : spell.sharedCooldown;
+        cooldown[sharedCooldown] = value > 0 ? value : 0;
+    }
+
+    castTime += elapsed;
+
+    if (!executed)
+        return;
+
+    mana -= spell.mana;
+    string sharedCooldown = spell.sharedCooldown.empty() ? name : spell.sharedCooldown;
+    cooldown[sharedCooldown] = spell.cooldown;
+    damage += spell.damage;
+    if (!log.empty())
+        log += ",";
+    log += name;
+}
+
+void EfficiencyActionExecutionListener::Report()
+{
+    cout << endl << log << endl <<
+            "Time: " << castTime << endl <<
+            "Damage: " << damage << endl <<
+            "Mana: " << mana << endl;
+    if (damage > 0 && castTime > 0)
+        cout << "DPS: " << damage / castTime << endl;
+}
+
+bool EfficiencyActionExecutionListener::CanContinue()
+{
+    return castTime < 60 && mana > fullMana / 10;
+}
diff --git a/src/test/efficiency/EfficiencyActionExecutionListener.h b/src/test/efficiency/EfficiencyActionExecutionListener.h
new file mode 100644
index 0000000..f4076d8
--- /dev/null
+++ b/src/test/efficiency/EfficiencyActionExecutionListener.h
@@ -0,0 +1,52 @@
+#pragma once
+
+#include "../../plugins/playerbot/strategy/Action.h"
+#include "../../plugins/playerbot/strategy/ActionBasket.h"
+#include "../../plugins/playerbot/strategy/Queue.h"
+#include "../../plugins/playerbot/strategy/Trigger.h"
+#include "../../plugins/playerbot/strategy/Engine.h"
+
+#include "../MockPlayerbotAIBase.h"
+
+using namespace ai;
+
+class SpellInfo
+{
+public:
+    SpellInfo() : mana(0), castTime(0), cooldown(0), damage(0) {}
+    SpellInfo(double mana, double castTime, double cooldown, double damage, string sharedCooldown = "") :
+        mana(mana), castTime(castTime), cooldown(cooldown), damage(damage), sharedCooldown(sharedCooldown) {}
+    SpellInfo(SpellInfo const& other)
+    {
+        mana = other.mana;
+        castTime = other.castTime;
+        cooldown = other.cooldown;
+        damage = other.damage;
+        sharedCooldown = other.sharedCooldown;
+    }
+    virtual ~SpellInfo() {}
+
+    double mana, castTime, cooldown, damage;
+    string sharedCooldown;
+};
+
+class EfficiencyActionExecutionListener : public ActionExecutionListener
+{
+public:
+    EfficiencyActionExecutionListener(MockPlayerbotAIBase *ai, map<string, SpellInfo> spellInfo, double mana);
+
+    virtual bool Before(Action* action, Event event);
+    virtual bool AllowExecution(Action* action, Event event);
+    virtual bool OverrideResult(Action* action, bool executed, Event event);
+    virtual void After(Action* action, bool executed, Event event);
+    void Report();
+    bool CanContinue();
+
+private:
+    map<string, SpellInfo> spellInfo;
+    map<string, double> cooldown;
+    double mana, castTime, damage, fullMana;
+    MockPlayerbotAIBase *ai;
+    string log;
+};
+
diff --git a/src/test/efficiency/MageEfficiencyTestCase.cpp b/src/test/efficiency/MageEfficiencyTestCase.cpp
new file mode 100644
index 0000000..7de662d
--- /dev/null
+++ b/src/test/efficiency/MageEfficiencyTestCase.cpp
@@ -0,0 +1,55 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/mage/MageAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class MageEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( MageEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_frost );
+  CPPUNIT_TEST( lvl19_fire );
+  CPPUNIT_TEST( lvl19_arcane );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["frostbolt"] = SpellInfo(27, 2, 0, 54);
+        spellInfo["frost nova"] = SpellInfo(24, 0, 25, 20);
+        spellInfo["arcane explosion"] = SpellInfo(67, 0, 0, 33);
+        spellInfo["arcane missiles"] = SpellInfo(106, 4, 0, 36 * 4);
+        spellInfo["polymorph"] = SpellInfo(24, 1.5, 0, 0);
+        spellInfo["remove curse"] = SpellInfo(27, 0, 0, 0);
+        spellInfo["fire blast"] = SpellInfo(72, 0, 8, 64);
+        spellInfo["fireball"] = SpellInfo(54, 3, 0, 100);
+        spellInfo["flamestrike"] = SpellInfo(120, 2, 0, 60);
+        return spellInfo;
+    }
+
+ 	void lvl19_frost()
+	{
+        setupEngine(new MageAiObjectContext(ai), "frost", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_fire()
+	{
+        setupEngine(new MageAiObjectContext(ai), "fire", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_arcane()
+	{
+        setupEngine(new MageAiObjectContext(ai), "arcane", NULL);
+        run(lvl19(), 888);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( MageEfficiencyTestCase );
diff --git a/src/test/efficiency/PriestEfficiencyTestCase.cpp b/src/test/efficiency/PriestEfficiencyTestCase.cpp
new file mode 100644
index 0000000..5331b28
--- /dev/null
+++ b/src/test/efficiency/PriestEfficiencyTestCase.cpp
@@ -0,0 +1,43 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Priest/PriestAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class PriestEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+
+CPPUNIT_TEST_SUITE( PriestEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_shadow );
+  CPPUNIT_TEST( lvl19_holy );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["mind blast"] = SpellInfo(62, 1.5, 8, 74);
+        spellInfo["shadow word: pain"] = SpellInfo(80, 0, 18, 120);
+        spellInfo["smite"] = SpellInfo(54, 2.5, 0, 58);
+        spellInfo["shoot"] = SpellInfo(0, 0, 1, 15);
+        return spellInfo;
+    }
+
+ 	void lvl19_shadow()
+	{
+        setupEngine(new PriestAiObjectContext(ai), "shadow", "aoe", NULL);
+        run(lvl19(), 777);
+	}
+
+ 	void lvl19_holy()
+	{
+        setupEngine(new PriestAiObjectContext(ai), "holy", "aoe", NULL);
+        run(lvl19(), 777);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( PriestEfficiencyTestCase );
diff --git a/src/test/efficiency/ShamanEfficiencyTestCase.cpp b/src/test/efficiency/ShamanEfficiencyTestCase.cpp
new file mode 100644
index 0000000..b9a8ff1
--- /dev/null
+++ b/src/test/efficiency/ShamanEfficiencyTestCase.cpp
@@ -0,0 +1,46 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class ShamanEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( ShamanEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_melee );
+  CPPUNIT_TEST( lvl19_caster );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["earth shock"] = SpellInfo(62, 0, 6, 62, "shock");
+        spellInfo["flame shock"] = SpellInfo(58, 0, 18, 45 + 72, "shock");
+        spellInfo["lightning bolt"] = SpellInfo(34, 2.5, 0, 49);
+        spellInfo["lightning shield"] = SpellInfo(0, 0, 0, 0);
+        spellInfo["searing totem"] = SpellInfo(24, 0, 30, 10 * 30 / 1.5);
+        spellInfo["fire nova"] = SpellInfo(75, 0, 6, 52);
+        spellInfo["melee"] = SpellInfo(0, 0, 1, 15 + 6);
+        return spellInfo;
+    }
+
+ 	void lvl19_melee()
+	{
+        setupEngine(new ShamanAiObjectContext(ai), "melee", "melee aoe", NULL);
+        run(lvl19(), 600);
+	}
+
+ 	void lvl19_caster()
+	{
+        setupEngine(new ShamanAiObjectContext(ai), "caster", "caster aoe", NULL);
+        run(lvl19(), 600);
+	}
+
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( ShamanEfficiencyTestCase );
diff --git a/src/test/efficiency/WarlockEfficiencyTestCase.cpp b/src/test/efficiency/WarlockEfficiencyTestCase.cpp
new file mode 100644
index 0000000..790e249
--- /dev/null
+++ b/src/test/efficiency/WarlockEfficiencyTestCase.cpp
@@ -0,0 +1,43 @@
+#include "pch.h"
+
+#include "../aitest.h"
+#include "../../../plugins/playerbot/strategy/Warlock/WarlockAiObjectContext.h"
+#include "EfficiencyActionExecutionListener.h"
+#include "AbstractEfficiencyTestCase.h"
+
+using namespace ai;
+
+
+class WarlockEfficiencyTestCase : public AbstractEfficiencyTestCase
+{
+  CPPUNIT_TEST_SUITE( WarlockEfficiencyTestCase );
+  CPPUNIT_TEST( lvl19_dps );
+  CPPUNIT_TEST( lvl19_tank );
+  CPPUNIT_TEST_SUITE_END();
+
+protected:
+    map<string, SpellInfo> lvl19()
+    {
+        map<string, SpellInfo> spellInfo;
+        spellInfo["corruption"] = SpellInfo(42, 0, 15, 90);
+        spellInfo["immolate"] = SpellInfo(60, 0, 15, 19 + 40);
+        spellInfo["shadow bolt"] = SpellInfo(58, 2.8, 0, 52);
+        spellInfo["curse of agony"] = SpellInfo(35, 0, 24, 180);
+        spellInfo["shoot"] = SpellInfo(0, 0, 1, 15);
+        return spellInfo;
+    }
+
+ 	void lvl19_dps()
+	{
+        setupEngine(new WarlockAiObjectContext(ai), "dps", "aoe", NULL);
+        run(lvl19(), 888);
+	}
+
+ 	void lvl19_tank()
+	{
+        setupEngine(new WarlockAiObjectContext(ai), "tank", "aoe", NULL);
+        run(lvl19(), 888);
+	}
+};
+
+CPPUNIT_TEST_SUITE_REGISTRATION( WarlockEfficiencyTestCase );
diff --git a/src/test/main.cpp b/src/test/main.cpp
new file mode 100644
index 0000000..2e0c74f
--- /dev/null
+++ b/src/test/main.cpp
@@ -0,0 +1,94 @@
+#include "pch.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/ahbot/AhBot.h"
+
+WorldDatabaseWorkerPool WorldDatabase;                      ///< Accessor to the world database
+CharacterDatabaseWorkerPool CharacterDatabase;              ///< Accessor to the character database
+LoginDatabaseWorkerPool LoginDatabase;                      ///< Accessor to the realm/login database
+uint32 realmID;                                             ///< Id of the realm
+
+int main(int argc, char* argv[])
+{
+
+    std::string configError;
+    if (!sConfigMgr->LoadInitial("worldserver.conf", configError))
+    {
+        printf("Error in config file: %s\n", configError.c_str());
+        return 1;
+    }
+
+    MySQL::Library_Init();
+
+    if (!WorldDatabase.Open(sConfigMgr->GetStringDefault("WorldDatabaseInfo", ""), 1, 1))
+    {
+        TC_LOG_ERROR("server.worldserver", "Cannot connect to world database");
+        return false;
+    }
+    if (!CharacterDatabase.Open(sConfigMgr->GetStringDefault("CharacterDatabaseInfo", ""), 1, 1))
+    {
+        TC_LOG_ERROR("server.worldserver", "Cannot connect to Character database");
+        return false;
+    }
+    if (!LoginDatabase.Open(sConfigMgr->GetStringDefault("LoginDatabaseInfo", ""), 1, 1))
+    {
+        TC_LOG_ERROR("server.worldserver", "Cannot connect to Login database");
+        return false;
+    }
+
+    //sWorld->SetInitialWorldSettings();
+    std::string dataPath = sConfigMgr->GetStringDefault("DataDir", "./");
+    if (dataPath.empty() || (dataPath.at(dataPath.length()-1) != '/' && dataPath.at(dataPath.length()-1) != '\\'))
+        dataPath.push_back('/');
+
+    ///- Load the DBC files
+     TC_LOG_INFO("server.loading", "Initialize data stores...");
+     LoadDBCStores(dataPath);
+
+     auctionbot.Init();
+
+    sPlayerbotAIConfig.Initialize();
+    sPlayerbotAIConfig.enabled = true;
+    sPlayerbotAIConfig.globalCoolDown = 1000;
+    sPlayerbotAIConfig.reactDelay = 100;
+    sPlayerbotAIConfig.sightDistance = 40.0f;
+    sPlayerbotAIConfig.spellDistance = 25.0f;
+    sPlayerbotAIConfig.reactDistance = 100.0f;
+    sPlayerbotAIConfig.grindDistance = 50.0f;
+    sPlayerbotAIConfig.meleeDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.followDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.tooCloseDistance = ATTACK_DISTANCE;
+    sPlayerbotAIConfig.contactDistance = CONTACT_DISTANCE;
+    sPlayerbotAIConfig.lootDistance = 20.0f;
+    sPlayerbotAIConfig.criticalHealth = 25;
+    sPlayerbotAIConfig.lowHealth = 40;
+    sPlayerbotAIConfig.mediumHealth = 60;
+    sPlayerbotAIConfig.almostFullHealth = 80;
+    sPlayerbotAIConfig.lowMana = 40;
+    sPlayerbotAIConfig.mediumMana = 60;
+    sPlayerbotAIConfig.iterationsPerTick = 10;
+    sPlayerbotAIConfig.randomChangeMultiplier = 1;
+
+    // Create the event manager and test controller
+    CPPUNIT_NS::TestResult controller;
+
+    // Add a listener that colllects test result
+    CPPUNIT_NS::TestResultCollector result;
+    controller.addListener( &result );
+
+    // Add a listener that print dots as test run.
+    CPPUNIT_NS::BriefTestProgressListener progress;
+    controller.addListener( &progress );
+
+    // Add the top suite to the test runner
+    CPPUNIT_NS::TestRunner runner;
+
+    runner.addTest( CPPUNIT_NS::TestFactoryRegistry::getRegistry().makeTest() );
+    runner.run( controller, argc > 1 ? argv[1] : "" );
+
+    // Print test in a compiler compatible format.
+    CPPUNIT_NS::CompilerOutputter outputter( &result, CPPUNIT_NS::stdCOut() );
+    outputter.write();
+
+    cout.flush();
+    return result.wasSuccessful() ? 0 : 1;
+}
diff --git a/src/test/pch.cpp b/src/test/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/test/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/test/pch.h b/src/test/pch.h
new file mode 100644
index 0000000..4feb1f7
--- /dev/null
+++ b/src/test/pch.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../server/game/Miscellaneous/Language.h"
+#include "../server/shared/Logging/Log.h"
+#include "../server/game/World/World.h"
+#include "../server/game/Globals/ObjectMgr.h"
+#include "../server/game/Server/WorldSession.h"
+#include "../server/shared/Configuration/Config.h"
+#include "../server/shared/Utilities/Util.h"
+#include "../server/game/Accounts/AccountMgr.h"
+#include "../server/worldserver/CommandLine/CliRunnable.h"
+#include "../server/game/Maps/MapManager.h"
+#include "../server/game/Entities/Player/Player.h"
+#include "../server/game/Chat/Chat.h"
+#include "../server/shared/Database/DatabaseEnv.h"
+#include "../server/shared/SystemConfig.h"
+#include <openssl/opensslv.h>
+#include <openssl/crypto.h>
+
+#include <cppunit/BriefTestProgressListener.h>
+#include <cppunit/CompilerOutputter.h>
+#include <cppunit/extensions/TestFactoryRegistry.h>
+#include <cppunit/TestResult.h>
+#include <cppunit/TestResultCollector.h>
+#include <cppunit/TestRunner.h>
+#include <cppunit/extensions/HelperMacros.h>
+#include <cppunit/TestSuite.h>
+#include <cppunit/TestPath.h>
+#include <stdexcept>
+
+#include <stdio.h>
+#include <iostream>
+
+#include <list>
+#include "../server/shared/Define.h"
+
+#include <stdexcept>
+
+#include "../../plugins/playerbot/playerbotDefs.h"
-- 
1.7.10.4

