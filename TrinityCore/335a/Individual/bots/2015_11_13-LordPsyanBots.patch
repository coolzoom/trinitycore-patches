From 17d114bb2accf66d714d49a44dec66da1fae73df Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Sun, 15 Nov 2015 08:09:35 -0600
Subject: [PATCH] 2015_11_13-LordPsyanBots

---
 .../Bots/character_lordpsyanbots.sql               | 10771 +++++++++++++++++++
 .../Bots/world_lordpsyanbots.sql                   |   170 +
 src/CMakeLists.txt                                 |     2 +
 src/common/Configuration/Config.h                  |     2 +
 src/plugins/CMakeLists.txt                         |   192 +
 src/plugins/ahbot/AhBot.cpp                        |   985 ++
 src/plugins/ahbot/AhBot.h                          |    93 +
 src/plugins/ahbot/AhBotConfig.cpp                  |    58 +
 src/plugins/ahbot/AhBotConfig.h                    |    93 +
 src/plugins/ahbot/Category.cpp                     |    76 +
 src/plugins/ahbot/Category.h                       |   354 +
 src/plugins/ahbot/ConsumableCategory.cpp           |     5 +
 src/plugins/ahbot/ConsumableCategory.h             |    86 +
 src/plugins/ahbot/ItemBag.cpp                      |   184 +
 src/plugins/ahbot/ItemBag.h                        |    82 +
 src/plugins/ahbot/PricingStrategy.cpp              |   220 +
 src/plugins/ahbot/PricingStrategy.h                |    55 +
 src/plugins/ahbot/TradeCategory.cpp                |     4 +
 src/plugins/ahbot/TradeCategory.h                  |   183 +
 src/plugins/ahbot/ahbot.conf.dist.in               |   209 +
 src/plugins/pch/pch.cpp                            |     1 +
 src/plugins/pch/pch.h                              |    10 +
 src/plugins/pchdef.h                               |     4 +
 src/plugins/playerbot/AiFactory.cpp                |   229 +
 src/plugins/playerbot/AiFactory.h                  |    20 +
 src/plugins/playerbot/ChatFilter.cpp               |   258 +
 src/plugins/playerbot/ChatFilter.h                 |    24 +
 src/plugins/playerbot/ChatHelper.cpp               |   450 +
 src/plugins/playerbot/ChatHelper.h                 |    52 +
 src/plugins/playerbot/FleeManager.cpp              |   160 +
 src/plugins/playerbot/FleeManager.h                |    83 +
 src/plugins/playerbot/GuildTaskMgr.cpp             |   697 ++
 src/plugins/playerbot/GuildTaskMgr.h               |    45 +
 src/plugins/playerbot/Helpers.cpp                  |    90 +
 src/plugins/playerbot/LazyCalculatedValue.h        |    42 +
 src/plugins/playerbot/LootObjectStack.cpp          |   234 +
 src/plugins/playerbot/LootObjectStack.h            |    76 +
 src/plugins/playerbot/PlayerbotAI.cpp              |  1390 +++
 src/plugins/playerbot/PlayerbotAI.h                |   186 +
 src/plugins/playerbot/PlayerbotAIAware.h           |    13 +
 src/plugins/playerbot/PlayerbotAIBase.cpp          |    51 +
 src/plugins/playerbot/PlayerbotAIBase.h            |    24 +
 src/plugins/playerbot/PlayerbotAIConfig.cpp        |   229 +
 src/plugins/playerbot/PlayerbotAIConfig.h          |    82 +
 src/plugins/playerbot/PlayerbotCommandServer.cpp   |    94 +
 src/plugins/playerbot/PlayerbotCommandServer.h     |    26 +
 src/plugins/playerbot/PlayerbotFactory.cpp         |  1723 +++
 src/plugins/playerbot/PlayerbotFactory.h           |    68 +
 src/plugins/playerbot/PlayerbotMgr.cpp             |   472 +
 src/plugins/playerbot/PlayerbotMgr.h               |    69 +
 src/plugins/playerbot/PlayerbotSecurity.cpp        |   187 +
 src/plugins/playerbot/PlayerbotSecurity.h          |    42 +
 src/plugins/playerbot/RandomItemMgr.cpp            |   154 +
 src/plugins/playerbot/RandomItemMgr.h              |    50 +
 src/plugins/playerbot/RandomPlayerbotFactory.cpp   |   386 +
 src/plugins/playerbot/RandomPlayerbotFactory.h     |    35 +
 src/plugins/playerbot/RandomPlayerbotMgr.cpp       |   912 ++
 src/plugins/playerbot/RandomPlayerbotMgr.h         |    74 +
 src/plugins/playerbot/aiplayerbot.conf.dist.in     |   183 +
 src/plugins/playerbot/playerbot.h                  |    31 +
 src/plugins/playerbot/playerbotDefs.h              |     2 +
 src/plugins/playerbot/strategy/Action.cpp          |    93 +
 src/plugins/playerbot/strategy/Action.h            |   138 +
 src/plugins/playerbot/strategy/ActionBasket.cpp    |     4 +
 src/plugins/playerbot/strategy/ActionBasket.h      |     5 +
 src/plugins/playerbot/strategy/AiObject.cpp        |    16 +
 src/plugins/playerbot/strategy/AiObject.h          |    33 +
 src/plugins/playerbot/strategy/AiObjectContext.cpp |    48 +
 src/plugins/playerbot/strategy/AiObjectContext.h   |    81 +
 src/plugins/playerbot/strategy/Engine.cpp          |   536 +
 src/plugins/playerbot/strategy/Engine.h            |   123 +
 src/plugins/playerbot/strategy/Event.cpp           |    20 +
 src/plugins/playerbot/strategy/Event.h             |    36 +
 .../playerbot/strategy/ExternalEventHelper.h       |    69 +
 src/plugins/playerbot/strategy/ItemVisitors.h      |   258 +
 src/plugins/playerbot/strategy/Multiplier.cpp      |     5 +
 src/plugins/playerbot/strategy/Multiplier.h        |    16 +
 .../playerbot/strategy/NamedObjectContext.h        |   249 +
 .../playerbot/strategy/PassiveMultiplier.cpp       |    47 +
 src/plugins/playerbot/strategy/PassiveMultiplier.h |    20 +
 src/plugins/playerbot/strategy/Queue.cpp           |    81 +
 src/plugins/playerbot/strategy/Queue.h             |    21 +
 src/plugins/playerbot/strategy/Strategy.cpp        |   117 +
 src/plugins/playerbot/strategy/Strategy.h          |    55 +
 src/plugins/playerbot/strategy/StrategyContext.h   |   146 +
 src/plugins/playerbot/strategy/Trigger.cpp         |    27 +
 src/plugins/playerbot/strategy/Trigger.h           |    84 +
 src/plugins/playerbot/strategy/Value.cpp           |     5 +
 src/plugins/playerbot/strategy/Value.h             |   177 +
 .../playerbot/strategy/actions/AcceptDuelAction.h  |    31 +
 .../strategy/actions/AcceptInvitationAction.h      |    47 +
 .../strategy/actions/AcceptQuestAction.cpp         |   102 +
 .../playerbot/strategy/actions/AcceptQuestAction.h |    27 +
 .../strategy/actions/AcceptResurrectAction.h       |    31 +
 .../playerbot/strategy/actions/ActionContext.h     |   110 +
 .../playerbot/strategy/actions/AddLootAction.cpp   |    62 +
 .../playerbot/strategy/actions/AddLootAction.h     |    32 +
 .../strategy/actions/AreaTriggerAction.cpp         |    80 +
 .../playerbot/strategy/actions/AreaTriggerAction.h |    23 +
 .../playerbot/strategy/actions/AttackAction.cpp    |   104 +
 .../playerbot/strategy/actions/AttackAction.h      |    38 +
 .../playerbot/strategy/actions/BankAction.cpp      |   168 +
 .../playerbot/strategy/actions/BankAction.h        |    21 +
 .../playerbot/strategy/actions/BuffAction.cpp      |   118 +
 .../playerbot/strategy/actions/BuffAction.h        |    17 +
 .../playerbot/strategy/actions/BuyAction.cpp       |    53 +
 src/plugins/playerbot/strategy/actions/BuyAction.h |    19 +
 .../strategy/actions/CastCustomSpellAction.cpp     |    48 +
 .../strategy/actions/CastCustomSpellAction.h       |    14 +
 .../strategy/actions/ChangeChatAction.cpp          |    26 +
 .../playerbot/strategy/actions/ChangeChatAction.h  |    14 +
 .../strategy/actions/ChangeStrategyAction.cpp      |    38 +
 .../strategy/actions/ChangeStrategyAction.h        |    30 +
 .../strategy/actions/ChangeTalentsAction.cpp       |    37 +
 .../strategy/actions/ChangeTalentsAction.h         |    16 +
 .../playerbot/strategy/actions/ChatActionContext.h |   184 +
 .../strategy/actions/ChatShortcutActions.cpp       |   108 +
 .../strategy/actions/ChatShortcutActions.h         |    57 +
 .../playerbot/strategy/actions/CheckMailAction.cpp |    66 +
 .../playerbot/strategy/actions/CheckMailAction.h   |    17 +
 .../strategy/actions/CheckMountStateAction.cpp     |    80 +
 .../strategy/actions/CheckMountStateAction.h       |    19 +
 .../strategy/actions/ChooseTargetActions.h         |    80 +
 .../strategy/actions/DestroyItemAction.cpp         |    34 +
 .../playerbot/strategy/actions/DestroyItemAction.h |    17 +
 .../playerbot/strategy/actions/DropQuestAction.cpp |    47 +
 .../playerbot/strategy/actions/DropQuestAction.h   |    13 +
 .../playerbot/strategy/actions/EmoteAction.cpp     |   100 +
 .../playerbot/strategy/actions/EmoteAction.h       |    18 +
 .../playerbot/strategy/actions/EquipAction.cpp     |   105 +
 .../playerbot/strategy/actions/EquipAction.h       |    21 +
 .../playerbot/strategy/actions/FollowActions.cpp   |    49 +
 .../playerbot/strategy/actions/FollowActions.h     |    14 +
 .../playerbot/strategy/actions/GenericActions.cpp  |     5 +
 .../playerbot/strategy/actions/GenericActions.h    |    19 +
 .../strategy/actions/GenericSpellActions.cpp       |    58 +
 .../strategy/actions/GenericSpellActions.h         |   271 +
 .../strategy/actions/GossipHelloAction.cpp         |    72 +
 .../playerbot/strategy/actions/GossipHelloAction.h |    13 +
 .../strategy/actions/GuildAcceptAction.cpp         |    42 +
 .../playerbot/strategy/actions/GuildAcceptAction.h |    14 +
 .../playerbot/strategy/actions/GuildBankAction.cpp |    61 +
 .../playerbot/strategy/actions/GuildBankAction.h   |    18 +
 .../playerbot/strategy/actions/HelpAction.cpp      |    54 +
 .../playerbot/strategy/actions/HelpAction.h        |    22 +
 .../playerbot/strategy/actions/InventoryAction.cpp |   288 +
 .../playerbot/strategy/actions/InventoryAction.h   |    24 +
 .../actions/InventoryChangeFailureAction.cpp       |    55 +
 .../actions/InventoryChangeFailureAction.h         |    12 +
 .../strategy/actions/InviteToGroupAction.h         |    28 +
 .../playerbot/strategy/actions/LeaveGroupAction.h  |    79 +
 .../playerbot/strategy/actions/LfgActions.cpp      |   236 +
 .../playerbot/strategy/actions/LfgActions.h        |    48 +
 .../strategy/actions/ListQuestsActions.cpp         |    71 +
 .../playerbot/strategy/actions/ListQuestsActions.h |    25 +
 .../strategy/actions/ListSpellsAction.cpp          |    65 +
 .../playerbot/strategy/actions/ListSpellsAction.h  |    16 +
 .../playerbot/strategy/actions/LogLevelAction.cpp  |    43 +
 .../playerbot/strategy/actions/LogLevelAction.h    |    17 +
 .../playerbot/strategy/actions/LootAction.cpp      |   338 +
 .../playerbot/strategy/actions/LootAction.h        |    39 +
 .../playerbot/strategy/actions/LootRollAction.cpp  |    66 +
 .../playerbot/strategy/actions/LootRollAction.h    |    15 +
 .../strategy/actions/LootStrategyAction.cpp        |   100 +
 .../strategy/actions/LootStrategyAction.h          |    19 +
 .../playerbot/strategy/actions/MovementActions.cpp |   373 +
 .../playerbot/strategy/actions/MovementActions.h   |    92 +
 .../strategy/actions/NonCombatActions.cpp          |     6 +
 .../playerbot/strategy/actions/NonCombatActions.h  |    47 +
 .../actions/PassLeadershipToMasterAction.h         |    26 +
 .../playerbot/strategy/actions/PositionAction.cpp  |    38 +
 .../playerbot/strategy/actions/PositionAction.h    |    37 +
 .../strategy/actions/QueryItemUsageAction.cpp      |   172 +
 .../strategy/actions/QueryItemUsageAction.h        |    24 +
 .../strategy/actions/QueryQuestAction.cpp          |    89 +
 .../playerbot/strategy/actions/QueryQuestAction.h  |    16 +
 .../playerbot/strategy/actions/QuestAction.cpp     |   137 +
 .../playerbot/strategy/actions/QuestAction.h       |    33 +
 .../strategy/actions/ReachTargetActions.h          |    57 +
 .../strategy/actions/ReadyCheckAction.cpp          |    84 +
 .../playerbot/strategy/actions/ReadyCheckAction.h  |    26 +
 .../strategy/actions/ReleaseSpiritAction.h         |    29 +
 .../strategy/actions/RememberTaxiAction.cpp        |    46 +
 .../strategy/actions/RememberTaxiAction.h          |    13 +
 .../playerbot/strategy/actions/RepairAllAction.cpp |    30 +
 .../playerbot/strategy/actions/RepairAllAction.h   |    13 +
 .../playerbot/strategy/actions/ResetAiAction.cpp   |    12 +
 .../playerbot/strategy/actions/ResetAiAction.h     |    14 +
 .../strategy/actions/ReviveFromCorpseAction.cpp    |    51 +
 .../strategy/actions/ReviveFromCorpseAction.h      |    21 +
 .../playerbot/strategy/actions/RewardAction.cpp    |    75 +
 .../playerbot/strategy/actions/RewardAction.h      |    17 +
 src/plugins/playerbot/strategy/actions/RtiAction.h |    44 +
 .../playerbot/strategy/actions/SaveManaAction.cpp  |    73 +
 .../playerbot/strategy/actions/SaveManaAction.h    |    20 +
 .../strategy/actions/SecurityCheckAction.cpp       |    31 +
 .../strategy/actions/SecurityCheckAction.h         |    14 +
 .../playerbot/strategy/actions/SellAction.cpp      |    95 +
 .../playerbot/strategy/actions/SellAction.h        |    18 +
 .../playerbot/strategy/actions/SetHomeAction.cpp   |    42 +
 .../playerbot/strategy/actions/SetHomeAction.h     |    12 +
 .../playerbot/strategy/actions/StatsAction.cpp     |   145 +
 .../playerbot/strategy/actions/StatsAction.h       |    22 +
 .../playerbot/strategy/actions/StayActions.cpp     |    34 +
 .../playerbot/strategy/actions/StayActions.h       |    23 +
 .../strategy/actions/SuggestWhatToDoAction.cpp     |   255 +
 .../strategy/actions/SuggestWhatToDoAction.h       |    34 +
 .../strategy/actions/TalkToQuestGiverAction.cpp    |    90 +
 .../strategy/actions/TalkToQuestGiverAction.h      |    22 +
 .../playerbot/strategy/actions/TaxiAction.cpp      |    51 +
 .../playerbot/strategy/actions/TaxiAction.h        |    13 +
 .../playerbot/strategy/actions/TeleportAction.cpp  |    54 +
 .../playerbot/strategy/actions/TeleportAction.h    |    16 +
 .../strategy/actions/TellCastFailedAction.cpp      |    75 +
 .../strategy/actions/TellCastFailedAction.h        |    22 +
 .../strategy/actions/TellItemCountAction.cpp       |    16 +
 .../strategy/actions/TellItemCountAction.h         |    14 +
 .../playerbot/strategy/actions/TellLosAction.cpp   |    61 +
 .../playerbot/strategy/actions/TellLosAction.h     |    17 +
 .../playerbot/strategy/actions/TellMasterAction.h  |    38 +
 .../strategy/actions/TellReputationAction.cpp      |    68 +
 .../strategy/actions/TellReputationAction.h        |    16 +
 .../strategy/actions/TellTargetAction.cpp          |    53 +
 .../playerbot/strategy/actions/TellTargetAction.h  |    21 +
 .../playerbot/strategy/actions/TradeAction.cpp     |    83 +
 .../playerbot/strategy/actions/TradeAction.h       |    19 +
 .../strategy/actions/TradeStatusAction.cpp         |   216 +
 .../playerbot/strategy/actions/TradeStatusAction.h |    20 +
 .../playerbot/strategy/actions/TrainerAction.cpp   |   114 +
 .../playerbot/strategy/actions/TrainerAction.h     |    22 +
 .../playerbot/strategy/actions/UnequipAction.cpp   |    45 +
 .../playerbot/strategy/actions/UnequipAction.h     |    18 +
 .../playerbot/strategy/actions/UseItemAction.cpp   |   302 +
 .../playerbot/strategy/actions/UseItemAction.h     |    47 +
 .../strategy/actions/UseMeetingStoneAction.cpp     |    81 +
 .../strategy/actions/UseMeetingStoneAction.h       |    26 +
 .../playerbot/strategy/actions/WhoAction.cpp       |   160 +
 src/plugins/playerbot/strategy/actions/WhoAction.h |    23 +
 .../strategy/actions/WorldPacketActionContext.h    |   108 +
 .../strategy/druid/BearTankDruidStrategy.cpp       |   171 +
 .../strategy/druid/BearTankDruidStrategy.h         |    18 +
 .../strategy/druid/CasterDruidStrategy.cpp         |   177 +
 .../playerbot/strategy/druid/CasterDruidStrategy.h |    39 +
 .../strategy/druid/CatDpsDruidStrategy.cpp         |   139 +
 .../playerbot/strategy/druid/CatDpsDruidStrategy.h |    29 +
 .../playerbot/strategy/druid/DruidActions.cpp      |    31 +
 .../playerbot/strategy/druid/DruidActions.h        |   205 +
 .../strategy/druid/DruidAiObjectContext.cpp        |   258 +
 .../strategy/druid/DruidAiObjectContext.h          |    12 +
 .../playerbot/strategy/druid/DruidBearActions.h    |    64 +
 .../playerbot/strategy/druid/DruidCatActions.h     |    69 +
 .../playerbot/strategy/druid/DruidMultipliers.cpp  |     6 +
 .../playerbot/strategy/druid/DruidMultipliers.h    |     6 +
 .../strategy/druid/DruidShapeshiftActions.h        |    53 +
 .../playerbot/strategy/druid/DruidTriggers.cpp     |     7 +
 .../playerbot/strategy/druid/DruidTriggers.h       |   127 +
 .../strategy/druid/FeralDruidStrategy.cpp          |    90 +
 .../playerbot/strategy/druid/FeralDruidStrategy.h  |    75 +
 .../druid/GenericDruidNonCombatStrategy.cpp        |    73 +
 .../strategy/druid/GenericDruidNonCombatStrategy.h |    16 +
 .../strategy/druid/GenericDruidStrategy.cpp        |   132 +
 .../strategy/druid/GenericDruidStrategy.h          |    18 +
 .../playerbot/strategy/druid/HealDruidStrategy.cpp |    57 +
 .../playerbot/strategy/druid/HealDruidStrategy.h   |    18 +
 .../generic/AttackEnemyPlayersStrategy.cpp         |    13 +
 .../strategy/generic/AttackEnemyPlayersStrategy.h  |    16 +
 .../strategy/generic/AttackRtiStrategy.cpp         |    14 +
 .../playerbot/strategy/generic/AttackRtiStrategy.h |    16 +
 .../strategy/generic/AttackWeakStrategy.cpp        |    13 +
 .../strategy/generic/AttackWeakStrategy.h          |    16 +
 .../strategy/generic/CastTimeStrategy.cpp          |    42 +
 .../playerbot/strategy/generic/CastTimeStrategy.h  |    26 +
 .../generic/ChatCommandHandlerStrategy.cpp         |   177 +
 .../strategy/generic/ChatCommandHandlerStrategy.h  |    15 +
 .../playerbot/strategy/generic/CombatStrategy.cpp  |    12 +
 .../playerbot/strategy/generic/CombatStrategy.h    |    13 +
 .../strategy/generic/ConserveManaStrategy.cpp      |    88 +
 .../strategy/generic/ConserveManaStrategy.h        |    32 +
 .../playerbot/strategy/generic/DeadStrategy.cpp    |    23 +
 .../playerbot/strategy/generic/DeadStrategy.h      |    15 +
 .../playerbot/strategy/generic/DpsAoeStrategy.cpp  |    12 +
 .../playerbot/strategy/generic/DpsAoeStrategy.h    |    18 +
 .../strategy/generic/DpsAssistStrategy.cpp         |    15 +
 .../playerbot/strategy/generic/DpsAssistStrategy.h |    16 +
 .../playerbot/strategy/generic/DuelStrategy.cpp    |    24 +
 .../playerbot/strategy/generic/DuelStrategy.h      |    15 +
 .../playerbot/strategy/generic/EmoteStrategy.cpp   |    17 +
 .../playerbot/strategy/generic/EmoteStrategy.h     |    16 +
 .../playerbot/strategy/generic/FleeStrategy.cpp    |    26 +
 .../playerbot/strategy/generic/FleeStrategy.h      |    21 +
 .../strategy/generic/FollowMasterStrategy.cpp      |    17 +
 .../strategy/generic/FollowMasterStrategy.h        |    16 +
 .../strategy/generic/GrindingStrategy.cpp          |    20 +
 .../playerbot/strategy/generic/GrindingStrategy.h  |    20 +
 .../playerbot/strategy/generic/GuardStrategy.cpp   |    16 +
 .../playerbot/strategy/generic/GuardStrategy.h     |    19 +
 .../playerbot/strategy/generic/KiteStrategy.cpp    |    16 +
 .../playerbot/strategy/generic/KiteStrategy.h      |    15 +
 .../strategy/generic/LootNonCombatStrategy.cpp     |    29 +
 .../strategy/generic/LootNonCombatStrategy.h       |    24 +
 .../strategy/generic/MeleeCombatStrategy.cpp       |    23 +
 .../strategy/generic/MeleeCombatStrategy.h         |    16 +
 .../strategy/generic/MoveRandomStrategy.cpp        |    13 +
 .../strategy/generic/MoveRandomStrategy.h          |    16 +
 .../strategy/generic/NonCombatStrategy.cpp         |    28 +
 .../playerbot/strategy/generic/NonCombatStrategy.h |    21 +
 .../strategy/generic/PassTroughStrategy.h          |    26 +
 .../playerbot/strategy/generic/PassiveStrategy.cpp |    13 +
 .../playerbot/strategy/generic/PassiveStrategy.h   |    16 +
 .../playerbot/strategy/generic/PullStrategy.cpp    |    52 +
 .../playerbot/strategy/generic/PullStrategy.h      |    24 +
 .../playerbot/strategy/generic/QuestStrategies.cpp |    69 +
 .../playerbot/strategy/generic/QuestStrategies.h   |    34 +
 .../playerbot/strategy/generic/RacialsStrategy.cpp |    39 +
 .../playerbot/strategy/generic/RacialsStrategy.h   |    15 +
 .../strategy/generic/RangedCombatStrategy.cpp      |    15 +
 .../strategy/generic/RangedCombatStrategy.h        |    15 +
 .../playerbot/strategy/generic/RunawayStrategy.cpp |    18 +
 .../playerbot/strategy/generic/RunawayStrategy.h   |    16 +
 .../playerbot/strategy/generic/StayStrategy.cpp    |    11 +
 .../playerbot/strategy/generic/StayStrategy.h      |    14 +
 .../playerbot/strategy/generic/TankAoeStrategy.cpp |    12 +
 .../playerbot/strategy/generic/TankAoeStrategy.h   |    18 +
 .../strategy/generic/TankAssistStrategy.cpp        |    13 +
 .../strategy/generic/TankAssistStrategy.h          |    17 +
 .../strategy/generic/TellTargetStrategy.cpp        |    13 +
 .../strategy/generic/TellTargetStrategy.h          |    16 +
 .../playerbot/strategy/generic/ThreatStrategy.cpp  |    32 +
 .../playerbot/strategy/generic/ThreatStrategy.h    |    25 +
 .../playerbot/strategy/generic/UseFoodStrategy.cpp |    18 +
 .../playerbot/strategy/generic/UseFoodStrategy.h   |    15 +
 .../strategy/generic/UsePotionsStrategy.cpp        |    18 +
 .../strategy/generic/UsePotionsStrategy.h          |    15 +
 .../generic/WorldPacketHandlerStrategy.cpp         |   106 +
 .../strategy/generic/WorldPacketHandlerStrategy.h  |    25 +
 .../strategy/hunter/DpsHunterStrategy.cpp          |   118 +
 .../playerbot/strategy/hunter/DpsHunterStrategy.h  |    39 +
 .../hunter/GenericHunterNonCombatStrategy.cpp      |    58 +
 .../hunter/GenericHunterNonCombatStrategy.h        |    17 +
 .../strategy/hunter/GenericHunterStrategy.cpp      |    66 +
 .../strategy/hunter/GenericHunterStrategy.h        |    20 +
 .../playerbot/strategy/hunter/HunterActions.cpp    |    26 +
 .../playerbot/strategy/hunter/HunterActions.h      |   154 +
 .../strategy/hunter/HunterAiObjectContext.cpp      |   191 +
 .../strategy/hunter/HunterAiObjectContext.h        |    12 +
 .../strategy/hunter/HunterBuffStrategies.cpp       |    35 +
 .../strategy/hunter/HunterBuffStrategies.h         |    47 +
 .../strategy/hunter/HunterMultipliers.cpp          |     5 +
 .../playerbot/strategy/hunter/HunterMultipliers.h  |     6 +
 .../playerbot/strategy/hunter/HunterTriggers.cpp   |    29 +
 .../playerbot/strategy/hunter/HunterTriggers.h     |    86 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.cpp |    64 +
 .../playerbot/strategy/mage/ArcaneMageStrategy.h   |    18 +
 .../playerbot/strategy/mage/FireMageStrategy.cpp   |    44 +
 .../playerbot/strategy/mage/FireMageStrategy.h     |    28 +
 .../playerbot/strategy/mage/FrostMageStrategy.cpp  |    32 +
 .../playerbot/strategy/mage/FrostMageStrategy.h    |    28 +
 .../strategy/mage/GenericMageNonCombatStrategy.cpp |    87 +
 .../strategy/mage/GenericMageNonCombatStrategy.h   |    37 +
 .../strategy/mage/GenericMageStrategy.cpp          |   137 +
 .../playerbot/strategy/mage/GenericMageStrategy.h  |    17 +
 .../playerbot/strategy/mage/MageActions.cpp        |    10 +
 src/plugins/playerbot/strategy/mage/MageActions.h  |   205 +
 .../strategy/mage/MageAiObjectContext.cpp          |   221 +
 .../playerbot/strategy/mage/MageAiObjectContext.h  |    12 +
 .../playerbot/strategy/mage/MageMultipliers.cpp    |     6 +
 .../playerbot/strategy/mage/MageMultipliers.h      |     6 +
 .../playerbot/strategy/mage/MageTriggers.cpp       |    15 +
 src/plugins/playerbot/strategy/mage/MageTriggers.h |    92 +
 .../strategy/paladin/DpsPaladinStrategy.cpp        |    83 +
 .../strategy/paladin/DpsPaladinStrategy.h          |    18 +
 .../paladin/GenericPaladinNonCombatStrategy.cpp    |    65 +
 .../paladin/GenericPaladinNonCombatStrategy.h      |    16 +
 .../strategy/paladin/GenericPaladinStrategy.cpp    |    77 +
 .../strategy/paladin/GenericPaladinStrategy.h      |    18 +
 .../GenericPaladinStrategyActionNodeFactory.h      |   142 +
 .../playerbot/strategy/paladin/PaladinActions.cpp  |     6 +
 .../playerbot/strategy/paladin/PaladinActions.h    |   365 +
 .../strategy/paladin/PaladinAiObjectContext.cpp    |   279 +
 .../strategy/paladin/PaladinAiObjectContext.h      |    12 +
 .../strategy/paladin/PaladinBuffStrategies.cpp     |    72 +
 .../strategy/paladin/PaladinBuffStrategies.h       |    86 +
 .../strategy/paladin/PaladinMultipliers.cpp        |     6 +
 .../strategy/paladin/PaladinMultipliers.h          |     6 +
 .../playerbot/strategy/paladin/PaladinTriggers.cpp |    23 +
 .../playerbot/strategy/paladin/PaladinTriggers.h   |   114 +
 .../strategy/paladin/TankPaladinStrategy.cpp       |    70 +
 .../strategy/paladin/TankPaladinStrategy.h         |    18 +
 .../strategy/priest/GenericPriestStrategy.cpp      |    67 +
 .../strategy/priest/GenericPriestStrategy.h        |    17 +
 .../GenericPriestStrategyActionNodeFactory.h       |   173 +
 .../strategy/priest/HealPriestStrategy.cpp         |    36 +
 .../playerbot/strategy/priest/HealPriestStrategy.h |    18 +
 .../strategy/priest/HolyPriestStrategy.cpp         |    46 +
 .../playerbot/strategy/priest/HolyPriestStrategy.h |    18 +
 .../playerbot/strategy/priest/PriestActions.cpp    |    17 +
 .../playerbot/strategy/priest/PriestActions.h      |   246 +
 .../strategy/priest/PriestAiObjectContext.cpp      |   217 +
 .../strategy/priest/PriestAiObjectContext.h        |    12 +
 .../strategy/priest/PriestMultipliers.cpp          |     6 +
 .../playerbot/strategy/priest/PriestMultipliers.h  |     6 +
 .../strategy/priest/PriestNonCombatStrategy.cpp    |    82 +
 .../strategy/priest/PriestNonCombatStrategy.h      |    17 +
 .../PriestNonCombatStrategyActionNodeFactory.h     |   126 +
 .../playerbot/strategy/priest/PriestTriggers.cpp   |     7 +
 .../playerbot/strategy/priest/PriestTriggers.h     |    54 +
 .../strategy/priest/ShadowPriestStrategy.cpp       |    60 +
 .../strategy/priest/ShadowPriestStrategy.h         |    38 +
 .../priest/ShadowPriestStrategyActionNodeFactory.h |    37 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.cpp  |   110 +
 .../playerbot/strategy/rogue/DpsRogueStrategy.h    |    18 +
 .../rogue/GenericRogueNonCombatStrategy.cpp        |    14 +
 .../strategy/rogue/GenericRogueNonCombatStrategy.h |    16 +
 .../playerbot/strategy/rogue/RogueActions.cpp      |     5 +
 .../playerbot/strategy/rogue/RogueActions.h        |    82 +
 .../strategy/rogue/RogueAiObjectContext.cpp        |   119 +
 .../strategy/rogue/RogueAiObjectContext.h          |    12 +
 .../playerbot/strategy/rogue/RogueComboActions.h   |    45 +
 .../strategy/rogue/RogueFinishingActions.h         |    35 +
 .../playerbot/strategy/rogue/RogueMultipliers.cpp  |     6 +
 .../playerbot/strategy/rogue/RogueMultipliers.h    |     6 +
 .../playerbot/strategy/rogue/RogueOpeningActions.h |    24 +
 .../playerbot/strategy/rogue/RogueTriggers.cpp     |     7 +
 .../playerbot/strategy/rogue/RogueTriggers.h       |    36 +
 .../strategy/shaman/CasterShamanStrategy.cpp       |    75 +
 .../strategy/shaman/CasterShamanStrategy.h         |    29 +
 .../strategy/shaman/GenericShamanStrategy.cpp      |   159 +
 .../strategy/shaman/GenericShamanStrategy.h        |    39 +
 .../strategy/shaman/HealShamanStrategy.cpp         |    82 +
 .../playerbot/strategy/shaman/HealShamanStrategy.h |    17 +
 .../strategy/shaman/MeleeShamanStrategy.cpp        |    93 +
 .../strategy/shaman/MeleeShamanStrategy.h          |    28 +
 .../playerbot/strategy/shaman/ShamanActions.cpp    |     6 +
 .../playerbot/strategy/shaman/ShamanActions.h      |   304 +
 .../strategy/shaman/ShamanAiObjectContext.cpp      |   268 +
 .../strategy/shaman/ShamanAiObjectContext.h        |    12 +
 .../strategy/shaman/ShamanMultipliers.cpp          |     6 +
 .../playerbot/strategy/shaman/ShamanMultipliers.h  |     6 +
 .../strategy/shaman/ShamanNonCombatStrategy.cpp    |    49 +
 .../strategy/shaman/ShamanNonCombatStrategy.h      |    19 +
 .../playerbot/strategy/shaman/ShamanTriggers.cpp   |    38 +
 .../playerbot/strategy/shaman/ShamanTriggers.h     |   197 +
 .../strategy/shaman/TotemsShamanStrategy.cpp       |    31 +
 .../strategy/shaman/TotemsShamanStrategy.h         |    17 +
 .../strategy/triggers/ChatCommandTrigger.h         |    36 +
 .../strategy/triggers/ChatTriggerContext.h         |   140 +
 .../playerbot/strategy/triggers/CureTriggers.cpp   |    17 +
 .../playerbot/strategy/triggers/CureTriggers.h     |    35 +
 .../strategy/triggers/GenericTriggers.cpp          |   242 +
 .../playerbot/strategy/triggers/GenericTriggers.h  |   540 +
 .../playerbot/strategy/triggers/HealthTriggers.cpp |    26 +
 .../playerbot/strategy/triggers/HealthTriggers.h   |   139 +
 .../playerbot/strategy/triggers/LfgTriggers.h      |    17 +
 .../playerbot/strategy/triggers/LootTriggers.cpp   |    20 +
 .../playerbot/strategy/triggers/LootTriggers.h     |    30 +
 .../playerbot/strategy/triggers/RangeTriggers.h    |    81 +
 .../playerbot/strategy/triggers/TriggerContext.h   |   158 +
 .../strategy/triggers/WithinAreaTrigger.h          |    76 +
 .../strategy/triggers/WorldPacketTrigger.h         |    36 +
 .../strategy/triggers/WorldPacketTriggerContext.h  |    85 +
 .../strategy/values/AlwaysLootListValue.h          |    14 +
 .../playerbot/strategy/values/AoeHealValues.cpp    |    37 +
 .../playerbot/strategy/values/AoeHealValues.h      |    14 +
 .../strategy/values/AttackerCountValues.cpp        |   107 +
 .../strategy/values/AttackerCountValues.h          |    59 +
 .../values/AttackerWithoutAuraTargetValue.cpp      |    26 +
 .../values/AttackerWithoutAuraTargetValue.h        |    15 +
 .../playerbot/strategy/values/AttackersValue.cpp   |    94 +
 .../playerbot/strategy/values/AttackersValue.h     |    20 +
 .../playerbot/strategy/values/AvailableLootValue.h |    40 +
 .../playerbot/strategy/values/CcTargetValue.cpp    |    88 +
 .../playerbot/strategy/values/CcTargetValue.h      |    16 +
 src/plugins/playerbot/strategy/values/ChatValue.h  |    11 +
 .../strategy/values/CurrentCcTargetValue.cpp       |    31 +
 .../strategy/values/CurrentCcTargetValue.h         |    16 +
 .../strategy/values/CurrentTargetValue.cpp         |    22 +
 .../playerbot/strategy/values/CurrentTargetValue.h |    17 +
 .../playerbot/strategy/values/DistanceValue.h      |    35 +
 .../playerbot/strategy/values/DpsTargetValue.cpp   |    45 +
 .../playerbot/strategy/values/DpsTargetValue.h     |    16 +
 .../playerbot/strategy/values/DuelTargetValue.cpp  |    10 +
 .../playerbot/strategy/values/DuelTargetValue.h    |    15 +
 .../strategy/values/EnemyHealerTargetValue.cpp     |    36 +
 .../strategy/values/EnemyHealerTargetValue.h       |    15 +
 .../playerbot/strategy/values/EnemyPlayerValue.cpp |    34 +
 .../playerbot/strategy/values/EnemyPlayerValue.h   |    15 +
 .../playerbot/strategy/values/Formations.cpp       |   346 +
 src/plugins/playerbot/strategy/values/Formations.h |    52 +
 .../playerbot/strategy/values/GrindTargetValue.cpp |   126 +
 .../playerbot/strategy/values/GrindTargetValue.h   |    20 +
 .../strategy/values/HasAvailableLootValue.h        |    20 +
 .../playerbot/strategy/values/HasTotemValue.h      |    34 +
 .../strategy/values/InvalidTargetValue.cpp         |    26 +
 .../playerbot/strategy/values/InvalidTargetValue.h |    14 +
 .../playerbot/strategy/values/IsBehindValue.h      |    25 +
 .../playerbot/strategy/values/IsFacingValue.h      |    20 +
 .../playerbot/strategy/values/IsMovingValue.h      |    42 +
 .../playerbot/strategy/values/ItemCountValue.cpp   |    37 +
 .../playerbot/strategy/values/ItemCountValue.h     |    35 +
 .../strategy/values/ItemForSpellValue.cpp          |    70 +
 .../playerbot/strategy/values/ItemForSpellValue.h  |    20 +
 .../playerbot/strategy/values/ItemUsageValue.cpp   |   146 +
 .../playerbot/strategy/values/ItemUsageValue.h     |    28 +
 .../playerbot/strategy/values/LastMovementValue.h  |    61 +
 .../strategy/values/LastSpellCastTimeValue.h       |    11 +
 .../playerbot/strategy/values/LastSpellCastValue.h |    39 +
 .../strategy/values/LeastHpTargetValue.cpp         |    33 +
 .../playerbot/strategy/values/LeastHpTargetValue.h |    15 +
 src/plugins/playerbot/strategy/values/LfgValues.h  |    12 +
 .../playerbot/strategy/values/LineTargetValue.cpp  |    33 +
 .../playerbot/strategy/values/LineTargetValue.h    |    14 +
 .../playerbot/strategy/values/LogLevelValue.h      |    12 +
 .../playerbot/strategy/values/LootStrategyValue.h  |    11 +
 .../playerbot/strategy/values/ManaSaveLevelValue.h |    11 +
 .../playerbot/strategy/values/MasterTargetValue.h  |    13 +
 .../playerbot/strategy/values/NearestAdsValue.cpp  |    11 +
 .../playerbot/strategy/values/NearestAdsValue.h    |    18 +
 .../strategy/values/NearestCorpsesValue.cpp        |    36 +
 .../strategy/values/NearestCorpsesValue.h          |    19 +
 .../strategy/values/NearestGameObjects.cpp         |    47 +
 .../playerbot/strategy/values/NearestGameObjects.h |    19 +
 .../playerbot/strategy/values/NearestNpcsValue.cpp |    23 +
 .../playerbot/strategy/values/NearestNpcsValue.h   |    18 +
 .../playerbot/strategy/values/NearestUnitsValue.h  |    36 +
 .../strategy/values/PartyMemberToDispel.cpp        |    37 +
 .../strategy/values/PartyMemberToDispel.h          |    16 +
 .../strategy/values/PartyMemberToHeal.cpp          |    60 +
 .../playerbot/strategy/values/PartyMemberToHeal.h  |    17 +
 .../strategy/values/PartyMemberToResurrect.cpp     |    44 +
 .../strategy/values/PartyMemberToResurrect.h       |    16 +
 .../playerbot/strategy/values/PartyMemberValue.cpp |   111 +
 .../playerbot/strategy/values/PartyMemberValue.h   |    31 +
 .../values/PartyMemberWithoutAuraValue.cpp         |    35 +
 .../strategy/values/PartyMemberWithoutAuraValue.h  |    17 +
 .../playerbot/strategy/values/PetTargetValue.h     |    13 +
 .../playerbot/strategy/values/PositionValue.cpp    |    10 +
 .../playerbot/strategy/values/PositionValue.h      |    26 +
 .../strategy/values/PossibleTargetsValue.cpp       |    23 +
 .../strategy/values/PossibleTargetsValue.h         |    19 +
 .../playerbot/strategy/values/RtiTargetValue.h     |    51 +
 src/plugins/playerbot/strategy/values/RtiValue.cpp |    36 +
 src/plugins/playerbot/strategy/values/RtiValue.h   |    11 +
 .../playerbot/strategy/values/SelfTargetValue.h    |    13 +
 .../strategy/values/SpellCastUsefulValue.cpp       |    44 +
 .../strategy/values/SpellCastUsefulValue.h         |    17 +
 .../playerbot/strategy/values/SpellIdValue.cpp     |    90 +
 .../playerbot/strategy/values/SpellIdValue.h       |    17 +
 .../playerbot/strategy/values/StatsValues.cpp      |   111 +
 .../playerbot/strategy/values/StatsValues.h        |   133 +
 .../playerbot/strategy/values/TankTargetValue.cpp  |    47 +
 .../playerbot/strategy/values/TankTargetValue.h    |    16 +
 .../playerbot/strategy/values/TargetValue.cpp      |    54 +
 .../playerbot/strategy/values/TargetValue.h        |    39 +
 .../playerbot/strategy/values/ThreatValues.cpp     |    62 +
 .../playerbot/strategy/values/ThreatValues.h       |    17 +
 .../playerbot/strategy/values/ValueContext.h       |   225 +
 .../playerbot/strategy/values/formations/Arrow.cpp |   162 +
 .../playerbot/strategy/values/formations/Arrow.h   |   109 +
 .../strategy/warlock/DpsWarlockStrategy.cpp        |    76 +
 .../strategy/warlock/DpsWarlockStrategy.h          |    39 +
 .../warlock/GenericWarlockNonCombatStrategy.cpp    |    65 +
 .../warlock/GenericWarlockNonCombatStrategy.h      |    16 +
 .../strategy/warlock/GenericWarlockStrategy.cpp    |    74 +
 .../strategy/warlock/GenericWarlockStrategy.h      |    18 +
 .../strategy/warlock/TankWarlockStrategy.cpp       |    51 +
 .../strategy/warlock/TankWarlockStrategy.h         |    17 +
 .../playerbot/strategy/warlock/WarlockActions.cpp  |     5 +
 .../playerbot/strategy/warlock/WarlockActions.h    |   176 +
 .../strategy/warlock/WarlockAiObjectContext.cpp    |   183 +
 .../strategy/warlock/WarlockAiObjectContext.h      |    12 +
 .../strategy/warlock/WarlockMultipliers.cpp        |     6 +
 .../strategy/warlock/WarlockMultipliers.h          |     6 +
 .../playerbot/strategy/warlock/WarlockTriggers.cpp |    19 +
 .../playerbot/strategy/warlock/WarlockTriggers.h   |    81 +
 .../strategy/warrior/DpsWarriorStrategy.cpp        |   130 +
 .../strategy/warrior/DpsWarriorStrategy.h          |    28 +
 .../warrior/GenericWarriorNonCombatStrategy.cpp    |     7 +
 .../warrior/GenericWarriorNonCombatStrategy.h      |    13 +
 .../strategy/warrior/GenericWarriorStrategy.cpp    |    73 +
 .../strategy/warrior/GenericWarriorStrategy.h      |    19 +
 .../strategy/warrior/TankWarriorStrategy.cpp       |   126 +
 .../strategy/warrior/TankWarriorStrategy.h         |    18 +
 .../playerbot/strategy/warrior/WarriorActions.cpp  |    30 +
 .../playerbot/strategy/warrior/WarriorActions.h    |   210 +
 .../strategy/warrior/WarriorAiObjectContext.cpp    |   192 +
 .../strategy/warrior/WarriorAiObjectContext.h      |    12 +
 .../strategy/warrior/WarriorMultipliers.cpp        |     6 +
 .../strategy/warrior/WarriorMultipliers.h          |     6 +
 .../playerbot/strategy/warrior/WarriorTriggers.cpp |     7 +
 .../playerbot/strategy/warrior/WarriorTriggers.h   |    78 +
 src/server/database/Database/DatabaseWorkerPool.h  |     4 +
 src/server/database/Database/Field.h               |     4 +
 .../Database/Implementation/CharacterDatabase.cpp  |    20 +-
 .../Database/Implementation/CharacterDatabase.h    |    15 +-
 .../Database/Implementation/WorldDatabase.cpp      |     5 +
 .../Database/Implementation/WorldDatabase.h        |     5 +
 src/server/database/Database/MySQLConnection.cpp   |     4 +
 src/server/database/Database/QueryResult.h         |     4 +
 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp    |   121 +
 src/server/game/AI/NpcBots/bot_Events.h            |   133 +
 src/server/game/AI/NpcBots/bot_GridNotifiers.h     |   724 ++
 src/server/game/AI/NpcBots/bot_ai.cpp              |  8125 ++++++++++++++
 src/server/game/AI/NpcBots/bot_ai.h                |   908 ++
 src/server/game/AI/NpcBots/bot_bm_ai.cpp           |   968 ++
 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp |  1622 +++
 src/server/game/AI/NpcBots/bot_druid_ai.cpp        |  1389 +++
 src/server/game/AI/NpcBots/bot_hunter_ai.cpp       |  1086 ++
 src/server/game/AI/NpcBots/bot_mage_ai.cpp         |   910 ++
 src/server/game/AI/NpcBots/bot_paladin_ai.cpp      |  1173 ++
 src/server/game/AI/NpcBots/bot_priest_ai.cpp       |  1066 ++
 src/server/game/AI/NpcBots/bot_rogue_ai.cpp        |   828 ++
 src/server/game/AI/NpcBots/bot_shaman_ai.cpp       |  1340 +++
 src/server/game/AI/NpcBots/bot_warlock_ai.cpp      |   519 +
 src/server/game/AI/NpcBots/bot_warrior_ai.cpp      |  1915 ++++
 src/server/game/AI/NpcBots/botcommands.cpp         |   934 ++
 src/server/game/AI/NpcBots/botmgr.cpp              |   841 ++
 src/server/game/AI/NpcBots/botmgr.h                |   110 +
 src/server/game/AuctionHouse/AuctionHouseMgr.cpp   |     8 +
 src/server/game/CMakeLists.txt                     |     2 +
 src/server/game/Chat/Chat.cpp                      |     3 +-
 src/server/game/DungeonFinding/LFGMgr.cpp          |   159 +
 src/server/game/DungeonFinding/LFGQueue.cpp        |    19 +
 src/server/game/Entities/Creature/Creature.cpp     |   465 +
 src/server/game/Entities/Creature/Creature.h       |    85 +-
 .../game/Entities/Creature/TemporarySummon.cpp     |    10 +
 src/server/game/Entities/Object/Object.cpp         |    16 +
 src/server/game/Entities/Player/Player.cpp         |   144 +-
 src/server/game/Entities/Player/Player.h           |    47 +-
 src/server/game/Entities/Totem/Totem.cpp           |     7 +
 src/server/game/Entities/Unit/StatSystem.cpp       |     4 +
 src/server/game/Entities/Unit/Unit.cpp             |   565 +
 src/server/game/Entities/Unit/Unit.h               |    12 +
 src/server/game/Globals/ObjectMgr.cpp              |    76 +
 src/server/game/Globals/ObjectMgr.h                |    20 +
 src/server/game/Groups/Group.cpp                   |    22 +
 src/server/game/Groups/Group.h                     |     8 +
 src/server/game/Handlers/CharacterHandler.cpp      |    81 +
 src/server/game/Handlers/ChatHandler.cpp           |    87 +-
 src/server/game/Handlers/SpellHandler.cpp          |    30 +
 src/server/game/Maps/Map.cpp                       |    30 +-
 src/server/game/Maps/MapManager.cpp                |    80 +
 src/server/game/Movement/MotionMaster.cpp          |    14 +
 src/server/game/OutdoorPvP/OutdoorPvP.cpp          |    17 +
 src/server/game/Scripting/ScriptLoader.cpp         |    34 +-
 src/server/game/Server/WorldSession.cpp            |    46 +-
 src/server/game/Server/WorldSession.h              |     7 +-
 src/server/game/Spells/Spell.cpp                   |    20 +
 src/server/game/Spells/SpellInfo.cpp               |     5 +
 src/server/game/World/World.cpp                    |    32 +-
 src/server/game/World/World.h                      |     1 +
 src/server/scripts/CMakeLists.txt                  |     1 +
 src/server/scripts/Commands/cs_ahbot.cpp           |     4 +
 src/server/scripts/Commands/cs_misc.cpp            |     9 +
 src/server/scripts/Commands/cs_npc.cpp             |   103 +
 src/server/scripts/Spells/spell_paladin.cpp        |    40 +
 src/server/scripts/Spells/spell_priest.cpp         |     4 +
 src/server/worldserver/CMakeLists.txt              |     1 +
 src/server/worldserver/worldserver.conf.dist       |   138 +-
 658 files changed, 79426 insertions(+), 25 deletions(-)
 create mode 100644 sql/TrinityCore-Patches/Bots/character_lordpsyanbots.sql
 create mode 100644 sql/TrinityCore-Patches/Bots/world_lordpsyanbots.sql
 create mode 100644 src/plugins/CMakeLists.txt
 create mode 100644 src/plugins/ahbot/AhBot.cpp
 create mode 100644 src/plugins/ahbot/AhBot.h
 create mode 100644 src/plugins/ahbot/AhBotConfig.cpp
 create mode 100644 src/plugins/ahbot/AhBotConfig.h
 create mode 100644 src/plugins/ahbot/Category.cpp
 create mode 100644 src/plugins/ahbot/Category.h
 create mode 100644 src/plugins/ahbot/ConsumableCategory.cpp
 create mode 100644 src/plugins/ahbot/ConsumableCategory.h
 create mode 100644 src/plugins/ahbot/ItemBag.cpp
 create mode 100644 src/plugins/ahbot/ItemBag.h
 create mode 100644 src/plugins/ahbot/PricingStrategy.cpp
 create mode 100644 src/plugins/ahbot/PricingStrategy.h
 create mode 100644 src/plugins/ahbot/TradeCategory.cpp
 create mode 100644 src/plugins/ahbot/TradeCategory.h
 create mode 100644 src/plugins/ahbot/ahbot.conf.dist.in
 create mode 100644 src/plugins/pch/pch.cpp
 create mode 100644 src/plugins/pch/pch.h
 create mode 100644 src/plugins/pchdef.h
 create mode 100644 src/plugins/playerbot/AiFactory.cpp
 create mode 100644 src/plugins/playerbot/AiFactory.h
 create mode 100644 src/plugins/playerbot/ChatFilter.cpp
 create mode 100644 src/plugins/playerbot/ChatFilter.h
 create mode 100644 src/plugins/playerbot/ChatHelper.cpp
 create mode 100644 src/plugins/playerbot/ChatHelper.h
 create mode 100644 src/plugins/playerbot/FleeManager.cpp
 create mode 100644 src/plugins/playerbot/FleeManager.h
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.cpp
 create mode 100644 src/plugins/playerbot/GuildTaskMgr.h
 create mode 100644 src/plugins/playerbot/Helpers.cpp
 create mode 100644 src/plugins/playerbot/LazyCalculatedValue.h
 create mode 100644 src/plugins/playerbot/LootObjectStack.cpp
 create mode 100644 src/plugins/playerbot/LootObjectStack.h
 create mode 100644 src/plugins/playerbot/PlayerbotAI.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAI.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIAware.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIBase.h
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotAIConfig.h
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotCommandServer.h
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.cpp
 create mode 100644 src/plugins/playerbot/PlayerbotSecurity.h
 create mode 100644 src/plugins/playerbot/RandomItemMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomItemMgr.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotFactory.h
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.cpp
 create mode 100644 src/plugins/playerbot/RandomPlayerbotMgr.h
 create mode 100644 src/plugins/playerbot/aiplayerbot.conf.dist.in
 create mode 100644 src/plugins/playerbot/playerbot.h
 create mode 100644 src/plugins/playerbot/playerbotDefs.h
 create mode 100644 src/plugins/playerbot/strategy/Action.cpp
 create mode 100644 src/plugins/playerbot/strategy/Action.h
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.cpp
 create mode 100644 src/plugins/playerbot/strategy/ActionBasket.h
 create mode 100644 src/plugins/playerbot/strategy/AiObject.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObject.h
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/AiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/Engine.cpp
 create mode 100644 src/plugins/playerbot/strategy/Engine.h
 create mode 100644 src/plugins/playerbot/strategy/Event.cpp
 create mode 100644 src/plugins/playerbot/strategy/Event.h
 create mode 100644 src/plugins/playerbot/strategy/ExternalEventHelper.h
 create mode 100644 src/plugins/playerbot/strategy/ItemVisitors.h
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/Multiplier.h
 create mode 100644 src/plugins/playerbot/strategy/NamedObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.cpp
 create mode 100644 src/plugins/playerbot/strategy/PassiveMultiplier.h
 create mode 100644 src/plugins/playerbot/strategy/Queue.cpp
 create mode 100644 src/plugins/playerbot/strategy/Queue.h
 create mode 100644 src/plugins/playerbot/strategy/Strategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/Strategy.h
 create mode 100644 src/plugins/playerbot/strategy/StrategyContext.h
 create mode 100644 src/plugins/playerbot/strategy/Trigger.cpp
 create mode 100644 src/plugins/playerbot/strategy/Trigger.h
 create mode 100644 src/plugins/playerbot/strategy/Value.cpp
 create mode 100644 src/plugins/playerbot/strategy/Value.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AddLootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/AttackAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuffAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/BuyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeChatAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMailAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DestroyItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/DropQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EmoteAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/EquipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/FollowActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GenericSpellActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GossipHelloAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/GuildBankAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/HelpAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LfgActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListQuestsActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ListSpellsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LogLevelAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootRollAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/LootStrategyAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/MovementActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/NonCombatActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/PositionAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QueryQuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/QuestAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReachTargetActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RepairAllAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ResetAiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/RewardAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/RtiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SaveManaAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SellAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SetHomeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StatsAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/StayActions.h
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TaxiAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TeleportAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellItemCountAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellLosAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellMasterAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellReputationAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TellTargetAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TradeStatusAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/TrainerAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UnequipAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseItemAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.cpp
 create mode 100644 src/plugins/playerbot/strategy/actions/WhoAction.h
 create mode 100644 src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidBearActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidCatActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/DruidTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/CombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DeadStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/DuelStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/EmoteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FleeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GrindingStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/GuardStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/KiteStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PassiveStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/PullStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/QuestStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RacialsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/RunawayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/StayStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/ThreatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterActions.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/hunter/HunterTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FireMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageActions.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/mage/MageTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinActions.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestActions.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/PriestTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueComboActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/rogue/RogueTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanActions.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/CureTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/GenericTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/HealthTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LfgTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/triggers/LootTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/RangeTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/TriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
 create mode 100644 src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AoeHealValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerCountValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/AttackersValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/AvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ChatValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/CurrentTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DistanceValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DpsTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/DuelTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/Formations.h
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/GrindTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/HasTotemValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/InvalidTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsBehindValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsFacingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/IsMovingValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemCountValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemForSpellValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ItemUsageValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastMovementValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LastSpellCastValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LfgValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/LineTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LogLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/LootStrategyValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/MasterTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestAdsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestGameObjects.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/NearestNpcsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/NearestUnitsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PetTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PositionValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/RtiValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SelfTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/SpellIdValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/StatsValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TankTargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/TargetValue.h
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/ThreatValues.h
 create mode 100644 src/plugins/playerbot/strategy/values/ValueContext.h
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.cpp
 create mode 100644 src/plugins/playerbot/strategy/values/formations/Arrow.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockActions.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorActions.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
 create mode 100644 src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
 create mode 100644 src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_Events.h
 create mode 100644 src/server/game/AI/NpcBots/bot_GridNotifiers.h
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_ai.h
 create mode 100644 src/server/game/AI/NpcBots/bot_bm_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_druid_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_hunter_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_mage_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_paladin_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_priest_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_rogue_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_shaman_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warlock_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/bot_warrior_ai.cpp
 create mode 100644 src/server/game/AI/NpcBots/botcommands.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.cpp
 create mode 100644 src/server/game/AI/NpcBots/botmgr.h

diff --git a/sql/TrinityCore-Patches/Bots/character_lordpsyanbots.sql b/sql/TrinityCore-Patches/Bots/character_lordpsyanbots.sql
new file mode 100644
index 0000000..1d094dd
--- /dev/null
+++ b/sql/TrinityCore-Patches/Bots/character_lordpsyanbots.sql
@@ -0,0 +1,10771 @@
+DROP TABLE IF EXISTS `characters_npcbot`;
+CREATE TABLE `characters_npcbot` (
+  `entry` int(10) unsigned NOT NULL COMMENT 'creature_template.entry',
+  `owner` int(10) unsigned NOT NULL DEFAULT '0' COMMENT 'characters.guid (lowguid)',
+  `roles` tinyint(3) unsigned NOT NULL COMMENT 'bitmask: tank(1),dps(2),heal(4),ranged(8)',
+  `faction` int(10) unsigned NOT NULL DEFAULT '14',
+  `equipMhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipOhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipRhEx` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHead` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipShoulders` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipChest` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWaist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipLegs` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFeet` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipWrist` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipHands` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBack` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipBody` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipFinger2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket1` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipTrinket2` int(10) unsigned NOT NULL DEFAULT '0',
+  `equipNeck` int(10) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `ai_playerbot_random_bots`;
+
+CREATE TABLE `ai_playerbot_random_bots` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `bot` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `event` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `bot` (`bot`),
+  KEY `event` (`event`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+
+DROP TABLE IF EXISTS `ai_playerbot_guild_tasks`;
+
+CREATE TABLE `ai_playerbot_guild_tasks` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `owner` bigint(20) NOT NULL,
+  `guildid` bigint(20) NOT NULL,
+  `time` bigint(20) NOT NULL,
+  `validIn` bigint(20) DEFAULT NULL,
+  `type` varchar(45) DEFAULT NULL,
+  `value` bigint(20) DEFAULT NULL,
+  `data` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`),
+  KEY `owner` (`owner`),
+  KEY `guildid` (`guildid`),
+  KEY `type` (`type`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `ahbot_history`;
+DROP TABLE IF EXISTS `ahbot_category`;
+DROP TABLE IF EXISTS `ahbot_price`;
+
+CREATE TABLE `ahbot_history` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `buytime` bigint(20) NOT NULL,
+  `item` bigint(20) NOT NULL,
+  `bid` bigint(20) NOT NULL,
+  `buyout` bigint(20) NOT NULL,
+  `won` bigint(20) NOT NULL,
+  `category` varchar(45) DEFAULT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `won` (`won`),
+  KEY `category` (`category`),
+  KEY `auction_house` (`auction_house`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_category` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `category` varchar(45) DEFAULT NULL,
+  `multiplier` decimal(20, 2) NOT NULL,
+  `max_auction_count` bigint(20) NOT NULL,
+  `expire_time` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `helper` (`category`, `multiplier`, `expire_time`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+CREATE TABLE `ahbot_price` (
+  `id` bigint(20) NOT NULL AUTO_INCREMENT,
+  `item` varchar(45) DEFAULT NULL,
+  `price` decimal(20, 2) NOT NULL,
+  `auction_house` bigint(20) NOT NULL,
+  PRIMARY KEY (`id`),
+  KEY `ahbot_price_item` (`item`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `ai_playerbot_guild_names`;
+CREATE TABLE `ai_playerbot_guild_names` (
+  `name_id` MEDIUMINT(8) NOT NULL AUTO_INCREMENT UNIQUE,
+  `name` VARCHAR(24) NOT NULL UNIQUE,
+  PRIMARY KEY (`name_id`)
+) ENGINE=MYISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='PlayerbotAI guild names';
+
+LOCK TABLES `ai_playerbot_guild_names` WRITE;
+INSERT INTO `ai_playerbot_guild_names` VALUES
+(NULL, 'Black Guard'),
+(NULL, 'Abyssal Kingdoms'),
+(NULL, 'Acid Evil'),
+(NULL, 'Addicts Muskateers'),
+(NULL, 'Adventurers War'),
+(NULL, 'Age of Red Water Clan'),
+(NULL, 'Alivso Reason'),
+(NULL, 'All Knights'),
+(NULL, 'Allegiance of the Vile'),
+(NULL, 'Alliance Clan'),
+(NULL, 'Alliance of Defectives'),
+(NULL, 'Alti Legions'),
+(NULL, 'Anarchie Shi'),
+(NULL, 'Anchors of the Nominal'),
+(NULL, 'Ancients of Part Times'),
+(NULL, 'Angelus Gods'),
+(NULL, 'Angry Party'),
+(NULL, 'Apocalyptic Lamont'),
+(NULL, 'Architects of Green'),
+(NULL, 'Army of Black Widows'),
+(NULL, 'Army of Orgrimmar Minds'),
+(NULL, 'Army of Three Horses'),
+(NULL, 'Arrows of Midlight'),
+(NULL, 'Artisans of Best Guild'),
+(NULL, 'Assasins of the Pyrewood'),
+(NULL, 'Assassins Bane'),
+(NULL, 'Avatars of Warsong Stuff'),
+(NULL, 'Axis of the Funky Night'),
+(NULL, 'Azeroth Souls'),
+(NULL, 'Azeroths Rabbits'),
+(NULL, 'Bad Sentinels'),
+(NULL, 'Banana Song'),
+(NULL, 'Band of Tarantula Attack'),
+(NULL, 'Band of the Dark Reveren'),
+(NULL, 'Barcode Praised'),
+(NULL, 'Basher Goats'),
+(NULL, 'Basic Order'),
+(NULL, 'Batman of Banished'),
+(NULL, 'Betrayers of Lucky Child'),
+(NULL, 'Blackwater Committee'),
+(NULL, 'Blades of Lich Kings'),
+(NULL, 'Blades of the Hive'),
+(NULL, 'Blades of the Total'),
+(NULL, 'Bleeding War'),
+(NULL, 'Blessed Lair'),
+(NULL, 'Blizzards of the Iron'),
+(NULL, 'Blood Chaos'),
+(NULL, 'Blood Intrigue'),
+(NULL, 'Blood Samurai'),
+(NULL, 'Bloodlust Good'),
+(NULL, 'Bonds of Reported Ignore'),
+(NULL, 'Booty Cry'),
+(NULL, 'Border Knights'),
+(NULL, 'Bossmans Targaryen'),
+(NULL, 'Braveheart Heaven'),
+(NULL, 'Brotherhood of Twilight'),
+(NULL, 'Bruised Pain'),
+(NULL, 'Burning Control'),
+(NULL, 'Burning Oblivion'),
+(NULL, 'Cabal of Kalimdor'),
+(NULL, 'Cake Crusade'),
+(NULL, 'Call of the Ironforge'),
+(NULL, 'Carebears Thunder'),
+(NULL, 'Carpe Heaven'),
+(NULL, 'Carpe Regiment'),
+(NULL, 'Children of Order'),
+(NULL, 'Children of the Gods'),
+(NULL, 'Circle of Amor E Bobby'),
+(NULL, 'Clan of the Elven Toys'),
+(NULL, 'Clan of the Strike Light'),
+(NULL, 'Coalition of Super Best'),
+(NULL, 'Collective Pimps'),
+(NULL, 'Companions of the Gnome'),
+(NULL, 'Company of the Vibe'),
+(NULL, 'Conclave of the Triad'),
+(NULL, 'Council of Final Demise'),
+(NULL, 'Council of Hard Core Ord'),
+(NULL, 'Craaweh Thrall'),
+(NULL, 'Cradle Scourge'),
+(NULL, 'Crimson Angels'),
+(NULL, 'Crimson Saints'),
+(NULL, 'Crusade of Oh'),
+(NULL, 'Crusaders of Undead'),
+(NULL, 'Cryptic Serenity'),
+(NULL, 'Csa Rigged'),
+(NULL, 'Cult of the Raging Raid'),
+(NULL, 'Dalaran Fair'),
+(NULL, 'Damage Inc'),
+(NULL, 'Dark Alliance'),
+(NULL, 'Dark Azeroth'),
+(NULL, 'Dark Damage'),
+(NULL, 'Dark Resistus'),
+(NULL, 'Dark Samurai'),
+(NULL, 'Dark Turtles'),
+(NULL, 'Darken Mercenaries'),
+(NULL, 'Darkened Malevolence'),
+(NULL, 'Darkness of Sword Coast'),
+(NULL, 'Dawn of Knights Society'),
+(NULL, 'Dawn of Mad Sentry'),
+(NULL, 'Dead Zug'),
+(NULL, 'Death Darkness'),
+(NULL, 'Death Knights'),
+(NULL, 'Deathlike Goods'),
+(NULL, 'Deaths Venoms'),
+(NULL, 'Decree of the Phumpers'),
+(NULL, 'Defenders of Da Raised'),
+(NULL, 'Defenders of Hyuuga Dark'),
+(NULL, 'Defenders of Sacred Harm'),
+(NULL, 'Deths Lords'),
+(NULL, 'Devil Circl'),
+(NULL, 'Devils Klng'),
+(NULL, 'Dharma Hand'),
+(NULL, 'Dharma Thorn'),
+(NULL, 'Dies Ravager'),
+(NULL, 'Disciples of Dead Panda'),
+(NULL, 'Disciples of the Rot'),
+(NULL, 'Doomsday Youth'),
+(NULL, 'Dorcha Knights'),
+(NULL, 'Dots of Dead Skull'),
+(NULL, 'Dragon Arms'),
+(NULL, 'Dragonhawk Revolution'),
+(NULL, 'Dragons Erythnul'),
+(NULL, 'Dragons of the Black'),
+(NULL, 'Drunken Thunder'),
+(NULL, 'Drunks of Matoskan'),
+(NULL, 'Dwarven Rock'),
+(NULL, 'Dynasty of the Emerald'),
+(NULL, 'Eastern Asylum'),
+(NULL, 'Echo Sanctus'),
+(NULL, 'Echoes of the Muphin'),
+(NULL, 'Effreno Death'),
+(NULL, 'Elite Guild'),
+(NULL, 'Elite Legion'),
+(NULL, 'Elite Veritas'),
+(NULL, 'Elunes Meat'),
+(NULL, 'Emerald Men'),
+(NULL, 'Emerald Mjolnir'),
+(NULL, 'Endless Defense'),
+(NULL, 'Enemies of Bleeding'),
+(NULL, 'Enternal Saber'),
+(NULL, 'Evictors of the Returned'),
+(NULL, 'Evil Guard'),
+(NULL, 'Exalted Effect'),
+(NULL, 'Eyes of a Night Elf'),
+(NULL, 'Eyes of the Elton Souls'),
+(NULL, 'Fallen Clan'),
+(NULL, 'Fallen Milk'),
+(NULL, 'Fenrir Seeker'),
+(NULL, 'Final Army'),
+(NULL, 'Flames of Ale Drinkers'),
+(NULL, 'Flames of Antarian Chaos'),
+(NULL, 'Forestt''s Wrath'),
+(NULL, 'Forgotten Within'),
+(NULL, 'From Synergy'),
+(NULL, 'Frozen Oblivion'),
+(NULL, 'Gashlycrumb Rollers'),
+(NULL, 'Giovannitwos Elune'),
+(NULL, 'Glass Meridian'),
+(NULL, 'Gnome Faction'),
+(NULL, 'Gods Gold'),
+(NULL, 'Gods of the Complete'),
+(NULL, 'Gold Catchers'),
+(NULL, 'Golden Legendz'),
+(NULL, 'Golden Souls'),
+(NULL, 'Goldshire Goats'),
+(NULL, 'Good Azeroth'),
+(NULL, 'Gotz Safety'),
+(NULL, 'Grammaton Alliance'),
+(NULL, 'Great Circle'),
+(NULL, 'Guardians of Honor'),
+(NULL, 'Guards of Frostmane'),
+(NULL, 'Guild of La Mano Dragons'),
+(NULL, 'Guild of the Puppet'),
+(NULL, 'Haggles Brigade'),
+(NULL, 'Hammer of the Moral'),
+(NULL, 'Hand of the Iron'),
+(NULL, 'Hands of Far Con Buddies'),
+(NULL, 'Hearts Knights'),
+(NULL, 'Hell Angels'),
+(NULL, 'Hells Thorn'),
+(NULL, 'Holy Darnassus'),
+(NULL, 'Horde Abh'),
+(NULL, 'Horde Dragons'),
+(NULL, 'Horde Leaders'),
+(NULL, 'Horde Squad'),
+(NULL, 'Horde of Omnia'),
+(NULL, 'Horde of Free Brigade'),
+(NULL, 'Horde of Shadow Flush'),
+(NULL, 'Hordes Buccaneers'),
+(NULL, 'Hordes Marauders'),
+(NULL, 'House Crusaders'),
+(NULL, 'Immortality Honor'),
+(NULL, 'Inside Poof'),
+(NULL, 'Iron Boyz'),
+(NULL, 'Iscariot Ginas'),
+(NULL, 'Island Kimchi'),
+(NULL, 'Jenovas Wild'),
+(NULL, 'Kalimdor Darkness'),
+(NULL, 'Keepers of Golden Misery'),
+(NULL, 'Keggers of Alt Hand Aton'),
+(NULL, 'Kill Mafia'),
+(NULL, 'Killer Durotar'),
+(NULL, 'Killer Force'),
+(NULL, 'Kindred Yardies'),
+(NULL, 'Kindred of King Assassin'),
+(NULL, 'Kingdom of the Ordo Crew'),
+(NULL, 'Kings Boys'),
+(NULL, 'Kings Windstorm'),
+(NULL, 'Kings of Blood Knuckle'),
+(NULL, 'Kings of Dol Aegis'),
+(NULL, 'Knight Combat'),
+(NULL, 'Knight of Fuzzy Night'),
+(NULL, 'Knights of Darkspear'),
+(NULL, 'Knights of Heavens Grave'),
+(NULL, 'Knights of Myrmidon Ivxx'),
+(NULL, 'Knights of the Avenging'),
+(NULL, 'Knights of the Ballpeen'),
+(NULL, 'Knights of the Black'),
+(NULL, 'Knights of the Bloodhoof'),
+(NULL, 'Knights of the Sovereign'),
+(NULL, 'Knights of the Storm'),
+(NULL, 'Knights of the Zulian'),
+(NULL, 'Last Ptesanwi'),
+(NULL, 'League of Hate Crew Seek'),
+(NULL, 'Legacy of Ninth Beard'),
+(NULL, 'Legendary Sons'),
+(NULL, 'Legion of Maple Syrup'),
+(NULL, 'Legion of Public Works'),
+(NULL, 'Legion of Three Course'),
+(NULL, 'Legion of United Souls'),
+(NULL, 'Legion of Westfall Gold'),
+(NULL, 'Legion of the Dark'),
+(NULL, 'Legionnaires of Skull'),
+(NULL, 'Les Warriors'),
+(NULL, 'Lifetakers Inc'),
+(NULL, 'Light of Dark Spire'),
+(NULL, 'Light of Jade Renegade'),
+(NULL, 'Liquid Guild'),
+(NULL, 'Lone Side'),
+(NULL, 'Lords of Fallen Blood'),
+(NULL, 'Los Frum'),
+(NULL, 'Lost Boyz'),
+(NULL, 'Lost Squad'),
+(NULL, 'Mad Daggers'),
+(NULL, 'Malice Fatale'),
+(NULL, 'Mandate of Jade'),
+(NULL, 'Marines of the Butt'),
+(NULL, 'Mercenaries of the Death'),
+(NULL, 'Midget Council'),
+(NULL, 'Midgets of Dark Sexy'),
+(NULL, 'Midnight Norrathians'),
+(NULL, 'Midnight Slayer'),
+(NULL, 'Midnight War'),
+(NULL, 'Minions of the Shadow'),
+(NULL, 'Ministry of the Allince'),
+(NULL, 'Mithril Destiny'),
+(NULL, 'Monarchs of Party Crew'),
+(NULL, 'Money Call'),
+(NULL, 'Moonwood Redeye'),
+(NULL, 'Narrow Patrol'),
+(NULL, 'New Clan'),
+(NULL, 'Night Pack'),
+(NULL, 'Nightmare Guild'),
+(NULL, 'Ninja Pledge'),
+(NULL, 'Nocturne of Totally Dead'),
+(NULL, 'Obsidian Fish'),
+(NULL, 'Old Cosa'),
+(NULL, 'One Valor'),
+(NULL, 'Opus Faithful'),
+(NULL, 'Order of Alts oF Fate'),
+(NULL, 'Order of Nagas Bike Hunt'),
+(NULL, 'Order of Omega Wards'),
+(NULL, 'Order of Pink'),
+(NULL, 'Order of Shield Bed'),
+(NULL, 'Order of the Alt Sheep'),
+(NULL, 'Order of the Honor'),
+(NULL, 'Order of the Divine Lord'),
+(NULL, 'Ordo Force'),
+(NULL, 'Orgrimmar Ones'),
+(NULL, 'Out of Lw Downed Wrynn'),
+(NULL, 'Out of Mithril Avengers'),
+(NULL, 'Oxbloods Medivh'),
+(NULL, 'Pally Guard'),
+(NULL, 'Path of the Brain'),
+(NULL, 'Peddlers of the Hidden'),
+(NULL, 'Phantoms of Wicked'),
+(NULL, 'Phoenix Keepers'),
+(NULL, 'Pillowcase Azeroth'),
+(NULL, 'Pillowcase Cats'),
+(NULL, 'Pius Tribe'),
+(NULL, 'Plague of Human Slayer'),
+(NULL, 'Plan Hand'),
+(NULL, 'Power of Tuatha De Blood'),
+(NULL, 'Priest Guild'),
+(NULL, 'Prophets of Fatima War'),
+(NULL, 'Prophets of Outlaw'),
+(NULL, 'Prophets of the Red Mean'),
+(NULL, 'Protectors of Black Hand'),
+(NULL, 'Pure Aequitas'),
+(NULL, 'Question Thrall'),
+(NULL, 'Quintessential Sister'),
+(NULL, 'Rage of Prairie Black'),
+(NULL, 'Rage of the Flame'),
+(NULL, 'Raiders of Candy Heart'),
+(NULL, 'Raiders of the Purple'),
+(NULL, 'Raiders of the Sil'),
+(NULL, 'Ram Runners'),
+(NULL, 'Rangers Vengeance'),
+(NULL, 'Rangers of Interitus'),
+(NULL, 'Raven Clan'),
+(NULL, 'Razzle Guardian'),
+(NULL, 'Reapers of the Shadow'),
+(NULL, 'Reckless Knights'),
+(NULL, 'Red Byam'),
+(NULL, 'Red Death'),
+(NULL, 'Reign of Alliance Task'),
+(NULL, 'Reign of Blazing Frell'),
+(NULL, 'Reign of Pure Conway'),
+(NULL, 'Restoration of Illegal'),
+(NULL, 'Resurrection of Tenui'),
+(NULL, 'Ronin Kalimdor'),
+(NULL, 'Rotting Tears'),
+(NULL, 'Ruins of Dark Azeroth'),
+(NULL, 'Rulers of Devils'),
+(NULL, 'Sacred Parts'),
+(NULL, 'Sacred Society'),
+(NULL, 'Sacrificial Brotherhood'),
+(NULL, 'Sanguine Council'),
+(NULL, 'Sapphic Exiles'),
+(NULL, 'Savage Kalimdor'),
+(NULL, 'Scourge of Eight Inches'),
+(NULL, 'Scourge of Wow Knights'),
+(NULL, 'Scythe Sauce'),
+(NULL, 'Secret Clan'),
+(NULL, 'Seki Council'),
+(NULL, 'Seraph Legends'),
+(NULL, 'Shaded Judgement'),
+(NULL, 'Shadow America'),
+(NULL, 'Shadow Boys'),
+(NULL, 'Shadow Knights'),
+(NULL, 'Shadowed Ghosts'),
+(NULL, 'Shadowed Goat'),
+(NULL, 'Shadows of Cole Trainz'),
+(NULL, 'Shadows of Los Banditos'),
+(NULL, 'Shattered Stormrage'),
+(NULL, 'Silent Night'),
+(NULL, 'Silver Fools'),
+(NULL, 'Silversky Sun'),
+(NULL, 'Sisters of Kalimdor'),
+(NULL, 'Skulled Ironforge'),
+(NULL, 'Slayers of the Primals'),
+(NULL, 'Sleepy Steel'),
+(NULL, 'Soldiers of Azeroth'),
+(NULL, 'Soldiers of Stalker'),
+(NULL, 'Sons of Lambent Virtue'),
+(NULL, 'Sons of the Top Truth'),
+(NULL, 'Soul Wish'),
+(NULL, 'Souls of Elite Gnome'),
+(NULL, 'Spanaway Metalheadz'),
+(NULL, 'Spoony Demise'),
+(NULL, 'Squires of Sacred Tribe'),
+(NULL, 'Stagnant Jesters'),
+(NULL, 'Stars of Gear Farming'),
+(NULL, 'Stupid Crusaders'),
+(NULL, 'Stop Guides'),
+(NULL, 'Storm of the Mope''s'),
+(NULL, 'Stormrage Ferguson'),
+(NULL, 'Stormtroopers of Fatima '),
+(NULL, 'Stormwind Crew'),
+(NULL, 'Straight Caedes'),
+(NULL, 'Stronghold Angels'),
+(NULL, 'Sturgeon Empire'),
+(NULL, 'Survivors of Devil Club'),
+(NULL, 'Sweet Bear'),
+(NULL, 'Sword of Lost Evil'),
+(NULL, 'Tainted Bunnies'),
+(NULL, 'Talon of the Eclectic'),
+(NULL, 'Team Kingdom'),
+(NULL, 'Team United'),
+(NULL, 'Tears of Eternal Kitties'),
+(NULL, 'Tears of Phantom Druids'),
+(NULL, 'Templar of Raid Dodgers'),
+(NULL, 'Templars of Plagueware'),
+(NULL, 'Terra Totem'),
+(NULL, 'Terra War'),
+(NULL, 'Abiem'),
+(NULL, 'Aceofchaos'),
+(NULL, 'Afterlife'),
+(NULL, 'Aggression'),
+(NULL, 'Alliance of Dark'),
+(NULL, 'Altimate'),
+(NULL, 'Ancona Fire'),
+(NULL, 'Apocalypse'),
+(NULL, 'Arcane Monkey'),
+(NULL, 'Army of Spartans'),
+(NULL, 'Avalon'),
+(NULL, 'Avengers of Shining'),
+(NULL, 'Azure Gangstaz'),
+(NULL, 'Battlegnome'),
+(NULL, 'Black Hand Haven'),
+(NULL, 'Blackdraygon'),
+(NULL, 'Blackout'),
+(NULL, 'Blade'),
+(NULL, 'Blades of Caer Eel'),
+(NULL, 'Blades of Onyxia'),
+(NULL, 'Blood Red Violence'),
+(NULL, 'Blood of Red Powers'),
+(NULL, 'Bloodycrusaders'),
+(NULL, 'Blues Azeroth'),
+(NULL, 'Blues Grimfang'),
+(NULL, 'Bluethunder'),
+(NULL, 'Bonds of Arcane'),
+(NULL, 'Brimstone'),
+(NULL, 'Broken Chaos'),
+(NULL, 'Brood of Unknown'),
+(NULL, 'Burning Dog Firewall'),
+(NULL, 'Cabal'),
+(NULL, 'Cake Gankers'),
+(NULL, 'Cannabuddies'),
+(NULL, 'Circle of Shadow'),
+(NULL, 'Clan Blackwatch Few'),
+(NULL, 'Clan Cats'),
+(NULL, 'Clan Knights'),
+(NULL, 'Clean Combinations'),
+(NULL, 'Clean Up Guard'),
+(NULL, 'Council of Dark'),
+(NULL, 'Covenant'),
+(NULL, 'Crimson Guild'),
+(NULL, 'Crimson Marbock'),
+(NULL, 'Crusaders of Horde'),
+(NULL, 'Crusaders of Seksoni'),
+(NULL, 'Cult of Clan Brigade'),
+(NULL, 'Cult of the Pink'),
+(NULL, 'Daggers of the Vile'),
+(NULL, 'Dark'),
+(NULL, 'Dark Dogs'),
+(NULL, 'Dark Pain'),
+(NULL, 'Darkfall'),
+(NULL, 'Darkside Vanguard'),
+(NULL, 'Darkside of Initium'),
+(NULL, 'Daughters of the Elite'),
+(NULL, 'Daytripper'),
+(NULL, 'Deadfriends'),
+(NULL, 'Defiant'),
+(NULL, 'Dont Overwhelming'),
+(NULL, 'Doom Pasta'),
+(NULL, 'Dragon Redeye'),
+(NULL, 'Dragons Flame'),
+(NULL, 'Dreadlords'),
+(NULL, 'Dublainn Crown'),
+(NULL, 'Durban Protecters'),
+(NULL, 'Echoes of Goldshire'),
+(NULL, 'Elit of Dark Elune'),
+(NULL, 'Emissaries of Furiou'),
+(NULL, 'Eternal Chaos'),
+(NULL, 'Eternus'),
+(NULL, 'Exiie'),
+(NULL, 'Expendable Shadow'),
+(NULL, 'Faith of Desert'),
+(NULL, 'Family Misfits'),
+(NULL, 'Fere Darkness'),
+(NULL, 'Final Tears'),
+(NULL, 'Forsaken Boochies'),
+(NULL, 'Gates of the Bloody'),
+(NULL, 'Gnomes Lordaero'),
+(NULL, 'Gods of Blackscar'),
+(NULL, 'Gods of Twilight'),
+(NULL, 'Gold Fighters'),
+(NULL, 'Guardian Thieves'),
+(NULL, 'Guardians of Gnome'),
+(NULL, 'Hands of Redridge'),
+(NULL, 'Hawk'),
+(NULL, 'Hearts Images'),
+(NULL, 'Hellborn Die'),
+(NULL, 'Heroes Plague'),
+(NULL, 'Horde Farmer'),
+(NULL, 'Horde Honor'),
+(NULL, 'Hotpocket'),
+(NULL, 'Ignis Prophecy'),
+(NULL, 'Illuminatie'),
+(NULL, 'Immortal League'),
+(NULL, 'Independant'),
+(NULL, 'Infragilis Legion'),
+(NULL, 'Jag'),
+(NULL, 'Jookmaster'),
+(NULL, 'Kataclysm'),
+(NULL, 'Knight'),
+(NULL, 'Knightelf'),
+(NULL, 'Knights Thorn'),
+(NULL, 'Knights of Gods Fury'),
+(NULL, 'Knights of Lost Peon'),
+(NULL, 'Knights of Mortal'),
+(NULL, 'Knights of Samurai'),
+(NULL, 'Kobra'),
+(NULL, 'Leaders of Evil'),
+(NULL, 'Leaders of Life'),
+(NULL, 'League of Red Knight'),
+(NULL, 'Legacy Meathooks'),
+(NULL, 'Legion of the Blue'),
+(NULL, 'Legion of Death'),
+(NULL, 'Lemmings of Flaming'),
+(NULL, 'Let Blood Gamer'),
+(NULL, 'Light'),
+(NULL, 'Little Hunters'),
+(NULL, 'Lords of Vae Knight'),
+(NULL, 'Mercenaries'),
+(NULL, 'Midieval Vanguard'),
+(NULL, 'Might of Dark Tong'),
+(NULL, 'Mithril Justice'),
+(NULL, 'Mithril Pepsi'),
+(NULL, 'Mjollnir'),
+(NULL, 'Moo Licht'),
+(NULL, 'Morgantis'),
+(NULL, 'Mulletmen'),
+(NULL, 'Necrontyr of Eternal'),
+(NULL, 'Nedrage Kills'),
+(NULL, 'Night'),
+(NULL, 'Nightfall'),
+(NULL, 'Ninja Heroes'),
+(NULL, 'Order of Gold'),
+(NULL, 'Order of Warcraft'),
+(NULL, 'Order of Warsong'),
+(NULL, 'Over Louder'),
+(NULL, 'Overlord'),
+(NULL, 'Pants'),
+(NULL, 'Pie'),
+(NULL, 'Pretectors'),
+(NULL, 'Project Disease'),
+(NULL, 'Psychotics'),
+(NULL, 'Puggers'),
+(NULL, 'Pyreborne'),
+(NULL, 'Queen of Meow'),
+(NULL, 'Red Hood Thunder'),
+(NULL, 'Reign of Uber Enigma'),
+(NULL, 'Resurrection'),
+(NULL, 'Ring of Honor'),
+(NULL, 'Ropetown'),
+(NULL, 'Royal Militia Blanco'),
+(NULL, 'Samurai Banda'),
+(NULL, 'Sanity'),
+(NULL, 'Sauce'),
+(NULL, 'Schoolyard Reapers'),
+(NULL, 'Secrets of Hehog'),
+(NULL, 'Seers'),
+(NULL, 'Servants of Cyclone'),
+(NULL, 'Seven'),
+(NULL, 'Shadow Gate'),
+(NULL, 'Shadow Misfits'),
+(NULL, 'Shadow of Ninja Pain'),
+(NULL, 'Shadowborn'),
+(NULL, 'Shizam'),
+(NULL, 'Shockers'),
+(NULL, 'Shriek of Nightmare'),
+(NULL, 'Silent Grunts'),
+(NULL, 'Silent Legion'),
+(NULL, 'Skunkdesigns'),
+(NULL, 'Sorrow'),
+(NULL, 'Souls of Azeroth Old'),
+(NULL, 'Spazler'),
+(NULL, 'Squirrels'),
+(NULL, 'Stringville'),
+(NULL, 'Stronghold of Reds'),
+(NULL, 'Tha Handlers'),
+(NULL, 'Thieves of Moral'),
+(NULL, 'Thorium Claw'),
+(NULL, 'Thread'),
+(NULL, 'Thule'),
+(NULL, 'Thunderslayers'),
+(NULL, 'True Wow'),
+(NULL, 'Trusted Minions'),
+(NULL, 'Twilight Rangers'),
+(NULL, 'Tyraels Aggression'),
+(NULL, 'Ultimates'),
+(NULL, 'Unforgiven Heresy'),
+(NULL, 'Unholy Bards'),
+(NULL, 'Unsung Efficiency'),
+(NULL, 'Valley of the Demon'),
+(NULL, 'Valor'),
+(NULL, 'Violent Chaos'),
+(NULL, 'Virus Eternal'),
+(NULL, 'War'),
+(NULL, 'Warsong Gnomeregan'),
+(NULL, 'Westcoast'),
+(NULL, 'Wicked'),
+(NULL, 'Will of Chronicles'),
+(NULL, 'Windsword Nightmare'),
+(NULL, 'Wings of Oxy Claw'),
+(NULL, 'Wrath of Elton'),
+(NULL, 'Wut'),
+(NULL, 'Yoricks Assassins'),
+(NULL, 'Zeksonic Thieves'),
+(NULL, 'Theramore Azeroth'),
+(NULL, 'Thirstquencher Chaos'),
+(NULL, 'Thralls Caribous'),
+(NULL, 'Three Alive'),
+(NULL, 'Titans of Blood Sun'),
+(NULL, 'Torvus Dragons'),
+(NULL, 'Tower of the Little'),
+(NULL, 'True Team'),
+(NULL, 'Tul Inc'),
+(NULL, 'Twinks of Cold Club'),
+(NULL, 'Twinks of Hidden Venture'),
+(NULL, 'Ultimate Rules'),
+(NULL, 'Undead Kingdom'),
+(NULL, 'Unforgiven Destiny'),
+(NULL, 'Unguilded War'),
+(NULL, 'Unholy Cats'),
+(NULL, 'Unholy Teeth'),
+(NULL, 'Union of Burning Prz'),
+(NULL, 'Unusual Guard'),
+(NULL, 'Valiant Riderz'),
+(NULL, 'Vanguard Omen'),
+(NULL, 'Vanguard Redeemers'),
+(NULL, 'Vanguard of Teutonic'),
+(NULL, 'Vengeful Mayhem'),
+(NULL, 'Verata Blackflame'),
+(NULL, 'Vicious Renegade'),
+(NULL, 'Vile Dead'),
+(NULL, 'Voodoo Hearth'),
+(NULL, 'War Legion'),
+(NULL, 'Warlockian Tree'),
+(NULL, 'Warlords of Kungfu Army'),
+(NULL, 'Warriors of Happy Death'),
+(NULL, 'Warriors of the Tundra'),
+(NULL, 'Warsong Insanity'),
+(NULL, 'Waste of Grey Death'),
+(NULL, 'Wayfarers of Maple Leaf'),
+(NULL, 'Wayward Agenda'),
+(NULL, 'Web of Forgoten Warfare'),
+(NULL, 'Wet Guard'),
+(NULL, 'Wild Fire'),
+(NULL, 'Will of the Forgotten'),
+(NULL, 'Winds of Steve Irwin'),
+(NULL, 'Wings of Emerald Minions'),
+(NULL, 'Wintermane Good'),
+(NULL, 'Witchhunters of Chaos'),
+(NULL, 'With Sea'),
+(NULL, 'Wrath of the Horde Troop'),
+(NULL, 'Wtf Losers'),
+(NULL, 'Xcalibur of Shogunz Depo'),
+(NULL, 'Xelium Determination');
+
+UNLOCK TABLES;
+
+
+DROP TABLE IF EXISTS `ai_playerbot_names`;
+CREATE TABLE `ai_playerbot_names` (
+  `name_id` mediumint(8) NOT NULL AUTO_INCREMENT UNIQUE,
+  `name` varchar(13) NOT NULL UNIQUE,
+  `gender` tinyint(3) unsigned NOT NULL,
+  `race` smallint(5) unsigned NOT NULL,
+  `class` smallint(5) unsigned NOT NULL,
+  `purpose` int(11) unsigned NOT NULL,
+  `priority` bit(1) NOT NULL,
+  `in_use` bit(1) NOT NULL,
+PRIMARY KEY (`name_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8 ROW_FORMAT=FIXED COMMENT='PlayerbotAI AutoBot names';
+
+
+LOCK TABLES `ai_playerbot_names` WRITE;
+INSERT INTO `ai_playerbot_names` VALUES
+(NULL, 'Cuan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yahaerai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adycrhesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stimeenu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riarroseop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rigraemsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuneso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elmuorie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaohea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Whaaimpiidri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agtyiencra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ketnea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arpraerela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nirier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Youeeso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eongdeathiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stritosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itaifein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Desteoloest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inrodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiesoghaadny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noyoenie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agmaoga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uturoerim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spuicoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acuseflini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erwoulase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyerary', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staheaoejgho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umaintosp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omeqis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seniosomocat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laewaulefi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eshalech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iflae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cauif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rarelmarial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erhoyeroneal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atriupbei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleruficem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leiani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiyb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hamoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shiedfoeraa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erpoudcoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayospavae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xipoteiyse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieniocif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naocoopic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytwoabrise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opcoerical', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okyestraec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okonekpaund', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fastryaneara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaquoyya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Privegais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroiobipu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boisaisaot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaysce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voecy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iulcri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciabatase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etwiace', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethtaegnmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inmuinseoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yonashuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesleeist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayigste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vomeiug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoevi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ersnyla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uplychyevedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otueialfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiimaite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nioreyro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odraemab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibliab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lueid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yngyalmeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineyicaci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroloveiab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kierer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antesadinag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abmuatmour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibnere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyngisym', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Insene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Athcheoirdlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ompsaetpobo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleaemyau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bimoloaanbla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amashuulid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liitiori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oroliliel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piiftap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iorhoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahleluali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilyvione', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nimoawao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teswoenedau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tysha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raosoamen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugruepeke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teulat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cielpruroor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyroichet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeronaesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eckomayii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otearccheto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eulyoflamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raastafo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prorilapoun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocinealon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yisoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alureeicis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iraker', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eisiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jualenefily', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethasiisenxo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogetiyija', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coucreasto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceyrnac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teonierayp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chotelerer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uapra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ydepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liosthe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reineatitle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lochekeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Samiefetuit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ersiuuphaeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usericlao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuaiiack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oioyuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iienneify', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uuarcteyn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olsuraeom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imumutrishi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iigoxaoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaisgi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lusiurho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neayisal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onefnerevi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteyeneaw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Byubiubeco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geaoenis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adamoifona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edwiaban', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meiacyeru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aplyeyalanra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieaninespi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scheeschiero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arkrafliu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aronaah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emerla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rhasemieaci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opaghancoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bleitrieae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osaivocomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anodivli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izaneunbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoctniisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icizsycheh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eumalioo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bunoovane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chiama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imtiob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urefpligruco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erakimze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iangoecayond', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoroboakix', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stoeea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatolisuret', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edetirynaus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Occheyoulro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubainteoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilfreceane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atonorori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adfleledeip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocbeul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Undopheyie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sothete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usrawaanir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroiatbistro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Culilile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odioyusgliiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rizoossneop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyoigae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rioceric', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osariai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caikeabinis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aupissohcin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieroachek', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatipedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyteyngleilp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alcepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogtyabstoiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noroengut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mitamac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ritana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aepmuleshige', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esussdoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upeveolsaas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sceycerne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peesholecraa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akcefoveiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cospaulyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noilwaisio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunodebo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eocsounkora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehyes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Troic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onmibible', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iultismewoac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reyikovu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoaga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eibdaeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinsuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scistociae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gemiecipre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reacop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erooayil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoodan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jaedhebiamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istdibo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oraacumaeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Croaengye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roenethexart', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Azsaashir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bitreiepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayapsuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iadisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itmeecelera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uzluailan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assigh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chamey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loorephyri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewnudli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yazaedigate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alpaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Repaoliseoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipeit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owpreti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Temaicainik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamahyon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroxaoyera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hanagoory', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaumigisviod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onreat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amingmoumepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itualcirye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atank', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayminefa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emenreficli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erisdho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imneao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rezaidikdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erpiylahro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoleoubet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niradoeyee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erteflaonla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueneosibte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neleais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anelediudu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maetriabox', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itulni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emysceer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gamabacpeeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Casii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Praryinial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipatielana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lophirielpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lerew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Albusoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytiesiare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivboaeeske', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erereraanye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toedale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yatcooyiki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tromahyeil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ontoeovothan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neililiai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otagermi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edualaheth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoanuet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riliiagyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hocoinerays', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaaeoca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clionieayu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iemasehoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeipeisspo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veiodayeif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antamisanneu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayistmoumins', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itarer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enovespu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Craneenyley', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olaegu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umomwaisoss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oardemeaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiocredoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoinsiangit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lianiflidyna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilobiit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogghiecapta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meroabiejic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeturitro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anaraengue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiableatne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baneon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anatne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miaextraoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duomurer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroareumab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pory', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coutiteal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tabu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ackusterthie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abicniaeog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eutaachoay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eceurfuel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erooe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaspuaten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aieinayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuicriey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dodepo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunorgo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isassyercem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Migioible', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bonorio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayoistroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rafiomeesp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asheyestra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atauu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untayege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irsaudabev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iitgearah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Applitaeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leovy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ronisara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ketidre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uanet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oceler', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivwhiesmte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiymped', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isowheyngu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erstecaijala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogicecegop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheamlaaten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiahema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nobuilasy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enalua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiabenier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pamiismod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewogrecola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pauadotao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roivey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maraibaror', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reaynive', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esscha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Schealzewoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipohocanic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blinoumey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Civonmae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teelaefgape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aisplaay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alaociny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osrhetememi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asciraoiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eochya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caopreaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keoaote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deryacoeron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deueyro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itagoacrayst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abneesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Axamlene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chaaweng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esengaost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fleracehayse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeubtizetru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Strogioemis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayegahi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eugyacho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithaef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irghoecteawo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tideulcaoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roehiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dateameze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ermaieera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poumumweynko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opheoad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oshat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoremeibig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flerpero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tishayen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uclualete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiestvie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubsiahyaomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isioarke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beinoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alaspoasixo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teibalavesho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecicia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poeumo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pesiasifbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iillacibeen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acerne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yerdiasa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tolaiteathm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pryculo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aosxurouso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idyynyont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atquer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uorechos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecraenag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieinee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deneula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icenanfly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edyeneage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aimoyiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eigeniizi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reutyaczy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iupomang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adieitego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Resoba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enalde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daausteiess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ijiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaigeonoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iooyco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opestoxiok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneyieway', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oahis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mouewreoip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avatpremi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iediswialry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichparier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adernedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utsticemp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecreebco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohaenritha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aheatxech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulenoron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyfemihaesya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeruckewoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ustamoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ariy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rainsaiog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elnaierle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeyuibeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuoplivee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opiceve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxeiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osioastcapo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apryu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efnea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teagecliommo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aayaeca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blaeodedto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Islanathyiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niaotephao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abidby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loitoinader', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toudiaghmia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyiedev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reahify', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caetinasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiangandeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaroyig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lauinoave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tryeaduerho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noabroei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Needefeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uferetho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iecop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esttalaamos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aravepyro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noenungo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iibaea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlerku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eytear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iareent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiomsenou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraimfoossoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Denoeroyei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouolpeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odlearea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efyraeckdabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atpaestuzenu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Autmeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eptmeerimmoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upaalino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etybo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sceictineem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyuyod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyuacloacat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofaagule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itxilyliema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebwogoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Verhoegaza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeuf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehtsebi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olierin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cucoicaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aataaxte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mileladri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovogepru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ranohchenoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pleacha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esneti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleraruaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ondielfriisp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ragoitrie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oboagbruliat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iorebiose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyahospa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaroni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiwheer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymetiohyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seeytaelmeha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lucrepisadui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogrina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuyititi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riengviya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seuvilema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eunees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reeyleisle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sparielyporo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imaus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eared', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tachiyel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akyaoyee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eutmiymeip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osbau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuifiscy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oayau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uqahperee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypurverali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erneoeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyisale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecalmyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoledier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deetenoth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oarraorke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umileriut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wenoeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noililadeag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oicu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ughteardahid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neestah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iltdite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prebloela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teyxditri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itolecaly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uleoem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meamiosni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eratbotobana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toreic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iriecheklian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Holasline', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifpaamugal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iconan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icstraeare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biglusithi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riryfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeypliao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doyamizul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asuliereys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amdrereoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raleeomois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Praneneoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockphoalni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emiahikaren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eioyicky', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Linederti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naibatay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohecsiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enogeashnero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caostschere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eisogilico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesaclene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iclaloove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ispreruiny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteeus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deaeray', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alysinorha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wrieowausge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atumcywheeq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeyooiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tomoagharo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esoayoclefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teolerchui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unateol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikoneferol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateudod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyaoumero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icevdyatac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staeodev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emamest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icgruproier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lecysubeormi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alutif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untabofi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yluminmaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unbeiseogne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aindasuatze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ameresioul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yubpre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuniveso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yolonime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gilipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilrieilyja', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eakodead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uladi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeyrsveety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yebeontael', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecuaatyeass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eratadegye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anostri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antracaru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilolgierild', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icuneint', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stoagcoeryar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raenraeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olmaesend', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanega', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eltmoiidli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elinulupo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aterei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icuireana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luueoev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ropleeara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fehme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erawlyatneca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epoyepode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tesantxy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kihie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iprieoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gobryinkliy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brathoheibo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etisiizi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockutoxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paeyotliase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalybab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatasm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shogeteak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliyiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epuatcelepre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iperacra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifepraebodyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostiachenae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inkitatrou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyisineleoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asyilyustor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onilm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Queayurniong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoagi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amdefla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyarilanonli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryucili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esmosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flicioomopli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diudineest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egeblaesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gymeareq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naoodfyib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aegaioy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isidealul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etpeyshiorud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyobieil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ancsidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ragaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilmonare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opbloytshe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fiuho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yceykieoret', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arleaento', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coneahunle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilniur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bubyarif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yalooedece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asubowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toamve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ligro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roethaliliap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Motieei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goarimae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onsenobru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oampat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xaithsheipas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eerohai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ispiater', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ientroitwait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iredize', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engach', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Manesiecyare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seesocawao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reacorteurt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iipioyelfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inneypahang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayuegiuow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yowstiomiub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heeciattula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isadisuisim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Terono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayechti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eassinogi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upepotockey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udtoorbuproe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lolerole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hierwriom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Robrilote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otgorilca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eistewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeajow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coaltearuy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raaoacu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiserdgao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buareru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anarai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teropale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieriipub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itlyass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernicime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afohynari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aisser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Proraileine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icieneqfliet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yareao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stoine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eicumedrayn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileubunan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqcuxaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dececrypaaki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Griurfcaeme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungolifepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acteatiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onhyatadni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igayoelsme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aish', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuapraama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesdorusese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egobite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tinaeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isoylhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Detefohail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trezekephale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sioussema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deylapchoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ramay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eungoromiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilclemebotea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingelelyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opainoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ultoatinao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omesmuist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceyapio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroypaivle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iearci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Difatye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angrymuiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estioitveon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymagilai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aderruoioch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plucaaockum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uemolel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aalak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gynoatae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yuarzaerldti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uftiebi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pihale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urelgeani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retuiastwata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tidetete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Allypeisaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biiadilede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockiarorloo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickuhy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethwaymerwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukethosdifle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aatiine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Typro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamysaomco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aopocis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arakemuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imeotgihie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iarteil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Truircrearu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evoply', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteyaewoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyiloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earyaaney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elinisaghie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rielfov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aibesharab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inopotigry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaueotscho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rialbao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yshoispe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tocifae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tymipeyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tichye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaizilli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uataury', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoceuk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eilsec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neatogic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mahyye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reupore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Allweionddi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuademomy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abedoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeroerache', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iloeeock', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riamacbio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elecuetro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aparilgeuogh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucyrsooner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahowirya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osurut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emeaaii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woeluly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nerosniodo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iytee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bleiresla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytreoesoet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eefoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toetuogca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniesmialu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaaepait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onemohvatior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piterecao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umestoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otaloisti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dephoai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plekeikid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astxyoctyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coriledeira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uonleri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arapichoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meymyal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pruouldai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tepiawryokci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spioaoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Operne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itelossu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zealreonalli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Learenengliy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oareructeil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taiog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hyleindeompo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uegoayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erapaeta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oltonkeeaste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashaegle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ochonteriast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubodrotce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iacueghuruck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciisynei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunetsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaohud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raorneuci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esmealonae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Molianohrle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isoynunla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umtiiph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sirhuorichid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itisso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainnedeoul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retxihiditi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usphubuac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieraver', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raemedoitur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astelumesif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionorm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neboital', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usiim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ailoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibishan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Snecrobuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isiryrunedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiexiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enveunome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayssaghebra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tialri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taemid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dinoeaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rikleov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aynwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suleyrtpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoggeaja', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayverae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irnulidu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roinun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theonety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymiortea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iryhiosreon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eerifepedu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Linuepor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ziip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useqinywkle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euohpab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poicheoso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockuroeya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoyaesin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieongioyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryetdierye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aosmibiue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enatulriu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irinabiphire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siahes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Craeidahiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oamine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unuviba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aogmech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echnoeroit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mapeneymapo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luadoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubereag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edousaibo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sareydyeus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sogieyost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chelsiadiny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eathiciati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preyay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongauticeest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suodtu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyurti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reathalfeiag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lauixa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebupnetau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itraplapruel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraniaci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovphomesay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aigioscu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owieriaak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingentmuea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oodterii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toesdo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pachealrauca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iryolaoywa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraniicko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeathoraeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reecuast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eronsyatrig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nilere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amowi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oibfreiltra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneheyeyma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obicucerrin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iletegeem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miutom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Quostyionthu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unyoeve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odiayhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noreoiyoick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaesiddurhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lipawienerot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erayhee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aicero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okmiee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arstre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liranenear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouratono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fielmanerom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoilud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezyialba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Floili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieeht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaywa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taesetdeot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uohtoplesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anaroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oobbri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orsecreagua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viuoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esraidov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iquynua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emonyaupie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaloydoalar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erispeodura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coeura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ychteiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teliimoty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raohme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orleaion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaonanicoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evefier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alaada', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onidapagemte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trityase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stroiveruc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereftetila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pleneopa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oealengam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estiaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scoeoypfra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yssrulioli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echeaayinde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haorey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaniyngna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lialie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucarvepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odtatie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulavoago', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvbitailice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paoxetof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Senonuaisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uponeil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Equmos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veorliumxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Optere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umatrechup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aobicke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ylogriig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paessoleboel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucepacri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teielimde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evcoinyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tifsinure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riniuntrono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yareybrezo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vauaeboi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veeckurtyra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epingarta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liadentcryis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odyickhenee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peorata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaupyte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mepiilais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoeresenick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reumpisomcae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aliraowney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wooistauti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalidie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiylvi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erunulleoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alinoyatis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyeinryla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urazoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Radoai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itmikicho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elteyoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esuspuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laiheygehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anaagohle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaneweoyig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idkebreaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Digliarolam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibgeciumre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nasea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vediwayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urebontenaok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taoewere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eicalstaorov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaruogu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aychue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sutewoola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itchimieolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olehoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icmoreaosman', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaloymowor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egyeerseacky', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ideagila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyerelrie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifneyahabuin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohmoaynoelt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yliroayene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogonke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coowyatreasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stroyossizra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eivreneag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apoeacra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaksack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebrunaug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Losta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieropli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seeratmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycentyggeati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yflu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cueriymi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neercapaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereminino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqiaan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Behy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owesitery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chicheatae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enttrapoci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tueromi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neked', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eengisyngphe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abaeaew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spuowobri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uputhutroel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icleongsqelt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atuasnepla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otierla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ollseaoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyuia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edpliilla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeyteu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adaca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trueshmalee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epheneho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imatiassel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atesedaessid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aryisiuni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isyepintpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nageener', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lepaeyceeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aghpeomchi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isriegfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaebiater', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echiataf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echieypuise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioroeab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulastam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eityi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oigiumlana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osiucilryi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gosteenewiod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aebiee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saeyneryen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniledeapt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyteflitu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalidtalati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noonre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lutenipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yorickasiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spiraeunapu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jeilonuam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Grozety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wieyotiamul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymuinsel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imieriff', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eutete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leogueri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ictutevekale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucaneiech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehplotyogste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eooh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Quenti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nepraad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roemevhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atnequmiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eamisachi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izonemookek', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiyyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usanaple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Espfeitaub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiissee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eongtruuin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anretyan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dooatevti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onailayingde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oecbuoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neathtaeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inieserycy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intreen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biquosraor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibpromicshe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nointeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egyow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phuanios', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipureglieis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alokraeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idnachaitri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uitnenak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leingoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oopueyeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sphiista', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecesri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oksopa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akadbiubrair', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereagoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyshefebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aecktealjoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pryindowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypreanisoyf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doredo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deowatoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toehaseu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niscianotoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealraca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peabrae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiriiela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nilenai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yecksiin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoyupacu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiprecubaun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostolimaito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivascria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iasroeilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tioratip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meigneal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heopnao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neelian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eifrabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rayndamamti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yapayost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niiriadi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Penaalgepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eceili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irbaragosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edosceipoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeoxenuto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoafanofo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aboom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neyrnog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaecitpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Royarchinirm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroneiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eysnaoua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereuith', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omecidstaew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oshastaliefu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peieigaiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uieatrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mueoteagre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereenin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukbliego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rewordreeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emkii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niwhuyatie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tilareut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooaloalzi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coyackesyth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naenotee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaiwnaso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sleuctait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaingiger', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aratyaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nesphoeiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Annatram', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniaijumin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neyero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroehti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anseati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leomaef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pireroie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anicafri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hefrechear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usieroarad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oshengbeseni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iginiouon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogiynoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woriteoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olyiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neraele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogfiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Netuliast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayurpuhomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Palioet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiatag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etwoivbuihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yosiache', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eesteai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isopato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meleaslyug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateoyetmao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laraoyerurow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riclomdo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Necoasupiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiyelealpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioiur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaayap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clereuimipu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onirklovaeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eorekeyese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umianraron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dueazocheon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astrioboet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Criaohas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iceod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyacoluery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaaloyicoril', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Togaopioli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eynaiasolint', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reymiocatpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atsie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esatedou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ondvysetuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucrihyry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arebiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itaarelexi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yopoonet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adyuodpoild', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amyemovo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rokeclau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opthocamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scoasasane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaiyema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angweeucu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sealbra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onseetsaylo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aieuue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adbenoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adeicaali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achrecif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuayp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onenpuei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inraoeag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idnisevove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoltipuople', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiienemayb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puonic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reree', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateanad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tooi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hafithareon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flapaeit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adeaifra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iepmeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teneocyoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etplipui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tokeazriatow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roeadio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atlaisteha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erthliviest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ylyenuta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udleitnia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eredi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eray', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohaeayiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehaov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaesolla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oporauckeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brerorief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esherstroesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiyrengy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euremeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoava', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilnoalratila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arearsy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naestbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eynggiigili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xeteanerkplu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayessidskuin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urdtanedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebiwkugal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayatliniecro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elalgies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oraleardupa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onyaypeisat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gucoehxagoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aecyipid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rareia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awieegh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Friaeaec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uieselee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aryhatsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emeono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etissumnoog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dachashixae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoqicar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ramaoubdiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icnoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deabaufxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reunonte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryalohe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orayntenine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqieolfnimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uenubkiok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uunreidth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethbiuke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lerorisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teilisloor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ornedaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pnane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neomdeilom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetagoypse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baissivonuoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caerri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeratco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anwhoingo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oldinyexqura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aceelerd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paerisyiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abideseu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peabit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tipisuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nionstamatre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kaiyeriz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istafueie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gehis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izilnipu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Werypaefhia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scaeooratil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etfiwoayat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieasihic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emaoctpris', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieninowdul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Detry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acchoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stueragsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owneifhoeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coipetyoipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zioles', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esroaged', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaseide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaelieort', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alhyuowbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloyssoauc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ideepati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adroaspoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eosyawene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afnieowe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umcuneita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phietmio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scyiga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivimoast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syerectiul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beinruer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lioparelier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoldomabste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heparivuwe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oelesee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aidomabock', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitibo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neicamumer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nereealeust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scuneeumya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Netyulda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Quile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufoanuteer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raeryichost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abyriola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raolaum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umimirana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udeilbueyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osayowecyhzo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auvistiay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniceahxy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entlibaeano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetspo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wieyma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoeocyhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reivbuie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itetiaora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeellaando', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obarcory', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spiolastay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Norele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaiprichon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mepiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scustiooyam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peiorop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitrary', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiotentocub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebeiotorack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueewarepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pianiclae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reexyarpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abitonaner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uuapeyogle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Almaiik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neonre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enisecarolqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anyulnepoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eletiuena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rishistuoed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atunroesal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ygeangei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Talaitystra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inpetootarol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otessgloiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Razyap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aysaey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pealysauna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cocoeerigo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aldoomadac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectehthey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araciciiup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Invesiioctom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismoreg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efleokipyhga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iboienesti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiiaboispya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubutearnu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leossaeyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hagirodikeep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izpunaohtan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intiteizyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaateyat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umonahetrao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caqomeimay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opierenire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiliipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icumem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useoctrali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Revule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iessupum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sasepolue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostseel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyemaytaty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyetnioira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oasieuwket', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iceyieirin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fyoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awiybstio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyiunat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riaewfeteiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alatoqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainays', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uerutcaate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuoiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealekugg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adoxuocola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amapiah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rytiesuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eghibimal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Totteiem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amupolro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riensdioymdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pliauspayaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ototerie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoibyathe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aholer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atalaoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayorideomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oimni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avpoheara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipgeprea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abblueonlito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryorbepuist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laessag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foalsipast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yostucuise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atrooscepri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esayoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leimemca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniicicli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estreoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igipeiddlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moeiislacry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adabemil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Depri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theteusmiah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avadiockey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaxai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piyrodtyone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiankea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oecferaea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amniriad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gydeaovli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reonoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issvedreief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plioneesoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uatemre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naifniiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enkyat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oicintore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obueisu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebitan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choertru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoabeasm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idsoategor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gloumsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Silera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ykidriegenew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epeas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eovtitepai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayeieriston', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iontno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idrenor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiscaileni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caopdaomse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehigoesy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atapmosceute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeasmeaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rihetenefica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oryceysayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iumne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raycae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiurithin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eithucinaoth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wealis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuyeowysy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytintri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oratclanasee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miark', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainarule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rhiaeseadec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iistjuem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baisboiur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iseylaleno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahopoao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engigsie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niuniukhyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utpleanay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arkeefeshies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajskoeuguco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eourni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ybingoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iangbutees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ispipoentisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doeyertiona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areneisash', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreyaher', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isreti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earydle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteongi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atslohoemow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eueflanoast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isditimioov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yhyemeini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aocyovete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Easip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yalty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epchyilopab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estidifa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oluolaodat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayolan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iypapariun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anesifare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amastaisreac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loocechanes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leraoseor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atriyses', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giteniastai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awaile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossakoreat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aheceur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yonachlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agakpraa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entytiean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryakati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuvi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofatuche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaaonumo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuoyiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doassaboidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aalneq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icorosiok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ylve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Grionoru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaiac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leinibli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eapoenpie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arireulona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiyaprena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umagivisato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eglifu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leinhyola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buniootier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uastriinnu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yediavioh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayakauryus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umteuyiab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boapertweaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peteyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dicedae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaistine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mayanodpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeleeonu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exyliyh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giylataonon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Badoonhy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nautedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nortanoto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Letyrais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keotreosimb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teanarytri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayidchaolera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essioniedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Strucapla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erboocuniat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lafuakuot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iluasotmaov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uobo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nesucuraet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miorploe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abygiebaog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litiarigroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uleauira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anilungatne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aructiad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uknemougagi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zoisniis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiaciag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acydophe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geaemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ospuxieteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coivri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Axulerehco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oedifali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saeftolfiody', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itmiogacmuan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estismupeet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahaog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ranei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vebuereru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haerubhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adaufra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiuanta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Weocynis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ireraeeas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deirdesmpaca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roaoveang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onisag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gruarhipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroesinufu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trileigha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertiem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etubluyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aosciey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oraie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lomyeapleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dateo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inpoeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneeinein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aphisieato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utopmitrat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uddsae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aadaryfrosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epafco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epleal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odiyiaani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliyocme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateceetlene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Swaino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eashie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Radesciaoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rousi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onteaduho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yddudermo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sukasha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epnease', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aybefo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewacuifa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meipeal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iriaybutea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Relolossem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifneleinie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isilotio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oresyeeoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idaow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otuon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erigelieve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puotayone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroentullia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tezegotiva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idalselyois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eintuautsci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untuonassca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elengleneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atesismaobra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajikadiantoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Therepeyvo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aojoingy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itiyaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Methy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aordeaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onizatbra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainustpasta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayalesnolans', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yautinif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anayaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zecli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Droeianop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mieoostil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ararens', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lineaeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raowuwnal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeris', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Algaosheiper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismyraieu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raride', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estabembaoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reaiyoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neyaetseo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoseageatsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isemrepalre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Swierheoang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echenemaolte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etogpeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miedgula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eirth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erotaile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rausmaeoba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riciseualhy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isicerkaogli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoupavy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liyrueay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gleenessuma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anathiiyaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keiedinoem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unabluerylge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heifryaeox', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urfmaoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeesick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afruoieras', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paulroate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epivel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iheraesmlomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meonaigaqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enestriion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maariq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acchiieri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oowaph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iokineyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiobteocke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayuatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suake', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aacid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scilydiiol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahesolidycad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adalyboveom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inblationeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaaviile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pheperailk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lidrytotiail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesyiran', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyissoth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piuoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoscote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cometirondco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yonieiis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Balaeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epethio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Illyey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voeivfido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seasteaolen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivromioev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionyoete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eual', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omclueeub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilalyuafon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atayoado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mameaecde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehenilioi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioeyainurn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opyrybiot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useintinusu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esieacwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saeliedai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leabanetoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paotatape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neceseatus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ellapati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ospiful', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eurep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neacap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraveawnaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aigaitobo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeyloadpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaghoryul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraommuseste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeyuciagy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipyai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aralenvi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neipao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ointtaau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agenithubuid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gielima', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Looleae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezahoveonen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adinle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asonniqueblo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bueicprogli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilneeloyal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rilori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anifsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aokalcoiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseuimponesm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilalea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaeadog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayoyve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onneieram', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keohesoreem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aminisentare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olondix', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engigeotiste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icalyaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elapceuy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obliyakist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moebaima', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gitiatspu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ylpyehbli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alodaucenke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alentsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceabrispypre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diteabic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Youmalizo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nashupra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naetioroye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezzisayimar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moageydofni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymiolpetier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bleal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytarea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efonclo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sorute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inorarmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caooramte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongeyaos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulabuine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edryassit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owroachga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olabopyta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arearo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tomerwhatiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trientoyiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Askibluift', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utuout', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suieai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litieesedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peeowywang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pashyontini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceetreonoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iisemuinunt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roechianeci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seinwricyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubrewhati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itabeyqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Breadbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peciye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otitupipeoss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deraolwoaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyetil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongouo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogoisediem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itaatolon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecinambo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeieti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etleoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ononeotuthne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eponesaetar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mayieeymi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ripoaniya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysmramiteig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayaicbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineatyais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rebobeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieawsteop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneeuibbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thaay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoporytepoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryeymaiest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuonyoliar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opsurele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neuntinasma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iinri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areatri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sostrineenos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysstihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynoik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icnibliies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehkizeief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uisipri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eozrebti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otseirhuga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caabliaasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blaacixukne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abriat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edeitigamti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atpar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieicen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imepra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elynu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eidti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agoucem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deangape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ottaili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Recuypin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wasnaiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essreacitphe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apmeanyecti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Proacte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egiirli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneanecey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Demeardme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abvate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymerui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noilasmniosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Melomuraleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reneumriasol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okgaeve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysunduea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biasco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyfomeuxse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atamar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypaeliosat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiguldreah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onskaepem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiyeuy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afenjuorrwai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pepileneord', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiendosli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lobiaoig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engmeclioi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otchoirfluow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ienario', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erabtigyh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilereondofi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaeyloid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arteveladepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angapidiao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ticeniaeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebaoyga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onobchoienu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuicetepre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iseboo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wenelyie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uptiec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaeum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tozaere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uynda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enonkiufo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekcefoxyan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dealhaass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cesourto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneoonover', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orelollo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Susesau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinogeut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raalipio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iwsoraikeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aibiroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neneurlorira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amdwesinyad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nireetra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oceroeraga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isecignia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uneicno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Topreirmne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intiaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iznosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astudodro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issnaickorie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uneshge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erushthanide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Drolenypa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elasoanenef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehyeaira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uemshoeme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coicentyatei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erasaio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cairteau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogneabdaest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aysiooperflo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imerfioao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etucar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aorot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efatinib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereglakeaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egliediaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oorcobi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onglaineri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iubo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifroi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Italaniop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otleagyeci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayngoiruci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iomho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neitaonir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongeyikar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intutopsti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epracomew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aivo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tomeyom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irchaonriu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryolastryer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieickriiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiebiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eshpountangi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onugleo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oileroag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epeoass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thacesrymi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivoeoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noryilalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deossceye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mecle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ercoeyhexida', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leinayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishaist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayyaynpesaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yngoxepgapeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoyagoststo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mouiemey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Restesliao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awandardo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uitasphuup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eertiordri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iplueyuz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Steoeyesisam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulnizoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubsoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siitopari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atisfriplu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efdieig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apreusma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aenfenaode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atilaopoyte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Troolkea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Weofneontran', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tipeerpususe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieshaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchaasy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taeyreeckri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyieyuokple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Citywoaald', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wosuve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheuheanabdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erkaaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igamyaelat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubikireneat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iualdarot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialsuiceeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yfstreine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oisovnecha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ightedei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eautoimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eratnyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caleahith', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossmuenekieq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efaetuluxte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecieva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noawnete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uhyta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneifupeep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeneciyao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Temsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeusra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtoyepaaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ephiefipade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acholdeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ompe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocierovplu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uriubboa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afetepeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeonco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enefloarne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iffeiani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olumalfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretiyaat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oluilach', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oscoomedipla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yataniurepme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunushilmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erliliro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elteloge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kiama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inulamlie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irdjain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ererfoabesip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lanebuoephi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puesaeiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atimaelbere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleacetei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalamcyge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fogrozaiper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loeiskekuem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulyeneof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaynemalre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eurartbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sioclalaaren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eotop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inonryco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icruatcireno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeisnuam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arlialmeun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toigahych', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyaopabse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubninyepke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiaeom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivoblor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acmuassuan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keteoyeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oimpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omemiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oispeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aecku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earym', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostunocyoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Floite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peseosui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooaeach', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erfa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istguvyotata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aschystiow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ruenstaasa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doaymyeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crygaoenyyd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiacsma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eireyebisten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaistaual', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Embe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reihtne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entnaroaci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etuinre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atablaioch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dadiaworar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gevecuorer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xievatect', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ralaeierit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyoisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoyni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maionglege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseromepod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fluaheme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mupeaeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emaare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiaevin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleaolyplu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maertsuusie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alladyceaoct', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untaerca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mainaryete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neapesscriop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ripli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enotesili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeniu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyowsoliea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeteneul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etyema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernismoca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caopone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meacashu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraecick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecrira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idogimpli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oower', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aissniic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unuinom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phaenmeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oroikior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neiospelayrd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Linasha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatueur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycoeug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyoaortitha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liiablio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaefaeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreelanyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tidro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiegere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diomnoeebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leantis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esompredail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uastetiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufindoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abdeus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rizere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Smianiterig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orscroalac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onaisofot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeneeteemla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypeahic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atecode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arneealalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istvai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naymugaitit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuailiora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoupaygi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aypihaacyli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eronro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubchuostoith', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udericktigro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eriiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owaepayel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sioc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sesoneehoah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echoissor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acorbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Azium', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erageumo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eehodca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipphyileribi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Depaiestheif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aicirpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehstigrarai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaqtaneanunc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocorre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bareifeceir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trichoee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Selyderiful', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolatmonadu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isugreopil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceietilpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suodeyafe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viefco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aygeoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipnaonsta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teiloshopco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arialitni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyecirdspo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roupitirk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseynt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teakici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubeyemai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ansfaess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erraoyesomri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Latroeonlosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ourushae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oanteeae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eimueuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ninugyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asiuquro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olicgle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atlyyehylu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aovacgeow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cageamocisce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiatriinerm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaflao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roipitomea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleehise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ricepothow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cooatraac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leloveiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Skeistri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lakoecohtov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikeheskawhi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naiei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayoyier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assaoneat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isecha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Espuyele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroseire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eafiliawor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aikingum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etemine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaifaapat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okaeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roesilack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heanba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ankreimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Escro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lisearoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocoeromab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanablurial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reysmeretig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vineanemteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyeere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deitine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyaroeite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oraamubsece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lateayerlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neerbetosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyeakienal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preaeroex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reukiatolen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abidhapeate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diuyealatid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otaey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shueatfo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Austoses', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avsleneser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teyait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ramekye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ututatro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongoparuco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enueylou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uisoolah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lymyusm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatiymam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amelwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubliiesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ketiaexash', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adiftev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icnoha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muecho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eialliapri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teinutne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asatereis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianriel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atstaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Steat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeeprosore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineyiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eubsostoibra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orintenti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suyeso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roagueryst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deoshini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ermoicay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacdoeen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esteopare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikiepao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eafi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoneromu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Testraiil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amobialrya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uareyome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eimpaywera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Quaonse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatoiryin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreghutae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anonim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acootecelf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nayoeisseyna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guebaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rearosan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itbeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veieopla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ienerosie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nehyidyiciew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ackagre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acivavryoay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inizayivri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ellaihalti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliogy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vaonestinafo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uraspiage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tocarareo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seutlyum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intiize', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oseofed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omirasetito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateolada', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriwaulangat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Floipce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asleali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aafbapa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaoeneel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mocaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uenaneiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clefumewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouret', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iicoirt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idtepacoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Snene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keiareigut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ananenaror', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itcinieiggi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Easteg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymraogira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchribarara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieichene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naasesyaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifutema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guium', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtiaeduand', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateyea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uacaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ejostbei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atriroinre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vedaur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agleoceiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essitesuca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooyiaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oryprenie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leodmyeyeang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diaar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohnoia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gusechani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tirelaphi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omseorhien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oovstuhaema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fulinioama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toneat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cauecnaey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Attriynareni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eowadis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inutfeaem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieleati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yreyget', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucioanfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernelyopleso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecyperuil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rexoycebovo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sesphyha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Licalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teseoysopait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engeyoelee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deieyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suitpla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agesqieary', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Disylofaerli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onzenuescri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choibgatape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creleatmege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileifu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tariamlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichuespidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoyonimceeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amalauser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aarezaedchi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phiethmsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kibi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iitassopge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nibuyswa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruenasonit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekealash', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yocebainzove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orereik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Picepemutiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulonoaie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elgoquise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muexkeain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zoegrorzetro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernayaan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchilre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thiluema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etenabei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciponeutri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avdaolyleop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coloneesnui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isawneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyeral', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Armiomleneca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dopuipy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dulawiivey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estisaerik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alitafe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryakeabecgri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Graiqutophoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utentifo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goomoradro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneshliessa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efiungkieug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Weapdoef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aveal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciheacesyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phitrail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeisoule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieruntpreov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iposiadaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scairepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einseateath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eipmeoroes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiengbrie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boaadnewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naraetebothi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipeourcoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ersieraeflu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otlamio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatsianstre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyebiael', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieeae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oilelestao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniegail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viaicarta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Putuacay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayphaomisni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uticot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eafepo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usistins', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beemgealue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isscreoru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ierearior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sescoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ravyal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nojaseeassub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aveteurep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idakyidreyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingeio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urnhiwistro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayusamepid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blaogesniro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeritetno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebnitrio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ferereoloan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Espescahii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipax', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eosasm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingetifatyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvofyoubed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ildugleif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noloniecose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neealioah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itralulo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loliizri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onechanopge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utaenryabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lueaete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eapyri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evschoto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifeinti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoitehao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abeorirkciel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rolfo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emaonan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orayaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omenipmite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleatacingew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arfoayeere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orowerme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leronayrzeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilyarongay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raecac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iugeedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onedale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earorneyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithyumun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owyeaerce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeeboziabyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eniatmait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogeaotehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroigeply', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icelae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acuote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyogoicy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikeepro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eotnaceto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inobkosau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibaewogont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paproedobke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omcokees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaobuny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioeybu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atool', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Revateiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiadil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aticneayiiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Togmein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dieli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyovag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esoicabro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icroinarbye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pochiiex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zesciacveami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialodo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avecnena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Proyotaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apeiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estuiojo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roayuciachli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owgoarbclo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reieyost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Streaibudi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esnotaire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iltecktogomu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iedomguat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxskisintqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inealereot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icinaderam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehualire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mapriiospi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Undik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateniweli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Allepipat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iditlesiep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maoleneudi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usioren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciulo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovowra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neentlaeina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrelti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anxyum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soacari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayfioca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adoavei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eadcheylo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toalymetno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohfreonruche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongonte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liismasotune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foaat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enoatery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naeoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiethloha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efosuiawo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paogeuteu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryinsieui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thucliustze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maoyabal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ricesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onasicbayni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieoidep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaohap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nenocori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iulyoiot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naeyhoedos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icrieicori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staifceoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itnoero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istialtoaho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esetraeru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sialieic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idoroisu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diedudko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nocias', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dodesho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoolegero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shehefleohpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biogy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diwiangurab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iumoirmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erolayip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ounoneal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umopocream', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyoatonbebre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erneop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahaveni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neurnamareba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izuoriss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muitinutip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alainener', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olohesea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ityoetichila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arftoleidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foeniecha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uawitiopi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gauma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orterapheo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odapoesab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onaeslipu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biusat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uococal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eduilegoveg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Letribe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oarserle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eglaogheroar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iogu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atutriil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteohechie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciatsuagoryp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aligho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geoymeldu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiedyupsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Insidisnuye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shaichdiust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olacab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iabak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alamyicont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wovoilgeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaeayro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gemeruer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioneti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wetabatyrkid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estoiesroad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yenesale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abinile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olfriisyig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siosimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atorerethol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tareo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buwe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mueoesore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuikup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aultiteya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estroineckef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Momeoacze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaind', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atabic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockenuesmspy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilisseanucy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceehoymiuab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Espliticruoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Joinuu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Graioagowpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aapa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Infragoretu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tioayuntis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akacaveat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egliarasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osoabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poarigana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paiblileoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ospoad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaurkecsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agabaisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roaera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neciraraey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyyatolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enamtesaot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edstirodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockcoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biampegoicar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kearycko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oianolite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trauan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iromoiplo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zohoageve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iseupe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oytyaale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maroiaui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Notoayyol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oacai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rayfalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oauoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imcaifowy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nayoecra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igtoursta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ignocefoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingabfliuob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataitay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erawaoleo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lobti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staiegtocin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veskoiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pataotyqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacruni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiteiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickesstroi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Temoeuqni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olinule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Feupiahofe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pryisdeacpre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aligeopcue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdeilswail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staaske', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ollrapro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imchaarneid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Girioploonud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edaltyeya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytesaea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuliliuogy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inteyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ienedioca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elyayake', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itrina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esphelero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aguou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adnocipe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aranekoch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utuyin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reaaunon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apoatnai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeleraly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiesoballata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iveasaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiareckent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nilistepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nediertoeod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poboyente', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oloe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auipauel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unefleito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tilaboo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdaebo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaikdoaorny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adguetobia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ordriluic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edoasae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isiuntei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaurou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muazan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cotiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aovessligre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rialeleigo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaerau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emtarauc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Namibe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otatiopa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onutywe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueyon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entiop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reipeam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuprirona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiaosuary', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icelanych', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itneurstaoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nicuio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orsypboao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayenaafedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oezesmin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inmarwasca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alepoayra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atanebatner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itesiert', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odiegwhoonle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vaorpaercoon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iastde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ortunakat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atleetethi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esaesafa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osimei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oveioat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onianeid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleyashiai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayirapa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sutudesiple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siyepeockano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roeyptore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hyotoent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aymei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haitchaiec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oymaflais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syolachi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmedoewloit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etassimubome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayatoltorois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peneagfriyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ployeupotat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alexegac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niimoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leisryait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitoespoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shadiseos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hestaki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeyckorocy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doatorop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epcluosti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuarohan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Youlafeim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Instru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utosuens', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tamiupeubo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypatoencea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hyneiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iurp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vyereoysem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Braiuck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abuessyicuit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiganerla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usectroeuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iowdnecoma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nadelierne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fiesmnein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockliupti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poerilpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aday', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roassietethi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uboubrae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adienruntaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uybi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovdoyuk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohisceodeol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urusoetex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeceroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingirtu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geichnesone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coarthumiges', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayogneob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsieuypt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aledateerdo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Priaha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ozeedyob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orisasun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atanizcyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etenal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oamedire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riovedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayafal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uraune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erutrual', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogwrenea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laryoatoyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etzdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esaiad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eghqubiseat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biipailco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulyg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irdilespa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evneablo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyaedihire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alnenouk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereilphaex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehgeiigco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daatovi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongniyindiuk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tredlidode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acedinegloti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Greuadniethe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liiau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liernyeiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liceulel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eahentroinra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilneic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nelaidice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieidaocri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteeylcevo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leguepme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abuwhena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yzao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atadoifug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilstreiphi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ublyliiage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyutboyund', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loateteimpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Streasmee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amuncraec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edordina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keerecita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aotiphapig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneunastier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riessotbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inutei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veacutde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoreu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atulap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uckanowulaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aicuarer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayutysitii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stripebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cabeniixa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ardores', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egonenoivam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreziatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unceyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echecoho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elienigoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lialadayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytufralu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiorat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rireeipufe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noroamasvope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yvasuodke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assiesariin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eibuimabis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycoaitea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amcaorit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lisetick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acatiamobre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiulu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adveyt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rerasle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upzeneome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hineda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Timeyomameck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayasero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icayeaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estinraig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tauteoliye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usalayto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliocacla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaocescoyc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulecisuoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oregorerigri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ixic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bitaaboss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kutoitunkzoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aexakeism', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoysta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eychiochiag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odeaotne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efrune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolotnauso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniangi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oderadure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iodvopesthe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etelabanaot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ankilyuhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shieceed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oldguintne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecemis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eypo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ring', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maecduiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moatgoian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phoewengahyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohuasere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olesya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etgro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abbluelxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Migrilie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umasahat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onierero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alpeklyeewn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seaisyaial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aluypoghon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neroyaheesul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ticlonuse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifahenoleim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aanoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enumamom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meanlaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yulluide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tempsojoib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Westre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agoliblaorci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deteyraene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyeenwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eshdediwi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olacryohdaup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraliteos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yekiacsniu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irenierac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itteeakiart', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iheprainble', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edotilsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enasatnoiuch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Capeeraid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vihe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecuecsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istrealma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neasplaory', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olepostahaph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laonaah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Traoshuwepoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esanidip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneoggesla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upraylinses', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anemo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaasserita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaordread', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialimaetar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoheo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omafi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neitapanqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaburonei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Segla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buibisarere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essyde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uliuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecactra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyanica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uapilai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraerohuz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uylgioesscra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istyemapien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iistayloeqya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emosiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engcuetymli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Susigreroal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inchitebi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryoao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efaeismadgy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elanne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nomaut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iacao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usackayimer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roumgeaurpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jieara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifcawoanni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awgeoryeas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yserae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fieatdra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neusi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Operayoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urflaloerici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arishaze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yirmtai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inopeb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oolowhiede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kaoari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Husuiore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gliasiemo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekpriuteuli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilmitete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseexveiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayramene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othaplatiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayhubsaymu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echbateutno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imotwao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uosceansiov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeatucemre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avizowlcaele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyaoistli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eranoaai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shaaeshiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytaliad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blonocoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismearnichay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycireeula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aecheey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Negeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iscapenaisnu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyroieforhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abofyeloba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ydesdeey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Parueplyehti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lodipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urebdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enevo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olmiureub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irisincaem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arifoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungsealavayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owalfyiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatesizpiac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kiille', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciuogtenei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iceailpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iliniox', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mioomuuri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uplaishuie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Userinoede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooyohe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaosm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eemydoass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eceluijse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chirayrtma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mesu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aemesedig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doedcouh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essooaraun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeriiyiter', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeocolyoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iorhamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exsherereu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiraneteagya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Axoiermceil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eribeop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atemetnaell', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossreteae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atofe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haolec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oundo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orozre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Navire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niryorunin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okoyistitu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyigmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ordoraneryny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unoquog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umadniglaun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyotry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoishoilem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zestaeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioriolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etreuzaj', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaorinafi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockiovdao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creacoiza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Criun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneritioc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apyachse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jeomionio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abyrmskour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aggutkiopai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycalyine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geheonisphoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enyaopirun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seinsympao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iddilasesean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Glialoivarro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oweatharinme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dianseroais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionaran', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moyckessoay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biasatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiemge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaheng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyichiafia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahleaone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retoagalig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omurenecest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onraeulio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abliad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieerio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eagtoega', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yierthspo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Conoialust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniaystrati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleatoxu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aceosweidef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeliera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rayenge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itzdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arolosk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noltea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icruongane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reuv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arermioadu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeixa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emovehtiade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stylaooa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epseinib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otheatsosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erbecise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiqro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iofian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olroreico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otonausco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prahawooiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aynaoviod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reoguivlao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laedduse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owelriaus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riolirpraan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Almayotel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leurneas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liosharedri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oifyeoliil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leceorduri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oieaga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unriro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orelliizcry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyocak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egeati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaedawanio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeutintre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolreriami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omayeati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indfiarira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ameyaraeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iloineu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoyyle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteishoncaic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ailacoyesre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehethulahiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abligaechu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onrilaresmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irdlemaehow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staliscadea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zecochailm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroataoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acacogi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neererscieu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ramoyereab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niapra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loelas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taensletyong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utspoocfoig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Henaeche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sasooerin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aopluinhait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouithmglahi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onatel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoaesmtitaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otliatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecnospuaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agtiatno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erzaiyasic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Screeragtami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reizairm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucpri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caobe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imayatea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rimeotega', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enacbli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaiacefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lapreug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oraiercao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaamaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Renecoestyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eusaputtearl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaerne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eftediey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itwiemeaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aruri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoeil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleyub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oteotang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edahzeizce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewolaeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ardiaette', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tryfierow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osstyalerper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vilifistomei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abofa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uenase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unditarbenta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtoee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lebiesoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eush', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Twemariiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gegiaeod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialgoerth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aevooperd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leeimhy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohdite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esackaloestu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionleaoss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyockol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Azostinbly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ochiodinteit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asautell', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aytisle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icealolar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alorieiko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyecboureor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayatarering', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anocopian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieecereiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hosweabiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nitiyergora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achitow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aubya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlaizleuye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taeki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reotreyomye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izucta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gulpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofueba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puinarreeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eostpieope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uesreipute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rioivestripi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imtoerpatla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otenvedewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roeugonlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icyerestreo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uniqfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Airkmalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echehehei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lietrimoipub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismieronta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rebusolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stropo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uogayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orirallipri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oritpeysi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecisumen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reoalnievu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oteamefato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bipaoap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erueliua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idroowpeico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tybatscene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othlaoyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Melay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acimaesri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Encaallihiak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chaarstanier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boecanin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonwopifeyst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostuow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Resonipeoss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Denegii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atidieb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebreetheiegh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqessioed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aissaipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nisuit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inhytatiemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaantadier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ailneayean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipulinty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulteabaeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geytaht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teshigaeite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Axotroishi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alisdoagus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onieider', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aangoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsuiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usreum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iisotmyob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guonaebju', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teacesty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tryodingari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usohabaoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieldosarean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeeaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateochipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laalsein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olneimose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Priklykial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Segri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anasiine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oserilyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riastreomny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isoylaoroce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gleiusyaoht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mesies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orustaxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nioksneite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anrar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeqeonso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayyeskedrhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fohococaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leiiech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obacruerer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rohomdrycoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubinomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epiner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieamebay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owurer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaytusy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icureoed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eobul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiateoiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugatiamipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocirlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uerpheutety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rasha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udreyeute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shaogac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ragileiam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iataele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacirmesonse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maleoonmoam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaireya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riioniehyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imoerinena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biismy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseasinanle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyocnego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ageief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiliultuatri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peoweatar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laerecriipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eehardoiqunt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aticorabaest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewacroyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubatypspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aestid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilbraichro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlioannebri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osecaaspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egoqneomolo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siriapipese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osnoeod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Snunoehari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alnoiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Artaotaassar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urdniiaatre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obbetelyro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihuao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyrouteic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiupoatno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iossastenguc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niopailes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suoplineri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egenoiftopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erzeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deind', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aigentiarso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tioratcoblu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odagrisceol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amatsobesce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coodesciaum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaerabord', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inytesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tawouni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otiaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irerey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luasale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aolba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pevoraorpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneanaipiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erehutyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aumettongero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockadhoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opoana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itmaeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mapier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoeur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owahelhean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inumarsilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteindkeje', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilonilesedny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adneacutyilk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opulenigh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahtoraurond', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tesyossemoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uhafu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lapeacedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceyeyet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inewnapreor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phapimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yppachibeiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meprohiyec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deinmiaphe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yneifo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertrie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeockefeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernoanif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echuoiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oscidaicse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onolte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sleagrey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehicya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyegeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiolueiq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elerdysep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ligiodroice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anayera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Natemaow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siryimfecuol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aboceaghloe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inefaloatli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bimoakin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sukeiiteyof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goucrieevo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Remaecestro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iistyintabmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialeetypnu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eovesponon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahireer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otaereet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aogine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatuiweri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einedoaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoleisme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioycoino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astochaireor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anlikeese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urwautryeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pirashapugro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suamolit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiantihte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueldepo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owatroistre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lehuaripein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peicowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utalalicre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaezeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raaoodna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raajioryed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engadie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolefi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laepeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teochascroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erapupeaga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Milaameuxol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luinefro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siumon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siahoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cemiabortme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiteehtibi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gousole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uhtoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovatypoca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aremevo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egoyeotcoce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eemeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umengvealalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otcoeckelyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upoaalatco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tehin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seayesoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leontog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deleneas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euliy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeunugh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idinenecoga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Curaona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchoadaene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nekenarech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esinefueic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeaeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nauesptri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odteumstune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vepeedtiim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oloanaaplo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulitesteatyt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taiveatelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aingeemain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iengeul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Borybaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayehidne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Safreesmolya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrauro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloreloora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udatee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igaerol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynuipaspiho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teowicbeovdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erotloinun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uneri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engoessitu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etcetaspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eigu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nopiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewooc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meyamoitli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iabcho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sqimegoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biolucayng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayessedess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilcuacro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoilsidinati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Proicoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erboeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jiweimoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isuceassyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edinsrycyode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obataiocne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antytitheba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aplio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nomoeot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioatti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erericken', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enaemejnime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raimaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleeiulco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eidbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pheial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voidchueeha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecedlaatis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeolshoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Canecauer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealyooro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Racuayetre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iluck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essnyneru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asobomxoac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esarinoivay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vaomdroag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chayiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idarnloeram', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysheie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chioamcoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehagodu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cruaenoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upicihy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eftestihaiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doflikaolte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Espisceickua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xoiantco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teeleni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iium', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Styabivior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iusk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uopran', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynisstu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beestu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noatod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heyureris', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eduonsbona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cierstri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iethociton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noicyye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raliyctthui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gymeleer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aicstroaldma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roemermesmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iugi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meesteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alerlaemp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inralieli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uralilae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tioyet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Easliom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheighilahe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aywiaeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elnenery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inpeinpro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icoxaviyss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismisam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocyoyov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoyas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leareategg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dausa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneymiandi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neispca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Glemoaiowi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beidyoerju', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohfupra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaciting', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woaypeei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deriulitmeba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ignaeyurne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yenismob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elekail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eypoiex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isheopeac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqlientat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noiterfepra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kaofeeonfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maniizafioh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucoupine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yatomuti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upelute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bueom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciubatinpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yafniri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omamyes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uegrure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daochecamo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneowlebicu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieviai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otlaiadubya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Honieruseca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orgueragelid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opoyiaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itxy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opaurpayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uponstuumry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edeaymy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaydo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneshantamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riultepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mell', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efied', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nimeaufli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoackrosere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etmeja', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astyeahtlaay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myudereatig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoiyea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoheos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocinirat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ricoter', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aplula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atcoifama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ombia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoeabceord', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oomomyomer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Operleat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onuara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sarerorai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toyperteeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upioii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raleogribu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idcodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moapriamp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icisat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aimecy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mauconoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istoaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oweo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phiyienis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raeoeteti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gekhietuyrd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneiia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lotian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piamily', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evucaopnoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issonnionaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yneoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gieda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edudyuial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imilyome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neefneiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aforymepo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eahysisgapsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineyanene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibnaiinoty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereoaresto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rueruao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urasinsye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shieanalco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaofrewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cafleoth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omygmayng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yieina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ardoshta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isameni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ontiipaar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneneyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isuiws', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diyavacuet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeretop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoplylepre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saeost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iviequitic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caodsaerid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ustcuneili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoshwayol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evimav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ridontsei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kualallatai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciedinoalit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraafay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayinag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neipat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiysiriop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miomipiurxo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chaocsie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imyrketap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kamystnaery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eris', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eguem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plalyobiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriqesitiry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anyeuagoten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiregrayene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bibaroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanglestriab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opidiogic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loayipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iytonenaep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atbori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uromin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duiorte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othaiyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nouya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laplei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatadolto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ondeia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olilinin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geotliero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Andudaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataneni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oucdreergra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sogoistenesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emuogi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rihiogiqy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoatlecreo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeolnei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edmeoq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilyihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ameraon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyakeanytro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niuio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdetoutme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sutiroyaper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raowola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifoliete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fetaaeick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coeromitbyar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoeisli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naoshu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isowpapeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omgraeeda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emiencoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apeondpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maoid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipwhoneelfsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irircue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roneod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Romepeeuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroerkokri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teadmaul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aayovyyri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chialupoogto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engaobeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leonstuatin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olisystredri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashiote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asesmopuore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Capunaivarip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sesce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adteecoxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esepeyukaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectalone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoychani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithapeyum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Necariys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeneroz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gleyaagpibru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eontaeoryo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuexildchy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leodus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlayst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oycevieto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onungloloom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puabi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mapoesiriv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eootteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olesstritiao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianeing', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itetaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyacaadi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeotfieo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dezoarog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eimiavasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeiriaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upooakalso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aantake', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utgotreac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laacacapdane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iespuieh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acyatiienthi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rotrispuordy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itesoem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oerpeost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uduryfemo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opaspuda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaintardepit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irengu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Codyoesta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reforuma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yliacleite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeseyay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eber', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeocse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arowigdoseit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onarueisel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chuaereori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diyeavi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opyneoch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilteoede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entialuidde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aantichni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereckak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyoengnenoic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniwanoarko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otpriolaical', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdougipune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oenooken', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anteotar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifigionvi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yacaient', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecmieourli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eipein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiulian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uceaycyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahercaonspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apeno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icathuniup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oteriatripi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehcity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naiaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toihtelumla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Layie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoumpeiph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oguibir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yexororo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdeutnio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Libu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fliow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eckildoliem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Quizdiifest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abniungbla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biyaemtiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itermabofa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuybgoga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiichfu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oecnirabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynoiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foicaliz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiigubva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yereraecde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleiseivi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naaltaitokny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ruraey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajslaipioin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awonoele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amuaklo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erocaordio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethoasec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preaismychi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deitaeathe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyheaphloi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shoanerillny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tosteyoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyinomp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viefla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laadasta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayrcylord', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enaino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoiliul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amlaeabli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uglybio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eerehboiloc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ececheest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uttbaelenu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diadinopun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypmoaerkigay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebuisusi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iupiato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiltupexi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umutraaytemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiseadenge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ospu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uantbrecla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungneetoetmu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itrieem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tauall', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreshaortil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oseode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciaemesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eriy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erpite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yepayaab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oilae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyererharery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Techaogdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unieomea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyssaka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aquyhreseof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liayreinemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caefuver', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indabmioctea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raonabvio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yuteerephe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugenlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonlietib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Econaaej', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tumeisuath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etmeasrineor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haercaneluse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otseby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agihtazepis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyrideier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieitperi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaoenkve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mitoot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoneapo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choric', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogumte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sceno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nebosnoenina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatumanie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erotcosera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giewarano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esteimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umictisy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enetre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assiapeefta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogatapale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oddridyit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poeika', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyssai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehiuspyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofaiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyouambi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteingipry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pieehreebu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipaienio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phetoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Milieraceno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emacei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaybaopla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otiind', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiienotra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleffasidmau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preinspatei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iegauoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hemecocia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebaeper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyleteademo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sporueaiqze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angteine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oroizyicaim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pheieaht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reulevein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yukuecyac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dioru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gutoia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayadnanetru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyatabu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tedhokeoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toerteake', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eomam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Croe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yocaowur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raivue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umoboce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egerpoayon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaolchoea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatriu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asheyetaist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aruaodbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utoyones', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaseic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyeutoabro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraacoyagra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fluyot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyunt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umacpiflioli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismeteosm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clatinuphiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phevaorase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaliflaotre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaoiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reochade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odoper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inidgaodse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izoeabadam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niaogrier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Frecoepopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Titaiisonat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bieyacolian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Equis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Whejuid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apagetri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afliad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaespalomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efilothootre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yawehomisail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emsivofo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pacaeeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynehiudsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saifisicve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaadmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Smiohao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yebireufune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyneeing', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eewonce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretiecki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nihiadeiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipuowilamar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeaiza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiasei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rauogheyau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awcha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugieulraer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seowreupei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lanyfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionukagh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nisneiry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ratisiodon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alpoeny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aerimacit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryfliind', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rameitalfona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Norina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yitrewaam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afligefipo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isesyeezsho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gelouowix', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aayrinanie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elereneprani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithreupanuno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilyisyri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oapo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oifseto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohichor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiiroke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ozbyramiyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aexneiychwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoreaksuoraf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eobeane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neetiyoodje', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efanabiopho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keesiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viiang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaspebies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Natii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nohuinio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvrayigechi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tusaki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuetecu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acroos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icteca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atokosawglo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Into', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udangatomiij', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oheonsoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abeacherea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nearnte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ussomiscoeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolumeole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiurarai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owvieminrom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ninoeurru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reyntyooe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayoig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pristro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apaesge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilisechonebu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ascakyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yhto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Froackne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isesedtre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Swuatit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fluais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lieiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Recoepcoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoiupe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siboienni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raeiga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urespis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upiatro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gepaiotino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Knejuatlus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atescatopa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enerioce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugorinort', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oysti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eniubadatey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hefreisak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elvesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enokeaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itcha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orewrinte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iasebiarm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniesionbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arusun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iarheioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichotiold', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prareypmari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sqiemkyigen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astriowciam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aulossicue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoyeatequm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Triertoinap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utedlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nereoiiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaitli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naiut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uceproehip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eranruomin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apariselaec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suyoeman', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isontbeapung', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elspie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yenze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isicypoto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ameketiaam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isalpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tienkeatse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubutarahafja', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nasioayonad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniuini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miofroneab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flamakeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edydriuucho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuipentribly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edreyrispeul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untieup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseblioinso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itieressca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umnoave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eucymywa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uthoeser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Escoyeyie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loyamuperi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieromalwie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sageiopri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speureru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytinesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianineie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniyakecreal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickneocgeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovoztinitire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebaniyodoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nueremaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinankyaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eodcaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thatat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoistofa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igniatildat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Qureki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onrenefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noelalopois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceongbeilvei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abcora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiilboa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urellinismip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Museahtimiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edtroina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yitauy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uotol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataondduort', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orteshayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aterrene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peibascanir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iratoelei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oireivtou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iceou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esaotou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubugeteai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neranone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeonuniyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enfreoncoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scaov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ruahha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Modealasud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiyaefay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neanuuroat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dalaahec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertenorutile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyaebun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iospaose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onuiubat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dexiystuue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rosareiit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocloekeuleh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeetarat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vineeter', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inebra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icoepeleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esieo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puitwetoiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itievdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ireheste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoiisuyty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essuedalis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ortiengese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peiericora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lispheomab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiopuleent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soabneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auboh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iormeloal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maielele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raiyen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arbiired', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reteseoldo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mepeyeameog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unompasyyno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erble', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueolu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingeongum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yliaeytypu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neakae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebeotines', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyteisliu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereenientla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essaicaonkba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neibonyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peleraol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rebleopda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phagere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uenol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mutiaamra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Topseiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteary', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epeulutiof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onaloault', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itasa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ononoesm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nueonyh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oakaladu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iwkaiil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astuedinktra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaoxpy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichaisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echeir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Traely', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ignoonimera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retiseichbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seneemivsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efeatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aderyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ochirheydge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysseitvoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umesanereom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onetoskiol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evecheut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aacospeeren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyoieoam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atetra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urovean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omirititar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reidotis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uckto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ullilamoie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duteoniladi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheuooyower', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anieaas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emunihateoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pudiilesok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocswo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiorcoontty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neigusu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umoipeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asnuoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aladkiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istieyanal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alildamee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucdaigroor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ridaei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroabrega', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Snuhataatugh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etatessoani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ortponare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aterliyermno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edwineibuti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yumeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abloyg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raeol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usisle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroguo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omereyhosti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noardaeth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atsciriye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usieyeier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rayoreme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aieoul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ormomiis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeyrii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ancuem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayewluaikit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inincatpre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idraena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nicagaythea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyebacka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pyiesmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoxavbraa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usswi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epdepone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erissiute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odilone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieresro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gusawoleime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enproty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isabetaeomp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeulacnousis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alatiayoyre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speatog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeitait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iisseartfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryeiad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gianebois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keabicroo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynitdolufne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yanispe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecagte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noriefuonva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gieresocca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acembev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesheecuthir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gruionitvu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayerter', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eongicee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alpoyra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeromli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fepeaim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilraorish', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essoakspee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abodligaab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yriitbroig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elyecri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antedog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buowatne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecliiweni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shoeaort', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onindseost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asioder', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rerguyauf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaudyaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tinoayra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caiddufoaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pearisy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheanamudio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Copriumirn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyfieaef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loeypeitrio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trionto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'User', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asalxan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itewokiachar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cotyniivle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neantro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oliteir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utrour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iplieiwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichiteidarom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryeatnaoyis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Slyoaboli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echesianyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itopayide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omiee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veuckbo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eman', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatsha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oldearyb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eorsku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Titeostilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esagugaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anoimeya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roescrieloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiminosyty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meamti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laiigeati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afquyeseeyce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaikriemat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opiaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Freaeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Striolgo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edaitit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iveli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iturike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wieedadie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aclicluo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeriurimesse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acistag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atbeicep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aperdidopri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rinelaroye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aibyfiley', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aafliadcee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otyoetu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crebesiiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraenig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yinesespo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Galacaamtei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reruglu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adanoybwai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wilenuisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oecy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioyandyie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retroalra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okeno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trepialu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eevoemriel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afiicariig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liirabru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tacceise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifyetriroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishepoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeeptean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aopynucau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateuf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evistelkareh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyimoduasre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungroeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icemaypa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oangmeieri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ygfioutwoug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaycdosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saevelecio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iapiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shotaegaan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Schaci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raraaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iglioihoid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlioageorth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyolia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuofyerbliuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytaansoesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loolinare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piydoslady', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eurorifgeste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esnojeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amleontesmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuiapit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoiyare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocbeypeiyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xaquilavype', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poayse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teraieritoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atieckwi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eritis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amoifel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avariolleat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dicoocsoraim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enaerosoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yamoaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teagedao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yedonicu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fepisedoual', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiemcuucle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivereicagha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogeseuedeth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tualerocabre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaalbetre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oylayro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emneataan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oposseopcaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aratriathiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiuphoowsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Craeshodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oruoxo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchieime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saacreoiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqenmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amindi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mosiercleoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oorycoana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieebyiosti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imaipopoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enasshaooy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buolaliral', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maeicea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yropreaoth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echesao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatveusro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypmadeplema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oizitangipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieykni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oretsuaton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goonnei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atleta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roryu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ropelead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoiknyloi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olmeic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hifoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idiecifard', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doelgioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epirofotov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leeaberuib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaniengriot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lerooebihe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeicsaobya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iducae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bolod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikeiicentne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatonufzao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Viinecrenoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elonlela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adrieumy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atwru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uruickposhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eifsniu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aynuestismur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apasiurn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anuehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Impyrdatazer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Groinayina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Watruyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kuolyroyngij', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amleemakre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estrieoig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angmiingpro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sueyeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nyelieyowti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehshoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseissuub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysianivdiis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daeromint', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amopwoissexi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ighluopynat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Terushebooi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amineul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xaisenu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staukmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tifothoad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Celene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anuikab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geooessiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leeche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iureytree', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ietuacao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inloele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Selcloylni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iarilumubis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoonhaecesil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolesooro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deweit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roalaad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibalypeare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyseaichaop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istiahenei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naeresast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adocoke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esubehadonag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyiunau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alidehees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uesteyoserne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peniuroile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engatlin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nasaak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echcecaef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ande', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aevodeuawn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thiomreiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peysithoisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Potiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rydifeayre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Axoatutrao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeyipliisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealopintheey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aciucharoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speroouhca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eauloctis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okapedarcli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gudemoyofuac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anmeia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spiay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoseuarpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eube', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoternossu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eunopyal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guoniusebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoeling', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erieupo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laerin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mepial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeoging', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioruedni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liuresso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohuiwnoeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysiois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yotient', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Endeermamu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Synereeplai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odanduro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesttimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eerewao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Redroyme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haytanet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auima', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeyaenmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amacaistode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyinte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itpoysna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poanse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erklirepiyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayoubtevewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereahohinche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectalil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqgroli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cusoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efagho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ritwaadras', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iongbeid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exmeaedarla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiertprete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oisnatdiur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iranireoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rysay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriegeehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haisese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aluoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nofiabasali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opachtre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gelasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Treibioh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibilaopesze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieyudcito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stacinsubais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Truatyeomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymisiuyag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agybeilbepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiyuaeyem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inermerica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inliorofin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulialolones', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zoephirape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaerev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoenimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etowhionsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivamscrostii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stayni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taeleiben', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pinosuaerwi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihtid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neareire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alielwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agamcaac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilybeteine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nainroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynernguo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Placra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itogliea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inegsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asalarivne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daumoabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efkre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inyeocyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staeyast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onhat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehcoipaoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alopie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdemeurd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orlyoesutco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Endulaniging', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoxoeyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiecerun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crewar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nabliophao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aahutulrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iitrierenay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apendinkiala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoenais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maoetul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovoarieu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adeabayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lilaigrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiuat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovamyssclora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veueepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alciyci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioeta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Needth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loassale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleburasoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achyoochie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eahike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orycescloimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Glabinome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Affmaveuazli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soesex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orcotyic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peeiitado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebiciuingve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otaltichono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uarroya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otofowe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imoesmaclie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mipituecot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ablieqgeulsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucseo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untguboti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoviogatde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phemiatessie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reabine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uritarcourt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inriabes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaerifu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ariay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otsico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erbeinse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idedov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Groicait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeamurol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saumexcait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itauedian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeffgachi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ackeete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieyneoyoci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osmdoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noapi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niuone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fietcoeth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lireesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agsloinit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onayantentae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aemteoenush', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieueu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nityeetsisu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nibrobo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obyaeahemco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atucoav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheagianis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abeusodaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useiungi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiengin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovaibnaad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eshneyoyumu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilpeupycoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesimpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uerkisopy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itteatiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvsierore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raarycea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryjeico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engfruowi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anuchniutis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oereroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubuoneu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omfleaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luiob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umrapreta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emorpatiry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eovari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iongot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aifroim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uciyany', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashiguaelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aygi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apvayrnaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paacerilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noimloitre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ighy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toiteantrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pretreen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siive', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitaplymo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciahamlein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Breluinou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idaron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoiteinia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igedipourimp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indpyeesmyum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alosahoatye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehschenolpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sceieesca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseumchori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isygytuesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ampeuche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeutkene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiflioannera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uofiuwkuf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eateyeag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeorayeef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siseize', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eieivein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeoentre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enpyaru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iebre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urpese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erasui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Togiycunto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmessonu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giotha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytetoier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayrain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheydoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isiset', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utigativein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umfaayyirosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloorno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coahwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeneitaab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uzeuxatol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maorpiwione', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eguamahdaic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onacard', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riliessuca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oakior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opdeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayoyakeau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epreisyssen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuzelalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woeraluia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peahpenaita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isereyec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yatwilaale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibogog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iniugoypa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymavuse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oberashaei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nezonie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickewtuchi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haenizru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neteyusossi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tealkaroya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaric', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulayaierot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upiechoesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tapuiyeil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toheke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eihmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aarofieok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nonarayenis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apviino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teireule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syued', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymtrato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erabidut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayraoehpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essfeoinycy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Escoupeuen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soneni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingyostre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pepsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upinyist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roaboad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fleevuerin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lawo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enuziaj', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateruleoem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeaoriege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryeilfoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofatte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rairmsepocin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeollaesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ergaichqui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyomunein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yenulline', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ophianic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enoeyaytac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueuccuayos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdiok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yafoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungentiist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoessenin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geteamtea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineaiyen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufriass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shuic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onalti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eguearty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaneamoach', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eardoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeuoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aenma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sciyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nioveeco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riaacaenmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vopraetoolet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilneconaab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuaoctadre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eigeyterae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chifoliee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caylciiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymoossuro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egatuluce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loyesluailsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteinaasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Briuesodes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bilari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isantob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efiaagoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gethoaty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilomeoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bibmuadafyn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainuesci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eesleyerche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piyeeyisve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nife', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ditiemam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesogiarey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baulesan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trekuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emeclaao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iliruncba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eapawuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekayicalgiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asinraacto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araelar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitaibho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoypae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isleei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arewil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indoqlipru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enyesne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilincuro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fiubraanpro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enasineolul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aselaoefo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maicoistsali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umeoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamesoito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adfle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoiathe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohing', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vaiaoyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uliepyoklyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycimalemale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiaada', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upyaneyd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibuleyab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewesyspoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esangoagcora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekitherendog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataaledy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leubca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyepeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deyxibituna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iziab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siaraeschav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imibmanetroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eusmswa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeree', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalmounom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipfli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syyemaenerd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laushosroi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icyrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiceghyewhu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roaotitha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imaticorayal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okacotytow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aliduktool', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emloisnooet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erexneuyou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icfrecu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxinauara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gloiwaeec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oivtenegyme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oonphaant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Knyaestu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aylie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethlieritio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rerse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udireati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Direra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eluaysuu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaicilunbry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeteca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aealiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yieyaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reinbeniehco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atwao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amabicesgefu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araolsercra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maialei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bleiployga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esproe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oheal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asseyayle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uatishueon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iciine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itunealsteon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othiondarat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xaiascily', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugeulifare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleiaear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiseopkno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lautteenop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysgerpak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseucrais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avosite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivpei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edeai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abock', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogaiore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqaevaszo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roluit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goitisniyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tynaolyme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edichaeirm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileawexle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mimiayeno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Besuaog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daotanyis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atreue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acrosuiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gailydiuluj', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oigie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fyunralu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugesatoum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrsebimadior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aticat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olauria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scoedbrica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eogoaita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eluoatsepla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etussnedeile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lenaexraesh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meprios', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeycpreucmu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oukne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mialelian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lionian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roindebike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aechiadad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeaab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upasumdou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaerair', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neudtaut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pieiule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uticnoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lericaity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecsucoengce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatwostry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeahsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nelolelu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olerdobaoeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enunen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itacaurgre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Telioeff', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeatehreeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oqneogumoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empoyisae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aanreoteh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estcro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orynkemeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imaipyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Monayr', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teiteoplao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acyeyteyba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Freaego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suameobint', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaylnoaryo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Whorupyrhoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebieffsly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulnecrizyur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyeicsuompbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oynerena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enolsuaman', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahlioabat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ussacyeirve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omesiatere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agorid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asesia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uptoetstepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oceeurea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edereiqin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iirnaous', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ielycgoest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lipeoteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efleidureyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismeraey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seisewpea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mabi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teatares', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Palaolali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niufe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nayzussalge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spouola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naerra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoqlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obiahchuriar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onrieacscu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opriogioist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inceopri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uortean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ensuytyean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loretyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyaudsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coeckgi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealtruciy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuincloli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeyot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abpeneusho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Desoec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecytuime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouynie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oynuilmeprog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lilioantatse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cleeoblene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaebe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icresoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egcygune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egackduac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eclioybara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoeibne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Optatealo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epiguseme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umscrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egelira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystmahioayti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riatef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteceniahe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Necoeste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaktolave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otativinrira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odolaranro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hasomeoboht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Schoetalepry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyhi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neiothesibay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Straideune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Metyloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyeb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assamivtinu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingumipaeste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urtnemorewro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyoas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aouit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bypaesae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toiorthi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moayayn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Steneaig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eciltheolste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipypia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoleasya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intky', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeacauopon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Althe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainleane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liaitaruor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orasicime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Areadmeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naisbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erpichoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roimeton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omayageossug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tayalraswoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idtreiess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iurylitre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omayphi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aboa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eisybote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryrlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bipuinara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Revapaoyera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoyloby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Colot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Borao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iingiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Popepaliti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loerdiunse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iinine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hehi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meaokdithebo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nedaico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exyssaltele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laiutueston', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oycu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urowackteri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iluoeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oladraze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roawimgurine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdcostalete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eessossildid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maexonexno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aerei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eftsuaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nerea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoliand', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akconeaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edagipva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acarkothgoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifonassungak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jokeenacke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itakesiness', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amichogult', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caomongi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealavoara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elostaenige', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waerleicotme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epeypre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abtiowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nefedwestri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asactoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aghsesume', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itraahalxoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ozze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gebiiow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lekieoati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewoaicutre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Else', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Altaoho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spoecliet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isentrenoiem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inatuawe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enludeoyio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Solaentoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otreoril', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zatoerois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teyoto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogchoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tigetaapinus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oerostat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uobruy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anotioa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eizis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toului', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noerabeit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laeric', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianeoud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adalitos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoinrenorore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mogu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orathiclaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utilhoumci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuilte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erkveke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goneiel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeangif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gratongio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nepiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaijirdse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lagrozina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oferieder', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raiclyalip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pecoabon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itosin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orongpuildi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaiheupe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unkokulo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iswoirilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atebiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chiesanaxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyoyabonspry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isitsheti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icdroenam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaonehopat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereioesfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibtriat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uotree', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lieolieniz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wolavoeyazfo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogelarti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihtuauutgi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poehopbeso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yapoao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opifruilesy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isuniddeosy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mestamia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antponivierd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etorbiaty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omleungan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucinanois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haerehe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etushentlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urleiayat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiatongonin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teryeyee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loesem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeadisin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erayohidro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaberae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bireoldulees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iulnikema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertiie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usvyolab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uchur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ordo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyeictea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uxan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dedierreuti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xyocynade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awraevup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eovisin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elatoeocan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onmimcenei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eththomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Weiozspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olaeranax', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moeei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibruakhaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elasiaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiesantey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaife', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Motoyderniit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipolernaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aysafeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubiod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aconmei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imgaansleip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odociho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emehatiypi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uloeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iehtwio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esmmucoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icusaid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iddexpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utaiuga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ladoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prohylo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Winoabtegrao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaojaiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoffi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehvac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohoyodojesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igrau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nireolastula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eprufusi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Catiiere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoruiybe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tichicu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatxioew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeizriz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myraae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utolica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apciane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coloutatri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Proabraict', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iotudiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nitrobeosais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayreano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oustco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diatsutak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uniia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aityhush', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostbiamun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wheolee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saecio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiluyiiluck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yshfri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caneontere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iseryblaed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoareab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongrohip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oywegaelyle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Swioyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oael', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asententsoqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udussoniio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oustada', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Telyep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essanlyeoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiroen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ravemordar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaismevaonti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edbointoivso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irianoft', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anwai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veuenaben', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieleiatno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coaprorodo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Retre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phefaseya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneipsemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoyoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stainetesibi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rayiodflea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ackca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owfioroi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretnaivoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Errieegh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Turaorenin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iueshu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aronaw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anscry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyeneysena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoumem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Striustiul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ejaghteab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piifmieig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onachde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uliarniomath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idoxteorcete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibunaoen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idaetala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enenogre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bamo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oteyoapar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Endeanipet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecaiitspeas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taestciug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ounaliep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oerboteit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieyengto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uorinphae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Repli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paepapakia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seyrig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emyeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amuancheoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Joame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ribiyhi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efasiam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teiyainew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Breypearisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyuys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahilaucusti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etefexgleoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aecif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cayorocioyov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onelinifor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rinilio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeuyaypt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloapnela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hianseit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostetiocage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emeniuti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooiduast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aweatyprol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onpihibanglo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reuterminga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iinepo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siproweire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesteselua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifmascee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bakeclemide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiycpue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eptryseinier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niysmtydeyom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isohandaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neayamwaerre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iraaina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeesni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pirel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miorth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rueost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eierwece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aichyuseer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aepyaetiko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tynioktuneip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aetsara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeoabis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erktecoisri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nefreilarma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiatirden', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikgoweic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izrenediflo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leandekono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poamy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omeidswodise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abroese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heieconea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loasoytiiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orasteca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rutryeroin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxgefiec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Demeta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yabbruseo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyplo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laatnaixle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tomeyy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtioidya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uasecingut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyusro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Losaoengug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebrakeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iasmont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wiyesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apigru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyiupinseqi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alisasak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoumig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astesapiam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leulrinoasti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecmealheum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eacutilkeul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oelanymuneth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irtflaeylyc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raitsape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyetipemo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litaoaxit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oineferda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liinagoyao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unyoelro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astoypote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vude', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erevdo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atatruier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oemenaent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intyungre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uneoncii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onospeaanir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uecigerem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naizeip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iatymiulasp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nioludie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvogumi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eigabio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rulaneco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naierxiedof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estereruce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reilucotoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iarie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guacetierfub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eleaam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maisalimys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceayloikzien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nanitalscru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yecaoast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crialcail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peokomoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liealibiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etoneihod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aptebindcete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iofatsalaoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoeem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utailarosle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beryeshryeaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehymasity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingyoalissi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sulesto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyej', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiofcata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efeigtiandba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owmemase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecetsereaib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heoaodea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umeduneose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifialreo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaaryi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loobesepya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethava', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ophearetero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roeroco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heuayana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imfeyay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aykoumew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Risiatomta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inerouelni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zereyeeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogifa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wapishee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongedira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lagiahachroe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ponila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anineiengy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seiep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paimtofeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Setuogyc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocsty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goeira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taawteip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ireyesneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypealri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiirkotera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieibwane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niroer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paflocooea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avolat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alerle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oarooli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atpaivrialo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caiangidmequ', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ownen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aunkocu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyapaea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iselreeyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isoneroayma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yevesedoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aplotebre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bokeishe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umieder', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uropraot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unitiuleeft', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otokienit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipirartte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Articocamno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uheifaity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xeleenafi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cokerniuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogofru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duemphaewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raredieroc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unehoay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bomafe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Macaosiho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etilitrefi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyodci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyeweyejatra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echesiost', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itdeoyangie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edeoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystroimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaoniossabre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etahti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nesiilur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetuoeeft', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayleeramco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsuatyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismounusnanu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liareub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gryoyng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iceyma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rauyeolero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kajochyyoido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiwaonira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofisty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itpoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icaozhore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashnandiyg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esseatak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emetopti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aerameesag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogyonosirndo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umypuxomeen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Galomeattien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oabuduethih', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imneniomei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izuspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaoenoct', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engmiabru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeneonoik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etpoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bapa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esudraoig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyeswougis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esleyswi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erihuac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Troyosealoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Joatagpuil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obtido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossnie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urosaiehy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roteapinooc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eciirne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaoperyow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peersecyrou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoeyoploin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongyuribaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teniesmaican', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Twichui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rasarkynal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ixecatwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoleey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alymenub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsuraurtero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iscreontya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maumodfinele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eymioro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estnoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyanete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efetoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uynidrisein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cieia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usobinareo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fanhari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idsoolnaode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiecreoas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sechanieplea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wiesseki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waisef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abtaenboe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neilkese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sliokinate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caceaumeyb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Slitieyalore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nedu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awalaia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caesemceager', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yevmoyeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duuinishak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yapupfaono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucoicme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tudeynibroge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odtewavece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioniaqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Briiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bigeinool', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostcozey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onkaifpisho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orlegiipar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wiitina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eotnuefapstu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esebieong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eotei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acaesteasy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etetjaoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shekiatogotu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brinepaainu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ospe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deadiolam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giospoah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aipodraronu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trouyemo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooiausso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imhuecagu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxieck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aclarelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeabeate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrmnagoeson', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieromo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocnepiab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enmoayet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikiicol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaboleici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zetiimeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diruat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otieralufa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noriorveuti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohmizeuberce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arsicatelu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecusoonhiel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aihiorni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upemcuao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thaumarpei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wiplopeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ielaod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enyoratnean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alouwkiotwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eceliailla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Camia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oimbarey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orpovlaapxa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinlioninoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anciental', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geuith', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baprenaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoyoontor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouveokho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Capluteai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roroea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niugra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wiamatift', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukrisaentze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etioseno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erbuoewiog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyeyke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiflotwee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acuaydoscoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enochotomoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onpradi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epleungay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Relowe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ydgyesco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Remeprirade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeoinicpri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seigeitet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litamo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teetego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fleefyoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ninya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreinstu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omouvcaufu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buarmuse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stoicne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arasit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoachli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ougrieus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Psocuoge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esormeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewefdaelkio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izraoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eralcly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erobgicitent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owogasere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciruabrioyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riash', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etblia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyedib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieiilal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayroreersto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apotiauneth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doeoxmer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rauteitidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idamasolmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Recetei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neibul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieicsee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuiuer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lidloste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omirieang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoutsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukuacnein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mutoei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oadeteass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofoly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etmieiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rateicgeizo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imorore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tolaernenis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loemtiirtoki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereaghic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orreoipne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upsesmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iwaonvecoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erutebeid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eusiewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diomtreoip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buloeacre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogonbovari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iltaneneyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipiegycyni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oapiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eesmere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniciseatul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akshia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inelciesep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olesynaue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lemecryoam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieyigle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itreeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seactudatme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxeoayssish', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mapheebati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pranetui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mawoisnaraac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmizglacosy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scoruastne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arephi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Praquokera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebepoackopdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naeov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enuuottio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ausalene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uefyopsisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Frainoeegent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoroin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tefoarjo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oawyroga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oerlieve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tostecoassre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iotnininosto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tybayeinat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elelye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intyuetofre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soenoramer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ariaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ochystpu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingdagier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imstretheho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Haoyitilel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolyhta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uglirupira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeoactyat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tonaoemax', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onissosmaare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noceih', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ojruermwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishryatatlue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yngup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deetlo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kieodu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoumapre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acorase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blamam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongiderswipi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paicami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fereiclana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ectaekchei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leleesume', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyseamla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehiepaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaewija', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishuori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Glasetryno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izorxienoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idaniyhyui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lougali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ontolro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroltufois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibliu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ephios', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ardnonsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irotiaoaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laromecufie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cepeyisen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omazesope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neatouoib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fryintineip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olarthogeow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etawitiayit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gresieid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doydointog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enuxacoess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lipasabstee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ojvetreheele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eigiluler', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeonaleyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estclyideoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yenas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epiol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertada', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uafawtaasti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acrialipamam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odensi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enuindong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Delecopro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaatucine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionynetaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lesura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aratiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chearonuart', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egoekate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woarpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Almyfoyele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paueywilo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eceilagy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atatuoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Faloaaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioylorane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tabeabrai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scoyekdiiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miemclihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiarneluupre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iguleawikni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iulra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroacowhyen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enacakintine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emigolou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paesrachic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubisin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naicazar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucruoylaepli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Panur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iascaw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veoicien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aootcosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eecreplite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiuyya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuhoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enateulachy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Athy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nigemalipra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Heafofeid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertatiwaohe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dimeonorao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivoceronria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elondne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oest', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Netebinie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neenotesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pootasoivsy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionodyekif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astongonurdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anilitdu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miicureyar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eptrewour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phaoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nemiiepifi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikewona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yffoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noeruath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaesherang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afscheypri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Detrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isiengeerub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geeliongeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eldehtim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beotaool', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyinoprioni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oulay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseeseleov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oupidatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orstriwamauy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esgealown', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyiamhy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtoege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einauma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yotiyaresum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitoiitri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eresnaetniya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deiyachyontu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceizroioam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atcali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etimytha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsekeuei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echediefyna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shuisie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emenetilike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atatifraya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etgobun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icoalerle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dwineisk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipitigpyna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyteiucead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speeche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veneeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efengoiyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niytdiva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatreraead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eerloye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paesicouet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idetyouo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilielpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arsue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asteonali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nakeilirvu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esnaeeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keideat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sniyoefluiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Socroyeelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pokliacmoori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineooro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asostaesid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ielsoiewyg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teapous', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atindemaide', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sinsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ediapni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lecyanagiha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sireskuyilao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elalalewpede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewnidwinoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tipsecery', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caopatcateir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaufegey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chaentakloo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tearuaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceopulnees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anmiraz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sabi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eogbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cooctehyprit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceoneifoic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymedoriti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eurerifo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niypesmeois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usondca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atetizereol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intcaou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Weyehore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaufdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooaieul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inenoyreect', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isrirua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uprab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pithetiyspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iluso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilioerar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omcheil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yuermuabywe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiereeoda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayabigeyis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scephicoune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omcheoctilu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meararta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycuatiar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reroitha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issyupcae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeitia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rotopoic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crulymawiene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaneruaw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engeriyiom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilceuchspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pruosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ancaalchievu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashoaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moumianno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anliavess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aehro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulifaspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Drei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niypuisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebesillora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erdoat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehizoyel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohorti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaytaene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoasastor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beayenin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aathey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seeomesve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owyayioa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inteonspyid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laerwadies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroecie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neinmaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugaondoor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucfoyaef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aashoeha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aldseifalrae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doemroep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eopthodra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clocheay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auranju', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uuop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uottayoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaighe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teyialseit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealiasta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dezatoensou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peubo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etatao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Userodeoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionmiety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yinmilea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irbueti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ophanaesajra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oainolin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utgeyle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rupano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edaingu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oabita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogova', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lielhai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toebliomple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neonerappoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icnoabesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teroil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esyoyoatan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okaulatmibla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aphuarri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouomon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eomlaeser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diliepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eristiopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uneyearaim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rareaile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isnies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecitaistael', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeomioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unusentinfli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cowirithimeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agneti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seodu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olayoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gepulieoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esedeen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineyage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asripea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apalu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufraige', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anueudcuiq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taiose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vesyaleit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulianisufti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyarwiep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yitenecio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onasitii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Priaeyoripi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urisutepru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaoounird', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doimrasachea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eratobe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipolydeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reecoyr', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilioteea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileilonrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Necrousnerso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roetel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yomu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oienupu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Athire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asezepiele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miaryop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laonerhene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitfayius', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akgaaninore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceiohi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bealaupeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rioeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izensi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coenktier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elacwoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nogeibafaner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Negiallniqua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aorloeumli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubeuncole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roathap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atedymcaur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiopplio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iossaurec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Canulill', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoynetebaag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itieht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aejo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theoaltuared', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ento', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eolasuri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atdioco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brayaapveat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oemam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raovyela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seseabmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riryessyal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aamsioeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toiutzene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usstraerely', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeifeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaederey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Endnamanaoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utaneceo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leonsoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rins', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oihao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abpaobige', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyeifloosm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siilusmolar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aochya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teissiedatne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyourirei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiicoemaob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inonoani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aassro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laudlicha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roubaocrera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Namiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oasirt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmcymuicpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oebriioin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Styneab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adraiudim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irsuseoity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lelaoasweol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eserial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nenegaelieb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecagit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahbautay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yyatauntpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Failiislado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inepiace', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odtyeyeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thaitereani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oicxiac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itejogpuxaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stoata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enismido', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ideteuns', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ukitausglo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoanenadspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reacinta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Supeamiassu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scroauptetri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edoaeduan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inrotabpyke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oweadu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoarcaute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izoilidihtre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abitegumy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Charaeulee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noaialtopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udlygycoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aceokno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoadcoeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elyceoneim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoctaele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ices', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aopchiseot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuseivaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riaeizit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bacoarat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voneaerere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iowy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eusonos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iarivowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meostoave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Linerer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ystamia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uasetatei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucrabi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inagecoefu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isehun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dorayolyt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aenyyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayunin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceiuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orapereike', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahfoamee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lieblaadtro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lifouesour', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umdewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyangniaodle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brytoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abowfiex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oglior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iengaoyua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eauvua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eethtreitre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alsiub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolosheireth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineersea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ralume', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynseblaenli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lirao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaceedamla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odoxounde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fueipas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miubwiiedpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieeclai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hemyieowsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Letonayc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caegruelyid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Draeudypra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emapsentifol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaolaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yilewaot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leawyoyiain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajasspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atnilaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuspeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plotupeiijti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aayicmeiber', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geninigryne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Colies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sheeae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Priangitiryo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yneanonyeny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifincodiop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atimelyib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleetiaan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apaatroeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oenemgayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohhyoab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Answoliae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raroron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cauhetyre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phioki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paiurojo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibclaniaemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Macrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaseo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yengilomena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esheid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itachodeeryf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiakekciul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoumi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoewho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteulenea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osuacfuin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isatumruyag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aayaces', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chyaracetve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eexirizrile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otierkiub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieangiige', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyluapao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lidepryaster', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Titanituei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earnies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meapra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teisespo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ixwadia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yesaigchey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuerponoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayuteecgaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeroare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uplaeongya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrseaae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roabreele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acicine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyaosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioicibe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adroatitai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gilepeae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocisengiayga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oetigi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sounrieer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyifucnuni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewraiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ripoendy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cougistli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dotaepoeyem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agacread', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puorielat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyaypaieh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungionea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieaeya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maifciau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oenailan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqeeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiysmniovu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omnieama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iscay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isengviad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imibruedsura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nicoeroyui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deserepino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inemte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acahoerpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyomore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaluf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acboerde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaplanoin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ruoon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibyumiliyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euanesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryemeifaoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iloapylap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auemoee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cazastoteblu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahiareyre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iodlineoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esafraeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geriusluese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agotiricniex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iveyaatny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eslatab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zelsueh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omoeuade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thylepseuch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eniem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetiobripi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehyoehdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Metepaso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teclaspeudew', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lazupovi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etibievo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tikaotel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulpeacsui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etdeytai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciotrieyel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igegaadule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toamcorehep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rispupo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreimeode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cretwuac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyiier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asyipotnoah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yabbuwophuu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Smaiffaicin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exioto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickienid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifepaglapmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caerveadre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thaileentsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toeapriharho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rarep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otayala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Octeryp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otasaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fiajiyear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaeyeoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sculita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otanewians', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emteoodsee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainifoweri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adarulyc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theweehumein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aceni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toupiroyao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obroac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tethogea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertyaop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piroinog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oppesurani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acieaamco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruacoyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onubarthuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yyaamuoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creerisna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiyafe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeexfyar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyopiearar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sinet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blionethaoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opusandeby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucphiarogwhe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rekefeflemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sadii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itiiedoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eytiathbula', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stediaclov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daiapenti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ledelouray', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayretarera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naetrifinu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onagetie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Steyumi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeweam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deissenasat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meaengnira', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiocora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Letaqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odxyeteerit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doertz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilyocone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omtyngues', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahodanyan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cocento', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioamif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enimiubeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inutundyop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untipety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umdeoludtho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gitoistyhon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asaesto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pheroau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogungangaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eldiosion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aovep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inheil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raonishyenya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oalite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omliolre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ororreiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Troepieroow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cefuanobeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kemonaeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veatre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erihe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urerneaalat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Praisointe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyngegn', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aegisitat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyateflei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choontane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geodxy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Insruolir', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acphuomame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wetalenya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fatpetrayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taraio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeeresiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Grypaetfrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gokaoitcyorm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esheinedege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jirosal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vecitiyuke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohysewoeve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneesot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maromeoamp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oapreepuos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ionicu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icoriemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unoeassneso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efevepy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ermeincashal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooflu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meatopommire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pluarieyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iowaiciok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eragfae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iacriyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lereprasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iser', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atguenk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anolar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Narefiacra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiekel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayinyuy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiungslail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamostoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iureuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imhaeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kiyoegatmo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipialiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seporayge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edercoell', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nearpra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohowancez', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teeyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uapme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acnedico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilasupgru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iogamteog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocenicpiyei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eizei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yuckleanato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eohmaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inetaulpei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itinriyipru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeicealsche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iadhohete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiogackokni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pliuya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Notaraiach', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siuhodetre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nepoami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adetecewe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atloni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orolteonin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lispewhiotro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oramphoitac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veatatilge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahpeepizya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acbuyenoulay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idirk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aslaeqapal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostonexoono', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oboe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iphuetdewe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayilyarimsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lioleieble', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecocjoeb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Claao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upbogeawplo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coatraoeln', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reicybucdro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vieorthleto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emoyspeos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoetoac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceilifte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialpiuyiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nepriaccyei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isagetoenna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reyeatcreeit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tadiobcaisu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echephose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrtsune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieshul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staczene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urupo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Midilol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Putirophe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetraci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofbot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Truatesorla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reresyalit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rauleye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifisaesste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emererna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oguenktie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ituinel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ensocke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muergleao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nesaururos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roalme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uouaidah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usleaop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eefnoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ischazisbao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oseveo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atumwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caoickue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aytuehtha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eantdeanple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yafu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Jolei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edchatraraow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruninoleri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nooss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iogsca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aontryuseru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inekabo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesamta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leseve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaskoninuye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oasete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olalero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaumtora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inmaliorniey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hixenteeto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieltubi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iendapa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aslacherza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eodanish', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oolda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oywarne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoifymed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bestaumin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dopaeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okoiteonli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ygno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aireayowar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iveroustama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uideibowa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eetostre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empioligy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaidsima', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sqeireeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raukoliacem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroprenaviut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acnesee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omalysre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rierairo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unweiatu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruntip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofhihewe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eocit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anesgypaong', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urnyieosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neucoramule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nounapwatei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebaoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqinieo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erstinaayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaunoner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onneelciro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elevliprial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raarcmeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pruatchurape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esyau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewesatoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irtheockamok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivadata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aktienoje', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nuhebyoonil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiabzeizgae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiatclyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocnorekeasye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meiesicrico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crive', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soadiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Manoiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creidmoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tace', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rainao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aist', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amostue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaishiyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atitzsioffo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coyocelili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecautiheaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyiru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Styonaerde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Averellasu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anermatuae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Undiabepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aassheoli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alsuseer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioranath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeocka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raulal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Newatiuidne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assyiued', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eauwnsteay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifnefigeape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Donapelye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vescrepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eqdacateri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeimlode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ratrekeraub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emtyaoulti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agariyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pastraicua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eteynii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingsceziateq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vieyy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hyirei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peotisiack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoengsho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chiogoiyarni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elekerati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bremeneemoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itinoeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oerdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estienge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Skaosmiverd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adehertecem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eores', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mearineup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipiedasne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raytea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Knaitulemroo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiealscilor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeshogteecev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiamsole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piakesmpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inkyadeted', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aveim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Timeiteagg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aehgeerina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiyna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isamiiteum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilapinei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isoseapatec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Este', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoawegipflo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otienia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Resmiqe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uerga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileouysay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Palkeuog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Griphisio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evemuertoag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eicose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epneqioipco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omicreiuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etsarii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inttiuackne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Soiotisfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeckialinda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geugrage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pasacoas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ydseidenda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umdoaht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Floenenaylo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ichei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iloly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialureim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ardteatila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyayra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intafisiaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaoctgegy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yilosheson', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omsiehtima', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epzonabyt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gadonaboiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iessnenyeti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyecadusas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tenaopre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liebaaeca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oesocava', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aikcae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Feid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trucarointe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umefreelig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossnoda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sqecatuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onlaeiumust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yemuio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etartityote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eypse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yapuordel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tespaepstene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tionmeveone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Licaibyesu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erornyia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oedua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owtirdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uopeov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyppreibesri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubxiaguut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etsgestrivea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amedruche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oqurouid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itismyssi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eepoiniyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulewiobalmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obusmfiotote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eibyonsaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxiheau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osasreuont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoesandey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iusto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vueon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneoodnena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roneayliri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duocat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agfloanoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rataysscesue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choetheave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engrholea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aihtivuch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seeyoapaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iruleacse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seypriowspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neniufiue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arfilico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismacit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poamesepla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeyoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneriloiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esealbacka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eimnicelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omitalna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usadcioti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iebluenra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eotyhyya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eogoordete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enarne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onryurald', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neameay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peseat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esegendi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nelugave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Creibapo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayorilas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilnynenie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alilaizo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atonoey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cucaesrionlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umpoerecliu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiblierbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osteoalha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiiape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atsini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aemaopinin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineineexom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siuziave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roocmoic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rachocheoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inopraea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atneimuntino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orelu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apoucameso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehyjut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neonyiyst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egakeiraep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istestyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulpeikohla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fraeleent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roawuidne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epunewele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tygayastbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omoamiahtli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syakbretriin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isnema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hapliaymiuis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rartano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coartao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciowitoceub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyaclu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untoopentoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apicawreerul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiopat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilmleaneac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayalraefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riaotte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raaensie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytuscechaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyorakielid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeinaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iabelaeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mierdeyeai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiasoives', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uebegatus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileheyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Athegerer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imueat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Triissisom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emaeiis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mireeyadi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utsidenva', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amideave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onissinsama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neeyuse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inochilil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fidese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aierail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emayno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Endenuce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poangatompe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ureltaolar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaorao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evcoyit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atkeodei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aojeoju', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thussedenroy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voannego', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteaivo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pareilyardi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoppu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peitbea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saetra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyassiertre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zearnikieste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giahotasuve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aemat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veigegle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Curyte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atfiraast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entsce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Covepruaafri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateniohail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahukiero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yininopeub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baigbrebeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yidco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saachue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entlean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saios', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyinot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroeycleni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uabiif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elouoruro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raistasson', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naacet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucenidto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ozavo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tissyveo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Voayie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reraproi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oapan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iedleiph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Treulaoatard', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oayfresiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itzuoleloor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urpopni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiebiiear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiatheo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uratucabynym', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issniusti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucinrepeba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iackni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asetiuctog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neesiaysico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceneroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyahith', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreaceon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adigomonis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraltoen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engjeati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enupculyrawo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipabyoviyat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edatutnai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonyr', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atulstoacwo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yalcheer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iataberdopu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Latruza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Flaoyraw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieesoung', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaeyeongal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aitneeram', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inuatdo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipriedeif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeteedaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sleroreli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acninphoesmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naoiphoghem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etuoase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loesag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynicant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peyoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spieene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abaede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaracaerna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yomaunesti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lopaoarpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ansalyngai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upuinbiopu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoinrioo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uioretneto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iumya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shofyro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brooroteo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sisetozelu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiurloecop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Earnoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ixeangat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Turupriro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aieveeyond', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waareruleher', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apcaerockfa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymdipyerico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essaichcera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ituri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saagresa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieuch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Node', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omagve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iflodaaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bianeraob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onamibone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iotluynsniem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pepitooe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lonayomum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akaentianto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipashimila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uuoelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uieagshul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apuaonaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulmapoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peoriht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oelice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saleickneey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoengooad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibusom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aophubearid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atock', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaornatimu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olothintai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sholaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atipogroad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noesiomryre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alsqislouc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eahaulin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryaleys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elealo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonami', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erraelzedeso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolsioang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoymeho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovilpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iwkaneismush', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boonae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hegleoogi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umriutovma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etspanaad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulregreejab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovayico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scueaovos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucheonayeaft', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rodirezetyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idtoable', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uslaifta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ridi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apoaerro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emarmeetond', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Azubetymi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyefyduopag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odyavimigasi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheileemspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anobedetene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Corair', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esots', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Varene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iroofcify', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uabyose', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ytsedor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoyeswagi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneouftfi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umismturae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lepoehockeg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ochucenotile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eperla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eiroria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etweeneanol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iaatyfolpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sleabey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doyoymbawi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nesterohoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thiape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yedostak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agoocudoert', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biceit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biysufreoti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erchomera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epuob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eypimine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orolcoerti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaolue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otopei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kelecephinai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oetspheayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idetyole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oagti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esaoyergro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evaeorin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abiarpoag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leeakscoaal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odceyoiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonhi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aerdmeak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dorudreesro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesoethoras', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ortiongai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zechiteeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awoutpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bapiom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Untriani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihoam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neotuyeect', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Allakrableed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atatikud', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eniosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agaostaec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealfnozaaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coisay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owbeuimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efaerur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astproghse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneuriznoyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fleryroeng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otorenraaher', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouscleaap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oghraco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utiomeplati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sepaaitmave', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esigse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neasumniit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sueyoitiyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Swemchaep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayerstre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieraltruera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesayesuu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyage', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odonidea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewhyumahati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keyegaop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neciwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateessacai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alabis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iotiryi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moilirseum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atpaikseark', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Whaodacenito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yfuacse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wyhiidisiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yraempgyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achrautri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iicton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Memai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fefeao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abeckreic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epneenreus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amooestey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iveyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beitishulyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anasia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amnaproip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Auanamp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asayobiviap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugjia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ositivemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eriele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezimav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maeayraazza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoaniefa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoochayae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maitede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Piaiak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itolysielo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilerite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Druvenatepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loniessryaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aereeki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieyayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyatbely', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aidocoute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ellme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icyoiui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Akvio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oorlu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arioiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amihtusfro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieatais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oidiptitno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prephazeze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epyendhyie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icchasimea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xibao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echiosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opnenei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assuocri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretofneipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nialtmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bidieraam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aetoneli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ischaboass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oangadra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antzoiomame', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bocrituestru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocinisiproa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upaokaev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ackyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puetey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eytrapylio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enveingogco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uioopu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilroahor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leteerepi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etunona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogeareno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amifa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezzaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyceyiah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeertalado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poraireind', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usmnane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibriainaber', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izocneno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofroebynea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeongro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fapekmeho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeiena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chepaazyto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rinieszail', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abyergestio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neangie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oluoabent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Luoypemyte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioltichida', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roinearreant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noaryo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iealiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Thiisaddyeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealiwaba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ultyiry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cacoichiko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obameso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neutaermei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaanu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilceob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipskood', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sneiszeb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entrionuchao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atikogostquo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehackat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poactco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inerpgrytelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoeyaol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onetaomchiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilearna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyechociswo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheiit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eubqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preueyii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uphiyiaroq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uatra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apoey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleanetra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anaibionyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umterooneda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebivgioayal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erertaeriss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spiatyueer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iflaupeaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyeyoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eieiohr', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amoilna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noepee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efayezemeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olyis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eseroial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emiinwaibye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inoenne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Crerliul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifonoaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipcuossiddy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lierneiya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mueflemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awnosmenrio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atohtitrio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moglidcha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engdrizarko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieayonaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osaly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lecau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yesriiblari', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aotontu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aloplotale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ites', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itamdee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eheat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cioney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateickiorne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Incleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riogeoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismalabtiaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assybeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ituere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opaiopeba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eloayten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouosmoia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omaso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoloweche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyuereto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apinath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istomvemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araesota', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mofriaowom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onaruorciyll', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olbiliatle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doetiodrona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maseoctuon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exatbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biusilino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eorsean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Skoieblyip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erurilernear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayerzoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uyaviattoly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xesieun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seyriorryi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iqepetaid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aumegeenk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toveaeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muarsevease', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atonsyltotse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upickimste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neondieiaf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obodaorep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eekeogeh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryveyiguock', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yostraolaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ywka', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yucwobreenti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bealcearade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noptuep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yfdeeceoske', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asielon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amejtoze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riedieyaiph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poumtaie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Torateni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engrepyerca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adyiasunru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obmiolomengi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sugeylunt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deicgra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isucateceed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Syjuetteabfo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peroyupru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icelry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaisomtri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Derf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umigasoeste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxack', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubroegicho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liyeioapra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilcaope', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icliismdifla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emfleoty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uraetat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuanes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elodeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tekeocode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irigafeango', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oitas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereseckeaby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niomacrede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyainonsej', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaniademyen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Equlwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bierahpoog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iogeowwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocuvaatsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icunggeiath', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciurein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elayere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivasniquleme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaipon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uliaiphstiay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onockco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oceraicugh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivaouru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itagololy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anpre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otanlieasm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stixoom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asmoade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoidanine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynotinig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liineye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayokanli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iadsphiuor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coreaoca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eron', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onreatcuif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itohaet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Staod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eckbuaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meaiicer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brausta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Marhoci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyiabat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itisto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ermuloreiph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atwasiui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eurtergela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giaeobirtad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icarik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omoetny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moaewibro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieneliteex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itemsteic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tenoehli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noinohaig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Conefoesatwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooititrove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idetie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofslee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mesinier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assanau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ellubeopho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naytog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ithibnu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riua', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unentearf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rupeetplona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imadi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Afraasiabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oroedidoas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anicarcrei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irdaryhney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igatev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rirearorha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boadatenshu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acipulip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reeadayu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leughchiliab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imiiotoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lebuopan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aliay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aashimyat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ysunoung', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yailerga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geteetogi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uvilaghayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leayocnoati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opeiome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otnaolk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipelaere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idnaemroo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ephuahuicmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diycisiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ierin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oruaiet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liaheneyifis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecpoteorshi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nediesen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaarpney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostreictia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oycroieja', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanaldeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leitheialni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sielmiirco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idsochiadus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uilulatheat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ginioi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sieeiici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alebo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otenihcoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neagumi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Floce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neehxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lespeiaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roteneryepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iderysoro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaemicsei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bioaewbye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pateaiomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iesastinraut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taowsucet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alalroleic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ijostra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Briolna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Strate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stuespauiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omlauciusno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yngerkire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aebemfimesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxnaockgrosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Litesslaleub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inilopeiro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hishsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniesmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muishaoeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onibbugi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oquetisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edbiyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teiesaug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaeluinkto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umeheoluta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofalipeug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iipiiati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icasoiog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraszerase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ronefa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liliaodikast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hukeiheyor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gidenimeca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Guliakmeow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asnaaimcesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itiste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moeyano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oengizmeass', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ericonemue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mamiycneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciseas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trifugmovear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riabe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteehoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antafoesme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tetitojusa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekaessipu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veanurote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryoit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocyumroi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiseab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seayaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuseahiast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blidautee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plaole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toraoeogod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isflemooer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caiverle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofism', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyibefrano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aracetheio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neabexni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oineliobed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atstise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idriite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioludyla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eblaerbliei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onlyacheleaj', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifiogteile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diatiahwoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iabiyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alsyfleaceng', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anitpiclie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irpiaghcleo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyaeilete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esituarkuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estiroak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diisicentpi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avyuiusla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucemeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ideyiordeto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utryti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xayoode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tierfoonoil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriahaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebindyoeo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acowrietise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyeangecuzop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nekilic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lachonyan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lynecam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilamicreit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idyaniie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enpsionade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaerastu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ines', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pemawopla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoumonead', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orinore', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eomyare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osicousocla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erofagiei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rauliont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clalaockly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xiboise', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoaaychi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaroeanoyer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niarthien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amineom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroiasscayf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilchiowonear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moeueic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imaskueisor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiayuaorca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atuodpipa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vieo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inayolitero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteivoand', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouswosiast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiodsla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iberaagfla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeoak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reajetoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuetanxe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Speeiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caotpreip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erpayedipui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipsleurtrao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etabpuep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oareinei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oudecrionglo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tauasare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyeyia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iolaro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ungcoabte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Breaorhiur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veelmar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bopineondsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issoiheabom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icezalaexi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aizeyoma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Breoudyit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olasie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elaceph', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Juanne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriesoporel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaora', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toipiiseper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leedtuey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alydla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ickablio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ageytioer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Satiinoce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiizirahi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onyldadimiog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anseypvae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atiyouyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifumonodiswa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Limobitu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeratinare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sauinbre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uberelee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acatlaeiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atmiuydae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alieraly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatnecediav', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eorcheistoih', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dapiwralu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isentisgy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awoiceolge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Away', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ongi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gaeinansiov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isanop', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chaymeiname', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apleehniriu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehorreneylt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eersaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihitine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niaabetya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etiayocu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ordiaceabet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Koessaueythe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zeengba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nieipelao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yarutea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yeegeluot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilavspoesi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olohoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fleharo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Prenyniam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pragomehafu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inceildiaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynsythoiaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onhanoelya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eicha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiyaessne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uoken', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umorup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atamdeshe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Struilopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiqen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lieromespeip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Colarisp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moapstre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ranui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sireiacan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Parauxue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trychibryce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cresalxadi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kaafleagoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liiaao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seaenunsab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egeyrsta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erkitor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tieajenme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sedichumo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emeizre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uastay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anleocoyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otnuli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chighoho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Faotxa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obdiinid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pusiprene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouluarev', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atauacal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Praseyhao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poefru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uscyirtne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyathibrabid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eivestineont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bedeeikalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cueragim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leadet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aidotreueb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isreaisnoer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asegaegte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryliumbiraob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acaway', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiham', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phaiae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woikinias', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isipreivhai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owaknate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idadiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vecoriet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilalinory', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihenare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opicner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epuisaedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eowpem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adliropro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eumpeasor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elewiemipne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ydre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Octoilime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iptoesse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ainflatiook', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyiochewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leharaoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abaing', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enailunscuci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ufricuog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istsanuesov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyokaplasybi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayodeita', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ozfoagto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inopaonnata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pelaieye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buaafulci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oteerole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otiol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deiayaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atieho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uisleatt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nepriahape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eius', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyesagmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogehreeyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sisiaooi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itriooe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emesemyke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raynd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceatri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udooeurism', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etednilies', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osmihuolyre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewasirer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooalneol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Negaclyesse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arorimaur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utocepire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anoga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Biineion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoecoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Baenaumo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cenganla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diasaeremi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inarmasuanli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ityayheyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoainmi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neimu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nosfeero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waaiubiic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etolopoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymaorlin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aakyaluco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atatobre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulineyinerwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eticori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oetrini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hyayineamid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atdaeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reoiodebo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efitomu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loesmpeeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engipfa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iodoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orcheam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Letibacito', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoreciodri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Muuereze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arfpastri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iulusk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tienreysm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rheleyapae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ditoladein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ridioil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roenoverpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arotiri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aghbetiyeona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Griyang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Efeofdaugalf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iudsieh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanjealtoche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irdoinfii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utticati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eduayidgo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evaeteele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abasu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dynaeal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipnetah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astuale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ityzelpousi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boark', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaraploriim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipzacyy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gliougfeal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eizingey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Angneuypla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Testraogod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engyonyetiel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oxurpaniela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebneumi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaleati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inteoomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Attea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Telinebioe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izamait', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eanenoyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edkioyaot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omorisoesm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pareotae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Catipre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moracef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onanutaya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iufoonleo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oisinopladi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agislie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atlegypheief', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneboodti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyouerd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euteestno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tebuvospy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nedinuehbro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogedi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gune', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cayss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaesuera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Shaoesoia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stutrobicote', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuomerpeur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Debloet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acoshonileli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odithoeota', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itbaolpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrmci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irerip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayniafpure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trueckentiay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ashothespe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irolonloi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiswia', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opnetior', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cheioyieer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oynaroa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orthudi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poreoler', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaengtea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wais', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owaracircone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esieiyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eachi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaneffouik', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitonceal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oseeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroipeder', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aotabo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eosmucees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ureghba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osinowale', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyibdehemu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ullomatevo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taueysosca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lode', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewhecydaado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oveseaki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arewa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veeplacobuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kayeaor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inyienta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neweyerca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omoceomis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cerispatko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owatreilties', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aertywa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugallio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Choensayaun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Renoandaeru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yionleosto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ylumarof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sheub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rasipearet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imvoidyvea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orcoemre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Griohy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teasda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uscledeom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onfusididauc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raethmaspaat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olyayatya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arseio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orpecenani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Clisimec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omesangse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anenilbaybo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyeintal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ockwesila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yablete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irneuit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahizmoiamb', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ompstie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omneeid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itsaosa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apausuroyst', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etfen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iurmaamve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poafla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayaconilar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yachna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onilliwaaber', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ortastbyiscu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tioalobe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiabad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enlitietiku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uanalya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geoasech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idoidpereer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lipoisy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inisit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riduleviagri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sceurya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oped', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayeaetho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovisulesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayulians', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wainegoeor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dyeki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eopbroem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nakeap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Okgooycocoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Udboyssisone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esmie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enomxiciu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suiwsuegank', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesecospum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diyeaii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osveolkea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caabaltoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anefleerag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elomneetepu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ityal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulonocagdayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oproeni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oedanveieck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entaisneon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utipivieth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliurt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eskiitbou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ompeidniba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eistotybe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eadie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cierboiosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eltuebhabro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingeese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onufliat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tasuaesxi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usmeussbru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubleifiasm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneniotepa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneriysqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oneou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocloim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opatayuugent', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oanil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilbituloi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edleoty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inank', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaizpaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teviaveoif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acidosopaoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roeuphe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oveernebie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeyestewouch', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otyupysezo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erlizeey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doildaelitex', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eresh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeafoopom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inelag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usiho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erswiede', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atrapoiclo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aswa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meoerab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isniit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pleheoyl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unupsaulyaer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icoeacnion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isimpdeko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stiuaselite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oniinera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arduatoctoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arpropakaspi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buiinopga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Loartyule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entawi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puiletaloan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Malenotola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivriet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aseolelea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Geeaody', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aawifdee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocoesko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unforofueg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lenitruoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eweteepiil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enosesioy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arredaadje', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Netueldun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elorazbu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeconat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogyseagsy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fiyneanne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anebaoplu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egbenitiaton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Illar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iudifere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utflias', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toaimsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cureucoae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itoyayeduna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etotoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atreuttaos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yseuoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euneic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rhaord', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifinone', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istyexopnoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seinglecu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iumer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifahubprayi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etteuengdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ipemtra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Paroesa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ontethecial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inepenoyf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amefom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beyancoei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoeki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coseot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eingophati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taeuhoac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obluonkoni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pluidireyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ifsiodeno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lyuleu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oparbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osolthyonusm', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eissod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tialpuskaele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olakiorze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etuaeini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Duoengonri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaeoral', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ratretare', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hemycoiztyas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eplaeul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uluykinkyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ryesiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onatnelubimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xyketiup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tihueilete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eachraku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noubcieirdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raustucohae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meagom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyoyocnaciri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poobuis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Romiegegii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esabocingry', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiispengri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iliftarmjaon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ealyonoyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yitonu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hitrioad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iudemeori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iekfoegi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sihi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utmeleal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sezeidifla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idtychiat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilberonaete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hoirano', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itorusteoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Latuowatmear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocoivarsceey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eferetoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oplaoitma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adyeavioty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icniayheiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emisahyome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Locoato', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imodathi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eralyub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nisoaidasthu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esoluovier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiagle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oreuit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siengunassat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edecyele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otielany', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aboimitiscri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocapoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Suoimoltroar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rezerene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Runoeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neefla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gioc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gihai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycoqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Skere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hechafraut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riafioec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diteiemek', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uinyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araioiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onirxei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Faitaneiye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teiamara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaodya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikosmuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileucooip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fuelogese', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Araifrera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maasty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ishonete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Foyaopalaca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onkbi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Insliende', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egyivsidaku', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycraboayo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oussethre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icraad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uatesseyupo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieeiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekauteeom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tuvoiba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyenmuittoar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Vecloeypro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eshinueade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beoshaabomo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odoisuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isryatpena', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etotelaogri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alayootra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eodionsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uldytra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Patuartea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivgli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyoncadiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inneit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eayidade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroalpaense', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yieye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iglazo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eericei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyisibaei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deataltna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uaaleta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atarin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rulesean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ampileydgli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiatreci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naruneui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Issmauromit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urflenotee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abfri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opleaviney', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Secytei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Toip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycceos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emaronea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaecaknereni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kiiah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dieniasiu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esosuiole', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poralierco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ermueomis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaseabetit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cayeyde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niroo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eliwhuiteit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gevaefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oterne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onyanecala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kraogsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osacoemkele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onegenar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehtyipe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irealey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Daalpero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abgroirona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alyialheed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itstaacoamo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoiem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iciumti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taiidmeaco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aneckism', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceedon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogabuc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inyioortuo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dasanaaurt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iadau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiogear', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yiaflaynt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obuazovoun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urnagossolyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Plimouponsme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enassatyap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uboshupe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ouconure', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leaec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ewniv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogethzaiziq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiuthece', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oicgefepene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecscegigauma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Octeigbiina', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poehslatyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecsaieabsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Broneov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omcieoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atoera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isetidioras', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maaextera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rokocunk', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Michierteaga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaryler', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tice', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icnefleo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Whoagoyaoscy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umsionitzeoh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esphiericy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enymbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aesenkcayl', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Engesraoghin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noakceerbe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Racu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Olalnegmeat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciropui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eodalunnaan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecropavaeme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aotetut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Otsu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayfe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynuboi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acokypeam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omstesuoem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amkeov', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iselidei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unroismbybie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tococ', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beoisyoel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estiby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spoleiemad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ezeani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leuade', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noolneamol', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibneo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikeuntareno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alizylahtge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ierer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieyecepee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aerudotite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alehugay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onoabstan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilinidety', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coraauldeyct', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereaeshurd', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cicieyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ambaoy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyaosuna', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astacuamip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iielonten', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rieye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Spapeloeleve', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oriowadtri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anspa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uisosoiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Scaatioliiq', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Episcro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ymulimnodeac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Takadwei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Giniusne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neaule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eryaehereon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enacei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eriliedicil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeakica', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eutofazce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eonreevqu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aedfeule', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esaionux', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cearwhuseoc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asteriko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oineo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teriwiend', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneroncutgla', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Treswosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aspe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Urayea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ostaycoidi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miwiust', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ismeref', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reneidam', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iblomaedawa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omerbathae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onifaki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Umborenexe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dayaiz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aevick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecaexcara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahothesre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eckylat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oinigesclo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gicro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayulug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cuimtirean', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eglovinti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veyi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etoenti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reiaau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doehusuep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiaisoet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abuecostet', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inaacene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omurangoyne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atebdeogokic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Topsyeyaentu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boyeoogeon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aronuoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rechiroarc', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Styeaom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yagene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estetopo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yitacquum', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Imyocmine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amnoeyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioolme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ajeyecou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zioerteahcho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riulakerene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eylo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eohoitif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bastoeresoak', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hinahati', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inayes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eesserti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahesteau', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bamoageyefe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esiiuba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lacahois', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Male', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iiag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atcocane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leivo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Preuamaric', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antiltzeiti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Useetend', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woengte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cacha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ywiceavge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iecow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waediyrmiki', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liauec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esicteoo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ertitefii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyquargewoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diletanidre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erisainaeld', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raefoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eniskeatun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zaohoboase', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intluyedo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Demie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aroaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atyiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avyeierveos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eubcui', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaydloti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonaw', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lueen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ekun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Apraomnee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulaalenre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teugeey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idatayeog', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mydigytwoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elinmiesmao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lidiorali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueloa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ampay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ojlicreino', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coeanuial', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etleon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehedealai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ephistroscha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mieqiang', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ietgoizpeyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dicho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tepiaont', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Awcreal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chielai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Verdylios', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Insoeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ercanoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etidudmeis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adomoquge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ueiosi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lanetiawob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inmuimove', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enssaoynil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoaetauas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coelduo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gyedaen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Cyera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Lioryei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alini', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Taeemta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rilyuuyac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oleoendo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eatid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ighbatrayea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iamioni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Youcoif', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reumiimby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oturi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iginesnoarly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sphoethby', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Blyaoeft', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iirsane', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugaeyplaast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ecosiwkis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Xacyul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mattio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ketuelni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ingtepe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orciliesell', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eeteay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Miime', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Gluyoiymiac', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebriawa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Astemlieyys', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeilieclu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leaimiproo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isuconi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Einentesowed', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echub', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Andrioeral', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeachoorshe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ameos', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omste', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogashat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tineoctipe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erboieti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iuonroraor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hualayeyti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Egewimny', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraoqdiama', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayeloraco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iosisii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onlasuni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arulonria', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yecoapec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraussab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Dateangaledi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entoalutocde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peomairkfrai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Saneikma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oaypo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ineotcaqute', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edesco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Othe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anyrizee', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Peebfu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Laya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneveon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uitung', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiveopoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Woeata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atisertas', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatryni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eola', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avleafah', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uokiul', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Osuodepoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Fytaibsiea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uafumayni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Empie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Intateropsa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enyoco', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noiibraalo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogluis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uigh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mageinglooy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ater', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icsairimi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keinesheirze', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ustreboesut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neboyautnite', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elnoalaoyni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arsifrein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ripopooss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ycea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ucalstrilye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euib', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ocse', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istreomunat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leyletochne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icflaiqy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoaug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coahtier', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oituapara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Entspaidid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Riagyaoick', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ethpreoru', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayilyker', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oayiperei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ebuf', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esusleerdi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tenicodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coyliroat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erkeoay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iylireob', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Achostritra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etidoteper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noameasa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Waryedazneod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aion', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arwitiso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iseopialin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Autoatple', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irewi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneaerast', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aaceuant', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izueychenma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sityeseao', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esecyelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enkwotoen', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unanutsueh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teichyisoct', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Puneloisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iteona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yorpoesbrege', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isly', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uinluedpe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ubenkplein', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icraeyngulta', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Idathiivestu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yipielape', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bemiecei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Evogiyp', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enulabreyaca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aizboelow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eraoawe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Agapu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ybtinoudug', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iineo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onurien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stianesni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esneem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Opoesho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icstrohiwaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anetoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etuchveheom', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rofroiulela', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ataawa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meopowaingke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Nacuiseropa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Stieuab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyde', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ossifieake', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeashce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aywinio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tepayad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iyhechosni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaolodiff', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sinolu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioyu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atotyt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icyesenermi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Enypeneat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Athegedloe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seech', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Listuble', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sioy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aarsqieapi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oeoneh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buaroetiton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liyckda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ateickoofu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Drinainer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myepaura', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ontaire', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aporsoidti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ioico', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Essatart', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eyey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icastieldon', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teaioel', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Increagreo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Maeriegh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oliokeig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aptugeohu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aptoledi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acesdeavre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aonugeickche', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Faema', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isspuiy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Reomtraeno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugnelona', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ienacanec', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Istrotynuot', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liesputeay', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asceemeunton', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eretlaasti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiaof', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Joivrebatuli', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Netooba', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ywonoeanne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rosleraren', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Utneubleonra', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ahamio', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoanmeci', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eneyacma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etarinoyae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ceratylylie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iitara', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aosylgroroni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uroixosteip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tinu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uditoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynboshainil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aidty', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alindisa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tyumanti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neoredirota', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eapleori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eruboiglu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Raoxtietre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icibechea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehroy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehisuochusi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Poipigu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Adaree', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uala', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Euifroat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onerscaafo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esibewe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boecyaga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Alneaeso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anussleeme', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odosifyboa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acugubaelid', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eoneabrea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Igeroner', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Edoeiaes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Keriyo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atreatgi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myno', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hochuimut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilaotifoeht', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Usinadowooz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onabu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emibaur', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aeoeck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ialnalicheo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amonieni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yvael', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Chureodi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Bioraynioi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ianoedor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naiacemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ihengprelo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leealat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Sana', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Moelybae', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Icedecdeer', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ixorodeyene', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ofisate', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esonganoou', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Elakocuzaip', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ictyerowro', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Beabili', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ilvele', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Diyainraor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Leayella', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Seamanagile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amcaadyg', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inteucsceu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Naungisyanu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Unteatieti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Setyle', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Mochoitab', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veat', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aniumstai', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erapmuechte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oonadal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onantisley', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izbuatere', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yrackalti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Pesy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iian', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rifiieckut', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Teti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Uiga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ugugtescef', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hacaeshuecma', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Liinlotoes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aretiesca', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Etaogogucsy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Obya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ileejetus', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ivali', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amaanrayrre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Izerdiess', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Wigeahraso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anomwineu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Esilactroce', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ohiscialeiss', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoniesacep', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayeviapneil', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acera', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Newoyclicisi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Phoucke', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iplaonagraes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oiyaryoi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Theisyadieok', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Echo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogioxoerig', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Goeiares', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neicvi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aver', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ehmeoye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Deusaseck', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aosomain', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Indi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Boaumissag', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ieran', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Emnoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tiuatchy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Irpamung', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Neboneani', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Niaanabo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yseremar', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Onalsamimyni', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tilephoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Myaiimo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eafori', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Brooaniiv', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ynsagihitaup', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yoingenareso', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Napcaoan', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eitetynt', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aleilemdoe', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aoliesti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aiguhete', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Inyaslachy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ernosu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Noetsata', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eisufubresi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Abreameedy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Coayumantioh', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Kialatpo', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estnyineahun', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogopocutho', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Anleile', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Siedaogu', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ovifdarytie', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Doylirayurwa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ypayleceth', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Assisyomiue', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Epoya', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tielengsi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Avomoeit', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayteiey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibiaonte', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Upiduyasne', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rapues', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Amniattici', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erypleow', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Iewnoemes', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isaduntome', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Tenii', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Antiateomis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oatiinoa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ogatha', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eaneine', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Atialiod', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Yaeseaye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Meeye', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Caeromfabien', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acessaswero', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Allenitgeey', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Exlitomi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Triisitnea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Omastneis', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ibeto', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Owond', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Isceluaic', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oyveda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hiestaleonor', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Molenoal', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Veaa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Odosowreyad', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ereeullyin', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ikdyity', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Rabriosax', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eroiap', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Oassluti', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Asapuling', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estroiagre', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Roiwi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Buatolem', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ulhemeyees', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Itiemi', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erchayper', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estga', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Griaila', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Zepeeyoeri', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Hanaeiim', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Arpatado', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Aelinplucy', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ooertyge', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ayiestnei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Acyniilpa', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Estosumeaz', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Orda', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Erufgaiza', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Eofyhoea', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Trarecyeko', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0),
+(NULL, 'Ciei', 0xFF, 0xFFFF, 0xFFFF, 0xFFFFFFFF, 0, 0);
+UNLOCK TABLES;
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Bots/world_lordpsyanbots.sql b/sql/TrinityCore-Patches/Bots/world_lordpsyanbots.sql
new file mode 100644
index 0000000..6a85210
--- /dev/null
+++ b/sql/TrinityCore-Patches/Bots/world_lordpsyanbots.sql
@@ -0,0 +1,170 @@
+-- GENERAL --
+
+SET @BOT_START = 70001;
+SET @BOT_END   = 71000;
+
+delete from `creature_template` where entry between @BOT_START and @BOT_END;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) VALUES (70001,0,0,0,0,0,5001,0,5001,0,'Khelden','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70002,0,0,0,0,0,1294,0,1294,0,'Zaldimar','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70003,0,0,0,0,0,1484,0,1484,0,'Maginor','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70004,0,0,0,0,0,3344,0,3344,0,'Anetta','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70005,0,0,0,0,0,1495,0,1495,0,'Laurena','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70006,0,0,0,0,0,1295,0,1295,0,'Josetta','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70007,0,0,0,0,0,3345,0,3345,0,'Drusilla','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70008,0,0,0,0,0,1930,0,1930,0,'Alamar','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70009,0,0,0,0,0,1469,0,1469,0,'Demisette','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70010,0,0,0,0,0,12749,0,12749,0,'Nalesette','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70011,0,0,0,0,0,3401,0,3401,0,'Branstock','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70012,0,0,0,0,0,3395,0,3395,0,'Thorgas','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70013,0,0,0,0,0,3343,0,3343,0,'Llane','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70014,0,0,0,0,0,3399,0,3399,0,'Thran','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70015,0,0,0,0,0,1300,0,1300,0,'Lyria','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70016,0,0,0,0,0,3351,0,3351,0,'Jorik','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70017,0,0,0,0,0,3407,0,3407,0,'Solm','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70018,0,0,0,0,0,1297,0,1297,0,'Keryn','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70019,0,0,0,0,0,1507,0,1507,0,'Osborne','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70020,0,0,0,0,0,3346,0,3346,0,'Sammuel','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70021,0,0,0,0,0,3393,0,3393,0,'Bob','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70022,0,0,0,0,0,1299,0,1299,0,'Wilhelm','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70023,0,0,0,0,0,1499,0,1499,0,'Brisombre','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70024,0,0,0,0,0,10216,0,10216,0,'Marry','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70025,0,0,0,0,0,4552,0,4552,0,'Haromm','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70026,0,0,0,0,0,4567,0,4567,0,'Kartosh','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70027,0,0,0,0,0,3429,0,3429,0,'MaxanAnvol','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70028,0,0,0,0,0,10215,0,10215,0,'Magis','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70029,0,0,0,0,0,3431,0,3431,0,'GranVivehache','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70030,0,0,0,0,0,1622,0,1622,0,'Azar','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70031,0,0,0,0,0,3436,0,3436,0,'Hogral','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70032,0,0,0,0,0,3053,0,3053,0,'Kelstrum','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70033,0,0,0,0,0,1578,0,1578,0,'Dannal','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70034,0,0,0,0,0,1579,0,1579,0,'SombreDuesten','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70035,0,0,0,0,0,1592,0,1592,0,'Isabella','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70036,0,0,0,0,0,1581,0,1581,0,'Maximillion','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70037,0,0,0,0,0,1604,0,1604,0,'Rupert','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70038,0,0,0,0,0,1600,0,1600,0,'Cain','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70039,0,0,0,0,0,1602,0,1602,0,'SombreBeryl','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70041,0,0,0,0,0,10548,0,10548,0,'Milituus','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70042,0,0,0,0,0,2810,0,2810,0,'Lexington','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70043,0,0,0,0,0,2123,0,2123,0,'Siln','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70044,0,0,0,0,0,19598,0,19598,0,'Umbrua','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70045,0,0,0,0,0,2102,0,2102,0,'Tigor','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70046,0,0,0,0,0,2082,0,2082,0,'Beram','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70047,0,0,0,0,0,2106,0,2106,0,'Turak','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70048,0,0,0,0,0,2121,0,2121,0,'Sheal','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70049,0,0,0,0,0,2115,0,2115,0,'Kym','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70050,0,0,0,0,0,2112,0,2112,0,'Kary','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70051,0,0,0,0,0,2087,0,2087,0,'Holt','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70052,0,0,0,0,0,2105,0,2105,0,'Urek','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70053,0,0,0,0,0,2103,0,2103,0,'Torm','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70054,0,0,0,0,0,2096,0,2096,0,'Sark','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70055,0,0,0,0,0,17211,0,17211,0,'Kerra','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70056,0,0,0,0,0,2139,0,2139,0,'Miles Welsh','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70057,0,0,0,0,0,2138,0,2138,0,'Malakai','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70058,0,0,0,0,0,2137,0,2137,0,'Cobb','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70059,0,0,0,0,0,2134,0,2134,0,'Shymm','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,1,0,0,0,0,0,0,0,0,0,0,143,145,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70060,0,0,0,0,0,6058,0,6058,0,'Ursyn','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70061,0,0,0,0,0,2135,0,2135,0,'Thurston','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70062,0,0,0,0,0,3793,0,3793,0,'Harutt','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70063,0,0,0,0,0,3819,0,3819,0,'Gart','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70064,0,0,0,0,0,3810,0,3810,0,'Lanka','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70065,0,0,0,0,0,10180,0,10180,0,'Meela','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70066,0,0,0,0,0,3794,0,3794,0,'Krang','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70067,0,0,0,0,0,10734,0,10734,0,'Gennia','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70068,0,0,0,0,0,3811,0,3811,0,'Yaw','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70069,0,0,0,0,0,3816,0,3816,0,'Narm','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70070,0,0,0,0,0,1880,0,1880,0,'Frang','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70071,0,0,0,0,0,1882,0,1882,0,'Jenshan','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70072,0,0,0,0,0,1884,0,1884,0,'Nartok','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70073,0,0,0,0,0,1878,0,1878,0,'Shikrik','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70074,0,0,0,0,0,3743,0,3743,0,'Tarshaw','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70075,0,0,0,0,0,3744,0,3744,0,'Thotar','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70076,0,0,0,0,0,3745,0,3745,0,'Dhugru','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70077,0,0,0,0,0,3746,0,3746,0,'Swart','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70078,0,0,0,0,0,1324,0,1324,0,'Groldar','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70079,0,0,0,0,0,1325,0,1325,0,'Mirket','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70080,0,0,0,0,0,1326,0,1326,0,'Zevrost','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70081,0,0,0,0,0,1360,0,1360,0,'Kardris','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70082,0,0,0,0,0,1373,0,1373,0,'Ormak','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70083,0,0,0,0,0,1374,0,1374,0,'Grezz','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70084,0,0,0,0,0,1375,0,1375,0,'Sorek','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70085,0,0,0,0,0,4231,0,4231,0,'Siantsu','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70086,0,0,0,0,0,4239,0,4239,0,'Xorjuul','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70087,0,0,0,0,0,4241,0,4241,0,'Siandur','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70088,0,0,0,0,0,4242,0,4242,0,'Zelmak','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70089,0,0,0,0,0,7915,0,7915,0,'ClaudeErksine','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70090,0,0,0,0,0,1721,0,1721,0,'Alyissia','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70091,0,0,0,0,0,1725,0,1725,0,'FrahunMurmombre','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70092,0,0,0,0,0,1733,0,1733,0,'Shanda','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70093,0,0,0,0,0,1732,0,1732,0,'Mardant','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70094,0,0,0,0,0,1707,0,1707,0,'Kyra','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70095,0,0,0,0,0,1704,0,1704,0,'Jannok','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70096,0,0,0,0,0,1708,0,1708,0,'Laurna','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70097,0,0,0,0,0,1706,0,1706,0,'Kal','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70098,0,0,0,0,0,4296,0,4296,0,'Harruk','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70099,0,0,0,0,0,4299,0,4299,0,'Reban','Hunter bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70100,0,0,0,0,0,4304,0,4304,0,'Bolyun','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70101,0,0,0,0,0,1897,0,1897,0,'Taijin','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70102,0,0,0,0,0,4068,0,4068,0,'Kenjai','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70103,0,0,0,0,0,2066,0,2066,0,'Danlaar','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70104,0,0,0,0,0,2196,0,2196,0,'Ariasta','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70105,0,0,0,0,0,2198,0,2198,0,'Sildanair','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70106,0,0,0,0,0,2200,0,2200,0,'Astarii','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70107,0,0,0,0,0,2201,0,2201,0,'Jandria','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70108,0,0,0,0,0,2202,0,2202,0,'Lariia','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70109,0,0,0,0,0,2231,0,2231,0,'Syurna','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70110,0,0,0,0,0,7669,0,7669,0,'Elissa','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70111,0,0,0,0,0,2252,0,2252,0,'Erion','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70112,0,0,0,0,0,2243,0,2243,0,'Anishar','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70113,0,0,0,0,0,2250,0,2250,0,'Denatharion','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70114,0,0,0,0,0,2255,0,2255,0,'Fylerian','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70115,0,0,0,0,0,2416,0,2416,0,'Caelyb','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70116,0,0,0,0,0,2675,0,2675,0,'Kaal','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70117,0,0,0,0,0,16800,0,16800,0,'Lana','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70118,0,0,0,0,0,2646,0,2646,0,'Richard','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70119,0,0,0,0,0,10214,0,10214,0,'Kaelystia','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,6,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70120,0,0,0,0,0,2644,0,2644,0,'Pierce','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70121,0,0,0,0,0,2657,0,2657,0,'Anastasia','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70122,0,0,0,0,0,2620,0,2620,0,'Chris','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70123,0,0,0,0,0,2658,0,2658,0,'Angela','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70124,0,0,0,0,0,2614,0,2614,0,'Baltus','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70125,0,0,0,0,0,3054,0,3054,0,'Kelv','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70126,0,0,0,0,0,3055,0,3055,0,'Bilban','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70127,0,0,0,0,0,3056,0,3056,0,'Daera','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70128,0,0,0,0,0,3072,0,3072,0,'Olmin','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70129,0,0,0,0,0,3073,0,3073,0,'Regnus','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70130,0,0,0,0,0,3086,0,3086,0,'Theodrus','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70131,0,0,0,0,0,3066,0,3066,0,'Braenna','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70132,0,0,0,0,0,3085,0,3085,0,'Toldren','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70134,0,0,0,0,0,3108,0,3108,0,'Bink','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70135,0,0,0,0,0,10214,0,10214,0,'Juli','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70136,0,0,0,0,0,3109,0,3109,0,'Nittegousse','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70137,0,0,0,0,0,3089,0,3089,0,'Valgar','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70138,0,0,0,0,0,3088,0,3088,0,'Beldruk','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70139,0,0,0,0,0,3087,0,3087,0,'Brandur','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70140,0,0,0,0,0,3101,0,3101,0,'Hulfdan','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70141,0,0,0,0,0,3100,0,3100,0,'Ormyr','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70142,0,0,0,0,0,3113,0,3113,0,'Phenwick','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70143,0,0,0,0,0,3115,0,3115,0,'Coeurdechardon','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70144,0,0,0,0,0,3116,0,3116,0,'Eglantin','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70145,0,0,0,0,0,3122,0,3122,0,'Alexander','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70146,0,0,0,0,0,3280,0,3280,0,'Wu','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70147,0,0,0,0,0,3287,0,3287,0,'Ilsa','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70148,0,0,0,0,0,3283,0,3283,0,'Joshua','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70149,0,0,0,0,0,3284,0,3284,0,'Arthur','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70150,0,0,0,0,0,3289,0,3289,0,'Katherine','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70151,0,0,0,0,0,3291,0,3291,0,'Deline','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70152,0,0,0,0,0,3286,0,3286,0,'Sandahl','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70153,0,0,0,0,0,3292,0,3292,0,'Jennea','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70154,0,0,0,0,0,19803,0,19803,0,'Elsharin','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70155,0,0,0,0,0,3299,0,3299,0,'Kaerbrus','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70156,0,0,0,0,0,3300,0,3300,0,'Sheldras','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70157,0,0,0,0,0,3301,0,3301,0,'Theridran','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70158,0,0,0,0,0,3312,0,3312,0,'Einris','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70159,0,0,0,0,0,3309,0,3309,0,'Ulfir','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70160,0,0,0,0,0,3310,0,3310,0,'Thorfin','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70161,0,0,0,0,0,10171,0,10171,0,'UnThuwa','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70162,0,0,0,0,0,4524,0,4524,0,'Pephredo','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70163,0,0,0,0,0,4522,0,4522,0,'Enyo','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70164,0,0,0,0,0,4526,0,4526,0,'Mai','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70165,0,0,0,0,0,4523,0,4523,0,'Deino','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70166,0,0,0,0,0,4665,0,4665,0,'Birgitte','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70167,0,0,0,0,0,12849,0,12849,0,'Thuul','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70168,0,0,0,0,0,4690,0,4690,0,'Zayus','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70169,0,0,0,0,0,10473,0,10473,0,'Xyera','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70170,0,0,0,0,0,4711,0,4711,0,'Urkyo','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70171,0,0,0,0,0,6060,0,6060,0,'Uthelnay','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70172,0,0,0,0,0,6072,0,6072,0,'Dink','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70173,0,0,0,0,0,6071,0,6071,0,'Darnath','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70174,0,0,0,0,0,7356,0,7356,0,'Karman','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70175,0,0,0,0,0,11037,0,11037,0,'Evencane','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70176,0,0,0,0,0,7357,0,7357,0,'Jannos','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70177,0,0,0,0,0,7538,0,7538,0,'Alenndaar','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70178,0,0,0,0,0,10738,0,10738,0,'Golhine','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70179,0,0,0,0,0,9337,0,9337,0,'Hesuwa','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70180,0,0,0,0,0,9336,0,9336,0,'Xao\'tsu','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70181,0,0,0,0,0,9338,0,9338,0,'Belia','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,3,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70182,0,0,0,0,0,10245,0,10245,0,'Dargh','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70183,0,0,0,0,0,11044,0,11044,0,'Meideros','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70184,0,0,0,0,0,11048,0,11048,0,'Presse','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70185,0,0,0,0,0,11053,0,11053,0,'Rohan','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,3,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70186,0,0,0,0,0,12053,0,12053,0,'Loganaar','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70187,0,0,0,0,0,13171,0,13171,0,'Romano','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70188,0,0,0,0,0,13341,0,13341,0,'Sagorne','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70189,0,0,0,0,0,15522,0,15522,0,'Julia','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70190,0,0,0,0,0,16811,0,16811,0,'Ithelis','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70191,0,0,0,0,0,15524,0,15524,0,'Invocateur','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70192,0,0,0,0,0,15518,0,15518,0,'Matrone','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70193,0,0,0,0,0,2659,0,2659,0,'Eclaireur','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70194,0,0,0,0,0,15520,0,15520,0,'Sallina','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70195,0,0,0,0,0,16685,0,16685,0,'Noellene','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70196,0,0,0,0,0,16707,0,16707,0,'Ponaris','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70197,0,0,0,0,0,16222,0,16222,0,'Keilnei','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70198,0,0,0,0,0,16223,0,16223,0,'Valaatu','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70199,0,0,0,0,0,16224,0,16224,0,'Aurelon','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70200,0,0,0,0,0,16225,0,16225,0,'Zalduun','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70201,0,0,0,0,0,16226,0,16226,0,'Kore','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70202,0,0,0,0,0,16787,0,16787,0,'Alamma','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70203,0,0,0,0,0,16800,0,16800,0,'Talionia','Warlock Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,8,0,16384,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warlock_bot',-1),(70204,0,0,0,0,0,16831,0,16831,0,'Zanien','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3500,2000,1,1,2,0,16384,0,0,0,0,9,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70205,0,0,0,0,0,16781,0,16781,0,'Zaedana','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70206,0,0,0,0,0,16824,0,16824,0,'Quithas','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70207,0,0,0,0,0,16739,0,16739,0,'Harene','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70208,0,0,0,0,0,16778,0,16778,0,'Tana','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70209,0,0,0,0,0,16816,0,16816,0,'Oninath','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70210,0,0,0,0,0,16829,0,16829,0,'Bachi','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70211,0,0,0,0,0,16767,0,16767,0,'Zelanis','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70212,0,0,0,0,0,16798,0,16798,0,'Elara','Rogue Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,1600,2000,1,1,4,0,16384,0,0,0,0,4,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'rogue_bot',-1),(70213,0,0,0,0,0,16858,0,16858,0,'Shalannius','Druid Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2200,2000,1,1,2,0,16384,0,0,0,0,11,6,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'druid_bot',-1),(70214,0,0,0,0,0,17434,0,17434,0,'Deremiis','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70215,0,0,0,0,0,17247,0,17247,0,'Caedmos','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70216,0,0,0,0,0,17225,0,17225,0,'Baatun','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70217,0,0,0,0,0,17212,0,17212,0,'Ahonan','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70218,0,0,0,0,0,17598,0,17598,0,'Firmanvaar','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70219,0,0,0,0,0,16860,0,16860,0,'Actron','Hunter Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70220,0,0,0,0,0,17213,0,17213,0,'Behomat','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70221,0,0,0,0,0,17600,0,17600,0,'Nobundo','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70222,0,0,0,0,0,17599,0,17599,0,'Tuluun','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70223,0,0,0,0,0,16914,0,16914,0,'Sulaa','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70224,0,0,0,0,0,17215,0,17215,0,'Ruada','Warrior Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3400,2000,1,1,1,0,16384,0,0,0,0,1,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'warrior_bot',-1),(70225,0,0,0,0,0,17233,0,17233,0,'Semid','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70226,0,0,0,0,0,17232,0,17232,0,'Guvan','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70227,0,0,0,0,0,17234,0,17234,0,'Tullas','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70228,0,0,0,0,0,17488,0,17488,0,'Killac','Hunter bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2800,2000,1,1,2,0,16384,0,0,0,0,3,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'hunter_bot',-1),(70229,0,0,0,0,0,17226,0,17226,0,'Jol','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70230,0,0,0,0,0,17248,0,17248,0,'Fallat','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70231,0,0,0,0,0,17243,0,17243,0,'Harnan','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70232,0,0,0,0,0,17241,0,17241,0,'Bati','Mage Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3800,2000,1,1,8,0,16384,0,0,0,0,8,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'mage_bot',-1),(70233,0,0,0,0,0,17792,0,17792,0,'Hobahken','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70234,0,0,0,0,0,6820,0,6820,0,'Gurrag','Shaman Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2600,2000,1,1,2,0,16384,0,0,0,0,7,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'shaman_bot',-1),(70235,0,0,0,0,0,19596,0,19596,0,'Auberose','Paladin Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,2300,2000,1,1,2,0,16384,0,0,0,0,2,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'paladin_bot',-1),(70236,0,0,0,0,0,10335,10335,10335,10335,'Afina','Priest Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3600,2000,1,1,8,0,16384,0,0,0,0,5,1,7,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'priest_bot',-1),(70237,0,0,0,0,0,26939,26939,26939,26939,'Imhadria','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70238,0,0,0,0,0,28039,28039,28039,28039,'Mynx','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,0.8,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70239,0,0,0,0,0,26688,26688,26688,26688,'Lankral','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,1,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70240,0,0,0,0,0,26195,26195,26195,26195,'Silver','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70241,0,0,0,0,0,27402,27402,27402,27402,'Vereth','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,0.8,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,5,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70242,0,0,0,0,0,27189,27189,27189,27189,'Arly','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,7,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70243,0,0,0,0,0,26217,26217,26217,26217,'Setaal','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,11,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70244,0,0,0,0,0,28842,28842,28842,28842,'Illyrie','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,4,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70245,0,0,0,0,0,28840,28840,28840,28840,'Zor\'be','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,8,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70246,0,0,0,0,0,25512,25512,25512,25512,'Datura','Death Knight Bot','',0,1,80,2,14,1,1.2,1.3,1,0,0,3300,2000,1,1,1,0,16384,0,0,0,0,6,10,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157552,'death_knight_bot',-1),(70247,0,0,0,0,0,1132,0,1132,0,'Voidwalker','Warlock\'s Pet Bot',NULL,0,1,80,2,14,0,1.2,1.3,1,0,0,2000,2000,1,1,2,0,0,0,16,0,0,0,0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,1048688,'voidwalker_bot',-1),(70248,0,0,0,0,0,1105,0,0,0,'Hunter\'s Pet',NULL,NULL,0,1,80,0,14,0,1.1,1.14286,1,0,0,2000,0,1,1,1,0,0,0,7,0,0,0,0,1,1,0,0,0,0,0,0,0,0,0,5708,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,149,1,0,0,'',-1),(70301,0,0,0,0,0,17659,17659,17659,17659,'Gorkramato','Ex. Blademaster','',0,81,81,2,14,1,1.2,1.3,1.05,4,0,2200,2000,1,1,1,0,16384,0,0,0,0,12,2,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1,1,1,1,1,0,0,0,1,68157560,'blademaster_bot',-1),(71000,0,0,0,0,0,16853,16853,16853,16853,'Airen','Priestess of Suffering',NULL,0,95,95,1,14,1,1.2,1.3,1.173,4,0,1500,0,1,1,1,898,49152,2,0,0,0,0,0,3,67110912,0,0,0,450,450,450,450,450,450,0,0,0,0,0,0,0,0,0,0,0,0,'',0,3,1,1000,1,5,5,1,1,0,0,617299839,1048946,'npc_Airen_qI',-213);
+
+
+-- EQUIPS --
+
+delete from `creature_equip_template` where CreatureID between @BOT_START and @BOT_END;
+
+insert into `creature_equip_template` (`CreatureID`, `ID`, `itemID1`, `itemID2`, `itemID3`, `VerifiedBuild`) values
+('70001','1','18842','0','0','0'), ('70002','1','18842','0','0','0'), ('70003','1','18842','0','0','0'), ('70004','1','31289','0','0','0'), ('70005','1','31289','0','0','0'), ('70006','1','31289','0','0','0'),
+('70007','1','31186','0','0','0'), ('70008','1','31186','0','0','0'), ('70009','1','31186','0','0','0'), ('70010','1','2291','0','2825','0'), ('70011','1','31289','0','0','0'), ('70012','1','2291','0','2825','0'),
+('70013','1','18002','0','0','0'), ('70014','1','27903','0','0','0'), ('70015','1','7723','0','0','0'), ('70016','1','13984','6448','0','0'), ('70017','1','13984','6448','0','0'), ('70018','1','6633','820','0','0'),
+('70019','1','13984','6448','0','0'), ('70020','1','12584','18825','0','0'), ('70021','1','18876','0','0','0'), ('70022','1','12584','18825','0','0'), ('70023','1','18876','0','0','0'), ('70024','1','18842','0','0','0'),
+('70025','1','18203','18202','0','0'), ('70026','1','31186','0','0','0'), ('70027','1','31289','0','0','0'), ('70028','1','18842','0','0','0'), ('70029','1','28367','0','0','0'), ('70030','1','12584','18825','0','0'),
+('70031','1','13984','6448','0','0'), ('70032','1','27903','0','0','0'), ('70033','1','18002','0','0','0'), ('70034','1','31289','0','0','0'), ('70035','1','18842','0','0','0'), ('70036','1','31186','0','0','0'),
+('70037','1','31186','0','0','0'), ('70038','1','18842','0','0','0'), ('70039','1','31289','0','0','0'), ('70041','1','18842','0','0','0'), ('70042','1','18842','0','0','0'), ('70043','1','18203','18202','0','0'),
+('70044','1','18203','18202','0','0'), ('70045','1','18203','18202','0','0'), ('70046','1','18203','18202','0','0'), ('70047','1','25622','0','0','0'), ('70048','1','25622','0','0','0'), ('70049','1','25622','0','0','0'),
+('70050','1','2291','0','2825','0'), ('70051','1','2291','0','2825','0'), ('70052','1','2291','0','2825','0'), ('70053','1','18002','0','0','0'), ('70054','1','27903','0','0','0'), ('70055','1','28367','0','0','0'),
+('70056','1','31289','0','0','0'), ('70057','1','31289','0','0','0'), ('70058','1','31289','0','0','0'), ('70059','1','18842','0','0','0'), ('70060','1','18842','0','0','0'), ('70061','1','18842','0','0','0'),
+('70062','1','28367','0','0','0'), ('70063','1','25622','0','0','0'), ('70064','1','2291','0','2825','0'), ('70065','1','18203','18202','0','0'), ('70066','1','18002','0','0','0'), ('70067','1','25622','0','0','0'),
+('70068','1','2291','0','2825','0'), ('70069','1','18203','18202','0','0'), ('70070','1','27903','0','0','0'), ('70071','1','2291','0','2825','0'), ('70072','1','31186','0','0','0'), ('70073','1','18203','18202','0','0'),
+('70074','1','18002','0','0','0'), ('70075','1','2291','0','2825','0'), ('70076','1','31186','0','0','0'), ('70077','1','18203','18202','0','0'), ('70078','1','31186','0','0','0'), ('70079','1','31186','0','0','0'),
+('70080','1','31186','0','0','0'), ('70081','1','18203','18202','0','0'), ('70082','1','2291','0','2825','0'), ('70083','1','7723','0','0','0'), ('70084','1','18002','0','0','0'), ('70085','1','18203','18202','0','0'),
+('70086','1','2291','0','2825','0'), ('70087','1','2291','0','2825','0'), ('70088','1','27903','0','0','0'), ('70089','1','2291','0','2825','0'), ('70090','1','28367','0','0','0'), ('70091','1','6633','820','0','0'),
+('70092','1','31289','0','0','0'), ('70093','1','25622','0','0','0'), ('70094','1','18002','0','0','0'), ('70095','1','13984','6448','0','0'), ('70096','1','31289','0','0','0'), ('70097','1','25622','0','0','0'),
+('70098','1','2291','0','2825','0'), ('70099','1','2291','0','2825','0'),
+('70100','1','2291','0','2825','0'), ('70101','1','31289','0','0','0'), ('70102','1','31289','0','0','0'), ('70103','1','2291','0','2825','0'), ('70104','1','7723','0','0','0'), ('70105','1','18002','0','0','0'),
+('70106','1','31289','0','0','0'), ('70107','1','31289','0','0','0'), ('70108','1','31289','0','0','0'), ('70109','1','13984','6448','0','0'), ('70110','1','18842','0','0','0'), ('70111','1','6633','820','0','0'),
+('70112','1','13984','6448','0','0'), ('70113','1','25622','0','0','0'), ('70114','1','25622','0','0','0'), ('70115','1','2291','0','2825','0'), ('70116','1','31186','0','0','0'), ('70117','1','31186','0','0','0'),
+('70118','1','31186','0','0','0'), ('70119','1','18842','0','0','0'), ('70120','1','18842','0','0','0'), ('70121','1','18842','0','0','0'), ('70122','1','27903','0','0','0'), ('70123','1','18002','0','0','0'),
+('70124','1','7723','0','0','0'), ('70125','1','18002','0','0','0'), ('70126','1','28367','0','0','0'), ('70127','1','2291','0','2825','0'), ('70128','1','2291','0','2825','0'), ('70129','1','2291','0','2825','0'),
+('70130','1','31289','0','0','0'), ('70131','1','31289','0','0','0'), ('70132','1','31289','0','0','0'), ('70134','1','18842','0','0','0'), ('70135','1','18842','0','0','0'), ('70136','1','18842','0','0','0'),
+('70137','1','18876','0','0','0'), ('70138','1','12584','18825','0','0'), ('70139','1','18876','0','0','0'), ('70140','1','6633','820','0','0'), ('70141','1','13984','6448','0','0'), ('70142','1','6633','820','0','0'),
+('70143','1','31186','0','0','0'), ('70144','1','31186','0','0','0'), ('70145','1','31186','0','0','0'), ('70146','1','27903','0','0','0'), ('70147','1','18002','0','0','0'), ('70148','1','31289','0','0','0'),
+('70149','1','12584','18825','0','0'), ('70150','1','18876','0','0','0'),
+('70151','1','31186','0','0','0'), ('70152','1','31186','0','0','0'), ('70153','1','18842','0','0','0'), ('70154','1','18842','0','0','0'), ('70155','1','2291','0','2825','0'), ('70156','1','25622','0','0','0'),
+('70157','1','25622','0','0','0'), ('70158','1','2291','0','2825','0'), ('70159','1','2291','0','2825','0'), ('70160','1','2291','0','2825','0'), ('70161','1','18842','0','0','0'), ('70162','1','18842','0','0','0'),
+('70163','1','18842','0','0','0'), ('70164','1','18842','0','0','0'), ('70165','1','18842','0','0','0'), ('70166','1','18842','0','0','0'), ('70167','1','18842','0','0','0'), ('70168','1','31289','0','0','0'),
+('70169','1','31289','0','0','0'), ('70170','1','31289','0','0','0'), ('70171','1','18842','0','0','0'), ('70172','1','18842','0','0','0'), ('70173','1','28367','0','0','0'), ('70174','1','12584','18825','0','0'),
+('70175','1','7723','0','0','0'), ('70176','1','25622','0','0','0'), ('70177','1','2291','0','2825','0'), ('70178','1','25622','0','0','0'), ('70179','1','2291','0','2825','0'), ('70180','1','2291','0','2825','0'),
+('70181','1','2291','0','2825','0'), ('70182','1','2291','0','2825','0'), ('70183','1','31289','0','0','0'), ('70184','1','31289','0','0','0'), ('70185','1','31289','0','0','0'), ('70186','1','25622','0','0','0'),
+('70187','1','13984','6448','0','0'), ('70188','1','18203','18202','0','0'), ('70189','1','18842','0','0','0'), ('70190','1','12584','18826','0','0'), ('70191','1','31186','0','0','0'), ('70192','1','31289','0','0','0'),
+('70193','1','13984','6448','0','0'), ('70194','1','2291','0','2825','0'), ('70195','1','12584','18826','0','0'), ('70196','1','31289','0','0','0'), ('70197','1','2291','0','2825','0'), ('70198','1','18842','0','0','0'),
+('70199','1','18876','0','0','0'), ('70200','1','31289','0','0','0'),
+('70201','1','27903','0','0','0'), ('70202','1','31186','0','0','0'), ('70203','1','31186','0','0','0'), ('70204','1','31186','0','0','0'), ('70205','1','18842','0','0','0'), ('70206','1','18842','0','0','0'),
+('70207','1','25622','0','0','0'), ('70208','1','2291','0','2825','0'), ('70209','1','2291','0','2825','0'), ('70210','1','12584','18826','0','0'), ('70211','1','6633','820','0','0'), ('70212','1','13984','6448','0','0'),
+('70213','1','25622','0','0','0'), ('70214','1','2291','0','2825','0'), ('70215','1','31289','0','0','0'), ('70216','1','18876','0','0','0'), ('70217','1','28367','0','0','0'), ('70218','1','18203','18202','0','0'),
+('70219','1','2291','0','2825','0'), ('70220','1','18002','0','0','0'), ('70221','1','18203','18202','0','0'), ('70222','1','18203','18202','0','0'), ('70223','1','18203','18202','0','0'), ('70224','1','27903','0','0','0'),
+('70225','1','18842','0','0','0'), ('70226','1','31289','0','0','0'), ('70227','1','12584','18825','0','0'), ('70228','1','2291','0','2825','0'), ('70229','1','18876','0','0','0'), ('70230','1','31289','0','0','0'),
+('70231','1','18842','0','0','0'), ('70232','1','18842','0','0','0'), ('70233','1','18203','18202','0','0'), ('70234','1','18203','18202','0','0'), ('70235','1','29175','18826','0','0'), ('70236','1','31289','0','0','0'),
+('70237','1','13505','0','0','0'), ('70238','1','12775','0','0','0'), ('70239','1','24044','0','0','0'), ('70240','1','43601','0','0','0'), ('70241','1','23499','0','0','0'), ('70242','1','38632','0','0','0'),
+('70243','1','34891','0','0','0'), ('70244','1','38632','0','0','0'), ('70245','1','50798','0','0','0'), ('70246','1','12592','0','0','0'), ('70301','1','24044','0','0','0'),
+
+('71000','1','0','30902','0','0');
+
+-- -- -- Update 18.09.13 - Equips for shamans
+-- Orcs and Draenei. Mainhand: Cudgel of Furious Justice, Offhand: Azure-Shield of Coldarra
+UPDATE `creature_equip_template` SET `itemID1` = '50050', `itemID2` = '29266', `itemID3` = '0' WHERE `CreatureID` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN @BOT_START AND @BOT_END) AND `trainer_class` = '7' AND (`trainer_race` = '2' OR `trainer_race` = '11'));
+-- Taurens and some Draenei. De-Raged Waraxe (Two-Hand)
+UPDATE `creature_equip_template` SET `itemID1` = '41816', `itemID2` = '0', `itemID3` = '0' WHERE `CreatureID` IN (SELECT entry FROM `creature_template` WHERE (`entry` BETWEEN @BOT_START AND @BOT_END) AND `trainer_class` = '7' AND (`trainer_race` = '6' OR `entry` IN (70218,70222,70223,70233)));
+
+
+-- GOSSIPS --
+delete from `npc_text` where ID between @BOT_START and @BOT_END;
+insert into `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `Probability0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `Probability1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `Probability2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `Probability3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`,
+`text4_0`, `text4_1`, `lang4`, `Probability4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `Probability5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `Probability6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `Probability7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`)
+values
+('70001','I live only to serve the master.','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70002','You need something?','','0','1','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','','','0','0','0','0','0','0','0','0','-213'),
+('70003','Mortals... usually I kill wretches like you at sight',NULL,'0','1','396','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0',NULL,NULL,'0','0','0','0','0','0','0','0','-213');
+
+
+-- OUTFITS --
+-- Npc Dress mod by Rochet2
+CREATE TABLE IF NOT EXISTS `creature_template_outfits` (
+    `entry` INT(10) UNSIGNED NOT NULL,
+    `race` tinyint(3) UNSIGNED NOT NULL DEFAULT '1',
+    `gender` tinyint(3) UNSIGNED NOT NULL DEFAULT '0' COMMENT '0 for male, 1 for female',
+    `skin` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `face` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `hair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `haircolor` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `facialhair` tinyint(3) UNSIGNED NOT NULL DEFAULT '0',
+    `head` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `shoulders` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `body` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `chest` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `waist` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `legs` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `feet` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `wrists` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `hands` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `back` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    `tabard` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+    PRIMARY KEY  (`entry`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+-- End Npc Dress mod
+
+replace into `creature_template_outfits` (`entry`, `race`, `gender`, `skin`, `face`, `hair`, `haircolor`, `facialhair`, `head`, `shoulders`, `body`, `chest`, `waist`, `legs`, `feet`, `wrists`, `hands`, `back`, `tabard`)
+values
+('70301','2','0','0','14','9','7','5','0','0','0','0','59194','64674','0','36248','0','0','0'), -- Blademaster
+('71000','11','1','0','5','0','6','0','0','53903','21842','35049','35058','35051','35067','35044','0','0','0'); -- Airen
+
+
+-- Customize section
+-- You can create your own values to be in line with your own server if these are not acceptable.
+
+SET @CLASS_WARRIOR = 1;
+SET @CLASS_PALADIN = 2;
+SET @CLASS_HUNTER  = 3;
+SET @CLASS_ROGUE   = 4;
+SET @CLASS_PRIEST  = 5;
+SET @CLASS_DK      = 6;
+SET @CLASS_SHAMAN  = 7;
+SET @CLASS_MAGE    = 8;
+SET @CLASS_WARLOCK = 9;
+SET @CLASS_DRUID   = 11;
+SET @CLASS_BM      = 12;
+
+-- Add flags_extra
+-- -- -- Update 6.04.14 - extra flags for recognizing bots core-side - CREATURE_FLAG_EXTRA_NPCBOT
+
+SET @EX_NO_PARRY_HASTEN = 8; -- 0x00000008 - CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN
+SET @EX_NO_BLOCK = 16; -- 0x00000010 - CREATURE_FLAG_EXTRA_NO_BLOCK
+SET @EX_NO_CRUSH = 32; -- 0x00000020 - CREATURE_FLAG_EXTRA_NO_CRUSH
+SET @EX_NO_XP = 64; -- 0x00000040 - CREATURE_FLAG_EXTRA_NO_XP_AT_KILL
+SET @EX_DIMINISH = 1048576; -- 0x00100000 - CREATURE_FLAG_EXTRA_ALL_DIMINISH
+SET @EX_NPCBOT = 67108864; -- 0x04000000 - CREATURE_FLAG_EXTRA_NPCBOT - custom flag
+SET @FLAGS_EX = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT;
+SET @FLAGS_EXN = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH | @EX_NPCBOT | @EX_NO_PARRY_HASTEN;
+SET @FLAGS_EX_PET = @EX_NO_BLOCK | @EX_NO_CRUSH | @EX_NO_XP | @EX_DIMINISH;
+
+-- Add extra 'unit_flags2' flags
+SET @U2_ENEMY_INTERRACT = 16384; -- 0x00004000 - UNIT_FLAG2_ALLOW_ENEMY_INTERACT
+SET @FLAGS_U2 = @U2_ENEMY_INTERRACT;
+
+-- minions
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3300, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DK;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2200, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_DRUID;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2800, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_HUNTER;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3800, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_MAGE;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2300, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PALADIN;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_PRIEST;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=1600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_ROGUE;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2600, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_SHAMAN;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3500, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARLOCK;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=3400, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_WARRIOR;
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=81, maxlevel:=81, baseattacktime:=2200, rangeattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EXN, unit_flags2:=`unit_flags2`|@FLAGS_U2, AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and trainer_class=@CLASS_BM;
+
+-- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK       -- DK
+-- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid    -- Druid
+-- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter   -- Hunter
+-- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage     -- Mage
+-- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin  -- Paladin
+-- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest   -- Priest
+-- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue    -- Rogue
+-- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman   -- Shaman
+-- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock  -- Warlock
+-- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior  -- Warrior
+-- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster  -- BMaster
+
+-- pets
+UPDATE `creature_template` SET exp:=2, faction:=14, DamageModifier:=1.0, minlevel:=80, maxlevel:=80, baseattacktime:=2000, dynamicflags:=0, speed_walk:=1.2, speed_run:=1.3, InhabitType:=3, HealthModifier:=1, ManaModifier:=1, ArmorModifier:=1, RegenHealth:=0, mechanic_immune_mask:=1, flags_extra:=@FLAGS_EX_PET,                                       AIName:='', VerifiedBuild:=-1 where entry between @BOT_START and @BOT_END-1 and name='Voidwalker';
+
+-- end
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 914ad31..c13349c 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -10,6 +10,7 @@
 
 add_subdirectory(genrev)
 add_subdirectory(common)
+add_subdirectory(plugins)
 
 if(SERVERS)
   add_subdirectory(server)
@@ -18,3 +19,4 @@ endif(SERVERS)
 if(TOOLS)
   add_subdirectory(tools)
 endif(TOOLS)
+
diff --git a/src/common/Configuration/Config.h b/src/common/Configuration/Config.h
index 5fb7cef..1979067 100644
--- a/src/common/Configuration/Config.h
+++ b/src/common/Configuration/Config.h
@@ -26,6 +26,8 @@
 
 class ConfigMgr
 {
+// playerbot mod
+public:
     ConfigMgr() { }
     ~ConfigMgr() { }
 
diff --git a/src/plugins/CMakeLists.txt b/src/plugins/CMakeLists.txt
new file mode 100644
index 0000000..804c47f
--- /dev/null
+++ b/src/plugins/CMakeLists.txt
@@ -0,0 +1,192 @@
+# Copyright (C) 2008-2014 TrinityCore <http://www.trinitycore.org/>
+#
+# This file is free software; as a special exception the author gives
+# unlimited permission to copy and/or distribute it, with or without
+# modifications, as long as this notice is preserved.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
+# implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+file(GLOB_RECURSE sources_Playerbot playerbot/*.cpp playerbot/*.h)
+file(GLOB_RECURSE sources_Ahbot ahbot/*.cpp ahbot/*.h)
+
+# Create plugins-libary
+
+if (USE_COREPCH)
+  set(plugins_STAT_PCH_HDR pch/pch.h)
+  set(plugins_STAT_PCH_SRC pch/pch.cpp)
+endif ()
+
+set(plugins_STAT_SRCS
+  ${sources_Playerbot}
+  ${sources_Ahbot}
+)
+
+include_directories(
+  ${CMAKE_BINARY_DIR}
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Detour/Include
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast
+  ${CMAKE_SOURCE_DIR}/dep/recastnavigation/Recast/Include
+  ${CMAKE_SOURCE_DIR}/dep/cppformat
+  ${CMAKE_SOURCE_DIR}/dep/g3dlite/include
+  ${CMAKE_SOURCE_DIR}/dep/SFMT
+  ${CMAKE_SOURCE_DIR}/dep/zlib
+  ${CMAKE_SOURCE_DIR}/src/common
+  ${CMAKE_SOURCE_DIR}/src/common/Collision
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Management
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/common/Collision/Models
+  ${CMAKE_SOURCE_DIR}/src/common/Configuration
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/common/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/common/Debugging
+  ${CMAKE_SOURCE_DIR}/src/common/Logging
+  ${CMAKE_SOURCE_DIR}/src/common/Threading
+  ${CMAKE_SOURCE_DIR}/src/common/Utilities
+  ${CMAKE_SOURCE_DIR}/src/server/collision
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Management
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Models
+  ${CMAKE_SOURCE_DIR}/src/server/collision/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Configuration
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Cryptography/Authentication
+  ${CMAKE_SOURCE_DIR}/src/server/database
+  ${CMAKE_SOURCE_DIR}/src/server/database/Database
+  ${CMAKE_SOURCE_DIR}/src/server/shared
+  ${CMAKE_SOURCE_DIR}/src/server/shared/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Debugging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic/LinkedReference
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Dynamic
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Logging
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Networking
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Packets
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Threading
+  ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
+  ${CMAKE_CURRENT_SOURCE_DIR}
+  ${CMAKE_SOURCE_DIR}/src/server/game
+  ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
+  ${CMAKE_SOURCE_DIR}/src/server/game/Addons
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
+  ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouseBot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlefield/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Battlegrounds/Zones
+  ${CMAKE_SOURCE_DIR}/src/server/game/Calendar
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Chat/Channels
+  ${CMAKE_SOURCE_DIR}/src/server/game/Combat
+  ${CMAKE_SOURCE_DIR}/src/server/game/Conditions
+  ${CMAKE_SOURCE_DIR}/src/server/game/DataStores
+  ${CMAKE_SOURCE_DIR}/src/server/game/DungeonFinding
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Creature
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Corpse
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/DynamicObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/GameObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/pluginsObject
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Item/Container
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Object/Updates
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Pet
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Player
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Totem
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Unit
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Vehicle
+  ${CMAKE_SOURCE_DIR}/src/server/game/Entities/Transport
+  ${CMAKE_SOURCE_DIR}/src/server/game/Events
+  ${CMAKE_SOURCE_DIR}/src/server/game/Globals
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Cells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids/Notifiers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Grids
+  ${CMAKE_SOURCE_DIR}/src/server/game/Groups
+  ${CMAKE_SOURCE_DIR}/src/server/game/Guilds
+  ${CMAKE_SOURCE_DIR}/src/server/game/Handlers
+  ${CMAKE_SOURCE_DIR}/src/server/game/Instances
+  ${CMAKE_SOURCE_DIR}/src/server/game/Loot
+  ${CMAKE_SOURCE_DIR}/src/server/game/Mails
+  ${CMAKE_SOURCE_DIR}/src/server/game/Maps
+  ${CMAKE_SOURCE_DIR}/src/server/game/Miscellaneous
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Spline
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/MovementGenerators
+  ${CMAKE_SOURCE_DIR}/src/server/game/Movement/Waypoints
+  ${CMAKE_SOURCE_DIR}/src/server/game/OutdoorPvP
+  ${CMAKE_SOURCE_DIR}/src/server/game/Pools
+  ${CMAKE_SOURCE_DIR}/src/server/game/PrecompiledHeaders
+  ${CMAKE_SOURCE_DIR}/src/server/game/Quests
+  ${CMAKE_SOURCE_DIR}/src/server/game/Reputation
+  ${CMAKE_SOURCE_DIR}/src/server/game/Scripting
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server/Protocol
+  ${CMAKE_SOURCE_DIR}/src/server/game/Server
+  ${CMAKE_SOURCE_DIR}/src/server/game/Skills
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells
+  ${CMAKE_SOURCE_DIR}/src/server/game/Spells/Auras
+  ${CMAKE_SOURCE_DIR}/src/server/game/Texts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tools
+  ${CMAKE_SOURCE_DIR}/src/server/game/Tickets
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden
+  ${CMAKE_SOURCE_DIR}/src/server/game/Warden/Modules
+  ${CMAKE_SOURCE_DIR}/src/server/game/Weather
+  ${CMAKE_SOURCE_DIR}/src/server/game/World
+  ${CMAKE_SOURCE_DIR}/src/server/scripts/PrecompiledHeaders
+  ${MYSQL_INCLUDE_DIR}
+  ${OPENSSL_INCLUDE_DIR}
+)
+
+add_library(plugins STATIC
+  ${plugins_STAT_SRCS}
+  ${plugins_STAT_PCH_SRC}
+)
+
+add_dependencies(plugins revision_data.h)
+
+if( WIN32 )
+  if ( MSVC )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+ 	  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/playerbot/aiplayerbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/$(ConfigurationName)/
+    )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+ 	  COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}/ahbot/ahbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/$(ConfigurationName)/
+    )
+  elseif ( MINGW )
+
+	 add_custom_command(TARGET plugins
+      POST_BUILD
+      COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}playerbot/aiplayerbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/
+    )
+	add_custom_command(TARGET plugins
+      POST_BUILD
+      COMMAND ${CMAKE_COMMAND} -E copy ${CMAKE_CURRENT_SOURCE_DIR}ahbot/ahbot.conf.dist.in ${CMAKE_BINARY_DIR}/bin/
+    )
+  endif()
+endif()
+
+if( UNIX )
+  install(TARGETS plugins DESTINATION bin)
+  install(FILES playerbot/aiplayerbot.conf.dist.in DESTINATION ${CONF_DIR})
+  install(FILES ahbot/ahbot.conf.dist.in DESTINATION ${CONF_DIR})
+elseif( WIN32 )
+  install(TARGETS plugins DESTINATION "${CMAKE_INSTALL_PREFIX}")
+  install(FILES playerbot/aiplayerbot.conf.dist.in DESTINATION "${CMAKE_INSTALL_PREFIX}")
+  install(FILES ahbot/ahbot.conf.dist.in DESTINATION "${CMAKE_INSTALL_PREFIX}")
+endif()
+
+
+
+# Generate precompiled header
+if (USE_COREPCH)
+  add_cxx_pch(plugins ${plugins_STAT_PCH_HDR} ${plugins_STAT_PCH_SRC})
+endif ()
diff --git a/src/plugins/ahbot/AhBot.cpp b/src/plugins/ahbot/AhBot.cpp
new file mode 100644
index 0000000..0134253
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.cpp
@@ -0,0 +1,985 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBot.h"
+#include "../World/World.h"
+#include "../Chat.h"
+#include "AhBotConfig.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../../game/Entities/Player/Player.h"
+#include "../playerbot/PlayerbotAIConfig.h"
+#include "../playerbot/playerbot.h"
+
+using namespace ahbot;
+
+bool Player::MinimalLoadFromDB( QueryResult result, uint32 guid )
+{
+    if (!result)
+    {
+        //                                        0     1           2           3           4    5          6          7
+        result = CharacterDatabase.PQuery("SELECT name, position_x, position_y, position_z, map, totaltime, leveltime, at_login FROM characters WHERE guid = '%u'",guid);
+        if (!result)
+            return false;
+    }
+
+    Field *fields = result->Fetch();
+
+    m_name = fields[0].GetString();
+
+    Relocate(fields[1].GetFloat(),fields[2].GetFloat(),fields[3].GetFloat());
+    SetLocationMapId(fields[4].GetUInt32());
+
+    m_Played_time[PLAYED_TIME_TOTAL] = fields[5].GetUInt32();
+    m_Played_time[PLAYED_TIME_LEVEL] = fields[6].GetUInt32();
+
+    m_atLoginFlags = fields[7].GetUInt32();
+
+    for (int i = 0; i < PLAYER_SLOTS_COUNT; ++i)
+        m_items[i] = NULL;
+
+    if (HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+        m_deathState = DEAD;
+
+    return true;
+}
+
+bool AhBot::HandleAhBotCommand(ChatHandler* handler, char const* args)
+{
+    auctionbot.HandleCommand(args);
+    return true;
+}
+
+uint32 AhBot::auctionIds[MAX_AUCTIONS] = {1,6,7};
+uint32 AhBot::auctioneers[MAX_AUCTIONS] = {79707,4656,23442};
+map<uint32, uint32> AhBot::factions;
+
+void AhBot::Init()
+{
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "Initializing AhBot by ike3");
+
+    if (!sAhBotConfig.Initialize())
+        return;
+
+    factions[1] = 1;
+    factions[2] = 1;
+    factions[3] = 1;
+    factions[4] = 2;
+    factions[5] = 2;
+    factions[6] = 2;
+    factions[7] = 3;
+
+    availableItems.Init();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot configuration loaded");
+}
+
+AhBot::~AhBot()
+{
+}
+
+ObjectGuid AhBot::GetAHBplayerGUID()
+{
+    return ObjectGuid(sAhBotConfig.guid);
+}
+
+void AhBotThread(AhBot* ahbot)
+{
+    ahbot->ForceUpdate();
+}
+
+void AhBot::Update()
+{
+    time_t now = time(0);
+
+    if (now < nextAICheckTime)
+        return;
+
+    if (updating)
+        return;
+
+    nextAICheckTime = time(0) + sAhBotConfig.updateInterval;
+
+    thread ahBotThread(AhBotThread, this);
+    ahBotThread.detach();
+}
+
+void AhBot::ForceUpdate()
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (updating)
+        return;
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is now checking auctions");
+    updating = true;
+
+    if (!allBidders.size())
+        LoadRandomBots();
+
+    if (!allBidders.size())
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "Ahbot is disabled but there is no bidders available");
+        return;
+    }
+
+    CheckCategoryMultipliers();
+
+    int answered = 0, added = 0;
+    for (int i = 0; i < MAX_AUCTIONS; i++)
+    {
+        InAuctionItemsBag inAuctionItems(auctionIds[i]);
+        inAuctionItems.Init(true);
+
+        for (int j = 0; j < CategoryList::instance.size(); j++)
+        {
+            Category* category = CategoryList::instance[j];
+            answered += Answer(i, category, &inAuctionItems);
+            added += AddAuctions(i, category, &inAuctionItems);
+        }
+    }
+
+    CleanupHistory();
+
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot auction check finished. %d auctions answered, %d new auctions added. Next check in %d seconds",
+            answered, added, sAhBotConfig.updateInterval);
+    updating = false;
+}
+
+struct SortByPricePredicate
+{
+    bool operator()(AuctionEntry* const & a, AuctionEntry* const & b) const
+    {
+        if (a->startbid == b->startbid)
+            return a->buyout < b->buyout;
+
+        return a->startbid < b->startbid;
+    }
+};
+
+vector<AuctionEntry*> AhBot::LoadAuctions(AuctionHouseObject* auctionHouse,
+        Category*& category, int& auction)
+{
+    vector<AuctionEntry*> entries;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (IsBotAuction(entry->owner) || IsBotAuction(entry->bidder))
+            continue;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item)
+            continue;
+
+        if (!category->Contains(item->GetTemplate()))
+            continue;
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(item->GetTemplate(), auctionIds[auction]);
+        if (!price || !item->GetCount())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price cannot be determined",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        entries.push_back(entry);
+    }
+    sort(entries.begin(), entries.end(), SortByPricePredicate());
+    return entries;
+}
+
+void AhBot::FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+        uint32* minBuyout)
+{
+    *minBid = 0;
+    *minBuyout = 0;
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+            itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *other = itr->second;
+        if (other->owner == entry->owner)
+            continue;
+
+        Item *otherItem = sAuctionMgr->GetAItem(other->itemGUIDLow);
+        if (!otherItem || !otherItem->GetCount() || otherItem->GetTemplate()->ItemId != item->GetTemplate()->ItemId)
+            continue;
+
+        uint32 startbid = other->startbid / otherItem->GetCount() * item->GetCount();
+        uint32 bid = other->bid / otherItem->GetCount() * item->GetCount();
+        uint32 buyout = other->buyout / otherItem->GetCount() * item->GetCount();
+
+        if (!bid && startbid && (!*minBid || *minBid > startbid))
+            *minBid = startbid;
+
+        if (bid && (*minBid || *minBid > bid))
+            *minBid = bid;
+
+        if (buyout && (!*minBuyout || *minBuyout > buyout))
+            *minBuyout = buyout;
+    }
+}
+
+int AhBot::Answer(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if (!ahEntry)
+        return 0;
+
+    int answered = 0;
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    int64 availableMoney = GetAvailableMoney(auctionIds[auction]);
+
+    vector<AuctionEntry*> entries = LoadAuctions(auctionHouse, category, auction);
+    for (vector<AuctionEntry*>::iterator itr = entries.begin(); itr != entries.end(); ++itr)
+    {
+        AuctionEntry *entry = *itr;
+
+        Item *item = sAuctionMgr->GetAItem(entry->itemGUIDLow);
+        if (!item || !item->GetCount())
+            continue;
+
+        const ItemTemplate* proto = item->GetTemplate();
+        vector<uint32> items = availableItems.Get(category);
+        if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: unavailable item",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 answerCount = GetAnswerCount(proto->ItemId, auctionIds[auction], sAhBotConfig.itemBuyMaxInterval);
+        uint32 maxAnswerCount = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAnswerCount && answerCount > maxAnswerCount)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: answer count %d > %d (max)",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], answerCount, maxAnswerCount);
+            continue;
+        }
+
+        if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: above max required or item level",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+        if (!price)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: cannot determine price",
+                    item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+            continue;
+        }
+
+        uint32 bidPrice = item->GetCount() * price;
+        uint32 buyoutPrice = item->GetCount() * urand(price, 4 * price / 3);
+
+        uint32 curPrice = entry->bid;
+        if (!curPrice) curPrice = entry->startbid;
+        if (!curPrice) curPrice = entry->buyout;
+
+        if (curPrice > buyoutPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (buyout price)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, buyoutPrice);
+            continue;
+        }
+
+        if (availableMoney < curPrice)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: price %d > %d (available money)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], curPrice, availableMoney);
+            continue;
+        }
+
+        uint32 minBid = 0, minBuyout = 0;
+        FindMinPrice(auctionHouse, entry, item, &minBid, &minBuyout);
+
+        if (minBid && entry->bid && minBid < entry->bid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (bid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->bid, minBid);
+            continue;
+        }
+
+        if (minBid && entry->startbid && minBid < entry->startbid)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: %d (startbid) > %d (minBid)",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->startbid, minBid);
+            continue;
+        }
+
+        double priceLevel = (double)curPrice / (double)buyoutPrice;
+        uint32 buytime = GetBuyTime(entry->Id, proto->ItemId, auctionIds[auction], category, priceLevel);
+        if (time(0) < buytime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s (x%d) in auction %d: will buy/bid in %d seconds",
+                    proto->Name1.c_str(), item->GetCount(), auctionIds[auction], buytime - time(0));
+            continue;
+        }
+
+        uint32 bidder = GetRandomBidder(auctionIds[auction]);
+        if (!bidder)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+            break;
+        }
+
+        entry->bidder = bidder;
+        entry->bid = curPrice + urand(1, 1 + bidPrice / 10);
+        availableMoney -= curPrice;
+
+        updateMarketPrice(item->GetTemplate()->ItemId, entry->buyout / item->GetCount(), auctionIds[auction]);
+
+        if ((entry->buyout && (entry->bid >= entry->buyout || 100 * (entry->buyout - entry->bid) / price < 25)) &&
+                !(minBuyout && entry->buyout && minBuyout < entry->buyout))
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d won %s (x%d) in auction %d for %d",
+                    bidder, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction], entry->buyout);
+
+            entry->bid = entry->buyout;
+        }
+        else
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d placed bid %d for %s (x%d) in auction %d",
+                    bidder, entry->bid, item->GetTemplate()->Name1.c_str(), item->GetCount(), auctionIds[auction]);
+
+            CharacterDatabase.PExecute("UPDATE auctionhouse SET buyguid = '%u',lastbid = '%u' WHERE id = '%u'",
+                entry->bidder, entry->bid, entry->Id);
+            AddToHistory(entry, AHBOT_WON_BID);
+        }
+
+        CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = 4 AND auction_house = '%u' ",
+                proto->ItemId, factions[auctionIds[auction]]);
+
+        answered++;
+    }
+
+    return answered;
+}
+
+uint32 AhBot::GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type)
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT MAX(buytime) FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    if (!results)
+        return 0;
+
+    Field* fields = results->Fetch();
+    uint32 result = fields[0].GetUInt32();
+
+    return result;
+}
+
+void AhBot::SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value)
+{
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE item = '%u' AND won = '%u' AND auction_house = '%u' AND category = '%s'",
+        id, type, factions[auctionHouse], category.c_str());
+
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        value, id, 0, 0,
+        category.c_str(), type, factions[auctionHouse]);
+}
+
+uint32 AhBot::GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel)
+{
+    uint32 entryTime = GetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY);
+    if (entryTime > time(0))
+        return entryTime;
+
+    uint32 result = entryTime;
+
+    string categoryName = category->GetName();
+    uint32 categoryTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel;
+    itemTime += urand(sAhBotConfig.itemBuyMinInterval, sAhBotConfig.itemBuyMaxInterval) * priceLevel / rarity;
+    entryTime = max(categoryTime, itemTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY, itemTime);
+    SetTime("entry", entry, auctionHouse, AHBOT_WON_DELAY, entryTime);
+
+    return result ? result : entryTime;
+}
+
+uint32 AhBot::GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category)
+{
+    uint32 itemSellTime = GetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 itemBuyTime = GetTime("item", itemId, auctionHouse, AHBOT_WON_DELAY);
+    uint32 itemTime = max(itemSellTime, itemBuyTime);
+
+    if (itemTime > time(0))
+        return itemTime;
+
+    uint32 result = itemTime;
+
+    string categoryName = category->GetName();
+    uint32 categorySellTime = GetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY);
+    uint32 categoryBuyTime = GetTime(categoryName, 0, auctionHouse, AHBOT_WON_DELAY);
+    uint32 categoryTime = max(categorySellTime, categoryBuyTime);
+
+    if (categoryTime < time(0)) categoryTime = time(0);
+    if (itemTime < time(0)) itemTime = time(0);
+
+    double rarity = category->GetPricingStrategy()->GetRarityPriceMultiplier(itemId);
+    categoryTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval);
+    itemTime += urand(sAhBotConfig.itemSellMinInterval, sAhBotConfig.itemSellMaxInterval) * rarity;
+    itemTime = max(itemTime, categoryTime);
+
+    SetTime(categoryName, 0, auctionHouse, AHBOT_SELL_DELAY, categoryTime);
+    SetTime("item", itemId, auctionHouse, AHBOT_SELL_DELAY, itemTime);
+
+    return result ? result : itemTime;
+}
+
+int AhBot::AddAuctions(int auction, Category* category, ItemBag* inAuctionItems)
+{
+    vector<uint32>& inAuction = inAuctionItems->Get(category);
+
+    int32 maxAllowedAuctionCount = categoryMaxAuctionCount[category->GetName()];
+    if (inAuctionItems->GetCount(category) >= maxAllowedAuctionCount)
+        return 0;
+
+    int added = 0;
+    vector<uint32> available = availableItems.Get(category);
+    for (int32 i = 0; i <= maxAllowedAuctionCount && available.size() > 0 && inAuctionItems->GetCount(category) < maxAllowedAuctionCount; ++i)
+    {
+        uint32 index = urand(0, available.size() - 1);
+        uint32 itemId = available[index];
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        int32 maxAllowedItems = category->GetMaxAllowedItemAuctionCount(proto);
+        if (maxAllowedItems && inAuctionItems->GetCount(category, proto->ItemId) >= maxAllowedItems)
+            continue;
+
+        uint32 sellTime = GetSellTime(proto->ItemId, auctionIds[auction], category);
+        if (time(0) < sellTime)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: will add in %d seconds",
+                    proto->Name1.c_str(), auctionIds[auction], sellTime - time(0));
+            continue;
+        }
+        else if (time(0) - sellTime > sAhBotConfig.maxSellInterval)
+        {
+            sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "%s in auction %d: too old (%d secs)",
+                    proto->Name1.c_str(), auctionIds[auction], time(0) - sellTime);
+            continue;
+        }
+
+        inAuctionItems->Add(proto);
+        added += AddAuction(auction, category, proto);
+    }
+
+    return added;
+}
+
+int AhBot::AddAuction(int auction, Category* category, ItemTemplate const* proto)
+{
+    uint32 owner = GetRandomBidder(auctionIds[auction]);
+    if (!owner)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_ERROR, "No bidders for auction %d", auctionIds[auction]);
+        return 0;
+    }
+
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return 0;
+
+    uint32 price = category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddAuction: market price adjust");
+    updateMarketPrice(proto->ItemId, price, auctionIds[auction]);
+
+    price = category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+    uint32 stackCount = category->GetStackCount(proto);
+    if (!price || !stackCount)
+        return 0;
+
+    if (urand(0, 100) <= sAhBotConfig.underPriceProbability * 100)
+        price = price * 100 / urand(100, 200);
+
+    uint32 bidPrice = stackCount * price;
+    uint32 buyoutPrice = stackCount * urand(price, 4 * price / 3);
+
+    Item* item = Item::CreateItem(proto->ItemId, stackCount);
+    if (!item)
+        return 0;
+
+    uint32 randomPropertyId = Item::GenerateItemRandomPropertyId(proto->ItemId);
+    if (randomPropertyId)
+        item->SetItemRandomProperties(randomPropertyId);
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return 0;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionEntry* auctionEntry = new AuctionEntry;
+    auctionEntry->Id = sObjectMgr->GenerateAuctionID();
+    auctionEntry->itemGUIDLow = item->GetGUID().GetCounter();
+    auctionEntry->itemEntry = item->GetEntry();
+    auctionEntry->owner = owner;
+    auctionEntry->startbid = bidPrice;
+    auctionEntry->buyout = buyoutPrice;
+    // TODO: remove?
+    // auctionEntry->auctioneer = auctioneers[auction];
+    auctionEntry->bidder = 0;
+    auctionEntry->bid = 0;
+    auctionEntry->deposit = 0;
+    auctionEntry->expire_time = (time_t) (urand(8, 24) * 60 * 60 + time(NULL));
+    auctionEntry->auctionHouseEntry = ahEntry;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    item->SaveToDB(trans);
+    sAuctionMgr->AddAItem(item);
+    auctionHouse->AddAuction(auctionEntry);
+    auctionEntry->SaveToDB(trans);
+
+    auctionHouse->AddAuction(auctionEntry);
+
+    CharacterDatabase.CommitTransaction(trans);
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AhBot %d added %d of %s to auction %d for %d..%d", owner, stackCount, proto->Name1.c_str(), auctionIds[auction], bidPrice, buyoutPrice);
+    return 1;
+}
+
+void AhBot::HandleCommand(string command)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    if (command == "expire")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            Expire(i);
+
+        return;
+    }
+
+    if (command == "stats")
+    {
+        for (int i = 0; i < MAX_AUCTIONS; i++)
+            PrintStats(i);
+
+        return;
+    }
+
+    if (command == "update")
+    {
+        thread ahBotThread(AhBotThread, this);
+        ahBotThread.detach();
+        return;
+    }
+
+    uint32 itemId = atoi(command.c_str());
+    if (!itemId)
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot stats - show short summary");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot expire - expire all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot update - update all auctions");
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "ahbot <itemId> - show item price");
+        return;
+    }
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (category->Contains(proto))
+        {
+            vector<uint32> items = availableItems.Get(category);
+            if (find(items.begin(), items.end(), proto->ItemId) == items.end())
+                continue;
+
+            ostringstream out;
+            out << proto->Name1 << " (" << category->GetDisplayName() << "), "
+                    << category->GetMaxAllowedAuctionCount() << "x" << category->GetMaxAllowedItemAuctionCount(proto)
+                    << "x" << category->GetStackCount(proto) << " max"
+                    << "\n";
+            for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+            {
+                const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+                out << "--- auction house " << auctionIds[auction] << "(faction: " << factions[auctionIds[auction]] << ", money: "
+                    << GetAvailableMoney(auctionIds[auction])
+                    << ") ---\n";
+
+                out << "sell: " << category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainSellPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+
+                out << "buy: " << category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction])
+                    << " ("  << category->GetPricingStrategy()->ExplainBuyPrice(proto, auctionIds[auction]) << ")"
+                    << "\n";
+            }
+            sLog->outMessage("ahbot", LOG_LEVEL_INFO, out.str().c_str());
+            break;
+        }
+    }
+}
+
+void AhBot::Expire(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionIds[auction]);
+
+    AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin();
+
+    int count = 0;
+    while (itr != auctionHouse->GetAuctionsEnd())
+    {
+        if (IsBotAuction(itr->second->owner))
+        {
+            itr->second->expire_time = sWorld->GetGameTime();
+            count++;
+        }
+
+        ++itr;
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions marked as expired in auction %d", count, auctionIds[auction]);
+}
+
+void AhBot::PrintStats(int auction)
+{
+    if (!sAhBotConfig.enabled)
+        return;
+
+    AuctionHouseEntry const* ahEntry = sAuctionHouseStore.LookupEntry(auctionIds[auction]);
+    if(!ahEntry)
+        return;
+
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auction);
+    sLog->outMessage("ahbot", LOG_LEVEL_INFO, "%d auctions available on auction house %d", auctionHouse->Getcount(), auctionIds[auction]);
+}
+
+void AhBot::AddToHistory(AuctionEntry* entry, uint32 won)
+{
+    if (!sAhBotConfig.enabled || !entry)
+        return;
+
+    if (!IsBotAuction(entry->owner) && !IsBotAuction(entry->bidder))
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(entry->itemEntry);
+    if (!proto)
+        return;
+
+    string category = "";
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            category = CategoryList::instance[i]->GetName();
+            break;
+        }
+    }
+
+    if (!won)
+    {
+        won = AHBOT_WON_PLAYER;
+        if (IsBotAuction(entry->bidder))
+            won = AHBOT_WON_SELF;
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "AddToHistory: market price adjust");
+    int count = entry->itemCount ? entry->itemCount : 1;
+    updateMarketPrice(proto->ItemId, entry->buyout / count, entry->auctionHouseEntry->houseId);
+
+    uint32 now = time(0);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_history (buytime, item, bid, buyout, category, won, auction_house) "
+        "VALUES ('%u', '%u', '%u', '%u', '%s', '%u', '%u')",
+        now, entry->itemEntry, entry->bid ? entry->bid : entry->startbid, entry->buyout,
+        category.c_str(), won, factions[entry->auctionHouseEntry->houseId]);
+}
+
+uint32 AhBot::GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime)
+{
+    uint32 count = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT COUNT(*) FROM ahbot_history WHERE "
+        "item = '%u' AND won in (2, 3) AND auction_house = '%u' AND buytime > '%u'",
+        itemId, factions[auctionHouse], time(0) - withinTime);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            count = fields[0].GetUInt32();
+        } while (results->NextRow());
+    }
+
+    return count;
+}
+
+void AhBot::CleanupHistory()
+{
+    uint32 when = time(0) - 3600 * 24 * sAhBotConfig.historyDays;
+    CharacterDatabase.PExecute("DELETE FROM ahbot_history WHERE buytime < '%u'", when);
+}
+
+uint32 AhBot::GetAvailableMoney(uint32 auctionHouse)
+{
+    int64 result = sAhBotConfig.alwaysAvailableMoney;
+
+    map<uint32, uint32> data;
+    data[AHBOT_WON_PLAYER] = 0;
+    data[AHBOT_WON_SELF] = 0;
+
+    const AuctionHouseEntry* ahEntry = sAuctionHouseStore.LookupEntry(auctionHouse);
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT won, SUM(bid) FROM ahbot_history WHERE auction_house = '%u' GROUP BY won HAVING won > 0 ORDER BY won",
+        factions[auctionHouse]);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            data[fields[0].GetUInt32()] = fields[1].GetUInt32();
+
+        } while (results->NextRow());
+    }
+
+    results = CharacterDatabase.PQuery(
+        "SELECT max(buytime) FROM ahbot_history WHERE auction_house = '%u' AND won = '2'",
+        factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 lastBuyTime = fields[0].GetUInt32();
+        uint32 now = time(0);
+        if (lastBuyTime && now > lastBuyTime)
+        result += (now - lastBuyTime) / 3600 / 24 * sAhBotConfig.alwaysAvailableMoney;
+    }
+
+    AuctionHouseObject* auctionHouseObject = sAuctionMgr->GetAuctionsMap(auctionHouse);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouseObject->GetAuctionsBegin(); itr != auctionHouseObject->GetAuctionsEnd(); ++itr)
+    {
+        AuctionEntry *entry = itr->second;
+        if (!IsBotAuction(entry->bidder))
+            continue;
+
+        result -= entry->bid;
+    }
+
+    result += (data[AHBOT_WON_PLAYER] - data[AHBOT_WON_SELF]);
+    return result < 0 ? 0 : (uint32)result;
+}
+
+void AhBot::CheckCategoryMultipliers()
+{
+    QueryResult results = CharacterDatabase.PQuery("SELECT category, multiplier, max_auction_count, expire_time FROM ahbot_category");
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            categoryMultipliers[fields[0].GetString()] = fields[1].GetFloat();
+            categoryMaxAuctionCount[fields[0].GetString()] = fields[2].GetInt32();
+            categoryMultiplierExpireTimes[fields[0].GetString()] = fields[3].GetUInt64();
+
+        } while (results->NextRow());
+    }
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_category");
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        string name = CategoryList::instance[i]->GetName();
+        int theTime = time(0);
+        if (categoryMultiplierExpireTimes[name] <= theTime || categoryMultipliers[name] <= 0)
+        {
+            categoryMultipliers[name] = (double)urand(20, 100) / 20.0;
+            uint32 maxAllowedAuctionCount = CategoryList::instance[i]->GetMaxAllowedAuctionCount();
+            categoryMaxAuctionCount[name] = urand(maxAllowedAuctionCount / 2, maxAllowedAuctionCount);
+            categoryMultiplierExpireTimes[name] = time(0) + urand(4, 7) * 3600 * 24;
+        }
+
+        CharacterDatabase.PExecute("INSERT INTO ahbot_category (category, multiplier, max_auction_count, expire_time) "
+                "VALUES ('%s', '%f', '%u', '%u')",
+                name.c_str(), categoryMultipliers[name], categoryMaxAuctionCount[name], categoryMultiplierExpireTimes[name]);
+    }
+}
+
+
+void AhBot::updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    if (marketPrice > 0)
+        marketPrice = (marketPrice + price) / 2;
+    else
+        marketPrice = price;
+
+    CharacterDatabase.PExecute("DELETE FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    CharacterDatabase.PExecute("INSERT INTO ahbot_price (item, price, auction_house) VALUES ('%u', '%lf', '%u')", itemId, marketPrice, auctionHouse);
+}
+
+bool AhBot::IsBotAuction(uint32 bidder)
+{
+    return allBidders.find(bidder) != allBidders.end();
+}
+
+uint32 AhBot::GetRandomBidder(uint32 auctionHouse)
+{
+    vector<uint32> guids = bidders[factions[auctionHouse]];
+    if (guids.empty())
+        return 0;
+
+    vector<uint32> online;
+    for (vector<uint32>::iterator i = guids.begin(); i != guids.end(); ++i)
+    {
+        uint32 guid = *i;
+        Player* player = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (!player)
+            continue;
+
+        online.push_back(guid);
+    }
+
+    if (online.empty())
+        return 0;
+
+    int index = urand(0, online.size() - 1);
+    return online[index];
+}
+
+void AhBot::LoadRandomBots()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            uint32 auctionHouse = PlayerbotAI::IsOpposing(race, RACE_HUMAN) ? 2 : 1;
+            bidders[auctionHouse].push_back(guid);
+            bidders[3].push_back(guid);
+            allBidders.insert(guid);
+        } while (result->NextRow());
+    }
+
+    if (allBidders.empty() && sAhBotConfig.guid)
+    {
+        uint32 guid = sAhBotConfig.guid;
+        allBidders.insert(guid);
+        for (int i = 1; i <= 3; i++)
+        {
+            bidders[i].push_back(guid);
+        }
+    }
+
+    sLog->outMessage("ahbot", LOG_LEVEL_DEBUG, "{A=%d,H=%d,N=%d} bidders loaded", bidders[1].size(), bidders[2].size(), bidders[3].size());
+}
+
+int32 AhBot::GetSellPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetSellPrice(proto, auctionIds[auction]);
+            if (!price)
+                price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+int32 AhBot::GetBuyPrice(ItemTemplate const* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 0;
+
+    int32 maxPrice = 0;
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        for (int auction = 0; auction < MAX_AUCTIONS; auction++)
+        {
+            int32 price = (int32)category->GetPricingStrategy()->GetBuyPrice(proto, auctionIds[auction]);
+            if (!price)
+                continue;
+
+            if (price > maxPrice)
+                maxPrice = price;
+        }
+    }
+
+    return maxPrice;
+}
+
+double AhBot::GetRarityPriceMultiplier(const ItemTemplate* proto)
+{
+    if (!sAhBotConfig.enabled)
+        return 1.0;
+
+    for (int i=0; i<CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        if (!category->Contains(proto))
+            continue;
+
+        return category->GetPricingStrategy()->GetRarityPriceMultiplier(proto->ItemId);
+    }
+
+    return 1.0;
+
+}
diff --git a/src/plugins/ahbot/AhBot.h b/src/plugins/ahbot/AhBot.h
new file mode 100644
index 0000000..4b704fb
--- /dev/null
+++ b/src/plugins/ahbot/AhBot.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "Category.h"
+#include "ItemBag.h"
+#include "../playerbot/PlayerbotAIBase.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+#include "../WorldSession.h"
+#include "../pchdef.h"
+
+#define MAX_AUCTIONS 3
+#define AHBOT_WON_EXPIRE 0
+#define AHBOT_WON_PLAYER 1
+#define AHBOT_WON_SELF 2
+#define AHBOT_WON_BID 3
+#define AHBOT_WON_DELAY 4
+#define AHBOT_SELL_DELAY 5
+
+namespace ahbot
+{
+    using namespace std;
+
+    class AhBot
+    {
+    public:
+        AhBot() : nextAICheckTime(0), updating(false) {}
+        virtual ~AhBot();
+        static AhBot& instance()
+        {
+            static AhBot instance;
+            return instance;
+        }
+
+    public:
+        static bool HandleAhBotCommand(ChatHandler* handler, char const* args);
+        ObjectGuid GetAHBplayerGUID();
+        void Init();
+        void Update();
+        void ForceUpdate();
+        void HandleCommand(string command);
+        void Won(AuctionEntry* entry) { AddToHistory(entry); }
+        void Expired(AuctionEntry* entry) {}
+
+        double GetCategoryMultiplier(string category)
+        {
+            return categoryMultipliers[category];
+        }
+
+        int32 GetSellPrice(const ItemTemplate* proto);
+        int32 GetBuyPrice(const ItemTemplate* proto);
+        double GetRarityPriceMultiplier(const ItemTemplate* proto);
+
+    private:
+        int Answer(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuctions(int auction, Category* category, ItemBag* inAuctionItems);
+        int AddAuction(int auction, Category* category, const ItemTemplate* proto);
+        void Expire(int auction);
+        void PrintStats(int auction);
+        void AddToHistory(AuctionEntry* entry, uint32 won = 0);
+        void CleanupHistory();
+        uint32 GetAvailableMoney(uint32 auctionHouse);
+        void CheckCategoryMultipliers();
+        void updateMarketPrice(uint32 itemId, double price, uint32 auctionHouse);
+        bool IsBotAuction(uint32 bidder);
+        uint32 GetRandomBidder(uint32 auctionHouse);
+        void LoadRandomBots();
+        uint32 GetAnswerCount(uint32 itemId, uint32 auctionHouse, uint32 withinTime);
+        vector<AuctionEntry*> LoadAuctions(AuctionHouseObject* auctionHouse, Category*& category,
+                int& auction);
+        void FindMinPrice(AuctionHouseObject* auctionHouse, AuctionEntry*& entry, Item*& item, uint32* minBid,
+                uint32* minBuyout);
+        uint32 GetBuyTime(uint32 entry, uint32 itemId, uint32 auctionHouse, Category*& category, double priceLevel);
+        uint32 GetTime(string category, uint32 id, uint32 auctionHouse, uint32 type);
+        void SetTime(string category, uint32 id, uint32 auctionHouse, uint32 type, uint32 value);
+        uint32 GetSellTime(uint32 itemId, uint32 auctionHouse, Category*& category);
+
+    public:
+        static uint32 auctionIds[MAX_AUCTIONS];
+        static uint32 auctioneers[MAX_AUCTIONS];
+        static map<uint32, uint32> factions;
+
+    private:
+        AvailableItemsBag availableItems;
+        time_t nextAICheckTime;
+        map<string, double> categoryMultipliers;
+        map<string, uint32> categoryMaxAuctionCount;
+        map<string, uint64> categoryMultiplierExpireTimes;
+        map<uint32, vector<uint32> > bidders;
+        set<uint32> allBidders;
+        bool updating;
+    };
+};
+
+#define auctionbot ahbot::AhBot::instance()
diff --git a/src/plugins/ahbot/AhBotConfig.cpp b/src/plugins/ahbot/AhBotConfig.cpp
new file mode 100644
index 0000000..561b652
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.cpp
@@ -0,0 +1,58 @@
+#include "../pchdef.h"
+#include "AhBotConfig.h"
+std::vector<std::string> split(const std::string &s, char delim);
+
+using namespace std;
+
+AhBotConfig::AhBotConfig()
+{
+}
+
+template <class T>
+void LoadSet(string value, T &res)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        res.insert(id);
+    }
+}
+
+bool AhBotConfig::Initialize()
+{
+    string error;
+    if (!config.LoadInitial("ahbot.conf", error))
+    {
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled. Unable to open configuration file ahbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AhBot.Enabled", true);
+
+    if (!enabled)
+        sLog->outMessage("ahbot", LOG_LEVEL_INFO, "AhBot is Disabled in ahbot.conf");
+
+    guid = (uint64)config.GetIntDefault("AhBot.GUID", 0);
+    updateInterval = config.GetIntDefault("AhBot.UpdateIntervalInSeconds", 300);
+    historyDays = config.GetIntDefault("AhBot.History.Days", 30);
+    itemBuyMinInterval = config.GetIntDefault("AhBot.ItemBuyMinInterval", 7200);
+    itemBuyMaxInterval = config.GetIntDefault("AhBot.ItemBuyMaxInterval", 28800);
+    itemSellMinInterval = config.GetIntDefault("AhBot.ItemSellMinInterval", 7200);
+    itemSellMaxInterval = config.GetIntDefault("AhBot.ItemSellMaxInterval", 28800);
+    maxSellInterval = config.GetIntDefault("AhBot.MaxSellInterval", 3600 * 8);
+    alwaysAvailableMoney = config.GetIntDefault("AhBot.AlwaysAvailableMoney", 200000);
+    priceMultiplier = config.GetFloatDefault("AhBot.PriceMultiplier", 1.0f);
+    defaultMinPrice = config.GetIntDefault("AhBot.DefaultMinPrice", 20);
+    maxItemLevel = config.GetIntDefault("AhBot.MaxItemLevel", 199);
+    maxRequiredLevel = config.GetIntDefault("AhBot.MaxRequiredLevel", 80);
+    priceQualityMultiplier = config.GetFloatDefault("AhBot.PriceQualityMultiplier", 1.0f);
+    underPriceProbability = config.GetFloatDefault("AhBot.UnderPriceProbability", 0.05f);
+    LoadSet<set<uint32> >(config.GetStringDefault("AhBot.IgnoreItemIds", "49283,52200,8494,6345,6891,2460,37164,34835"), ignoreItemIds);
+
+
+    return enabled;
+}
diff --git a/src/plugins/ahbot/AhBotConfig.h b/src/plugins/ahbot/AhBotConfig.h
new file mode 100644
index 0000000..1826109
--- /dev/null
+++ b/src/plugins/ahbot/AhBotConfig.h
@@ -0,0 +1,93 @@
+#pragma once
+
+#include "../../common/Configuration/Config.h"
+
+using namespace std;
+
+class AhBotConfig
+{
+public:
+    AhBotConfig();
+    static AhBotConfig& instance()
+    {
+        static AhBotConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+
+    bool enabled;
+    uint64 guid;
+    uint32 updateInterval;
+    uint32 historyDays, maxSellInterval;
+    uint32 itemBuyMinInterval, itemBuyMaxInterval;
+    uint32 itemSellMinInterval, itemSellMaxInterval;
+    uint32 alwaysAvailableMoney;
+    float priceMultiplier, priceQualityMultiplier;
+    uint32 defaultMinPrice;
+    uint32 maxItemLevel, maxRequiredLevel;
+    float underPriceProbability;
+    std::set<uint32> ignoreItemIds;
+
+    float GetSellPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(sellPriceMultipliers, "PriceMultiplier.Sell", category, 1.0f);
+    }
+
+    float GetBuyPriceMultiplier(string category)
+    {
+        return GetCategoryParameter(buyPriceMultipliers, "PriceMultiplier.Buy", category, 1.0f);
+    }
+
+    float GetItemPriceMultiplier(string name)
+    {
+        return GetCategoryParameter(itemPriceMultipliers, "PriceMultiplier.Item", name, 1.0f);
+    }
+
+    int32 GetMaxAllowedAuctionCount(string category)
+    {
+        return (int32)GetCategoryParameter(maxAuctionCount, "MaxAuctionCount", category, 5);
+    }
+
+    std::string GetStringDefault(const char* name, const char* def)
+    {
+        return config.GetStringDefault(name, def);
+    }
+
+    bool GetBoolDefault(const char* name, const bool def = false)
+    {
+        return config.GetBoolDefault(name, def);
+    }
+
+    int32 GetIntDefault(const char* name, const int32 def)
+    {
+        return config.GetIntDefault(name, def);
+    }
+
+    float GetFloatDefault(const char* name, const float def)
+    {
+        return config.GetFloatDefault(name, def);
+    }
+
+private:
+    float GetCategoryParameter(map<string, float>& cache, string type, string category, float defaultValue)
+    {
+        if (cache.find(category) == cache.end())
+        {
+            ostringstream out; out << "AhBot."<< type << "." << category;
+            cache[category] = config.GetFloatDefault(out.str().c_str(), defaultValue);
+        }
+
+        return cache[category];
+    }
+
+private:
+    ConfigMgr config;
+    map<string, float> sellPriceMultipliers;
+    map<string, float> buyPriceMultipliers;
+    map<string, float> itemPriceMultipliers;
+    map<string, float> maxAuctionCount;
+};
+
+#define sAhBotConfig AhBotConfig::instance()
diff --git a/src/plugins/ahbot/Category.cpp b/src/plugins/ahbot/Category.cpp
new file mode 100644
index 0000000..1dd0ac5
--- /dev/null
+++ b/src/plugins/ahbot/Category.cpp
@@ -0,0 +1,76 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "PricingStrategy.h"
+
+using namespace ahbot;
+
+uint32 Category::GetStackCount(ItemTemplate const* proto)
+{
+    if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+        return 1;
+
+    return urand(1, proto->GetMaxStackSize());
+}
+
+uint32 Category::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return 0;
+}
+
+uint32 Category::GetMaxAllowedAuctionCount()
+{
+    return sAhBotConfig.GetMaxAllowedAuctionCount(GetName());
+}
+
+PricingStrategy* Category::GetPricingStrategy()
+{
+    if (pricingStrategy)
+        return pricingStrategy;
+
+    ostringstream out; out << "AhBot.PricingStrategy." << GetName();
+    string name = sAhBotConfig.GetStringDefault(out.str().c_str(), "default");
+    return pricingStrategy = PricingStrategyFactory::Create(name, this);
+}
+
+QualityCategoryWrapper::QualityCategoryWrapper(Category* category, uint32 quality) : Category(), quality(quality), category(category)
+{
+    ostringstream out; out << category->GetName() << ".";
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR:
+        out << "gray";
+        break;
+    case ITEM_QUALITY_NORMAL:
+        out << "white";
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        out << "green";
+        break;
+    case ITEM_QUALITY_RARE:
+        out << "blue";
+        break;
+    default:
+        out << "epic";
+        break;
+    }
+
+    combinedName = out.str();
+}
+
+bool QualityCategoryWrapper::Contains(ItemTemplate const* proto)
+{
+    return proto->Quality == quality && category->Contains(proto);
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedAuctionCount()
+{
+    uint32 count = sAhBotConfig.GetMaxAllowedAuctionCount(combinedName);
+    return count > 0 ? count : category->GetMaxAllowedAuctionCount();
+}
+
+uint32 QualityCategoryWrapper::GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+{
+    return category->GetMaxAllowedItemAuctionCount(proto);
+}
diff --git a/src/plugins/ahbot/Category.h b/src/plugins/ahbot/Category.h
new file mode 100644
index 0000000..ed528dd
--- /dev/null
+++ b/src/plugins/ahbot/Category.h
@@ -0,0 +1,354 @@
+#pragma once
+#include "PricingStrategy.h"
+#include "../Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category
+    {
+    public:
+        Category() : pricingStrategy(NULL) {}
+        virtual ~Category() { if (pricingStrategy) delete pricingStrategy; }
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto) { return false; }
+        virtual string GetName() { return "default"; }
+        virtual string GetDisplayName() { return GetName(); }
+
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto);
+
+        virtual PricingStrategy* GetPricingStrategy();
+
+    private:
+        PricingStrategy *pricingStrategy;
+    };
+
+    class Consumable : public Category
+    {
+    public:
+        Consumable() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONSUMABLE;
+        }
+
+        virtual string GetName() { return "consumable"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 10;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (maxStackSize == 1)
+                return 1;
+
+            if (maxStackSize <= 10)
+                return urand(1, 10);
+
+            return urand(1, 4) * maxStackSize / 5;
+        }
+    };
+
+    class Quest : public Category
+    {
+    public:
+        Quest() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUEST;
+        }
+        virtual string GetName() { return "quest"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            if (proto->Quality > ITEM_QUALITY_UNCOMMON)
+                return 1;
+
+            uint32 maxStackSize = proto->GetMaxStackSize();
+            if (proto->Quality == ITEM_QUALITY_UNCOMMON && maxStackSize > 10)
+                maxStackSize = urand(1, 10);
+
+            if (maxStackSize > 20)
+                maxStackSize = urand(1, 20);
+
+            return maxStackSize;
+        }
+    };
+
+    class Trade : public Category
+    {
+    public:
+        Trade() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_TRADE_GOODS;
+        }
+        virtual string GetName() { return "trade"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            uint32 maxStack = proto->GetMaxStackSize();
+            if (maxStack < 2)
+                return maxStack;
+
+            switch (proto->Quality)
+            {
+            case ITEM_QUALITY_NORMAL:
+                return maxStack;
+            case ITEM_QUALITY_UNCOMMON:
+                return urand(1, maxStack);
+            }
+
+            return 1;
+        }
+    };
+
+    class Enchant : public Category
+    {
+    public:
+        Enchant() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PERMANENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "enchant"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Reagent : public Category
+    {
+    public:
+        Reagent() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_REAGENT && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "reagent"; }
+    };
+
+    class Recipe : public Category
+    {
+    public:
+        Recipe() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_RECIPE && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "recipe"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Equip : public Category
+    {
+    public:
+        Equip() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return (proto->Class == ITEM_CLASS_WEAPON ||
+                proto->Class == ITEM_CLASS_ARMOR) && proto->ItemLevel > 1;
+        }
+        virtual string GetName() { return "equip"; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Other : public Category
+    {
+    public:
+        Other() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Quality > ITEM_QUALITY_POOR && (
+                proto->Class == ITEM_CLASS_MISC ||
+                proto->Class == ITEM_CLASS_GENERIC ||
+                proto->Class == ITEM_CLASS_MONEY) && proto->ItemLevel > 1 && proto->SubClass != ITEM_SUBCLASS_JUNK_MOUNT;
+        }
+        virtual string GetName() { return "other"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Quiver : public Category
+    {
+    public:
+        Quiver() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_QUIVER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "quiver"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Projectile : public Category
+    {
+    public:
+        Projectile() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_PROJECTILE;
+        }
+
+        virtual string GetName() { return "projectile"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 5;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return proto->GetMaxStackSize();
+        }
+    };
+
+    class Container : public Category
+    {
+    public:
+        Container() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_CONTAINER && proto->ItemLevel > 1;
+        }
+
+        virtual string GetName() { return "container"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class Glyph : public Category
+    {
+    public:
+        Glyph() : Category() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GLYPH;
+        }
+
+        virtual string GetName() { return "glyph"; }
+
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+
+        virtual uint32 GetStackCount(ItemTemplate const* proto)
+        {
+            return 1;
+        }
+    };
+
+    class QualityCategoryWrapper : public Category
+    {
+    public:
+        QualityCategoryWrapper(Category* category, uint32 quality);
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto);
+        virtual uint32 GetMaxAllowedAuctionCount();
+        virtual string GetName() { return category->GetName(); }
+        virtual string GetDisplayName() { return combinedName; }
+        virtual uint32 GetMaxAllowedItemAuctionCount(ItemTemplate const* proto);
+        virtual uint32 GetStackCount(ItemTemplate const* proto) { return category->GetStackCount(proto); }
+        virtual PricingStrategy* GetPricingStrategy() { return category->GetPricingStrategy(); }
+
+    private:
+        uint32 quality;
+        Category* category;
+        string combinedName;
+    };
+};
diff --git a/src/plugins/ahbot/ConsumableCategory.cpp b/src/plugins/ahbot/ConsumableCategory.cpp
new file mode 100644
index 0000000..2cd06c5
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.cpp
@@ -0,0 +1,5 @@
+#include "../pchdef.h"
+#include "ConsumableCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/ConsumableCategory.h b/src/plugins/ahbot/ConsumableCategory.h
new file mode 100644
index 0000000..6f3051b
--- /dev/null
+++ b/src/plugins/ahbot/ConsumableCategory.h
@@ -0,0 +1,86 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Alchemy : public Consumable
+    {
+    public:
+        Alchemy() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_POTION ||
+                    proto->SubClass == ITEM_SUBCLASS_ELIXIR ||
+                    proto->SubClass == ITEM_SUBCLASS_FLASK);
+        }
+
+        virtual string GetName() { return "Alchemy"; }
+    };
+
+    class Scroll : public Consumable
+    {
+    public:
+        Scroll() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_SCROLL ||
+                    proto->SubClass == ITEM_SUBCLASS_ITEM_ENHANCEMENT);
+        }
+
+        virtual string GetName() { return "Scroll"; }
+    };
+
+    class Food : public Consumable
+    {
+    public:
+        Food() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_FOOD;
+        }
+
+        virtual string GetName() { return "Food"; }
+    };
+
+    class Bandage : public Consumable
+    {
+    public:
+        Bandage() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_BANDAGE;
+        }
+
+        virtual string GetName() { return "Bandage"; }
+    };
+
+    class OtherConsumable : public Consumable
+    {
+    public:
+        OtherConsumable() : Consumable() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Consumable::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_CONSUMABLE ||
+                    proto->SubClass == ITEM_SUBCLASS_CONSUMABLE_OTHER) && (proto->RequiredSkill || proto->Flags & ITEM_FLAG_UNK6);
+        }
+
+        virtual string GetName() { return "OtherConsumable"; }
+    };
+};
diff --git a/src/plugins/ahbot/ItemBag.cpp b/src/plugins/ahbot/ItemBag.cpp
new file mode 100644
index 0000000..8bf4107
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.cpp
@@ -0,0 +1,184 @@
+#include "../pchdef.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "ConsumableCategory.h"
+#include "TradeCategory.h"
+#include "AhBotConfig.h"
+#include "../DataStores/DBCStructure.h"
+#include "../../common/Logging/Log.h"
+#include "../../server/database/Database/QueryResult.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../AuctionHouse/AuctionHouseMgr.h"
+
+using namespace ahbot;
+char * strstri (const char* str1, const char* str2);
+
+CategoryList CategoryList::instance;
+
+CategoryList::CategoryList()
+{
+    Add(new Equip());
+    Add(new ahbot::Quest());
+    Add(new Quiver());
+    Add(new Projectile());
+
+    Add(new Recipe());
+    Add(new Container());
+
+    Add(new Reagent());
+    Add(new Enchant());
+    Add(new Alchemy());
+    Add(new Scroll());
+    Add(new Food());
+    Add(new Bandage());
+
+    Add(new Cloth());
+    Add(new Leather());
+    Add(new Herb());
+    Add(new Metal());
+    Add(new Disenchants());
+    Add(new Meat());
+    Add(new Engineering());
+    Add(new SimpleGems());
+    Add(new SocketGems());
+    Add(new Elemental());
+
+    Add(new Glyph());
+
+    Add(new OtherConsumable());
+    Add(new OtherTrade());
+    Add(new Other());
+}
+
+void CategoryList::Add(Category* category)
+{
+    for (uint32 quality = ITEM_QUALITY_NORMAL; quality <= ITEM_QUALITY_EPIC; ++quality)
+        categories.push_back(new QualityCategoryWrapper(category, quality));
+}
+
+CategoryList::~CategoryList()
+{
+    for (vector<Category*>::const_iterator i = categories.begin(); i != categories.end(); ++i)
+        delete *i;
+}
+
+ItemBag::ItemBag()
+{
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        content[CategoryList::instance[i]] = vector<uint32>();
+    }
+}
+
+void ItemBag::Init(bool silent)
+{
+    if (silent)
+    {
+        Load();
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Loading/Scanning %s...", GetName().c_str());
+
+    Load();
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        Category* category = CategoryList::instance[i];
+        Shuffle(content[category]);
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "loaded %d %s items", content[category].size(), category->GetDisplayName().c_str());
+    }
+}
+
+int32 ItemBag::GetCount(Category* category, uint32 item)
+{
+    uint32 count = 0;
+
+    vector<uint32>& items = content[category];
+    for (vector<uint32>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        if (*i == item)
+            count++;
+    }
+
+    return count;
+}
+
+bool ItemBag::Add(ItemTemplate const* proto)
+{
+    if (!proto ||
+        proto->Bonding == BIND_WHEN_PICKED_UP ||
+        proto->Bonding == BIND_QUEST_ITEM)
+        return false;
+
+    if (proto->RequiredLevel > sAhBotConfig.maxRequiredLevel || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+        return false;
+
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+        return false;
+
+    if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+        return false;
+
+    for (int i = 0; i < CategoryList::instance.size(); i++)
+    {
+        if (CategoryList::instance[i]->Contains(proto))
+        {
+            content[CategoryList::instance[i]].push_back(proto->ItemId);
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void AvailableItemsBag::Load()
+{
+    set<uint32> vendorItems;
+
+      QueryResult results = WorldDatabase.PQuery("SELECT item FROM npc_vendor where maxcount = 0");
+      if (results != NULL)
+      {
+          do
+          {
+              Field* fields = results->Fetch();
+              vendorItems.insert(fields[0].GetUInt32());
+          } while (results->NextRow());
+      }
+
+      ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+      for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+      {
+          ItemTemplate const& itemTemplate = i->second;
+          uint32 itemId = i->first;
+
+          if (vendorItems.find(itemTemplate.ItemId) != vendorItems.end())
+              continue;
+
+        Add(sObjectMgr->GetItemTemplate(itemId));
+    }
+
+}
+
+void InAuctionItemsBag::Load()
+{
+    AuctionHouseObject* auctionHouse = sAuctionMgr->GetAuctionsMap(auctionId);
+    for (AuctionHouseObject::AuctionEntryMap::iterator itr = auctionHouse->GetAuctionsBegin(); itr != auctionHouse->GetAuctionsEnd(); ++itr)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itr->second->itemEntry);
+        if (!proto)
+            continue;
+
+        Add(proto);
+    }
+}
+
+string InAuctionItemsBag::GetName()
+{
+    ostringstream out; out << "auction house " << auctionId;
+    return out.str();
+}
diff --git a/src/plugins/ahbot/ItemBag.h b/src/plugins/ahbot/ItemBag.h
new file mode 100644
index 0000000..4d11fd4
--- /dev/null
+++ b/src/plugins/ahbot/ItemBag.h
@@ -0,0 +1,82 @@
+#pragma once
+#include "Category.h"
+
+namespace ahbot
+{
+    using namespace std;
+
+    class CategoryList
+    {
+    public:
+        CategoryList();
+        virtual ~CategoryList();
+
+        Category* operator[](int index) { return categories[index]; }
+        int32 size() { return categories.size(); }
+        static CategoryList instance;
+
+    private:
+        void Add(Category* category);
+
+    private:
+        vector<Category*> categories;
+    };
+
+    template<class T>
+    void Shuffle(vector<T>& items) 
+    {
+        uint32 count = items.size();
+        for (uint32 i = 0; i < count * 5; i++)
+        {
+            int i1 = urand(0, count - 1);
+            int i2 = urand(0, count - 1);
+
+            T item = items[i1];
+            items[i1] = items[i2];
+            items[i2] = item;
+        }
+    }
+
+    class ItemBag 
+    {
+    public:
+        ItemBag();
+
+    public:
+        void Init(bool silent = false);
+        vector<uint32>& Get(Category* category) { return content[category]; }
+        int32 GetCount(Category* category) { return content[category].size(); }
+        int32 GetCount(Category* category, uint32 item);
+        bool Add(ItemTemplate const* proto);
+
+    protected:
+        virtual void Load() = 0;
+        virtual string GetName() = 0;
+
+    protected:
+        map<Category*,vector<uint32> > content;
+    };
+
+    class AvailableItemsBag : public ItemBag
+    {
+    public:
+        AvailableItemsBag() {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName() { return "available"; }
+    };
+
+    class InAuctionItemsBag : public ItemBag
+    {
+    public:
+        InAuctionItemsBag(uint32 auctionId) : auctionId(auctionId) {}
+
+    protected:
+        virtual void Load();
+        virtual string GetName();
+
+    private:
+        uint32 auctionId;
+    };
+};
diff --git a/src/plugins/ahbot/PricingStrategy.cpp b/src/plugins/ahbot/PricingStrategy.cpp
new file mode 100644
index 0000000..e51c00e
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.cpp
@@ -0,0 +1,220 @@
+#include "PricingStrategy.h"
+#include "Category.h"
+#include "ItemBag.h"
+#include "AhBotConfig.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "AhBot.h"
+
+using namespace ahbot;
+
+uint32 PricingStrategy::GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    uint32 now = time(0);
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(now, auctionHouse) *
+        GetItemPriceMultiplier(proto, now, auctionHouse) *
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) *
+        GetDefaultSellPrice(proto);
+    return (uint32)price;
+}
+
+double PricingStrategy::GetMarketPrice(uint32 itemId, uint32 auctionHouse)
+{
+    double marketPrice = 0;
+
+    QueryResult results = CharacterDatabase.PQuery("SELECT price FROM ahbot_price WHERE item = '%u' AND auction_house = '%u'", itemId, auctionHouse);
+    if (results)
+    {
+        marketPrice = results->Fetch()[0].GetFloat();
+    }
+
+    return marketPrice;
+}
+
+uint32 PricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+
+    if (marketPrice > 0)
+        return marketPrice;
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    double price = sAhBotConfig.GetItemPriceMultiplier(proto->Name1) *
+        auctionbot.GetCategoryMultiplier(category->GetName()) *
+        GetRarityPriceMultiplier(proto->ItemId) *
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) *
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) *
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) *
+        GetDefaultBuyPrice(proto);
+    return (uint32)price;
+}
+
+string PricingStrategy::ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    uint32 untilTime = time(0);
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rariry) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetSellPriceMultiplier(category->GetName()) << " (sell) * " <<
+        GetDefaultSellPrice(proto) << " (price)";
+    return out.str();
+}
+
+string PricingStrategy::ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    ostringstream out;
+
+    double marketPrice = GetMarketPrice(proto->ItemId, auctionHouse);
+    if (marketPrice > 0)
+    {
+        out << marketPrice << " (market)";
+        return out.str();
+    }
+
+    uint32 untilTime = time(0) - 3600 * 12;
+    out << sAhBotConfig.GetItemPriceMultiplier(proto->Name1) << " (item const) * " <<
+        auctionbot.GetCategoryMultiplier(category->GetName()) << " (random) * " <<
+        GetRarityPriceMultiplier(proto->ItemId) << " (rarity) * " <<
+        GetCategoryPriceMultiplier(untilTime, auctionHouse) << " (category) * " <<
+        GetItemPriceMultiplier(proto, untilTime, auctionHouse) << " (item) * " <<
+        sAhBotConfig.GetBuyPriceMultiplier(category->GetName()) << " (buy) * " <<
+        GetDefaultBuyPrice(proto) << " (price)";
+    return out.str();
+}
+
+double PricingStrategy::GetRarityPriceMultiplier(uint32 itemId)
+{
+    double result = 1.0;
+
+    QueryResult results = WorldDatabase.PQuery(
+        "select max(Chance) from ( "
+        "select Chance from gameobject_loot_template where item = '%u' "
+        "union select Chance from spell_loot_template where item = '%u' "
+        "union select Chance from disenchant_loot_template where item = '%u' "
+        "union select Chance from fishing_loot_template where item = '%u' "
+        "union select Chance from item_loot_template where item = '%u' "
+        "union select Chance from milling_loot_template where item = '%u' "
+        "union select Chance from pickpocketing_loot_template where item = '%u' "
+        "union select Chance from prospecting_loot_template where item = '%u' "
+        "union select Chance from reference_loot_template where item = '%u' "
+        "union select Chance from skinning_loot_template where item = '%u' "
+        "union select Chance from creature_loot_template where item = '%u' "
+        "union select 0 "
+        ") a",
+        itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId,itemId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        float chance = fields[0].GetFloat();
+
+        if (chance > 0 && chance <= 90.0)
+            result = sqrt((100.0 - chance) / 10.0);
+    }
+
+    return result >= 1.0 ? result : 1.0;
+}
+
+
+double PricingStrategy::GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE category = '%s' AND won = '1' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        category->GetName().c_str(), untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+double PricingStrategy::GetMultiplier(double count, double firstBuyTime, double lastBuyTime)
+{
+    double k1 = (double)count / (double)((time(0) - firstBuyTime) / 3600 / 24 + 1);
+    double k2 = (double)count / (double)((time(0) - lastBuyTime) / 3600 / 24 + 1);
+    return max(1.0, k1 + k2) * sAhBotConfig.priceMultiplier;
+}
+
+double PricingStrategy::GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse)
+{
+    double result = 1.0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+        "SELECT count(*) FROM (SELECT round(buytime/3600/24/5) as days FROM ahbot_history WHERE won = '1' AND item = '%u' AND buytime <= '%u' AND auction_house = '%u' group by days) q",
+        proto->ItemId, untilTime, AhBot::factions[auctionHouse]);
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint32 count = fields[0].GetUInt32();
+
+        if (count)
+            result += count;
+    }
+
+    return result;
+}
+
+uint32 PricingStrategy::ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price)
+{
+    if (proto->Quality == ITEM_QUALITY_POOR)
+        return price;
+
+    return (uint32)(price * sqrt((double)proto->Quality) * sAhBotConfig.priceQualityMultiplier);
+}
+
+uint32 PricingStrategy::GetDefaultBuyPrice(ItemTemplate const* proto)
+{
+    uint32 price = 0;
+
+    if (proto->SellPrice)
+        price = proto->SellPrice;
+    if (proto->BuyPrice)
+        price = max(price, (uint32)(proto->BuyPrice / 4));
+
+    uint32 level = max(proto->ItemLevel, proto->RequiredLevel);
+    if (proto->Class == ITEM_CLASS_QUEST)
+    {
+        double result = 1.0;
+
+        QueryResult results = WorldDatabase.PQuery(
+            "select max(QuestLevel), max(MinLevel) from quest_template where RequiredItemId1 = %u or RequiredItemId2 = %u or RequiredItemId3 = %u or RequiredItemId4 = %u or RequiredItemId5 = %u or RequiredItemId6 = %u",
+            proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId, proto->ItemId);
+        if (results)
+        {
+            Field* fields = results->Fetch();
+            level = max(fields[0].GetUInt32(), fields[1].GetUInt32());
+        }
+    }
+    price = max(price, sAhBotConfig.defaultMinPrice * level * level / 10);
+    price = max(price, (uint32)100);
+
+    return ApplyQualityMultiplier(proto, price) * sAhBotConfig.priceMultiplier;
+}
+
+uint32 PricingStrategy::GetDefaultSellPrice(ItemTemplate const* proto)
+{
+    return GetDefaultBuyPrice(proto);
+}
+
+
+uint32 BuyOnlyRarePricingStrategy::GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse)
+{
+    if (proto->Quality < ITEM_QUALITY_RARE)
+        return 0;
+
+    return PricingStrategy::GetBuyPrice(proto, auctionHouse);
+}
+
diff --git a/src/plugins/ahbot/PricingStrategy.h b/src/plugins/ahbot/PricingStrategy.h
new file mode 100644
index 0000000..ac94724
--- /dev/null
+++ b/src/plugins/ahbot/PricingStrategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "../../game/Entities/Item/ItemPrototype.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Category;
+
+    class PricingStrategy
+    {
+    public:
+        PricingStrategy(Category* category) : category(category) {}
+
+    public:
+        virtual uint32 GetSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainSellPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        string ExplainBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+        virtual double GetRarityPriceMultiplier(uint32 itemId);
+
+    protected:
+        virtual uint32 GetDefaultBuyPrice(ItemTemplate const* proto);
+        virtual uint32 GetDefaultSellPrice(ItemTemplate const* proto);
+        virtual uint32 ApplyQualityMultiplier(ItemTemplate const* proto, uint32 price);
+        virtual double GetCategoryPriceMultiplier(uint32 untilTime, uint32 auctionHouse);
+        virtual double GetItemPriceMultiplier(ItemTemplate const* proto, uint32 untilTime, uint32 auctionHouse);
+        double GetMultiplier(double count, double firstBuyTime, double lastBuyTime);
+        double GetMarketPrice(uint32 itemId, uint32 auctionHouse);
+
+    protected:
+        Category* category;
+    };
+
+    class BuyOnlyRarePricingStrategy : public PricingStrategy
+    {
+    public:
+        BuyOnlyRarePricingStrategy(Category* category) : PricingStrategy(category) {}
+
+    public:
+        virtual uint32 GetBuyPrice(ItemTemplate const* proto, uint32 auctionHouse);
+    };
+
+    class PricingStrategyFactory
+    {
+    public:
+        static PricingStrategy* Create(string name, Category* category)
+        {
+            if (name == "buyOnlyRare")
+                return new BuyOnlyRarePricingStrategy(category);
+
+            return new PricingStrategy(category);
+        }
+    };
+};
diff --git a/src/plugins/ahbot/TradeCategory.cpp b/src/plugins/ahbot/TradeCategory.cpp
new file mode 100644
index 0000000..082ee56
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.cpp
@@ -0,0 +1,4 @@
+#include "TradeCategory.h"
+#include "ItemBag.h"
+
+using namespace ahbot;
diff --git a/src/plugins/ahbot/TradeCategory.h b/src/plugins/ahbot/TradeCategory.h
new file mode 100644
index 0000000..1d987ba
--- /dev/null
+++ b/src/plugins/ahbot/TradeCategory.h
@@ -0,0 +1,183 @@
+#pragma once
+#include "Category.h"
+
+using namespace std;
+
+namespace ahbot
+{
+    class Cloth : public Trade
+    {
+    public:
+        Cloth() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "Cloth"; }
+    };
+
+    class Leather : public Trade
+    {
+    public:
+        Leather() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_LEATHER;
+        }
+
+        virtual string GetName() { return "Leather"; }
+    };
+
+    class Elemental : public Trade
+    {
+    public:
+        Elemental() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                proto->SubClass == ITEM_SUBCLASS_ELEMENTAL;
+        }
+
+        virtual string GetName() { return "Elemental"; }
+    };
+
+    class Herb : public Trade
+    {
+    public:
+        Herb() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_HERB;
+        }
+
+        virtual string GetName() { return "Herb"; }
+    };
+
+    class Meat : public Trade
+    {
+    public:
+        Meat() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_MEAT;
+        }
+
+        virtual string GetName() { return "Meat"; }
+    };
+
+    class Metal : public Trade
+    {
+    public:
+        Metal() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_METAL_STONE;
+        }
+
+        virtual string GetName() { return "Metal"; }
+    };
+
+    class Disenchants : public Trade
+    {
+    public:
+        Disenchants() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass == ITEM_SUBCLASS_ENCHANTING;
+        }
+
+        virtual string GetName() { return "Disenchants"; }
+    };
+
+    class SimpleGems : public Trade
+    {
+    public:
+        SimpleGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SimpleGems"; }
+    };
+
+    class SocketGems : public Trade
+    {
+    public:
+        SocketGems() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return proto->Class == ITEM_CLASS_GEM && proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE;
+        }
+
+        virtual string GetName() { return "SocketGems"; }
+    };
+
+    class Engineering : public Trade
+    {
+    public:
+        Engineering() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    (proto->SubClass == ITEM_SUBCLASS_PARTS ||
+                    proto->SubClass == ITEM_SUBCLASS_DEVICES ||
+                    proto->SubClass == ITEM_SUBCLASS_MATERIAL ||
+                    proto->SubClass == ITEM_SUBCLASS_EXPLOSIVES);
+        }
+
+        virtual string GetName() { return "Engineering"; }
+    };
+
+    class OtherTrade : public Trade
+    {
+    public:
+        OtherTrade() : Trade() {}
+
+    public:
+        virtual bool Contains(ItemTemplate const* proto)
+        {
+            return Trade::Contains(proto) &&
+                    proto->SubClass != ITEM_SUBCLASS_PARTS &&
+                    proto->SubClass != ITEM_SUBCLASS_DEVICES &&
+                    proto->SubClass != ITEM_SUBCLASS_MATERIAL &&
+                    proto->SubClass != ITEM_SUBCLASS_EXPLOSIVES &&
+                    proto->SubClass != ITEM_SUBCLASS_ENCHANTING &&
+                    proto->SubClass != ITEM_SUBCLASS_JEWELCRAFTING &&
+                    proto->SubClass != ITEM_SUBCLASS_METAL_STONE &&
+                    proto->SubClass != ITEM_SUBCLASS_MEAT &&
+                    proto->SubClass != ITEM_SUBCLASS_HERB &&
+                    proto->SubClass != ITEM_SUBCLASS_LEATHER &&
+                    proto->SubClass != ITEM_SUBCLASS_CLOTH;
+        }
+
+        virtual string GetName() { return "OtherTrade"; }
+    };
+};
diff --git a/src/plugins/ahbot/ahbot.conf.dist.in b/src/plugins/ahbot/ahbot.conf.dist.in
new file mode 100644
index 0000000..f50ffc2
--- /dev/null
+++ b/src/plugins/ahbot/ahbot.conf.dist.in
@@ -0,0 +1,209 @@
+################################################
+# MANGOS Auction House Bot Configuration file  #
+################################################
+
+[AhbotConf]
+ConfVersion=2010102201
+
+###################################################################################################################
+# AUCTION HOUSE BOT SETTINGS
+#
+###################################################################################################################
+
+# Disable original AuctionHouseBot
+AuctionHouseBot.Seller.Enabled = 0
+AuctionHouseBot.Buyer.Enabled = 0
+
+# Replace with the new AhBot
+AhBot.Enabled = 1
+
+# Should be used only if random bots are disabled
+# AhBot.GUID = 0
+
+# 199 for 80, 80 for 70, 70 for 60, ..., 25 for 20
+AhBot.MaxItemLevel = 199
+# Same as level cap
+AhBot.MaxRequiredLevel = 80
+
+# Ignore items by ID
+AhBot.IgnoreItemIds = 49283,52200,8494,6345,6891,2460
+
+AhBot.PriceMultiplier = 1.0
+AhBot.DefaultMinPrice = 20
+AhBot.PriceQualityMultiplier = 1.0
+AhBot.AlwaysAvailableMoney = 2000000
+
+# Buy/sell delays
+AhBot.ItemBuyMinInterval = 7200
+AhBot.ItemBuyMaxInterval = 28800
+AhBot.ItemSellMinInterval = 7200
+AhBot.ItemSellMaxInterval = 28800
+
+#
+# Items
+#
+
+AhBot.MaxAuctionCount.equip.green = 0
+AhBot.MaxAuctionCount.equip.blue = 40
+AhBot.MaxAuctionCount.equip.epic = 20
+AhBot.PriceMultiplier.Sell.equip = 1.0
+AhBot.PriceMultiplier.Buy.equip = 1.0
+AhBot.PricingStrategy.equip = buyOnlyRare
+
+AhBot.MaxAuctionCount.reagent.white = 6
+AhBot.MaxAuctionCount.reagent.green = 2
+AhBot.PriceMultiplier.Sell.reagent = 1.0
+AhBot.PriceMultiplier.Buy.reagent = 1.0
+AhBot.PricingStrategy.reagent = buyOnlyRare
+
+AhBot.MaxAuctionCount.other.white = 20
+AhBot.MaxAuctionCount.other.green = 10
+AhBot.MaxAuctionCount.other.blue = 6
+AhBot.PriceMultiplier.Sell.other = 1.0
+AhBot.PriceMultiplier.Buy.other = 1.0
+AhBot.PricingStrategy.other = buyOnlyRare
+
+#
+# Container
+#
+
+AhBot.MaxAuctionCount.quiver.white = 2
+AhBot.PriceMultiplier.Sell.quiver = 1.0
+AhBot.PriceMultiplier.Buy.quiver = 1.0
+AhBot.PricingStrategy.quiver = buyOnlyRare
+
+AhBot.MaxAuctionCount.container.white = 6
+AhBot.MaxAuctionCount.container.green = 2
+AhBot.MaxAuctionCount.container.blue = 2
+AhBot.PriceMultiplier.Sell.container = 1.0
+AhBot.PriceMultiplier.Buy.container = 1.0
+
+#
+# Glyph
+#
+
+AhBot.MaxAuctionCount.glyph.white = 50
+AhBot.MaxAuctionCount.glyph.green = 20
+AhBot.MaxAuctionCount.glyph.blue = 10
+AhBot.PriceMultiplier.Sell.glyph = 1.0
+AhBot.PriceMultiplier.Buy.glyph = 1.0
+
+#
+# Quest
+#
+
+AhBot.MaxAuctionCount.quest.white = 14
+AhBot.MaxAuctionCount.quest.green = 2
+AhBot.MaxAuctionCount.quest.blue = 2
+AhBot.PriceMultiplier.Sell.quest = 1.0
+AhBot.PriceMultiplier.Buy.quest = 1.0
+
+#
+# Consumables
+#
+
+AhBot.MaxAuctionCount.alchemy.white = 50
+AhBot.MaxAuctionCount.alchemy.green = 20
+AhBot.MaxAuctionCount.alchemy.blue = 10
+AhBot.PriceMultiplier.Sell.alchemy = 1.0
+AhBot.PriceMultiplier.Buy.alchemy = 1.0
+
+AhBot.MaxAuctionCount.scroll.white = 40
+AhBot.MaxAuctionCount.scroll.green = 6
+AhBot.MaxAuctionCount.scroll.blue = 4
+AhBot.PriceMultiplier.Sell.scroll = 1.0
+AhBot.PriceMultiplier.Buy.scroll = 1.0
+
+AhBot.MaxAuctionCount.Food.white = 40
+AhBot.PriceMultiplier.Sell.Food = 1.0
+AhBot.PriceMultiplier.Buy.Food = 1.0
+
+AhBot.MaxAuctionCount.bandage.white = 10
+AhBot.PriceMultiplier.Sell.bandage = 1.0
+AhBot.PriceMultiplier.Buy.bandage = 1.0
+
+AhBot.MaxAuctionCount.OtherConsumable.white = 20
+AhBot.MaxAuctionCount.OtherConsumable.green = 10
+AhBot.MaxAuctionCount.OtherConsumable.blue = 5
+AhBot.PriceMultiplier.Sell.OtherConsumable = 1.0
+AhBot.PriceMultiplier.Buy.OtherConsumable = 1.0
+
+#
+# Recipe
+#
+
+AhBot.MaxAuctionCount.recipe.white = 8
+AhBot.MaxAuctionCount.recipe.green = 4
+AhBot.MaxAuctionCount.recipe.blue = 2
+AhBot.MaxAuctionCount.recipe.epic = 2
+AhBot.PriceMultiplier.Sell.recipe = 1.0
+AhBot.PriceMultiplier.Buy.recipe = 1.0
+
+#
+# Trade
+#
+
+AhBot.MaxAuctionCount.Elemental.white = 30
+AhBot.MaxAuctionCount.Elemental.green = 20
+AhBot.MaxAuctionCount.Elemental.blue = 6
+AhBot.PriceMultiplier.Sell.Elemental = 1.0
+AhBot.PriceMultiplier.Buy.Elemental = 1.0
+
+AhBot.MaxAuctionCount.Cloth.white = 50
+AhBot.MaxAuctionCount.Cloth.green = 14
+AhBot.MaxAuctionCount.Cloth.blue = 6
+AhBot.PriceMultiplier.Sell.Cloth = 1.0
+AhBot.PriceMultiplier.Buy.Cloth = 1.0
+
+AhBot.MaxAuctionCount.Leather.white = 50
+AhBot.MaxAuctionCount.Leather.green = 14
+AhBot.MaxAuctionCount.Leather.blue = 6
+AhBot.PriceMultiplier.Sell.Leather = 1.0
+AhBot.PriceMultiplier.Buy.Leather = 1.0
+
+AhBot.MaxAuctionCount.Herb.white = 50
+AhBot.MaxAuctionCount.Herb.green = 14
+AhBot.PriceMultiplier.Sell.Herb = 1.0
+AhBot.PriceMultiplier.Buy.Herb = 1.0
+
+AhBot.MaxAuctionCount.Meat.white = 50
+AhBot.PriceMultiplier.Sell.Meat = 1.0
+AhBot.PriceMultiplier.Buy.Meat = 1.0
+
+AhBot.MaxAuctionCount.Metal.white = 50
+AhBot.MaxAuctionCount.Metal.green = 14
+AhBot.MaxAuctionCount.Metal.blue = 6
+AhBot.PriceMultiplier.Sell.Metal = 1.0
+AhBot.PriceMultiplier.Buy.Metal = 1.0
+
+AhBot.MaxAuctionCount.Engineering.white = 20
+AhBot.MaxAuctionCount.Engineering.green = 10
+AhBot.MaxAuctionCount.Engineering.blue = 4
+AhBot.PriceMultiplier.Sell.Engineering = 1.0
+AhBot.PriceMultiplier.Buy.Engineering = 1.0
+
+AhBot.MaxAuctionCount.Disenchants.white = 40
+AhBot.MaxAuctionCount.Disenchants.green = 20
+AhBot.MaxAuctionCount.Disenchants.blue = 20
+AhBot.PriceMultiplier.Sell.Disenchants = 1.0
+AhBot.PriceMultiplier.Buy.Disenchants = 1.0
+
+AhBot.MaxAuctionCount.SimpleGems.green = 30
+AhBot.MaxAuctionCount.SimpleGems.blue = 20
+AhBot.MaxAuctionCount.SimpleGems.epic = 4
+AhBot.PriceMultiplier.Sell.SimpleGems = 1.0
+AhBot.PriceMultiplier.Buy.SimpleGems = 1.0
+
+AhBot.MaxAuctionCount.SocketGems.green = 50
+AhBot.MaxAuctionCount.SocketGems.blue = 20
+AhBot.MaxAuctionCount.SocketGems.epic = 4
+AhBot.PriceMultiplier.Sell.SocketGems = 1.0
+AhBot.PriceMultiplier.Buy.SocketGems = 1.0
+
+AhBot.MaxAuctionCount.OtherTrade.white = 10
+AhBot.PriceMultiplier.Sell.OtherTrade = 1.0
+AhBot.PriceMultiplier.Buy.OtherTrade = 1.0
+
+AhBot.PriceMultiplier.Sell.projectile = 1.0
+AhBot.PriceMultiplier.Buy.projectile = 1.0
+AhBot.PricingStrategy.projectile = buyOnlyRare
diff --git a/src/plugins/pch/pch.cpp b/src/plugins/pch/pch.cpp
new file mode 100644
index 0000000..1d9f38c
--- /dev/null
+++ b/src/plugins/pch/pch.cpp
@@ -0,0 +1 @@
+#include "pch.h"
diff --git a/src/plugins/pch/pch.h b/src/plugins/pch/pch.h
new file mode 100644
index 0000000..c7c6ca5
--- /dev/null
+++ b/src/plugins/pch/pch.h
@@ -0,0 +1,10 @@
+//add here most rarely modified headers to speed up debug build compilation
+
+#include "Common.h"
+#include "MapManager.h"
+#include "Log.h"
+#include "ObjectAccessor.h"
+#include "ObjectDefines.h"
+#include "Opcodes.h"
+#include "SharedDefines.h"
+#include "ObjectMgr.h"
diff --git a/src/plugins/pchdef.h b/src/plugins/pchdef.h
new file mode 100644
index 0000000..f58aae9
--- /dev/null
+++ b/src/plugins/pchdef.h
@@ -0,0 +1,4 @@
+#ifndef PCHDEF_H_
+#define PCHDEF_H_
+
+#endif /* PCHDEF_H_ */
diff --git a/src/plugins/playerbot/AiFactory.cpp b/src/plugins/playerbot/AiFactory.cpp
new file mode 100644
index 0000000..9dd58d7
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.cpp
@@ -0,0 +1,229 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "AiFactory.h"
+#include "strategy/Engine.h"
+
+#include "strategy/priest/PriestAiObjectContext.h"
+#include "strategy/mage/MageAiObjectContext.h"
+#include "strategy/warlock/WarlockAiObjectContext.h"
+#include "strategy/warrior/WarriorAiObjectContext.h"
+#include "strategy/shaman/ShamanAiObjectContext.h"
+#include "strategy/paladin/PaladinAiObjectContext.h"
+#include "strategy/druid/DruidAiObjectContext.h"
+#include "strategy/hunter/HunterAiObjectContext.h"
+#include "strategy/rogue/RogueAiObjectContext.h"
+#include "../Entities/Player/Player.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomPlayerbotMgr.h"
+
+
+AiObjectContext* AiFactory::createAiObjectContext(Player* player, PlayerbotAI* ai)
+{
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return new PriestAiObjectContext(ai);
+        break;
+    case CLASS_MAGE:
+        return new MageAiObjectContext(ai);
+        break;
+    case CLASS_WARLOCK:
+        return new WarlockAiObjectContext(ai);
+        break;
+    case CLASS_WARRIOR:
+        return new WarriorAiObjectContext(ai);
+        break;
+    case CLASS_SHAMAN:
+        return new ShamanAiObjectContext(ai);
+        break;
+    case CLASS_PALADIN:
+        return new PaladinAiObjectContext(ai);
+        break;
+    case CLASS_DRUID:
+        return new DruidAiObjectContext(ai);
+        break;
+    case CLASS_HUNTER:
+        return new HunterAiObjectContext(ai);
+        break;
+    case CLASS_ROGUE:
+        return new RogueAiObjectContext(ai);
+        break;
+    }
+    return new AiObjectContext(ai);
+}
+
+int AiFactory::GetPlayerSpecTab(Player* player)
+{
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    if (c0 >= c1 && c0 >= c2)
+        return 0;
+
+    if (c1 >= c0 && c1 >= c2)
+        return 1;
+
+    return 2;
+}
+
+void AiFactory::AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    engine->addStrategies("attack weak", "racials", "chat", "default", "aoe", "potions", "cast time", "conserve mana", "duel", "pvp", NULL);
+
+    switch (player->getClass())
+    {
+        case CLASS_PRIEST:
+            if (tab == 2)
+            {
+                engine->addStrategies("dps", "threat", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("dps debuff");
+            }
+            else
+                engine->addStrategy("heal");
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_MAGE:
+            if (tab == 0)
+                engine->addStrategies("arcane", "threat", NULL);
+            else if (tab == 1)
+                engine->addStrategies("fire", "fire aoe", "threat", NULL);
+            else
+                engine->addStrategies("frost", "frost aoe", "threat", NULL);
+
+            engine->addStrategy("flee");
+            break;
+        case CLASS_WARRIOR:
+            if (tab == 2)
+                engine->addStrategies("tank", "tank aoe", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_SHAMAN:
+            if (tab == 0)
+                engine->addStrategies("caster", "caster aoe", "bmana", "threat", "flee", NULL);
+            else if (tab == 2)
+                engine->addStrategies("heal", "bmana", "flee", NULL);
+            else
+                engine->addStrategies("dps", "melee aoe", "bdps", "threat", NULL);
+            break;
+        case CLASS_PALADIN:
+            if (tab == 1)
+                engine->addStrategies("tank", "tank aoe", "barmor", NULL);
+            else
+                engine->addStrategies("dps", "bdps", "threat", NULL);
+            break;
+        case CLASS_DRUID:
+            if (tab == 0)
+            {
+                engine->addStrategies("caster", "caster aoe", "threat", "flee", NULL);
+                if (player->getLevel() > 19)
+                    engine->addStrategy("caster debuff");
+            }
+            else if (tab == 2)
+                engine->addStrategies("heal", "flee", NULL);
+            else
+                engine->addStrategies("bear", "tank aoe", "threat", "flee", NULL);
+            break;
+        case CLASS_HUNTER:
+            engine->addStrategies("dps", "bdps", "threat", NULL);
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+            break;
+        case CLASS_ROGUE:
+            engine->addStrategies("dps", "threat", NULL);
+            break;
+        case CLASS_WARLOCK:
+            if (tab == 1)
+                engine->addStrategies("tank", "threat", NULL);
+            else
+                engine->addStrategies("dps", "threat", NULL);
+
+            if (player->getLevel() > 19)
+                engine->addStrategy("dps debuff");
+
+            engine->addStrategy("flee");
+            break;
+    }
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        engine->ChangeStrategy(sPlayerbotAIConfig.randomBotCombatStrategies);
+        if (player->getClass() == CLASS_DRUID && player->getLevel() < 20)
+            engine->addStrategies("bear", "threat", NULL);
+    }
+}
+
+Engine* AiFactory::createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* engine = new Engine(facade, AiObjectContext);
+    AddDefaultCombatStrategies(player, facade, engine);
+    return engine;
+}
+
+void AiFactory::AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine)
+{
+    int tab = GetPlayerSpecTab(player);
+
+    switch (player->getClass()){
+        case CLASS_PALADIN:
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+            nonCombatEngine->addStrategy("bmana");
+            break;
+        case CLASS_MAGE:
+            if (tab == 1)
+                nonCombatEngine->addStrategy("bdps");
+            else
+                nonCombatEngine->addStrategy("bmana");
+            break;
+    }
+    nonCombatEngine->addStrategies("nc", "attack weak", "food", "stay", "chat",
+            "default", "quest", "loot", "gather", "duel", "emote", "lfg", NULL);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        nonCombatEngine->ChangeStrategy(sPlayerbotAIConfig.randomBotNonCombatStrategies);
+    }
+
+}
+
+Engine* AiFactory::createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+	Engine* nonCombatEngine = new Engine(facade, AiObjectContext);
+
+    AddDefaultNonCombatStrategies(player, facade, nonCombatEngine);
+	return nonCombatEngine;
+}
+
+void AiFactory::AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine)
+{
+    deadEngine->addStrategies("dead", "stay", "chat", "default", "follow", NULL);
+    if (sRandomPlayerbotMgr.IsRandomBot(player) && !player->GetGroup())
+    {
+        deadEngine->removeStrategy("follow");
+    }
+}
+
+Engine* AiFactory::createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext) {
+    Engine* deadEngine = new Engine(facade, AiObjectContext);
+    AddDefaultDeadStrategies(player, facade, deadEngine);
+    return deadEngine;
+}
diff --git a/src/plugins/playerbot/AiFactory.h b/src/plugins/playerbot/AiFactory.h
new file mode 100644
index 0000000..a101092
--- /dev/null
+++ b/src/plugins/playerbot/AiFactory.h
@@ -0,0 +1,20 @@
+#pragma once
+
+class Player;
+
+using namespace ai;
+
+class AiFactory
+{
+public:
+    static AiObjectContext* createAiObjectContext(Player* player, PlayerbotAI* ai);
+	static Engine* createCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+	static Engine* createNonCombatEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static Engine* createDeadEngine(Player* player, PlayerbotAI* const facade, AiObjectContext* AiObjectContext);
+    static void AddDefaultNonCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* nonCombatEngine);
+    static void AddDefaultDeadStrategies(Player* player, PlayerbotAI* const facade, Engine* deadEngine);
+    static void AddDefaultCombatStrategies(Player* player, PlayerbotAI* const facade, Engine* engine);
+
+public:
+    static int GetPlayerSpecTab(Player* player);
+};
diff --git a/src/plugins/playerbot/ChatFilter.cpp b/src/plugins/playerbot/ChatFilter.cpp
new file mode 100644
index 0000000..ac007f2
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.cpp
@@ -0,0 +1,258 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatFilter.h"
+#include "strategy/values/RtiTargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+string ChatFilter::Filter(string message)
+{
+    if (message.find("@") == string::npos)
+        return message;
+
+    return message.substr(message.find(" ") + 1);
+}
+
+class StrategyChatFilter : public ChatFilter
+{
+public:
+    StrategyChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool tank = message.find("@tank") == 0;
+        if (tank && !ai->IsTank(bot))
+            return "";
+
+        bool dps = message.find("@dps") == 0;
+        if (dps && ai->IsTank(bot))
+            return "";
+
+        bool heal = message.find("@heal") == 0;
+        if (heal && !ai->IsHeal(bot))
+            return "";
+
+        if (tank || dps)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class LevelChatFilter : public ChatFilter
+{
+public:
+    LevelChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        if (message[0] != '@')
+            return message;
+
+        if (message.find("-") != string::npos)
+        {
+            int fromLevel = atoi(message.substr(message.find("@") + 1, message.find("-")).c_str());
+            int toLevel = atoi(message.substr(message.find("-") + 1, message.find(" ")).c_str());
+
+            if (bot->getLevel() >= fromLevel && bot->getLevel() <= toLevel)
+                return ChatFilter::Filter(message);
+
+            return message;
+        }
+
+		int level = atoi(message.substr(message.find("@") + 1, message.find(" ")).c_str());
+        if (bot->getLevel() == level)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+};
+
+class CombatTypeChatFilter : public ChatFilter
+{
+public:
+    CombatTypeChatFilter(PlayerbotAI* ai) : ChatFilter(ai) {}
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool melee = message.find("@melee") == 0;
+        bool ranged = message.find("@ranged") == 0;
+
+        if (!melee && !ranged)
+            return message;
+
+        switch (bot->getClass())
+        {
+            case CLASS_WARRIOR:
+            case CLASS_PALADIN:
+            case CLASS_ROGUE:
+            case CLASS_DEATH_KNIGHT:
+                if (ranged)
+                    return "";
+                break;
+
+            case CLASS_HUNTER:
+            case CLASS_PRIEST:
+            case CLASS_MAGE:
+            case CLASS_WARLOCK:
+                if (melee)
+                    return "";
+                break;
+
+            case CLASS_DRUID:
+                if (ranged && ai->IsTank(bot))
+                    return "";
+                if (melee && !ai->IsTank(bot))
+                    return "";
+                break;
+
+            case CLASS_SHAMAN:
+                if (melee && ai->IsHeal(bot))
+                    return "";
+                if (ranged && !ai->IsHeal(bot))
+                    return "";
+                break;
+        }
+
+        return ChatFilter::Filter(message);
+    }
+};
+
+class RtiChatFilter : public ChatFilter
+{
+public:
+    RtiChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        rtis.push_back("@star");
+        rtis.push_back("@circle");
+        rtis.push_back("@diamond");
+        rtis.push_back("@triangle");
+        rtis.push_back("@moon");
+        rtis.push_back("@square");
+        rtis.push_back("@cross");
+        rtis.push_back("@skull");
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+        Group *group = bot->GetGroup();
+        if(!group)
+            return message;
+
+        bool found = false;
+        for (list<string>::iterator i = rtis.begin(); i != rtis.end(); i++)
+        {
+            string rti = *i;
+
+            bool isRti = message.find(rti) == 0;
+            if (!isRti)
+                continue;
+
+            ObjectGuid rtiTarget = group->GetTargetIcon(RtiTargetValue::GetRtiIndex(rti.substr(1)));
+            if (bot->GetGUID() == rtiTarget)
+                return ChatFilter::Filter(message);
+
+            Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+            if (!target)
+                return "";
+
+            if (target->GetGUID() != rtiTarget)
+                return "";
+
+            if (found |= isRti)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    list<string> rtis;
+};
+
+class ClassChatFilter : public ChatFilter
+{
+public:
+    ClassChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+    {
+        classNames["@death_knight"] = CLASS_DEATH_KNIGHT;
+        classNames["@druid"] = CLASS_DRUID;
+        classNames["@hunter"] = CLASS_HUNTER;
+        classNames["@mage"] = CLASS_MAGE;
+        classNames["@paladin"] = CLASS_PALADIN;
+        classNames["@priest"] = CLASS_PRIEST;
+        classNames["@rogue"] = CLASS_ROGUE;
+        classNames["@shaman"] = CLASS_SHAMAN;
+        classNames["@warlock"] = CLASS_WARLOCK;
+        classNames["@warrior"] = CLASS_WARRIOR;
+    }
+
+    virtual string Filter(string message)
+    {
+        Player* bot = ai->GetBot();
+
+        bool found = false;
+        for (map<string, uint8>::iterator i = classNames.begin(); i != classNames.end(); i++)
+        {
+            bool isClass = message.find(i->first) == 0;
+            if (isClass && bot->getClass() != i->second)
+                return "";
+
+            if (found |= isClass)
+                break;
+        }
+
+        if (found)
+            return ChatFilter::Filter(message);
+
+        return message;
+    }
+
+private:
+    map<string, uint8> classNames;
+};
+
+
+
+CompositeChatFilter::CompositeChatFilter(PlayerbotAI* ai) : ChatFilter(ai)
+{
+    filters.push_back(new StrategyChatFilter(ai));
+    filters.push_back(new ClassChatFilter(ai));
+    filters.push_back(new RtiChatFilter(ai));
+    filters.push_back(new CombatTypeChatFilter(ai));
+    filters.push_back(new LevelChatFilter(ai));
+}
+
+CompositeChatFilter::~CompositeChatFilter()
+{
+    for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        delete (*i);
+}
+
+string CompositeChatFilter::Filter(string message)
+{
+    int filterSize = filters.size();
+    for (int j = 0; j < filterSize; ++j)
+    {
+        for (list<ChatFilter*>::iterator i = filters.begin(); i != filters.end(); i++)
+        {
+            message = (*i)->Filter(message);
+            if (message.empty())
+                break;
+        }
+    }
+
+    return message;
+}
+
diff --git a/src/plugins/playerbot/ChatFilter.h b/src/plugins/playerbot/ChatFilter.h
new file mode 100644
index 0000000..16dde4d
--- /dev/null
+++ b/src/plugins/playerbot/ChatFilter.h
@@ -0,0 +1,24 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    class ChatFilter : public PlayerbotAIAware
+    {
+    public:
+        ChatFilter(PlayerbotAI* ai) : PlayerbotAIAware(ai) {}
+        virtual string Filter(string message);
+    };
+
+    class CompositeChatFilter : public ChatFilter
+    {
+    public:
+        CompositeChatFilter(PlayerbotAI* ai);
+        virtual ~CompositeChatFilter();
+        string Filter(string message);
+
+    private:
+        list<ChatFilter*> filters;
+    };
+};
diff --git a/src/plugins/playerbot/ChatHelper.cpp b/src/plugins/playerbot/ChatHelper.cpp
new file mode 100644
index 0000000..a84a55c
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.cpp
@@ -0,0 +1,450 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "ChatHelper.h"
+
+using namespace ai;
+using namespace std;
+
+map<string, uint32> ChatHelper::consumableSubClasses;
+map<string, uint32> ChatHelper::tradeSubClasses;
+map<string, uint32> ChatHelper::itemQualities;
+map<string, uint32> ChatHelper::slots;
+map<string, ChatMsg> ChatHelper::chats;
+map<uint8, string> ChatHelper::classes;
+map<uint8, string> ChatHelper::races;
+map<uint8, map<uint8, string> > ChatHelper::specs;
+
+template<class T>
+static bool substrContainsInMap(string searchTerm, map<string, T> searchIn)
+{
+    for (typename map<string, T>::iterator i = searchIn.begin(); i != searchIn.end(); ++i)
+    {
+		string term = i->first;
+		if (term.size() > 1 && searchTerm.find(term) != string::npos)
+            return true;
+    }
+
+    return false;
+}
+
+ChatHelper::ChatHelper(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    itemQualities["poor"] = ITEM_QUALITY_POOR;
+    itemQualities["gray"] = ITEM_QUALITY_POOR;
+    itemQualities["normal"] = ITEM_QUALITY_NORMAL;
+    itemQualities["white"] = ITEM_QUALITY_NORMAL;
+    itemQualities["uncommon"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["green"] = ITEM_QUALITY_UNCOMMON;
+    itemQualities["rare"] = ITEM_QUALITY_RARE;
+    itemQualities["blue"] = ITEM_QUALITY_RARE;
+    itemQualities["epic"] = ITEM_QUALITY_EPIC;
+    itemQualities["violet"] = ITEM_QUALITY_EPIC;
+
+    consumableSubClasses["potion"] = ITEM_SUBCLASS_POTION;
+    consumableSubClasses["elixir"] = ITEM_SUBCLASS_ELIXIR;
+    consumableSubClasses["flask"] = ITEM_SUBCLASS_FLASK;
+    consumableSubClasses["scroll"] = ITEM_SUBCLASS_SCROLL;
+    consumableSubClasses["food"] = ITEM_SUBCLASS_FOOD;
+    consumableSubClasses["bandage"] = ITEM_SUBCLASS_BANDAGE;
+    consumableSubClasses["enchant"] = ITEM_SUBCLASS_CONSUMABLE_OTHER;
+
+    tradeSubClasses["cloth"] = ITEM_SUBCLASS_CLOTH;
+    tradeSubClasses["leather"] = ITEM_SUBCLASS_LEATHER;
+    tradeSubClasses["metal"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["stone"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["ore"] = ITEM_SUBCLASS_METAL_STONE;
+    tradeSubClasses["meat"] = ITEM_SUBCLASS_MEAT;
+    tradeSubClasses["herb"] = ITEM_SUBCLASS_HERB;
+    tradeSubClasses["elemental"] = ITEM_SUBCLASS_ELEMENTAL;
+    tradeSubClasses["disenchants"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["enchanting"] = ITEM_SUBCLASS_ENCHANTING;
+    tradeSubClasses["gems"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewels"] = ITEM_SUBCLASS_JEWELCRAFTING;
+    tradeSubClasses["jewelcrafting"] = ITEM_SUBCLASS_JEWELCRAFTING;
+
+    slots["head"] = EQUIPMENT_SLOT_HEAD;
+    slots["neck"] = EQUIPMENT_SLOT_NECK;
+    slots["shoulder"] = EQUIPMENT_SLOT_SHOULDERS;
+    slots["shirt"] = EQUIPMENT_SLOT_BODY;
+    slots["chest"] = EQUIPMENT_SLOT_CHEST;
+    slots["waist"] = EQUIPMENT_SLOT_WAIST;
+    slots["legs"] = EQUIPMENT_SLOT_LEGS;
+    slots["feet"] = EQUIPMENT_SLOT_FEET;
+    slots["wrist"] = EQUIPMENT_SLOT_WRISTS;
+    slots["hands"] = EQUIPMENT_SLOT_HANDS;
+    slots["finger 1"] = EQUIPMENT_SLOT_FINGER1;
+    slots["finger 2"] = EQUIPMENT_SLOT_FINGER2;
+    slots["trinket 1"] = EQUIPMENT_SLOT_TRINKET1;
+    slots["trinket 2"] = EQUIPMENT_SLOT_TRINKET2;
+    slots["back"] = EQUIPMENT_SLOT_BACK;
+    slots["main hand"] = EQUIPMENT_SLOT_MAINHAND;
+    slots["off hand"] = EQUIPMENT_SLOT_OFFHAND;
+    slots["ranged"] = EQUIPMENT_SLOT_RANGED;
+    slots["tabard"] = EQUIPMENT_SLOT_TABARD;
+
+    chats["party"] = CHAT_MSG_PARTY;
+    chats["p"] = CHAT_MSG_PARTY;
+    chats["guild"] = CHAT_MSG_GUILD;
+    chats["g"] = CHAT_MSG_GUILD;
+    chats["raid"] = CHAT_MSG_RAID;
+    chats["r"] = CHAT_MSG_RAID;
+    chats["whisper"] = CHAT_MSG_WHISPER;
+    chats["w"] = CHAT_MSG_WHISPER;
+
+    classes[CLASS_DRUID] = "druid";
+    specs[CLASS_DRUID][0] = "balance";
+    specs[CLASS_DRUID][1] = "feral combat";
+    specs[CLASS_DRUID][2] = "restoration";
+
+    classes[CLASS_HUNTER] = "hunter";
+    specs[CLASS_HUNTER][0] = "beast mastery";
+    specs[CLASS_HUNTER][1] = "marksmanship";
+    specs[CLASS_HUNTER][2] = "survival";
+
+    classes[CLASS_MAGE] = "mage";
+    specs[CLASS_MAGE][0] = "arcane";
+    specs[CLASS_MAGE][1] = "fire";
+    specs[CLASS_MAGE][2] = "frost";
+
+    classes[CLASS_PALADIN] = "paladin";
+    specs[CLASS_PALADIN][0] = "holy";
+    specs[CLASS_PALADIN][1] = "protection";
+    specs[CLASS_PALADIN][2] = "retribution";
+
+    classes[CLASS_PRIEST] = "priest";
+    specs[CLASS_PRIEST][0] = "discipline";
+    specs[CLASS_PRIEST][1] = "holy";
+    specs[CLASS_PRIEST][2] = "shadow";
+
+    classes[CLASS_ROGUE] = "rogue";
+    specs[CLASS_ROGUE][0] = "assasination";
+    specs[CLASS_ROGUE][1] = "combat";
+    specs[CLASS_ROGUE][2] = "subtlety";
+
+    classes[CLASS_SHAMAN] = "shaman";
+    specs[CLASS_SHAMAN][0] = "elemental";
+    specs[CLASS_SHAMAN][1] = "enhancement";
+    specs[CLASS_SHAMAN][2] = "restoration";
+
+    classes[CLASS_WARLOCK] = "warlock";
+    specs[CLASS_WARLOCK][0] = "affliction";
+    specs[CLASS_WARLOCK][1] = "demonology";
+    specs[CLASS_WARLOCK][2] = "destruction";
+
+    classes[CLASS_WARRIOR] = "warrior";
+    specs[CLASS_WARRIOR][0] = "arms";
+    specs[CLASS_WARRIOR][1] = "fury";
+    specs[CLASS_WARRIOR][2] = "protection";
+
+    races[RACE_BLOODELF] = "Blood Elf";
+    races[RACE_DRAENEI] = "Draenei";
+    races[RACE_DWARF] = "Dwarf";
+    races[RACE_GNOME] = "Gnome";
+    races[RACE_HUMAN] = "Human";
+    races[RACE_NIGHTELF] = "Night Elf";
+    races[RACE_ORC] = "Orc";
+    races[RACE_TAUREN] = "Tauren";
+    races[RACE_TROLL] = "Troll";
+    races[RACE_UNDEAD_PLAYER] = "Undead";
+}
+
+string ChatHelper::formatMoney(uint32 copper)
+{
+    ostringstream out;
+	if (!copper)
+	{
+		out << "0|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+		return out.str();
+	}
+
+    uint32 gold = uint32(copper / 10000);
+    copper -= (gold * 10000);
+    uint32 silver = uint32(copper / 100);
+    copper -= (silver * 100);
+    out << " ";
+    if (gold > 0)
+        out << gold <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\gold:0|t ";
+    if (silver > 0 && gold < 50)
+        out << silver <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\silver:0|t ";
+	if (copper > 0 && gold < 10)
+		out << copper <<  "|TInterface\\AddOns\\AtlasLoot\\Images\\bronze:0|t";
+
+    return out.str();
+}
+
+uint32 ChatHelper::parseMoney(string& text)
+{
+    // if user specified money in ##g##s##c format
+    string acum = "";
+    uint32 copper = 0;
+    for (uint8 i = 0; i < text.length(); i++)
+    {
+        if (text[i] == 'g')
+        {
+            copper += (atol(acum.c_str()) * 100 * 100);
+            acum = "";
+        }
+        else if (text[i] == 'c')
+        {
+            copper += atol(acum.c_str());
+            acum = "";
+        }
+        else if (text[i] == 's')
+        {
+            copper += (atol(acum.c_str()) * 100);
+            acum = "";
+        }
+        else if (text[i] == ' ')
+            break;
+        else if (text[i] >= 48 && text[i] <= 57)
+            acum += text[i];
+        else
+        {
+            copper = 0;
+            break;
+        }
+    }
+    return copper;
+}
+
+ItemIds ChatHelper::parseItems(string& text)
+{
+    ItemIds itemIds;
+
+    uint8 pos = 0;
+    while (true)
+    {
+        int i = text.find("Hitem:", pos);
+        if (i == -1)
+            break;
+        pos = i + 6;
+        int endPos = text.find(':', pos);
+        if (endPos == -1)
+            break;
+        string idC = text.substr(pos, endPos - pos);
+        uint32 id = atol(idC.c_str());
+        pos = endPos;
+        if (id)
+            itemIds.insert(id);
+    }
+
+    return itemIds;
+}
+
+string ChatHelper::formatQuest(Quest const* quest)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << quest->GetTitle() << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatGameobject(GameObject* go)
+{
+    ostringstream out;
+    out << "|cFFFFFF00|Hfound:" << go->GetGUID() << ":" << go->GetEntry() << ":" <<  "|h[" << go->GetGOInfo()->name << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatSpell(SpellInfo const *sInfo)
+{
+    ostringstream out;
+    out << "|cffffffff|Hspell:" << sInfo->Id << "|h[" << sInfo->SpellName[LOCALE_enUS] << "]|h|r";
+    return out.str();
+}
+
+string ChatHelper::formatItem(ItemTemplate const * proto, int count)
+{
+    char color[32];
+    sprintf(color, "%x", ItemQualityColors[proto->Quality]);
+
+    ostringstream out;
+    out << "|c" << color << "|Hitem:" << proto->ItemId
+        << ":0:0:0:0:0:0:0" << "|h[" << proto->Name1
+        << "]|h|r";
+
+    if (count > 1)
+        out << "x" << count;
+
+    return out.str();
+}
+
+ChatMsg ChatHelper::parseChat(string& text)
+{
+    if (chats.find(text) != chats.end())
+        return chats[text];
+
+    return CHAT_MSG_SYSTEM;
+}
+
+string ChatHelper::formatChat(ChatMsg chat)
+{
+    switch (chat)
+    {
+    case CHAT_MSG_GUILD:
+        return "guild";
+    case CHAT_MSG_PARTY:
+        return "party";
+    case CHAT_MSG_WHISPER:
+        return "whisper";
+    case CHAT_MSG_RAID:
+        return "raid";
+    }
+
+    return "unknown";
+}
+
+
+uint32 ChatHelper::parseSpell(string& text)
+{
+    PlayerbotChatHandler handler(ai->GetBot());
+    return handler.extractSpellId(text);
+}
+
+list<ObjectGuid> ChatHelper::parseGameobjects(string& text)
+{
+    list<ObjectGuid> gos;
+    //    Link format
+    //    |cFFFFFF00|Hfound:" << guid << ':'  << entry << ':'  <<  "|h[" << gInfo->name << "]|h|r";
+    //    |cFFFFFF00|Hfound:9582:1731|h[Copper Vein]|h|r
+
+    uint8 pos = 0;
+    while (true)
+    {
+        // extract GO guid
+        int i = text.find("Hfound:", pos);     // base H = 11
+        if (i == -1)     // break if error
+            break;
+
+        pos = i + 7;     //start of window in text 11 + 7 = 18
+        int endPos = text.find(':', pos);     // end of window in text 22
+        if (endPos == -1)     //break if error
+            break;
+        istringstream stream(text.substr(pos, endPos - pos));
+        uint64 guid; stream >> guid;
+
+        // extract GO entry
+        pos = endPos + 1;
+        endPos = text.find(':', pos);     // end of window in text
+        if (endPos == -1)     //break if error
+            break;
+
+        std::string entryC = text.substr(pos, endPos - pos);     // get string within window i.e entry
+        uint32 entry = atol(entryC.c_str());     // convert ascii to float
+
+        ObjectGuid lootCurrent = ObjectGuid(guid);
+
+        if (guid)
+            gos.push_back(lootCurrent);
+    }
+
+    return gos;
+}
+
+string ChatHelper::formatQuestObjective(string name, int available, int required)
+{
+    ostringstream out;
+    out << "|cFFFFFFFF" << name << (available >= required ? "|c0000FF00: " : "|c00FF0000: ")
+        << available << "/" << required << "|r";
+
+    return out.str();
+}
+
+
+uint32 ChatHelper::parseItemQuality(string text)
+{
+    if (itemQualities.find(text) == itemQualities.end())
+        return MAX_ITEM_QUALITY;
+
+    return itemQualities[text];
+}
+
+bool ChatHelper::parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass)
+{
+    if (text == "questitem")
+    {
+        *itemClass = ITEM_CLASS_QUEST;
+        *itemSubClass = ITEM_SUBCLASS_QUEST;
+        return true;
+    }
+
+    if (consumableSubClasses.find(text) != consumableSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_CONSUMABLE;
+        *itemSubClass = consumableSubClasses[text];
+        return true;
+    }
+
+    if (tradeSubClasses.find(text) != tradeSubClasses.end())
+    {
+        *itemClass = ITEM_CLASS_TRADE_GOODS;
+        *itemSubClass = tradeSubClasses[text];
+        return true;
+    }
+
+    return false;
+}
+
+uint32 ChatHelper::parseSlot(string text)
+{
+    if (slots.find(text) != slots.end())
+        return slots[text];
+
+    return EQUIPMENT_SLOT_END;
+}
+
+bool ChatHelper::parseable(string text)
+{
+    return text.find("|H") != string::npos ||
+            text == "questitem" ||
+            substrContainsInMap<uint32>(text, consumableSubClasses) ||
+            substrContainsInMap<uint32>(text, tradeSubClasses) ||
+            substrContainsInMap<uint32>(text, itemQualities) ||
+            substrContainsInMap<uint32>(text, slots) ||
+            substrContainsInMap<ChatMsg>(text, chats) ||
+            parseMoney(text) > 0;
+}
+
+string ChatHelper::formatClass(Player* player, int spec)
+{
+    uint8 cls = player->getClass();
+
+    ostringstream out;
+    out << specs[cls][spec] << " (";
+
+    int c0 = 0, c1 = 0, c2 = 0;
+    PlayerTalentMap& talentMap = player->GetTalentMap(0);
+    for (PlayerTalentMap::iterator i = talentMap.begin(); i != talentMap.end(); ++i)
+    {
+        uint32 spellId = i->first;
+        TalentSpellPos const* talentPos = GetTalentSpellPos(spellId);
+        if(!talentPos)
+            continue;
+
+        TalentEntry const* talentInfo = sTalentStore.LookupEntry(talentPos->talent_id);
+
+        if (!talentInfo)
+            continue;
+
+        uint32 const* talentTabIds = GetTalentTabPages(player->getClass());
+        if (talentInfo->TalentTab == talentTabIds[0]) c0++;
+        if (talentInfo->TalentTab == talentTabIds[1]) c1++;
+        if (talentInfo->TalentTab == talentTabIds[2]) c2++;
+    }
+
+    out << (c0 ? "|h|cff00ff00" : "") << c0 << "|h|cffffffff/";
+    out << (c1 ? "|h|cff00ff00" : "") << c1 << "|h|cffffffff/";
+    out << (c2 ? "|h|cff00ff00" : "") << c2 << "|h|cffffffff";
+
+    out <<  ") " << classes[cls];
+    return out.str();
+}
+
+string ChatHelper::formatClass(uint8 cls)
+{
+    return classes[cls];
+}
+
+string ChatHelper::formatRace(uint8 race)
+{
+    return races[race];
+}
diff --git a/src/plugins/playerbot/ChatHelper.h b/src/plugins/playerbot/ChatHelper.h
new file mode 100644
index 0000000..3d493d1
--- /dev/null
+++ b/src/plugins/playerbot/ChatHelper.h
@@ -0,0 +1,52 @@
+#pragma once
+
+using namespace std;
+
+typedef set<uint32> ItemIds;
+typedef set<uint32> SpellIds;
+
+#include "../pchdef.h"
+
+namespace ai
+{
+    class ChatHelper : public PlayerbotAIAware
+    {
+    public:
+        ChatHelper(PlayerbotAI* ai);
+
+    public:
+        static string formatMoney(uint32 copper);
+        static uint32 parseMoney(string& text);
+        static ItemIds parseItems(string& text);
+        uint32 parseSpell(string& text);
+        static string formatQuest(Quest const* quest);
+        static string formatItem(ItemTemplate const * proto, int count = 0);
+        static string formatSpell(SpellInfo const *sInfo);
+        static string formatGameobject(GameObject* go);
+        static string formatQuestObjective(string name, int available, int required);
+        static list<ObjectGuid> parseGameobjects(string& text);
+
+        static ChatMsg parseChat(string& text);
+        static string formatChat(ChatMsg chat);
+
+        static string formatClass(Player* player, int spec);
+        static string formatClass(uint8 cls);
+        static string formatRace(uint8 race);
+
+        static uint32 parseItemQuality(string text);
+        static bool parseItemClass(string text, uint32 *itemClass, uint32 *itemSubClass);
+        static uint32 parseSlot(string text);
+
+        static bool parseable(string text);
+
+    private:
+        static map<string, uint32> consumableSubClasses;
+        static map<string, uint32> tradeSubClasses;
+        static map<string, uint32> itemQualities;
+        static map<string, uint32> slots;
+        static map<string, ChatMsg> chats;
+        static map<uint8, string> classes;
+        static map<uint8, string> races;
+        static map<uint8, map<uint8, string> > specs;
+    };
+};
diff --git a/src/plugins/playerbot/FleeManager.cpp b/src/plugins/playerbot/FleeManager.cpp
new file mode 100644
index 0000000..d7f93f5
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.cpp
@@ -0,0 +1,160 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "FleeManager.h"
+#include "PlayerbotAIConfig.h"
+#include "../Groups/Group.h"
+
+using namespace ai;
+using namespace std;
+
+void FleeManager::calculateDistanceToPlayers(FleePoint *point)
+{
+	Group* group = bot->GetGroup();
+	if (!group)
+		return;
+
+	for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+		Player* player = gref->GetSource();
+		if(player == bot)
+			continue;
+
+		float d = player->GetDistance(point->x, point->y, point->z);
+		point->toAllPlayers.probe(d);
+		switch (player->getClass()) {
+			case CLASS_HUNTER:
+			case CLASS_MAGE:
+			case CLASS_PRIEST:
+			case CLASS_WARLOCK:
+				point->toRangedPlayers.probe(d);
+				break;
+			case CLASS_PALADIN:
+			case CLASS_ROGUE:
+			case CLASS_WARRIOR:
+				point->toMeleePlayers.probe(d);
+				break;
+		}
+	}
+}
+
+void FleeManager::calculateDistanceToCreatures(FleePoint *point)
+{
+	RangePair &distance = point->toCreatures;
+
+	list<ObjectGuid> units = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<list<ObjectGuid> >("possible targets");
+	for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+		Unit* unit = bot->GetPlayerbotAI()->GetUnit(*i);
+		if (!unit)
+		    continue;
+
+		float d = unit->GetDistance(point->x, point->y, point->z);
+		if (d <= sPlayerbotAIConfig.tooCloseDistance)
+		    continue;
+
+		distance.probe(d);
+	}
+}
+
+void FleeManager::calculatePossibleDestinations(list<FleePoint*> &points)
+{
+	float botPosX = bot->GetPositionX();
+	float botPosY = bot->GetPositionY();
+	float botPosZ = bot->GetPositionZ();
+
+	for (float distance = maxAllowedDistance; distance > sPlayerbotAIConfig.tooCloseDistance + 5.0f; distance -= 5.0f)
+	{
+        for (float angle = -M_PI + followAngle; angle < M_PI + followAngle; angle += M_PI / 16)
+        {
+            float x = botPosX + cos(angle) * distance;
+            float y = botPosY + sin(angle) * distance;
+
+            if (!bot->IsWithinLOS(x, y, botPosZ))
+                continue;
+
+            FleePoint *point = new FleePoint(x, y, botPosZ);
+            calculateDistanceToPlayers(point);
+            calculateDistanceToCreatures(point);
+            points.push_back(point);
+        }
+	}
+}
+
+void FleeManager::cleanup(list<FleePoint*> &points)
+{
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		delete point;
+	}
+	points.clear();
+}
+
+bool FleePoint::isReasonable()
+{
+	return toAllPlayers.max <= sPlayerbotAIConfig.sightDistance && toCreatures.min >= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool FleePoint::isBetterByCreatures(FleePoint* other)
+{
+    return toCreatures.min > 0 && other->toCreatures.min > 0 &&
+            (toCreatures.min - other->toCreatures.min) >= 0;
+}
+
+bool FleePoint::isBetterByAll(FleePoint* other)
+{
+    bool isFartherFromCreatures = isBetterByCreatures(other);
+    bool isNearerToRangedPlayers = toRangedPlayers.max > 0 && other->toRangedPlayers.max > 0 &&
+            (toRangedPlayers.max - other->toRangedPlayers.max) <= 0;
+    bool isFartherFromMeleePlayers = toMeleePlayers.min > 0 && other->toMeleePlayers.min > 0 &&
+            (toMeleePlayers.min - other->toMeleePlayers.min) >= 0;
+
+    return isFartherFromCreatures && (isNearerToRangedPlayers || isFartherFromMeleePlayers);
+}
+
+FleePoint* FleeManager::selectOptimalDestination(list<FleePoint*> &points)
+{
+	FleePoint* byCreatures = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byCreatures || point->isBetterByCreatures(byCreatures)))
+			byCreatures = point;
+	}
+
+	FleePoint* byAll = NULL;
+	for (list<FleePoint*>::iterator i = points.begin(); i != points.end(); i++)
+    {
+		FleePoint* point = *i;
+		if (point->isReasonable() && (!byAll || point->isBetterByAll(byAll)))
+		    byAll = point;
+	}
+
+	if (byAll && byCreatures)
+	{
+	    if (byAll->isBetterByCreatures(byCreatures))
+	        return byAll;
+	}
+
+	return byCreatures;
+}
+
+bool FleeManager::CalculateDestination(float* rx, float* ry, float* rz)
+{
+	list<FleePoint*> points;
+	calculatePossibleDestinations(points);
+
+    FleePoint* point = selectOptimalDestination(points);
+    if (!point)
+    {
+        cleanup(points);
+        return false;
+    }
+
+	*rx = point->x;
+	*ry = point->y;
+	*rz = bot->GetPositionZ();
+
+    cleanup(points);
+	return true;
+}
diff --git a/src/plugins/playerbot/FleeManager.h b/src/plugins/playerbot/FleeManager.h
new file mode 100644
index 0000000..3084cdd
--- /dev/null
+++ b/src/plugins/playerbot/FleeManager.h
@@ -0,0 +1,83 @@
+#pragma once
+
+using namespace std;
+
+class Player;
+
+namespace ai
+{
+    class Engine;
+
+	class RangePair {
+	public:
+		RangePair() {
+			min = -1.0f;
+			max = -1.0f;
+		}
+
+	public:
+		float min;
+		float max;
+
+	public:
+		void probe(float d) {
+			if (min < 0 || min > d)
+				min = d;
+
+			if (max < 0 || max < d)
+				max = d;
+		}
+	};
+
+	class FleePoint {
+	public:
+		FleePoint(float x, float y, float z) {
+			this->x = x;
+			this->y = y;
+			this->z = z;
+		}
+
+    public:
+        bool isReasonable();
+        bool isBetterByCreatures(FleePoint* other);
+        bool isBetterByAll(FleePoint* other);
+
+	public:
+		float x;
+		float y;
+		float z;
+
+		RangePair toCreatures;
+		RangePair toAllPlayers;
+		RangePair toMeleePlayers;
+		RangePair toRangedPlayers;
+	};
+
+	class FleeManager
+	{
+	public:
+		FleeManager(Player* bot, float maxAllowedDistance, float followAngle) {
+			this->bot = bot;
+			this->maxAllowedDistance = maxAllowedDistance;
+			this->followAngle = followAngle;
+		}
+
+	public:
+		bool CalculateDestination(float* rx, float* ry, float* rz);
+
+	private:
+		void calculatePossibleDestinations(list<FleePoint*> &points);
+		void calculateDistanceToPlayers(FleePoint *point);
+		void calculateDistanceToCreatures(FleePoint *point);
+		void cleanup(list<FleePoint*> &points);
+		FleePoint* selectOptimalDestination(list<FleePoint*> &points);
+		bool isReasonable(FleePoint* point);
+		bool isBetterThan(FleePoint* point, FleePoint* other);
+
+	private:
+		Player* bot;
+		float maxAllowedDistance;
+		float followAngle;
+	};
+
+};
diff --git a/src/plugins/playerbot/GuildTaskMgr.cpp b/src/plugins/playerbot/GuildTaskMgr.cpp
new file mode 100644
index 0000000..abaf28a
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.cpp
@@ -0,0 +1,697 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "GuildTaskMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "../../server/game/Mails/Mail.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+#include "RandomItemMgr.h"
+
+char * strstri (const char* str1, const char* str2);
+
+enum GuildTaskType
+{
+    GUILD_TASK_TYPE_NONE = 0,
+    GUILD_TASK_TYPE_ITEM = 1,
+    GUILD_TASK_TYPE_KILL = 2
+};
+
+GuildTaskMgr::GuildTaskMgr()
+{
+}
+
+GuildTaskMgr::~GuildTaskMgr()
+{
+}
+
+void GuildTaskMgr::Update(Player* player, Player* guildMaster)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+        return;
+
+    uint32 guildId = guildMaster->GetGuildId();
+    if (!guildId || !guildMaster->GetPlayerbotAI() || !guildMaster->GetGuild())
+        return;
+
+    if (!player->IsFriendlyTo(guildMaster))
+        return;
+
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel secLevel = guildMaster->GetPlayerbotAI()->GetSecurity()->LevelFor(player, &reason);
+    if (secLevel == PLAYERBOT_SECURITY_DENY_ALL || (secLevel == PLAYERBOT_SECURITY_TALK && reason != PLAYERBOT_DENY_FAR))
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: skipping guild task update - not enough security level, reason = %u",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(), reason);
+        return;
+    }
+
+    uint32 owner = (uint32)player->GetGUID().GetRawValue();
+
+    uint32 activeTask = GetTaskValue(owner, guildId, "activeTask");
+    if (!activeTask)
+    {
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemTask", 0, 0);
+        SetTaskValue(owner, guildId, "itemCount", 0, 0);
+        SetTaskValue(owner, guildId, "killTask", 0, 0);
+        SetTaskValue(owner, guildId, "killCount", 0, 0);
+        SetTaskValue(owner, guildId, "payment", 0, 0);
+        SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+
+        uint32 task = CreateTask(owner, guildId);
+
+        if (task == GUILD_TASK_TYPE_NONE)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error creating guild task",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+
+        uint32 time = urand(sPlayerbotAIConfig.minGuildTaskChangeTime, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "activeTask", task, time);
+        SetTaskValue(owner, guildId, "advertisement", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task %u is set for %u secs",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str(),
+                task, time);
+        return;
+    }
+
+    uint32 advertisement = GetTaskValue(owner, guildId, "advertisement");
+    if (!advertisement)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending advertisement",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendAdvertisement(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "advertisement", 1,
+                    urand(sPlayerbotAIConfig.minGuildTaskAdvertisementTime, sPlayerbotAIConfig.maxGuildTaskAdvertisementTime));
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending advertisement",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 thanks = GetTaskValue(owner, guildId, "thanks");
+    if (!thanks)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending thanks",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (SendThanks(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "thanks", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending thanks",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+
+    uint32 reward = GetTaskValue(owner, guildId, "reward");
+    if (!reward)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: sending reward",
+                guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        if (Reward(owner, guildId))
+        {
+            SetTaskValue(owner, guildId, "reward", 1, 2 * sPlayerbotAIConfig.maxGuildTaskChangeTime);
+            SetTaskValue(owner, guildId, "payment", 0, 0);
+        }
+        else
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: error sending reward",
+                    guildMaster->GetGuild()->GetName().c_str(), player->GetName().c_str());
+        }
+    }
+}
+
+uint32 GuildTaskMgr::CreateTask(uint32 owner, uint32 guildId)
+{
+    switch (urand(0, 1))
+    {
+    case 0:
+        CreateItemTask(owner, guildId);
+        return GUILD_TASK_TYPE_ITEM;
+    default:
+        CreateKillTask(owner, guildId);
+        return GUILD_TASK_TYPE_KILL;
+    }
+}
+
+bool GuildTaskMgr::CreateItemTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK);
+    if (!itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no items avaible for item task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 count = GetMaxItemTaskCount(itemId);
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item task %u (x%d)",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            itemId, count);
+
+    SetTaskValue(owner, guildId, "itemCount", count, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    SetTaskValue(owner, guildId, "itemTask", itemId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::CreateKillTask(uint32 owner, uint32 guildId)
+{
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    vector<uint32> ids;
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.rank != CREATURE_ELITE_RARE)
+            continue;
+
+        if (co.minlevel > player->getLevel() || co.maxlevel < player->getLevel() - 5)
+            continue;
+
+        ids.push_back(i->first);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "%s / %s: no rare creatures available for kill task",
+                sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str());
+        return false;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    uint32 creatureId = ids[index];
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: kill task %u",
+            sGuildMgr->GetGuildById(guildId)->GetName().c_str(), player->GetName().c_str(),
+            creatureId);
+
+    SetTaskValue(owner, guildId, "killTask", creatureId, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+    return true;
+}
+
+bool GuildTaskMgr::SendAdvertisement(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask)
+        return SendItemAdvertisement(itemTask, owner, guildId);
+
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask");
+    if (killTask)
+        return SendKillAdvertisement(killTask, owner, guildId);
+
+    return false;
+}
+
+bool GuildTaskMgr::SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "We are in a great need of " << proto->Name1 << ". If you could sell us ";
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (count > 1)
+        body << "at least " << count << " of them ";
+    else
+        body << "some ";
+    body << "we'd really appreciate that and pay a high price.\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+    MailDraft("Guild Task Advertisement", body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+
+bool GuildTaskMgr::SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+
+    CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(creatureId);
+    if (!proto)
+        return false;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+    body << "As you probably know " << proto->Name << " is wanted dead for the crimes it did against our guild. If you should kill it ";
+    body << "we'd really appreciate that.\n";
+    body << "\n";
+    body << "Best Regards,\n";
+    body << guild->GetName() << "\n";
+    body << leader->GetName() << "\n";
+    MailDraft("Guild Task Advertisement", body.str()).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    return true;
+}
+
+bool GuildTaskMgr::SendThanks(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        ostringstream body;
+        body << "Hello, " << player->GetName() << ",\n";
+        body << "\n";
+        body << "One of our guild members wishes to thank you for the " << proto->Name1 << "! If we have another ";
+        uint32 count = GetTaskValue(owner, guildId, "itemCount");
+        body << count << " of them that would help us tremendously.\n";
+        body << "\n";
+        body << "Thanks again,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+
+        MailDraft("Thank You", body.str()).
+                AddMoney(GetTaskValue(owner, guildId, "payment")).
+                SendMailTo(trans, MailReceiver(player), MailSender(leader));
+
+        CharacterDatabase.CommitTransaction(trans);
+
+        return true;
+    }
+
+    return false;
+}
+
+uint32 GuildTaskMgr::GetMaxItemTaskCount(uint32 itemId)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return 0;
+
+    if (proto->Quality < ITEM_QUALITY_RARE && proto->Stackable && proto->GetMaxStackSize() > 1)
+        return proto->GetMaxStackSize();
+
+    return 1;
+}
+
+bool GuildTaskMgr::IsGuildTaskItem(uint32 itemId, uint32 guildId)
+{
+    bool value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where `value` = '%u' and guildid = '%u' and `type` = 'itemTask'",
+            itemId, guildId);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        bool value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+map<uint32,uint32> GuildTaskMgr::GetTaskValues(uint32 owner, string type, uint32 *validIn /* = NULL */)
+{
+    map<uint32,uint32> result;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn, guildid from ai_playerbot_guild_tasks where owner = '%u' and `type` = '%s'",
+            owner, type.c_str());
+
+    if (!results)
+        return result;
+
+    do
+    {
+        Field* fields = results->Fetch();
+        uint32 value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        uint32 guildId = fields[3].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        result[guildId] = value;
+
+    } while (results->NextRow());
+
+    return result;
+}
+
+uint32 GuildTaskMgr::GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn /* = NULL */)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 secs = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= secs)
+            value = 0;
+
+        if (validIn) *validIn = secs;
+    }
+
+    return value;
+}
+
+uint32 GuildTaskMgr::SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks where owner = '%u' and guildid = '%u' and `type` = '%s'",
+            owner, guildId, type.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_guild_tasks (owner, guildid, `time`, validIn, `type`, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                owner, guildId, (uint32)time(0), validIn, type.c_str(), value);
+    }
+
+    return value;
+}
+
+bool GuildTaskMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.guildTaskEnabled)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Guild task system is currently disabled!");
+        return false;
+    }
+
+    if (!*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: gtask stats/reset");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_guild_tasks");
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Guild tasks were reset for all players");
+        return true;
+    }
+
+    if (cmd == "stats")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask stats <player name>");
+        return true;
+    }
+
+    if (cmd.find("stats ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("stats ") + 6);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+
+        QueryResult result = CharacterDatabase.PQuery(
+                "select `value`, `time`, validIn, guildid, `type` from ai_playerbot_guild_tasks where owner = '%u' order by guildid, `type`",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 value = fields[0].GetUInt32();
+                uint32 lastChangeTime = fields[1].GetUInt32();
+                uint32 validIn = fields[2].GetUInt32();
+                if ((time(0) - lastChangeTime) >= validIn)
+                    value = 0;
+                uint32 guildId = fields[3].GetUInt32();
+                string type = fields[4].GetString();
+
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sLog->outMessage("gtask", LOG_LEVEL_INFO, "Player '%s' Guild '%s' %s=%u (%u secs)",
+                        charName.c_str(), guild->GetName().c_str(),
+                        type.c_str(), value, validIn);
+
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+        }
+
+        return true;
+    }
+
+    if (cmd == "reward")
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_INFO, "Usage: gtask reward <player name>");
+        return true;
+    }
+
+    if (cmd.find("reward ") != string::npos)
+    {
+        string charName = cmd.substr(cmd.find("reward ") + 7);
+        ObjectGuid guid = sObjectMgr->GetPlayerGUIDByName(charName);
+        if (!guid)
+        {
+            sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Player %s not found", charName.c_str());
+            return false;
+        }
+
+        uint32 owner = (uint32)guid.GetRawValue();
+        QueryResult result = CharacterDatabase.PQuery(
+                "select distinct guildid from ai_playerbot_guild_tasks where owner = '%u'",
+                owner);
+
+        if (result)
+        {
+            do
+            {
+                Field* fields = result->Fetch();
+                uint32 guildId = fields[0].GetUInt32();
+                Guild *guild = sGuildMgr->GetGuildById(guildId);
+                if (!guild)
+                    continue;
+
+                sGuildTaskMgr.Reward(owner, guildId);
+            } while (result->NextRow());
+
+            Field* fields = result->Fetch();
+            return true;
+        }
+    }
+
+    return false;
+}
+
+void GuildTaskMgr::CheckItemTask(uint32 itemId, uint32 obtained, Player* ownerPlayer, Player* bot, bool byMail)
+{
+    uint32 guildId = bot->GetGuildId();
+    if (!guildId)
+        return;
+
+    uint32 owner = (uint32)ownerPlayer->GetGUID().GetRawValue();
+
+    sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: checking guild task",
+            bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    if (itemTask != itemId)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: item %u is not guild task item (%u)",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str(),
+                itemId, itemTask);
+        return;
+    }
+
+    if (byMail)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            return;
+
+        uint32 money = GetTaskValue(owner, guildId, "payment");
+        SetTaskValue(owner, guildId, "payment", money + auctionbot.GetBuyPrice(proto) * obtained,
+                sPlayerbotAIConfig.maxGuildTaskRewardTime);
+    }
+
+    uint32 count = GetTaskValue(owner, guildId, "itemCount");
+    if (obtained >= count)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+    else
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task progress",
+                bot->GetGuild()->GetName().c_str(), ownerPlayer->GetName().c_str());
+        SetTaskValue(owner, guildId, "itemCount", count - obtained, sPlayerbotAIConfig.maxGuildTaskChangeTime);
+        SetTaskValue(owner, guildId, "thanks", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+}
+
+bool GuildTaskMgr::Reward(uint32 owner, uint32 guildId)
+{
+    Guild *guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+        return false;
+
+    Player* player = sObjectMgr->GetPlayerByLowGUID(owner);
+    if (!player)
+        return false;
+
+    Player* leader = sObjectMgr->GetPlayerByLowGUID(guild->GetLeaderGUID());
+    if (!leader)
+        return false;
+
+    uint32 itemTask = GetTaskValue(owner, guildId, "itemTask");
+    uint32 killTask = GetTaskValue(owner, guildId, "killTask");
+    if (!itemTask && !killTask)
+        return false;
+
+    ostringstream body;
+    body << "Hello, " << player->GetName() << ",\n";
+    body << "\n";
+
+    if (itemTask)
+    {
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name1 << " you provided so kindly. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+    else if (killTask)
+    {
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(killTask);
+        if (!proto)
+            return false;
+
+        body << "We wish to thank you for the " << proto->Name << " you've killed recently. We really appreciate this and may this small gift bring you our thanks!\n";
+        body << "\n";
+        body << "Many thanks,\n";
+        body << guild->GetName() << "\n";
+        body << leader->GetName() << "\n";
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft draft("Thank You", body.str());
+
+    uint32 count = urand(1, 3);
+    for (uint32 i = 0; i < count; ++i)
+    {
+        uint32 itemId = sRandomItemMgr.GetRandomItem(RANDOM_ITEM_GUILD_TASK_REWARD);
+        if (itemId)
+        {
+            Item* item = Item::CreateItem(itemId, 1, leader);
+            item->SaveToDB(trans);
+            draft.AddItem(item);
+        }
+    }
+
+    draft.AddMoney(GetTaskValue(owner, guildId, "payment")).SendMailTo(trans, MailReceiver(player), MailSender(leader));
+    CharacterDatabase.CommitTransaction(trans);
+
+    SetTaskValue(owner, guildId, "activeTask", 0, 0);
+    return true;
+}
+
+void GuildTaskMgr::CheckKillTask(Player* player, Unit* victim)
+{
+    uint32 owner = player->GetGUID().GetCounter();
+    Creature* creature = victim->ToCreature();
+    if (!creature)
+        return;
+
+    map<uint32,uint32> tasks = GetTaskValues(owner, "killTask");
+    for (map<uint32,uint32>::iterator i = tasks.begin(); i != tasks.end(); ++i)
+    {
+        uint32 guildId = i->first;
+        uint32 value = i->second;
+        Guild* guild = sGuildMgr->GetGuildById(guildId);
+
+        if (value != creature->GetCreatureTemplate()->Entry)
+            continue;
+
+        sLog->outMessage("gtask", LOG_LEVEL_DEBUG, "%s / %s: guild task complete",
+                guild->GetName().c_str(), player->GetName().c_str());
+        SetTaskValue(owner, guildId, "reward", 1,
+                urand(sPlayerbotAIConfig.minGuildTaskRewardTime, sPlayerbotAIConfig.maxGuildTaskRewardTime));
+    }
+}
diff --git a/src/plugins/playerbot/GuildTaskMgr.h b/src/plugins/playerbot/GuildTaskMgr.h
new file mode 100644
index 0000000..5e78e9f
--- /dev/null
+++ b/src/plugins/playerbot/GuildTaskMgr.h
@@ -0,0 +1,45 @@
+#ifndef _GuildTaskMgr_H
+#define _GuildTaskMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+class GuildTaskMgr
+{
+    public:
+        GuildTaskMgr();
+        virtual ~GuildTaskMgr();
+        static GuildTaskMgr& instance()
+        {
+            static GuildTaskMgr instance;
+            return instance;
+        }
+
+        void Update(Player* owner, Player* guildMaster);
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsGuildTaskItem(uint32 itemId, uint32 guildId);
+        void CheckItemTask(uint32 itemId, uint32 obtained, Player* owner, Player* bot, bool byMail = false);
+        void CheckKillTask(Player* owner, Unit* victim);
+
+    private:
+        map<uint32,uint32> GetTaskValues(uint32 owner, string type, uint32 *validIn = NULL);
+        uint32 GetTaskValue(uint32 owner, uint32 guildId, string type, uint32 *validIn = NULL);
+        uint32 SetTaskValue(uint32 owner, uint32 guildId, string type, uint32 value, uint32 validIn);
+        uint32 CreateTask(uint32 owner, uint32 guildId);
+        bool SendAdvertisement(uint32 owner, uint32 guildId);
+        bool SendItemAdvertisement(uint32 itemId, uint32 owner, uint32 guildId);
+        bool SendKillAdvertisement(uint32 creatureId, uint32 owner, uint32 guildId);
+        bool SendThanks(uint32 owner, uint32 guildId);
+        bool Reward(uint32 owner, uint32 guildId);
+        bool CreateItemTask(uint32 owner, uint32 guildId);
+        bool CreateKillTask(uint32 owner, uint32 guildId);
+        uint32 GetMaxItemTaskCount(uint32 itemId);
+};
+
+#define sGuildTaskMgr GuildTaskMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/Helpers.cpp b/src/plugins/playerbot/Helpers.cpp
new file mode 100644
index 0000000..1d0b408
--- /dev/null
+++ b/src/plugins/playerbot/Helpers.cpp
@@ -0,0 +1,90 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include <algorithm>
+#include <functional>
+#include <cctype>
+#include <locale>
+
+vector<string>& split(const string &s, char delim, vector<string> &elems)
+{
+    stringstream ss(s);
+    string item;
+    while(getline(ss, item, delim))
+    {
+        elems.push_back(item);
+    }
+    return elems;
+}
+
+
+vector<string> split(const string &s, char delim)
+{
+    vector<string> elems;
+    return split(s, delim, elems);
+}
+
+char *strstri(const char *haystack, const char *needle)
+{
+    if ( !*needle )
+    {
+        return (char*)haystack;
+    }
+    for ( ; *haystack; ++haystack )
+    {
+        if ( tolower(*haystack) == tolower(*needle) )
+        {
+            const char *h = haystack, *n = needle;
+            for ( ; *h && *n; ++h, ++n )
+            {
+                if ( tolower(*h) != tolower(*n) )
+                {
+                    break;
+                }
+            }
+            if ( !*n )
+            {
+                return (char*)haystack;
+            }
+        }
+    }
+    return 0;
+}
+
+
+
+uint64 extractGuid(WorldPacket& packet)
+{
+    uint8 mask;
+    packet >> mask;
+    uint64 guid = 0;
+    uint8 bit = 0;
+    uint8 testMask = 1;
+    while (true)
+    {
+        if (mask & testMask)
+        {
+            uint8 word;
+            packet >> word;
+            guid += (word << bit);
+        }
+        if (bit == 7)
+            break;
+        ++bit;
+        testMask <<= 1;
+    }
+    return guid;
+}
+
+std::string &ltrim(std::string &s) {
+        s.erase(s.begin(), std::find_if(s.begin(), s.end(), std::not1(std::ptr_fun<int, int>(std::isspace))));
+        return s;
+}
+
+std::string &rtrim(std::string &s) {
+        s.erase(std::find_if(s.rbegin(), s.rend(), std::not1(std::ptr_fun<int, int>(std::isspace))).base(), s.end());
+        return s;
+}
+
+std::string &trim(std::string &s) {
+        return ltrim(rtrim(s));
+}
diff --git a/src/plugins/playerbot/LazyCalculatedValue.h b/src/plugins/playerbot/LazyCalculatedValue.h
new file mode 100644
index 0000000..f7d3d31
--- /dev/null
+++ b/src/plugins/playerbot/LazyCalculatedValue.h
@@ -0,0 +1,42 @@
+#pragma once
+
+using namespace std;
+
+namespace ai 
+{
+    template <class TValue, class TOwner>
+    class LazyCalculatedValue
+    {
+    public:
+        typedef TValue (TOwner::*Calculator)();
+
+    public:
+        LazyCalculatedValue(TOwner* owner, Calculator calculator) 
+        {
+            this->calculator = calculator;
+            this->owner = owner;
+            Reset();
+        }
+
+    public:
+        TValue GetValue()
+        {
+            if (!calculated)
+            {
+                value = (owner->*calculator)();
+                calculated = true;
+            }
+            return value;
+        }
+        void Reset() 
+        {
+            calculated = false;
+        }
+
+    protected:
+        Calculator calculator;
+        TOwner* owner;
+        bool calculated;
+        TValue value;
+    };
+};
\ No newline at end of file
diff --git a/src/plugins/playerbot/LootObjectStack.cpp b/src/plugins/playerbot/LootObjectStack.cpp
new file mode 100644
index 0000000..faf459c
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.cpp
@@ -0,0 +1,234 @@
+#include "../pchdef.h"
+#include "LootObjectStack.h"
+#include "playerbot.h"
+
+using namespace ai;
+using namespace std;
+
+#define MAX_LOOT_OBJECT_COUNT 10
+
+LootTarget::LootTarget(ObjectGuid guid) : guid(guid), asOfTime(time(0))
+{
+}
+
+LootTarget::LootTarget(LootTarget const& other)
+{
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+}
+
+LootTarget& LootTarget::operator=(LootTarget const& other)
+{
+    if((void*)this == (void*)&other)
+        return *this;
+
+    guid = other.guid;
+    asOfTime = other.asOfTime;
+
+    return *this;
+}
+
+bool LootTarget::operator< (const LootTarget& other) const
+{
+    return guid < other.guid;
+}
+
+void LootTargetList::shrink(time_t fromTime)
+{
+    for (set<LootTarget>::iterator i = begin(); i != end(); )
+    {
+        if (i->asOfTime <= fromTime)
+            erase(i++);
+		else
+			++i;
+    }
+}
+
+LootObject::LootObject(Player* bot, ObjectGuid guid)
+	: guid(), skillId(SKILL_NONE), reqSkillValue(0), reqItem(NULL)
+{
+    Refresh(bot, guid);
+}
+
+void LootObject::Refresh(Player* bot, ObjectGuid guid)
+{
+    skillId = SKILL_NONE;
+    reqSkillValue = 0;
+    reqItem = NULL;
+    this->guid = ObjectGuid();
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+    {
+        if (creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+            this->guid = guid;
+
+        if (creature->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SKINNABLE))
+        {
+            skillId = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+            uint32 targetLevel = creature->getLevel();
+            reqSkillValue = targetLevel < 10 ? 0 : targetLevel < 20 ? (targetLevel - 10) * 10 : targetLevel * 5;
+            if (bot->HasSkill(skillId) && bot->GetSkillValue(skillId) >= reqSkillValue)
+                this->guid = guid;
+        }
+
+        return;
+    }
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+    {
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return;
+
+        this->guid = guid;
+        for (int i = 0; i < 8; ++i)
+        {
+            switch (lockInfo->Type[i])
+            {
+            case LOCK_KEY_ITEM:
+                if (lockInfo->Index[i] > 0)
+                {
+                    reqItem = lockInfo->Index[i];
+                }
+                break;
+            case LOCK_KEY_SKILL:
+                if (SkillByLockType(LockType(lockInfo->Index[i])) > 0)
+                {
+                    skillId = SkillByLockType(LockType(lockInfo->Index[i]));
+                    reqSkillValue = lockInfo->Skill[i];
+                }
+                break;
+            default:
+                break;
+            }
+        }
+    }
+}
+
+WorldObject* LootObject::GetWorldObject(Player* bot)
+{
+    Refresh(bot, guid);
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    Creature *creature = ai->GetCreature(guid);
+    if (creature && creature->getDeathState() == CORPSE)
+        return creature;
+
+    GameObject* go = ai->GetGameObject(guid);
+    if (go && go->isSpawned())
+        return go;
+
+    return NULL;
+}
+
+LootObject::LootObject(const LootObject& other)
+{
+    guid = other.guid;
+    skillId = other.skillId;
+    reqSkillValue = other.reqSkillValue;
+    reqItem = other.reqItem;
+}
+
+bool LootObject::IsLootPossible(Player* bot)
+{
+    if (IsEmpty() || !GetWorldObject(bot))
+        return false;
+
+    PlayerbotAI* ai = bot->GetPlayerbotAI();
+
+    if (reqItem && !bot->HasItemCount(reqItem, 1))
+        return false;
+
+    if (skillId == SKILL_NONE)
+        return true;
+
+    if (skillId == SKILL_FISHING)
+        return false;
+
+    if (!bot->HasSkill(skillId))
+        return false;
+
+    if (!reqSkillValue)
+        return true;
+
+    uint32 skillValue = uint32(bot->GetPureSkillValue(skillId));
+    if (reqSkillValue > skillValue)
+        return false;
+
+    if (skillId == SKILL_MINING && !bot->HasItemTotemCategory(TC_MINING_PICK))
+        return false;
+
+    if (skillId == SKILL_SKINNING && !bot->HasItemTotemCategory(TC_SKINNING_KNIFE))
+        return false;
+
+    return true;
+}
+
+bool LootObjectStack::Add(ObjectGuid guid)
+{
+    if (!availableLoot.insert(guid).second)
+        return false;
+
+    if (availableLoot.size() < MAX_LOOT_OBJECT_COUNT)
+        return true;
+
+    vector<LootObject> ordered = OrderByDistance();
+    for (size_t i = MAX_LOOT_OBJECT_COUNT; i < ordered.size(); i++)
+        Remove(ordered[i].guid);
+
+    return true;
+}
+
+void LootObjectStack::Remove(ObjectGuid guid)
+{
+    LootTargetList::iterator i = availableLoot.find(guid);
+    if (i != availableLoot.end())
+        availableLoot.erase(i);
+}
+
+void LootObjectStack::Clear()
+{
+    availableLoot.clear();
+}
+
+bool LootObjectStack::CanLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return !ordered.empty();
+}
+
+LootObject LootObjectStack::GetLoot(float maxDistance)
+{
+    vector<LootObject> ordered = OrderByDistance(maxDistance);
+    return ordered.empty() ? LootObject() : *ordered.begin();
+}
+
+vector<LootObject> LootObjectStack::OrderByDistance(float maxDistance)
+{
+    availableLoot.shrink(time(0) - 30);
+
+    map<float, LootObject> sortedMap;
+    LootTargetList safeCopy(availableLoot);
+    for (LootTargetList::iterator i = safeCopy.begin(); i != safeCopy.end(); i++)
+    {
+        ObjectGuid guid = i->guid;
+        LootObject lootObject(bot, guid);
+        if (!lootObject.IsLootPossible(bot))
+            continue;
+
+        float distance = bot->GetDistance(lootObject.GetWorldObject(bot));
+        if (!maxDistance || distance <= maxDistance)
+            sortedMap[distance] = lootObject;
+    }
+
+    vector<LootObject> result;
+    for (map<float, LootObject>::iterator i = sortedMap.begin(); i != sortedMap.end(); i++)
+        result.push_back(i->second);
+    return result;
+}
+
diff --git a/src/plugins/playerbot/LootObjectStack.h b/src/plugins/playerbot/LootObjectStack.h
new file mode 100644
index 0000000..a35bdd2
--- /dev/null
+++ b/src/plugins/playerbot/LootObjectStack.h
@@ -0,0 +1,76 @@
+#pragma once
+
+using namespace std;
+
+namespace ai
+{
+    enum LootStrategy
+    {
+        LOOTSTRATEGY_QUEST = 1,
+        LOOTSTRATEGY_SKILL = 2,
+        LOOTSTRATEGY_GRAY = 3,
+        LOOTSTRATEGY_NORMAL = 4,
+        LOOTSTRATEGY_ALL = 5
+    };
+
+    class LootObject
+    {
+    public:
+        LootObject() {}
+        LootObject(Player* bot, ObjectGuid guid);
+        LootObject(const LootObject& other);
+
+    public:
+        bool IsEmpty() { return !guid; }
+        bool IsLootPossible(Player* bot);
+        void Refresh(Player* bot, ObjectGuid guid);
+        WorldObject* GetWorldObject(Player* bot);
+        ObjectGuid guid;
+
+        uint32 skillId;
+        uint32 reqSkillValue;
+        uint32 reqItem;
+    };
+
+    class LootTarget
+    {
+    public:
+        LootTarget(ObjectGuid guid);
+        LootTarget(LootTarget const& other);
+
+    public:
+        LootTarget& operator=(LootTarget const& other);
+        bool operator< (const LootTarget& other) const;
+
+    public:
+        ObjectGuid guid;
+        time_t asOfTime;
+    };
+
+    class LootTargetList : public set<LootTarget>
+    {
+    public:
+        void shrink(time_t fromTime);
+    };
+
+    class LootObjectStack
+    {
+    public:
+        LootObjectStack(Player* bot) : bot(bot) {}
+
+    public:
+        bool Add(ObjectGuid guid);
+        void Remove(ObjectGuid guid);
+        void Clear();
+        bool CanLoot(float maxDistance);
+        LootObject GetLoot(float maxDistance = 0);
+
+    private:
+        vector<LootObject> OrderByDistance(float maxDistance = 0);
+
+    private:
+        Player* bot;
+        LootTargetList availableLoot;
+    };
+
+};
diff --git a/src/plugins/playerbot/PlayerbotAI.cpp b/src/plugins/playerbot/PlayerbotAI.cpp
new file mode 100644
index 0000000..82c203d
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.cpp
@@ -0,0 +1,1390 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+
+#include "AiFactory.h"
+
+#include "../Grids/Notifiers/GridNotifiers.h"
+#include "../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../Grids/Cells/CellImpl.h"
+#include "strategy/values/LastMovementValue.h"
+#include "strategy/actions/LogLevelAction.h"
+#include "strategy/values/LastSpellCastValue.h"
+#include "LootObjectStack.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotSecurity.h"
+#include "../Groups/Group.h"
+#include "../Entities/Pet/Pet.h"
+#include "../Spells/Auras/SpellAuraEffects.h"
+
+using namespace ai;
+using namespace std;
+
+vector<string>& split(const string &s, char delim, vector<string> &elems);
+vector<string> split(const string &s, char delim);
+uint64 extractGuid(WorldPacket& packet);
+std::string &trim(std::string &s);
+
+uint32 PlayerbotChatHandler::extractQuestId(string str)
+{
+    char* source = (char*)str.c_str();
+    char* cId = extractKeyFromLink(source,"Hquest");
+    return cId ? atol(cId) : 0;
+}
+
+void PacketHandlingHelper::AddHandler(uint16 opcode, string handler)
+{
+    handlers[opcode] = handler;
+}
+
+void PacketHandlingHelper::Handle(ExternalEventHelper &helper)
+{
+    while (!queue.empty())
+    {
+        helper.HandlePacket(handlers, queue.top());
+        queue.pop();
+    }
+}
+
+void PacketHandlingHelper::AddPacket(const WorldPacket& packet)
+{
+	if (handlers.find(packet.GetOpcode()) != handlers.end())
+        queue.push(WorldPacket(packet));
+}
+
+
+PlayerbotAI::PlayerbotAI() : PlayerbotAIBase(), bot(NULL), aiObjectContext(NULL),
+    currentEngine(NULL), chatHelper(this), chatFilter(this), accountId(0), security(NULL), master(NULL)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i] = NULL;
+}
+
+PlayerbotAI::PlayerbotAI(Player* bot) :
+    PlayerbotAIBase(), chatHelper(this), chatFilter(this), security(bot), master(NULL)
+{
+	this->bot = bot;
+
+	accountId = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+
+    aiObjectContext = AiFactory::createAiObjectContext(bot, this);
+
+    engines[BOT_STATE_COMBAT] = AiFactory::createCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_NON_COMBAT] = AiFactory::createNonCombatEngine(bot, this, aiObjectContext);
+    engines[BOT_STATE_DEAD] = AiFactory::createDeadEngine(bot, this, aiObjectContext);
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    currentState = BOT_STATE_NON_COMBAT;
+
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_REPORT_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_AREATRIGGER, "area trigger");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GAMEOBJ_USE, "use game object");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LOOT_ROLL, "loot roll");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GOSSIP_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_HELLO, "gossip hello");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_COMPLETE_QUEST, "complete quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_QUESTGIVER_ACCEPT_QUEST, "accept quest");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXI, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_ACTIVATETAXIEXPRESS, "activate taxi");
+    masterIncomingPacketHandlers.AddHandler(CMSG_MOVE_SPLINE_DONE, "taxi done");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GROUP_UNINVITE_GUID, "uninvite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_PUSHQUESTTOPARTY, "quest share");
+    masterIncomingPacketHandlers.AddHandler(CMSG_GUILD_INVITE, "guild invite");
+    masterIncomingPacketHandlers.AddHandler(CMSG_LFG_TELEPORT, "lfg teleport");
+
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_INVITE, "group invite");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_NOT_ENOUGHT_MONEY, "not enough money");
+    botOutgoingPacketHandlers.AddHandler(BUY_ERR_REPUTATION_REQUIRE, "not enough reputation");
+    botOutgoingPacketHandlers.AddHandler(SMSG_GROUP_SET_LEADER, "group set leader");
+    botOutgoingPacketHandlers.AddHandler(SMSG_FORCE_RUN_SPEED_CHANGE, "check mount state");
+    botOutgoingPacketHandlers.AddHandler(SMSG_RESURRECT_REQUEST, "resurrect request");
+    botOutgoingPacketHandlers.AddHandler(SMSG_INVENTORY_CHANGE_FAILURE, "cannot equip");
+    botOutgoingPacketHandlers.AddHandler(SMSG_TRADE_STATUS, "trade status");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LOOT_RESPONSE, "loot response");
+    botOutgoingPacketHandlers.AddHandler(SMSG_QUESTUPDATE_ADD_KILL, "quest objective completed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_ITEM_PUSH_RESULT, "item push result");
+    botOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    botOutgoingPacketHandlers.AddHandler(SMSG_CAST_FAILED, "cast failed");
+    botOutgoingPacketHandlers.AddHandler(SMSG_DUEL_REQUESTED, "duel requested");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_ROLE_CHECK_UPDATE, "lfg role check");
+    botOutgoingPacketHandlers.AddHandler(SMSG_LFG_PROPOSAL_UPDATE, "lfg proposal");
+
+    masterOutgoingPacketHandlers.AddHandler(SMSG_PARTY_COMMAND_RESULT, "party command");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK, "ready check");
+    masterOutgoingPacketHandlers.AddHandler(MSG_RAID_READY_CHECK_FINISHED, "ready check finished");
+}
+
+PlayerbotAI::~PlayerbotAI()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i])
+            delete engines[i];
+    }
+
+    if (aiObjectContext)
+        delete aiObjectContext;
+}
+
+void PlayerbotAI::UpdateAI(uint32 elapsed)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown &&
+            bot->IsNonMeleeSpellCast(true, true, false) &&
+            *GetAiObjectContext()->GetValue<bool>("invalid target", "current target"))
+    {
+        Spell* spell = bot->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && !spell->GetSpellInfo()->IsPositive())
+        {
+            InterruptSpell();
+            SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        }
+    }
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.maxWaitForMove && bot->IsInCombat() && !bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+    {
+        nextAICheckDelay = sPlayerbotAIConfig.maxWaitForMove;
+    }
+
+    PlayerbotAIBase::UpdateAI(elapsed);
+}
+
+void PlayerbotAI::UpdateAIInternal(uint32 elapsed)
+{
+    ExternalEventHelper helper(aiObjectContext);
+    while (!chatCommands.empty())
+    {
+        ChatCommandHolder holder = chatCommands.top();
+        string command = holder.GetCommand();
+        Player* owner = holder.GetOwner();
+        if (!helper.ParseChatCommand(command, owner) && holder.GetType() == CHAT_MSG_WHISPER)
+        {
+            ostringstream out; out << "Unknown command " << command;
+            TellMaster(out);
+            helper.ParseChatCommand("help");
+        }
+        chatCommands.pop();
+    }
+
+    botOutgoingPacketHandlers.Handle(helper);
+    masterIncomingPacketHandlers.Handle(helper);
+    masterOutgoingPacketHandlers.Handle(helper);
+
+	DoNextAction();
+}
+
+void PlayerbotAI::HandleTeleportAck()
+{
+	bot->GetMotionMaster()->Clear(true);
+	if (bot->IsBeingTeleportedNear())
+	{
+		WorldPacket p = WorldPacket(MSG_MOVE_TELEPORT_ACK, 8 + 4 + 4);
+		p.appendPackGUID(bot->GetGUID());
+		p << (uint32) 0; // supposed to be flags? not used currently
+		p << (uint32) time(0); // time - not currently used
+		bot->GetSession()->HandleMoveTeleportAck(p);
+	}
+	else if (bot->IsBeingTeleportedFar())
+	{
+		bot->GetSession()->HandleMoveWorldportAckOpcode();
+		SetNextCheckDelay(1000);
+	}
+}
+
+void PlayerbotAI::Reset()
+{
+    if (bot->IsFlying())
+        return;
+
+    currentEngine = engines[BOT_STATE_NON_COMBAT];
+    nextAICheckDelay = 0;
+
+    aiObjectContext->GetValue<Unit*>("old target")->Set(NULL);
+    aiObjectContext->GetValue<Unit*>("current target")->Set(NULL);
+    aiObjectContext->GetValue<LootObject>("loot target")->Set(LootObject());
+    aiObjectContext->GetValue<uint32>("lfg proposal")->Set(0);
+
+    LastSpellCast & lastSpell = aiObjectContext->GetValue<LastSpellCast& >("last spell cast")->Get();
+    lastSpell.Reset();
+
+    LastMovement & lastMovement = aiObjectContext->GetValue<LastMovement& >("last movement")->Get();
+    lastMovement.Set(NULL);
+
+    bot->GetMotionMaster()->Clear();
+    bot->m_taxi.ClearTaxiDestinations();
+    InterruptSpell();
+
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        engines[i]->Init();
+    }
+}
+
+void PlayerbotAI::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    if (!GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_ADDON)
+        return;
+
+    string filtered = text;
+    if (!sPlayerbotAIConfig.commandPrefix.empty())
+    {
+        if (filtered.find(sPlayerbotAIConfig.commandPrefix) != 0)
+            return;
+
+        filtered = filtered.substr(sPlayerbotAIConfig.commandPrefix.size());
+    }
+
+    filtered = chatFilter.Filter(trim((string&)filtered));
+    if (filtered.empty())
+        return;
+
+    if (filtered.find("who") != 0 && !GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, type != CHAT_MSG_WHISPER, &fromPlayer))
+        return;
+
+    if (type == CHAT_MSG_RAID_WARNING && filtered.find(bot->GetName()) != string::npos && filtered.find("award") == string::npos)
+    {
+        ChatCommandHolder cmd("warning", &fromPlayer, type);
+        chatCommands.push(cmd);
+        return;
+    }
+
+    if (filtered.size() > 2 && filtered.substr(0, 2) == "d " || filtered.size() > 3 && filtered.substr(0, 3) == "do ")
+    {
+        std::string action = filtered.substr(filtered.find(" ") + 1);
+        DoSpecificAction(action);
+    }
+    else if (filtered == "reset")
+    {
+        Reset();
+    }
+    else
+    {
+        ChatCommandHolder cmd(filtered, &fromPlayer, type);
+        chatCommands.push(cmd);
+    }
+}
+
+void PlayerbotAI::HandleBotOutgoingPacket(const WorldPacket& packet)
+{
+    switch (packet.GetOpcode())
+    {
+    case SMSG_MOVE_SET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+
+            bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+            return;
+        }
+    case SMSG_MOVE_UNSET_CAN_FLY:
+        {
+            WorldPacket p(packet);
+            uint64 guid;
+            p.readPackGUID(guid);
+            if (guid != bot->GetGUID())
+                return;
+            bot->m_movementInfo.RemoveMovementFlag(MOVEMENTFLAG_FLYING);
+            return;
+        }
+    case SMSG_CAST_FAILED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint8 castCount, result;
+            uint32 spellId;
+            p >> castCount >> spellId >> result;
+            if (result != SPELL_CAST_OK)
+            {
+                SpellInterrupted(spellId);
+                botOutgoingPacketHandlers.AddPacket(packet);
+            }
+            return;
+        }
+    case SMSG_SPELL_FAILURE:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint8 castCount;
+            uint32 spellId;
+            p >> castCount;
+            p >> spellId;
+            SpellInterrupted(spellId);
+            return;
+        }
+    case SMSG_SPELL_DELAYED:
+        {
+            WorldPacket p(packet);
+            p.rpos(0);
+            uint64 casterGuid;
+            p.readPackGUID(casterGuid);
+
+            if (casterGuid != bot->GetGUID())
+                return;
+
+            uint32 delaytime;
+            p >> delaytime;
+            if (delaytime <= 1000)
+                IncreaseNextCheckDelay(delaytime);
+            return;
+        }
+    default:
+        botOutgoingPacketHandlers.AddPacket(packet);
+    }
+}
+
+void PlayerbotAI::SpellInterrupted(uint32 spellid)
+{
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    if (lastSpell.id != spellid)
+        return;
+
+    lastSpell.Reset();
+
+    time_t now = time(0);
+    if (now <= lastSpell.time)
+        return;
+
+    int castTimeSpent = 1000 * (now - lastSpell.time);
+
+    int globalCooldown = CalculateGlobalCooldown(lastSpell.id);
+    if (castTimeSpent < globalCooldown)
+        SetNextCheckDelay(globalCooldown - castTimeSpent);
+    else
+        SetNextCheckDelay(0);
+
+    lastSpell.id = 0;
+}
+
+int32 PlayerbotAI::CalculateGlobalCooldown(uint32 spellid)
+{
+    if (!spellid)
+        return 0;
+
+    if (bot->GetSpellHistory()->HasCooldown(spellid))
+        return sPlayerbotAIConfig.globalCoolDown;
+
+    return sPlayerbotAIConfig.reactDelay;
+}
+
+void PlayerbotAI::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    masterIncomingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    masterOutgoingPacketHandlers.AddPacket(packet);
+}
+
+void PlayerbotAI::ChangeEngine(BotState type)
+{
+    Engine* engine = engines[type];
+
+    if (currentEngine != engine)
+    {
+        currentEngine = engine;
+        currentState = type;
+        ReInitCurrentEngine();
+
+        switch (type)
+        {
+        case BOT_STATE_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_NON_COMBAT:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s NON-COMBAT ===", bot->GetName().c_str());
+            break;
+        case BOT_STATE_DEAD:
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "=== %s DEAD ===", bot->GetName().c_str());
+            break;
+        }
+    }
+}
+
+void PlayerbotAI::DoNextAction()
+{
+    if (bot->IsBeingTeleported() || (GetMaster() && GetMaster()->IsBeingTeleported()))
+        return;
+
+    currentEngine->DoNextAction(NULL);
+
+    if (bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        // TODO
+        //WorldPacket packet(CMSG_MOVE_SET_FLY);
+        //packet.appendPackGUID(bot->GetGUID());
+        //packet << bot->m_movementInfo;
+        bot->SetMover(bot);
+        //bot->GetSession()->HandleMovementOpcodes(packet);
+    }
+
+    Player* master = GetMaster();
+    if (bot->IsMounted() && bot->IsFlying())
+    {
+        bot->m_movementInfo.SetMovementFlags((MovementFlags)(MOVEMENTFLAG_FLYING|MOVEMENTFLAG_CAN_FLY));
+
+        bot->SetSpeed(MOVE_FLIGHT, 1.0f, true);
+        bot->SetSpeed(MOVE_RUN, 1.0f, true);
+
+        if (master)
+        {
+            bot->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT), true);
+            bot->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT), true);
+        }
+
+    }
+
+    if (currentEngine != engines[BOT_STATE_DEAD] && !bot->IsAlive())
+        ChangeEngine(BOT_STATE_DEAD);
+
+    if (currentEngine == engines[BOT_STATE_DEAD] && bot->IsAlive())
+        ChangeEngine(BOT_STATE_NON_COMBAT);
+
+    Group *group = bot->GetGroup();
+    if (!master && group)
+    {
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member && member->IsInWorld() && !member->GetPlayerbotAI() && (!master || master->GetPlayerbotAI()))
+            {
+                ai->SetMaster(member);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotAI::ReInitCurrentEngine()
+{
+    InterruptSpell();
+    currentEngine->Init();
+}
+
+void PlayerbotAI::ChangeStrategy(string names, BotState type)
+{
+    Engine* e = engines[type];
+    if (!e)
+        return;
+
+    e->ChangeStrategy(names);
+}
+
+void PlayerbotAI::DoSpecificAction(string name)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        ostringstream out;
+        ActionResult res = engines[i]->ExecuteAction(name);
+        switch (res)
+        {
+        case ACTION_RESULT_UNKNOWN:
+            continue;
+        case ACTION_RESULT_OK:
+            out << name << ": done";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_IMPOSSIBLE:
+            out << name << ": impossible";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_USELESS:
+            out << name << ": useless";
+            TellMaster(out);
+            return;
+        case ACTION_RESULT_FAILED:
+            out << name << ": failed";
+            TellMaster(out);
+            return;
+        }
+    }
+    ostringstream out;
+    out << name << ": unknown action";
+    TellMaster(out);
+}
+
+bool PlayerbotAI::ContainsStrategy(StrategyType type)
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+    {
+        if (engines[i]->ContainsStrategy(type))
+            return true;
+    }
+    return false;
+}
+
+bool PlayerbotAI::HasStrategy(string name, BotState type)
+{
+    return engines[type]->HasStrategy(name);
+}
+
+void PlayerbotAI::ResetStrategies()
+{
+    for (int i = 0 ; i < BOT_STATE_MAX; i++)
+        engines[i]->removeAllStrategies();
+
+    AiFactory::AddDefaultCombatStrategies(bot, this, engines[BOT_STATE_COMBAT]);
+    AiFactory::AddDefaultNonCombatStrategies(bot, this, engines[BOT_STATE_NON_COMBAT]);
+    AiFactory::AddDefaultDeadStrategies(bot, this, engines[BOT_STATE_DEAD]);
+}
+
+bool PlayerbotAI::IsRanged(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_RANGED);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+    case CLASS_ROGUE:
+        return false;
+    case CLASS_DRUID:
+        return !HasAnyAuraOf(player, "cat form", "bear form", "dire bear form", NULL);
+    }
+    return true;
+}
+
+bool PlayerbotAI::IsTank(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_TANK);
+
+    switch (player->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "bear form", "dire bear form", NULL);
+    }
+    return false;
+}
+
+bool PlayerbotAI::IsHeal(Player* player)
+{
+    PlayerbotAI* botAi = player->GetPlayerbotAI();
+    if (botAi)
+        return botAi->ContainsStrategy(STRATEGY_TYPE_HEAL);
+
+    switch (player->getClass())
+    {
+    case CLASS_PRIEST:
+        return true;
+    case CLASS_DRUID:
+        return HasAnyAuraOf(player, "tree of life form", NULL);
+    }
+    return false;
+}
+
+
+
+namespace MaNGOS
+{
+
+    class UnitByGuidInRangeCheck
+    {
+    public:
+        UnitByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(Unit* u)
+        {
+            return u->GetGUID() == i_guid && i_obj->IsWithinDistInMap(u, i_range);
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+    class GameObjectByGuidInRangeCheck
+    {
+    public:
+        GameObjectByGuidInRangeCheck(WorldObject const* obj, ObjectGuid guid, float range) : i_obj(obj), i_range(range), i_guid(guid) {}
+        WorldObject const& GetFocusObject() const { return *i_obj; }
+        bool operator()(GameObject* u)
+        {
+            if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo() && u->GetGUID() == i_guid)
+                return true;
+
+            return false;
+        }
+    private:
+        WorldObject const* i_obj;
+        float i_range;
+        ObjectGuid i_guid;
+    };
+
+};
+
+
+Unit* PlayerbotAI::GetUnit(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return ObjectAccessor::GetUnit(*bot, guid);
+}
+
+
+Creature* PlayerbotAI::GetCreature(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetCreature(guid);
+}
+
+GameObject* PlayerbotAI::GetGameObject(ObjectGuid guid)
+{
+    if (!guid)
+        return NULL;
+
+    Map* map = bot->GetMap();
+    if (!map)
+        return NULL;
+
+    return map->GetGameObject(guid);
+}
+
+bool PlayerbotAI::TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!GetSecurity()->CheckLevelFor(securityLevel, true, master))
+        return false;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            master->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.whisperDistance))
+        return false;
+
+    bot->Whisper(text, LANG_UNIVERSAL, master);
+    return true;
+}
+
+bool PlayerbotAI::TellMaster(string text, PlayerbotSecurityLevel securityLevel)
+{
+    if (!TellMasterNoFacing(text, securityLevel))
+        return false;
+
+    if (!bot->isMoving() && !bot->IsInCombat() && bot->GetMapId() == master->GetMapId())
+    {
+        if (!bot->isInFront(master, M_PI / 2))
+            bot->SetFacingTo(bot->GetAngle(master));
+
+        bot->HandleEmoteCommand(EMOTE_ONESHOT_TALK);
+    }
+
+    return true;
+}
+
+bool IsRealAura(Player* bot, Aura const* aura, Unit* unit)
+{
+    if (!aura)
+        return false;
+
+    if (!unit->IsHostileTo(bot))
+        return true;
+
+    uint32 stacks = aura->GetStackAmount();
+    if (stacks >= aura->GetSpellInfo()->StackAmount)
+        return true;
+
+    if (aura->GetCaster() == bot || aura->GetSpellInfo()->IsPositive() || aura->IsArea())
+        return true;
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(string name, Unit* unit)
+{
+    if (!unit)
+        return false;
+
+    uint32 spellId = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellId)
+        return HasAura(spellId, unit);
+
+    wstring wnamepart;
+    if (!Utf8toWStr(name, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+
+    Unit::AuraApplicationMap& map = unit->GetAppliedAuras();
+    for (Unit::AuraApplicationMap::iterator i = map.begin(); i != map.end(); ++i)
+    {
+        Aura const* aura  = i->second->GetBase();
+        if (!aura)
+            continue;
+
+        const string auraName = aura->GetSpellInfo()->SpellName[0];
+        if (auraName.empty() || auraName.length() != wnamepart.length() || !Utf8FitTo(auraName, wnamepart))
+            continue;
+
+        if (IsRealAura(bot, aura, unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAura(uint32 spellId, const Unit* unit)
+{
+    if (!spellId || !unit)
+        return false;
+
+    for (uint32 effect = EFFECT_0; effect <= EFFECT_2; effect++)
+    {
+        Aura* aura = ((Unit*)unit)->GetAura(spellId);
+
+        if (IsRealAura(bot, aura, (Unit*)unit))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAnyAuraOf(Unit* player, ...)
+{
+    if (!player)
+        return false;
+
+    va_list vl;
+    va_start(vl, player);
+
+    const char* cur;
+    do {
+        cur = va_arg(vl, const char*);
+        if (cur && HasAura(cur, player)) {
+            va_end(vl);
+            return true;
+        }
+    }
+    while (cur);
+
+    va_end(vl);
+    return false;
+}
+
+bool PlayerbotAI::CanCastSpell(string name, Unit* target)
+{
+    return CanCastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+}
+
+bool PlayerbotAI::CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell)
+{
+    if (!spellid)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    if (checkHasSpell && !bot->HasSpell(spellid))
+        return false;
+
+    if (bot->GetSpellHistory()->HasCooldown(spellid))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    bool positiveSpell = spellInfo->IsPositive();
+    if (positiveSpell && bot->IsHostileTo(target))
+        return false;
+
+    if (!positiveSpell && bot->IsFriendlyTo(target))
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    if (bot != target && bot->GetDistance(target) > sPlayerbotAIConfig.sightDistance)
+        return false;
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+    Spell *spell = new Spell(bot, spellInfo, TRIGGERED_NONE);
+
+    spell->m_targets.SetUnitTarget(target);
+    spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellid)->Get();
+    spell->m_targets.SetItemTarget(spell->m_CastItem);
+    SpellCastResult result = spell->CheckCast(false);
+    delete spell;
+	if (oldSel)
+		bot->SetSelection(oldSel->GetGUID());
+
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_INFRONT:
+    case SPELL_FAILED_NOT_STANDING:
+    case SPELL_FAILED_UNIT_NOT_INFRONT:
+    case SPELL_FAILED_SUCCESS:
+    case SPELL_FAILED_MOVING:
+    case SPELL_FAILED_TRY_AGAIN:
+    case SPELL_FAILED_NOT_IDLE:
+    case SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW:
+    case SPELL_FAILED_SUMMON_PENDING:
+    case SPELL_FAILED_BAD_IMPLICIT_TARGETS:
+    case SPELL_FAILED_BAD_TARGETS:
+    case SPELL_CAST_OK:
+    case SPELL_FAILED_ITEM_NOT_FOUND:
+        return true;
+    default:
+        return false;
+    }
+}
+
+
+bool PlayerbotAI::CastSpell(string name, Unit* target)
+{
+    bool result = CastSpell(aiObjectContext->GetValue<uint32>("spell id", name)->Get(), target);
+    if (result)
+    {
+        aiObjectContext->GetValue<time_t>("last spell cast time", name)->Set(time(0));
+    }
+
+    return result;
+}
+
+bool PlayerbotAI::CastSpell(uint32 spellId, Unit* target)
+{
+    if (!spellId)
+        return false;
+
+    if (!target)
+        target = bot;
+
+    Pet* pet = bot->GetPet();
+    const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (pet && pet->HasSpell(spellId))
+    {
+        pet->GetCharmInfo()->SetSpellAutocast(pSpellInfo, true);
+        pet->GetCharmInfo()->ToggleCreatureAutocast(pSpellInfo, true);
+        TellMaster("My pet will auto-cast this spell");
+        return true;
+    }
+
+    aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get().Set(spellId, target->GetGUID(), time(0));
+    aiObjectContext->GetValue<LastMovement&>("last movement")->Get().Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (bot->IsFlying())
+        return false;
+
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    Unit* oldSel = bot->GetSelectedUnit();
+    bot->SetSelection(target->GetGUID());
+
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    if (bot->isMoving() && spell->GetCastTime())
+    {
+        delete spell;
+        return false;
+    }
+
+    SpellCastTargets targets;
+    WorldObject* faceTo = target;
+
+    if (pSpellInfo->Targets & TARGET_FLAG_SOURCE_LOCATION ||
+            pSpellInfo->Targets & TARGET_FLAG_DEST_LOCATION)
+    {
+        targets.SetDst(target->GetPosition());
+    }
+    else
+    {
+        targets.SetUnitTarget(target);
+    }
+
+    if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+    {
+        spell->m_CastItem = aiObjectContext->GetValue<Item*>("item for spell", spellId)->Get();
+        targets.SetItemTarget(spell->m_CastItem);
+    }
+
+    if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_OPEN_LOCK ||
+        pSpellInfo->Effects[0].Effect == SPELL_EFFECT_SKINNING)
+    {
+        LootObject loot = *aiObjectContext->GetValue<LootObject>("loot target");
+        if (!loot.IsLootPossible(bot))
+        {
+            delete spell;
+            return false;
+        }
+
+        GameObject* go = GetGameObject(loot.guid);
+        if (go && go->isSpawned())
+        {
+            WorldPacket* const packetgouse = new WorldPacket(CMSG_GAMEOBJ_REPORT_USE, 8);
+            *packetgouse << loot.guid;
+            bot->GetSession()->QueuePacket(packetgouse);
+            targets.SetGOTarget(go);
+            faceTo = go;
+        }
+        else
+        {
+            Unit* creature = GetUnit(loot.guid);
+            if (creature)
+            {
+                targets.SetUnitTarget(creature);
+                faceTo = creature;
+            }
+        }
+    }
+
+
+    if (!bot->isInFront(faceTo, M_PI / 2))
+    {
+        bot->SetFacingTo(bot->GetAngle(faceTo));
+        delete spell;
+        SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+        return false;
+    }
+
+	spell->prepare(&targets);
+	WaitForSpellCast(spell);
+
+    if (oldSel)
+        bot->SetSelection(oldSel->GetGUID());
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+    return lastSpell.id == spellId;
+}
+
+void PlayerbotAI::WaitForSpellCast(Spell *spell)
+{
+    const SpellInfo* const pSpellInfo = spell->GetSpellInfo();
+
+    float castTime = spell->GetCastTime() + sPlayerbotAIConfig.reactDelay;
+    if (pSpellInfo->IsChanneled())
+    {
+        int32 duration = pSpellInfo->GetDuration();
+        if (duration > 0)
+            castTime += duration;
+    }
+
+    castTime = ceil(castTime);
+
+    uint32 globalCooldown = CalculateGlobalCooldown(pSpellInfo->Id);
+    if (castTime < globalCooldown)
+        castTime = globalCooldown;
+
+    SetNextCheckDelay(castTime);
+}
+
+void PlayerbotAI::InterruptSpell()
+{
+    if (bot->GetCurrentSpell(CURRENT_CHANNELED_SPELL))
+        return;
+
+    LastSpellCast& lastSpell = aiObjectContext->GetValue<LastSpellCast&>("last spell cast")->Get();
+
+    for (int type = CURRENT_MELEE_SPELL; type < CURRENT_CHANNELED_SPELL; type++)
+    {
+        Spell* spell = bot->GetCurrentSpell((CurrentSpellTypes)type);
+        if (!spell)
+            continue;
+
+        bot->InterruptSpell((CurrentSpellTypes)type);
+
+        WorldPacket data(SMSG_SPELL_FAILURE, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        data.Initialize(SMSG_SPELL_FAILED_OTHER, 8 + 1 + 4 + 1);
+        data.appendPackGUID(bot->GetGUID());
+        data << uint8(1);
+        data << uint32(spell->m_spellInfo->Id);
+        data << uint8(0);
+        bot->SendMessageToSet(&data, true);
+
+        SpellInterrupted(spell->m_spellInfo->Id);
+    }
+
+    SpellInterrupted(lastSpell.id);
+}
+
+
+void PlayerbotAI::RemoveAura(string name)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", name)->Get();
+    if (spellid && HasAura(spellid, bot))
+        bot->RemoveAurasDueToSpell(spellid);
+}
+
+bool PlayerbotAI::IsInterruptableSpellCasting(Unit* target, string spell)
+{
+    uint32 spellid = aiObjectContext->GetValue<uint32>("spell id", spell)->Get();
+    if (!spellid || !target->IsNonMeleeSpellCast(true))
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid );
+    if (!spellInfo)
+        return false;
+
+    if (target->IsImmunedToSpell(spellInfo))
+        return false;
+
+    for (uint32 i = EFFECT_0; i <= EFFECT_2; i++)
+    {
+        if ((spellInfo->InterruptFlags & SPELL_INTERRUPT_FLAG_INTERRUPT) && spellInfo->PreventionType == SPELL_PREVENTION_TYPE_SILENCE)
+            return true;
+
+        if ((spellInfo->Effects[i].Effect == SPELL_EFFECT_REMOVE_AURA || spellInfo->Effects[i].Effect == SPELL_EFFECT_INTERRUPT_CAST) &&
+                !target->IsImmunedToSpellEffect(spellInfo, i))
+            return true;
+    }
+
+    return false;
+}
+
+bool PlayerbotAI::HasAuraToDispel(Unit* target, uint32 dispelType)
+{
+    for (uint32 type = SPELL_AURA_NONE; type < TOTAL_AURAS; ++type)
+    {
+        Unit::AuraEffectList const& auras = target->GetAuraEffectsByType((AuraType)type);
+        for (Unit::AuraEffectList::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+        {
+            const AuraEffect *const aura = *itr;
+			const SpellInfo* entry = aura->GetSpellInfo();
+            uint32 spellId = entry->Id;
+
+            bool isPositiveSpell = entry->IsPositive();
+            if (isPositiveSpell && bot->IsFriendlyTo(target))
+                continue;
+
+            if (!isPositiveSpell && bot->IsHostileTo(target))
+                continue;
+
+            if (canDispel(entry, dispelType))
+                return true;
+        }
+    }
+    return false;
+}
+
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool PlayerbotAI::canDispel(const SpellInfo* entry, uint32 dispelType)
+{
+    if (entry->Dispel != dispelType)
+        return false;
+
+    return !entry->SpellName[0] ||
+        (strcmpi((const char*)entry->SpellName[0], "demon skin") &&
+        strcmpi((const char*)entry->SpellName[0], "mage armor") &&
+        strcmpi((const char*)entry->SpellName[0], "frost armor") &&
+        strcmpi((const char*)entry->SpellName[0], "wavering will") &&
+        strcmpi((const char*)entry->SpellName[0], "chilled") &&
+        strcmpi((const char*)entry->SpellName[0], "ice armor"));
+}
+
+bool IsAlliance(uint8 race)
+{
+    return race == RACE_HUMAN || race == RACE_DWARF || race == RACE_NIGHTELF ||
+            race == RACE_GNOME || race == RACE_DRAENEI;
+}
+
+bool PlayerbotAI::IsOpposing(Player* player)
+{
+    return IsOpposing(player->getRace(), bot->getRace());
+}
+
+bool PlayerbotAI::IsOpposing(uint8 race1, uint8 race2)
+{
+    return (IsAlliance(race1) && !IsAlliance(race2)) || (!IsAlliance(race1) && IsAlliance(race2));
+}
+
+void PlayerbotAI::RemoveShapeshift()
+{
+    RemoveAura("bear form");
+    RemoveAura("dire bear form");
+    RemoveAura("moonkin form");
+    RemoveAura("travel form");
+    RemoveAura("cat form");
+    RemoveAura("flight form");
+    RemoveAura("swift flight form");
+    RemoveAura("aquatic form");
+    RemoveAura("ghost wolf");
+    RemoveAura("tree of life");
+}
+
+uint32 PlayerbotAI::GetEquipGearScore(Player* player, bool withBags, bool withBank)
+{
+    std::vector<uint32> gearScore(EQUIPMENT_SLOT_END);
+    uint32 twoHandScore = 0;
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            _fillGearScoreData(player, item, &gearScore, twoHandScore);
+    }
+
+    if (withBags)
+    {
+        // check inventory
+        for (int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        // check bags
+        for (int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        {
+            if (Bag* pBag = (Bag*)player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                {
+                    if (Item* item2 = pBag->GetItemByPos(j))
+                        _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                }
+            }
+        }
+    }
+
+    if (withBank)
+    {
+        for (uint8 i = BANK_SLOT_ITEM_START; i < BANK_SLOT_ITEM_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                _fillGearScoreData(player, item, &gearScore, twoHandScore);
+        }
+
+        for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        {
+            if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            {
+                if (item->IsBag())
+                {
+                    Bag* bag = (Bag*)item;
+                    for (uint8 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (Item* item2 = bag->GetItemByPos(j))
+                            _fillGearScoreData(player, item2, &gearScore, twoHandScore);
+                    }
+                }
+            }
+        }
+    }
+
+    uint8 count = EQUIPMENT_SLOT_END - 2;   // ignore body and tabard slots
+    uint32 sum = 0;
+
+    // check if 2h hand is higher level than main hand + off hand
+    if (gearScore[EQUIPMENT_SLOT_MAINHAND] + gearScore[EQUIPMENT_SLOT_OFFHAND] < twoHandScore * 2)
+    {
+        gearScore[EQUIPMENT_SLOT_OFFHAND] = 0;  // off hand is ignored in calculations if 2h weapon has higher score
+        --count;
+        gearScore[EQUIPMENT_SLOT_MAINHAND] = twoHandScore;
+    }
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < EQUIPMENT_SLOT_END; ++i)
+    {
+       sum += gearScore[i];
+    }
+
+    if (count)
+    {
+        uint32 res = uint32(sum / count);
+        return res;
+    }
+    else
+        return 0;
+}
+
+void PlayerbotAI::_fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore)
+{
+    if (!item)
+        return;
+
+    if (player->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+        return;
+
+    uint8 type   = item->GetTemplate()->InventoryType;
+    uint32 level = item->GetTemplate()->ItemLevel;
+
+    switch (type)
+    {
+        case INVTYPE_2HWEAPON:
+            twoHandScore = std::max(twoHandScore, level);
+            break;
+        case INVTYPE_WEAPON:
+        case INVTYPE_WEAPONMAINHAND:
+            (*gearScore)[SLOT_MAIN_HAND] = std::max((*gearScore)[SLOT_MAIN_HAND], level);
+            break;
+        case INVTYPE_SHIELD:
+        case INVTYPE_WEAPONOFFHAND:
+            (*gearScore)[EQUIPMENT_SLOT_OFFHAND] = std::max((*gearScore)[EQUIPMENT_SLOT_OFFHAND], level);
+            break;
+        case INVTYPE_THROWN:
+        case INVTYPE_RANGEDRIGHT:
+        case INVTYPE_RANGED:
+        case INVTYPE_QUIVER:
+        case INVTYPE_RELIC:
+            (*gearScore)[EQUIPMENT_SLOT_RANGED] = std::max((*gearScore)[EQUIPMENT_SLOT_RANGED], level);
+            break;
+        case INVTYPE_HEAD:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        case INVTYPE_NECK:
+            (*gearScore)[EQUIPMENT_SLOT_NECK] = std::max((*gearScore)[EQUIPMENT_SLOT_NECK], level);
+            break;
+        case INVTYPE_SHOULDERS:
+            (*gearScore)[EQUIPMENT_SLOT_SHOULDERS] = std::max((*gearScore)[EQUIPMENT_SLOT_SHOULDERS], level);
+            break;
+        case INVTYPE_BODY:
+            (*gearScore)[EQUIPMENT_SLOT_BODY] = std::max((*gearScore)[EQUIPMENT_SLOT_BODY], level);
+            break;
+        case INVTYPE_CHEST:
+            (*gearScore)[EQUIPMENT_SLOT_CHEST] = std::max((*gearScore)[EQUIPMENT_SLOT_CHEST], level);
+            break;
+        case INVTYPE_WAIST:
+            (*gearScore)[EQUIPMENT_SLOT_WAIST] = std::max((*gearScore)[EQUIPMENT_SLOT_WAIST], level);
+            break;
+        case INVTYPE_LEGS:
+            (*gearScore)[EQUIPMENT_SLOT_LEGS] = std::max((*gearScore)[EQUIPMENT_SLOT_LEGS], level);
+            break;
+        case INVTYPE_FEET:
+            (*gearScore)[EQUIPMENT_SLOT_FEET] = std::max((*gearScore)[EQUIPMENT_SLOT_FEET], level);
+            break;
+        case INVTYPE_WRISTS:
+            (*gearScore)[EQUIPMENT_SLOT_WRISTS] = std::max((*gearScore)[EQUIPMENT_SLOT_WRISTS], level);
+            break;
+        case INVTYPE_HANDS:
+            (*gearScore)[EQUIPMENT_SLOT_HEAD] = std::max((*gearScore)[EQUIPMENT_SLOT_HEAD], level);
+            break;
+        // equipped gear score check uses both rings and trinkets for calculation, assume that for bags/banks it is the same
+        // with keeping second highest score at second slot
+        case INVTYPE_FINGER:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_FINGER1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = (*gearScore)[EQUIPMENT_SLOT_FINGER1];
+                (*gearScore)[EQUIPMENT_SLOT_FINGER1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_FINGER2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_FINGER2] = level;
+            break;
+        }
+        case INVTYPE_TRINKET:
+        {
+            if ((*gearScore)[EQUIPMENT_SLOT_TRINKET1] < level)
+            {
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = (*gearScore)[EQUIPMENT_SLOT_TRINKET1];
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET1] = level;
+            }
+            else if ((*gearScore)[EQUIPMENT_SLOT_TRINKET2] < level)
+                (*gearScore)[EQUIPMENT_SLOT_TRINKET2] = level;
+            break;
+        }
+        case INVTYPE_CLOAK:
+            (*gearScore)[EQUIPMENT_SLOT_BACK] = std::max((*gearScore)[EQUIPMENT_SLOT_BACK], level);
+            break;
+        default:
+            break;
+    }
+}
+
+string PlayerbotAI::HandleRemoteCommand(string command)
+{
+    if (command == "state")
+    {
+        switch (currentState)
+        {
+        case BOT_STATE_COMBAT:
+            return "combat";
+        case BOT_STATE_DEAD:
+            return "dead";
+        case BOT_STATE_NON_COMBAT:
+            return "non-combat";
+        default:
+            return "unknown";
+        }
+    }
+    else if (command == "position")
+    {
+        ostringstream out; out << bot->GetMapId() << "," << bot->GetPositionX() << "," << bot->GetPositionY() << "," << bot->GetPositionZ() << "," << bot->GetOrientation();
+        return out.str();
+    }
+    else if (command == "target")
+    {
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return "";
+        }
+
+        return target->GetName();
+    }
+    else if (command == "hp")
+    {
+        int pct = (int)((static_cast<float> (bot->GetHealth()) / bot->GetMaxHealth()) * 100);
+        ostringstream out; out << pct << "%";
+
+        Unit* target = *GetAiObjectContext()->GetValue<Unit*>("current target");
+        if (!target) {
+            return out.str();
+        }
+
+        pct = (int)((static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100);
+        out << " / " << pct << "%";
+        return out.str();
+    }
+    else if (command == "strategy")
+    {
+        return currentEngine->ListStrategies();
+    }
+    else if (command == "action")
+    {
+        return currentEngine->GetLastAction();
+    }
+    ostringstream out; out << "invalid command: " << command;
+    return out.str();
+}
diff --git a/src/plugins/playerbot/PlayerbotAI.h b/src/plugins/playerbot/PlayerbotAI.h
new file mode 100644
index 0000000..06cd309
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAI.h
@@ -0,0 +1,186 @@
+#pragma once
+
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "PlayerbotAIBase.h"
+#include "strategy/AiObjectContext.h"
+#include "strategy/Engine.h"
+#include "strategy/ExternalEventHelper.h"
+#include "ChatFilter.h"
+#include "PlayerbotSecurity.h"
+#include <stack>
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using namespace ai;
+
+bool IsAlliance(uint8 race);
+
+class PlayerbotChatHandler: protected ChatHandler
+{
+public:
+    explicit PlayerbotChatHandler(Player* pMasterPlayer) : ChatHandler(pMasterPlayer->GetSession()) {}
+    void sysmessage(string str) { SendSysMessage(str.c_str()); }
+    uint32 extractQuestId(string str);
+    uint32 extractSpellId(string str)
+    {
+        char* source = (char*)str.c_str();
+        return extractSpellIdFromLink(source);
+    }
+};
+
+namespace ai
+{
+	class MinValueCalculator {
+	public:
+		MinValueCalculator(float def = 0.0f) {
+			param = NULL;
+			minValue = def;
+		}
+
+	public:
+		void probe(float value, void* p) {
+			if (!param || minValue >= value) {
+				minValue = value;
+				param = p;
+			}
+		}
+
+	public:
+		void* param;
+		float minValue;
+	};
+};
+
+enum BotState
+{
+    BOT_STATE_COMBAT = 0,
+    BOT_STATE_NON_COMBAT = 1,
+    BOT_STATE_DEAD = 2
+};
+
+#define BOT_STATE_MAX 3
+
+class PacketHandlingHelper
+{
+public:
+    void AddHandler(uint16 opcode, string handler);
+    void Handle(ExternalEventHelper &helper);
+    void AddPacket(const WorldPacket& packet);
+
+private:
+    map<uint16, string> handlers;
+    stack<WorldPacket> queue;
+};
+
+class ChatCommandHolder
+{
+public:
+    ChatCommandHolder(string command, Player* owner = NULL, uint32 type = CHAT_MSG_WHISPER) : command(command), owner(owner), type(type) {}
+    ChatCommandHolder(ChatCommandHolder const& other)
+    {
+        this->command = other.command;
+        this->owner = other.owner;
+        this->type = other.type;
+    }
+
+public:
+    string GetCommand() { return command; }
+    Player* GetOwner() { return owner; }
+    uint32 GetType() { return type; }
+
+private:
+    string command;
+    Player* owner;
+    uint32 type;
+};
+
+class PlayerbotAI : public PlayerbotAIBase
+{
+public:
+	PlayerbotAI();
+	PlayerbotAI(Player* bot);
+	virtual ~PlayerbotAI();
+
+public:
+	virtual void UpdateAI(uint32 elapsed);
+	virtual void UpdateAIInternal(uint32 elapsed);
+	string HandleRemoteCommand(string command);
+    void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+	void HandleBotOutgoingPacket(const WorldPacket& packet);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+	void HandleTeleportAck();
+    void ChangeEngine(BotState type);
+    void DoNextAction();
+    void DoSpecificAction(string name);
+    void ChangeStrategy(string name, BotState type);
+    bool ContainsStrategy(StrategyType type);
+    bool HasStrategy(string name, BotState type);
+    void ResetStrategies();
+    void ReInitCurrentEngine();
+    void Reset();
+    bool IsTank(Player* player);
+    bool IsHeal(Player* player);
+    bool IsRanged(Player* player);
+    Creature* GetCreature(ObjectGuid guid);
+    Unit* GetUnit(ObjectGuid guid);
+    GameObject* GetGameObject(ObjectGuid guid);
+    bool TellMaster(ostringstream &stream, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL) { return TellMaster(stream.str(), securityLevel); }
+    bool TellMaster(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    bool TellMasterNoFacing(string text, PlayerbotSecurityLevel securityLevel = PLAYERBOT_SECURITY_ALLOW_ALL);
+    void SpellInterrupted(uint32 spellid);
+    int32 CalculateGlobalCooldown(uint32 spellid);
+    void InterruptSpell();
+    void RemoveAura(string name);
+    void RemoveShapeshift();
+    void WaitForSpellCast(Spell *spell);
+
+    virtual bool CanCastSpell(string name, Unit* target);
+    virtual bool CastSpell(string name, Unit* target);
+    virtual bool HasAura(string spellName, Unit* player);
+    virtual bool HasAnyAuraOf(Unit* player, ...);
+
+    virtual bool IsInterruptableSpellCasting(Unit* player, string spell);
+    virtual bool HasAuraToDispel(Unit* player, uint32 dispelType);
+    bool CanCastSpell(uint32 spellid, Unit* target, bool checkHasSpell = true);
+
+    bool HasAura(uint32 spellId, const Unit* player);
+    bool CastSpell(uint32 spellId, Unit* target);
+    bool canDispel(const SpellInfo* entry, uint32 dispelType);
+
+    uint32 GetEquipGearScore(Player* player, bool withBags, bool withBank);
+
+private:
+    void _fillGearScoreData(Player *player, Item* item, std::vector<uint32>* gearScore, uint32& twoHandScore);
+
+public:
+	Player* GetBot() { return bot; }
+    Player* GetMaster() { return master; }
+    void SetMaster(Player* master) { this->master = master; }
+    AiObjectContext* GetAiObjectContext() { return aiObjectContext; }
+    ChatHelper* GetChatHelper() { return &chatHelper; }
+    bool IsOpposing(Player* player);
+    static bool IsOpposing(uint8 race1, uint8 race2);
+    PlayerbotSecurity* GetSecurity() { return &security; }
+
+protected:
+	Player* bot;
+	Player* master;
+	uint32 accountId;
+    AiObjectContext* aiObjectContext;
+    Engine* currentEngine;
+    Engine* engines[BOT_STATE_MAX];
+    BotState currentState;
+    ChatHelper chatHelper;
+    stack<ChatCommandHolder> chatCommands;
+    PacketHandlingHelper botOutgoingPacketHandlers;
+    PacketHandlingHelper masterIncomingPacketHandlers;
+    PacketHandlingHelper masterOutgoingPacketHandlers;
+    CompositeChatFilter chatFilter;
+    PlayerbotSecurity security;
+};
+
diff --git a/src/plugins/playerbot/PlayerbotAIAware.h b/src/plugins/playerbot/PlayerbotAIAware.h
new file mode 100644
index 0000000..740628a
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIAware.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class PlayerbotAIAware 
+    {
+    public:
+        PlayerbotAIAware(PlayerbotAI* const ai) : ai(ai) { }
+
+    protected:
+        PlayerbotAI* ai;
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/PlayerbotAIBase.cpp b/src/plugins/playerbot/PlayerbotAIBase.cpp
new file mode 100644
index 0000000..4acb310
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.cpp
@@ -0,0 +1,51 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+PlayerbotAIBase::PlayerbotAIBase() : nextAICheckDelay(0)
+{
+}
+
+void PlayerbotAIBase::UpdateAI(uint32 elapsed)
+{
+    if (nextAICheckDelay > elapsed)
+        nextAICheckDelay -= elapsed;
+    else
+        nextAICheckDelay = 0;
+
+    if (!CanUpdateAI())
+        return;
+
+    UpdateAIInternal(elapsed);
+    YieldThread();
+}
+
+void PlayerbotAIBase::SetNextCheckDelay(const uint32 delay)
+{
+    nextAICheckDelay = delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "set next check delay: %d", nextAICheckDelay);
+}
+
+void PlayerbotAIBase::IncreaseNextCheckDelay(uint32 delay)
+{
+    nextAICheckDelay += delay;
+
+    if (nextAICheckDelay > sPlayerbotAIConfig.globalCoolDown)
+        sLog->outMessage("playerbot", LOG_LEVEL_TRACE, "increase next check delay: %d", nextAICheckDelay);
+}
+
+bool PlayerbotAIBase::CanUpdateAI()
+{
+    return nextAICheckDelay < 100;
+}
+
+void PlayerbotAIBase::YieldThread()
+{
+    if (nextAICheckDelay < sPlayerbotAIConfig.reactDelay)
+        nextAICheckDelay = sPlayerbotAIConfig.reactDelay;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIBase.h b/src/plugins/playerbot/PlayerbotAIBase.h
new file mode 100644
index 0000000..8e72bf0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIBase.h
@@ -0,0 +1,24 @@
+#pragma once
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+
+class PlayerbotAIBase
+{
+public:
+	PlayerbotAIBase();
+
+public:
+	bool CanUpdateAI();
+	void SetNextCheckDelay(const uint32 delay);
+    void IncreaseNextCheckDelay(uint32 delay);
+	void YieldThread();
+    virtual void UpdateAI(uint32 elapsed);
+    virtual void UpdateAIInternal(uint32 elapsed) = 0;
+
+protected:
+	uint32 nextAICheckDelay;
+};
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.cpp b/src/plugins/playerbot/PlayerbotAIConfig.cpp
new file mode 100644
index 0000000..44e5bd9
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.cpp
@@ -0,0 +1,229 @@
+#include "../pchdef.h"
+#include "PlayerbotAIConfig.h"
+#include "playerbot.h"
+#include "RandomPlayerbotFactory.h"
+#include "../../game/Accounts/AccountMgr.h"
+
+using namespace std;
+
+PlayerbotAIConfig::PlayerbotAIConfig()
+{
+}
+
+template <class T>
+void LoadList(string value, T &list)
+{
+    vector<string> ids = split(value, ',');
+    for (vector<string>::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        uint32 id = atoi((*i).c_str());
+        if (!id)
+            continue;
+
+        list.push_back(id);
+    }
+}
+
+bool PlayerbotAIConfig::Initialize()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing AI Playerbot by ike3, based on the original Playerbot by blueboy and screwed up by LordPsyan (Had to get my name in here somehow)");
+
+    string error;
+    if (!config.LoadInitial("aiplayerbot.conf", error))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled. Unable to open configuration file aiplayerbot.conf");
+        return false;
+    }
+
+    enabled = config.GetBoolDefault("AiPlayerbot.Enabled", true);
+    if (!enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot is Disabled in aiplayerbot.conf");
+        return false;
+    }
+
+    globalCoolDown = (uint32) config.GetIntDefault("AiPlayerbot.GlobalCooldown", 500);
+    maxWaitForMove = config.GetIntDefault("AiPlayerbot.MaxWaitForMove", 3000);
+    reactDelay = (uint32) config.GetIntDefault("AiPlayerbot.ReactDelay", 100);
+
+    sightDistance = config.GetFloatDefault("AiPlayerbot.SightDistance", 50.0f);
+    spellDistance = config.GetFloatDefault("AiPlayerbot.SpellDistance", 30.0f);
+    reactDistance = config.GetFloatDefault("AiPlayerbot.ReactDistance", 150.0f);
+    grindDistance = config.GetFloatDefault("AiPlayerbot.GrindDistance", 100.0f);
+    lootDistance = config.GetFloatDefault("AiPlayerbot.LootDistance", 20.0f);
+    fleeDistance = config.GetFloatDefault("AiPlayerbot.FleeDistance", 20.0f);
+    tooCloseDistance = config.GetFloatDefault("AiPlayerbot.TooCloseDistance", 7.0f);
+    meleeDistance = config.GetFloatDefault("AiPlayerbot.MeleeDistance", 1.5f);
+    followDistance = config.GetFloatDefault("AiPlayerbot.FollowDistance", 1.5f);
+    whisperDistance = config.GetFloatDefault("AiPlayerbot.WhisperDistance", 6000.0f);
+    contactDistance = config.GetFloatDefault("AiPlayerbot.ContactDistance", 0.5f);
+
+    criticalHealth = config.GetIntDefault("AiPlayerbot.CriticalHealth", 20);
+    lowHealth = config.GetIntDefault("AiPlayerbot.LowHealth", 50);
+    mediumHealth = config.GetIntDefault("AiPlayerbot.MediumHealth", 70);
+    almostFullHealth = config.GetIntDefault("AiPlayerbot.AlmostFullHealth", 85);
+    lowMana = config.GetIntDefault("AiPlayerbot.LowMana", 15);
+    mediumMana = config.GetIntDefault("AiPlayerbot.MediumMana", 40);
+
+    randomGearLoweringChance = config.GetFloatDefault("AiPlayerbot.RandomGearLoweringChance", 0.15);
+    randomBotMaxLevelChance = config.GetFloatDefault("AiPlayerbot.RandomBotMaxLevelChance", 0.4);
+
+    iterationsPerTick = config.GetIntDefault("AiPlayerbot.IterationsPerTick", 4);
+
+    allowGuildBots = config.GetBoolDefault("AiPlayerbot.AllowGuildBots", true);
+
+    randomBotMapsAsString = config.GetStringDefault("AiPlayerbot.RandomBotMaps", "0,1,530,571");
+    LoadList<vector<uint32> >(randomBotMapsAsString, randomBotMaps);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotQuestItems", "6948,5175,5176,5177,5178"), randomBotQuestItems);
+    LoadList<list<uint32> >(config.GetStringDefault("AiPlayerbot.RandomBotSpellIds", "54197"), randomBotSpellIds);
+
+    randomBotAutologin = config.GetBoolDefault("AiPlayerbot.RandomBotAutologin", true);
+    minRandomBots = config.GetIntDefault("AiPlayerbot.MinRandomBots", 50);
+    maxRandomBots = config.GetIntDefault("AiPlayerbot.MaxRandomBots", 200);
+    randomBotUpdateInterval = config.GetIntDefault("AiPlayerbot.RandomBotUpdateInterval", 60);
+    randomBotCountChangeMinInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMinInterval", 24 * 3600);
+    randomBotCountChangeMaxInterval = config.GetIntDefault("AiPlayerbot.RandomBotCountChangeMaxInterval", 3 * 24 * 3600);
+    minRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MinRandomBotInWorldTime", 2 * 3600);
+    maxRandomBotInWorldTime = config.GetIntDefault("AiPlayerbot.MaxRandomBotInWorldTime", 14 * 24 * 3600);
+    minRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MinRandomBotRandomizeTime", 2 * 3600);
+    maxRandomBotRandomizeTime = config.GetIntDefault("AiPlayerbot.MaxRandomRandomizeTime", 14 * 24 * 3600);
+    minRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MinRandomBotReviveTime", 60);
+    maxRandomBotReviveTime = config.GetIntDefault("AiPlayerbot.MaxRandomReviveTime", 300);
+    randomBotTeleportDistance = config.GetIntDefault("AiPlayerbot.RandomBotTeleportDistance", 1000);
+    minRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPerInterval", 50);
+    maxRandomBotsPerInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPerInterval", 100);
+    minRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MinRandomBotsPriceChangeInterval", 2 * 3600);
+    maxRandomBotsPriceChangeInterval = config.GetIntDefault("AiPlayerbot.MaxRandomBotsPriceChangeInterval", 48 * 3600);
+    randomBotJoinLfg = config.GetBoolDefault("AiPlayerbot.RandomBotJoinLfg", true);
+    logInGroupOnly = config.GetBoolDefault("AiPlayerbot.LogInGroupOnly", true);
+    logValuesPerTick = config.GetBoolDefault("AiPlayerbot.LogValuesPerTick", false);
+    fleeingEnabled = config.GetBoolDefault("AiPlayerbot.FleeingEnabled", true);
+    randomBotMinLevel = config.GetIntDefault("AiPlayerbot.RandomBotMinLevel", 1);
+    randomBotMaxLevel = config.GetIntDefault("AiPlayerbot.RandomBotMaxLevel", 255);
+    randomBotLoginAtStartup = config.GetBoolDefault("AiPlayerbot.RandomBotLoginAtStartup", true);
+    randomBotTeleLevel = config.GetIntDefault("AiPlayerbot.RandomBotTeleLevel", 3);
+
+    randomChangeMultiplier = config.GetFloatDefault("AiPlayerbot.RandomChangeMultiplier", 1.0);
+
+    randomBotCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotCombatStrategies", "+dps,+attack weak");
+    randomBotNonCombatStrategies = config.GetStringDefault("AiPlayerbot.RandomBotNonCombatStrategies", "+grind,+move random,+loot");
+
+    commandPrefix = config.GetStringDefault("AiPlayerbot.CommandPrefix", "");
+
+    commandServerPort = config.GetIntDefault("AiPlayerbot.CommandServerPort", 0);
+
+    for (uint32 cls = 0; cls < MAX_CLASSES; ++cls)
+    {
+        for (uint32 spec = 0; spec < 3; ++spec)
+        {
+            ostringstream os; os << "AiPlayerbot.RandomClassSpecProbability." << cls << "." << spec;
+            specProbability[cls][spec] = config.GetIntDefault(os.str().c_str(), 33);
+        }
+    }
+
+    randomBotAccountPrefix = config.GetStringDefault("AiPlayerbot.RandomBotAccountPrefix", "rndbot");
+    randomBotAccountCount = config.GetIntDefault("AiPlayerbot.RandomBotAccountCount", 50);
+    deleteRandomBotAccounts = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotAccounts", false);
+    randomBotGuildCount = config.GetIntDefault("AiPlayerbot.RandomBotGuildCount", 50);
+    deleteRandomBotGuilds = config.GetBoolDefault("AiPlayerbot.DeleteRandomBotGuilds", false);
+
+    guildTaskEnabled = config.GetBoolDefault("AiPlayerbot.EnableGuildTasks", true);
+    minGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskChangeTime", 2 * 24 * 3600);
+    maxGuildTaskChangeTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskChangeTime", 5 * 24 * 3600);
+    minGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskAdvertisementTime", 300);
+    maxGuildTaskAdvertisementTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskAdvertisementTime", 8 * 3600);
+    minGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MinGuildTaskRewardTime", 300);
+    maxGuildTaskRewardTime = config.GetIntDefault("AiPlayerbot.MaxGuildTaskRewardTime", 1 * 3600);
+
+    RandomPlayerbotFactory::CreateRandomBots();
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "AI Playerbot configuration loaded");
+
+    return true;
+}
+
+
+bool PlayerbotAIConfig::IsInRandomAccountList(uint32 id)
+{
+    return find(randomBotAccounts.begin(), randomBotAccounts.end(), id) != randomBotAccounts.end();
+}
+
+bool PlayerbotAIConfig::IsInRandomQuestItemList(uint32 id)
+{
+    return find(randomBotQuestItems.begin(), randomBotQuestItems.end(), id) != randomBotQuestItems.end();
+}
+
+string PlayerbotAIConfig::GetValue(string name)
+{
+    ostringstream out;
+
+    if (name == "GlobalCooldown")
+        out << globalCoolDown;
+    else if (name == "ReactDelay")
+        out << reactDelay;
+
+    else if (name == "SightDistance")
+        out << sightDistance;
+    else if (name == "SpellDistance")
+        out << spellDistance;
+    else if (name == "ReactDistance")
+        out << reactDistance;
+    else if (name == "GrindDistance")
+        out << grindDistance;
+    else if (name == "LootDistance")
+        out << lootDistance;
+    else if (name == "FleeDistance")
+        out << fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out << criticalHealth;
+    else if (name == "LowHealth")
+        out << lowHealth;
+    else if (name == "MediumHealth")
+        out << mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out << almostFullHealth;
+    else if (name == "LowMana")
+        out << lowMana;
+
+    else if (name == "IterationsPerTick")
+        out << iterationsPerTick;
+
+    return out.str();
+}
+
+void PlayerbotAIConfig::SetValue(string name, string value)
+{
+    istringstream out(value, istringstream::in);
+
+    if (name == "GlobalCooldown")
+        out >> globalCoolDown;
+    else if (name == "ReactDelay")
+        out >> reactDelay;
+
+    else if (name == "SightDistance")
+        out >> sightDistance;
+    else if (name == "SpellDistance")
+        out >> spellDistance;
+    else if (name == "ReactDistance")
+        out >> reactDistance;
+    else if (name == "GrindDistance")
+        out >> grindDistance;
+    else if (name == "LootDistance")
+        out >> lootDistance;
+    else if (name == "FleeDistance")
+        out >> fleeDistance;
+
+    else if (name == "CriticalHealth")
+        out >> criticalHealth;
+    else if (name == "LowHealth")
+        out >> lowHealth;
+    else if (name == "MediumHealth")
+        out >> mediumHealth;
+    else if (name == "AlmostFullHealth")
+        out >> almostFullHealth;
+    else if (name == "LowMana")
+        out >> lowMana;
+
+    else if (name == "IterationsPerTick")
+        out >> iterationsPerTick;
+}
diff --git a/src/plugins/playerbot/PlayerbotAIConfig.h b/src/plugins/playerbot/PlayerbotAIConfig.h
new file mode 100644
index 0000000..1bbb57d
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotAIConfig.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../../common/Configuration/Config.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+class PlayerbotAIConfig
+{
+public:
+    PlayerbotAIConfig();
+    static PlayerbotAIConfig& instance()
+    {
+        static PlayerbotAIConfig instance;
+        return instance;
+    }
+
+public:
+    bool Initialize();
+    bool IsInRandomAccountList(uint32 id);
+    bool IsInRandomQuestItemList(uint32 id);
+
+    bool enabled;
+    bool allowGuildBots;
+    uint32 globalCoolDown, reactDelay, maxWaitForMove;
+    float sightDistance, spellDistance, reactDistance, grindDistance, lootDistance,
+        fleeDistance, tooCloseDistance, meleeDistance, followDistance, whisperDistance, contactDistance;
+    uint32 criticalHealth, lowHealth, mediumHealth, almostFullHealth;
+    uint32 lowMana, mediumMana;
+
+    bool randomBotAutologin;
+    std::string randomBotMapsAsString;
+    std::vector<uint32> randomBotMaps;
+    std::list<uint32> randomBotQuestItems;
+    std::list<uint32> randomBotAccounts;
+    std::list<uint32> randomBotSpellIds;
+    uint32 randomBotTeleportDistance;
+    float randomGearLoweringChance;
+    float randomBotMaxLevelChance;
+    uint32 minRandomBots, maxRandomBots;
+    uint32 randomBotUpdateInterval, randomBotCountChangeMinInterval, randomBotCountChangeMaxInterval;
+    uint32 minRandomBotInWorldTime, maxRandomBotInWorldTime;
+    uint32 minRandomBotRandomizeTime, maxRandomBotRandomizeTime;
+    uint32 minRandomBotReviveTime, maxRandomBotReviveTime;
+    uint32 minRandomBotPvpTime, maxRandomBotPvpTime;
+    uint32 minRandomBotsPerInterval, maxRandomBotsPerInterval;
+    uint32 minRandomBotsPriceChangeInterval, maxRandomBotsPriceChangeInterval;
+    bool randomBotJoinLfg;
+    bool randomBotLoginAtStartup;
+    uint32 randomBotTeleLevel;
+    bool logInGroupOnly, logValuesPerTick;
+    bool fleeingEnabled;
+    std::string randomBotCombatStrategies, randomBotNonCombatStrategies;
+    uint32 randomBotMinLevel, randomBotMaxLevel;
+    float randomChangeMultiplier;
+    uint32 specProbability[MAX_CLASSES][3];
+    std::string commandPrefix;
+    std::string randomBotAccountPrefix;
+    uint32 randomBotAccountCount;
+    bool deleteRandomBotAccounts;
+    uint32 randomBotGuildCount;
+    bool deleteRandomBotGuilds;
+    std::list<uint32> randomBotGuilds;
+
+    bool guildTaskEnabled;
+    uint32 minGuildTaskChangeTime, maxGuildTaskChangeTime;
+    uint32 minGuildTaskAdvertisementTime, maxGuildTaskAdvertisementTime;
+    uint32 minGuildTaskRewardTime, maxGuildTaskRewardTime;
+
+    uint32 iterationsPerTick;
+
+    int commandServerPort;
+
+    std::string GetValue(std::string name);
+    void SetValue(std::string name, std::string value);
+
+private:
+    ConfigMgr config;
+};
+
+#define sPlayerbotAIConfig PlayerbotAIConfig::instance()
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.cpp b/src/plugins/playerbot/PlayerbotCommandServer.cpp
new file mode 100644
index 0000000..07aceb2
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.cpp
@@ -0,0 +1,94 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "PlayerbotCommandServer.h"
+#include <cstdlib>
+#include <iostream>
+#include <boost/bind.hpp>
+#include <boost/smart_ptr.hpp>
+#include <boost/asio.hpp>
+#include <boost/thread/thread.hpp>
+
+
+using namespace std;
+using boost::asio::ip::tcp;
+typedef boost::shared_ptr<tcp::socket> socket_ptr;
+
+bool ReadLine(socket_ptr sock, string* buffer, string* line)
+{
+    // Do the real reading from fd until buffer has '\n'.
+    string::iterator pos;
+    while ((pos = find(buffer->begin(), buffer->end(), '\n')) == buffer->end())
+    {
+        char buf[1025];
+        boost::system::error_code error;
+        size_t n = sock->read_some(boost::asio::buffer(buf), error);
+        if (n == -1 || error == boost::asio::error::eof)
+            return false;
+        else if (error)
+            throw boost::system::system_error(error); // Some other error.
+
+        buf[n] = 0;
+        *buffer += buf;
+    }
+
+    *line = string(buffer->begin(), pos);
+    *buffer = string(pos + 1, buffer->end());
+    return true;
+}
+
+void session(socket_ptr sock)
+{
+    try
+    {
+        string buffer, request;
+        while (ReadLine(sock, &buffer, &request)) {
+            string response = sRandomPlayerbotMgr.HandleRemoteCommand(request) + "\n";
+            boost::asio::write(*sock, boost::asio::buffer(response.c_str(), response.size()));
+            request = "";
+        }
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+void server(boost::asio::io_service& io_service, short port)
+{
+    tcp::acceptor a(io_service, tcp::endpoint(tcp::v4(), port));
+    for (;;)
+    {
+        socket_ptr sock(new tcp::socket(io_service));
+        a.accept(*sock);
+        boost::thread t(boost::bind(session, sock));
+    }
+}
+
+void Run()
+{
+    if (!sPlayerbotAIConfig.commandServerPort) {
+        return;
+    }
+
+    ostringstream s; s << "Starting Playerbot Command Server on port " << sPlayerbotAIConfig.commandServerPort;
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, s.str().c_str());
+
+    try
+    {
+        boost::asio::io_service io_service;
+        server(io_service, sPlayerbotAIConfig.commandServerPort);
+    }
+    catch (std::exception& e)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, e.what());
+    }
+}
+
+
+void PlayerbotCommandServer::Start()
+{
+    thread serverThread(Run);
+    serverThread.detach();
+}
diff --git a/src/plugins/playerbot/PlayerbotCommandServer.h b/src/plugins/playerbot/PlayerbotCommandServer.h
new file mode 100644
index 0000000..0ea66c7
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotCommandServer.h
@@ -0,0 +1,26 @@
+#ifndef _PlayerbotCommandServer_H
+#define _PlayerbotCommandServer_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+using namespace std;
+
+class PlayerbotCommandServer
+{
+public:
+    PlayerbotCommandServer() {}
+    virtual ~PlayerbotCommandServer() {}
+    static PlayerbotCommandServer& instance()
+    {
+        static PlayerbotCommandServer instance;
+        return instance;
+    }
+
+    void Start();
+};
+
+#define sPlayerbotCommandServer PlayerbotCommandServer::instance()
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotFactory.cpp b/src/plugins/playerbot/PlayerbotFactory.cpp
new file mode 100644
index 0000000..adc7b23
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.cpp
@@ -0,0 +1,1723 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotFactory.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "../ItemPrototype.h"
+#include "PlayerbotAIConfig.h"
+#include "../../shared/DataStores/DBCStore.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../ahbot/AhBot.h"
+#include "../Entities/Pet/Pet.h"
+#include "RandomPlayerbotFactory.h"
+
+using namespace ai;
+using namespace std;
+
+uint32 PlayerbotFactory::tradeSkills[] =
+{
+    SKILL_ALCHEMY,
+    SKILL_ENCHANTING,
+    SKILL_SKINNING,
+    SKILL_JEWELCRAFTING,
+    SKILL_INSCRIPTION,
+    SKILL_TAILORING,
+    SKILL_LEATHERWORKING,
+    SKILL_ENGINEERING,
+    SKILL_HERBALISM,
+    SKILL_MINING,
+    SKILL_BLACKSMITHING,
+    SKILL_COOKING,
+    SKILL_FIRST_AID,
+    SKILL_FISHING
+};
+
+void PlayerbotFactory::Randomize()
+{
+    Randomize(true);
+}
+
+void PlayerbotFactory::Refresh()
+{
+    Prepare();
+    InitEquipment(true);
+    InitAmmo();
+    InitFood();
+    InitPotions();
+
+    uint32 money = urand(level * 1000, level * 5 * 1000);
+    if (bot->GetMoney() < money)
+        bot->SetMoney(money);
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::CleanRandomize()
+{
+    Randomize(false);
+}
+
+void PlayerbotFactory::Prepare()
+{
+    if (!itemQuality)
+    {
+        if (level <= 10)
+            itemQuality = urand(ITEM_QUALITY_NORMAL, ITEM_QUALITY_UNCOMMON);
+        else if (level <= 20)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_RARE);
+        else if (level <= 40)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else if (level < 60)
+            itemQuality = urand(ITEM_QUALITY_UNCOMMON, ITEM_QUALITY_EPIC);
+        else
+            itemQuality = urand(ITEM_QUALITY_RARE, ITEM_QUALITY_EPIC);
+    }
+
+    if (bot->isDead())
+        bot->ResurrectPlayer(1.0f, false);
+
+    bot->CombatStop(true);
+    bot->SetLevel(level);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_HELM);
+    bot->SetFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK);
+}
+
+void PlayerbotFactory::Randomize(bool incremental)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing to randomize...");
+    Prepare();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Resetting player...");
+    bot->ResetTalents(true);
+    ClearSpells();
+    ClearInventory();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing quests...");
+    InitQuests();
+    // quest rewards boost bot level, so reduce back
+    bot->SetLevel(level);
+    ClearInventory();
+    bot->SetUInt32Value(PLAYER_XP, 0);
+    CancelAuras();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing spells (step 1)...");
+    InitAvailableSpells();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing skills (step 1)...");
+    InitSkills();
+    InitTradeSkills();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing talents...");
+    InitTalents();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing spells (step 2)...");
+    InitAvailableSpells();
+    InitSpecialSpells();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing mounts...");
+    InitMounts();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing skills (step 2)...");
+    UpdateTradeSkills();
+    bot->SaveToDB();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing equipmemt...");
+    InitEquipment(incremental);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing bags...");
+    InitBags();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing ammo...");
+    InitAmmo();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing food...");
+    InitFood();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing potions...");
+    InitPotions();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing second equipment set...");
+    InitSecondEquipmentSet();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing inventory...");
+    InitInventory();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing glyphs...");
+    InitGlyphs();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing guilds...");
+    InitGuild();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Initializing pet...");
+    InitPet();
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Saving to DB...");
+    bot->SetMoney(urand(level * 1000, level * 5 * 1000));
+    bot->SaveToDB();
+}
+
+void PlayerbotFactory::InitPet()
+{
+    Pet* pet = bot->GetPet();
+    if (!pet)
+    {
+        if (bot->getClass() != CLASS_HUNTER)
+            return;
+
+        Map* map = bot->GetMap();
+        if (!map)
+            return;
+
+		vector<uint32> ids;
+	    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+	    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+	    {
+	        CreatureTemplate const& co = i->second;
+            if (!co.IsTameable(false))
+                continue;
+
+            if (co.minlevel > bot->getLevel())
+                continue;
+
+			PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co.Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+			ids.push_back(i->first);
+		}
+
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No pets available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+            return;
+        }
+
+		for (int i = 0; i < 100; i++)
+		{
+			int index = urand(0, ids.size() - 1);
+			CreatureTemplate const* co = sObjectMgr->GetCreatureTemplate(ids[index]);
+
+            PetLevelInfo const* petInfo = sObjectMgr->GetPetLevelInfo(co->Entry, bot->getLevel());
+            if (!petInfo)
+                continue;
+
+            uint32 guid = map->GenerateLowGuid<HighGuid::Pet>();
+            pet = new Pet(bot, HUNTER_PET);
+            if (!pet->Create(guid, map, 0, ids[index], 0))
+            {
+                delete pet;
+                pet = NULL;
+                continue;
+            }
+
+            pet->SetPosition(bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), bot->GetOrientation());
+            pet->setFaction(bot->getFaction());
+            pet->SetLevel(bot->getLevel());
+            bot->SetPetGUID(pet->GetGUID());
+            bot->GetMap()->AddToMap(pet->ToCreature());
+            bot->SetMinion(pet, true);
+            pet->InitTalentForLevel();
+            bot->PetSpellInitialize();
+            bot->InitTamedPet(pet, bot->getLevel(), 0);
+
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "Bot %s: assign pet %d (%d level)", bot->GetName().c_str(), co->Entry, bot->getLevel());
+            pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+            break;
+        }
+    }
+
+    if (!pet)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot create pet for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+    {
+        if(itr->second.state == PETSPELL_REMOVED)
+            continue;
+
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (spellInfo->IsPassive())
+            continue;
+
+        pet->ToggleAutocast(spellInfo, true);
+    }
+}
+
+void PlayerbotFactory::ClearSpells()
+{
+    list<uint32> spells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        spells.push_back(spellId);
+    }
+
+    for (list<uint32>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        bot->RemoveSpell(*i, false, false);
+    }
+}
+
+void PlayerbotFactory::InitSpells()
+{
+    for (int i = 0; i < 15; i++)
+        InitAvailableSpells();
+}
+
+void PlayerbotFactory::InitTalents()
+{
+    uint32 point = urand(0, 100);
+    uint8 cls = bot->getClass();
+    uint32 p1 = sPlayerbotAIConfig.specProbability[cls][0];
+    uint32 p2 = p1 + sPlayerbotAIConfig.specProbability[cls][1];
+
+    uint32 specNo = (point < p1 ? 0 : (point < p2 ? 1 : 2));
+    InitTalents(specNo);
+
+    if (bot->GetFreeTalentPoints())
+        InitTalents(2 - specNo);
+}
+
+
+class DestroyItemsVisitor : public IterateItemsVisitor
+{
+public:
+    DestroyItemsVisitor(Player* bot) : IterateItemsVisitor(), bot(bot) {}
+
+    virtual bool Visit(Item* item)
+    {
+        uint32 id = item->GetTemplate()->ItemId;
+        if (CanKeep(id))
+        {
+            keep.insert(id);
+            return true;
+        }
+
+        bot->DestroyItem(item->GetBagSlot(), item->GetSlot(), true);
+        return true;
+    }
+
+private:
+    bool CanKeep(uint32 id)
+    {
+        if (keep.find(id) != keep.end())
+            return false;
+
+        if (sPlayerbotAIConfig.IsInRandomQuestItemList(id))
+            return true;
+
+
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(id);
+        if (proto->Class == ITEM_CLASS_MISC && (proto->SubClass == ITEM_SUBCLASS_JUNK_REAGENT || proto->SubClass == ITEM_SUBCLASS_JUNK))
+            return true;
+
+        return false;
+    }
+
+private:
+    Player* bot;
+    set<uint32> keep;
+
+};
+
+bool PlayerbotFactory::CanEquipArmor(ItemTemplate const* proto)
+{
+    if (bot->HasSkill(SKILL_SHIELD) && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        return true;
+
+    if (bot->HasSkill(SKILL_PLATE_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_PLATE)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_MAIL))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_MAIL)
+            return false;
+    }
+    else if (bot->HasSkill(SKILL_LEATHER))
+    {
+        if (proto->SubClass != ITEM_SUBCLASS_ARMOR_LEATHER)
+            return false;
+    }
+
+    if (proto->Quality <= ITEM_QUALITY_NORMAL)
+        return true;
+
+    uint8 sp = 0, ap = 0, tank = 0;
+    for (int j = 0; j < MAX_ITEM_PROTO_STATS; ++j)
+    {
+        // for ItemStatValue != 0
+        if(!proto->ItemStat[j].ItemStatValue)
+            continue;
+
+        AddItemStats(proto->ItemStat[j].ItemStatType, sp, ap, tank);
+    }
+
+    return CheckItemStats(sp, ap, tank);
+}
+
+bool PlayerbotFactory::CheckItemStats(uint8 sp, uint8 ap, uint8 tank)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (!sp || ap > sp || tank > sp)
+            return false;
+        break;
+    case CLASS_PALADIN:
+    case CLASS_WARRIOR:
+        if ((!ap && !tank) || sp > ap || sp > tank)
+            return false;
+        break;
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        if (!ap || sp > ap || sp > tank)
+            return false;
+        break;
+    }
+
+    return sp || ap || tank;
+}
+
+void PlayerbotFactory::AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank)
+{
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_MANA:
+    case ITEM_MOD_INTELLECT:
+    case ITEM_MOD_SPIRIT:
+    case ITEM_MOD_MANA_REGENERATION:
+    case ITEM_MOD_SPELL_POWER:
+    case ITEM_MOD_SPELL_PENETRATION:
+    case ITEM_MOD_HIT_SPELL_RATING:
+    case ITEM_MOD_CRIT_SPELL_RATING:
+    case ITEM_MOD_HASTE_SPELL_RATING:
+        sp++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_DEFENSE_SKILL_RATING:
+    case ITEM_MOD_DODGE_RATING:
+    case ITEM_MOD_PARRY_RATING:
+    case ITEM_MOD_BLOCK_RATING:
+    case ITEM_MOD_HIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_HIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_HIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_CRIT_TAKEN_MELEE_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RANGED_RATING:
+    case ITEM_MOD_CRIT_TAKEN_SPELL_RATING:
+    case ITEM_MOD_HIT_TAKEN_RATING:
+    case ITEM_MOD_CRIT_TAKEN_RATING:
+    case ITEM_MOD_RESILIENCE_RATING:
+    case ITEM_MOD_BLOCK_VALUE:
+        tank++;
+        break;
+    }
+
+    switch (mod)
+    {
+    case ITEM_MOD_HEALTH:
+    case ITEM_MOD_STAMINA:
+    case ITEM_MOD_HEALTH_REGEN:
+    case ITEM_MOD_AGILITY:
+    case ITEM_MOD_STRENGTH:
+    case ITEM_MOD_HIT_MELEE_RATING:
+    case ITEM_MOD_HIT_RANGED_RATING:
+    case ITEM_MOD_CRIT_MELEE_RATING:
+    case ITEM_MOD_CRIT_RANGED_RATING:
+    case ITEM_MOD_HASTE_MELEE_RATING:
+    case ITEM_MOD_HASTE_RANGED_RATING:
+    case ITEM_MOD_HIT_RATING:
+    case ITEM_MOD_CRIT_RATING:
+    case ITEM_MOD_HASTE_RATING:
+    case ITEM_MOD_EXPERTISE_RATING:
+    case ITEM_MOD_ATTACK_POWER:
+    case ITEM_MOD_RANGED_ATTACK_POWER:
+    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+        ap++;
+        break;
+    }
+}
+
+bool PlayerbotFactory::CanEquipWeapon(ItemTemplate const* proto)
+{
+    switch (bot->getClass())
+    {
+    case CLASS_PRIEST:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE)
+            return false;
+        break;
+    case CLASS_MAGE:
+    case CLASS_WARLOCK:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_WAND &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_WARRIOR:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    case CLASS_PALADIN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+            return false;
+        break;
+    case CLASS_SHAMAN:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_DRUID:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+            return false;
+        break;
+    case CLASS_HUNTER:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD2 &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW)
+            return false;
+        break;
+    case CLASS_ROGUE:
+        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_GUN &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_CROSSBOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_BOW &&
+                proto->SubClass != ITEM_SUBCLASS_WEAPON_THROWN)
+            return false;
+        break;
+    }
+
+    return true;
+}
+
+bool PlayerbotFactory::CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality)
+{
+    if (proto->Duration & 0x80000000)
+        return false;
+
+    if (proto->Quality != desiredQuality)
+        return false;
+
+    if (proto->Bonding == BIND_QUEST_ITEM || proto->Bonding == BIND_WHEN_USE)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_CONTAINER)
+        return true;
+
+    uint32 requiredLevel = proto->RequiredLevel;
+    if (!requiredLevel)
+        return false;
+
+    uint32 level = bot->getLevel();
+    uint32 delta = 2;
+    if (level < 15)
+        delta = urand(7, 15);
+    else if (proto->Class == ITEM_CLASS_WEAPON || proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        delta = urand(2, 3);
+    else if (!(level % 10) || (level % 10) == 9)
+        delta = 2;
+    else if (level < 40)
+        delta = urand(5, 10);
+    else if (level < 60)
+        delta = urand(3, 7);
+    else if (level < 70)
+        delta = urand(2, 5);
+    else if (level < 80)
+        delta = urand(2, 4);
+
+    if (desiredQuality > ITEM_QUALITY_NORMAL &&
+            (requiredLevel > level || requiredLevel < level - delta))
+        return false;
+
+    for (uint32 gap = 60; gap <= 80; gap += 10)
+    {
+        if (level > gap && requiredLevel <= gap)
+            return false;
+    }
+
+    return true;
+}
+
+void PlayerbotFactory::InitEquipment(bool incremental)
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor, ITERATE_ALL_ITEMS);
+
+    map<uint8, vector<uint32> > items;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        uint32 desiredQuality = itemQuality;
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+            desiredQuality--;
+        }
+
+        do
+        {
+            ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+            for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+            {
+                uint32 itemId = i->first;
+                ItemTemplate const* proto = &i->second;
+                if (!proto)
+                    continue;
+
+                if (proto->Class != ITEM_CLASS_WEAPON &&
+                    proto->Class != ITEM_CLASS_ARMOR &&
+                    proto->Class != ITEM_CLASS_CONTAINER &&
+                    proto->Class != ITEM_CLASS_PROJECTILE)
+                    continue;
+
+                if (!CanEquipItem(proto, desiredQuality))
+                    continue;
+
+                if (proto->Class == ITEM_CLASS_ARMOR && (
+                    slot == EQUIPMENT_SLOT_HEAD ||
+                    slot == EQUIPMENT_SLOT_SHOULDERS ||
+                    slot == EQUIPMENT_SLOT_CHEST ||
+                    slot == EQUIPMENT_SLOT_WAIST ||
+                    slot == EQUIPMENT_SLOT_LEGS ||
+                    slot == EQUIPMENT_SLOT_FEET ||
+                    slot == EQUIPMENT_SLOT_WRISTS ||
+                    slot == EQUIPMENT_SLOT_HANDS) && !CanEquipArmor(proto))
+                        continue;
+
+                if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+                    continue;
+
+                if (slot == EQUIPMENT_SLOT_OFFHAND && bot->getClass() == CLASS_ROGUE && proto->Class != ITEM_CLASS_WEAPON)
+                    continue;
+
+                uint16 dest = 0;
+                if (CanEquipUnseenItem(slot, dest, itemId))
+                    items[slot].push_back(itemId);
+            }
+        } while (items[slot].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+    }
+
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        if (slot == EQUIPMENT_SLOT_TABARD || slot == EQUIPMENT_SLOT_BODY)
+            continue;
+
+        vector<uint32>& ids = items[slot];
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to equip for slot %d", bot->GetName().c_str(), slot);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+            Item* oldItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+
+            if (incremental && !IsDesiredReplacement(oldItem)) {
+                continue;
+            }
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            if (oldItem)
+            {
+                bot->RemoveItem(INVENTORY_SLOT_BAG_0, slot, true);
+                oldItem->DestroyForPlayer(bot, false);
+            }
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                bot->AutoUnequipOffhandIfNeed();
+                EnchantItem(newItem);
+                break;
+            }
+        }
+    }
+}
+
+bool PlayerbotFactory::IsDesiredReplacement(Item* item)
+{
+    if (!item)
+        return true;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int delta = 1 + (80 - bot->getLevel()) / 10;
+    return (int)bot->getLevel() - (int)proto->RequiredLevel > delta;
+}
+
+void PlayerbotFactory::InitSecondEquipmentSet()
+{
+    if (bot->getClass() == CLASS_MAGE || bot->getClass() == CLASS_WARLOCK || bot->getClass() == CLASS_PRIEST)
+        return;
+
+    map<uint32, vector<uint32> > items;
+
+    uint32 desiredQuality = itemQuality;
+    while (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    do
+    {
+        ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+        for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+        {
+            uint32 itemId = i->first;
+            ItemTemplate const* proto = &i->second;
+            if (!proto)
+                continue;
+
+            if (!CanEquipItem(proto, desiredQuality))
+                continue;
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                if (!CanEquipWeapon(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+                if (existingItem)
+                {
+                    switch (existingItem->GetTemplate()->SubClass)
+                    {
+                    case ITEM_SUBCLASS_WEAPON_AXE:
+                    case ITEM_SUBCLASS_WEAPON_DAGGER:
+                    case ITEM_SUBCLASS_WEAPON_FIST:
+                    case ITEM_SUBCLASS_WEAPON_MACE:
+                    case ITEM_SUBCLASS_WEAPON_SWORD:
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+                            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    default:
+                        if (proto->SubClass != ITEM_SUBCLASS_WEAPON_AXE && proto->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_FIST && proto->SubClass != ITEM_SUBCLASS_WEAPON_MACE &&
+                            proto->SubClass != ITEM_SUBCLASS_WEAPON_SWORD)
+                            continue;
+                        break;
+                    }
+                }
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (!CanEquipArmor(proto))
+                    continue;
+
+                Item* existingItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+                if (existingItem && existingItem->GetTemplate()->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    continue;
+            }
+            else
+                continue;
+
+            items[proto->Class].push_back(itemId);
+        }
+    } while (items[ITEM_CLASS_ARMOR].empty() && items[ITEM_CLASS_WEAPON].empty() && desiredQuality-- > ITEM_QUALITY_NORMAL);
+
+    for (map<uint32, vector<uint32> >::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        vector<uint32>& ids = i->second;
+        if (ids.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no items to make second equipment set for slot %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            ItemPosCountVec sDest;
+            Item* newItem = StoreItem(newItemId, 1);
+            if (newItem)
+            {
+                EnchantItem(newItem);
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::InitBags()
+{
+    vector<uint32> ids;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto || proto->Class != ITEM_CLASS_CONTAINER)
+            continue;
+
+        if (!CanEquipItem(proto, ITEM_QUALITY_NORMAL))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: no bags found", bot->GetName().c_str());
+        return;
+    }
+
+    for (uint8 slot = INVENTORY_SLOT_BAG_START; slot < INVENTORY_SLOT_BAG_END; ++slot)
+    {
+        for (int attempts = 0; attempts < 15; attempts++)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            uint32 newItemId = ids[index];
+
+            uint16 dest;
+            if (!CanEquipUnseenItem(slot, dest, newItemId))
+                continue;
+
+            Item* newItem = bot->EquipNewItem(dest, newItemId, true);
+            if (newItem)
+            {
+                newItem->AddToWorld();
+                newItem->AddToUpdateQueueOf(bot);
+                break;
+            }
+        }
+    }
+}
+
+void PlayerbotFactory::EnchantItem(Item* item)
+{
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance)
+        return;
+
+    if (bot->getLevel() < urand(40, 50))
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    int32 itemLevel = proto->ItemLevel;
+
+    vector<uint32> ids;
+    int spellStore = sSpellStore.GetNumRows();
+    for (int id = 0; id < spellStore; ++id)
+    {
+        SpellInfo const *entry = sSpellMgr->GetSpellInfo(id);
+        if (!entry)
+            continue;
+
+        int32 requiredLevel = (int32)entry->BaseLevel;
+        if (requiredLevel && (requiredLevel > itemLevel || requiredLevel < itemLevel - 35))
+            continue;
+
+        if (entry->MaxLevel && level > entry->MaxLevel)
+            continue;
+
+        uint32 spellLevel = entry->SpellLevel;
+        if (spellLevel && (spellLevel > level || spellLevel < level - 10))
+            continue;
+
+        for (int j = 0; j < 3; ++j)
+        {
+            if (entry->Effects[j].Effect != SPELL_EFFECT_ENCHANT_ITEM)
+                continue;
+
+            uint32 enchant_id = entry->Effects[j].MiscValue;
+            if (!enchant_id)
+                continue;
+
+            SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchant || enchant->slot != PERM_ENCHANTMENT_SLOT)
+                continue;
+
+            if (enchant->requiredLevel && enchant->requiredLevel > level)
+                continue;
+
+            uint8 sp = 0, ap = 0, tank = 0;
+            for (int i = 0; i < 3; ++i)
+            {
+                if (enchant->type[i] != ITEM_ENCHANTMENT_TYPE_STAT)
+                    continue;
+
+                AddItemStats(enchant->spellid[i], sp, ap, tank);
+            }
+
+            if (!CheckItemStats(sp, ap, tank))
+                continue;
+
+            if (enchant->EnchantmentCondition && !bot->EnchantmentFitsRequirements(enchant->EnchantmentCondition, -1))
+                continue;
+
+            if (!item->IsFitToSpellRequirements(entry))
+                continue;
+
+            ids.push_back(enchant_id);
+        }
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG,  "%s: no enchantments found for item %d", bot->GetName().c_str(), item->GetTemplate()->ItemId);
+        return;
+    }
+
+    int index = urand(0, ids.size() - 1);
+    uint32 id = ids[index];
+
+    SpellItemEnchantmentEntry const* enchant = sSpellItemEnchantmentStore.LookupEntry(id);
+    if (!enchant)
+        return;
+
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, false);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, id, 0, 0);
+    bot->ApplyEnchantment(item, PERM_ENCHANTMENT_SLOT, true);
+}
+
+bool PlayerbotFactory::CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item)
+{
+    dest = 0;
+    Item *pItem = Item::CreateItem(item, 1, bot);
+    if (pItem)
+    {
+        InventoryResult result = bot->CanEquipItem(slot, dest, pItem, true, false);
+        pItem->RemoveFromUpdateQueueOf(bot);
+        delete pItem;
+        return result == EQUIP_ERR_OK;
+    }
+
+    return false;
+}
+
+void PlayerbotFactory::InitTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+
+    vector<uint32> firstSkills;
+    vector<uint32> secondSkills;
+    switch (bot->getClass())
+    {
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        firstSkills.push_back(SKILL_MINING);
+        secondSkills.push_back(SKILL_BLACKSMITHING);
+        secondSkills.push_back(SKILL_ENGINEERING);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_DRUID:
+    case CLASS_HUNTER:
+    case CLASS_ROGUE:
+        firstSkills.push_back(SKILL_SKINNING);
+        secondSkills.push_back(SKILL_LEATHERWORKING);
+        break;
+    default:
+        firstSkills.push_back(SKILL_TAILORING);
+        secondSkills.push_back(SKILL_ENCHANTING);
+    }
+
+    SetRandomSkill(SKILL_FIRST_AID);
+    SetRandomSkill(SKILL_FISHING);
+    SetRandomSkill(SKILL_COOKING);
+
+    switch (urand(0, 3))
+    {
+    case 0:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_ALCHEMY);
+        break;
+    case 1:
+        SetRandomSkill(SKILL_HERBALISM);
+        SetRandomSkill(SKILL_INSCRIPTION);
+        break;
+    case 2:
+        SetRandomSkill(SKILL_MINING);
+        SetRandomSkill(SKILL_JEWELCRAFTING);
+        break;
+    case 3:
+        SetRandomSkill(firstSkills[urand(0, firstSkills.size() - 1)]);
+        SetRandomSkill(secondSkills[urand(0, secondSkills.size() - 1)]);
+        break;
+    }
+}
+
+void PlayerbotFactory::UpdateTradeSkills()
+{
+    for (int i = 0; i < sizeof(tradeSkills) / sizeof(uint32); ++i)
+    {
+        if (bot->GetSkillValue(tradeSkills[i]) == 1)
+            bot->SetSkill(tradeSkills[i], 0, 0, 0);
+    }
+}
+
+void PlayerbotFactory::InitSkills()
+{
+    uint32 maxValue = level * 5;
+    SetRandomSkill(SKILL_DEFENSE);
+    SetRandomSkill(SKILL_SWORDS);
+    SetRandomSkill(SKILL_AXES);
+    SetRandomSkill(SKILL_BOWS);
+    SetRandomSkill(SKILL_GUNS);
+    SetRandomSkill(SKILL_MACES);
+    SetRandomSkill(SKILL_2H_SWORDS);
+    SetRandomSkill(SKILL_STAVES);
+    SetRandomSkill(SKILL_2H_MACES);
+    SetRandomSkill(SKILL_2H_AXES);
+    SetRandomSkill(SKILL_DAGGERS);
+    SetRandomSkill(SKILL_THROWN);
+    SetRandomSkill(SKILL_CROSSBOWS);
+    SetRandomSkill(SKILL_WANDS);
+    SetRandomSkill(SKILL_POLEARMS);
+    SetRandomSkill(SKILL_FIST_WEAPONS);
+
+    if (bot->getLevel() >= 70)
+        bot->SetSkill(SKILL_RIDING, 0, 300, 300);
+    else if (bot->getLevel() >= 60)
+        bot->SetSkill(SKILL_RIDING, 0, 225, 225);
+    else if (bot->getLevel() >= 40)
+        bot->SetSkill(SKILL_RIDING, 0, 150, 150);
+    else if (bot->getLevel() >= 20)
+        bot->SetSkill(SKILL_RIDING, 0, 75, 75);
+    else
+        bot->SetSkill(SKILL_RIDING, 0, 0, 0);
+
+    uint32 skillLevel = bot->getLevel() < 40 ? 0 : 1;
+    switch (bot->getClass())
+    {
+    case CLASS_DEATH_KNIGHT:
+    case CLASS_WARRIOR:
+    case CLASS_PALADIN:
+        bot->SetSkill(SKILL_PLATE_MAIL, 0, skillLevel, skillLevel);
+        break;
+    case CLASS_SHAMAN:
+    case CLASS_HUNTER:
+        bot->SetSkill(SKILL_MAIL, 0, skillLevel, skillLevel);
+    }
+}
+
+void PlayerbotFactory::SetRandomSkill(uint16 id)
+{
+    uint32 maxValue = level * 5;
+    uint32 curValue = urand(maxValue - level, maxValue);
+    bot->SetSkill(id, 0, curValue, maxValue);
+
+}
+
+void PlayerbotFactory::InitAvailableSpells()
+{
+    bot->LearnDefaultSkills();
+
+    CreatureTemplateContainer const* creatureTemplateContainer = sObjectMgr->GetCreatureTemplates();
+    for (CreatureTemplateContainer::const_iterator i = creatureTemplateContainer->begin(); i != creatureTemplateContainer->end(); ++i)
+    {
+        CreatureTemplate const& co = i->second;
+        if (co.trainer_type != TRAINER_TYPE_TRADESKILLS && co.trainer_type != TRAINER_TYPE_CLASS)
+            continue;
+
+        if (co.trainer_type == TRAINER_TYPE_CLASS && co.trainer_class != bot->getClass())
+            continue;
+
+		uint32 trainerId = co.Entry;
+
+		TrainerSpellData const* trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+        if (!trainer_spells)
+            trainer_spells = sObjectMgr->GetNpcTrainerSpells(trainerId);
+
+        if (!trainer_spells)
+            continue;
+
+        for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+        {
+            TrainerSpell const* tSpell = &itr->second;
+
+            if (!tSpell)
+                continue;
+
+            if (!tSpell->learnedSpell[0] && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+                continue;
+
+            TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+            if (state != TRAINER_SPELL_GREEN)
+                continue;
+
+            if (tSpell->learnedSpell)
+                bot->LearnSpell(tSpell->learnedSpell[0], false);
+            else
+                ai->CastSpell(tSpell->spell, bot);
+        }
+    }
+}
+
+void PlayerbotFactory::InitSpecialSpells()
+{
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotSpellIds.begin(); i != sPlayerbotAIConfig.randomBotSpellIds.end(); ++i)
+    {
+        uint32 spellId = *i;
+        bot->LearnSpell(spellId, false);
+    }
+}
+
+void PlayerbotFactory::InitTalents(uint32 specNo)
+{
+    uint32 classMask = bot->getClassMask();
+
+    map<uint32, vector<TalentEntry const*> > spells;
+    for (uint32 i = 0; i < sTalentStore.GetNumRows(); ++i)
+    {
+        TalentEntry const *talentInfo = sTalentStore.LookupEntry(i);
+        if(!talentInfo)
+            continue;
+
+        TalentTabEntry const *talentTabInfo = sTalentTabStore.LookupEntry( talentInfo->TalentTab );
+        if(!talentTabInfo || talentTabInfo->tabpage != specNo)
+            continue;
+
+        if( (classMask & talentTabInfo->ClassMask) == 0 )
+            continue;
+
+        spells[talentInfo->Row].push_back(talentInfo);
+    }
+
+    uint32 freePoints = bot->GetFreeTalentPoints();
+    for (map<uint32, vector<TalentEntry const*> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        vector<TalentEntry const*> &spells = i->second;
+        if (spells.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "%s: No spells for talent row %d", bot->GetName().c_str(), i->first);
+            continue;
+        }
+
+        int attemptCount = 0;
+        while (!spells.empty() && (int)freePoints - (int)bot->GetFreeTalentPoints() < 5 && attemptCount++ < 3 && bot->GetFreeTalentPoints())
+        {
+            int index = urand(0, spells.size() - 1);
+            TalentEntry const *talentInfo = spells[index];
+            int maxRank = 0;
+            int minRank = min((uint32)MAX_TALENT_RANK, bot->GetFreeTalentPoints());
+            for (int rank = 0; rank < minRank; ++rank)
+            {
+                uint32 spellId = talentInfo->RankID[rank];
+                if (!spellId)
+                    continue;
+
+                maxRank = rank;
+            }
+
+            bot->LearnTalent(talentInfo->TalentID, maxRank);
+			spells.erase(spells.begin() + index);
+        }
+
+        freePoints = bot->GetFreeTalentPoints();
+    }
+
+    for (uint32 i = 0; i < MAX_TALENT_SPECS; ++i)
+    {
+        for (PlayerTalentMap::iterator itr = bot->GetTalentMap(i).begin(); itr != bot->GetTalentMap(i).end(); ++itr)
+        {
+            if (itr->second->state != PLAYERSPELL_REMOVED)
+                itr->second->state = PLAYERSPELL_CHANGED;
+        }
+    }
+}
+
+ObjectGuid PlayerbotFactory::GetRandomBot()
+{
+    vector<ObjectGuid> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            ObjectGuid guid = ObjectGuid(HighGuid::Player, fields[0].GetUInt32());
+            if (!sObjectMgr->GetPlayerByLowGUID(guid))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+    if (guids.empty())
+        return ObjectGuid();
+
+    int index = urand(0, guids.size() - 1);
+    return guids[index];
+}
+
+void PlayerbotFactory::InitQuests()
+{
+    ObjectMgr::QuestMap const& questTemplates = sObjectMgr->GetQuestTemplates();
+    for (ObjectMgr::QuestMap::const_iterator i = questTemplates.begin(); i != questTemplates.end(); ++i)
+    {
+        uint32 questId = i->first;
+        Quest const *quest = i->second;
+
+        if (quest->GetMinLevel() > bot->getLevel() || quest->GetQuestLevel() == -1 ||
+                quest->IsDailyOrWeekly() || quest->IsRepeatable() || quest->IsMonthly())
+            continue;
+
+        bot->SetQuestStatus(questId, QUEST_STATUS_NONE);
+
+        if (!bot->SatisfyQuestClass(quest, false) ||
+                !bot->SatisfyQuestRace(quest, false) ||
+                !bot->SatisfyQuestStatus(quest, false))
+            continue;
+
+        bot->SetQuestStatus(questId, QUEST_STATUS_COMPLETE);
+        bot->RewardQuest(quest, 0, bot, false);
+        ClearInventory();
+    }
+}
+
+void PlayerbotFactory::ClearInventory()
+{
+    DestroyItemsVisitor visitor(bot);
+    IterateItems(&visitor);
+}
+
+void PlayerbotFactory::InitAmmo()
+{
+    if (bot->getClass() != CLASS_HUNTER && bot->getClass() != CLASS_ROGUE && bot->getClass() != CLASS_WARRIOR)
+        return;
+
+    Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED);
+    if (!pItem)
+        return;
+
+    uint32 subClass = 0;
+    switch (pItem->GetTemplate()->SubClass)
+    {
+    case ITEM_SUBCLASS_WEAPON_GUN:
+        subClass = ITEM_SUBCLASS_BULLET;
+        break;
+    case ITEM_SUBCLASS_WEAPON_BOW:
+    case ITEM_SUBCLASS_WEAPON_CROSSBOW:
+        subClass = ITEM_SUBCLASS_ARROW;
+        break;
+    }
+
+    if (!subClass)
+        return;
+
+    QueryResult results = WorldDatabase.PQuery("select max(entry), max(RequiredLevel) from item_template where class = '%u' and subclass = '%u' and RequiredLevel <= '%u'",
+            ITEM_CLASS_PROJECTILE, subClass, bot->getLevel());
+
+    Field* fields = results->Fetch();
+    if (fields)
+    {
+        uint32 entry = fields[0].GetUInt32();
+        for (int i = 0; i < 5; i++)
+        {
+            bot->StoreNewItemInBestSlots(entry, 1000);
+        }
+        bot->SetAmmo(entry);
+    }
+}
+
+void PlayerbotFactory::InitMounts()
+{
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); ++spellId)
+    {
+        SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if (spellInfo->GetDuration() != -1)
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < 50)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    for (uint32 type = 0; type < 2; ++type)
+    {
+        map<int32, vector<uint32> >& spells = allSpells[type];
+        for (map<int32, vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+        {
+            int32 effect = i->first;
+            vector<uint32>& ids = i->second;
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            bot->LearnSpell(ids[index], false);
+        }
+    }
+}
+
+void PlayerbotFactory::InitPotions()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_POTION ||
+            proto->Spells[0].SpellCategory != 4 ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        int botLevel = bot->getLevel();
+        int botReqLevel = proto->RequiredLevel;
+        if (botReqLevel > botLevel || botReqLevel < botLevel - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+        {
+            const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+            if (!spellInfo)
+                continue;
+
+            for (int i = 0 ; i < 3; i++)
+            {
+                if (spellInfo->Effects[i].Effect == SPELL_EFFECT_HEAL || spellInfo->Effects[i].Effect == SPELL_EFFECT_ENERGIZE)
+                {
+                    items[spellInfo->Effects[i].Effect].push_back(itemId);
+                    break;
+                }
+            }
+        }
+    }
+
+    uint32 effects[] = { SPELL_EFFECT_HEAL, SPELL_EFFECT_ENERGIZE };
+    for (int i = 0; i < sizeof(effects) / sizeof(uint32); ++i)
+    {
+        uint32 effect = effects[i];
+        vector<uint32>& ids = items[effect];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+void PlayerbotFactory::InitFood()
+{
+    map<uint32, vector<uint32> > items;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE ||
+            proto->SubClass != ITEM_SUBCLASS_FOOD ||
+            (proto->Spells[0].SpellCategory != 11 && proto->Spells[0].SpellCategory != 59) ||
+            proto->Bonding != NO_BIND)
+            continue;
+
+        int botLevel = bot->getLevel();
+        int botReqLevel = proto->RequiredLevel;
+        if (botReqLevel > botLevel || botReqLevel < botLevel - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        if (proto->Area || proto->Map || proto->RequiredCityRank || proto->RequiredHonorRank)
+            continue;
+
+        items[proto->Spells[0].SpellCategory].push_back(itemId);
+    }
+
+    uint32 categories[] = { 11, 59 };
+    for (int i = 0; i < sizeof(categories) / sizeof(uint32); ++i)
+    {
+        uint32 category = categories[i];
+        vector<uint32>& ids = items[category];
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        bot->StoreNewItemInBestSlots(itemId, urand(1, proto->GetMaxStackSize()));
+   }
+}
+
+
+void PlayerbotFactory::CancelAuras()
+{
+    bot->RemoveAllAuras();
+}
+
+void PlayerbotFactory::InitInventory()
+{
+    InitInventoryTrade();
+    InitInventoryEquip();
+    InitInventorySkill();
+}
+
+void PlayerbotFactory::InitInventorySkill()
+{
+    if (bot->HasSkill(SKILL_MINING)) {
+        StoreItem(2901, 1); // Mining Pick
+    }
+    if (bot->HasSkill(SKILL_JEWELCRAFTING)) {
+        StoreItem(20815, 1); // Jeweler's Kit
+        StoreItem(20824, 1); // Simple Grinder
+    }
+    if (bot->HasSkill(SKILL_BLACKSMITHING) || bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(5956, 1); // Blacksmith Hammer
+    }
+    if (bot->HasSkill(SKILL_ENGINEERING)) {
+        StoreItem(6219, 1); // Arclight Spanner
+    }
+    if (bot->HasSkill(SKILL_ENCHANTING)) {
+        StoreItem(44452, 1); // Runed Titanium Rod
+    }
+    if (bot->HasSkill(SKILL_INSCRIPTION)) {
+        StoreItem(39505, 1); // Virtuoso Inking Set
+    }
+    if (bot->HasSkill(SKILL_SKINNING)) {
+        StoreItem(7005, 1); // Skinning Knife
+    }
+}
+
+Item* PlayerbotFactory::StoreItem(uint32 itemId, uint32 count)
+{
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    ItemPosCountVec sDest;
+    InventoryResult msg = bot->CanStoreNewItem(INVENTORY_SLOT_BAG_0, NULL_SLOT, sDest, itemId, count);
+    if (msg != EQUIP_ERR_OK)
+        return NULL;
+
+    return bot->StoreNewItem(sDest, itemId, true, Item::GenerateItemRandomPropertyId(itemId));
+}
+
+void PlayerbotFactory::InitInventoryTrade()
+{
+    vector<uint32> ids;
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_TRADE_GOODS || proto->Bonding != NO_BIND)
+            continue;
+
+        if (proto->ItemLevel < bot->getLevel())
+            continue;
+
+        int botLevel = bot->getLevel();
+        int botReqLevel = proto->RequiredLevel;
+        if (botReqLevel > botLevel || botReqLevel < botLevel - 10)
+            continue;
+
+        if (proto->RequiredSkill && !bot->HasSkill(proto->RequiredSkill))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    if (ids.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No trade items available for bot %s (%d level)", bot->GetName().c_str(), bot->getLevel());
+        return;
+    }
+
+    uint32 index = urand(0, ids.size() - 1);
+    if (index >= ids.size())
+        return;
+
+    uint32 itemId = ids[index];
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return;
+
+    uint32 count = 1, stacks = 1;
+    switch (proto->Quality)
+    {
+    case ITEM_QUALITY_NORMAL:
+        count = proto->GetMaxStackSize();
+        stacks = urand(1, 7) / auctionbot.GetRarityPriceMultiplier(proto);
+        break;
+    case ITEM_QUALITY_UNCOMMON:
+        stacks = 1;
+        count = urand(1, proto->GetMaxStackSize());
+        break;
+    case ITEM_QUALITY_RARE:
+        stacks = 1;
+        count = urand(1, min(uint32(3), proto->GetMaxStackSize()));
+        break;
+    }
+
+    for (uint32 i = 0; i < stacks; i++)
+        StoreItem(itemId, count);
+}
+
+void PlayerbotFactory::InitInventoryEquip()
+{
+    vector<uint32> ids;
+
+    uint32 desiredQuality = itemQuality;
+    if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomGearLoweringChance && desiredQuality > ITEM_QUALITY_NORMAL) {
+        desiredQuality--;
+    }
+
+    ItemTemplateContainer const* itemTemplateContainer = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplateContainer->begin(); i != itemTemplateContainer->end(); ++i)
+    {
+        ItemTemplate const& itemTemplate = i->second;
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_ARMOR && proto->Class != ITEM_CLASS_WEAPON || (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_WHEN_USE))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_ARMOR && !CanEquipArmor(proto))
+            continue;
+
+        if (proto->Class == ITEM_CLASS_WEAPON && !CanEquipWeapon(proto))
+            continue;
+
+        if (!CanEquipItem(proto, desiredQuality))
+            continue;
+
+        ids.push_back(itemId);
+    }
+
+    int maxCount = urand(0, 3);
+    int count = 0;
+    for (int attempts = 0; attempts < 15; attempts++)
+    {
+        uint32 index = urand(0, ids.size() - 1);
+        if (index >= ids.size())
+            continue;
+
+        uint32 itemId = ids[index];
+        if (StoreItem(itemId, 1) && count++ >= maxCount)
+            break;
+   }
+}
+
+void PlayerbotFactory::InitGlyphs()
+{
+    bot->InitGlyphsForLevel();
+
+    for (uint32 slotIndex = 0; slotIndex < MAX_GLYPH_SLOT_INDEX; ++slotIndex)
+    {
+        bot->SetGlyph(slotIndex, 0);
+    }
+
+    uint32 level = bot->getLevel();
+    uint32 maxSlot = 0;
+    if (level >= 15)
+        maxSlot = 2;
+    if (level >= 30)
+        maxSlot = 3;
+    if (level >= 50)
+        maxSlot = 4;
+    if (level >= 70)
+        maxSlot = 5;
+    if (level >= 80)
+        maxSlot = 6;
+
+    if (!maxSlot)
+        return;
+
+    list<uint32> glyphs;
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Class != ITEM_CLASS_GLYPH)
+            continue;
+
+        if ((proto->AllowableClass & bot->getClassMask()) == 0 || (proto->AllowableRace & bot->getRaceMask()) == 0)
+            continue;
+
+        for (uint32 spell = 0; spell < MAX_ITEM_PROTO_SPELLS; spell++)
+        {
+            uint32 spellId = proto->Spells[spell].SpellId;
+            SpellInfo const *entry = sSpellMgr->GetSpellInfo(spellId);
+            if (!entry)
+                continue;
+
+            for (uint32 effect = 0; effect <= EFFECT_2; ++effect)
+            {
+                if (entry->Effects[effect].Effect != SPELL_EFFECT_APPLY_GLYPH)
+                    continue;
+
+                uint32 glyph = entry->Effects[effect].MiscValue;
+                glyphs.push_back(glyph);
+            }
+        }
+    }
+
+    if (glyphs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s", bot->GetName().c_str());
+        return;
+    }
+
+    set<uint32> chosen;
+    for (uint32 slotIndex = 0; slotIndex < maxSlot; ++slotIndex)
+    {
+        uint32 slot = bot->GetGlyphSlot(slotIndex);
+        GlyphSlotEntry const *gs = sGlyphSlotStore.LookupEntry(slot);
+        if (!gs)
+            continue;
+
+        vector<uint32> ids;
+        for (list<uint32>::iterator i = glyphs.begin(); i != glyphs.end(); ++i)
+        {
+            uint32 id = *i;
+            GlyphPropertiesEntry const *gp = sGlyphPropertiesStore.LookupEntry(id);
+            if (!gp || gp->TypeFlags != gs->TypeFlags)
+                continue;
+
+            ids.push_back(id);
+        }
+
+        int maxCount = urand(0, 3);
+        int count = 0;
+        bool found = false;
+        for (int attempts = 0; attempts < 15; ++attempts)
+        {
+            uint32 index = urand(0, ids.size() - 1);
+            if (index >= ids.size())
+                continue;
+
+            uint32 id = ids[index];
+            if (chosen.find(id) != chosen.end())
+                continue;
+
+            chosen.insert(id);
+
+            bot->SetGlyph(slotIndex, id);
+            found = true;
+            break;
+        }
+        if (!found)
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No glyphs found for bot %s index %d slot %d", bot->GetName().c_str(), slotIndex, slot);
+    }
+}
+
+void PlayerbotFactory::InitGuild()
+{
+    if (bot->GetGuildId())
+        return;
+
+    if (sPlayerbotAIConfig.randomBotGuilds.empty())
+        RandomPlayerbotFactory::CreateRandomGuilds();
+
+    vector<uint32> guilds;
+    for(list<uint32>::iterator i = sPlayerbotAIConfig.randomBotGuilds.begin(); i != sPlayerbotAIConfig.randomBotGuilds.end(); ++i)
+        guilds.push_back(*i);
+
+    if (guilds.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No random guilds available");
+        return;
+    }
+
+    int index = urand(0, guilds.size() - 1);
+    uint32 guildId = guilds[index];
+    Guild* guild = sGuildMgr->GetGuildById(guildId);
+    if (!guild)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Invalid guild %u", guildId);
+        return;
+    }
+
+    if (guild->GetMemberCount() < 10)
+        guild->AddMember(bot->GetGUID(), urand(GR_OFFICER, GR_INITIATE));
+}
diff --git a/src/plugins/playerbot/PlayerbotFactory.h b/src/plugins/playerbot/PlayerbotFactory.h
new file mode 100644
index 0000000..e9535f0
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotFactory.h
@@ -0,0 +1,68 @@
+#pragma once
+
+#include "strategy/actions/InventoryAction.h"
+
+class Player;
+class PlayerbotMgr;
+class ChatHandler;
+
+using namespace std;
+using ai::InventoryAction;
+
+class PlayerbotFactory : public InventoryAction
+{
+public:
+    PlayerbotFactory(Player* bot, uint32 level, uint32 itemQuality = 0) :
+        bot(bot), level(level), itemQuality(itemQuality), InventoryAction(bot->GetPlayerbotAI(), "factory") {}
+
+    static ObjectGuid GetRandomBot();
+    void CleanRandomize();
+    void Randomize();
+    void Refresh();
+
+private:
+    void Randomize(bool incremental);
+    void Prepare();
+    void InitSecondEquipmentSet();
+    void InitEquipment(bool incremental);
+    bool CanEquipItem(ItemTemplate const* proto, uint32 desiredQuality);
+    bool CanEquipUnseenItem(uint8 slot, uint16 &dest, uint32 item);
+    void InitSkills();
+    void InitTradeSkills();
+    void UpdateTradeSkills();
+    void SetRandomSkill(uint16 id);
+    void InitSpells();
+    void ClearSpells();
+    void InitAvailableSpells();
+    void InitSpecialSpells();
+    void InitTalents();
+    void InitTalents(uint32 specNo);
+    void InitQuests();
+    void InitPet();
+    void ClearInventory();
+    void InitAmmo();
+    void InitMounts();
+    void InitPotions();
+    void InitFood();
+    bool CanEquipArmor(ItemTemplate const* proto);
+    bool CanEquipWeapon(ItemTemplate const* proto);
+    void EnchantItem(Item* item);
+    void AddItemStats(uint32 mod, uint8 &sp, uint8 &ap, uint8 &tank);
+    bool CheckItemStats(uint8 sp, uint8 ap, uint8 tank);
+    void CancelAuras();
+    bool IsDesiredReplacement(Item* item);
+    void InitBags();
+    void InitInventory();
+    void InitInventoryTrade();
+    void InitInventoryEquip();
+    void InitInventorySkill();
+    Item* StoreItem(uint32 itemId, uint32 count);
+    void InitGlyphs();
+    void InitGuild();
+
+private:
+    Player* bot;
+    uint32 level;
+    uint32 itemQuality;
+    static uint32 tradeSkills[];
+};
diff --git a/src/plugins/playerbot/PlayerbotMgr.cpp b/src/plugins/playerbot/PlayerbotMgr.cpp
new file mode 100644
index 0000000..945764f
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.cpp
@@ -0,0 +1,472 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "RandomPlayerbotMgr.h"
+
+
+class LoginQueryHolder;
+class CharacterHandler;
+
+PlayerbotHolder::PlayerbotHolder() : PlayerbotAIBase()
+{
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+        sSpellStore.LookupEntry(spellId);
+}
+
+PlayerbotHolder::~PlayerbotHolder()
+{
+    LogoutAllBots();
+}
+
+
+void PlayerbotHolder::UpdateAIInternal(uint32 elapsed)
+{
+}
+
+void PlayerbotHolder::UpdateSessions(uint32 elapsed)
+{
+    for (PlayerBotMap::const_iterator itr = GetPlayerBotsBegin(); itr != GetPlayerBotsEnd(); ++itr)
+    {
+        Player* const bot = itr->second;
+        if (bot->IsBeingTeleported())
+        {
+            bot->GetPlayerbotAI()->HandleTeleportAck();
+        }
+        else if (bot->IsInWorld())
+        {
+            bot->GetSession()->HandleBotPackets();
+        }
+    }
+}
+
+void PlayerbotHolder::LogoutAllBots()
+{
+    while (true)
+    {
+        PlayerBotMap::const_iterator itr = GetPlayerBotsBegin();
+        if (itr == GetPlayerBotsEnd()) break;
+        Player* bot= itr->second;
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
+void PlayerbotHolder::LogoutPlayerBot(uint64 guid)
+{
+    Player* bot = GetPlayerBot(guid);
+    if (bot)
+    {
+        bot->GetPlayerbotAI()->TellMaster("Goodbye!");
+        //bot->SaveToDB();
+
+        WorldSession * botWorldSessionPtr = bot->GetSession();
+        playerBots.erase(guid);    // deletes bot player ptr inside this WorldSession PlayerBotMap
+        botWorldSessionPtr->LogoutPlayer(true); // this will delete the bot Player object and PlayerbotAI object
+        delete botWorldSessionPtr;  // finally delete the bot's WorldSession
+    }
+}
+
+Player* PlayerbotHolder::GetPlayerBot(uint64 playerGuid) const
+{
+    PlayerBotMap::const_iterator it = playerBots.find(playerGuid);
+    return (it == playerBots.end()) ? 0 : it->second;
+}
+
+void PlayerbotHolder::OnBotLogin(Player * const bot)
+{
+	PlayerbotAI* ai = new PlayerbotAI(bot);
+	bot->SetPlayerbotAI(ai);
+	OnBotLoginInternal(bot);
+
+    playerBots[bot->GetGUID()] = bot;
+
+    Player* master = ai->GetMaster();
+    if (master)
+    {
+        ObjectGuid masterGuid = master->GetGUID();
+        if (master->GetGroup() &&
+            ! master->GetGroup()->IsLeader(masterGuid))
+            master->GetGroup()->ChangeLeader(masterGuid);
+    }
+
+    Group *group = bot->GetGroup();
+    if (group)
+    {
+        bool groupValid = false;
+        Group::MemberSlotList const& slots = group->GetMemberSlots();
+        for (Group::MemberSlotList::const_iterator i = slots.begin(); i != slots.end(); ++i)
+        {
+            ObjectGuid member = i->guid;
+            uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(member);
+            if (!sPlayerbotAIConfig.IsInRandomAccountList(account))
+            {
+                groupValid = true;
+                break;
+            }
+        }
+
+        if (!groupValid)
+        {
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+        }
+    }
+
+    ai->ResetStrategies();
+    ai->TellMaster("Hello!");
+}
+
+string PlayerbotHolder::ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId)
+{
+    if (!sPlayerbotAIConfig.enabled || guid.IsEmpty())
+        return "bot system is disabled";
+
+    uint32 botAccount = sObjectMgr->GetPlayerAccountIdByGUID(guid);
+    bool isRandomBot = sRandomPlayerbotMgr.IsRandomBot(guid);
+    bool isRandomAccount = sPlayerbotAIConfig.IsInRandomAccountList(botAccount);
+    bool isMasterAccount = (masterAccountId == botAccount);
+
+    if (isRandomAccount && !isRandomBot && !admin)
+    {
+        Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+        if (bot->GetGuildId() != masterGuildId)
+            return "not in your guild";
+    }
+
+    if (!isRandomAccount && !isMasterAccount && !admin)
+        return "not in your account";
+
+    if (cmd == "add" || cmd == "login")
+    {
+        if (sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player already logged in";
+
+        AddPlayerBot(guid.GetRawValue(), masterAccountId);
+        return "ok";
+    }
+    else if (cmd == "remove" || cmd == "logout" || cmd == "rm")
+    {
+        if (!sObjectMgr->GetPlayerByLowGUID(guid))
+            return "player is offline";
+
+        if (!GetPlayerBot(guid.GetRawValue()))
+            return "not your bot";
+
+        LogoutPlayerBot(guid.GetRawValue());
+        return "ok";
+    }
+
+    if (admin)
+    {
+        Player* bot = GetPlayerBot(guid.GetRawValue());
+        if (!bot)
+            return "bot not found";
+
+        Player* master = bot->GetPlayerbotAI()->GetMaster();
+        if (master)
+        {
+            if (cmd == "init=white" || cmd == "init=common")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_NORMAL);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=green" || cmd == "init=uncommon")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_UNCOMMON);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=blue" || cmd == "init=rare")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_RARE);
+                factory.CleanRandomize();
+                return "ok";
+            }
+            else if (cmd == "init=epic" || cmd == "init=purple")
+            {
+                PlayerbotFactory factory(bot, master->getLevel(), ITEM_QUALITY_EPIC);
+                factory.CleanRandomize();
+                return "ok";
+            }
+        }
+
+        if (cmd == "update")
+        {
+            PlayerbotFactory factory(bot, bot->getLevel());
+            factory.Refresh();
+            return "ok";
+        }
+        else if (cmd == "random")
+        {
+            sRandomPlayerbotMgr.Randomize(bot);
+            return "ok";
+        }
+    }
+
+    return "unknown command";
+}
+
+bool PlayerbotMgr::HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args)
+{
+	if (!sPlayerbotAIConfig.enabled)
+	{
+		handler->PSendSysMessage("|cffff0000Playerbot system is currently disabled!");
+		handler->SetSentErrorMessage(true);
+        return false;
+	}
+
+    WorldSession *m_session = handler->GetSession();
+
+    if (!m_session)
+    {
+        handler->PSendSysMessage("You may only add bots from an active session");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    Player* player = m_session->GetPlayer();
+    PlayerbotMgr* mgr = player->GetPlayerbotMgr();
+    if (!mgr)
+    {
+        handler->PSendSysMessage("you cannot control bots yet");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    list<string> messages = mgr->HandlePlayerbotCommand(args, player);
+    if (messages.empty())
+        return true;
+
+    for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+    {
+        handler->PSendSysMessage(i->c_str());
+    }
+
+    handler->SetSentErrorMessage(true);
+    return false;
+}
+
+list<string> PlayerbotHolder::HandlePlayerbotCommand(char const* args, Player* master)
+{
+    list<string> messages;
+
+    if (!*args)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    char *cmd = strtok ((char*)args, " ");
+    char *charname = strtok (NULL, " ");
+    if (!cmd || !charname)
+    {
+        messages.push_back("usage: add/init/remove PLAYERNAME");
+        return messages;
+    }
+
+    std::string cmdStr = cmd;
+    std::string charnameStr = charname;
+
+    set<string> bots;
+    if (charnameStr == "*" && master)
+    {
+        Group* group = master->GetGroup();
+        if (!group)
+        {
+            messages.push_back("you must be in group");
+            return messages;
+        }
+
+        Group::MemberSlotList slots = group->GetMemberSlots();
+        for (Group::member_citerator i = slots.begin(); i != slots.end(); i++)
+        {
+			ObjectGuid member = i->guid;
+
+			if (member == master->GetGUID())
+				continue;
+
+			string bot;
+			if (sObjectMgr->GetPlayerNameByGUID(member, bot))
+			    bots.insert(bot);
+        }
+    }
+
+    if (charnameStr == "!" && master && master->GetSession()->GetSecurity() > SEC_GAMEMASTER)
+    {
+        for (PlayerBotMap::const_iterator i = GetPlayerBotsBegin(); i != GetPlayerBotsEnd(); ++i)
+        {
+            Player* bot = i->second;
+            if (bot && bot->IsInWorld())
+                bots.insert(bot->GetName());
+        }
+    }
+
+    vector<string> chars = split(charnameStr, ',');
+    for (vector<string>::iterator i = chars.begin(); i != chars.end(); i++)
+    {
+        string s = *i;
+
+        uint32 accountId = GetAccountId(s);
+        if (!accountId)
+        {
+            bots.insert(s);
+            continue;
+        }
+
+        QueryResult results = CharacterDatabase.PQuery(
+            "SELECT name FROM characters WHERE account = '%u'",
+            accountId);
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                string charName = fields[0].GetString();
+                bots.insert(charName);
+            } while (results->NextRow());
+        }
+	}
+
+    for (set<string>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        string bot = *i;
+        ostringstream out;
+        out << cmdStr << ": " << bot << " - ";
+
+        ObjectGuid member = sObjectMgr->GetPlayerGUIDByName(bot);
+        if (!member)
+        {
+            out << "character not found";
+        }
+        else if (master && member != master->GetGUID())
+        {
+            out << ProcessBotCommand(cmdStr, member,
+                    master->GetSession()->GetSecurity() >= SEC_GAMEMASTER,
+                    master->GetSession()->GetAccountId(),
+                    master->GetGuildId());
+        }
+        else if (!master)
+        {
+            out << ProcessBotCommand(cmdStr, member, true, -1, -1);
+        }
+
+        messages.push_back(out.str());
+    }
+
+    return messages;
+}
+
+uint32 PlayerbotHolder::GetAccountId(string name)
+{
+    uint32 accountId = 0;
+
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account WHERE username = '%s'", name.c_str());
+    if(results)
+    {
+        Field* fields = results->Fetch();
+        accountId = fields[0].GetUInt32();
+    }
+
+    return accountId;
+}
+
+
+
+PlayerbotMgr::PlayerbotMgr(Player* const master) : PlayerbotHolder(),  master(master)
+{
+}
+
+PlayerbotMgr::~PlayerbotMgr()
+{
+}
+
+void PlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.reactDelay);
+}
+
+void PlayerbotMgr::HandleCommand(uint32 type, const string& text)
+{
+    Player *master = GetMaster();
+    if (!master)
+        return;
+
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == master)
+            bot->GetPlayerbotAI()->HandleCommand(type, text, *master);
+    }
+}
+
+void PlayerbotMgr::HandleMasterIncomingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterIncomingPacket(packet);
+    }
+
+    switch (packet.GetOpcode())
+    {
+        // if master is logging out, log out all bots
+        case CMSG_LOGOUT_REQUEST:
+        {
+            LogoutAllBots();
+            return;
+        }
+    }
+}
+void PlayerbotMgr::HandleMasterOutgoingPacket(const WorldPacket& packet)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->GetPlayerbotAI()->HandleMasterOutgoingPacket(packet);
+    }
+}
+
+void PlayerbotMgr::SaveToDB()
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->SaveToDB();
+    }
+    for (PlayerBotMap::const_iterator it = sRandomPlayerbotMgr.GetPlayerBotsBegin(); it != sRandomPlayerbotMgr.GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (bot->GetPlayerbotAI()->GetMaster() == GetMaster())
+            bot->SaveToDB();
+    }
+}
+
+void PlayerbotMgr::OnBotLoginInternal(Player * const bot)
+{
+    bot->GetPlayerbotAI()->SetMaster(master);
+    bot->GetPlayerbotAI()->ResetStrategies();
+}
+
diff --git a/src/plugins/playerbot/PlayerbotMgr.h b/src/plugins/playerbot/PlayerbotMgr.h
new file mode 100644
index 0000000..d22074c
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotMgr.h
@@ -0,0 +1,69 @@
+#ifndef _PLAYERBOTMGR_H
+#define _PLAYERBOTMGR_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "../pchdef.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+typedef map<uint64, Player*> PlayerBotMap;
+
+class PlayerbotHolder : public PlayerbotAIBase
+{
+public:
+    PlayerbotHolder();
+    virtual ~PlayerbotHolder();
+
+    void AddPlayerBot(uint64 guid, uint32 masterAccountId);
+    void LogoutPlayerBot(uint64 guid);
+    Player* GetPlayerBot (uint64 guid) const;
+    PlayerBotMap::const_iterator GetPlayerBotsBegin() const { return playerBots.begin(); }
+    PlayerBotMap::const_iterator GetPlayerBotsEnd()   const { return playerBots.end();   }
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+    void UpdateSessions(uint32 elapsed);
+
+    void LogoutAllBots();
+    void OnBotLogin(Player * const bot);
+
+    list<string> HandlePlayerbotCommand(char const* args, Player* master = NULL);
+    string ProcessBotCommand(string cmd, ObjectGuid guid, bool admin, uint32 masterAccountId, uint32 masterGuildId);
+    uint32 GetAccountId(string name);
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot) = 0;
+
+protected:
+    PlayerBotMap playerBots;
+};
+
+class PlayerbotMgr : public PlayerbotHolder
+{
+public:
+    PlayerbotMgr(Player* const master);
+    virtual ~PlayerbotMgr();
+
+    static bool HandlePlayerbotMgrCommand(ChatHandler* handler, char const* args);
+    void HandleMasterIncomingPacket(const WorldPacket& packet);
+    void HandleMasterOutgoingPacket(const WorldPacket& packet);
+    void HandleCommand(uint32 type, const string& text);
+
+    virtual void UpdateAIInternal(uint32 elapsed);
+
+    Player* GetMaster() const { return master; };
+
+    void SaveToDB();
+
+protected:
+    virtual void OnBotLoginInternal(Player * const bot);
+
+private:
+    Player* const master;
+};
+
+#endif
diff --git a/src/plugins/playerbot/PlayerbotSecurity.cpp b/src/plugins/playerbot/PlayerbotSecurity.cpp
new file mode 100644
index 0000000..4752731
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.cpp
@@ -0,0 +1,187 @@
+#include "../pchdef.h"
+#include "PlayerbotMgr.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotAI.h"
+#include "ChatHelper.h"
+
+PlayerbotSecurity::PlayerbotSecurity(Player* const bot) : bot(bot)
+{
+    if (bot)
+        account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+}
+
+PlayerbotSecurityLevel PlayerbotSecurity::LevelFor(Player* from, DenyReason* reason, bool ignoreGroup)
+{
+    if (from->GetSession()->GetSecurity() >= SEC_GAMEMASTER)
+        return PLAYERBOT_SECURITY_ALLOW_ALL;
+
+    if (from->GetPlayerbotAI())
+    {
+        if (reason) *reason = PLAYERBOT_DENY_IS_BOT;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (bot->GetPlayerbotAI()->IsOpposing(from))
+    {
+        if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+        return PLAYERBOT_SECURITY_DENY_ALL;
+    }
+
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account))
+    {
+        if (bot->GetPlayerbotAI()->IsOpposing(from))
+        {
+            if (reason) *reason = PLAYERBOT_DENY_OPPOSING;
+            return PLAYERBOT_SECURITY_DENY_ALL;
+        }
+
+        Group* group = from->GetGroup();
+        if (group)
+        {
+            for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+            {
+                Player* player = gref->GetSource();
+                if (player == bot && !ignoreGroup)
+                    return PLAYERBOT_SECURITY_ALLOW_ALL;
+            }
+        }
+
+        if ((int)bot->getLevel() - (int)from->getLevel() > 5)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_LOW_LEVEL;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->GetMapId() != from->GetMapId() || bot->GetDistance(from) > sPlayerbotAIConfig.whisperDistance)
+        {
+            if (!bot->GetGuildId() || bot->GetGuildId() != from->GetGuildId())
+            {
+                if (reason) *reason = PLAYERBOT_DENY_FAR;
+                return PLAYERBOT_SECURITY_TALK;
+            }
+        }
+
+        int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+        int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+        if (botGS && bot->getLevel() > 15 && (100 * (botGS - fromGS) / botGS) >= 20)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_GEARSCORE;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (bot->isDead())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_DEAD;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        group = bot->GetGroup();
+        if (!group)
+        {
+            if (reason) *reason = PLAYERBOT_DENY_INVITE;
+            return PLAYERBOT_SECURITY_INVITE;
+        }
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* player = gref->GetSource();
+            if (player == from)
+                return PLAYERBOT_SECURITY_ALLOW_ALL;
+        }
+
+        if (group->IsFull())
+        {
+            if (reason) *reason = PLAYERBOT_DENY_FULL_GROUP;
+            return PLAYERBOT_SECURITY_TALK;
+        }
+
+        if (reason) *reason = PLAYERBOT_DENY_INVITE;
+        return PLAYERBOT_SECURITY_INVITE;
+    }
+
+    return PLAYERBOT_SECURITY_ALLOW_ALL;
+}
+
+bool PlayerbotSecurity::CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup)
+{
+    DenyReason reason = PLAYERBOT_DENY_NONE;
+    PlayerbotSecurityLevel realLevel = LevelFor(from, &reason, ignoreGroup);
+    if (realLevel >= level)
+        return true;
+
+    if (silent || from->GetPlayerbotAI())
+        return false;
+
+    Player* master = bot->GetPlayerbotAI()->GetMaster();
+    if (master && bot->GetPlayerbotAI() && bot->GetPlayerbotAI()->IsOpposing(master) && master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+        return false;
+
+    ostringstream out;
+    switch (realLevel)
+    {
+    case PLAYERBOT_SECURITY_DENY_ALL:
+        out << "I'm kind of busy now";
+        break;
+    case PLAYERBOT_SECURITY_TALK:
+        switch (reason)
+        {
+        case PLAYERBOT_DENY_NONE:
+            out << "I'll do it later";
+            break;
+        case PLAYERBOT_DENY_LOW_LEVEL:
+            out << "You are too low level: |cffff0000" << (uint32)from->getLevel() << "|cffffffff/|cff00ff00" << (uint32)bot->getLevel();
+            break;
+        case PLAYERBOT_DENY_GEARSCORE:
+            {
+                int botGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(bot, false, false);
+                int fromGS = (int)bot->GetPlayerbotAI()->GetEquipGearScore(from, false, false);
+                out << "Your gearscore is too low: |cffff0000" << fromGS << "|cffffffff/|cff00ff00" << botGS;
+            }
+            break;
+        case PLAYERBOT_DENY_NOT_YOURS:
+            out << "I have a master already";
+            break;
+        case PLAYERBOT_DENY_IS_BOT:
+            out << "You are a bot";
+            break;
+        case PLAYERBOT_DENY_OPPOSING:
+            out << "You are the enemy";
+            break;
+        case PLAYERBOT_DENY_DEAD:
+            out << "I'm dead. Will do it later";
+            break;
+        case PLAYERBOT_DENY_INVITE:
+            out << "Invite me to your group first";
+            break;
+        case PLAYERBOT_DENY_FAR:
+            {
+                out << "I am too far away";
+
+                uint32 area = bot->GetAreaId();
+                if (area)
+                {
+                    const AreaTableEntry* entry = sAreaStore.LookupEntry(area);
+                    if (entry)
+                    {
+                        out << " |cffffffff(|cffff0000" << entry->area_name[0] << "|cffffffff)";
+                    }
+                }
+            }
+            break;
+        case PLAYERBOT_DENY_FULL_GROUP:
+            out << "I am in a full group. Will do it later";
+            break;
+        default:
+            out << "I can't do that";
+            break;
+        }
+        break;
+    case PLAYERBOT_SECURITY_INVITE:
+        out << "Invite me to your group first";
+        break;
+    }
+
+	bot->Whisper(out.str(), LANG_UNIVERSAL, from);
+    return false;
+}
diff --git a/src/plugins/playerbot/PlayerbotSecurity.h b/src/plugins/playerbot/PlayerbotSecurity.h
new file mode 100644
index 0000000..5349555
--- /dev/null
+++ b/src/plugins/playerbot/PlayerbotSecurity.h
@@ -0,0 +1,42 @@
+#ifndef _PlayerbotSecurity_H
+#define _PlayerbotSecurity_H
+
+using namespace std;
+
+enum PlayerbotSecurityLevel
+{
+    PLAYERBOT_SECURITY_DENY_ALL = 0,
+    PLAYERBOT_SECURITY_TALK = 1,
+    PLAYERBOT_SECURITY_INVITE = 2,
+    PLAYERBOT_SECURITY_ALLOW_ALL = 3
+};
+
+enum DenyReason
+{
+    PLAYERBOT_DENY_NONE,
+    PLAYERBOT_DENY_LOW_LEVEL,
+    PLAYERBOT_DENY_GEARSCORE,
+    PLAYERBOT_DENY_NOT_YOURS,
+    PLAYERBOT_DENY_IS_BOT,
+    PLAYERBOT_DENY_OPPOSING,
+    PLAYERBOT_DENY_DEAD,
+    PLAYERBOT_DENY_FAR,
+    PLAYERBOT_DENY_INVITE,
+    PLAYERBOT_DENY_FULL_GROUP
+};
+
+class PlayerbotSecurity
+{
+    public:
+        PlayerbotSecurity(Player* const bot);
+
+	public:
+        PlayerbotSecurityLevel LevelFor(Player* from, DenyReason* reason = NULL, bool ignoreGroup = false);
+        bool CheckLevelFor(PlayerbotSecurityLevel level, bool silent, Player* from, bool ignoreGroup = false);
+
+    private:
+        Player* const bot;
+        uint32 account;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomItemMgr.cpp b/src/plugins/playerbot/RandomItemMgr.cpp
new file mode 100644
index 0000000..bad4cc0
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.cpp
@@ -0,0 +1,154 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "RandomItemMgr.h"
+
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+
+#include "../../plugins/ahbot/AhBotConfig.h"
+
+char * strstri (const char* str1, const char* str2);
+
+class RandomItemGuildTaskPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_UNCOMMON)
+            return false;
+
+        if ((proto->Class == ITEM_CLASS_ARMOR || proto->Class == ITEM_CLASS_WEAPON) && proto->Quality >= ITEM_QUALITY_RARE)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS || proto->Class == ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        return false;
+    }
+};
+
+class RandomItemGuildTaskRewardPredicate : public RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto)
+    {
+        if (proto->Bonding == BIND_WHEN_PICKED_UP ||
+                proto->Bonding == BIND_QUEST_ITEM ||
+                proto->Bonding == BIND_WHEN_USE)
+            return false;
+
+        if (proto->Quality < ITEM_QUALITY_RARE)
+            return false;
+
+        if (proto->Class == ITEM_CLASS_QUEST)
+            return false;
+
+        return true;
+    }
+};
+
+RandomItemMgr::RandomItemMgr()
+{
+    predicates[RANDOM_ITEM_GUILD_TASK] = new RandomItemGuildTaskPredicate();
+    predicates[RANDOM_ITEM_GUILD_TASK_REWARD] = new RandomItemGuildTaskRewardPredicate();
+}
+
+RandomItemMgr::~RandomItemMgr()
+{
+    for (map<RandomItemType, RandomItemPredicate*>::iterator i = predicates.begin(); i != predicates.end(); ++i)
+        delete i->second;
+
+    predicates.clear();
+}
+
+bool RandomItemMgr::HandleConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!*args)
+    {
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "Usage: rnditem");
+        return false;
+    }
+
+    return false;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList &list = cache[type];
+    if (list.empty())
+        list = cache[type] = Query(type);
+
+    RandomItemList result;
+    for (RandomItemList::iterator i = list.begin(); i != list.end(); ++i)
+    {
+        uint32 itemId = *i;
+        ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId);
+        if (!proto)
+            continue;
+
+        if (predicate && !predicate->Apply(proto))
+            continue;
+
+        result.push_back(itemId);
+    }
+
+    return result;
+}
+
+RandomItemList RandomItemMgr::Query(RandomItemType type)
+{
+    RandomItemList items;
+
+    ItemTemplateContainer const* itemTemplates = sObjectMgr->GetItemTemplateStore();
+    for (ItemTemplateContainer::const_iterator i = itemTemplates->begin(); i != itemTemplates->end(); ++i)
+    {
+        uint32 itemId = i->first;
+        ItemTemplate const* proto = &i->second;
+        if (!proto)
+            continue;
+
+        if (proto->Duration & 0x80000000)
+            continue;
+
+        if (sAhBotConfig.ignoreItemIds.find(proto->ItemId) != sAhBotConfig.ignoreItemIds.end())
+            continue;
+
+        if (strstri(proto->Name1.c_str(), "qa") || strstri(proto->Name1.c_str(), "test") || strstri(proto->Name1.c_str(), "deprecated"))
+            continue;
+
+        if ((proto->RequiredLevel && proto->RequiredLevel > sAhBotConfig.maxRequiredLevel) || proto->ItemLevel > sAhBotConfig.maxItemLevel)
+            continue;
+
+        if (predicates[type] && !predicates[type]->Apply(proto))
+            continue;
+
+        if (!auctionbot.GetSellPrice(proto))
+            continue;
+
+        items.push_back(itemId);
+    }
+
+    if (items.empty())
+        sLog->outMessage("gtask", LOG_LEVEL_ERROR, "no items available for random item query %u", type);
+
+    return items;
+}
+
+uint32 RandomItemMgr::GetRandomItem(RandomItemType type, RandomItemPredicate* predicate)
+{
+    RandomItemList const& list = Query(type, predicate);
+    if (list.empty())
+        return 0;
+
+    uint32 index = urand(0, list.size() - 1);
+    uint32 itemId = list[index];
+
+    return itemId;
+}
diff --git a/src/plugins/playerbot/RandomItemMgr.h b/src/plugins/playerbot/RandomItemMgr.h
new file mode 100644
index 0000000..a0f8149
--- /dev/null
+++ b/src/plugins/playerbot/RandomItemMgr.h
@@ -0,0 +1,50 @@
+#ifndef _RandomItemMgr_H
+#define _RandomItemMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+using namespace std;
+
+enum RandomItemType
+{
+    RANDOM_ITEM_GUILD_TASK,
+    RANDOM_ITEM_GUILD_TASK_REWARD
+};
+
+class RandomItemPredicate
+{
+public:
+    virtual bool Apply(ItemTemplate const* proto) = 0;
+};
+
+typedef vector<uint32> RandomItemList;
+typedef map<RandomItemType, RandomItemList> RandomItemCache;
+
+class RandomItemMgr
+{
+    public:
+        RandomItemMgr();
+        virtual ~RandomItemMgr();
+        static RandomItemMgr& instance()
+        {
+            static RandomItemMgr instance;
+            return instance;
+        }
+
+	public:
+        static bool HandleConsoleCommand(ChatHandler* handler, char const* args);
+        RandomItemList Query(RandomItemType type, RandomItemPredicate* predicate);
+        uint32 GetRandomItem(RandomItemType type, RandomItemPredicate* predicate = NULL);
+
+    private:
+        RandomItemList Query(RandomItemType type);
+
+    private:
+        RandomItemCache cache;
+        map<RandomItemType, RandomItemPredicate*> predicates;
+};
+
+#define sRandomItemMgr RandomItemMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.cpp b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
new file mode 100644
index 0000000..d083416
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.cpp
@@ -0,0 +1,386 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "../../server/game/Entities/Player/Player.h"
+#include "../../server/game/Guilds/Guild.h"
+#include "../../server/game/Guilds/GuildMgr.h"
+#include "RandomPlayerbotFactory.h"
+
+map<uint8, vector<uint8> > RandomPlayerbotFactory::availableRaces;
+
+RandomPlayerbotFactory::RandomPlayerbotFactory(uint32 accountId) : accountId(accountId)
+{
+    availableRaces[CLASS_WARRIOR].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DWARF);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_ORC);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TAUREN);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_TROLL);
+    availableRaces[CLASS_WARRIOR].push_back(RACE_DRAENEI);
+
+    availableRaces[CLASS_PALADIN].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DWARF);
+    availableRaces[CLASS_PALADIN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PALADIN].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_ROGUE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_ROGUE].push_back(RACE_DWARF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_ROGUE].push_back(RACE_GNOME);
+    availableRaces[CLASS_ROGUE].push_back(RACE_ORC);
+    availableRaces[CLASS_ROGUE].push_back(RACE_TROLL);
+    availableRaces[CLASS_ROGUE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_PRIEST].push_back(RACE_HUMAN);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DWARF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_PRIEST].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_PRIEST].push_back(RACE_TROLL);
+    availableRaces[CLASS_PRIEST].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_PRIEST].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_MAGE].push_back(RACE_HUMAN);
+    availableRaces[CLASS_MAGE].push_back(RACE_GNOME);
+    availableRaces[CLASS_MAGE].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_MAGE].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_MAGE].push_back(RACE_TROLL);
+    availableRaces[CLASS_MAGE].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_WARLOCK].push_back(RACE_HUMAN);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_GNOME);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_UNDEAD_PLAYER);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_ORC);
+    availableRaces[CLASS_WARLOCK].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_SHAMAN].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_ORC);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TAUREN);
+    availableRaces[CLASS_SHAMAN].push_back(RACE_TROLL);
+
+    availableRaces[CLASS_HUNTER].push_back(RACE_DWARF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_HUNTER].push_back(RACE_DRAENEI);
+    availableRaces[CLASS_HUNTER].push_back(RACE_ORC);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TAUREN);
+    availableRaces[CLASS_HUNTER].push_back(RACE_TROLL);
+    availableRaces[CLASS_HUNTER].push_back(RACE_BLOODELF);
+
+    availableRaces[CLASS_DRUID].push_back(RACE_NIGHTELF);
+    availableRaces[CLASS_DRUID].push_back(RACE_TAUREN);
+}
+
+typedef std::multimap<uint32, CharSectionsEntry const*> CharSectionsMap;
+extern CharSectionsMap sCharSectionMap;
+CharSectionsEntry const* GetRandomCharSection(uint8 race, CharSectionType genType, uint8 gender, uint8 color = 255)
+{
+    vector<CharSectionsEntry const*> charSections;
+    std::pair<CharSectionsMap::const_iterator, CharSectionsMap::const_iterator> eqr = sCharSectionMap.equal_range(uint32(genType) | uint32(gender << 8) | uint32(race << 16));
+    for (CharSectionsMap::const_iterator itr = eqr.first; itr != eqr.second; ++itr)
+    {
+        CharSectionsEntry const* charSection = itr->second;
+        if ((charSection->Flags & SECTION_FLAG_PLAYER) && !(charSection->Flags & SECTION_FLAG_DEATH_KNIGHT)
+                && (charSection->Color == color || color == 255))
+        {
+            charSections.push_back(itr->second);
+        }
+    }
+    if (charSections.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "No match for race=%u gender=%u color=%u type=%u",
+                race, gender, color, genType);
+        return NULL;
+    }
+
+    uint32 charSectionIndex = urand(0, charSections.size() - 1);
+    return charSections[charSectionIndex];
+}
+
+bool RandomPlayerbotFactory::CreateRandomBot(uint8 cls)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Creating new random bot for class %d", cls);
+
+    uint8 gender = rand() % 2 ? GENDER_MALE : GENDER_FEMALE;
+
+    uint8 race = availableRaces[cls][urand(0, availableRaces[cls].size() - 1)];
+    string name = CreateRandomBotName();
+    if (name.empty())
+        return false;
+
+    CharSectionsEntry const* skin = GetRandomCharSection(race, SECTION_TYPE_SKIN, gender);
+    CharSectionsEntry const* face = GetRandomCharSection(race, SECTION_TYPE_FACE, gender, skin->Color);
+    CharSectionsEntry const* hair = GetRandomCharSection(race, SECTION_TYPE_HAIR, gender);
+    CharSectionsEntry const* facialHair = GetRandomCharSection(race, SECTION_TYPE_FACIAL_HAIR, gender, hair->Color);
+    uint8 outfitId = 0;
+
+    std::string accountName;
+    AccountMgr::GetName(accountId, accountName);
+	WorldSession* session = new WorldSession(accountId, std::move(accountName), NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+    if (!session)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Couldn't create session for random bot account %d", accountId);
+        delete session;
+        return false;
+    }
+
+    Player *player = new Player(session);
+
+    CharacterCreateInfo cci;
+    cci.Name = name;
+    cci.Race = race;
+    cci.Class = cls;
+    cci.Gender = gender;
+    cci.Skin = skin->Color;
+    cci.Face = face->Type;
+    cci.HairStyle = hair->Type;
+    cci.HairColor = hair->Color;
+    cci.FacialHair = facialHair ? facialHair->Type : 0;
+    cci.OutfitId = outfitId;
+
+    if (!player->Create(sObjectMgr->GetGenerator<HighGuid::Player>().Generate(), &cci))
+    {
+        player->DeleteFromDB(player->GetGUID(), accountId, true, true);
+        delete session;
+        delete player;
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Unable to create random bot for account %d - name: \"%s\"; race: %u; class: %u",
+                accountId, name.c_str(), race, cls);
+        return false;
+    }
+
+    player->setCinematic(2);
+    player->SetAtLoginFlag(AT_LOGIN_NONE);
+    player->SaveToDB(true);
+
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot created for account %d - name: \"%s\"; race: %u; class: %u",
+            accountId, name.c_str(), race, cls);
+
+    return true;
+}
+
+string RandomPlayerbotFactory::CreateRandomBotName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_names n "
+            "LEFT OUTER JOIN characters e ON e.name = n.name "
+            "WHERE e.guid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random bots");
+        return "";
+    }
+
+	fields = result->Fetch();
+    return fields[0].GetString();
+}
+
+
+void RandomPlayerbotFactory::CreateRandomBots()
+{
+    if (sPlayerbotAIConfig.deleteRandomBotAccounts)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot accounts...");
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                sAccountMgr->DeleteAccount(fields[0].GetUInt32());
+            } while (results->NextRow());
+        }
+
+        CharacterDatabase.Execute("DELETE FROM ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot accounts deleted");
+    }
+
+    int randBotAC = sPlayerbotAIConfig.randomBotAccountCount;
+    for (int accountNumber = 0; accountNumber < randBotAC; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (results)
+        {
+            continue;
+        }
+
+        string password = "";
+        for (int i = 0; i < 10; i++)
+        {
+            password += (char)urand('!', 'z');
+        }
+        sAccountMgr->CreateAccount(accountName, password, "playerbot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Account %s created for random bots", accountName.c_str());
+    }
+
+    LoginDatabase.PExecute("UPDATE account SET expansion = '%u' where username like '%s%%'", 2, sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+
+    int totalRandomBotChars = 0;
+    for (int accountNumber = 0; accountNumber < randBotAC; ++accountNumber)
+    {
+        ostringstream out; out << sPlayerbotAIConfig.randomBotAccountPrefix << accountNumber;
+        string accountName = out.str();
+
+        QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username = '%s'", accountName.c_str());
+        if (!results)
+            continue;
+
+        Field* fields = results->Fetch();
+        uint32 accountId = fields[0].GetUInt32();
+
+        sPlayerbotAIConfig.randomBotAccounts.push_back(accountId);
+
+        int count = sAccountMgr->GetCharactersCount(accountId);
+        if (count >= 10)
+        {
+            totalRandomBotChars += count;
+            continue;
+        }
+
+        RandomPlayerbotFactory factory(accountId);
+        for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+        {
+            if (cls != 10 && cls != CLASS_DEATH_KNIGHT)
+                factory.CreateRandomBot(cls);
+        }
+
+        totalRandomBotChars += sAccountMgr->GetCharactersCount(accountId);
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot accounts with %d characters available", sPlayerbotAIConfig.randomBotAccounts.size(), totalRandomBotChars);
+}
+
+
+void RandomPlayerbotFactory::CreateRandomGuilds()
+{
+    vector<uint32> randomBots;
+    QueryResult results = LoginDatabase.PQuery("SELECT id FROM account where username like '%s%%'", sPlayerbotAIConfig.randomBotAccountPrefix.c_str());
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 accountId = fields[0].GetUInt32();
+
+            QueryResult results2 = CharacterDatabase.PQuery("SELECT guid FROM characters where account  = '%u'", accountId);
+            if (results2)
+            {
+                do
+                {
+                    Field* fields = results2->Fetch();
+                    uint32 guid = fields[0].GetUInt32();
+                    randomBots.push_back(guid);
+                } while (results2->NextRow());
+            }
+
+        } while (results->NextRow());
+    }
+
+    if (sPlayerbotAIConfig.deleteRandomBotGuilds)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Deleting random bot guilds...");
+        for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+        {
+            ObjectGuid leader(HighGuid::Player, *i);
+            Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+            if (guild) guild->Disband();
+        }
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bot guilds deleted");
+    }
+
+    int guildNumber = 0;
+    vector<ObjectGuid> availableLeaders;
+    for (vector<uint32>::iterator i = randomBots.begin(); i != randomBots.end(); ++i)
+    {
+        ObjectGuid leader(HighGuid::Player, *i);
+        Guild* guild = sGuildMgr->GetGuildByLeader(leader);
+        if (guild)
+        {
+            ++guildNumber;
+            sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+        }
+        else
+        {
+            Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+            if (player)
+                availableLeaders.push_back(leader);
+        }
+    }
+
+    int randBotGC = sPlayerbotAIConfig.randomBotGuildCount;
+    for (; guildNumber < randBotGC; ++guildNumber)
+    {
+        string guildName = CreateRandomGuildName();
+        if (guildName.empty())
+            break;
+
+        if (availableLeaders.empty())
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No leaders for random guilds available");
+            break;
+        }
+
+        int index = urand(0, availableLeaders.size() - 1);
+        ObjectGuid leader = availableLeaders[index];
+        Player* player = sObjectMgr->GetPlayerByLowGUID(leader);
+        if (!player)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot find player for leader %u", leader);
+            break;
+        }
+
+        Guild* guild = new Guild();
+        if (!guild->Create(player, guildName))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Error creating guild %s", guildName.c_str());
+            break;
+        }
+
+        sGuildMgr->AddGuild(guild);
+        sPlayerbotAIConfig.randomBotGuilds.push_back(guild->GetId());
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d random bot guilds available", guildNumber);
+}
+
+string RandomPlayerbotFactory::CreateRandomGuildName()
+{
+    QueryResult result = CharacterDatabase.Query("SELECT MAX(name_id) FROM ai_playerbot_guild_names");
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    Field *fields = result->Fetch();
+    uint32 maxId = fields[0].GetUInt32();
+
+    uint32 id = urand(0, maxId);
+    result = CharacterDatabase.PQuery("SELECT n.name FROM ai_playerbot_guild_names n "
+            "LEFT OUTER JOIN guild e ON e.name = n.name "
+            "WHERE e.guildid IS NULL AND n.name_id >= '%u' LIMIT 1", id);
+    if (!result)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "No more names left for random guilds");
+        return "";
+    }
+
+    fields = result->Fetch();
+    return fields[0].GetString();
+}
+
diff --git a/src/plugins/playerbot/RandomPlayerbotFactory.h b/src/plugins/playerbot/RandomPlayerbotFactory.h
new file mode 100644
index 0000000..76f4d08
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotFactory.h
@@ -0,0 +1,35 @@
+#ifndef _RandomPlayerbotFactory_H
+#define _RandomPlayerbotFactory_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotFactory
+{
+    public:
+        RandomPlayerbotFactory(uint32 accountId);
+		virtual ~RandomPlayerbotFactory() {}
+
+	public:
+        bool CreateRandomBot(uint8 cls);
+        static void CreateRandomBots();
+        static void CreateRandomGuilds();
+
+	private:
+        string CreateRandomBotName();
+        static string CreateRandomGuildName();
+
+    private:
+        uint32 accountId;
+        static map<uint8, vector<uint8> > availableRaces;
+};
+
+#endif
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.cpp b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
new file mode 100644
index 0000000..1ebf978
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.cpp
@@ -0,0 +1,912 @@
+#include "../pchdef.h"
+#include "playerbot.h"
+#include "PlayerbotAIConfig.h"
+#include "PlayerbotFactory.h"
+#include "../../server/database/Database/DatabaseEnv.h"
+#include "PlayerbotAI.h"
+#include "AiFactory.h"
+#include "../../game/Maps/MapManager.h"
+#include "PlayerbotCommandServer.h"
+#include "GuildTaskMgr.h"
+
+RandomPlayerbotMgr::RandomPlayerbotMgr() : PlayerbotHolder(), processTicks(0)
+{
+    sPlayerbotCommandServer.Start();
+}
+
+RandomPlayerbotMgr::~RandomPlayerbotMgr()
+{
+}
+
+void RandomPlayerbotMgr::UpdateAIInternal(uint32 elapsed)
+{
+    SetNextCheckDelay(sPlayerbotAIConfig.randomBotUpdateInterval * 1000);
+
+    if (!sPlayerbotAIConfig.randomBotAutologin || !sPlayerbotAIConfig.enabled)
+        return;
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Processing random bots...");
+
+    int maxAllowedBotCount = GetEventValue(0, "bot_count");
+    if (!maxAllowedBotCount)
+    {
+        maxAllowedBotCount = urand(sPlayerbotAIConfig.minRandomBots, sPlayerbotAIConfig.maxRandomBots);
+        SetEventValue(0, "bot_count", maxAllowedBotCount,
+                urand(sPlayerbotAIConfig.randomBotCountChangeMinInterval, sPlayerbotAIConfig.randomBotCountChangeMaxInterval));
+    }
+
+    list<uint32> bots = GetBots();
+    int botCount = bots.size();
+    int allianceNewBots = 0, hordeNewBots = 0;
+    int randomBotsPerInterval = (int)urand(sPlayerbotAIConfig.minRandomBotsPerInterval, sPlayerbotAIConfig.maxRandomBotsPerInterval);
+    if (!processTicks)
+    {
+        if (sPlayerbotAIConfig.randomBotLoginAtStartup)
+            randomBotsPerInterval = bots.size();
+    }
+
+    while (botCount++ < maxAllowedBotCount)
+    {
+        bool alliance = botCount % 2;
+        uint32 bot = AddRandomBot(alliance);
+        if (bot)
+        {
+            if (alliance)
+                allianceNewBots++;
+            else
+                hordeNewBots++;
+
+            bots.push_back(bot);
+        }
+        else
+            break;
+    }
+
+    int botProcessed = 0;
+    for (list<uint32>::iterator i = bots.begin(); i != bots.end(); ++i)
+    {
+        uint32 bot = *i;
+        if (ProcessBot(bot))
+            botProcessed++;
+
+        if (botProcessed >= randomBotsPerInterval)
+            break;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d bots processed. %d alliance and %d horde bots added. %d bots online. Next check in %d seconds",
+            botProcessed, allianceNewBots, hordeNewBots, playerBots.size(), sPlayerbotAIConfig.randomBotUpdateInterval);
+
+    if (processTicks++ == 1)
+        PrintStats();
+}
+
+uint32 RandomPlayerbotMgr::AddRandomBot(bool alliance)
+{
+    vector<uint32> bots = GetFreeBots(alliance);
+    if (bots.size() == 0)
+        return 0;
+
+    int index = urand(0, bots.size() - 1);
+    uint32 bot = bots[index];
+    SetEventValue(bot, "add", 1, urand(sPlayerbotAIConfig.minRandomBotInWorldTime, sPlayerbotAIConfig.maxRandomBotInWorldTime));
+    uint32 randomTime = 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3);
+    ScheduleRandomize(bot, randomTime);
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Random bot %d added", bot);
+    return bot;
+}
+
+void RandomPlayerbotMgr::ScheduleRandomize(uint32 bot, uint32 time)
+{
+    SetEventValue(bot, "randomize", 1, time);
+    SetEventValue(bot, "logout", 1, time + 30 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+void RandomPlayerbotMgr::ScheduleTeleport(uint32 bot)
+{
+    SetEventValue(bot, "teleport", 1, 60 + urand(sPlayerbotAIConfig.randomBotUpdateInterval, sPlayerbotAIConfig.randomBotUpdateInterval * 3));
+}
+
+bool RandomPlayerbotMgr::ProcessBot(uint32 bot)
+{
+    uint32 isValid = GetEventValue(bot, "add");
+    if (!isValid)
+    {
+		Player* player = GetPlayerBot(bot);
+		if (!player || !player->GetGroup())
+		{
+			sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d expired", bot);
+			SetEventValue(bot, "add", 0, 0);
+		}
+        return true;
+    }
+
+    if (!GetPlayerBot(bot))
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Bot %d logged in", bot);
+        AddPlayerBot(bot, 0);
+        if (!GetEventValue(bot, "online"))
+        {
+            SetEventValue(bot, "online", 1, sPlayerbotAIConfig.minRandomBotInWorldTime);
+        }
+        return true;
+    }
+
+    Player* player = GetPlayerBot(bot);
+    if (!player)
+        return false;
+
+    PlayerbotAI* ai = player->GetPlayerbotAI();
+    if (!ai)
+        return false;
+
+    if (player->GetGroup())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Skipping bot %d as it is in group", bot);
+        return false;
+    }
+
+    if (player->isDead())
+    {
+        if (!GetEventValue(bot, "dead"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Setting dead flag for bot %d", bot);
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotReviveTime, sPlayerbotAIConfig.maxRandomBotReviveTime);
+            SetEventValue(bot, "dead", 1, randomTime);
+            SetEventValue(bot, "revive", 1, randomTime - 60);
+            return false;
+        }
+
+        if (!GetEventValue(bot, "revive"))
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Reviving dead bot %d", bot);
+            SetEventValue(bot, "dead", 0, 0);
+            SetEventValue(bot, "revive", 0, 0);
+            RandomTeleport(player, player->GetMapId(), player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+            return true;
+        }
+
+        return false;
+    }
+
+    if (player->GetGuild() && player->GetGuild()->GetLeaderGUID() == player->GetGUID())
+    {
+        for (vector<Player*>::iterator i = players.begin(); i != players.end(); ++i)
+            sGuildTaskMgr.Update(*i, player);
+    }
+
+    uint32 randomize = GetEventValue(bot, "randomize");
+    if (!randomize)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bot %d", bot);
+        Randomize(player);
+        uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+        ScheduleRandomize(bot, randomTime);
+        return true;
+    }
+
+    uint32 logout = GetEventValue(bot, "logout");
+    if (!logout)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Logging out bot %d", bot);
+        LogoutPlayerBot(bot);
+        SetEventValue(bot, "logout", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    uint32 teleport = GetEventValue(bot, "teleport");
+    if (!teleport)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %d", bot);
+        RandomTeleportForLevel(ai->GetBot());
+        SetEventValue(bot, "teleport", 1, sPlayerbotAIConfig.maxRandomBotInWorldTime);
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, vector<WorldLocation> &locs)
+{
+    if (bot->IsBeingTeleported())
+        return;
+
+    if (locs.empty())
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+        return;
+    }
+
+    for (int attemtps = 0; attemtps < 10; ++attemtps)
+    {
+        int index = urand(0, locs.size() - 1);
+        WorldLocation loc = locs[index];
+        float x = loc.m_positionX + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float y = loc.m_positionY + urand(0, sPlayerbotAIConfig.grindDistance) - sPlayerbotAIConfig.grindDistance / 2;
+        float z = loc.m_positionZ;
+
+        Map* map = sMapMgr->FindMap(loc.GetMapId(), 0);
+        if (!map)
+            continue;
+
+        if (!map->IsOutdoors(x, y, z) ||
+                map->IsInWater(x, y, z))
+            continue;
+
+        uint32 areaId = map->GetAreaId(x, y, z);
+        if (!areaId)
+            continue;
+
+        AreaTableEntry const* area = sAreaStore.LookupEntry(areaId);
+        if (!area)
+            continue;
+
+        float ground = map->GetHeight(x, y, z + 0.5f);
+        if (ground <= INVALID_HEIGHT)
+            continue;
+
+        z = 0.05f + ground;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random teleporting bot %s to %s %f,%f,%f (1/%u locations)",
+                bot->GetName().c_str(), area->area_name[0], x, y, z, locs.size());
+
+        bot->GetMotionMaster()->Clear();
+        bot->TeleportTo(loc.GetMapId(), x, y, z, 0);
+        return;
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Cannot teleport bot %s - no locations available", bot->GetName().c_str());
+}
+
+void RandomPlayerbotMgr::RandomTeleportForLevel(Player* bot)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing location to random teleporting bot %s for level %u", bot->GetName().c_str(), bot->getLevel());
+
+    if (locsPerLevelCache[bot->getLevel()].empty()) {
+        QueryResult results = WorldDatabase.PQuery("select map, position_x, position_y, position_z "
+            "from (select map, position_x, position_y, position_z, avg(t.maxlevel), avg(t.minlevel), "
+            "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+            "from creature c inner join creature_template t on c.id = t.entry group by t.entry) q "
+            "where delta >= 0 and delta <= %u and map in (%s) and not exists ( "
+            "select map, position_x, position_y, position_z from "
+            "("
+            "select map, c.position_x, c.position_y, c.position_z, avg(t.maxlevel), avg(t.minlevel), "
+            "%u - (avg(t.maxlevel) + avg(t.minlevel)) / 2 delta "
+            "from creature c "
+            "inner join creature_template t on c.id = t.entry group by t.entry "
+            ") q1 "
+            "where delta > %u and q1.map = q.map "
+            "and sqrt("
+            "(q1.position_x - q.position_x)*(q1.position_x - q.position_x) +"
+            "(q1.position_y - q.position_y)*(q1.position_y - q.position_y) +"
+            "(q1.position_z - q.position_z)*(q1.position_z - q.position_z)"
+            ") < %u)",
+            bot->getLevel(),
+            sPlayerbotAIConfig.randomBotTeleLevel,
+            sPlayerbotAIConfig.randomBotMapsAsString.c_str(),
+            bot->getLevel(),
+            sPlayerbotAIConfig.randomBotTeleLevel,
+            (uint32)sPlayerbotAIConfig.sightDistance
+            );
+        if (results)
+        {
+            do
+            {
+                Field* fields = results->Fetch();
+                uint16 mapId = fields[0].GetUInt16();
+                float x = fields[1].GetFloat();
+                float y = fields[2].GetFloat();
+                float z = fields[3].GetFloat();
+                WorldLocation loc(mapId, x, y, z, 0);
+                locsPerLevelCache[bot->getLevel()].push_back(loc);
+            } while (results->NextRow());
+        }
+    }
+
+    RandomTeleport(bot, locsPerLevelCache[bot->getLevel()]);
+}
+
+void RandomPlayerbotMgr::RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Preparing location to random teleporting bot %s", bot->GetName().c_str());
+
+    vector<WorldLocation> locs;
+    QueryResult results = WorldDatabase.PQuery("select position_x, position_y, position_z from creature where map = '%u' and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            float x = fields[0].GetFloat();
+            float y = fields[1].GetFloat();
+            float z = fields[2].GetFloat();
+            WorldLocation loc(mapId, x, y, z, 0);
+            locs.push_back(loc);
+        } while (results->NextRow());
+    }
+
+    RandomTeleport(bot, locs);
+    Refresh(bot);
+}
+
+void RandomPlayerbotMgr::Randomize(Player* bot)
+{
+    if (bot->getLevel() == 1)
+        RandomizeFirst(bot);
+    else
+        IncreaseLevel(bot);
+}
+
+void RandomPlayerbotMgr::IncreaseLevel(Player* bot)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    uint32 level = min((uint32)(bot->getLevel() + 1), maxLevel);
+    PlayerbotFactory factory(bot, level);
+    if (bot->GetGuildId())
+        factory.Refresh();
+    else
+        factory.Randomize();
+    RandomTeleportForLevel(bot);
+}
+
+void RandomPlayerbotMgr::RandomizeFirst(Player* bot)
+{
+    uint32 maxLevel = sPlayerbotAIConfig.randomBotMaxLevel;
+    if (maxLevel > sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
+        maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+    for (int attempt = 0; attempt < 10; ++attempt)
+    {
+        int index = urand(0, sPlayerbotAIConfig.randomBotMaps.size() - 1);
+        uint16 mapId = sPlayerbotAIConfig.randomBotMaps[index];
+
+        vector<GameTele const*> locs;
+        GameTeleContainer const & teleMap = sObjectMgr->GetGameTeleMap();
+        for(GameTeleContainer::const_iterator itr = teleMap.begin(); itr != teleMap.end(); ++itr)
+        {
+            GameTele const* tele = &itr->second;
+            if (tele->mapId == mapId)
+                locs.push_back(tele);
+        }
+
+        index = urand(0, locs.size() - 1);
+        GameTele const* tele = locs[index];
+        uint32 level = GetZoneLevel(tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        if (level > maxLevel + 5)
+            continue;
+
+        level = min(level, maxLevel);
+        if (!level) level = 1;
+
+        if (urand(0, 100) < 100 * sPlayerbotAIConfig.randomBotMaxLevelChance)
+            level = maxLevel;
+
+        if (level < sPlayerbotAIConfig.randomBotMinLevel)
+            continue;
+
+        PlayerbotFactory factory(bot, level);
+        factory.CleanRandomize();
+        RandomTeleport(bot, tele->mapId, tele->position_x, tele->position_y, tele->position_z);
+        break;
+    }
+}
+
+uint32 RandomPlayerbotMgr::GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ)
+{
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+
+	uint32 level;
+    QueryResult results = WorldDatabase.PQuery("select avg(t.minlevel) minlevel, avg(t.maxlevel) maxlevel from creature c "
+            "inner join creature_template t on c.id = t.entry "
+            "where map = '%u' and minlevel > 1 and abs(position_x - '%f') < '%u' and abs(position_y - '%f') < '%u'",
+            mapId, teleX, sPlayerbotAIConfig.randomBotTeleportDistance / 2, teleY, sPlayerbotAIConfig.randomBotTeleportDistance / 2);
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        uint8 minLevel = fields[0].GetUInt8();
+        uint8 maxLevel = fields[1].GetUInt8();
+        level = urand(minLevel, maxLevel);
+        if (level > maxLevel)
+            level = maxLevel;
+    }
+    else
+    {
+        level = urand(1, maxLevel);
+    }
+
+    return level;
+}
+
+void RandomPlayerbotMgr::Refresh(Player* bot)
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Refreshing bot %s", bot->GetName().c_str());
+    if (bot->isDead())
+    {
+        bot->ResurrectPlayer(1.0f);
+        bot->SpawnCorpseBones();
+        bot->SaveToDB();
+        bot->GetPlayerbotAI()->ResetStrategies();
+    }
+
+    bot->GetPlayerbotAI()->Reset();
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        unit->RemoveAllAttackers();
+        unit->ClearInCombat();
+
+        ref = ref->next();
+    }
+
+    bot->RemoveAllAttackers();
+    bot->ClearInCombat();
+
+    bot->DurabilityRepairAll(false, 1.0f, false);
+    bot->SetFullHealth();
+    bot->SetPvP(true);
+
+    if (bot->GetMaxPower(POWER_MANA) > 0)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA));
+
+    if (bot->GetMaxPower(POWER_ENERGY) > 0)
+        bot->SetPower(POWER_ENERGY, bot->GetMaxPower(POWER_ENERGY));
+}
+
+
+bool RandomPlayerbotMgr::IsRandomBot(Player* bot)
+{
+    return IsRandomBot(bot->GetGUID());
+}
+
+bool RandomPlayerbotMgr::IsRandomBot(uint32 bot)
+{
+    return GetEventValue(bot, "add");
+}
+
+list<uint32> RandomPlayerbotMgr::GetBots()
+{
+    list<uint32> bots;
+
+    QueryResult results = CharacterDatabase.Query(
+            "select bot from ai_playerbot_random_bots where owner = 0 and event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.push_back(bot);
+        } while (results->NextRow());
+    }
+
+    return bots;
+}
+
+vector<uint32> RandomPlayerbotMgr::GetFreeBots(bool alliance)
+{
+    set<uint32> bots;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `bot` from ai_playerbot_random_bots where event = 'add'");
+
+    if (results)
+    {
+        do
+        {
+            Field* fields = results->Fetch();
+            uint32 bot = fields[0].GetUInt32();
+            bots.insert(bot);
+        } while (results->NextRow());
+    }
+
+    vector<uint32> guids;
+    for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); i++)
+    {
+        uint32 accountId = *i;
+        if (!sAccountMgr->GetCharactersCount(accountId))
+            continue;
+
+        QueryResult result = CharacterDatabase.PQuery("SELECT guid, race FROM characters WHERE account = '%u'", accountId);
+        if (!result)
+            continue;
+
+        do
+        {
+            Field* fields = result->Fetch();
+            uint32 guid = fields[0].GetUInt32();
+            uint8 race = fields[1].GetUInt8();
+            if (bots.find(guid) == bots.end() &&
+                    ((alliance && IsAlliance(race)) || ((!alliance && !IsAlliance(race))
+            )))
+                guids.push_back(guid);
+        } while (result->NextRow());
+    }
+
+
+    return guids;
+}
+
+uint32 RandomPlayerbotMgr::GetEventValue(uint32 bot, string event)
+{
+    uint32 value = 0;
+
+    QueryResult results = CharacterDatabase.PQuery(
+            "select `value`, `time`, validIn from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+
+    if (results)
+    {
+        Field* fields = results->Fetch();
+        value = fields[0].GetUInt32();
+        uint32 lastChangeTime = fields[1].GetUInt32();
+        uint32 validIn = fields[2].GetUInt32();
+        if ((time(0) - lastChangeTime) >= validIn)
+            value = 0;
+    }
+
+    return value;
+}
+
+uint32 RandomPlayerbotMgr::SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn)
+{
+    CharacterDatabase.PExecute("delete from ai_playerbot_random_bots where owner = 0 and bot = '%u' and event = '%s'",
+            bot, event.c_str());
+    if (value)
+    {
+        CharacterDatabase.PExecute(
+                "insert into ai_playerbot_random_bots (owner, bot, `time`, validIn, event, `value`) values ('%u', '%u', '%u', '%u', '%s', '%u')",
+                0, bot, (uint32)time(0), validIn, event.c_str(), value);
+    }
+
+    return value;
+}
+
+bool RandomPlayerbotMgr::HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args)
+{
+    if (!sPlayerbotAIConfig.enabled)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Playerbot system is currently disabled!");
+        return false;
+    }
+
+    if (!*args)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "Usage: rndbot stats/update/reset/init/refresh/add/remove");
+        return false;
+    }
+
+    string cmd = args;
+
+    if (cmd == "reset")
+    {
+        CharacterDatabase.PExecute("delete from ai_playerbot_random_bots");
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Random bots were reset for all players");
+        return true;
+    }
+    else if (cmd == "stats")
+    {
+        sRandomPlayerbotMgr.PrintStats();
+        return true;
+    }
+    else if (cmd == "update")
+    {
+        sRandomPlayerbotMgr.UpdateAIInternal(0);
+        return true;
+    }
+    else if (cmd == "init" || cmd == "refresh" || cmd == "teleport")
+    {
+		sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Randomizing bots for %d accounts", sPlayerbotAIConfig.randomBotAccounts.size());
+        list<uint32> botIds;
+        for (list<uint32>::iterator i = sPlayerbotAIConfig.randomBotAccounts.begin(); i != sPlayerbotAIConfig.randomBotAccounts.end(); ++i)
+        {
+            uint32 account = *i;
+            if (QueryResult results = CharacterDatabase.PQuery("SELECT guid FROM characters where account = '%u'", account))
+            {
+                do
+                {
+                    Field* fields = results->Fetch();
+
+                    uint32 botId = fields[0].GetUInt32();
+                    ObjectGuid guid = ObjectGuid(HighGuid::Player, botId);
+                    Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+                    if (!bot)
+                        continue;
+
+                    botIds.push_back(botId);
+                } while (results->NextRow());
+            }
+        }
+
+        int processed = 0;
+        for (list<uint32>::iterator i = botIds.begin(); i != botIds.end(); ++i)
+        {
+            ObjectGuid guid = ObjectGuid(HighGuid::Player, *i);
+            Player* bot = sObjectMgr->GetPlayerByLowGUID(guid);
+            if (!bot)
+                continue;
+
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "[%u/%u] Processing command '%s' for bot '%s'",
+                    processed++, botIds.size(), cmd.c_str(), bot->GetName().c_str());
+
+            if (cmd == "init")
+            {
+                sRandomPlayerbotMgr.RandomizeFirst(bot);
+            }
+            else if (cmd == "teleport")
+            {
+                sRandomPlayerbotMgr.RandomTeleportForLevel(bot);
+            }
+            else
+            {
+                bot->SetLevel(bot->getLevel() - 1);
+                sRandomPlayerbotMgr.IncreaseLevel(bot);
+            }
+            uint32 randomTime = urand(sPlayerbotAIConfig.minRandomBotRandomizeTime, sPlayerbotAIConfig.maxRandomBotRandomizeTime);
+            CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'randomize' and bot = '%u'",
+                    randomTime, bot->GetGUID().GetCounter());
+            CharacterDatabase.PExecute("update ai_playerbot_random_bots set validIn = '%u' where event = 'logout' and bot = '%u'",
+                    sPlayerbotAIConfig.maxRandomBotInWorldTime, bot->GetGUID().GetCounter());
+        }
+        return true;
+    }
+    else
+    {
+        list<string> messages = sRandomPlayerbotMgr.HandlePlayerbotCommand(args, NULL);
+        for (list<string>::iterator i = messages.begin(); i != messages.end(); ++i)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, i->c_str());
+        }
+        return true;
+    }
+
+    return false;
+}
+
+void RandomPlayerbotMgr::HandleCommand(uint32 type, const string& text, Player& fromPlayer)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        bot->GetPlayerbotAI()->HandleCommand(type, text, fromPlayer);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogout(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        PlayerbotAI* ai = bot->GetPlayerbotAI();
+        if (player == ai->GetMaster())
+        {
+            ai->SetMaster(NULL);
+            ai->ResetStrategies();
+        }
+    }
+
+    if (!player->GetPlayerbotAI())
+    {
+        vector<Player*>::iterator i = find(players.begin(), players.end(), player);
+        if (i != players.end())
+            players.erase(i);
+    }
+}
+
+void RandomPlayerbotMgr::OnPlayerLogin(Player* player)
+{
+    for (PlayerBotMap::const_iterator it = GetPlayerBotsBegin(); it != GetPlayerBotsEnd(); ++it)
+    {
+        Player* const bot = it->second;
+        if (player == bot || player->GetPlayerbotAI())
+            continue;
+
+        Group* group = bot->GetGroup();
+        if (!group)
+            continue;
+
+        for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+        {
+            Player* member = gref->GetSource();
+            PlayerbotAI* ai = bot->GetPlayerbotAI();
+            if (member == player && (!ai->GetMaster() || ai->GetMaster()->GetPlayerbotAI()))
+            {
+                ai->SetMaster(player);
+                ai->ResetStrategies();
+                ai->TellMaster("Hello");
+                break;
+            }
+        }
+    }
+
+    if (player->GetPlayerbotAI())
+        return;
+
+    players.push_back(player);
+}
+
+Player* RandomPlayerbotMgr::GetRandomPlayer()
+{
+    if (players.empty())
+        return NULL;
+
+    uint32 index = urand(0, players.size() - 1);
+    return players[index];
+}
+
+void RandomPlayerbotMgr::PrintStats()
+{
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "%d Random Bots online", playerBots.size());
+
+    map<uint32, int> alliance, horde;
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        alliance[i] = 0;
+        horde[i] = 0;
+    }
+
+    map<uint8, int> perRace, perClass;
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        perRace[race] = 0;
+    }
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        perClass[cls] = 0;
+    }
+
+    int dps = 0, heal = 0, tank = 0;
+    for (PlayerBotMap::iterator i = playerBots.begin(); i != playerBots.end(); ++i)
+    {
+        Player* bot = i->second;
+        if (IsAlliance(bot->getRace()))
+            alliance[bot->getLevel() / 10]++;
+        else
+            horde[bot->getLevel() / 10]++;
+
+        perRace[bot->getRace()]++;
+        perClass[bot->getClass()]++;
+
+        int spec = AiFactory::GetPlayerSpecTab(bot);
+        switch (bot->getClass())
+        {
+        case CLASS_DRUID:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PALADIN:
+            if (spec == 1)
+                tank++;
+            else if (spec == 0)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_PRIEST:
+            if (spec != 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_SHAMAN:
+            if (spec == 2)
+                heal++;
+            else
+                dps++;
+            break;
+        case CLASS_WARRIOR:
+            if (spec == 2)
+                tank++;
+            else
+                dps++;
+            break;
+        default:
+            dps++;
+            break;
+        }
+    }
+
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per level:");
+    uint32 maxLevel = sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL);
+    for (uint32 i = 0; i < 10; ++i)
+    {
+        if (!alliance[i] && !horde[i])
+            continue;
+
+        uint32 from = i*10;
+        uint32 to = min(from + 9, maxLevel);
+        if (!from) from = 1;
+        sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %d..%d: %d alliance, %d horde", from, to, alliance[i], horde[i]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per race:");
+    for (uint8 race = RACE_HUMAN; race < MAX_RACES; ++race)
+    {
+        if (perRace[race])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatRace(race).c_str(), perRace[race]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per class:");
+    for (uint8 cls = CLASS_WARRIOR; cls < MAX_CLASSES; ++cls)
+    {
+        if (perClass[cls])
+            sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    %s: %d", ChatHelper::formatClass(cls).c_str(), perClass[cls]);
+    }
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "Per role:");
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    tank: %d", tank);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    heal: %d", heal);
+    sLog->outMessage("playerbot", LOG_LEVEL_INFO, "    dps: %d", dps);
+}
+
+double RandomPlayerbotMgr::GetBuyMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "buymultiplier");
+    if (!value)
+    {
+        value = urand(1, 120);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "buymultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+double RandomPlayerbotMgr::GetSellMultiplier(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    uint32 value = GetEventValue(id, "sellmultiplier");
+    if (!value)
+    {
+        value = urand(80, 250);
+        uint32 validIn = urand(sPlayerbotAIConfig.minRandomBotsPriceChangeInterval, sPlayerbotAIConfig.maxRandomBotsPriceChangeInterval);
+        SetEventValue(id, "sellmultiplier", value, validIn);
+    }
+
+    return (double)value / 100.0;
+}
+
+uint32 RandomPlayerbotMgr::GetLootAmount(Player* bot)
+{
+    uint32 id = bot->GetGUID();
+    return GetEventValue(id, "lootamount");
+}
+
+void RandomPlayerbotMgr::SetLootAmount(Player* bot, uint32 value)
+{
+    uint32 id = bot->GetGUID();
+    SetEventValue(id, "lootamount", value, 24 * 3600);
+}
+
+uint32 RandomPlayerbotMgr::GetTradeDiscount(Player* bot)
+{
+    Group* group = bot->GetGroup();
+    return GetLootAmount(bot) / (group ? group->GetMembersCount() : 10);
+}
+
+string RandomPlayerbotMgr::HandleRemoteCommand(string request)
+{
+    string::iterator pos = find(request.begin(), request.end(), ',');
+    if (pos == request.end())
+    {
+        ostringstream out; out << "invalid request: " << request;
+        return out.str();
+    }
+
+    string command = string(request.begin(), pos);
+    uint64 guid = atoi(string(pos + 1, request.end()).c_str());
+    Player* bot = GetPlayerBot(guid);
+    if (!bot)
+        return "invalid guid";
+
+    PlayerbotAI *ai = bot->GetPlayerbotAI();
+    if (!ai)
+        return "invalid guid";
+
+    return ai->HandleRemoteCommand(command);
+}
diff --git a/src/plugins/playerbot/RandomPlayerbotMgr.h b/src/plugins/playerbot/RandomPlayerbotMgr.h
new file mode 100644
index 0000000..0d0ada4
--- /dev/null
+++ b/src/plugins/playerbot/RandomPlayerbotMgr.h
@@ -0,0 +1,74 @@
+#ifndef _RandomPlayerbotMgr_H
+#define _RandomPlayerbotMgr_H
+
+#include "Common.h"
+#include "PlayerbotAIBase.h"
+#include "PlayerbotMgr.h"
+
+class WorldPacket;
+class Player;
+class Unit;
+class Object;
+class Item;
+
+using namespace std;
+
+class RandomPlayerbotMgr : public PlayerbotHolder
+{
+    public:
+        RandomPlayerbotMgr();
+        virtual ~RandomPlayerbotMgr();
+        static RandomPlayerbotMgr& instance()
+        {
+            static RandomPlayerbotMgr instance;
+            return instance;
+        }
+
+        virtual void UpdateAIInternal(uint32 elapsed);
+
+	public:
+        static bool HandlePlayerbotConsoleCommand(ChatHandler* handler, char const* args);
+        bool IsRandomBot(Player* bot);
+        bool IsRandomBot(uint32 bot);
+        void Randomize(Player* bot);
+        void RandomizeFirst(Player* bot);
+        void IncreaseLevel(Player* bot);
+        void ScheduleTeleport(uint32 bot);
+        void HandleCommand(uint32 type, const string& text, Player& fromPlayer);
+        string HandleRemoteCommand(string request);
+        void OnPlayerLogout(Player* player);
+        void OnPlayerLogin(Player* player);
+        Player* GetRandomPlayer();
+        void PrintStats();
+        double GetBuyMultiplier(Player* bot);
+        double GetSellMultiplier(Player* bot);
+        uint32 GetLootAmount(Player* bot);
+        void SetLootAmount(Player* bot, uint32 value);
+        uint32 GetTradeDiscount(Player* bot);
+        void Refresh(Player* bot);
+        void RandomTeleportForLevel(Player* bot);
+
+	protected:
+	    virtual void OnBotLoginInternal(Player * const bot) {}
+
+    private:
+        uint32 GetEventValue(uint32 bot, string event);
+        uint32 SetEventValue(uint32 bot, string event, uint32 value, uint32 validIn);
+        list<uint32> GetBots();
+        vector<uint32> GetFreeBots(bool alliance);
+        uint32 AddRandomBot(bool alliance);
+        bool ProcessBot(uint32 bot);
+        void ScheduleRandomize(uint32 bot, uint32 time);
+        void RandomTeleport(Player* bot, uint16 mapId, float teleX, float teleY, float teleZ);
+        void RandomTeleport(Player* bot, vector<WorldLocation> &locs);
+        uint32 GetZoneLevel(uint16 mapId, float teleX, float teleY, float teleZ);
+
+    private:
+        vector<Player*> players;
+        int processTicks;
+        map<uint8, vector<WorldLocation> > locsPerLevelCache;
+};
+
+#define sRandomPlayerbotMgr RandomPlayerbotMgr::instance()
+
+#endif
diff --git a/src/plugins/playerbot/aiplayerbot.conf.dist.in b/src/plugins/playerbot/aiplayerbot.conf.dist.in
new file mode 100644
index 0000000..54a2ad6
--- /dev/null
+++ b/src/plugins/playerbot/aiplayerbot.conf.dist.in
@@ -0,0 +1,183 @@
+##########################################
+# MANGOS Ai Playerbot Configuration file #
+##########################################
+
+[AiPlayerbotConf]
+ConfVersion=2010102201
+
+# Enable or disable AI Playerbot
+AiPlayerbot.Enabled = 1
+
+# Warrior
+AiPlayerbot.RandomClassSpecProbability.1.0 = 20
+AiPlayerbot.RandomClassSpecProbability.1.1 = 30
+AiPlayerbot.RandomClassSpecProbability.1.2 = 50
+# Paladin
+AiPlayerbot.RandomClassSpecProbability.2.0 = 20
+AiPlayerbot.RandomClassSpecProbability.2.1 = 50
+AiPlayerbot.RandomClassSpecProbability.2.2 = 30
+# Hunter
+AiPlayerbot.RandomClassSpecProbability.3.0 = 25
+AiPlayerbot.RandomClassSpecProbability.3.1 = 50
+AiPlayerbot.RandomClassSpecProbability.3.2 = 25
+# Rogue
+AiPlayerbot.RandomClassSpecProbability.4.0 = 40
+AiPlayerbot.RandomClassSpecProbability.4.1 = 50
+AiPlayerbot.RandomClassSpecProbability.4.2 = 10
+# Priest
+AiPlayerbot.RandomClassSpecProbability.5.0 = 40
+AiPlayerbot.RandomClassSpecProbability.5.1 = 40
+AiPlayerbot.RandomClassSpecProbability.5.2 = 20
+# Shaman
+AiPlayerbot.RandomClassSpecProbability.7.0 = 10
+AiPlayerbot.RandomClassSpecProbability.7.1 = 45
+AiPlayerbot.RandomClassSpecProbability.7.2 = 45
+# Mage
+AiPlayerbot.RandomClassSpecProbability.8.0 = 20
+AiPlayerbot.RandomClassSpecProbability.8.1 = 10
+AiPlayerbot.RandomClassSpecProbability.8.2 = 70
+# Warlock
+AiPlayerbot.RandomClassSpecProbability.9.0 = 33
+AiPlayerbot.RandomClassSpecProbability.9.1 = 33
+AiPlayerbot.RandomClassSpecProbability.9.2 = 33
+# Druid
+AiPlayerbot.RandomClassSpecProbability.11.0 = 10
+AiPlayerbot.RandomClassSpecProbability.11.1 = 45
+AiPlayerbot.RandomClassSpecProbability.11.2 = 45
+
+#
+# All other parameters are optional but can be changed by uncommenting them here
+#
+
+# Prefix for bot chat commands (e.g. follow, stay)
+AiPlayerbot.CommandPrefix =
+
+# Max AI iterations per tick
+#AiPlayerbot.IterationsPerTick = 10
+
+# Allow/deny bots from your guild
+#AiPlayerbot.AllowGuildBots = 1
+
+# Delay between two short-time spells cast
+#AiPlayerbot.GlobalCooldown = 500
+
+# Max wait time when moving
+#AiPlayerbot.MaxWaitForMove = 5000
+
+# Delay between two bot actions
+#AiPlayerbot.ReactDelay = 100
+
+# Distances
+#AiPlayerbot.SightDistance = 75.0
+#AiPlayerbot.SpellDistance = 30.0
+#AiPlayerbot.ReactDistance = 150.0
+#AiPlayerbot.GrindDistance = 100.0
+#AiPlayerbot.LootDistance = 20.0
+#AiPlayerbot.FleeDistance = 20.0
+#AiPlayerbot.TooCloseDistance = 7.0
+#AiPlayerbot.MeleeDistance = 1.0
+#AiPlayerbot.FollowDistance = 1.5
+#AiPlayerbot.WhisperDistance = 6000.0
+#AiPlayerbot.ContactDistance = 0.5
+
+# Bot can flee for enemy
+#AiPlayerbot.FleeingEnabled = 1
+
+# Health/Mana levels
+#AiPlayerbot.CriticalHealth = 25
+#AiPlayerbot.LowHealth = 45
+#AiPlayerbot.MediumHealth = 65
+#AiPlayerbot.AlmostFullHealth = 85
+#AiPlayerbot.LowMana = 15
+#AiPlayerbot.MediumMana = 40
+
+# Enable random bot system
+#AiPlayerbot.RandomBotAutologin = 1
+
+# Random bot default strategies (applied after defaults)
+#AiPlayerbot.RandomBotCombatStrategies = +dps,+attack weak
+#AiPlayerbot.RandomBotNonCombatStrategies = +grind,+move random,+loot
+
+# Create random bot characters automatically
+#AiPlayerbot.RandomBotAutoCreate = 1
+
+# Random bot count
+#AiPlayerbot.MinRandomBots = 50
+#AiPlayerbot.MaxRandomBots = 200
+#AiPlayerbot.RandomBotMinLevel = 1
+#AiPlayerbot.RandomBotMaxLevel = 255 (ignored if more than MaxPlayerLevel mangosd.conf value)
+
+# Accounts to create for random bots
+#AiPlayerbot.RandomBotAccountPrefix = rndbot
+#AiPlayerbot.RandomBotAccountCount = 50
+
+# Delete all random bot accounts
+#AiPlayerbot.DeleteRandomBotAccounts = 0
+
+# Random bot guild count
+#AiPlayerbot.RandomBotGuildCount = 50
+
+# Guild Task system
+#AiPlayerbot.EnableGuildTasks = 1
+
+# How often tasks are changed
+#AiPlayerbot.MinGuildTaskChangeTime = 172800
+#AiPlayerbot.MaxGuildTaskChangeTime = 432000
+# Mail spam interval
+#AiPlayerbot.MinGuildTaskAdvertisementTime = 300
+#AiPlayerbot.MaxGuildTaskAdvertisementTime = 28800
+# Delay before reward is sent
+#AiPlayerbot.MinGuildTaskRewardTime = 300
+#AiPlayerbot.MaxGuildTaskRewardTime = 3600
+
+# Delete all random bot guilds
+#AiPlayerbot.DeleteRandomBotGuilds = 0
+
+# Maps to teleport random bots
+#AiPlayerbot.RandomBotMaps = 0,1,530,571
+
+# Change random bot has lower gear
+#AiPlayerbot.RandomGearLoweringChance = 0.15
+
+# Chance random bot has max level on first randomize
+#AiPlayerbot.RandomBotMaxLevelChance = 0.4
+
+# Quest items to leave (do not destroy)
+#AiPlayerbot.RandomBotQuestItems = 6948,5175,5176,5177,5178
+
+# Spells every random bot will learn on randomize (54197 - cold weather flying)
+#AiPlayerbot.RandomBotSpellIds = 54197
+
+# Enable LFG for random bots
+#AiPlayerbot.RandomBotJoinLfg = 1
+
+# Level diff between random bots and nearby creatures for random teleports
+AiPlayerbot.RandomBotTeleLevel = 3
+
+# Intervals
+#AiPlayerbot.RandomBotUpdateInterval = 60
+#AiPlayerbot.RandomBotCountChangeMinInterval = 86400
+#AiPlayerbot.RandomBotCountChangeMaxInterval = 259200
+#AiPlayerbot.MinRandomBotInWorldTime = 7200
+#AiPlayerbot.MaxRandomBotInWorldTime = 1209600
+#AiPlayerbot.MinRandomBotRandomizeTime = 7200
+#AiPlayerbot.MaxRandomRandomizeTime = 1209600
+#AiPlayerbot.MinRandomBotsPerInterval = 50
+#AiPlayerbot.MaxRandomBotsPerInterval = 100
+#AiPlayerbot.MinRandomBotsPriceChangeInterval = 7200
+#AiPlayerbot.MaxRandomBotsPriceChangeInterval = 172800
+
+# Log on all random bots on start
+#AiPlayerbot.RandomBotLoginAtStartup = 1
+
+# How far random bots are teleported after death
+#AiPlayerbot.RandomBotTeleportDistance = 1000
+
+# Debug switches
+#AiPlayerbot.SpellDump = 0
+#AiPlayerbot.LogInGroupOnly = 1
+#AiPlayerbot.LogValuesPerTick = 0
+#AiPlayerbot.RandomChangeMultiplier = 1
+
+# Command server port, 0 - disabled
+#AiPlayerbot.CommandServerPort = 8888
diff --git a/src/plugins/playerbot/playerbot.h b/src/plugins/playerbot/playerbot.h
new file mode 100644
index 0000000..3de8ebc
--- /dev/null
+++ b/src/plugins/playerbot/playerbot.h
@@ -0,0 +1,31 @@
+#pragma once
+
+std::vector<std::string> split(const std::string &s, char delim);
+#ifndef WIN32
+int strcmpi(std::string s1, std::string s2);
+#endif
+
+#include "../Spell.h"
+#include "../../shared/Packets/WorldPacket.h"
+#include "../Loot/LootMgr.h"
+#include "../Entities/Creature/GossipDef.h"
+#include "../Chat/Chat.h"
+#include "../../common/Common.h"
+#include "../World/World.h"
+#include "../Spells/SpellMgr.h"
+#include "../Globals/ObjectMgr.h"
+#include "../Entities/Unit/Unit.h"
+#include "../Miscellaneous/SharedDefines.h"
+#include "../Movement/MotionMaster.h"
+#include "../Spells/Auras/SpellAuras.h"
+#include "../Guilds/Guild.h"
+#include "../Groups/Group.h"
+#include "../../game/Accounts/AccountMgr.h"
+#include "../../game/Globals/ObjectMgr.h"
+
+#include "playerbotDefs.h"
+#include "PlayerbotAIAware.h"
+#include "PlayerbotMgr.h"
+#include "RandomPlayerbotMgr.h"
+#include "ChatHelper.h"
+#include "PlayerbotAI.h"
diff --git a/src/plugins/playerbot/playerbotDefs.h b/src/plugins/playerbot/playerbotDefs.h
new file mode 100644
index 0000000..3f59c93
--- /dev/null
+++ b/src/plugins/playerbot/playerbotDefs.h
@@ -0,0 +1,2 @@
+#pragma once
+
diff --git a/src/plugins/playerbot/strategy/Action.cpp b/src/plugins/playerbot/strategy/Action.cpp
new file mode 100644
index 0000000..75e3301
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.cpp
@@ -0,0 +1,93 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "Action.h"
+
+using namespace ai;
+
+int NextAction::size(NextAction** actions)
+{
+    if (!actions)
+        return 0;
+
+    int size;
+    for (size=0; size<10 && actions[size]; ) 
+        size++;
+    return size;
+}
+
+NextAction** NextAction::clone(NextAction** actions)
+{
+    if (!actions)
+        return NULL;
+
+    int size = NextAction::size(actions);
+
+    NextAction** res = new NextAction*[size + 1];
+    for (int i=0; i<size; i++)
+        res[i] = new NextAction(*actions[i]);
+    res[size] = NULL;
+    return res;
+}
+
+NextAction** NextAction::merge(NextAction** left, NextAction** right)
+{
+    int leftSize = NextAction::size(left);
+    int rightSize = NextAction::size(right);
+
+    NextAction** res = new NextAction*[leftSize + rightSize + 1];
+    for (int i=0; i<leftSize; i++)
+        res[i] = new NextAction(*left[i]);
+    for (int i=0; i<rightSize; i++)
+        res[leftSize + i] = new NextAction(*right[i]);
+    res[leftSize + rightSize] = NULL;
+
+    NextAction::destroy(left);
+    NextAction::destroy(right);
+
+    return res;
+}
+
+NextAction** NextAction::array(uint8 nil, ...)
+{
+    va_list vl;
+    va_start(vl, nil);
+    
+    int size = 0;
+    NextAction* cur = NULL;
+    do 
+    {
+        cur = va_arg(vl, NextAction*);
+        size++;
+    }
+    while (cur);
+
+    va_end(vl);
+
+    NextAction** res = new NextAction*[size];
+    va_start(vl, nil);
+    for (int i=0; i<size; i++)
+        res[i] = va_arg(vl, NextAction*);
+    va_end(vl);
+
+    return res;
+}
+
+void NextAction::destroy(NextAction** actions)
+{
+    if (!actions)
+        return;
+
+    for (int i=0; i<10 && actions[i]; i++)
+        delete actions[i];
+}
+
+Value<Unit*>* Action::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Action::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Action.h b/src/plugins/playerbot/strategy/Action.h
new file mode 100644
index 0000000..b8d2a1c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Action.h
@@ -0,0 +1,138 @@
+#pragma once
+#include "Event.h"
+#include "Value.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class NextAction
+    {
+    public:
+        NextAction(string name, float relevance = 0.0f)
+        {
+            this->name = name;
+            this->relevance = relevance;
+        }
+        NextAction(const NextAction& o)
+        {
+            this->name = o.name;
+            this->relevance = o.relevance;
+        }
+
+    public:
+        string getName() { return name; }
+        float getRelevance() {return relevance;}
+
+    public:
+        static int size(NextAction** actions);
+        static NextAction** clone(NextAction** actions);
+        static NextAction** merge(NextAction** what, NextAction** with);
+        static NextAction** array(uint8 nil,...);
+        static void destroy(NextAction** actions);
+
+    private:
+        float relevance;
+        std::string name;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class ActionBasket;
+
+    enum ActionThreatType
+    {
+        ACTION_THREAT_NONE = 0,
+        ACTION_THREAT_SINGLE= 1,
+        ACTION_THREAT_AOE = 2
+    };
+
+    class Action : public AiNamedObject
+	{
+	public:
+        Action(PlayerbotAI* ai, string name = "action") : verbose(false), AiNamedObject(ai, name) { }
+        virtual ~Action(void) {}
+
+    public:
+        virtual bool Execute(Event event) { return true; }
+        virtual bool isPossible() { return true; }
+        virtual bool isUseful() { return true; }
+        virtual NextAction** getPrerequisites() { return NULL; }
+        virtual NextAction** getAlternatives() { return NULL; }
+        virtual NextAction** getContinuers() { return NULL; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+        void Update() {}
+        void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+        void MakeVerbose() { verbose = true; }
+
+    protected:
+        bool verbose;
+	};
+
+    class ActionNode
+    {
+    public:
+        ActionNode(string name, NextAction** prerequisites = NULL, NextAction** alternatives = NULL, NextAction** continuers = NULL)
+        {
+            this->action = NULL;
+            this->name = name;
+            this->prerequisites = prerequisites;
+            this->alternatives = alternatives;
+            this->continuers = continuers;
+        }
+        virtual ~ActionNode()
+        {
+            NextAction::destroy(prerequisites);
+            NextAction::destroy(alternatives);
+            NextAction::destroy(continuers);
+        }
+
+    public:
+        Action* getAction() { return action; }
+        void setAction(Action* action) { this->action = action; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getContinuers() { return NextAction::merge(NextAction::clone(continuers), action->getContinuers()); }
+        NextAction** getAlternatives() { return NextAction::merge(NextAction::clone(alternatives), action->getAlternatives()); }
+        NextAction** getPrerequisites() { return NextAction::merge(NextAction::clone(prerequisites), action->getPrerequisites()); }
+
+    private:
+        string name;
+        Action* action;
+        NextAction** continuers;
+        NextAction** alternatives;
+        NextAction** prerequisites;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+	class ActionBasket
+	{
+	public:
+        ActionBasket(ActionNode* action, float relevance, bool skipPrerequisites, Event event) :
+          action(action), relevance(relevance), skipPrerequisites(skipPrerequisites), event(event) {}
+        virtual ~ActionBasket(void) {}
+	public:
+		float getRelevance() {return relevance;}
+		ActionNode* getAction() {return action;}
+        Event getEvent() { return event; }
+        bool isSkipPrerequisites() { return skipPrerequisites; }
+        void AmendRelevance(float k) {relevance *= k; }
+        void setRelevance(float relevance) { this->relevance = relevance; }
+	private:
+		ActionNode* action;
+		float relevance;
+        bool skipPrerequisites;
+        Event event;
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+
+}
+
+#define AI_VALUE(type, name) context->GetValue<type>(name)->Get()
+#define AI_VALUE2(type, name, param) context->GetValue<type>(name, param)->Get()
diff --git a/src/plugins/playerbot/strategy/ActionBasket.cpp b/src/plugins/playerbot/strategy/ActionBasket.cpp
new file mode 100644
index 0000000..ef8e4b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.cpp
@@ -0,0 +1,4 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "ActionBasket.h"
+
diff --git a/src/plugins/playerbot/strategy/ActionBasket.h b/src/plugins/playerbot/strategy/ActionBasket.h
new file mode 100644
index 0000000..d85293b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ActionBasket.h
@@ -0,0 +1,5 @@
+#pragma once
+namespace ai
+{
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/AiObject.cpp b/src/plugins/playerbot/strategy/AiObject.cpp
new file mode 100644
index 0000000..3b807e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.cpp
@@ -0,0 +1,16 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObject.h"
+
+AiObject::AiObject(PlayerbotAI* ai) :
+    PlayerbotAIAware(ai),
+    bot(ai->GetBot()),
+    context(ai->GetAiObjectContext()),
+    chat(ai->GetChatHelper())
+{
+}
+
+Player* AiObject::GetMaster()
+{
+    return ai->GetMaster();
+}
diff --git a/src/plugins/playerbot/strategy/AiObject.h b/src/plugins/playerbot/strategy/AiObject.h
new file mode 100644
index 0000000..0b4f214
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObject.h
@@ -0,0 +1,33 @@
+#pragma once
+
+class PlayerbotAI;
+
+namespace ai
+{
+    class AiObjectContext;
+    class ChatHelper;
+
+    class AiObject : public PlayerbotAIAware
+	{
+	public:
+        AiObject(PlayerbotAI* ai);
+
+    protected:
+        Player* bot;
+        Player* GetMaster();
+        AiObjectContext* context;
+        ChatHelper* chat;
+	};
+
+    class AiNamedObject : public AiObject
+    {
+    public:
+        AiNamedObject(PlayerbotAI* ai, string name) : AiObject(ai), name(name) {}
+
+    public:
+        virtual string getName() { return name; }
+
+    protected:
+        string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.cpp b/src/plugins/playerbot/strategy/AiObjectContext.cpp
new file mode 100644
index 0000000..3c75542
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.cpp
@@ -0,0 +1,48 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "AiObjectContext.h"
+#include "NamedObjectContext.h"
+#include "StrategyContext.h"
+#include "triggers/TriggerContext.h"
+#include "actions/ActionContext.h"
+#include "triggers/ChatTriggerContext.h"
+#include "actions/ChatActionContext.h"
+#include "triggers/WorldPacketTriggerContext.h"
+#include "actions/WorldPacketActionContext.h"
+#include "values/ValueContext.h"
+
+using namespace ai;
+
+AiObjectContext::AiObjectContext(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    strategyContexts.Add(new StrategyContext());
+    strategyContexts.Add(new MovementStrategyContext());
+    strategyContexts.Add(new AssistStrategyContext());
+    strategyContexts.Add(new QuestStrategyContext());
+
+    actionContexts.Add(new ActionContext());
+    actionContexts.Add(new ChatActionContext());
+    actionContexts.Add(new WorldPacketActionContext());
+
+    triggerContexts.Add(new TriggerContext());
+    triggerContexts.Add(new ChatTriggerContext());
+    triggerContexts.Add(new WorldPacketTriggerContext());
+
+    valueContexts.Add(new ValueContext());
+}
+
+void AiObjectContext::Update()
+{
+    strategyContexts.Update();
+    triggerContexts.Update();
+    actionContexts.Update();
+    valueContexts.Update();
+}
+
+void AiObjectContext::Reset()
+{
+    strategyContexts.Reset();
+    triggerContexts.Reset();
+    actionContexts.Reset();
+    valueContexts.Reset();
+}
diff --git a/src/plugins/playerbot/strategy/AiObjectContext.h b/src/plugins/playerbot/strategy/AiObjectContext.h
new file mode 100644
index 0000000..f9313bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/AiObjectContext.h
@@ -0,0 +1,81 @@
+#pragma once
+
+#include "../PlayerbotAIAware.h"
+#include "Action.h"
+#include "Value.h"
+#include "NamedObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class AiObjectContext : public PlayerbotAIAware
+    {
+    public:
+        AiObjectContext(PlayerbotAI* ai);
+        virtual ~AiObjectContext() {}
+
+    public:
+        virtual Strategy* GetStrategy(string name) { return strategyContexts.GetObject(name, ai); }
+        virtual set<string> GetSiblingStrategy(string name) { return strategyContexts.GetSiblings(name); }
+        virtual Trigger* GetTrigger(string name) { return triggerContexts.GetObject(name, ai); }
+        virtual Action* GetAction(string name) { return actionContexts.GetObject(name, ai); }
+        virtual UntypedValue* GetUntypedValue(string name) { return valueContexts.GetObject(name, ai); }
+
+        template<class T>
+        Value<T>* GetValue(string name)
+        {
+            return dynamic_cast<Value<T>*>(GetUntypedValue(name));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, string param)
+        {
+            return GetValue<T>((string(name) + "::" + param));
+        }
+
+        template<class T>
+        Value<T>* GetValue(string name, uint32 param)
+        {
+        	ostringstream out; out << param;
+            return GetValue<T>(name, out.str());
+        }
+
+        set<string> GetSupportedStrategies()
+        {
+            return strategyContexts.supports();
+        }
+
+        string FormatValues()
+        {
+            ostringstream out;
+            set<string> names = valueContexts.GetCreated();
+            for (set<string>::iterator i = names.begin(); i != names.end(); ++i)
+            {
+                UntypedValue* value = GetUntypedValue(*i);
+                if (!value)
+                    continue;
+
+                string text = value->Format();
+                if (text == "?")
+                    continue;
+
+                out << "{" << *i << "=" << text << "} ";
+            }
+            return out.str();
+        }
+
+    public:
+        virtual void Update();
+        virtual void Reset();
+        virtual void AddShared(NamedObjectContext<UntypedValue>* sharedValues)
+        {
+            valueContexts.Add(sharedValues);
+        }
+
+    protected:
+        NamedObjectContextList<Strategy> strategyContexts;
+        NamedObjectContextList<Action> actionContexts;
+        NamedObjectContextList<Trigger> triggerContexts;
+        NamedObjectContextList<UntypedValue> valueContexts;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Engine.cpp b/src/plugins/playerbot/strategy/Engine.cpp
new file mode 100644
index 0000000..58ab72d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.cpp
@@ -0,0 +1,536 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+
+#include "Engine.h"
+#include "../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Engine::Engine(PlayerbotAI* ai, AiObjectContext *factory) : PlayerbotAIAware(ai), aiObjectContext(factory)
+{
+    lastRelevance = 0.0f;
+    testMode = false;
+}
+
+bool ActionExecutionListeners::Before(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->Before(action, event);
+    }
+    return result;
+}
+
+void ActionExecutionListeners::After(Action* action, bool executed, Event event)
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        (*i)->After(action, executed, event);
+    }
+}
+
+bool ActionExecutionListeners::OverrideResult(Action* action, bool executed, Event event)
+{
+    bool result = executed;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result = (*i)->OverrideResult(action, result, event);
+    }
+    return result;
+}
+
+bool ActionExecutionListeners::AllowExecution(Action* action, Event event)
+{
+    bool result = true;
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        result &= (*i)->AllowExecution(action, event);
+    }
+    return result;
+}
+
+ActionExecutionListeners::~ActionExecutionListeners()
+{
+    for (list<ActionExecutionListener*>::iterator i = listeners.begin(); i!=listeners.end(); i++)
+    {
+        delete *i;
+    }
+    listeners.clear();
+}
+
+
+Engine::~Engine(void)
+{
+    Reset();
+
+    strategies.clear();
+}
+
+void Engine::Reset()
+{
+    ActionNode* action = NULL;
+    do
+    {
+        action = queue.Pop();
+        delete action;
+    } while (action);
+
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* trigger = *i;
+        delete trigger;
+    }
+    triggers.clear();
+
+    for (list<Multiplier*>::iterator i = multipliers.begin(); i != multipliers.end(); i++)
+    {
+        Multiplier* multiplier = *i;
+        delete multiplier;
+    }
+    multipliers.clear();
+}
+
+void Engine::Init()
+{
+    Reset();
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        strategy->InitMultipliers(multipliers);
+        strategy->InitTriggers(triggers);
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+
+	if (testMode)
+	{
+        FILE* file = fopen("test.log", "w");
+        fprintf(file, "\n");
+        fclose(file);
+	}
+}
+
+
+bool Engine::DoNextAction(Unit* unit, int depth)
+{
+    LogAction("--- AI Tick ---");
+    if (sPlayerbotAIConfig.logValuesPerTick)
+        LogValues();
+
+    bool actionExecuted = false;
+    ActionBasket* basket = NULL;
+
+    time_t currentTime = time(0);
+    aiObjectContext->Update();
+    ProcessTriggers();
+
+    int iterations = 0;
+    int iterationsPerTick = queue.Size() * sPlayerbotAIConfig.iterationsPerTick;
+    do {
+        basket = queue.Peek();
+        if (basket) {
+            if (++iterations > iterationsPerTick)
+                break;
+
+            float relevance = basket->getRelevance(); // just for reference
+            bool skipPrerequisites = basket->isSkipPrerequisites();
+            Event event = basket->getEvent();
+            // NOTE: queue.Pop() deletes basket
+            ActionNode* actionNode = queue.Pop();
+            Action* action = InitializeAction(actionNode);
+
+            if (!action)
+            {
+                LogAction("A:%s - UNKNOWN", actionNode->getName().c_str());
+            }
+            else if (action->isUseful())
+            {
+                for (list<Multiplier*>::iterator i = multipliers.begin(); i!= multipliers.end(); i++)
+                {
+                    Multiplier* multiplier = *i;
+                    relevance *= multiplier->GetValue(action);
+                    if (!relevance)
+                    {
+                        LogAction("Multiplier %s made action %s useless", multiplier->getName().c_str(), action->getName().c_str());
+                        break;
+                    }
+                }
+
+                if (action->isPossible() && relevance)
+                {
+                    if ((!skipPrerequisites || lastRelevance-relevance > 0.04) &&
+                            MultiplyAndPush(actionNode->getPrerequisites(), relevance + 0.02, false, event))
+                    {
+                        PushAgain(actionNode, relevance + 0.01, event);
+                        continue;
+                    }
+
+                    actionExecuted = ListenAndExecute(action, event);
+
+                    if (actionExecuted)
+                    {
+                        LogAction("A:%s - OK", action->getName().c_str());
+                        MultiplyAndPush(actionNode->getContinuers(), 0, false, event);
+                        lastRelevance = relevance;
+                        delete actionNode;
+                        break;
+                    }
+                    else
+                    {
+                        MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                        LogAction("A:%s - FAILED", action->getName().c_str());
+                    }
+                }
+                else
+                {
+                    MultiplyAndPush(actionNode->getAlternatives(), relevance + 0.03, false, event);
+                    LogAction("A:%s - IMPOSSIBLE", action->getName().c_str());
+                }
+            }
+            else
+            {
+                lastRelevance = relevance;
+                LogAction("A:%s - USELESS", action->getName().c_str());
+            }
+            delete actionNode;
+        }
+    }
+    while (basket);
+
+    if (!basket)
+    {
+        lastRelevance = 0.0f;
+        PushDefaultActions();
+        if (queue.Peek() && depth < 2)
+            return DoNextAction(unit, depth + 1);
+    }
+
+    if (time(0) - currentTime > 1) {
+        LogAction("too long execution");
+    }
+
+    if (!actionExecuted)
+        LogAction("no actions executed");
+
+    return actionExecuted;
+}
+
+ActionNode* Engine::CreateActionNode(string name)
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        ActionNode* node = strategy->GetAction(name);
+        if (node)
+            return node;
+    }
+    return new ActionNode (name,
+        /*P*/ NULL,
+        /*A*/ NULL,
+        /*C*/ NULL);
+}
+
+bool Engine::MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event)
+{
+    bool pushed = false;
+    if (actions)
+    {
+        for (int j=0; j<10; j++) // TODO: remove 10
+        {
+            NextAction* nextAction = actions[j];
+            if (nextAction)
+            {
+                ActionNode* action = CreateActionNode(nextAction->getName());
+                InitializeAction(action);
+
+                float k = nextAction->getRelevance();
+                if (forceRelevance > 0.0f)
+                {
+                    k = forceRelevance;
+                }
+
+                if (k > 0)
+                {
+                    LogAction("PUSH:%s %f", action->getName().c_str(), k);
+                    queue.Push(new ActionBasket(action, k, skipPrerequisites, event));
+                    pushed = true;
+                }
+
+                delete nextAction;
+            }
+            else
+                break;
+        }
+        delete actions;
+    }
+    return pushed;
+}
+
+ActionResult Engine::ExecuteAction(string name)
+{
+	bool result = false;
+
+    ActionNode *actionNode = CreateActionNode(name);
+    if (!actionNode)
+        return ACTION_RESULT_UNKNOWN;
+
+    Action* action = InitializeAction(actionNode);
+    if (!action)
+        return ACTION_RESULT_UNKNOWN;
+
+    if (!action->isPossible())
+    {
+        delete actionNode;
+        return ACTION_RESULT_IMPOSSIBLE;
+    }
+
+    if (!action->isUseful())
+    {
+        delete actionNode;
+        return ACTION_RESULT_USELESS;
+    }
+
+    action->MakeVerbose();
+    Event emptyEvent;
+    result = ListenAndExecute(action, emptyEvent);
+    MultiplyAndPush(action->getContinuers(), 0.0f, false, emptyEvent);
+    delete actionNode;
+	return result ? ACTION_RESULT_OK : ACTION_RESULT_FAILED;
+}
+
+void Engine::addStrategy(string name)
+{
+    removeStrategy(name);
+
+    Strategy* strategy = aiObjectContext->GetStrategy(name);
+    if (strategy)
+    {
+        set<string> siblings = aiObjectContext->GetSiblingStrategy(name);
+        for (set<string>::iterator i = siblings.begin(); i != siblings.end(); i++)
+            removeStrategy(*i);
+
+        LogAction("S:+%s", strategy->getName().c_str());
+        strategies[strategy->getName()] = strategy;
+    }
+    Init();
+}
+
+void Engine::addStrategies(string first, ...)
+{
+	addStrategy(first);
+
+	va_list vl;
+	va_start(vl, first);
+
+	const char* cur;
+	do
+	{
+		cur = va_arg(vl, const char*);
+		if (cur)
+			addStrategy(cur);
+	}
+	while (cur);
+
+	va_end(vl);
+}
+
+bool Engine::removeStrategy(string name)
+{
+    map<string, Strategy*>::iterator i = strategies.find(name);
+    if (i == strategies.end())
+        return false;
+
+    LogAction("S:-%s", name.c_str());
+    strategies.erase(i);
+    Init();
+    return true;
+}
+
+void Engine::removeAllStrategies()
+{
+    strategies.clear();
+    Init();
+}
+
+void Engine::toggleStrategy(string name)
+{
+    if (!removeStrategy(name))
+        addStrategy(name);
+}
+
+bool Engine::HasStrategy(string name)
+{
+    return strategies.find(name) != strategies.end();
+}
+
+void Engine::ProcessTriggers()
+{
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        TriggerNode* node = *i;
+        if (!node)
+            continue;
+
+        Trigger* trigger = node->getTrigger();
+        if (!trigger)
+        {
+            trigger = aiObjectContext->GetTrigger(node->getName());
+            node->setTrigger(trigger);
+        }
+
+        if (!trigger)
+            continue;
+
+        if (testMode || trigger->needCheck())
+        {
+            Event event = trigger->Check();
+            if (!event)
+                continue;
+
+            LogAction("T:%s", trigger->getName().c_str());
+            MultiplyAndPush(node->getHandlers(), 0.0f, false, event);
+        }
+    }
+    for (list<TriggerNode*>::iterator i = triggers.begin(); i != triggers.end(); i++)
+    {
+        Trigger* trigger = (*i)->getTrigger();
+        if (trigger) trigger->Reset();
+    }
+}
+
+void Engine::PushDefaultActions()
+{
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        Strategy* strategy = i->second;
+        Event emptyEvent;
+        MultiplyAndPush(strategy->getDefaultActions(), 0.0f, false, emptyEvent);
+    }
+}
+
+string Engine::ListStrategies()
+{
+    string s = "Strategies: ";
+
+    if (strategies.empty())
+        return s;
+
+    for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+    {
+        s.append(i->first);
+        s.append(", ");
+    }
+    return s.substr(0, s.length() - 2);
+}
+
+void Engine::PushAgain(ActionNode* actionNode, float relevance, Event event)
+{
+    NextAction** nextAction = new NextAction*[2];
+    nextAction[0] = new NextAction(actionNode->getName(), relevance);
+    nextAction[1] = NULL;
+    MultiplyAndPush(nextAction, relevance, true, event);
+    delete actionNode;
+}
+
+bool Engine::ContainsStrategy(StrategyType type)
+{
+	for (map<string, Strategy*>::iterator i = strategies.begin(); i != strategies.end(); i++)
+	{
+		Strategy* strategy = i->second;
+		if (strategy->GetType() & type)
+			return true;
+	}
+	return false;
+}
+
+Action* Engine::InitializeAction(ActionNode* actionNode)
+{
+    Action* action = actionNode->getAction();
+    if (!action)
+    {
+        action = aiObjectContext->GetAction(actionNode->getName());
+        actionNode->setAction(action);
+    }
+    return action;
+}
+
+bool Engine::ListenAndExecute(Action* action, Event event)
+{
+    bool actionExecuted = false;
+
+    if (actionExecutionListeners.Before(action, event))
+    {
+        actionExecuted = actionExecutionListeners.AllowExecution(action, event) ? action->Execute(event) : true;
+    }
+
+    actionExecuted = actionExecutionListeners.OverrideResult(action, actionExecuted, event);
+    actionExecutionListeners.After(action, actionExecuted, event);
+    return actionExecuted;
+}
+
+void Engine::LogAction(const char* format, ...)
+{
+    char buf[1024];
+
+    va_list ap;
+    va_start(ap, format);
+    vsprintf(buf, format, ap);
+    va_end(ap);
+    lastAction = buf;
+
+    if (testMode)
+    {
+        FILE* file = fopen("test.log", "a");
+        fprintf(file, buf);
+        fprintf(file, "\n");
+        fclose(file);
+    }
+    else
+    {
+        Player* bot = ai->GetBot();
+        if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+            return;
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "%s %s", bot->GetName().c_str(), buf);
+    }
+}
+
+void Engine::ChangeStrategy(string names)
+{
+    vector<string> splitted = split(names, ',');
+    for (vector<string>::iterator i = splitted.begin(); i != splitted.end(); i++)
+    {
+        const char* name = i->c_str();
+        switch (name[0])
+        {
+        case '+':
+            addStrategy(name+1);
+            break;
+        case '-':
+            removeStrategy(name+1);
+            break;
+        case '~':
+            toggleStrategy(name+1);
+            break;
+        case '?':
+            ai->TellMaster(ListStrategies());
+            break;
+        }
+    }
+}
+
+void Engine::LogValues()
+{
+    if (testMode)
+        return;
+
+    Player* bot = ai->GetBot();
+    if (sPlayerbotAIConfig.logInGroupOnly && !bot->GetGroup())
+        return;
+
+    string text = ai->GetAiObjectContext()->FormatValues();
+    sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Values for %s: %s", bot->GetName().c_str(), text.c_str());
+}
diff --git a/src/plugins/playerbot/strategy/Engine.h b/src/plugins/playerbot/strategy/Engine.h
new file mode 100644
index 0000000..a395a1b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Engine.h
@@ -0,0 +1,123 @@
+#pragma once
+
+#include "Action.h"
+#include "Queue.h"
+#include "Trigger.h"
+#include "Multiplier.h"
+#include "AiObjectContext.h"
+#include "Strategy.h"
+
+namespace ai
+{
+    class ActionExecutionListener
+    {
+    public:
+        virtual bool Before(Action* action, Event event) = 0;
+        virtual bool AllowExecution(Action* action, Event event) = 0;
+        virtual void After(Action* action, bool executed, Event event) = 0;
+        virtual bool OverrideResult(Action* action, bool executed, Event event) = 0;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    class ActionExecutionListeners : public ActionExecutionListener
+    {
+    public:
+        virtual ~ActionExecutionListeners();
+
+    // ActionExecutionListener
+    public:
+        virtual bool Before(Action* action, Event event);
+        virtual bool AllowExecution(Action* action, Event event);
+        virtual void After(Action* action, bool executed, Event event);
+        virtual bool OverrideResult(Action* action, bool executed, Event event);
+
+    public:
+        void Add(ActionExecutionListener* listener)
+        {
+            listeners.push_back(listener);
+        }
+        void Remove(ActionExecutionListener* listener)
+        {
+            listeners.remove(listener);
+        }
+
+    private:
+        std::list<ActionExecutionListener*> listeners;
+    };
+
+    // -----------------------------------------------------------------------------------------------------------------------
+
+    enum ActionResult
+    {
+        ACTION_RESULT_UNKNOWN,
+        ACTION_RESULT_OK,
+        ACTION_RESULT_IMPOSSIBLE,
+        ACTION_RESULT_USELESS,
+        ACTION_RESULT_FAILED
+    };
+
+    class Engine : public PlayerbotAIAware
+    {
+    public:
+        Engine(PlayerbotAI* ai, AiObjectContext *factory);
+
+	    void Init();
+        void addStrategy(string name);
+		void addStrategies(string first, ...);
+        bool removeStrategy(string name);
+        bool HasStrategy(string name);
+        void removeAllStrategies();
+        void toggleStrategy(string name);
+        std::string ListStrategies();
+		bool ContainsStrategy(StrategyType type);
+		void ChangeStrategy(string names);
+		string GetLastAction() { return lastAction; }
+
+    public:
+	    virtual bool DoNextAction(Unit*, int depth = 0);
+	    ActionResult ExecuteAction(string name);
+
+    public:
+        void AddActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Add(listener);
+        }
+        void removeActionExecutionListener(ActionExecutionListener* listener)
+        {
+            actionExecutionListeners.Remove(listener);
+        }
+
+    public:
+	    virtual ~Engine(void);
+
+    private:
+        bool MultiplyAndPush(NextAction** actions, float forceRelevance, bool skipPrerequisites, Event event);
+        void Reset();
+        void ProcessTriggers();
+        void PushDefaultActions();
+        void PushAgain(ActionNode* actionNode, float relevance, Event event);
+        ActionNode* CreateActionNode(string name);
+        Action* InitializeAction(ActionNode* actionNode);
+        bool ListenAndExecute(Action* action, Event event);
+
+    private:
+        void LogAction(const char* format, ...);
+        void LogValues();
+
+    protected:
+	    Queue queue;
+	    std::list<TriggerNode*> triggers;
+        std::list<Multiplier*> multipliers;
+        AiObjectContext* aiObjectContext;
+        std::map<string, Strategy*> strategies;
+        float lastRelevance;
+        std::string lastAction;
+
+    public:
+		bool testMode;
+
+    private:
+        ActionExecutionListeners actionExecutionListeners;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Event.cpp b/src/plugins/playerbot/strategy/Event.cpp
new file mode 100644
index 0000000..1a0f28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.cpp
@@ -0,0 +1,20 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Event.h"
+
+
+using namespace ai;
+
+ObjectGuid Event::getObject()
+{
+    if (packet.empty())
+        return ObjectGuid();
+
+    WorldPacket p(packet);
+    p.rpos(0);
+    
+    ObjectGuid guid;
+    p >> guid;
+
+    return guid;
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Event.h b/src/plugins/playerbot/strategy/Event.h
new file mode 100644
index 0000000..86ea279
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Event.h
@@ -0,0 +1,36 @@
+#pragma once
+
+namespace ai
+{
+    class Event
+	{
+	public:
+        Event(Event const& other)
+        {
+            source = other.source;
+            param = other.param;
+            packet = other.packet;
+            owner = other.owner;
+        }
+        Event() {}
+        Event(string source) : source(source) {}
+        Event(string source, string param, Player* owner = NULL) : source(source), param(param), owner(owner) {}
+        Event(string source, WorldPacket &packet, Player* owner = NULL) : source(source), packet(packet), owner(owner) {}
+        virtual ~Event() {}
+
+	public:
+        string getSource() { return source; }
+        string getParam() { return param; }
+        WorldPacket& getPacket() { return packet; }
+        ObjectGuid getObject();
+        Player* getOwner() { return owner; }
+        bool operator! () const { return source.empty(); }
+
+    protected:
+        string source;
+        string param;
+        WorldPacket packet;
+        ObjectGuid object;
+        Player* owner;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/ExternalEventHelper.h b/src/plugins/playerbot/strategy/ExternalEventHelper.h
new file mode 100644
index 0000000..a25154e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ExternalEventHelper.h
@@ -0,0 +1,69 @@
+#pragma once
+
+#include "Trigger.h"
+
+namespace ai
+{
+    class ExternalEventHelper {
+    public:
+        ExternalEventHelper(AiObjectContext* aiObjectContext) : aiObjectContext(aiObjectContext) {}
+
+        bool ParseChatCommand(string command, Player* owner = NULL)
+        {
+            if (HandleCommand(command, "", owner))
+                return true;
+
+            size_t i = string::npos;
+            while (true)
+            {
+                size_t found = command.rfind(" ", i);
+                if (found == string::npos || !found)
+                    break;
+
+                string name = command.substr(0, found);
+                string param = command.substr(found + 1);
+
+                i = found - 1;
+
+                if (HandleCommand(name, param, owner))
+                    return true;
+            }
+
+            if (!ChatHelper::parseable(command))
+                return false;
+
+            HandleCommand("q", command, owner);
+            HandleCommand("c", command, owner);
+            HandleCommand("t", command, owner);
+            return true;
+        }
+
+        void HandlePacket(map<uint16, string> &handlers, const WorldPacket &packet, Player* owner = NULL)
+        {
+            uint16 opcode = packet.GetOpcode();
+            string name = handlers[opcode];
+            if (name.empty())
+                return;
+
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return;
+
+            WorldPacket p(packet);
+            trigger->ExternalEvent(p, owner);
+        }
+
+        bool HandleCommand(string name, string param, Player* owner = NULL)
+        {
+            Trigger* trigger = aiObjectContext->GetTrigger(name);
+            if (!trigger)
+                return false;
+
+            trigger->ExternalEvent(param, owner);
+            return true;
+        }
+
+    private:
+        AiObjectContext* aiObjectContext;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/ItemVisitors.h b/src/plugins/playerbot/strategy/ItemVisitors.h
new file mode 100644
index 0000000..7d0fa5b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/ItemVisitors.h
@@ -0,0 +1,258 @@
+#pragma once
+
+char * strstri (const char* str1, const char* str2);
+
+namespace ai
+{
+    class IterateItemsVisitor
+    {
+    public:
+        IterateItemsVisitor() {}
+
+        virtual bool Visit(Item* item) = 0;
+    };
+
+    class FindItemVisitor : public IterateItemsVisitor {
+    public:
+        FindItemVisitor() : IterateItemsVisitor(), result(ObjectGuid::Empty) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (!Accept(item->GetTemplate()))
+                return true;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult() { return result; }
+
+    protected:
+        virtual bool Accept(const ItemTemplate* proto) = 0;
+
+    private:
+        list<Item*> result;
+    };
+
+    enum IterateItemsMask
+    {
+        ITERATE_ITEMS_IN_BAGS = 1,
+        ITERATE_ITEMS_IN_EQUIP = 2,
+        ITERATE_ALL_ITEMS = 255
+    };
+
+    class FindUsableItemVisitor : public FindItemVisitor {
+    public:
+        FindUsableItemVisitor(Player* bot) : FindItemVisitor()
+        {
+            this->bot = bot;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (bot->CanUseItem(item->GetTemplate()) == EQUIP_ERR_OK)
+                return FindItemVisitor::Visit(item);
+
+            return true;
+        }
+
+    private:
+        Player* bot;
+    };
+
+
+    class FindItemsByQualityVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsByQualityVisitor(uint32 quality, int count) : IterateItemsVisitor()
+        {
+            this->quality = quality;
+            this->count = count;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->Quality != quality)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 quality;
+        int count;
+        list<Item*> result;
+    };
+
+    class FindItemsToTradeByQualityVisitor : public FindItemsByQualityVisitor
+    {
+    public:
+        FindItemsToTradeByQualityVisitor(uint32 quality, int count) : FindItemsByQualityVisitor(quality, count) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            return FindItemsByQualityVisitor::Visit(item);
+        }
+    };
+
+    class FindItemsToTradeByClassVisitor : public IterateItemsVisitor
+    {
+    public:
+        FindItemsToTradeByClassVisitor(uint32 itemClass, uint32 itemSubClass, int count)
+            : IterateItemsVisitor(), count(count), itemClass(itemClass), itemSubClass(itemSubClass) {}
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->IsSoulBound())
+                return true;
+
+            if (item->GetTemplate()->Class != itemClass || item->GetTemplate()->SubClass != itemSubClass)
+                return true;
+
+            if (result.size() >= (size_t)count)
+                return false;
+
+            result.push_back(item);
+            return true;
+        }
+
+        list<Item*>& GetResult()
+        {
+            return result;
+        }
+
+    private:
+        uint32 itemClass;
+        uint32 itemSubClass;
+        int count;
+        list<Item*> result;
+    };
+
+    class QueryItemCountVisitor : public IterateItemsVisitor
+    {
+    public:
+        QueryItemCountVisitor(uint32 itemId)
+        {
+            count = 0;
+            this->itemId = itemId;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            if (item->GetTemplate()->ItemId == itemId)
+                count += item->GetCount();
+
+            return true;
+        }
+
+        int GetCount() { return count; }
+
+    protected:
+        int count;
+        uint32 itemId;
+    };
+
+
+    class QueryNamedItemCountVisitor : public QueryItemCountVisitor
+    {
+    public:
+        QueryNamedItemCountVisitor(string name) : QueryItemCountVisitor(0)
+        {
+            this->name = name;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            const ItemTemplate* proto = item->GetTemplate();
+            if (proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str()))
+                count += item->GetCount();
+
+            return true;
+        }
+
+    private:
+        string name;
+    };
+
+    class FindUsableNamedItemVisitor : public FindUsableItemVisitor {
+    public:
+        FindUsableNamedItemVisitor(Player* bot, string name) : FindUsableItemVisitor(bot)
+        {
+            this->name = name;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto && !proto->Name1.empty() && strstri(proto->Name1.c_str(), name.c_str());
+        }
+
+    private:
+        string name;
+    };
+
+    class FindItemByIdVisitor : public FindItemVisitor {
+    public:
+        FindItemByIdVisitor(uint32 id) : FindItemVisitor()
+        {
+            this->id = id;
+        }
+
+        virtual bool Accept(const ItemTemplate* proto)
+        {
+            return proto->ItemId == id;
+        }
+
+    private:
+        uint32 id;
+    };
+
+    class ListItemsVisitor : public IterateItemsVisitor
+    {
+    public:
+        ListItemsVisitor() : IterateItemsVisitor() {}
+
+        map<uint32, int> items;
+
+        virtual bool Visit(Item* item)
+        {
+            uint32 id = item->GetTemplate()->ItemId;
+
+            if (items.find(id) == items.end())
+                items[id] = 0;
+
+            items[id] += item->GetCount();
+            return true;
+        }
+    };
+
+    class ItemCountByQuality : public IterateItemsVisitor
+    {
+    public:
+        ItemCountByQuality() : IterateItemsVisitor()
+        {
+            for (uint32 i = 0; i < MAX_ITEM_QUALITY; ++i)
+                count[i] = 0;
+        }
+
+        virtual bool Visit(Item* item)
+        {
+            count[item->GetTemplate()->Quality]++;
+            return true;
+        }
+
+    public:
+        map<uint32, int> count;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Multiplier.cpp b/src/plugins/playerbot/strategy/Multiplier.cpp
new file mode 100644
index 0000000..893d7f3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Multiplier.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Multiplier.h b/src/plugins/playerbot/strategy/Multiplier.h
new file mode 100644
index 0000000..e86fa05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Multiplier.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "Action.h"
+
+namespace ai
+{
+    class Multiplier : public AiNamedObject
+    {
+    public:
+        Multiplier(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual ~Multiplier() {}
+
+    public:
+        virtual float GetValue(Action* action) { return 1.0f; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/NamedObjectContext.h b/src/plugins/playerbot/strategy/NamedObjectContext.h
new file mode 100644
index 0000000..2ccb68c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/NamedObjectContext.h
@@ -0,0 +1,249 @@
+#pragma once
+
+namespace ai
+{
+    using namespace std;
+
+    class Qualified
+    {
+    public:
+        Qualified() {};
+
+    public:
+        void Qualify(string qualifier) { this->qualifier = qualifier; }
+
+    protected:
+        string qualifier;
+    };
+
+    template <class T> class NamedObjectFactory
+    {
+    protected:
+        typedef T* (*ActionCreator) (PlayerbotAI* ai);
+        map<string, ActionCreator> creators;
+
+    public:
+        T* create(string name, PlayerbotAI* ai)
+        {
+            size_t found = name.find("::");
+            string qualifier;
+            if (found != string::npos)
+            {
+                qualifier = name.substr(found + 2);
+                name = name.substr(0, found);
+            }
+
+            if (creators.find(name) == creators.end())
+                return NULL;
+
+            ActionCreator creator = creators[name];
+            if (!creator)
+                return NULL;
+
+            T *object = (*creator)(ai);
+            Qualified *q = dynamic_cast<Qualified *>(object);
+            if (q)
+                q->Qualify(qualifier);
+
+            return object;
+        }
+
+        set<string> supports()
+        {
+            set<string> keys;
+            for (typename map<string, ActionCreator>::iterator it = creators.begin(); it != creators.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+    };
+
+
+    template <class T> class NamedObjectContext : public NamedObjectFactory<T>
+    {
+    public:
+        NamedObjectContext(bool shared = false, bool supportsSiblings = false) :
+            NamedObjectFactory<T>(), shared(shared), supportsSiblings(supportsSiblings) {}
+
+        T* create(string name, PlayerbotAI* ai)
+        {
+            if (created.find(name) == created.end())
+                return created[name] = NamedObjectFactory<T>::create(name, ai);
+
+            return created[name];
+        }
+
+        virtual ~NamedObjectContext()
+        {
+            Clear();
+        }
+
+        void Clear()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    delete i->second;
+            }
+
+            created.clear();
+        }
+
+        void Update()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename map<string, T*>::iterator i = created.begin(); i != created.end(); i++)
+            {
+                if (i->second)
+                    i->second->Reset();
+            }
+        }
+
+        bool IsShared() { return shared; }
+        bool IsSupportsSiblings() { return supportsSiblings; }
+
+        set<string> GetCreated()
+        {
+            set<string> keys;
+            for (typename map<string, T*>::iterator it = created.begin(); it != created.end(); it++)
+                keys.insert(it->first);
+            return keys;
+        }
+
+    protected:
+        map<string, T*> created;
+        bool shared;
+        bool supportsSiblings;
+    };
+
+    template <class T> class NamedObjectContextList
+    {
+    public:
+        virtual ~NamedObjectContextList()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                NamedObjectContext<T>* context = *i;
+                if (!context->IsShared())
+                    delete context;
+            }
+        }
+
+        void Add(NamedObjectContext<T>* context)
+        {
+            contexts.push_back(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+        void Update()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsShared())
+                    (*i)->Update();
+            }
+        }
+
+        void Reset()
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                (*i)->Reset();
+            }
+        }
+
+        set<string> GetSiblings(string name)
+        {
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                if (!(*i)->IsSupportsSiblings())
+                    continue;
+
+                set<string> supported = (*i)->supports();
+                set<string>::iterator found = supported.find(name);
+                if (found == supported.end())
+                    continue;
+
+                supported.erase(found);
+                return supported;
+            }
+
+            return set<string>();
+        }
+
+        set<string> supports()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> supported = (*i)->supports();
+
+                for (set<string>::iterator j = supported.begin(); j != supported.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+        set<string> GetCreated()
+        {
+            set<string> result;
+
+            for (typename list<NamedObjectContext<T>*>::iterator i = contexts.begin(); i != contexts.end(); i++)
+            {
+                set<string> createdKeys = (*i)->GetCreated();
+
+                for (set<string>::iterator j = createdKeys.begin(); j != createdKeys.end(); j++)
+                    result.insert(*j);
+            }
+            return result;
+        }
+
+    private:
+        list<NamedObjectContext<T>*> contexts;
+    };
+
+    template <class T> class NamedObjectFactoryList
+    {
+    public:
+        virtual ~NamedObjectFactoryList()
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+                delete *i;
+        }
+
+        void Add(NamedObjectFactory<T>* context)
+        {
+            factories.push_front(context);
+        }
+
+        T* GetObject(string name, PlayerbotAI* ai)
+        {
+            for (typename list<NamedObjectFactory<T>*>::iterator i = factories.begin(); i != factories.end(); i++)
+            {
+                T* object = (*i)->create(name, ai);
+                if (object) return object;
+            }
+            return NULL;
+        }
+
+    private:
+        list<NamedObjectFactory<T>*> factories;
+    };
+};
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.cpp b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
new file mode 100644
index 0000000..f987438
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.cpp
@@ -0,0 +1,47 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "PassiveMultiplier.h"
+
+using namespace ai;
+
+list<string> PassiveMultiplier::allowedActions;
+list<string> PassiveMultiplier::allowedParts;
+
+PassiveMultiplier::PassiveMultiplier(PlayerbotAI* ai) : Multiplier(ai, "passive")
+{
+    if (allowedActions.empty())
+    {
+        allowedActions.push_back("co");
+        allowedActions.push_back("nc");
+        allowedActions.push_back("reset ai");
+        allowedActions.push_back("check mount state");
+    }
+
+    if (allowedParts.empty())
+    {
+        allowedParts.push_back("follow");
+        allowedParts.push_back("stay");
+        allowedParts.push_back("chat shortcut");
+    }
+}
+
+float PassiveMultiplier::GetValue(Action* action) {
+    if (!action)
+		return 1.0f;
+
+    string name = action->getName();
+
+    for (list<string>::iterator i = allowedActions.begin(); i != allowedActions.end(); i++)
+    {
+        if (name == *i)
+            return 1.0f;
+    }
+
+    for (list<string>::iterator i = allowedParts.begin(); i != allowedParts.end(); i++)
+    {
+        if (name.find(*i) != string::npos)
+            return 1.0f;
+    }
+
+    return 0;
+}
diff --git a/src/plugins/playerbot/strategy/PassiveMultiplier.h b/src/plugins/playerbot/strategy/PassiveMultiplier.h
new file mode 100644
index 0000000..37985a0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/PassiveMultiplier.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+
+namespace ai
+{
+    class PassiveMultiplier : public Multiplier
+    {
+    public:
+        PassiveMultiplier(PlayerbotAI* ai);
+
+    public:
+        virtual float GetValue(Action* action);
+
+    private:
+        static list<string> allowedActions;
+        static list<string> allowedParts;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/Queue.cpp b/src/plugins/playerbot/strategy/Queue.cpp
new file mode 100644
index 0000000..8553b44
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.cpp
@@ -0,0 +1,81 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Action.h"
+#include "Queue.h"
+
+using namespace ai;
+
+
+void Queue::Push(ActionBasket *action)
+{
+	if (action)
+    {
+        for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+        {
+            ActionBasket* basket = *iter;
+            if (action->getAction()->getName() == basket->getAction()->getName())
+            {
+				if (basket->getRelevance() < action->getRelevance())
+					basket->setRelevance(action->getRelevance());
+                delete action;
+                return;
+            }
+        }
+		actions.push_back(action);
+    }
+}
+
+void Queue::Push(ActionBasket **actions)
+{
+	if (actions)
+	{
+		for (int i=0; i<sizeof(actions)/sizeof(ActionBasket*); i++)
+		{
+			Push(actions[i]);
+		}
+	}
+}
+
+ActionNode* Queue::Pop()
+{
+	float max = -1;
+	ActionBasket* selection = NULL;
+	for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+	{
+		ActionBasket* basket = *iter;
+		if (basket->getRelevance() > max)
+		{
+			max = basket->getRelevance();
+			selection = basket;
+		}
+	}
+	if (selection != NULL)
+	{
+		ActionNode* action = selection->getAction();
+		actions.remove(selection);
+		delete selection;
+		return action;
+	}
+	return NULL;
+}
+
+ActionBasket* Queue::Peek()
+{
+    float max = -1;
+    ActionBasket* selection = NULL;
+    for (std::list<ActionBasket*>::iterator iter = actions.begin(); iter != actions.end(); iter++)
+    {
+        ActionBasket* basket = *iter;
+        if (basket->getRelevance() > max)
+        {
+            max = basket->getRelevance();
+            selection = basket;
+        }
+    }
+    return selection;
+}
+
+int Queue::Size()
+{
+	return actions.size();
+}
diff --git a/src/plugins/playerbot/strategy/Queue.h b/src/plugins/playerbot/strategy/Queue.h
new file mode 100644
index 0000000..b70a526
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Queue.h
@@ -0,0 +1,21 @@
+#include "ActionBasket.h"
+
+#pragma once
+namespace ai
+{
+class Queue
+{
+public:
+    Queue(void) {}
+public:
+    ~Queue(void) {}
+public:
+	void Push(ActionBasket *action);
+	void Push(ActionBasket **actions);
+	ActionNode* Pop();
+    ActionBasket* Peek();
+	int Size();
+private:
+	std::list<ActionBasket*> actions;
+};
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/Strategy.cpp b/src/plugins/playerbot/strategy/Strategy.cpp
new file mode 100644
index 0000000..5275ae0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.cpp
@@ -0,0 +1,117 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Strategy.h"
+#include "NamedObjectContext.h"
+
+using namespace ai;
+using namespace std;
+
+
+class ActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ActionNodeFactoryInternal()
+    {
+        creators["melee"] = &melee;
+        creators["healthstone"] = &healthstone;
+        creators["be near"] = &follow_master_random;
+        creators["attack anything"] = &attack_anything;
+        creators["move random"] = &move_random;
+        creators["move to loot"] = &move_to_loot;
+        creators["food"] = &food;
+        creators["drink"] = &drink;
+        creators["mana potion"] = &mana_potion;
+        creators["healing potion"] = &healing_potion;
+        creators["flee"] = &flee;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* healthstone(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healthstone",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* follow_master_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("be near",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("follow"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* attack_anything(PlayerbotAI* ai)
+    {
+        return new ActionNode ("attack anything",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* move_random(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move random",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("stay line"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* move_to_loot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("move to loot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* food(PlayerbotAI* ai)
+    {
+        return new ActionNode ("food",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* drink(PlayerbotAI* ai)
+    {
+        return new ActionNode ("drink",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* healing_potion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("healing potion",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("food"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flee",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+Strategy::Strategy(PlayerbotAI* ai) : PlayerbotAIAware(ai)
+{
+    actionNodeFactories.Add(new ActionNodeFactoryInternal());
+}
+
+ActionNode* Strategy::GetAction(string name)
+{
+    return actionNodeFactories.GetObject(name, ai);
+}
+
diff --git a/src/plugins/playerbot/strategy/Strategy.h b/src/plugins/playerbot/strategy/Strategy.h
new file mode 100644
index 0000000..12e98eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Strategy.h
@@ -0,0 +1,55 @@
+#pragma once
+#include "Action.h"
+#include "Multiplier.h"
+#include "Trigger.h"
+#include "NamedObjectContext.h"
+
+namespace ai
+{
+	enum StrategyType
+	{
+		STRATEGY_TYPE_GENERIC = 0,
+		STRATEGY_TYPE_COMBAT = 1,
+		STRATEGY_TYPE_NONCOMBAT = 2,
+		STRATEGY_TYPE_TANK = 4,
+		STRATEGY_TYPE_DPS = 8,
+		STRATEGY_TYPE_HEAL = 16,
+		STRATEGY_TYPE_RANGED = 32,
+		STRATEGY_TYPE_MELEE = 64
+	};
+
+	enum ActionPriority
+	{
+	    ACTION_IDLE = 0,
+	    ACTION_NORMAL = 10,
+	    ACTION_HIGH = 20,
+	    ACTION_MOVE = 30,
+	    ACTION_INTERRUPT = 40,
+	    ACTION_DISPEL = 50,
+	    ACTION_LIGHT_HEAL = 60,
+	    ACTION_MEDIUM_HEAL = 70,
+	    ACTION_CRITICAL_HEAL = 80,
+	    ACTION_EMERGENCY = 90
+	};
+
+    class Strategy : public PlayerbotAIAware
+    {
+    public:
+        Strategy(PlayerbotAI* ai);
+        virtual ~Strategy() {}
+
+    public:
+        virtual NextAction** getDefaultActions() { return NULL; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers) {}
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers) {}
+        virtual string getName() = 0;
+		virtual int GetType() { return STRATEGY_TYPE_GENERIC; }
+        virtual ActionNode* GetAction(string name);
+        void Update() {}
+        void Reset() {}
+
+    protected:
+        NamedObjectFactoryList<ActionNode> actionNodeFactories;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/StrategyContext.h b/src/plugins/playerbot/strategy/StrategyContext.h
new file mode 100644
index 0000000..7283ed7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/StrategyContext.h
@@ -0,0 +1,146 @@
+#pragma once
+
+#include "generic/NonCombatStrategy.h"
+#include "generic/RacialsStrategy.h"
+#include "generic/ChatCommandHandlerStrategy.h"
+#include "generic/WorldPacketHandlerStrategy.h"
+#include "generic/DeadStrategy.h"
+#include "generic/QuestStrategies.h"
+#include "generic/LootNonCombatStrategy.h"
+#include "generic/DuelStrategy.h"
+#include "generic/KiteStrategy.h"
+#include "generic/FleeStrategy.h"
+#include "generic/FollowMasterStrategy.h"
+#include "generic/RunawayStrategy.h"
+#include "generic/StayStrategy.h"
+#include "generic/UseFoodStrategy.h"
+#include "generic/ConserveManaStrategy.h"
+#include "generic/EmoteStrategy.h"
+#include "generic/AttackRtiStrategy.h"
+#include "generic/AttackWeakStrategy.h"
+#include "generic/TankAoeStrategy.h"
+#include "generic/TankAssistStrategy.h"
+#include "generic/DpsAoeStrategy.h"
+#include "generic/DpsAssistStrategy.h"
+#include "generic/PassiveStrategy.h"
+#include "generic/GrindingStrategy.h"
+#include "generic/UsePotionsStrategy.h"
+#include "generic/GuardStrategy.h"
+#include "generic/CastTimeStrategy.h"
+#include "generic/ThreatStrategy.h"
+#include "generic/TellTargetStrategy.h"
+#include "generic/AttackEnemyPlayersStrategy.h"
+#include "generic/MoveRandomStrategy.h"
+
+namespace ai
+{
+    class StrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        StrategyContext()
+        {
+            creators["racials"] = &StrategyContext::racials;
+            creators["loot"] = &StrategyContext::loot;
+            creators["gather"] = &StrategyContext::gather;
+            creators["emote"] = &StrategyContext::emote;
+            creators["passive"] = &StrategyContext::passive;
+            creators["conserve mana"] = &StrategyContext::conserve_mana;
+            creators["food"] = &StrategyContext::food;
+            creators["chat"] = &StrategyContext::chat;
+            creators["default"] = &StrategyContext::world_packet;
+            creators["ready check"] = &StrategyContext::ready_check;
+            creators["dead"] = &StrategyContext::dead;
+            creators["flee"] = &StrategyContext::flee;
+            creators["duel"] = &StrategyContext::duel;
+            creators["kite"] = &StrategyContext::kite;
+            creators["potions"] = &StrategyContext::potions;
+            creators["cast time"] = &StrategyContext::cast_time;
+            creators["threat"] = &StrategyContext::threat;
+            creators["tell target"] = &StrategyContext::tell_target;
+            creators["pvp"] = &StrategyContext::pvp;
+            creators["move random"] = &StrategyContext::move_random;
+            creators["lfg"] = &StrategyContext::lfg;
+        }
+
+    private:
+        static Strategy* tell_target(PlayerbotAI* ai) { return new TellTargetStrategy(ai); }
+        static Strategy* threat(PlayerbotAI* ai) { return new ThreatStrategy(ai); }
+        static Strategy* cast_time(PlayerbotAI* ai) { return new CastTimeStrategy(ai); }
+        static Strategy* potions(PlayerbotAI* ai) { return new UsePotionsStrategy(ai); }
+        static Strategy* kite(PlayerbotAI* ai) { return new KiteStrategy(ai); }
+        static Strategy* duel(PlayerbotAI* ai) { return new DuelStrategy(ai); }
+        static Strategy* flee(PlayerbotAI* ai) { return new FleeStrategy(ai); }
+        static Strategy* dead(PlayerbotAI* ai) { return new DeadStrategy(ai); }
+        static Strategy* racials(PlayerbotAI* ai) { return new RacialsStrategy(ai); }
+        static Strategy* loot(PlayerbotAI* ai) { return new LootNonCombatStrategy(ai); }
+        static Strategy* gather(PlayerbotAI* ai) { return new GatherStrategy(ai); }
+        static Strategy* emote(PlayerbotAI* ai) { return new EmoteStrategy(ai); }
+        static Strategy* passive(PlayerbotAI* ai) { return new PassiveStrategy(ai); }
+        static Strategy* conserve_mana(PlayerbotAI* ai) { return new ConserveManaStrategy(ai); }
+        static Strategy* food(PlayerbotAI* ai) { return new UseFoodStrategy(ai); }
+        static Strategy* chat(PlayerbotAI* ai) { return new ChatCommandHandlerStrategy(ai); }
+        static Strategy* world_packet(PlayerbotAI* ai) { return new WorldPacketHandlerStrategy(ai); }
+        static Strategy* ready_check(PlayerbotAI* ai) { return new ReadyCheckStrategy(ai); }
+        static Strategy* pvp(PlayerbotAI* ai) { return new AttackEnemyPlayersStrategy(ai); }
+        static Strategy* move_random(PlayerbotAI* ai) { return new MoveRandomStrategy(ai); }
+        static Strategy* lfg(PlayerbotAI* ai) { return new LfgStrategy(ai); }
+    };
+
+    class MovementStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        MovementStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["follow"] = &MovementStrategyContext::follow_master;
+            creators["stay"] = &MovementStrategyContext::stay;
+            creators["runaway"] = &MovementStrategyContext::runaway;
+            creators["flee from adds"] = &MovementStrategyContext::flee_from_adds;
+            creators["guard"] = &MovementStrategyContext::guard;
+        }
+
+    private:
+        static Strategy* guard(PlayerbotAI* ai) { return new GuardStrategy(ai); }
+        static Strategy* follow_master(PlayerbotAI* ai) { return new FollowMasterStrategy(ai); }
+        static Strategy* stay(PlayerbotAI* ai) { return new StayStrategy(ai); }
+        static Strategy* runaway(PlayerbotAI* ai) { return new RunawayStrategy(ai); }
+        static Strategy* flee_from_adds(PlayerbotAI* ai) { return new FleeFromAddsStrategy(ai); }
+    };
+
+    class AssistStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        AssistStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["dps assist"] = &AssistStrategyContext::dps_assist;
+            creators["dps aoe"] = &AssistStrategyContext::dps_aoe;
+            creators["tank assist"] = &AssistStrategyContext::tank_assist;
+            creators["tank aoe"] = &AssistStrategyContext::tank_aoe;
+            creators["attack weak"] = &AssistStrategyContext::attack_weak;
+            creators["grind"] = &AssistStrategyContext::grind;
+            creators["attack rti"] = &AssistStrategyContext::attack_rti;
+        }
+
+    private:
+        static Strategy* dps_assist(PlayerbotAI* ai) { return new DpsAssistStrategy(ai); }
+        static Strategy* dps_aoe(PlayerbotAI* ai) { return new DpsAoeStrategy(ai); }
+        static Strategy* tank_assist(PlayerbotAI* ai) { return new TankAssistStrategy(ai); }
+        static Strategy* tank_aoe(PlayerbotAI* ai) { return new TankAoeStrategy(ai); }
+        static Strategy* attack_weak(PlayerbotAI* ai) { return new AttackWeakStrategy(ai); }
+        static Strategy* grind(PlayerbotAI* ai) { return new GrindingStrategy(ai); }
+        static Strategy* attack_rti(PlayerbotAI* ai) { return new AttackRtiStrategy(ai); }
+    };
+
+    class QuestStrategyContext : public NamedObjectContext<Strategy>
+    {
+    public:
+        QuestStrategyContext() : NamedObjectContext<Strategy>(false, true)
+        {
+            creators["quest"] = &QuestStrategyContext::quest;
+            creators["accept all quests"] = &QuestStrategyContext::accept_all_quests;
+        }
+
+    private:
+        static Strategy* quest(PlayerbotAI* ai) { return new DefaultQuestStrategy(ai); }
+        static Strategy* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsStrategy(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/Trigger.cpp b/src/plugins/playerbot/strategy/Trigger.cpp
new file mode 100644
index 0000000..7487f33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.cpp
@@ -0,0 +1,27 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Trigger.h"
+#include "Action.h"
+
+using namespace ai;
+
+Event Trigger::Check()
+{
+	if (IsActive())
+	{
+		Event event(getName());
+		return event;
+	}
+	Event event;
+	return event;
+}
+
+Value<Unit*>* Trigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>(GetTargetName());
+}
+
+Unit* Trigger::GetTarget()
+{
+    return GetTargetValue()->Get();
+}
diff --git a/src/plugins/playerbot/strategy/Trigger.h b/src/plugins/playerbot/strategy/Trigger.h
new file mode 100644
index 0000000..2ae7276
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Trigger.h
@@ -0,0 +1,84 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+
+#define NEXT_TRIGGERS(name, relevance) \
+    virtual NextAction* getNextAction() { return new NextAction(name, relevance); }
+
+#define BEGIN_TRIGGER(clazz, super) \
+class clazz : public super \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : super(ai) {} \
+    public: \
+        virtual bool IsActive();
+
+#define END_TRIGGER() \
+    };
+
+namespace ai
+{
+    class Trigger : public AiNamedObject
+	{
+	public:
+        Trigger(PlayerbotAI* ai, string name = "trigger", int checkInterval = 1) : AiNamedObject(ai, name) {
+			this->checkInterval = checkInterval;
+			ticksElapsed = 0;
+        }
+        virtual ~Trigger() {}
+
+	public:
+        virtual Event Check();
+        virtual void ExternalEvent(string param, Player* owner = NULL) {}
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL) {}
+        virtual bool IsActive() { return false; }
+        virtual NextAction** getHandlers() { return NULL; }
+        void Update() {}
+        virtual void Reset() {}
+        virtual Unit* GetTarget();
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string GetTargetName() { return "self target"; }
+
+		bool needCheck() {
+			if (++ticksElapsed >= checkInterval) {
+				ticksElapsed = 0;
+				return true;
+			}
+			return false;
+		}
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+	};
+
+
+    class TriggerNode
+    {
+    public:
+        TriggerNode(string name, NextAction** handlers = NULL)
+        {
+            this->name = name;
+            this->handlers = handlers;
+            this->trigger = NULL;
+        }
+        virtual ~TriggerNode()
+        {
+            NextAction::destroy(handlers);
+        }
+
+    public:
+        Trigger* getTrigger() { return trigger; }
+        void setTrigger(Trigger* trigger) { this->trigger = trigger; }
+        string getName() { return name; }
+
+    public:
+        NextAction** getHandlers() { return NextAction::merge(NextAction::clone(handlers), trigger->getHandlers()); }
+
+    private:
+        Trigger* trigger;
+        NextAction** handlers;
+        std::string name;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/Value.cpp b/src/plugins/playerbot/strategy/Value.cpp
new file mode 100644
index 0000000..8b87c26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.cpp
@@ -0,0 +1,5 @@
+#include "../../pchdef.h"
+#include "../playerbot.h"
+#include "Value.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/Value.h b/src/plugins/playerbot/strategy/Value.h
new file mode 100644
index 0000000..930e3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/Value.h
@@ -0,0 +1,177 @@
+#pragma once
+#include "Action.h"
+#include "Event.h"
+#include "../PlayerbotAIAware.h"
+#include "AiObject.h"
+
+namespace ai
+{
+    class UntypedValue : public AiNamedObject
+    {
+    public:
+        UntypedValue(PlayerbotAI* ai, string name) : AiNamedObject(ai, name) {}
+        virtual void Update() {}
+        virtual void Reset() {}
+        virtual string Format() { return "?"; }
+    };
+
+    template<class T>
+    class Value
+    {
+    public:
+        virtual T Get() = 0;
+        virtual void Set(T value) = 0;
+        operator T() { return Get(); }
+    };
+
+    template<class T>
+    class CalculatedValue : public UntypedValue, public Value<T>
+	{
+	public:
+        CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) : UntypedValue(ai, name),
+            checkInterval(checkInterval), ticksElapsed(checkInterval)
+        { }
+        virtual ~CalculatedValue() {}
+
+	public:
+        virtual T Get()
+        {
+            if (ticksElapsed >= checkInterval) {
+                ticksElapsed = 0;
+                value = Calculate();
+            }
+            return value;
+        }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update()
+        {
+            if (ticksElapsed < checkInterval) {
+                ticksElapsed++;
+            }
+        }
+
+    protected:
+        virtual T Calculate() = 0;
+
+    protected:
+		int checkInterval;
+		int ticksElapsed;
+        T value;
+	};
+
+    class Uint8CalculatedValue : public CalculatedValue<uint8>
+    {
+    public:
+        Uint8CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint8>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class Uint32CalculatedValue : public CalculatedValue<uint32>
+    {
+    public:
+        Uint32CalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<uint32>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << (int)Calculate();
+            return out.str();
+        }
+    };
+
+    class FloatCalculatedValue : public CalculatedValue<float>
+    {
+    public:
+        FloatCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<float>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << Calculate();
+            return out.str();
+        }
+    };
+
+    class BoolCalculatedValue : public CalculatedValue<bool>
+    {
+    public:
+        BoolCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<bool>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            return Calculate() ? "true" : "false";
+        }
+    };
+
+    class UnitCalculatedValue : public CalculatedValue<Unit*>
+    {
+    public:
+        UnitCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<Unit*>(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Calculate();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+
+    class ObjectGuidListCalculatedValue : public CalculatedValue<list<ObjectGuid> >
+    {
+    public:
+        ObjectGuidListCalculatedValue(PlayerbotAI* ai, string name = "value", int checkInterval = 1) :
+            CalculatedValue<list<ObjectGuid> >(ai, name, checkInterval) {}
+
+        virtual string Format()
+        {
+            ostringstream out; out << "{";
+            list<ObjectGuid> guids = Calculate();
+            for (list<ObjectGuid>::iterator i = guids.begin(); i != guids.end(); ++i)
+            {
+                ObjectGuid guid = *i;
+                out << guid.GetRawValue() << ",";
+            }
+            out << "}";
+            return out.str();
+        }
+    };
+
+    template<class T>
+    class ManualSetValue : public UntypedValue, public Value<T>
+    {
+    public:
+        ManualSetValue(PlayerbotAI* ai, T defaultValue, string name = "value") :
+            UntypedValue(ai, name), value(defaultValue), defaultValue(defaultValue) {}
+        virtual ~ManualSetValue() {}
+
+    public:
+        virtual T Get() { return value; }
+        virtual void Set(T value) { this->value = value; }
+        virtual void Update() { }
+        virtual void Reset() { value = defaultValue; }
+
+    protected:
+        T value;
+        T defaultValue;
+    };
+
+    class UnitManualSetValue : public ManualSetValue<Unit*>
+    {
+    public:
+        UnitManualSetValue(PlayerbotAI* ai, Unit* defaultValue, string name = "value") :
+            ManualSetValue<Unit*>(ai, defaultValue, name) {}
+
+        virtual string Format()
+        {
+            Unit* unit = Get();
+            return unit ? unit->GetName() : "<none>";
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
new file mode 100644
index 0000000..461ea7e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptDuelAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptDuelAction : public Action
+    {
+    public:
+        AcceptDuelAction(PlayerbotAI* ai) : Action(ai, "accept duel")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket p(event.getPacket());
+
+            ObjectGuid flagGuid;
+            p >> flagGuid;
+            ObjectGuid playerGuid;
+            p >> playerGuid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_DUEL_ACCEPTED, 8);
+            *packet << flagGuid;
+            bot->GetSession()->QueuePacket(packet);
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
new file mode 100644
index 0000000..096fb84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptInvitationAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Globals/ObjectMgr.h"
+
+namespace ai
+{
+    class AcceptInvitationAction : public Action {
+    public:
+        AcceptInvitationAction(PlayerbotAI* ai) : Action(ai, "accept invitation") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+
+            Group* grp = bot->GetGroupInvite();
+            if (!grp)
+                return false;
+
+            Player* inviter = sObjectMgr->GetPlayerByLowGUID(grp->GetLeaderGUID());
+            if (!inviter)
+                return false;
+
+			if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, inviter))
+            {
+                WorldPacket data(SMSG_GROUP_DECLINE, 10);
+                data << bot->GetName();
+                inviter->GetSession()->SendPacket(&data);
+                bot->UninviteFromGroup();
+                return false;
+            }
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << roles_mask;
+            bot->GetSession()->HandleGroupAcceptOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+                bot->GetPlayerbotAI()->SetMaster(inviter);
+
+            ai->ResetStrategies();
+            ai->TellMaster("Hello");
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
new file mode 100644
index 0000000..af63f76
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.cpp
@@ -0,0 +1,102 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AcceptQuestAction.h"
+
+using namespace ai;
+
+void AcceptAllQuestsAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    AcceptQuest(quest, questGiver->GetGUID());
+}
+
+bool AcceptQuestAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Player *bot = ai->GetBot();
+    uint64 guid;
+    uint32 quest;
+
+    string text = event.getParam();
+    PlayerbotChatHandler ch(master);
+    quest = ch.extractQuestId(text);
+    if (quest)
+    {
+        Unit* npc = master->GetSelectedUnit();
+        if (!npc)
+        {
+            ai->TellMaster("Please select quest giver NPC");
+            return false;
+        }
+    }
+    else if (!event.getPacket().empty())
+    {
+        WorldPacket& p = event.getPacket();
+        p.rpos(0);
+        p >> guid >> quest;
+    }
+    else if (text == "*")
+    {
+        return QuestAction::Execute(event);
+    }
+    else
+        return false;
+
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+    if (!qInfo)
+        return false;
+
+    return AcceptQuest(qInfo, guid);
+}
+
+bool AcceptQuestShareAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    Player *bot = ai->GetBot();
+
+    WorldPacket& p = event.getPacket();
+    p.rpos(0);
+    uint32 quest;
+    p >> quest;
+    Quest const* qInfo = sObjectMgr->GetQuestTemplate(quest);
+
+    if (!qInfo || !bot->GetDivider())
+        return false;
+
+    quest = qInfo->GetQuestId();
+    if( !bot->CanTakeQuest( qInfo, false ) )
+    {
+        // can't take quest
+        bot->SetDivider( ObjectGuid() );
+        ai->TellMaster("I can't take this quest");
+
+        return false;
+    }
+
+    // send msg to quest giving player
+    master->SendPushToPartyResponse( bot, QUEST_PARTY_MSG_ACCEPT_QUEST );
+    bot->SetDivider( ObjectGuid() );
+
+    if( bot->CanAddQuest( qInfo, false ) )
+    {
+        bot->AddQuest( qInfo, master );
+
+        if( bot->CanCompleteQuest( quest ) )
+            bot->CompleteQuest( quest );
+
+        // Runsttren: did not add typeid switch from WorldSession::HandleQuestgiverAcceptQuestOpcode!
+        // I think it's not needed, cause typeid should be TYPEID_PLAYER - and this one is not handled
+        // there and there is no default case also.
+
+        if( qInfo->GetSrcSpell() > 0 )
+            bot->CastSpell( bot, qInfo->GetSrcSpell(), true );
+
+        ai->TellMaster("Quest accepted");
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
new file mode 100644
index 0000000..856c697
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptQuestAction.h
@@ -0,0 +1,27 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class AcceptAllQuestsAction : public QuestAction {
+    public:
+        AcceptAllQuestsAction(PlayerbotAI* ai, string name = "accept all quests") : QuestAction(ai, name) {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+    };
+
+    class AcceptQuestAction : public AcceptAllQuestsAction {
+    public:
+        AcceptQuestAction(PlayerbotAI* ai) : AcceptAllQuestsAction(ai, "accept quest") {}
+        virtual bool Execute(Event event);
+    };
+
+    class AcceptQuestShareAction : public Action {
+    public:
+        AcceptQuestShareAction(PlayerbotAI* ai) : Action(ai, "accept quest share") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
new file mode 100644
index 0000000..77dd0dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AcceptResurrectAction.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AcceptResurrectAction : public Action {
+    public:
+        AcceptResurrectAction(PlayerbotAI* ai) : Action(ai, "accept resurrect") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive())
+                return false;
+
+            WorldPacket p(event.getPacket());
+            p.rpos(0);
+            ObjectGuid guid;
+            p >> guid;
+
+            WorldPacket* const packet = new WorldPacket(CMSG_RESURRECT_RESPONSE, 8+1);
+            *packet << guid;
+            *packet << uint8(1);                        // accept
+            bot->GetSession()->QueuePacket(packet);   // queue the packet to get around race condition
+
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ActionContext.h b/src/plugins/playerbot/strategy/actions/ActionContext.h
new file mode 100644
index 0000000..7e76955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ActionContext.h
@@ -0,0 +1,110 @@
+#pragma once
+
+#include "GenericActions.h"
+#include "NonCombatActions.h"
+#include "EmoteAction.h"
+#include "AddLootAction.h"
+#include "LootAction.h"
+#include "AddLootAction.h"
+#include "StayActions.h"
+#include "FollowActions.h"
+#include "ChangeStrategyAction.h"
+#include "ChooseTargetActions.h"
+#include "SuggestWhatToDoAction.h"
+#include "PositionAction.h"
+#include "AttackAction.h"
+#include "CheckMailAction.h"
+
+namespace ai
+{
+    class ActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ActionContext()
+        {
+            creators["attack"] = &ActionContext::melee;
+            creators["melee"] = &ActionContext::melee;
+            creators["reach spell"] = &ActionContext::ReachSpell;
+            creators["reach melee"] = &ActionContext::ReachMelee;
+            creators["flee"] = &ActionContext::flee;
+            creators["gift of the naaru"] = &ActionContext::gift_of_the_naaru;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["lifeblood"] = &ActionContext::lifeblood;
+            creators["arcane torrent"] = &ActionContext::arcane_torrent;
+            creators["end pull"] = &ActionContext::end_pull;
+            creators["healthstone"] = &ActionContext::healthstone;
+            creators["healing potion"] = &ActionContext::healing_potion;
+            creators["mana potion"] = &ActionContext::mana_potion;
+            creators["food"] = &ActionContext::food;
+            creators["drink"] = &ActionContext::drink;
+            creators["tank assist"] = &ActionContext::tank_assist;
+            creators["dps assist"] = &ActionContext::dps_assist;
+            creators["attack rti target"] = &ActionContext::attack_rti_target;
+            creators["loot"] = &ActionContext::loot;
+            creators["add loot"] = &ActionContext::add_loot;
+            creators["add gathering loot"] = &ActionContext::add_gathering_loot;
+            creators["add all loot"] = &ActionContext::add_all_loot;
+            creators["shoot"] = &ActionContext::shoot;
+            creators["follow"] = &ActionContext::follow;
+            creators["follow"] = &ActionContext::follow;
+            creators["runaway"] = &ActionContext::runaway;
+            creators["stay"] = &ActionContext::stay;
+            creators["attack anything"] = &ActionContext::attack_anything;
+            creators["attack least hp target"] = &ActionContext::attack_least_hp_target;
+            creators["attack enemy player"] = &ActionContext::enemy_player_target;
+            creators["emote"] = &ActionContext::emote;
+            creators["suggest what to do"] = &ActionContext::suggest_what_to_do;
+            creators["move random"] = &ActionContext::move_random;
+            creators["move to loot"] = &ActionContext::move_to_loot;
+            creators["open loot"] = &ActionContext::open_loot;
+            creators["guard"] = &ActionContext::guard;
+            creators["move out of enemy contact"] = &ActionContext::move_out_of_enemy_contact;
+            creators["set facing"] = &ActionContext::set_facing;
+            creators["attack duel opponent"] = &ActionContext::attack_duel_opponent;
+            creators["drop target"] = &ActionContext::drop_target;
+            creators["check mail"] = &ActionContext::check_mail;
+        }
+
+    private:
+        static Action* check_mail(PlayerbotAI* ai) { return new CheckMailAction(ai); }
+        static Action* drop_target(PlayerbotAI* ai) { return new DropTargetAction(ai); }
+        static Action* attack_duel_opponent(PlayerbotAI* ai) { return new AttackDuelOpponentAction(ai); }
+        static Action* guard(PlayerbotAI* ai) { return new GuardAction(ai); }
+        static Action* open_loot(PlayerbotAI* ai) { return new OpenLootAction(ai); }
+        static Action* move_to_loot(PlayerbotAI* ai) { return new MoveToLootAction(ai); }
+        static Action* move_random(PlayerbotAI* ai) { return new MoveRandomAction(ai); }
+        static Action* shoot(PlayerbotAI* ai) { return new CastShootAction(ai); }
+        static Action* melee(PlayerbotAI* ai) { return new MeleeAction(ai); }
+        static Action* ReachSpell(PlayerbotAI* ai) { return new ReachSpellAction(ai); }
+        static Action* ReachMelee(PlayerbotAI* ai) { return new ReachMeleeAction(ai); }
+        static Action* flee(PlayerbotAI* ai) { return new FleeAction(ai); }
+        static Action* gift_of_the_naaru(PlayerbotAI* ai) { return new CastGiftOfTheNaaruAction(ai); }
+        static Action* lifeblood(PlayerbotAI* ai) { return new CastLifeBloodAction(ai); }
+        static Action* arcane_torrent(PlayerbotAI* ai) { return new CastArcaneTorrentAction(ai); }
+        static Action* end_pull(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai, "-pull"); }
+
+        static Action* emote(PlayerbotAI* ai) { return new EmoteAction(ai); }
+        static Action* suggest_what_to_do(PlayerbotAI* ai) { return new SuggestWhatToDoAction(ai); }
+        static Action* attack_anything(PlayerbotAI* ai) { return new AttackAnythingAction(ai); }
+        static Action* attack_least_hp_target(PlayerbotAI* ai) { return new AttackLeastHpTargetAction(ai); }
+        static Action* enemy_player_target(PlayerbotAI* ai) { return new AttackEnemyPlayerAction(ai); }
+        static Action* stay(PlayerbotAI* ai) { return new StayAction(ai); }
+        static Action* runaway(PlayerbotAI* ai) { return new RunAwayAction(ai); }
+        static Action* follow(PlayerbotAI* ai) { return new FollowAction(ai); }
+        static Action* add_gathering_loot(PlayerbotAI* ai) { return new AddGatheringLootAction(ai); }
+        static Action* add_loot(PlayerbotAI* ai) { return new AddLootAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* loot(PlayerbotAI* ai) { return new LootAction(ai); }
+        static Action* dps_assist(PlayerbotAI* ai) { return new DpsAssistAction(ai); }
+        static Action* attack_rti_target(PlayerbotAI* ai) { return new AttackRtiTargetAction(ai); }
+        static Action* tank_assist(PlayerbotAI* ai) { return new TankAssistAction(ai); }
+        static Action* drink(PlayerbotAI* ai) { return new DrinkAction(ai); }
+        static Action* food(PlayerbotAI* ai) { return new EatAction(ai); }
+        static Action* mana_potion(PlayerbotAI* ai) { return new UseManaPotion(ai); }
+        static Action* healing_potion(PlayerbotAI* ai) { return new UseHealingPotion(ai); }
+        static Action* healthstone(PlayerbotAI* ai) { return new UseItemAction(ai, "healthstone"); }
+        static Action* move_out_of_enemy_contact(PlayerbotAI* ai) { return new MoveOutOfEnemyContactAction(ai); }
+        static Action* set_facing(PlayerbotAI* ai) { return new SetFacingTargetAction(ai); }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.cpp b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
new file mode 100644
index 0000000..4d2c3ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AddLootAction.h"
+
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AddLootAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+    if (!guid)
+        return false;
+
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddAllLootAction::Execute(Event event)
+{
+    bool added = false;
+
+    list<ObjectGuid> gos = context->GetValue<list<ObjectGuid> >("nearest game objects")->Get();
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        added |= AddLoot(*i);
+
+    list<ObjectGuid> corpses = context->GetValue<list<ObjectGuid> >("nearest corpses")->Get();
+    for (list<ObjectGuid>::iterator i = corpses.begin(); i != corpses.end(); i++)
+        added |= AddLoot(*i);
+
+    return added;
+}
+
+bool AddLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::isUseful()
+{
+    return AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool AddAllLootAction::AddLoot(ObjectGuid guid)
+{
+    return AI_VALUE(LootObjectStack*, "available loot")->Add(guid);
+}
+
+bool AddGatheringLootAction::AddLoot(ObjectGuid guid)
+{
+    LootObject loot(bot, guid);
+
+    if (loot.IsEmpty() || !loot.GetWorldObject(bot))
+        return false;
+
+    if (loot.skillId == SKILL_NONE)
+        return false;
+
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return AddAllLootAction::AddLoot(guid);
+}
diff --git a/src/plugins/playerbot/strategy/actions/AddLootAction.h b/src/plugins/playerbot/strategy/actions/AddLootAction.h
new file mode 100644
index 0000000..402c50a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AddLootAction.h
@@ -0,0 +1,32 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class AddLootAction : public Action {
+    public:
+        AddLootAction(PlayerbotAI* ai) : Action(ai, "add loot") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class AddAllLootAction : public Action {
+    public:
+        AddAllLootAction(PlayerbotAI* ai, string name = "add all loot") : Action(ai, name) {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+    class AddGatheringLootAction : public AddAllLootAction {
+    public:
+        AddGatheringLootAction(PlayerbotAI* ai) : AddAllLootAction(ai, "add gathering loot") {}
+
+    protected:
+        virtual bool AddLoot(ObjectGuid guid);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
new file mode 100644
index 0000000..45518b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.cpp
@@ -0,0 +1,80 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AreaTriggerAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool ReachAreaTriggerAction::Execute(Event event)
+{
+    uint32 triggerId;
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    p >> triggerId;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+    {
+        WorldPacket p1(CMSG_AREATRIGGER);
+        p1 << triggerId;
+        p1.rpos(0);
+        bot->GetSession()->HandleAreaTriggerOpcode(p1);
+
+        return true;
+    }
+
+    if (bot->GetMapId() != atEntry->mapid || bot->GetDistance(atEntry->x, atEntry->y, atEntry->z) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I won't follow: too far away");
+        return true;
+    }
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+	mm.MovePoint(atEntry->mapid, atEntry->x, atEntry->y, atEntry->z);
+    float distance = bot->GetDistance(atEntry->x, atEntry->y, atEntry->z);
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+    ai->TellMaster("Wait for me");
+    ai->SetNextCheckDelay(delay);
+    context->GetValue<LastMovement&>("last movement")->Get().lastAreaTrigger = triggerId;
+
+    return true;
+}
+
+
+
+bool AreaTriggerAction::Execute(Event event)
+{
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    uint32 triggerId = movement.lastAreaTrigger;
+    movement.lastAreaTrigger = 0;
+
+    AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(triggerId);
+    if(!atEntry)
+        return false;
+
+    AreaTrigger const* at = sObjectMgr->GetAreaTrigger(triggerId);
+    if (!at)
+        return true;
+
+    ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+
+    WorldPacket p(CMSG_AREATRIGGER);
+    p << triggerId;
+    p.rpos(0);
+    bot->GetSession()->HandleAreaTriggerOpcode(p);
+
+    ai->TellMaster("Hello");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
new file mode 100644
index 0000000..de2b63a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AreaTriggerAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class ReachAreaTriggerAction : public MovementAction {
+    public:
+        ReachAreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "reach area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class AreaTriggerAction : public MovementAction {
+    public:
+        AreaTriggerAction(PlayerbotAI* ai) : MovementAction(ai, "area trigger") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.cpp b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
new file mode 100644
index 0000000..ded8aab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.cpp
@@ -0,0 +1,104 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackAction.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../../game/AI/CreatureAI.h"
+#include "../../../Entities/Pet/Pet.h"
+#include "../../LootObjectStack.h"
+
+using namespace ai;
+
+bool AttackAction::Execute(Event event)
+{
+    Unit* target = GetTarget();
+
+    if (!target)
+        return false;
+
+    return Attack(target);
+}
+
+bool AttackMyTargetAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("You have no target");
+        return false;
+    }
+
+    return Attack(target);
+}
+
+bool AttackAction::Attack(Unit* target)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (bot->IsFlying())
+    {
+        if (verbose) ai->TellMaster("I cannot attack in flight");
+        return false;
+    }
+
+    if (!target)
+    {
+        if (verbose) ai->TellMaster("I have no target");
+        return false;
+    }
+
+    ostringstream msg;
+    msg << target->GetName();
+    if (bot->IsFriendlyTo(target))
+    {
+        msg << " is friendly to me";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+    if (!bot->IsWithinLOSInMap(target))
+    {
+        msg << " is not on my sight";
+        if (verbose) ai->TellMaster(msg.str());
+        return false;
+    }
+
+    if (bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+    }
+
+    ObjectGuid guid = target->GetGUID();
+    bot->SetSelection(target->GetGUID());
+
+    Unit* oldTarget = context->GetValue<Unit*>("current target")->Get();
+    context->GetValue<Unit*>("old target")->Set(oldTarget);
+
+    context->GetValue<Unit*>("current target")->Set(target);
+    context->GetValue<LootObjectStack*>("available loot")->Get()->Add(guid);
+
+    Pet* pet = bot->GetPet();
+    if (pet)
+    {
+        pet->SetTarget(target->GetGUID());
+        pet->AI()->EnterCombat(target);
+		pet->GetCharmInfo()->SetIsCommandAttack(true);
+		pet->AI()->AttackStart(target);
+    }
+
+    bot->Attack(target, true);
+    ai->ChangeEngine(BOT_STATE_COMBAT);
+    return true;
+}
+
+bool AttackDuelOpponentAction::isUseful()
+{
+    return AI_VALUE(Unit*, "duel target");
+}
+
+bool AttackDuelOpponentAction::Execute(Event event)
+{
+    return Attack(AI_VALUE(Unit*, "duel target"));
+}
diff --git a/src/plugins/playerbot/strategy/actions/AttackAction.h b/src/plugins/playerbot/strategy/actions/AttackAction.h
new file mode 100644
index 0000000..ede665d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/AttackAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class AttackAction : public MovementAction
+	{
+	public:
+		AttackAction(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Attack(Unit* target);
+    };
+
+    class AttackMyTargetAction : public AttackAction
+    {
+    public:
+        AttackMyTargetAction(PlayerbotAI* ai, string name = "attack my target") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class AttackDuelOpponentAction : public AttackAction
+    {
+    public:
+        AttackDuelOpponentAction(PlayerbotAI* ai, string name = "attack duel opponent") : AttackAction(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.cpp b/src/plugins/playerbot/strategy/actions/BankAction.cpp
new file mode 100644
index 0000000..c7254be
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.cpp
@@ -0,0 +1,168 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BankAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace std;
+using namespace ai;
+
+bool BankAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (!npc || !bot->GetNPCIfCanInteractWith(npc->GetGUID(), UNIT_NPC_FLAG_BANKER))
+            continue;
+
+        return Execute(text, npc);
+    }
+
+    ai->TellMaster("Cannot find banker nearby");
+    return false;
+}
+
+bool BankAction::Execute(string text, Unit* bank)
+{
+    if (text.empty() || text == "?")
+    {
+        ListItems();
+        return true;
+    }
+
+    bool result = false;
+    if (text[0] == '-')
+    {
+        ItemIds found = chat->parseItems(text);
+        for (ItemIds::iterator i = found.begin(); i != found.end(); i++)
+        {
+            uint32 itemId = *i;
+            result &= Withdraw(itemId);
+        }
+    }
+    else
+    {
+        list<Item*> found = parseItems(text);
+        if (found.empty())
+            return false;
+
+        for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        {
+            Item* item = *i;
+            if (!item)
+                continue;
+
+            result &= Deposit(item);
+        }
+    }
+
+    return result;
+}
+
+bool BankAction::Withdraw(const uint32 itemid)
+{
+    Item* pItem = FindItemInBank(itemid);
+    if (!pItem)
+        return false;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanStoreItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->StoreItem(dest, pItem, true);
+
+    std::ostringstream out;
+    out << "got " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " from bank";
+    ai->TellMaster(out.str());
+    return true;
+}
+
+bool BankAction::Deposit(Item* pItem)
+{
+    std::ostringstream out;
+
+    ItemPosCountVec dest;
+    InventoryResult msg = bot->CanBankItem(NULL_BAG, NULL_SLOT, dest, pItem, false);
+    if (msg != EQUIP_ERR_OK)
+    {
+        bot->SendEquipError(msg, pItem, NULL);
+        return false;
+    }
+
+    bot->RemoveItem(pItem->GetBagSlot(), pItem->GetSlot(), true);
+    bot->BankItem(dest, pItem, true);
+
+    out << "put " << chat->formatItem(pItem->GetTemplate(), pItem->GetCount()) << " to bank";
+    ai->TellMaster(out.str());
+	return true;
+}
+
+void BankAction::ListItems()
+{
+    ai->TellMaster("=== Bank ===");
+
+    map<uint32, int> items;
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = static_cast<Bag *>(bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag));
+        if (pBag)
+        {
+            const ItemTemplate* const pBagProto = pBag->GetTemplate();
+            std::string bagName = pBagProto->Name1;
+
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const item = bot->GetItemByPos(bag, slot);
+                if (item)
+                    items[item->GetTemplate()->ItemId] = item->GetCount();
+            }
+        }
+    }
+
+    TellItems(items);
+}
+
+Item* BankAction::FindItemInBank(uint32 ItemId)
+{
+    for (uint8 slot = BANK_SLOT_ITEM_START; slot < BANK_SLOT_ITEM_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+        {
+            const ItemTemplate* const pItemProto = pItem->GetTemplate();
+            if (!pItemProto)
+                continue;
+
+            if (pItemProto->ItemId == ItemId)   // have required item
+                return pItem;
+        }
+    }
+
+    for (uint8 bag = BANK_SLOT_BAG_START; bag < BANK_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag *) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+            for (uint8 slot = 0; slot < pBag->GetBagSize(); ++slot)
+            {
+                Item* const pItem = bot->GetItemByPos(bag, slot);
+                if (pItem)
+                {
+                    const ItemTemplate* const pItemProto = pItem->GetTemplate();
+                    if (!pItemProto)
+                        continue;
+
+                    if (pItemProto->ItemId == ItemId)
+                        return pItem;
+                }
+            }
+    }
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BankAction.h b/src/plugins/playerbot/strategy/actions/BankAction.h
new file mode 100644
index 0000000..6b22095
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BankAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BankAction : public InventoryAction {
+    public:
+        BankAction(PlayerbotAI* ai) : InventoryAction(ai, "bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, Unit* bank);
+        void ListItems();
+        bool Withdraw(const uint32 itemid);
+        bool Deposit(Item* pItem);
+        Item* FindItemInBank(uint32 ItemId);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.cpp b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
new file mode 100644
index 0000000..0675f2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuffAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+class FindBuffVisitor : public IterateItemsVisitor {
+public:
+    FindBuffVisitor(Player* bot) : IterateItemsVisitor(), bot(bot)
+    {
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        if (bot->CanUseItem(item->GetTemplate()) != EQUIP_ERR_OK)
+            return true;
+
+        const ItemTemplate* proto = item->GetTemplate();
+
+        if (proto->Class != ITEM_CLASS_CONSUMABLE)
+            return true;
+
+        if (proto->SubClass != ITEM_SUBCLASS_ELIXIR && 
+            proto->SubClass != ITEM_SUBCLASS_FLASK &&
+            proto->SubClass != ITEM_SUBCLASS_SCROLL && 
+            proto->SubClass != ITEM_SUBCLASS_FOOD &&
+            proto->SubClass != ITEM_SUBCLASS_CONSUMABLE_OTHER &&
+            proto->SubClass != ITEM_SUBCLASS_ITEM_ENHANCEMENT)
+            return true;
+
+        for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+        {
+            uint32 spellId = proto->Spells[i].SpellId;
+            if (!spellId)
+                continue;
+
+            if (bot->HasAura(spellId))
+                return true;
+
+            Item* itemForSpell = *bot->GetPlayerbotAI()->GetAiObjectContext()->GetValue<Item*>("item for spell", spellId);
+            if (itemForSpell && itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                return true;
+        
+            if (items.find(proto->SubClass) == items.end())
+                items[proto->SubClass] = list<Item*>();
+
+            items[proto->SubClass].push_back(item);
+            break;
+        }
+
+        return true;
+    }
+
+public:
+    map<uint32, list<Item*> > items;
+
+private:
+    Player* bot;
+};
+
+void BuffAction::TellHeader(uint32 subClass)
+{
+    switch (subClass)
+    {
+    case ITEM_SUBCLASS_ELIXIR:
+        ai->TellMaster("--- Elixir ---");
+        return;
+    case ITEM_SUBCLASS_FLASK:
+        ai->TellMaster("--- Flask ---");
+        return;
+    case ITEM_SUBCLASS_SCROLL:
+        ai->TellMaster("--- Scroll ---");
+        return;
+    case ITEM_SUBCLASS_FOOD:
+        ai->TellMaster("--- Food ---");
+        return;
+    case ITEM_SUBCLASS_GENERIC:
+        ai->TellMaster("--- Other ---");
+        return;
+    case ITEM_SUBCLASS_ITEM_ENHANCEMENT:
+        ai->TellMaster("--- Enchant ---");
+        return;
+    }
+}
+
+
+bool BuffAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    FindBuffVisitor visitor(bot);
+    IterateItems(&visitor);
+
+    uint32 oldSubClass = -1;
+    for (map<uint32, list<Item*> >::iterator i = visitor.items.begin(); i != visitor.items.end(); ++i)
+    {
+        list<Item*> items = i->second;
+
+        uint32 subClass = i->first;
+        if (oldSubClass != subClass)
+        {
+            if (!items.empty())
+                TellHeader(subClass);
+            oldSubClass = subClass;
+        }
+        for (list<Item*>::iterator j = items.begin(); j != items.end(); ++j)
+        {
+            Item* item = *j;
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate(), item->GetCount());
+            ai->TellMaster(out);
+        }
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuffAction.h b/src/plugins/playerbot/strategy/actions/BuffAction.h
new file mode 100644
index 0000000..da8b6a6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuffAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuffAction : public InventoryAction {
+    public:
+        BuffAction(PlayerbotAI* ai) : InventoryAction(ai, "buff") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellHeader(uint32 subClass);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.cpp b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
new file mode 100644
index 0000000..20d9cea
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "BuyAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool BuyAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    Player* master = GetMaster();
+
+    if (!master)
+        return false;
+
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(vendor->GetGUID(), UNIT_NPC_FLAG_VENDOR);
+    if (!pCreature)
+    {
+        ai->TellMaster("Cannot talk to vendor");
+        return false;
+    }
+
+    VendorItemData const* tItems = pCreature->GetVendorItems();
+    if (!tItems)
+    {
+        ai->TellMaster("This vendor has no items");
+        return false;
+    }
+
+    for (ItemIds::iterator i = itemIds.begin(); i != itemIds.end(); i++)
+    {
+        for (uint32 slot = 0; slot < tItems->GetItemCount(); slot++)
+        {
+            if (tItems->GetItem(slot)->item == *i)
+            {
+                bot->BuyItemFromVendorSlot(vendor->GetGUID(), slot, *i, 1, NULL_BAG, NULL_SLOT);
+                ai->TellMaster("Bought item");
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/BuyAction.h b/src/plugins/playerbot/strategy/actions/BuyAction.h
new file mode 100644
index 0000000..2e0822c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/BuyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class BuyAction : public InventoryAction {
+    public:
+        BuyAction(PlayerbotAI* ai) : InventoryAction(ai, "buy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(FindItemVisitor *visitor, int8 slot);
+        bool TradeItem(const Item& item, int8 slot);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
new file mode 100644
index 0000000..e59110e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.cpp
@@ -0,0 +1,48 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastCustomSpellAction.h"
+
+using namespace ai;
+
+bool CastCustomSpellAction::Execute(Event event)
+{
+    Unit* target = NULL;
+
+    Player* master = GetMaster();
+    if (master)
+        target = master->GetSelectedUnit();
+
+    if (!target)
+        target = bot;
+
+    string text = event.getParam();
+
+    uint32 spell = chat->parseSpell(text);
+
+    ostringstream msg;
+    if (!ai->CanCastSpell(spell, target))
+    {
+        msg << "Cannot cast " << text << " on " << target->GetName();
+        ai->TellMaster(msg.str());
+        return false;
+    }
+
+    bool result = false;
+    if (spell)
+        result = ai->CastSpell(spell, target);
+    else
+        ai->CastSpell(text, target);
+
+    if (result)
+    {
+        msg << "Casting " << text << " on " << target->GetName();
+        ai->TellMasterNoFacing(msg.str());
+    }
+    else
+    {
+        msg << "Cast " << text << " on " << target->GetName() << " is failed";
+        ai->TellMaster(msg.str());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
new file mode 100644
index 0000000..976a9e4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CastCustomSpellAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CastCustomSpellAction : public Action
+    {
+    public:
+        CastCustomSpellAction(PlayerbotAI* ai) : Action(ai, "cast custom spell") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
new file mode 100644
index 0000000..32328db
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeChatAction.h"
+
+
+using namespace ai;
+
+
+bool ChangeChatAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ChatMsg parsed = chat->parseChat(text);
+    if (parsed == CHAT_MSG_SYSTEM)
+    {
+        ostringstream out; out << "Current chat is " << chat->formatChat(*context->GetValue<ChatMsg>("chat"));
+        ai->TellMaster(out);
+    }
+    else
+    {
+        context->GetValue<ChatMsg>("chat")->Set(parsed);
+        ostringstream out; out << "Chat set to " << chat->formatChat(parsed);
+        ai->TellMaster(out);
+    }
+    
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeChatAction.h b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
new file mode 100644
index 0000000..450a81a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeChatAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ChangeChatAction : public Action {
+    public:
+        ChangeChatAction(PlayerbotAI* ai) : Action(ai, "chat") {}
+        virtual bool Execute(Event event);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
new file mode 100644
index 0000000..64538cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeStrategyAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ChangeCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text.empty() ? getName() : text, BOT_STATE_COMBAT);
+    return true;
+}
+
+bool ChangeNonCombatStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    uint32 account = sObjectMgr->GetPlayerAccountIdByGUID(bot->GetGUID());
+    if (sPlayerbotAIConfig.IsInRandomAccountList(account) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        if (text.find("loot") != string::npos || text.find("gather") != string::npos)
+        {
+            ai->TellMaster("You can change any strategy except loot and gather");
+            return false;
+        }
+    }
+
+    ai->ChangeStrategy(text, BOT_STATE_NON_COMBAT);
+    return true;
+}
+
+bool ChangeDeadStrategyAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ai->ChangeStrategy(text, BOT_STATE_DEAD);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
new file mode 100644
index 0000000..9c3f4c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeStrategyAction.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeCombatStrategyAction : public Action {
+	public:
+		ChangeCombatStrategyAction(PlayerbotAI* ai, string name = "co") : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeNonCombatStrategyAction : public Action {
+    public:
+        ChangeNonCombatStrategyAction(PlayerbotAI* ai) : Action(ai, "nc") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+    class ChangeDeadStrategyAction : public Action {
+    public:
+        ChangeDeadStrategyAction(PlayerbotAI* ai) : Action(ai, "dead") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
new file mode 100644
index 0000000..3a7dc71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChangeTalentsAction.h"
+
+using namespace ai;
+
+bool ChangeTalentsAction::Execute(Event event)
+{
+    
+
+    string text = event.getParam();
+    if (text == "1" || text == "primary")
+    {
+        bot->ActivateSpec(0);
+        ai->TellMaster("Primary talents activated");
+    }
+    else if (text == "2" || text == "secondary")
+    {
+        bot->ActivateSpec(1);
+        ai->TellMaster("Secondary talents activated");
+    }
+    else
+    {
+        ostringstream out; 
+        switch (bot->GetActiveSpec())
+        {
+        case 0: out << "Primary";
+            break;
+        default: out << "Secondary";
+            break;
+        }
+        out << " talents are active";
+        ai->TellMaster(out);
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
new file mode 100644
index 0000000..dd9941a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChangeTalentsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class ChangeTalentsAction : public Action {
+	public:
+		ChangeTalentsAction(PlayerbotAI* ai) : Action(ai, "talents") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ChatActionContext.h b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
new file mode 100644
index 0000000..6a0ab6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatActionContext.h
@@ -0,0 +1,184 @@
+#pragma once
+
+#include "ListQuestsActions.h"
+#include "StatsAction.h"
+#include "LeaveGroupAction.h"
+#include "TellReputationAction.h"
+#include "LogLevelAction.h"
+#include "TellLosAction.h"
+#include "DropQuestAction.h"
+#include "QueryQuestAction.h"
+#include "QueryItemUsageAction.h"
+#include "LootStrategyAction.h"
+#include "AddLootAction.h"
+#include "ReleaseSpiritAction.h"
+#include "TeleportAction.h"
+#include "TaxiAction.h"
+#include "RepairAllAction.h"
+#include "UseItemAction.h"
+#include "TellItemCountAction.h"
+#include "RewardAction.h"
+#include "BuyAction.h"
+#include "SellAction.h"
+#include "UnequipAction.h"
+#include "EquipAction.h"
+#include "TradeAction.h"
+#include "ChangeTalentsAction.h"
+#include "ListSpellsAction.h"
+#include "ChangeStrategyAction.h"
+#include "TrainerAction.h"
+#include "ChangeChatAction.h"
+#include "SetHomeAction.h"
+#include "ResetAiAction.h"
+#include "DestroyItemAction.h"
+#include "BuffAction.h"
+#include "AttackAction.h"
+#include "HelpAction.h"
+#include "GuildBankAction.h"
+#include "ChatShortcutActions.h"
+#include "GossipHelloAction.h"
+#include "CastCustomSpellAction.h"
+#include "InviteToGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "RtiAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "BankAction.h"
+#include "PositionAction.h"
+#include "TellTargetAction.h"
+#include "UseMeetingStoneAction.h"
+#include "WhoAction.h"
+#include "SaveManaAction.h"
+#include "../values/Formations.h"
+
+namespace ai
+{
+    class ChatActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        ChatActionContext()
+        {
+            creators["stats"] = &ChatActionContext::stats;
+            creators["quests"] = &ChatActionContext::quests;
+            creators["leave"] = &ChatActionContext::leave;
+            creators["reputation"] = &ChatActionContext::reputation;
+            creators["log"] = &ChatActionContext::log;
+            creators["los"] = &ChatActionContext::los;
+            creators["drop"] = &ChatActionContext::drop;
+            creators["query quest"] = &ChatActionContext::query_quest;
+            creators["query item usage"] = &ChatActionContext::query_item_usage;
+            creators["ll"] = &ChatActionContext::ll;
+            creators["add all loot"] = &ChatActionContext::add_all_loot;
+            creators["release"] = &ChatActionContext::release;
+            creators["teleport"] = &ChatActionContext::teleport;
+            creators["taxi"] = &ChatActionContext::taxi;
+            creators["repair"] = &ChatActionContext::repair;
+            creators["use"] = &ChatActionContext::use;
+            creators["item count"] = &ChatActionContext::item_count;
+            creators["equip"] = &ChatActionContext::equip;
+            creators["unequip"] = &ChatActionContext::unequip;
+            creators["sell"] = &ChatActionContext::sell;
+            creators["buy"] = &ChatActionContext::buy;
+            creators["reward"] = &ChatActionContext::reward;
+            creators["trade"] = &ChatActionContext::trade;
+            creators["talents"] = &ChatActionContext::talents;
+            creators["spells"] = &ChatActionContext::spells;
+            creators["co"] = &ChatActionContext::co;
+            creators["nc"] = &ChatActionContext::nc;
+            creators["dead"] = &ChatActionContext::dead;
+            creators["trainer"] = &ChatActionContext::trainer;
+            creators["attack my target"] = &ChatActionContext::attack_my_target;
+            creators["chat"] = &ChatActionContext::chat;
+            creators["home"] = &ChatActionContext::home;
+            creators["destroy"] = &ChatActionContext::destroy;
+            creators["reset ai"] = &ChatActionContext::reset_ai;
+            creators["buff"] = &ChatActionContext::buff;
+            creators["help"] = &ChatActionContext::help;
+            creators["gb"] = &ChatActionContext::gb;
+            creators["bank"] = &ChatActionContext::bank;
+            creators["follow chat shortcut"] = &ChatActionContext::follow_chat_shortcut;
+            creators["stay chat shortcut"] = &ChatActionContext::stay_chat_shortcut;
+            creators["flee chat shortcut"] = &ChatActionContext::flee_chat_shortcut;
+            creators["runaway chat shortcut"] = &ChatActionContext::runaway_chat_shortcut;
+            creators["grind chat shortcut"] = &ChatActionContext::grind_chat_shortcut;
+            creators["tank attack chat shortcut"] = &ChatActionContext::tank_attack_chat_shortcut;
+            creators["gossip hello"] = &ChatActionContext::gossip_hello;
+            creators["cast custom spell"] = &ChatActionContext::cast_custom_spell;
+            creators["invite"] = &ChatActionContext::invite;
+            creators["spell"] = &ChatActionContext::spell;
+            creators["rti"] = &ChatActionContext::rti;
+            creators["spirit healer"] = &ChatActionContext::spirit_healer;
+            creators["position"] = &ChatActionContext::position;
+            creators["tell target"] = &ChatActionContext::tell_target;
+            creators["summon"] = &ChatActionContext::summon;
+            creators["who"] = &ChatActionContext::who;
+            creators["save mana"] = &ChatActionContext::save_mana;
+            creators["max dps chat shortcut"] = &ChatActionContext::max_dps_chat_shortcut;
+            creators["tell attackers"] = &ChatActionContext::tell_attackers;
+            creators["formation"] = &ChatActionContext::formation;
+        }
+
+    private:
+        static Action* formation(PlayerbotAI* ai) { return new SetFormationAction(ai); }
+        static Action* tell_attackers(PlayerbotAI* ai) { return new TellAttackersAction(ai); }
+        static Action* max_dps_chat_shortcut(PlayerbotAI* ai) { return new MaxDpsChatShortcutAction(ai); }
+        static Action* save_mana(PlayerbotAI* ai) { return new SaveManaAction(ai); }
+        static Action* who(PlayerbotAI* ai) { return new WhoAction(ai); }
+        static Action* summon(PlayerbotAI* ai) { return new SummonAction(ai); }
+        static Action* tell_target(PlayerbotAI* ai) { return new TellTargetAction(ai); }
+        static Action* position(PlayerbotAI* ai) { return new PositionAction(ai); }
+        static Action* spirit_healer(PlayerbotAI* ai) { return new SpiritHealerAction(ai); }
+        static Action* rti(PlayerbotAI* ai) { return new RtiAction(ai); }
+        static Action* invite(PlayerbotAI* ai) { return new InviteToGroupAction(ai); }
+        static Action* spell(PlayerbotAI* ai) { return new TellSpellAction(ai); }
+        static Action* cast_custom_spell(PlayerbotAI* ai) { return new CastCustomSpellAction(ai); }
+        static Action* tank_attack_chat_shortcut(PlayerbotAI* ai) { return new TankAttackChatShortcutAction(ai); }
+        static Action* grind_chat_shortcut(PlayerbotAI* ai) { return new GrindChatShortcutAction(ai); }
+        static Action* flee_chat_shortcut(PlayerbotAI* ai) { return new FleeChatShortcutAction(ai); }
+        static Action* runaway_chat_shortcut(PlayerbotAI* ai) { return new GoawayChatShortcutAction(ai); }
+        static Action* stay_chat_shortcut(PlayerbotAI* ai) { return new StayChatShortcutAction(ai); }
+        static Action* follow_chat_shortcut(PlayerbotAI* ai) { return new FollowChatShortcutAction(ai); }
+        static Action* gb(PlayerbotAI* ai) { return new GuildBankAction(ai); }
+        static Action* bank(PlayerbotAI* ai) { return new BankAction(ai); }
+        static Action* help(PlayerbotAI* ai) { return new HelpAction(ai); }
+        static Action* buff(PlayerbotAI* ai) { return new BuffAction(ai); }
+        static Action* destroy(PlayerbotAI* ai) { return new DestroyItemAction(ai); }
+        static Action* home(PlayerbotAI* ai) { return new SetHomeAction(ai); }
+        static Action* chat(PlayerbotAI* ai) { return new ChangeChatAction(ai); }
+        static Action* attack_my_target(PlayerbotAI* ai) { return new AttackMyTargetAction(ai); }
+        static Action* trainer(PlayerbotAI* ai) { return new TrainerAction(ai); }
+        static Action* co(PlayerbotAI* ai) { return new ChangeCombatStrategyAction(ai); }
+        static Action* nc(PlayerbotAI* ai) { return new ChangeNonCombatStrategyAction(ai); }
+        static Action* dead(PlayerbotAI* ai) { return new ChangeDeadStrategyAction(ai); }
+        static Action* spells(PlayerbotAI* ai) { return new ListSpellsAction(ai); }
+        static Action* talents(PlayerbotAI* ai) { return new ChangeTalentsAction(ai); }
+
+        static Action* equip(PlayerbotAI* ai) { return new EquipAction(ai); }
+        static Action* unequip(PlayerbotAI* ai) { return new UnequipAction(ai); }
+        static Action* sell(PlayerbotAI* ai) { return new SellAction(ai); }
+        static Action* buy(PlayerbotAI* ai) { return new BuyAction(ai); }
+        static Action* reward(PlayerbotAI* ai) { return new RewardAction(ai); }
+        static Action* trade(PlayerbotAI* ai) { return new TradeAction(ai); }
+
+        static Action* item_count(PlayerbotAI* ai) { return new TellItemCountAction(ai); }
+        static Action* use(PlayerbotAI* ai) { return new UseItemAction(ai); }
+        static Action* repair(PlayerbotAI* ai) { return new RepairAllAction(ai); }
+        static Action* taxi(PlayerbotAI* ai) { return new TaxiAction(ai); }
+        static Action* teleport(PlayerbotAI* ai) { return new TeleportAction(ai); }
+        static Action* release(PlayerbotAI* ai) { return new ReleaseSpiritAction(ai); }
+        static Action* query_item_usage(PlayerbotAI* ai) { return new QueryItemUsageAction(ai); }
+        static Action* query_quest(PlayerbotAI* ai) { return new QueryQuestAction(ai); }
+        static Action* drop(PlayerbotAI* ai) { return new DropQuestAction(ai); }
+        static Action* stats(PlayerbotAI* ai) { return new StatsAction(ai); }
+        static Action* quests(PlayerbotAI* ai) { return new ListQuestsAction(ai); }
+        static Action* leave(PlayerbotAI* ai) { return new LeaveGroupAction(ai); }
+        static Action* reputation(PlayerbotAI* ai) { return new TellReputationAction(ai); }
+        static Action* log(PlayerbotAI* ai) { return new LogLevelAction(ai); }
+        static Action* los(PlayerbotAI* ai) { return new TellLosAction(ai); }
+        static Action* ll(PlayerbotAI* ai) { return new LootStrategyAction(ai); }
+        static Action* add_all_loot(PlayerbotAI* ai) { return new AddAllLootAction(ai); }
+        static Action* reset_ai(PlayerbotAI* ai) { return new ResetAiAction(ai); }
+        static Action* gossip_hello(PlayerbotAI* ai) { return new GossipHelloAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
new file mode 100644
index 0000000..e0c3f12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.cpp
@@ -0,0 +1,108 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatShortcutActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool FollowChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not follow you - too far away");
+        return true;
+    }
+    ai->TellMaster("Following");
+    return true;
+}
+
+bool StayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+stay,-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-follow,-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Staying");
+    return true;
+}
+
+bool FleeChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+follow,+passive", BOT_STATE_COMBAT);
+    if (bot->GetMapId() != master->GetMapId() || bot->GetDistance(master) > sPlayerbotAIConfig.sightDistance)
+    {
+        ai->TellMaster("I will not flee with you - too far away");
+        return true;
+    }
+    ai->TellMaster("Fleeing");
+    return true;
+}
+
+bool GoawayChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+runaway", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("+runaway", BOT_STATE_COMBAT);
+    ai->TellMaster("Running away");
+    return true;
+}
+
+bool GrindChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("+grind,-passive", BOT_STATE_NON_COMBAT);
+    ai->TellMaster("Grinding");
+    return true;
+}
+
+bool TankAttackChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!ai->IsTank(bot))
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-passive", BOT_STATE_NON_COMBAT);
+    ai->ChangeStrategy("-passive", BOT_STATE_COMBAT);
+    ai->TellMaster("Attacking");
+    return true;
+}
+
+bool MaxDpsChatShortcutAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    ai->Reset();
+    ai->ChangeStrategy("-threat,-conserve mana,-cast time,+dps debuff", BOT_STATE_COMBAT);
+    ai->TellMaster("Max DPS");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
new file mode 100644
index 0000000..de9a86a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChatShortcutActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class FollowChatShortcutAction : public Action
+    {
+    public:
+        FollowChatShortcutAction(PlayerbotAI* ai) : Action(ai, "follow chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class StayChatShortcutAction : public Action
+    {
+    public:
+        StayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "stay chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class FleeChatShortcutAction : public Action
+    {
+    public:
+        FleeChatShortcutAction(PlayerbotAI* ai) : Action(ai, "flee chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GoawayChatShortcutAction : public Action
+    {
+    public:
+        GoawayChatShortcutAction(PlayerbotAI* ai) : Action(ai, "runaway chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class GrindChatShortcutAction : public Action
+    {
+    public:
+        GrindChatShortcutAction(PlayerbotAI* ai) : Action(ai, "grind chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TankAttackChatShortcutAction : public Action
+    {
+    public:
+        TankAttackChatShortcutAction(PlayerbotAI* ai) : Action(ai, "tank attack chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MaxDpsChatShortcutAction : public Action
+    {
+    public:
+        MaxDpsChatShortcutAction(PlayerbotAI* ai) : Action(ai, "max dps chat shortcut") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
new file mode 100644
index 0000000..c5aa48f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CheckMailAction.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+bool CheckMailAction::Execute(Event event)
+{
+    if (!bot->IsMailsLoaded())
+    {
+        WorldPacket p;
+        bot->GetSession()->HandleQueryNextMailTime(p);
+    }
+
+    if (!bot->GetMailSize())
+        return false;
+
+    list<uint32> ids;
+    for (PlayerMails::iterator i = bot->GetMailBegin(); i != bot->GetMailEnd(); ++i)
+    {
+        Mail* mail = *i;
+
+        if (!mail || mail->state == MAIL_STATE_DELETED)
+            continue;
+
+        Player* owner = sObjectMgr->GetPlayerByLowGUID(mail->sender);
+        if (!owner)
+            continue;
+
+        ProcessMail(mail, owner);
+        ids.push_back(mail->messageID);
+        mail->state = MAIL_STATE_DELETED;
+    }
+
+    for (list<uint32>::iterator i = ids.begin(); i != ids.end(); ++i)
+    {
+        uint32 id = *i;
+        bot->SendMailResult(id, MAIL_DELETED, MAIL_OK);
+        SQLTransaction tran = CharacterDatabase.BeginTransaction();
+        CharacterDatabase.PExecute("DELETE FROM mail WHERE id = '%u'", id);
+        CharacterDatabase.PExecute("DELETE FROM mail_items WHERE mail_id = '%u'", id);
+        CharacterDatabase.CommitTransaction(tran);
+        bot->RemoveMail(id);
+    }
+
+    return true;
+}
+
+
+void CheckMailAction::ProcessMail(Mail* mail, Player* owner)
+{
+    if (!mail->HasItems())
+        return;
+
+    for (MailItemInfoVec::iterator i = mail->items.begin(); i != mail->items.end(); ++i)
+    {
+        Item *item = bot->GetMItem(i->item_guid);
+        if (!item)
+            continue;
+
+        sGuildTaskMgr.CheckItemTask(i->item_template, item->GetCount(), owner, bot, true);
+        bot->RemoveMItem(i->item_guid);
+        item->DestroyForPlayer(bot);
+    }
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/CheckMailAction.h b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
new file mode 100644
index 0000000..9da88a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMailAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class CheckMailAction : public Action
+    {
+    public:
+        CheckMailAction(PlayerbotAI* ai) : Action(ai, "check mail") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ProcessMail(Mail* mail, Player* owner);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
new file mode 100644
index 0000000..15cd6b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.cpp
@@ -0,0 +1,80 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../../Spells/Auras/SpellAuraEffects.h"
+#include "CheckMountStateAction.h"
+
+using namespace ai;
+
+uint64 extractGuid(WorldPacket& packet);
+
+bool CheckMountStateAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!bot->GetGroup() || !master)
+        return false;
+
+    if (bot->IsFlying())
+        return false;
+
+    if (master->IsMounted() && !bot->IsMounted())
+    {
+        return Mount();
+    }
+    else if (!master->IsMounted() && bot->IsMounted())
+    {
+        WorldPacket emptyPacket;
+        bot->GetSession()->HandleCancelMountAuraOpcode(emptyPacket);
+        return true;
+    }
+    return false;
+}
+
+
+bool CheckMountStateAction::Mount()
+{
+    Player* master = GetMaster();
+    ai->RemoveShapeshift();
+
+    Unit::AuraEffectList const& auras = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+    const SpellInfo* masterSpell = auras.front()->GetSpellInfo();
+    int32 masterSpeed = max(masterSpell->Effects[1].BasePoints, masterSpell->Effects[2].BasePoints);
+
+    map<uint32, map<int32, vector<uint32> > > allSpells;
+    for(PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+        const SpellInfo* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+
+        if (!spellInfo || spellInfo->Effects[0].ApplyAuraName != SPELL_AURA_MOUNTED)
+            continue;
+
+        if(itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || spellInfo->IsPassive())
+            continue;
+
+        int32 effect = max(spellInfo->Effects[1].BasePoints, spellInfo->Effects[2].BasePoints);
+        if (effect < masterSpeed)
+            continue;
+
+        uint32 index = (spellInfo->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+                spellInfo->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+        allSpells[index][effect].push_back(spellId);
+    }
+
+    int masterMountType = (masterSpell->Effects[1].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED ||
+            masterSpell->Effects[2].ApplyAuraName == SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ? 1 : 0;
+
+    map<int32, vector<uint32> >& spells = allSpells[masterMountType];
+    for (map<int32,vector<uint32> >::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+		vector<uint32>& ids = i->second;
+        int index = urand(0, ids.size() - 1);
+        int idsSize = ids.size();
+        if (index >= idsSize)
+            continue;
+
+        ai->CastSpell(ids[index], bot);
+        return true;
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
new file mode 100644
index 0000000..c5b087e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/CheckMountStateAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class CheckMountStateAction : public Action {
+    public:
+        CheckMountStateAction(PlayerbotAI* ai) : Action(ai, "check mount state") {}
+
+        virtual bool Execute(Event event);
+
+    private:
+        bool Mount();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
new file mode 100644
index 0000000..d0b1a9a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ChooseTargetActions.h
@@ -0,0 +1,80 @@
+#pragma once
+
+#include "../Action.h"
+#include "AttackAction.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+
+namespace ai
+{
+    class DpsAssistAction : public AttackAction
+    {
+    public:
+        DpsAssistAction(PlayerbotAI* ai) : AttackAction(ai, "dps assist") {}
+
+        virtual string GetTargetName() { return "dps target"; }
+    };
+
+    class TankAssistAction : public AttackAction
+    {
+    public:
+        TankAssistAction(PlayerbotAI* ai) : AttackAction(ai, "tank assist") {}
+        virtual string GetTargetName() { return "tank target"; }
+    };
+
+    class AttackAnythingAction : public AttackAction
+    {
+    public:
+        AttackAnythingAction(PlayerbotAI* ai) : AttackAction(ai, "attack anything") {}
+        virtual string GetTargetName() { return "grind target"; }
+        virtual bool Execute(Event event)
+        {
+            return AttackAction::Execute(event);
+        }
+        virtual bool isUseful() {
+            return GetTarget() &&
+                (AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana)) || AI_VALUE2(bool, "combat", "self target");
+        }
+        virtual bool isPossible()
+        {
+            return AttackAction::isPossible() && GetTarget();
+        }
+    };
+
+    class AttackLeastHpTargetAction : public AttackAction
+    {
+    public:
+        AttackLeastHpTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack least hp target") {}
+        virtual string GetTargetName() { return "least hp target"; }
+    };
+
+    class AttackEnemyPlayerAction : public AttackAction
+    {
+    public:
+        AttackEnemyPlayerAction(PlayerbotAI* ai) : AttackAction(ai, "attack enemy player") {}
+        virtual string GetTargetName() { return "enemy player target"; }
+    };
+
+    class AttackRtiTargetAction : public AttackAction
+    {
+    public:
+        AttackRtiTargetAction(PlayerbotAI* ai) : AttackAction(ai, "attack rti target") {}
+        virtual string GetTargetName() { return "rti target"; }
+    };
+
+    class DropTargetAction : public Action
+    {
+    public:
+        DropTargetAction(PlayerbotAI* ai) : Action(ai, "drop target") {}
+
+        virtual bool Execute(Event event)
+        {
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid());
+            ai->ChangeEngine(BOT_STATE_NON_COMBAT);
+            ai->InterruptSpell();
+			return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
new file mode 100644
index 0000000..9167182
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DestroyItemAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool DestroyItemAction::Execute(Event event)
+{
+    string text = event.getParam();
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        DestroyItem(&visitor);
+    }
+
+    return true;
+}
+
+void DestroyItemAction::DestroyItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+		Item* item = *i;
+        bot->DestroyItem(item->GetBagSlot(),item->GetSlot(), true);
+        ostringstream out; out << chat->formatItem(item->GetTemplate()) << " destroyed";
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/DestroyItemAction.h b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
new file mode 100644
index 0000000..ad1ab05
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DestroyItemAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class DestroyItemAction : public InventoryAction {
+    public:
+        DestroyItemAction(PlayerbotAI* ai) : InventoryAction(ai, "destroy") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void DestroyItem(FindItemVisitor* visitor);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
new file mode 100644
index 0000000..e94e779
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DropQuestAction.h"
+
+
+using namespace ai;
+
+bool DropQuestAction::Execute(Event event)
+{
+    string link = event.getParam();
+    if (!GetMaster())
+        return false;
+
+    PlayerbotChatHandler handler(GetMaster());
+    uint32 entry = handler.extractQuestId(link);
+    if (!entry)
+        return false;
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(entry);
+    if (!quest)
+        return false;
+
+    // remove all quest entries for 'entry' from quest log
+    for (uint8 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 logQuest = bot->GetQuestSlotQuestId(slot);
+        if (logQuest == entry)
+        {
+            bot->SetQuestSlot(slot, 0);
+
+            // we ignore unequippable quest items in this case, its' still be equipped
+            bot->TakeQuestSourceItem(logQuest, false);
+
+            if (quest->HasFlag(QUEST_FLAGS_FLAGS_PVP))
+            {
+                bot->pvpInfo.IsHostile = bot->pvpInfo.IsInHostileArea || bot->HasPvPForcingQuest();
+                bot->UpdatePvPState();
+            }
+        }
+    }
+
+    bot->RemoveActiveQuest(entry, false);
+    bot->RemoveRewardedQuest(entry);
+
+    ai->TellMaster("Quest removed");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/DropQuestAction.h b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
new file mode 100644
index 0000000..af5d4ca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/DropQuestAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class DropQuestAction : public Action {
+    public:
+        DropQuestAction(PlayerbotAI* ai) : Action(ai, "drop quest") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.cpp b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
new file mode 100644
index 0000000..b609032
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteAction.h"
+
+using namespace ai;
+
+map<string, uint32> EmoteAction::emotes;
+
+bool EmoteAction::Execute(Event event)
+{
+    if (emotes.empty())
+        InitEmotes();
+
+    uint32 emote = 0;
+
+    string param = event.getParam();
+	if (param.empty() || emotes.find(param) == emotes.end())
+    {
+        int index = rand() % emotes.size();
+		for (map<string, uint32>::iterator i = emotes.begin(); i != emotes.end() && index; ++i, --index)
+			emote = i->second;
+    }
+    else
+    {
+        emote = emotes[param];
+    }
+
+	bot->CastStop();
+	ai->InterruptSpell();
+	bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    Player* master = GetMaster();
+	if (master)
+	{
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            Unit* oldSelection = bot->GetSelectedUnit();
+            bot->SetSelection(masterSelection->GetGUID());
+            bot->HandleEmoteCommand(emote);
+            if (oldSelection)
+                bot->SetSelection(oldSelection->GetGUID());
+            return true;
+        }
+	}
+
+    bot->HandleEmoteCommand(emote);
+    return true;
+}
+
+void EmoteAction::InitEmotes()
+{
+    emotes["cower"] = EMOTE_ONESHOT_COWER;
+    emotes["dance"] = EMOTE_ONESHOT_DANCE;
+    emotes["drown"] = EMOTE_ONESHOT_DROWN;
+    emotes["emerge"] = EMOTE_ONESHOT_EMERGE;
+    emotes["land"] = EMOTE_ONESHOT_LAND;
+    emotes["laugh_nosheathe"] = EMOTE_ONESHOT_LAUGH_NO_SHEATHE;
+    emotes["liftoff"] = EMOTE_ONESHOT_LIFTOFF;
+    emotes["loot"] = EMOTE_ONESHOT_LOOT;
+    emotes["no"] = EMOTE_ONESHOT_NO;
+    emotes["one_shot_stun"] = EMOTE_ONESHOT_STUN;
+    emotes["point_nosheathe"] = EMOTE_ONESHOT_POINT_NO_SHEATHE;
+    emotes["roar"] = EMOTE_STATE_ROAR;
+    emotes["salute"] = EMOTE_ONESHOT_SALUTE;
+    emotes["stomp"] = EMOTE_ONESHOT_STOMP;
+    emotes["train"] = EMOTE_ONESHOT_TRAIN;
+    emotes["yes"] = EMOTE_ONESHOT_YES;
+    emotes["applaud"] = EMOTE_ONESHOT_APPLAUD;
+    emotes["battleroar"] = EMOTE_ONESHOT_BATTLE_ROAR;
+    emotes["beg"] = EMOTE_ONESHOT_BEG;
+    emotes["bow"] = EMOTE_ONESHOT_BOW;
+    emotes["cheer"] = EMOTE_ONESHOT_CHEER;
+    emotes["chicken"] = EMOTE_ONESHOT_CHICKEN;
+    emotes["cry"] = EMOTE_ONESHOT_CRY;
+    emotes["dance"] = EMOTE_STATE_DANCE;
+    emotes["eat"] = EMOTE_ONESHOT_EAT;
+    emotes["exclamation"] = EMOTE_ONESHOT_EXCLAMATION;
+    emotes["flex"] = EMOTE_ONESHOT_FLEX;
+    emotes["kick"] = EMOTE_ONESHOT_KICK;
+    emotes["kiss"] = EMOTE_ONESHOT_KISS;
+    emotes["kneel"] = EMOTE_ONESHOT_KNEEL;
+    emotes["laugh"] = EMOTE_ONESHOT_LAUGH;
+    emotes["parryshield"] = EMOTE_ONESHOT_PARRY_SHIELD;
+    emotes["parryunarmed"] = EMOTE_ONESHOT_PARRY_UNARMED;
+    emotes["point"] = EMOTE_ONESHOT_POINT;
+    emotes["question"] = EMOTE_ONESHOT_QUESTION;
+    emotes["ready1h"] = EMOTE_ONESHOT_READY1H;
+    emotes["readybow"] = EMOTE_ONESHOT_READY_BOW;
+    emotes["readyunarmed"] = EMOTE_ONESHOT_READY_UNARMED;
+    emotes["roar"] = EMOTE_ONESHOT_ROAR;
+    emotes["rude"] = EMOTE_ONESHOT_RUDE;
+    emotes["shout"] = EMOTE_ONESHOT_SHOUT;
+    emotes["shy"] = EMOTE_ONESHOT_SHY;
+    emotes["sleep"] = EMOTE_STATE_SLEEP;
+    emotes["talk"] = EMOTE_ONESHOT_TALK;
+    emotes["wave"] = EMOTE_ONESHOT_WAVE;
+    emotes["woundcritical"] = EMOTE_ONESHOT_WOUND_CRITICAL;
+    emotes["wound"] = EMOTE_ONESHOT_WOUND;
+}
diff --git a/src/plugins/playerbot/strategy/actions/EmoteAction.h b/src/plugins/playerbot/strategy/actions/EmoteAction.h
new file mode 100644
index 0000000..8aa8fda
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EmoteAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class EmoteAction : public Action
+    {
+    public:
+        EmoteAction(PlayerbotAI* ai) : Action(ai, "emote") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void InitEmotes();
+        static map<string, uint32> emotes;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.cpp b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
new file mode 100644
index 0000000..1f8de55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.cpp
@@ -0,0 +1,105 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EquipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool EquipAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text == "?")
+    {
+        TellEquipmentSets();
+        return true;
+    }
+
+    if (UseEquipmentSet(text))
+        return true;
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        EquipItem(&visitor);
+    }
+
+    return true;
+}
+
+bool EquipAction::UseEquipmentSet(string& name)
+{
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state == EQUIPMENT_SET_DELETED || i->second.Name != name)
+            continue;
+
+        UseEquipmentSet(i->second);
+
+        ostringstream out; out << name << " set equipped";
+        ai->TellMaster(out);
+        return true;
+    }
+    return false;
+}
+
+bool EquipAction::UseEquipmentSet(EquipmentSet& set)
+{
+    WorldPacket* p = new WorldPacket(CMSG_EQUIPMENT_SET_USE);
+    uint8 srcbag = 0;
+    for(uint8 slot = 0; slot < EQUIPMENT_SLOT_END; ++slot)
+    {
+        ObjectGuid guid;
+        uint32 itemId = set.Items[slot];
+        if (set.IgnoreMask & (1 << slot))
+            p->appendPackGUID((uint64(1)));
+        else
+            p->appendPackGUID(itemId);
+        *p << srcbag << slot;
+    }
+    bot->GetSession()->QueuePacket(p);
+    return true;
+}
+
+void EquipAction::TellEquipmentSets()
+{
+    ai->TellMaster("=== Equipment sets ===");
+    EquipmentSets &sets = bot->GetEquipmentSets();
+    for (EquipmentSets::iterator i = sets.begin(); i != sets.end(); i++)
+    {
+        if (i->second.state != EQUIPMENT_SET_DELETED)
+            ai->TellMaster(i->second.Name);
+    }
+}
+
+void EquipAction::EquipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) EquipItem(**items.begin());
+}
+
+
+void EquipAction::EquipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint32 itemId = item.GetTemplate()->ItemId;
+
+    if (item.GetTemplate()->InventoryType == INVTYPE_AMMO)
+    {
+        bot->SetAmmo(itemId);
+    }
+    else
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOEQUIP_ITEM, 2);
+            *packet << bagIndex << slot;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    ostringstream out; out << "equipping " << chat->formatItem(item.GetTemplate());
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/EquipAction.h b/src/plugins/playerbot/strategy/actions/EquipAction.h
new file mode 100644
index 0000000..d23223c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/EquipAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class EquipAction : public InventoryAction {
+    public:
+        EquipAction(PlayerbotAI* ai) : InventoryAction(ai, "equip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void EquipItem(FindItemVisitor* visitor);
+        void EquipItem(Item& item);
+        void TellEquipmentSets();
+        bool UseEquipmentSet(string& name);
+        bool UseEquipmentSet(EquipmentSet& set);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.cpp b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
new file mode 100644
index 0000000..dfa115f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowActions.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../values/Formations.h"
+
+using namespace ai;
+
+bool FollowAction::Execute(Event event)
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    string target = formation->GetTargetName();
+    if (!target.empty())
+    {
+        return Follow(AI_VALUE(Unit*, target));
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || loc.GetMapId() == -1)
+            return false;
+
+        return MoveTo(loc.GetMapId(), loc.m_positionX, loc.m_positionY, loc.m_positionZ);
+    }
+}
+
+bool FollowAction::isUseful()
+{
+    Formation* formation = AI_VALUE(Formation*, "formation");
+    float distance = 0;
+    string target = formation->GetTargetName();
+
+    if (!target.empty())
+    {
+        distance = AI_VALUE2(float, "distance", target);
+    }
+    else
+    {
+        WorldLocation loc = formation->GetLocation();
+        if (loc == Formation::NullLocation || bot->GetMapId() != loc.GetMapId())
+            return false;
+
+        distance = bot->GetDistance(loc);
+    }
+
+    return distance > formation->GetMaxDistance() &&
+            !AI_VALUE(bool, "can loot");
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/FollowActions.h b/src/plugins/playerbot/strategy/actions/FollowActions.h
new file mode 100644
index 0000000..971ca99
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/FollowActions.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class FollowAction : public MovementAction {
+	public:
+		FollowAction(PlayerbotAI* ai) : MovementAction(ai, "follow") {}
+		virtual bool Execute(Event event);
+        virtual bool isUseful();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.cpp b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
new file mode 100644
index 0000000..22285f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/actions/GenericActions.h b/src/plugins/playerbot/strategy/actions/GenericActions.h
new file mode 100644
index 0000000..b32a8e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericActions.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "GenericSpellActions.h"
+#include "ReachTargetActions.h"
+#include "ChooseTargetActions.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class MeleeAction : public AttackAction 
+    {
+    public:
+        MeleeAction(PlayerbotAI* ai) : AttackAction(ai, "melee") {}
+
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
new file mode 100644
index 0000000..0ffeccc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericActions.h"
+
+using namespace ai;
+
+bool CastSpellAction::Execute(Event event) 
+{
+	return ai->CastSpell(spell, GetTarget()); 
+}
+
+bool CastSpellAction::isPossible() 
+{
+    if (AI_VALUE2(float, "distance", GetTargetName()) > range)
+        return false;
+
+	return ai->CanCastSpell(spell, GetTarget());
+}
+
+bool CastSpellAction::isUseful() 
+{
+	return GetTarget() && AI_VALUE2(bool, "spell cast useful", spell);
+}
+
+bool CastAuraSpellAction::isUseful() 
+{
+	return CastSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+}
+
+bool CastEnchantItemAction::isUseful()
+{
+    if (!CastSpellAction::isUseful())
+        return false;
+
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+bool CastHealingSpellAction::isUseful() 
+{
+	return CastAuraSpellAction::isUseful() && AI_VALUE2(uint8, "health", GetTargetName()) < (100 - estAmount);
+}
+
+bool CastAoeHealSpellAction::isUseful()
+{
+	return CastSpellAction::isUseful() && AI_VALUE2(uint8, "aoe heal", "medium") > 0;
+}
+
+
+Value<Unit*>* CurePartyMemberAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
+
+Value<Unit*>* BuffOnPartyAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("party member without aura", spell);
+}
diff --git a/src/plugins/playerbot/strategy/actions/GenericSpellActions.h b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
new file mode 100644
index 0000000..e286a17
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GenericSpellActions.h
@@ -0,0 +1,271 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BEGIN_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+
+#define END_SPELL_ACTION() \
+    };
+
+#define BEGIN_DEBUFF_ACTION(clazz, name) \
+class clazz : public CastDebuffSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastDebuffSpellAction(ai, name) {} \
+
+#define BEGIN_RANGED_SPELL_ACTION(clazz, name) \
+class clazz : public CastSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastSpellAction(ai, name) {} \
+
+#define BEGIN_MELEE_SPELL_ACTION(clazz, name) \
+class clazz : public CastMeleeSpellAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : CastMeleeSpellAction(ai, name) {} \
+
+
+#define END_RANGED_SPELL_ACTION() \
+    };
+
+
+#define BEGIN_BUFF_ON_PARTY_ACTION(clazz, name) \
+class clazz : public BuffOnPartyAction \
+        { \
+        public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyAction(ai, name) {}
+
+namespace ai
+{
+    class CastSpellAction : public Action
+    {
+    public:
+        CastSpellAction(PlayerbotAI* ai, string spell) : Action(ai, spell),
+			range(sPlayerbotAIConfig.spellDistance)
+        {
+            this->spell = spell;
+        }
+
+		virtual string GetTargetName() { return "current target"; };
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+		virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_SINGLE; }
+
+		virtual NextAction** getPrerequisites()
+		{
+			if (range > sPlayerbotAIConfig.spellDistance)
+				return NULL;
+			else if (range > ATTACK_DISTANCE)
+				return NextAction::merge( NextAction::array(0, new NextAction("reach spell"), NULL), Action::getPrerequisites());
+			else
+				return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), Action::getPrerequisites());
+		}
+
+    protected:
+        string spell;
+		float range;
+    };
+
+	//---------------------------------------------------------------------------------------------------------------------
+	class CastAuraSpellAction : public CastSpellAction
+	{
+	public:
+		CastAuraSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual bool isUseful();
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastMeleeSpellAction : public CastSpellAction
+    {
+    public:
+        CastMeleeSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {
+			range = ATTACK_DISTANCE;
+		}
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+    class CastDebuffSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+    };
+
+    class CastDebuffSpellOnAttackerAction : public CastAuraSpellAction
+    {
+    public:
+        CastDebuffSpellOnAttackerAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("attacker without aura", spell);
+        }
+        virtual string getName() { return spell + " on attacker"; }
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+    };
+
+	class CastBuffSpellAction : public CastAuraSpellAction
+	{
+	public:
+		CastBuffSpellAction(PlayerbotAI* ai, string spell) : CastAuraSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastEnchantItemAction : public CastSpellAction
+	{
+	public:
+	    CastEnchantItemAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+        virtual bool isUseful();
+        virtual string GetTargetName() { return "self target"; }
+	};
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastHealingSpellAction : public CastAuraSpellAction
+    {
+    public:
+        CastHealingSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastAuraSpellAction(ai, spell)
+		{
+            this->estAmount = estAmount;
+			range = sPlayerbotAIConfig.spellDistance;
+        }
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful();
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_AOE; }
+
+    protected:
+        uint8 estAmount;
+    };
+
+    class CastAoeHealSpellAction : public CastHealingSpellAction
+    {
+    public:
+    	CastAoeHealSpellAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) : CastHealingSpellAction(ai, spell, estAmount) {}
+		virtual string GetTargetName() { return "party member to heal"; }
+        virtual bool isUseful();
+    };
+
+	class CastCureSpellAction : public CastSpellAction
+	{
+	public:
+		CastCureSpellAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell)
+		{
+			range = sPlayerbotAIConfig.spellDistance;
+		}
+
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class PartyMemberActionNameSupport {
+	public:
+		PartyMemberActionNameSupport(string spell)
+		{
+			name = string(spell) + " on party";
+		}
+
+		virtual string getName() { return name; }
+
+	private:
+		string name;
+	};
+
+    class HealPartyMemberAction : public CastHealingSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        HealPartyMemberAction(PlayerbotAI* ai, string spell, uint8 estAmount = 15.0f) :
+			CastHealingSpellAction(ai, spell, estAmount), PartyMemberActionNameSupport(spell) {}
+
+		virtual string GetTargetName() { return "party member to heal"; }
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+	class ResurrectPartyMemberAction : public CastSpellAction
+	{
+	public:
+		ResurrectPartyMemberAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+
+		virtual string GetTargetName() { return "party member to resurrect"; }
+	};
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CurePartyMemberAction : public CastSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        CurePartyMemberAction(PlayerbotAI* ai, string spell, uint32 dispelType) :
+			CastSpellAction(ai, spell), PartyMemberActionNameSupport(spell)
+        {
+            this->dispelType = dispelType;
+        }
+
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+
+    protected:
+        uint32 dispelType;
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class BuffOnPartyAction : public CastBuffSpellAction, public PartyMemberActionNameSupport
+    {
+    public:
+        BuffOnPartyAction(PlayerbotAI* ai, string spell) :
+			CastBuffSpellAction(ai, spell), PartyMemberActionNameSupport(spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+		virtual string getName() { return PartyMemberActionNameSupport::getName(); }
+    };
+
+    //---------------------------------------------------------------------------------------------------------------------
+
+    class CastShootAction : public CastSpellAction
+    {
+    public:
+        CastShootAction(PlayerbotAI* ai) : CastSpellAction(ai, "shoot") {}
+        virtual ActionThreatType getThreatType() { return ACTION_THREAT_NONE; }
+    };
+
+	class CastLifeBloodAction : public CastHealingSpellAction
+	{
+	public:
+		CastLifeBloodAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lifeblood") {}
+	};
+
+	class CastGiftOfTheNaaruAction : public CastHealingSpellAction
+	{
+	public:
+		CastGiftOfTheNaaruAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "gift of the naaru") {}
+	};
+
+    class CastArcaneTorrentAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneTorrentAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane torrent") {}
+    };
+
+    class CastSpellOnEnemyHealerAction : public CastSpellAction
+    {
+    public:
+        CastSpellOnEnemyHealerAction(PlayerbotAI* ai, string spell) : CastSpellAction(ai, spell) {}
+        Value<Unit*>* GetTargetValue()
+        {
+            return context->GetValue<Unit*>("enemy healer target", spell);
+        }
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
new file mode 100644
index 0000000..b5b9d48
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.cpp
@@ -0,0 +1,72 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GossipHelloAction.h"
+
+
+using namespace ai;
+
+bool GossipHelloAction::Execute(Event event)
+{
+    ObjectGuid guid;
+
+    WorldPacket &p = event.getPacket();
+    if (p.empty())
+    {
+        Player* master = GetMaster();
+        if (master && master->GetSelectedUnit())
+            guid = master->GetSelectedUnit()->GetGUID();
+    }
+    else
+    {
+        p.rpos(0);
+        p >> guid;
+    }
+
+    if (!guid)
+        return false;
+
+    Creature *pCreature = bot->GetNPCIfCanInteractWith(guid, UNIT_NPC_FLAG_NONE);
+    if (!pCreature)
+    {
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "[PlayerbotMgr]: HandleMasterIncomingPacket - Received  CMSG_GOSSIP_HELLO %d not found or you can't interact with him.", guid.GetRawValue());
+        return false;
+    }
+
+    GossipMenuItemsMapBounds pMenuItemBounds = sObjectMgr->GetGossipMenuItemsMapBounds(pCreature->GetCreatureTemplate()->GossipMenuId);
+    if (pMenuItemBounds.first == pMenuItemBounds.second)
+        return false;
+
+    WorldPacket p1;
+    p1 << guid;
+    bot->GetSession()->HandleGossipHelloOpcode(p1);
+    bot->SetFacingToObject(pCreature);
+
+    ostringstream out; out << "--- " << pCreature->GetName() << " ---";
+    ai->TellMasterNoFacing(out.str());
+
+    GossipMenu& menu = bot->PlayerTalkClass->GetGossipMenu();
+    int i = 0, loops = 0;
+    set<uint32> alreadyTalked;
+    int menuGetItemCount = menu.GetMenuItemCount();
+    while (i < menuGetItemCount && loops++ < 100)
+    {
+        GossipMenuItem const* item = menu.GetItem(i);
+        ai->TellMasterNoFacing(item->Message);
+
+        if (item->OptionType < 1000 && item->OptionType != GOSSIP_OPTION_GOSSIP)
+        {
+            i++;
+            continue;
+        }
+
+        WorldPacket p1;
+        std::string code;
+        p1 << guid << menu.GetMenuId() << i << code;
+        bot->GetSession()->HandleGossipSelectOptionOpcode(p1);
+
+        i = 0;
+    }
+
+    bot->TalkedToCreature(pCreature->GetEntry(), pCreature->GetGUID());
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GossipHelloAction.h b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
new file mode 100644
index 0000000..603737c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GossipHelloAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class GossipHelloAction : public Action {
+    public:
+        GossipHelloAction(PlayerbotAI* ai) : Action(ai, "gossip hello") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
new file mode 100644
index 0000000..49d71cc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildAcceptAction.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildAcceptAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    bool accept = true;
+    uint32 guildId = master->GetGuildId();
+    if (!guildId)
+    {
+        ai->TellMaster("You are not in a guild");
+        accept = false;
+    }
+    else if (bot->GetGuildId())
+    {
+        ai->TellMaster("Sorry, I am in a guild already");
+        accept = false;
+    }
+    else if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_INVITE, false, master, true))
+    {
+        accept = false;
+    }
+
+    WorldPacket packet;
+    if (accept)
+    {
+        bot->SetGuildIdInvited(guildId);
+        bot->GetSession()->HandleGuildAcceptOpcode(packet);
+    }
+    else
+    {
+        bot->GetSession()->HandleGuildDeclineOpcode(packet);
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
new file mode 100644
index 0000000..ab8910c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildAcceptAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildAcceptAction : public Action {
+    public:
+        GuildAcceptAction(PlayerbotAI* ai) : Action(ai, "guild accept") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
new file mode 100644
index 0000000..849b1b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuildBankAction.h"
+
+#include "../values/ItemCountValue.h"
+#include "../../../Guilds/Guild.h"
+#include "../../../Guilds/GuildMgr.h"
+
+using namespace std;
+using namespace ai;
+
+bool GuildBankAction::Execute(Event event)
+{
+    string text = event.getParam();
+    if (text.empty())
+        return false;
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go || !bot->GetGameObjectIfCanInteractWith(go->GetGUID(), GAMEOBJECT_TYPE_GUILD_BANK))
+            continue;
+
+        return Execute(text, go);
+    }
+
+    ai->TellMaster("Cannot find the guild bank nearby");
+    return false;
+}
+
+bool GuildBankAction::Execute(string text, GameObject* bank)
+{
+    bool result = true;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+    {
+        Item* item = *i;
+        if (item)
+            result &= MoveFromCharToBank(item, bank);
+    }
+
+    return result;
+}
+
+bool GuildBankAction::MoveFromCharToBank(Item* item, GameObject* bank)
+{
+    uint32 playerSlot = item->GetSlot();
+    uint32 playerBag = item->GetBagSlot();
+
+    Guild* guild = sGuildMgr->GetGuildById(bot->GetGuildId());
+    guild->SwapItems(bot, 0, playerSlot, 0, INVENTORY_SLOT_BAG_0, 0);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " put to guild bank";
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/GuildBankAction.h b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
new file mode 100644
index 0000000..374fc0f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/GuildBankAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class GuildBankAction : public InventoryAction {
+    public:
+        GuildBankAction(PlayerbotAI* ai) : InventoryAction(ai, "guild bank") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Execute(string text, GameObject* bank);
+        bool MoveFromCharToBank(Item* item, GameObject* bank);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.cpp b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
new file mode 100644
index 0000000..6e7b776
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HelpAction.h"
+#include "ChatActionContext.h"
+
+using namespace ai;
+
+HelpAction::HelpAction(PlayerbotAI* ai) : Action(ai, "help")
+{
+    chatContext = new ChatActionContext();
+}
+
+HelpAction::~HelpAction()
+{
+    delete chatContext;
+}
+
+bool HelpAction::Execute(Event event)
+{
+    TellChatCommands();
+    TellStrategies();
+    return true;
+}
+
+void HelpAction::TellChatCommands()
+{
+    ostringstream out;
+    out << "Whisper any of: ";
+    out << CombineSupported(chatContext->supports());
+    out << ", [item], [quest] or [object] link";
+    ai->TellMaster(out);
+}
+
+void HelpAction::TellStrategies()
+{
+    ostringstream out;
+    out << "Possible strategies (co/nc/dead commands): ";
+    out << CombineSupported(ai->GetAiObjectContext()->GetSupportedStrategies());
+    ai->TellMaster(out);
+}
+
+string HelpAction::CombineSupported(set<string> commands)
+{
+    ostringstream out;
+
+    for (set<string>::iterator i = commands.begin(); i != commands.end(); )
+	{
+        out << *i;
+		if (++i != commands.end())
+			out << ", ";
+	}
+
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/HelpAction.h b/src/plugins/playerbot/strategy/actions/HelpAction.h
new file mode 100644
index 0000000..c0bc5e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/HelpAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class HelpAction : public Action {
+    public:
+        HelpAction(PlayerbotAI* ai);
+        virtual ~HelpAction();
+        virtual bool Execute(Event event);
+
+    private:
+        void TellChatCommands();
+        void TellStrategies();
+        string CombineSupported(set<string> commands);
+
+    private:
+        NamedObjectContext<Action>* chatContext;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
new file mode 100644
index 0000000..896466c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.cpp
@@ -0,0 +1,288 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+
+class FindPotionVisitor : public FindUsableItemVisitor
+{
+public:
+    FindPotionVisitor(Player* bot, uint32 effectId) : FindUsableItemVisitor(bot), effectId(effectId) {}
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        if (proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_POTION &&
+            proto->Spells[0].SpellCategory == 4)
+        {
+            for (int j = 0; j < MAX_ITEM_PROTO_SPELLS; j++)
+            {
+                const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(proto->Spells[j].SpellId);
+                if (!spellInfo)
+                    return false;
+
+                for (int i = 0 ; i < 3; i++)
+                {
+                    if (spellInfo->Effects[i].Effect == effectId)
+                        return true;
+                }
+            }
+        }
+        return false;
+    }
+
+private:
+    uint32 effectId;
+};
+
+class FindFoodVisitor : public FindUsableItemVisitor
+{
+public:
+    FindFoodVisitor(Player* bot, uint32 spellCategory) : FindUsableItemVisitor(bot)
+    {
+        this->spellCategory = spellCategory;
+    }
+
+    virtual bool Accept(const ItemTemplate* proto)
+    {
+        return proto->Class == ITEM_CLASS_CONSUMABLE &&
+            proto->SubClass == ITEM_SUBCLASS_FOOD &&
+            proto->Spells[0].SpellCategory == spellCategory;
+    }
+
+private:
+    uint32 spellCategory;
+};
+
+void InventoryAction::IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask)
+{
+    if (mask & ITERATE_ITEMS_IN_BAGS)
+        IterateItemsInBags(visitor);
+
+    if (mask & ITERATE_ITEMS_IN_EQUIP)
+        IterateItemsInEquip(visitor);
+}
+
+void InventoryAction::IterateItemsInBags(IterateItemsVisitor* visitor)
+{
+
+
+    for(int i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item *pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (!visitor->Visit(pItem))
+                return;
+
+    for(int i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag *pBag = (Bag*)bot->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            for(uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    if (!visitor->Visit(pItem))
+                        return;
+}
+
+void InventoryAction::IterateItemsInEquip(IterateItemsVisitor* visitor)
+{
+    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++)
+    {
+        Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if(!pItem)
+            continue;
+
+        if (!visitor->Visit(pItem))
+            return;
+    }
+}
+
+bool compare_items(const ItemTemplate *proto1, const ItemTemplate *proto2)
+{
+    if (proto1->Class != proto2->Class)
+        return proto1->Class > proto2->Class;
+
+    if (proto1->SubClass != proto2->SubClass)
+        return proto1->SubClass < proto2->SubClass;
+
+    if (proto1->Quality != proto2->Quality)
+        return proto1->Quality < proto2->Quality;
+
+    if (proto1->ItemLevel != proto2->ItemLevel)
+        return proto1->ItemLevel > proto2->ItemLevel;
+
+    return false;
+}
+
+bool compare_items_by_level(const Item* item1, const Item* item2)
+{
+    return compare_items(item1->GetTemplate(), item2->GetTemplate());
+}
+
+void InventoryAction::TellItems(map<uint32, int> itemMap)
+{
+    list<ItemTemplate const*> items;
+    for (map<uint32, int>::iterator i = itemMap.begin(); i != itemMap.end(); i++)
+    {
+        items.push_back(sObjectMgr->GetItemTemplate(i->first));
+    }
+
+    items.sort(compare_items);
+
+    uint32 oldClass = -1;
+    for (list<ItemTemplate const*>::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *proto = *i;
+
+        if (proto->Class != oldClass)
+        {
+            oldClass = proto->Class;
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_CONSUMABLE:
+                ai->TellMaster("--- consumable ---");
+                break;
+            case ITEM_CLASS_CONTAINER:
+                ai->TellMaster("--- container ---");
+                break;
+            case ITEM_CLASS_WEAPON:
+                ai->TellMaster("--- weapon ---");
+                break;
+            case ITEM_CLASS_GEM:
+                ai->TellMaster("--- gem ---");
+                break;
+            case ITEM_CLASS_ARMOR:
+                ai->TellMaster("--- armor ---");
+                break;
+            case ITEM_CLASS_REAGENT:
+                ai->TellMaster("--- reagent ---");
+                break;
+            case ITEM_CLASS_PROJECTILE:
+                ai->TellMaster("--- projectile ---");
+                break;
+            case ITEM_CLASS_TRADE_GOODS:
+                ai->TellMaster("--- trade goods ---");
+                break;
+            case ITEM_CLASS_GENERIC:
+                ai->TellMaster("--- generic ---");
+                break;
+            case ITEM_CLASS_RECIPE:
+                ai->TellMaster("--- recipe ---");
+                break;
+            case ITEM_CLASS_MONEY:
+                ai->TellMaster("--- money ---");
+                break;
+            case ITEM_CLASS_QUIVER:
+                ai->TellMaster("--- quiver ---");
+                break;
+            case ITEM_CLASS_QUEST:
+                ai->TellMaster("--- quest items ---");
+                break;
+            case ITEM_CLASS_KEY:
+                ai->TellMaster("--- keys ---");
+                break;
+            case ITEM_CLASS_PERMANENT:
+                ai->TellMaster("--- permanent ---");
+                break;
+            case ITEM_CLASS_MISC:
+                ai->TellMaster("--- other ---");
+                break;
+            case ITEM_CLASS_GLYPH:
+                ai->TellMaster("--- glyph ---");
+                break;
+            }
+        }
+
+        TellItem(proto, itemMap[proto->ItemId]);
+    }
+}
+
+void InventoryAction::TellItem(ItemTemplate const * proto, int count)
+{
+    ai->TellMaster(chat->formatItem(proto, count));
+}
+
+list<Item*> InventoryAction::parseItems(string text)
+{
+    set<Item*> found;
+    size_t pos = text.find(" ");
+    int count = pos!=string::npos ? atoi(text.substr(pos + 1).c_str()) : TRADE_SLOT_TRADED_COUNT;
+    if (count < 1) count = 1;
+    else if (count > TRADE_SLOT_TRADED_COUNT) count = TRADE_SLOT_TRADED_COUNT;
+
+    if (text == "food")
+    {
+        FindFoodVisitor visitor(bot, 11);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "drink")
+    {
+        FindFoodVisitor visitor(bot, 59);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "mana potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_ENERGIZE);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    if (text == "healing potion")
+    {
+        FindPotionVisitor visitor(bot, SPELL_EFFECT_HEAL);
+        IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    FindUsableNamedItemVisitor visitor(bot, text);
+    IterateItems(&visitor, ITERATE_ITEMS_IN_BAGS);
+    found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+
+    uint32 quality = chat->parseItemQuality(text);
+    if (quality != MAX_ITEM_QUALITY)
+    {
+        FindItemsToTradeByQualityVisitor visitor(quality, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 itemClass = MAX_ITEM_CLASS, itemSubClass = 0;
+    if (chat->parseItemClass(text, &itemClass, &itemSubClass))
+    {
+        FindItemsToTradeByClassVisitor visitor(itemClass, itemSubClass, count);
+        IterateItems(&visitor);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    uint32 fromSlot = chat->parseSlot(text);
+    if (fromSlot != EQUIPMENT_SLOT_END)
+    {
+        Item* item = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, fromSlot);
+        if (item)
+            found.insert(item);
+    }
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i = ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        IterateItems(&visitor, ITERATE_ALL_ITEMS);
+        found.insert(visitor.GetResult().begin(), visitor.GetResult().end());
+    }
+
+    list<Item*> result;
+    for (set<Item*>::iterator i = found.begin(); i != found.end(); ++i)
+        result.push_back(*i);
+
+    result.sort(compare_items_by_level);
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryAction.h b/src/plugins/playerbot/strategy/actions/InventoryAction.h
new file mode 100644
index 0000000..a1f1af7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "../ItemVisitors.h"
+
+namespace ai
+{
+
+
+    class InventoryAction : public Action {
+    public:
+        InventoryAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    protected:
+        void IterateItems(IterateItemsVisitor* visitor, IterateItemsMask mask = ITERATE_ITEMS_IN_BAGS);
+        void TellItems(map<uint32, int> items);
+        void TellItem(ItemTemplate const * proto, int count);
+        list<Item*> parseItems(string text);
+
+    private:
+        void IterateItemsInBags(IterateItemsVisitor* visitor);
+        void IterateItemsInEquip(IterateItemsVisitor* visitor);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
new file mode 100644
index 0000000..5933a19
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.cpp
@@ -0,0 +1,55 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InventoryChangeFailureAction.h"
+
+
+using namespace ai;
+
+bool InventoryChangeFailureAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 err;
+    p >> err;
+    if (err == EQUIP_ERR_OK)
+        return false;
+
+    switch (err)
+    {
+    case EQUIP_ERR_CANT_CARRY_MORE_OF_THIS:
+        ai->TellMaster("I can't carry anymore of those.");
+        break;
+    case EQUIP_ERR_MISSING_REAGENT:
+        ai->TellMaster("I'm missing some reagents for that.");
+        break;
+    case EQUIP_ERR_ITEM_LOCKED:
+        ai->TellMaster("That item is locked.");
+        break;
+    case EQUIP_ERR_ALREADY_LOOTED:
+        break;
+    case EQUIP_ERR_INVENTORY_FULL:
+        ai->TellMaster("My inventory is full.");
+        break;
+    case EQUIP_ERR_NOT_IN_COMBAT:
+        ai->TellMaster("I can't use that in combat.");
+        break;
+    case EQUIP_ERR_LOOT_CANT_LOOT_THAT_NOW:
+        ai->TellMaster("I can't get that now.");
+        break;
+    case EQUIP_ERR_ITEM_UNIQUE_EQUIPABLE:
+        ai->TellMaster("I can only have one of those equipped.");
+        break;
+    case EQUIP_ERR_BANK_FULL:
+        ai->TellMaster("My bank is full.");
+        break;
+    case EQUIP_ERR_ITEM_NOT_FOUND:
+        ai->TellMaster("I can't find the item.");
+        break;
+    case EQUIP_ERR_TOO_FAR_AWAY_FROM_BANK:
+        ai->TellMaster("I'm too far from the bank.");
+        break;
+    default:
+        ai->TellMaster("I can't use that.");
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
new file mode 100644
index 0000000..4125cd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InventoryChangeFailureAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InventoryChangeFailureAction : public Action {
+    public:
+        InventoryChangeFailureAction(PlayerbotAI* ai) : Action(ai, "inventory change failure") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
new file mode 100644
index 0000000..d57ee50
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/InviteToGroupAction.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class InviteToGroupAction : public Action
+    {
+    public:
+        InviteToGroupAction(PlayerbotAI* ai) : Action(ai, "invite") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = event.getOwner();
+            if (!master)
+                return false;
+
+            WorldPacket p;
+            uint32 roles_mask = 0;
+            p << master->GetName();
+            p << roles_mask;
+            bot->GetSession()->HandleGroupInviteOpcode(p);
+
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
new file mode 100644
index 0000000..90c0fff
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LeaveGroupAction.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../RandomPlayerbotMgr.h"
+
+namespace ai
+{
+    class LeaveGroupAction : public Action {
+    public:
+        LeaveGroupAction(PlayerbotAI* ai, string name = "leave") : Action(ai, name) {}
+
+        virtual bool Execute(Event event)
+        {
+            if (!bot->GetGroup())
+                return false;
+
+            ai->TellMaster("Goodbye!", PLAYERBOT_SECURITY_TALK);
+
+            WorldPacket p;
+            string member = bot->GetName();
+            p << uint32(PARTY_OP_LEAVE) << member << uint32(0);
+            bot->GetSession()->HandleGroupDisbandOpcode(p);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                bot->GetPlayerbotAI()->SetMaster(NULL);
+                sRandomPlayerbotMgr.ScheduleTeleport(bot->GetGUID().GetCounter());
+                sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+            }
+
+            ai->ResetStrategies();
+            return true;
+        }
+    };
+
+    class PartyCommandAction : public LeaveGroupAction {
+    public:
+        PartyCommandAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            uint32 operation;
+            string member;
+
+            p >> operation >> member;
+
+            if (operation != PARTY_OP_LEAVE)
+                return false;
+
+            Player* master = GetMaster();
+            if (master && member == master->GetName())
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+    class UninviteAction : public LeaveGroupAction {
+    public:
+        UninviteAction(PlayerbotAI* ai) : LeaveGroupAction(ai, "party command") {}
+
+        virtual bool Execute(Event event)
+        {
+            WorldPacket& p = event.getPacket();
+            p.rpos(0);
+            ObjectGuid guid;
+
+            p >> guid;
+
+            if (bot->GetGUID() == guid)
+                return LeaveGroupAction::Execute(event);
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.cpp b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
new file mode 100644
index 0000000..76868a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.cpp
@@ -0,0 +1,236 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LfgActions.h"
+#include "../../AiFactory.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../ItemVisitors.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../../DungeonFinding/LFGMgr.h"
+#include "../../../DungeonFinding/LFG.h"
+
+using namespace ai;
+using namespace lfg;
+
+bool LfgJoinAction::Execute(Event event)
+{
+    if (!sPlayerbotAIConfig.randomBotJoinLfg)
+        return false;
+
+    if (bot->isDead())
+        return false;
+
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return false;
+
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_NONE)
+        return false;
+
+    if (bot->IsBeingTeleported())
+        return false;
+
+    Map* map = bot->GetMap();
+    if (map && map->Instanceable())
+        return false;
+
+    return JoinProposal();
+}
+
+uint8 LfgJoinAction::GetRoles()
+{
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    switch (bot->getClass())
+    {
+    case CLASS_DRUID:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else if (spec == 1 && bot->getLevel() >= 40)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PALADIN:
+        if (spec == 1)
+            return PLAYER_ROLE_TANK;
+        else if (spec == 0)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_PRIEST:
+        if (spec != 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_SHAMAN:
+        if (spec == 2)
+            return PLAYER_ROLE_HEALER;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    case CLASS_WARRIOR:
+        if (spec == 2)
+            return PLAYER_ROLE_TANK;
+        else
+            return PLAYER_ROLE_DAMAGE;
+        break;
+    default:
+        return PLAYER_ROLE_DAMAGE;
+        break;
+    }
+
+    return PLAYER_ROLE_DAMAGE;
+}
+
+bool LfgJoinAction::SetRoles()
+{
+    sLFGMgr->SetRoles(bot->GetGUID(), GetRoles());
+	return true;
+}
+
+bool LfgJoinAction::JoinProposal()
+{
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+	bool heroic = urand(0, 100) < 50 && (visitor.count[ITEM_QUALITY_EPIC] >= 3 || visitor.count[ITEM_QUALITY_RARE] >= 10) && bot->getLevel() >= 70;
+    bool random = urand(0, 100) < 25;
+    bool raid = !heroic && (urand(0, 100) < 50 && visitor.count[ITEM_QUALITY_EPIC] >= 5 && (bot->getLevel() == 60 || bot->getLevel() == 70 || bot->getLevel() == 80));
+
+    LfgDungeonSet list;
+    vector<uint32> idx;
+    for (uint32 i = 0; i < sLFGDungeonStore.GetNumRows(); ++i)
+    {
+        LFGDungeonEntry const* dungeon = sLFGDungeonStore.LookupEntry(i);
+        if (!dungeon || (dungeon->type != LFG_TYPE_RANDOM && dungeon->type != LFG_TYPE_DUNGEON && dungeon->type != LFG_TYPE_HEROIC &&
+                dungeon->type != LFG_TYPE_RAID))
+            continue;
+
+        int botLevel = (int)bot->getLevel();
+        if (dungeon->minlevel && botLevel < (int)dungeon->minlevel)
+            continue;
+
+        if (dungeon->minlevel && botLevel > (int)dungeon->minlevel + 10)
+            continue;
+
+        if (dungeon->maxlevel && botLevel > (int)dungeon->maxlevel)
+            continue;
+
+        if (heroic && !dungeon->difficulty)
+            continue;
+
+        if (raid && dungeon->type != LFG_TYPE_RAID)
+            continue;
+
+        if (random && dungeon->type != LFG_TYPE_RANDOM)
+            continue;
+
+        if (!random && !raid && !heroic && dungeon->type != LFG_TYPE_DUNGEON)
+            continue;
+
+        if (!random)
+            list.insert(dungeon->ID);
+        else
+            idx.push_back(dungeon->ID);
+    }
+
+    if (list.empty())
+        return false;
+
+    uint8 roles = GetRoles();
+    if (random)
+	{
+        list.insert(idx[urand(0, idx.size() - 1)]);
+        sLFGMgr->JoinLfg(bot, roles, list, "bot");
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RANDOM as %d", bot->GetName().c_str(), (uint32)roles);
+		return true;
+	}
+    else if (heroic)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_HEROIC_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else if (raid)
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_RAID as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+    else
+	{
+		sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s joined to LFG_TYPE_DUNGEON as %d", bot->GetName().c_str(), (uint32)roles);
+	}
+
+    sLFGMgr->JoinLfg(bot, roles, list, "bot");
+    return true;
+}
+
+bool LfgRoleCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        sLFGMgr->UpdateRoleCheck(group->GetGUID(), bot->GetGUID(), GetRoles());
+        return true;
+    }
+
+    return false;
+}
+
+bool LfgAcceptAction::Execute(Event event)
+{
+    uint32 id = AI_VALUE(uint32, "lfg proposal");
+    if (id)
+    {
+        if (bot->IsInCombat() || bot->isDead() || bot->IsFalling())
+        {
+            sLFGMgr->LeaveLfg(bot->GetGUID());
+            return false;
+        }
+
+        ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+        if (urand(0, 1 + 10 / sPlayerbotAIConfig.randomChangeMultiplier))
+            return false;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot) && !bot->GetGroup())
+            ai->ChangeStrategy("-grind", BOT_STATE_NON_COMBAT);
+
+        sLog->outMessage("playerbot", LOG_LEVEL_DEBUG, "Bot %s updated proposal %d", bot->GetName().c_str(), id);
+        ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(0);
+        bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+        sLFGMgr->UpdateProposal(id, bot->GetGUID(), true);
+
+        return true;
+    }
+
+    WorldPacket p(event.getPacket());
+
+    uint32 dungeon;
+    uint8 state;
+    p >> dungeon >> state >> id;
+
+    ai->GetAiObjectContext()->GetValue<uint32>("lfg proposal")->Set(id);
+    return true;
+}
+
+bool LfgLeaveAction::Execute(Event event)
+{
+    if (sLFGMgr->GetState(bot->GetGUID()) != LFG_STATE_QUEUED)
+        return false;
+
+    sLFGMgr->LeaveLfg(bot->GetGUID());
+	return true;
+}
+
+bool LfgTeleportAction::Execute(Event event)
+{
+    bool out = false;
+
+    WorldPacket p(event.getPacket());
+    if (!p.empty())
+    {
+        p.rpos(0);
+        p >> out;
+    }
+
+    bot->ClearUnitState(UNIT_STATE_ALL_STATE_SUPPORTED);
+    sLFGMgr->TeleportPlayer(bot, out);
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LfgActions.h b/src/plugins/playerbot/strategy/actions/LfgActions.h
new file mode 100644
index 0000000..052cdcc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LfgActions.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class LfgJoinAction : public InventoryAction
+    {
+    public:
+        LfgJoinAction(PlayerbotAI* ai, string name = "lfg join") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool JoinProposal();
+        bool SetRoles();
+        uint8 GetRoles();
+    };
+
+    class LfgAcceptAction : public LfgJoinAction
+    {
+    public:
+        LfgAcceptAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg accept") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgRoleCheckAction : public LfgJoinAction
+    {
+    public:
+        LfgRoleCheckAction(PlayerbotAI* ai) : LfgJoinAction(ai, "lfg role check") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgLeaveAction : public Action
+    {
+    public:
+        LfgLeaveAction(PlayerbotAI* ai) : Action(ai, "lfg leave") {}
+        virtual bool Execute(Event event);
+    };
+
+    class LfgTeleportAction : public Action
+    {
+    public:
+        LfgTeleportAction(PlayerbotAI* ai) : Action(ai, "lfg teleport") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
new file mode 100644
index 0000000..d9249ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.cpp
@@ -0,0 +1,71 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListQuestsActions.h"
+
+
+using namespace ai;
+
+bool ListQuestsAction::Execute(Event event)
+{
+    if (event.getParam() == "completed")
+    {
+        ListQuests(QUEST_LIST_FILTER_COMPLETED);
+    }
+    else if (event.getParam() == "incompleted")
+    {
+        ListQuests(QUEST_LIST_FILTER_INCOMPLETED);
+    }
+    else if (event.getParam() == "all")
+    {
+        ListQuests(QUEST_LIST_FILTER_ALL);
+    }
+    else
+    {
+        ListQuests(QUEST_LIST_FILTER_SUMMARY);
+    }
+    return true;
+}
+
+void ListQuestsAction::ListQuests(QuestListFilter filter)
+{
+    bool showIncompleted = filter & QUEST_LIST_FILTER_INCOMPLETED;
+    bool showCompleted = filter & QUEST_LIST_FILTER_COMPLETED;
+
+    if (showIncompleted)
+        ai->TellMaster("--- Incomplete quests ---");
+    int incompleteCount = ListQuests(false, !showIncompleted);
+
+    if (showCompleted)
+        ai->TellMaster("--- Complete quests ---");
+    int completeCount = ListQuests(true, !showCompleted);
+
+    ai->TellMaster("--- Summary ---");
+    std::ostringstream out;
+    out << "Total: " << (completeCount + incompleteCount) << " / 25 (incomplete: " << incompleteCount << ", complete: " << completeCount << ")";
+    ai->TellMaster(out);
+}
+
+int ListQuestsAction::ListQuests(bool completed, bool silent)
+{
+    int count = 0;
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questId);
+        bool isCompletedQuest = bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE;
+        if (completed != isCompletedQuest)
+            continue;
+
+        count++;
+
+        if (silent)
+            continue;
+
+        ai->TellMaster(chat->formatQuest(pQuest));
+    }
+
+    return count;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ListQuestsActions.h b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
new file mode 100644
index 0000000..961acb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListQuestsActions.h
@@ -0,0 +1,25 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    enum QuestListFilter {
+        QUEST_LIST_FILTER_SUMMARY = 0,
+        QUEST_LIST_FILTER_COMPLETED = 1,
+        QUEST_LIST_FILTER_INCOMPLETED = 2,
+        QUEST_LIST_FILTER_ALL = QUEST_LIST_FILTER_COMPLETED | QUEST_LIST_FILTER_INCOMPLETED
+    };
+
+    class ListQuestsAction : public Action {
+    public:
+        ListQuestsAction(PlayerbotAI* ai) : Action(ai, "quests") {}
+        virtual bool Execute(Event event);
+
+    private:
+        int ListQuests(bool completed, bool silent);
+        void ListQuests(QuestListFilter filter);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
new file mode 100644
index 0000000..4602fb8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ListSpellsAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool ListSpellsAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    int loc = master->GetSession()->GetSessionDbcLocale();
+
+    std::ostringstream posOut;
+    std::ostringstream negOut;
+
+    string filter = event.getParam();
+
+    const std::string ignoreList = ",Opening,Closing,Stuck,Remove Insignia,Opening - No Text,Grovel,Duel,Honorless Target,";
+    std::string alreadySeenList = ",";
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr) {
+        const uint32 spellId = itr->first;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        //|| name.find("Teleport") != -1
+
+        std::string comp = ",";
+        comp.append(pSpellInfo->SpellName[loc]);
+        comp.append(",");
+
+        if (!(ignoreList.find(comp) == std::string::npos && alreadySeenList.find(comp) == std::string::npos))
+            continue;
+
+        if (!filter.empty() && !strstri(pSpellInfo->SpellName[loc], filter.c_str()))
+            continue;
+
+        alreadySeenList += pSpellInfo->SpellName[loc];
+        alreadySeenList += ",";
+
+        if (pSpellInfo->IsPositive())
+            posOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+        else
+            negOut << " |cffffffff|Hspell:" << spellId << "|h["
+            << pSpellInfo->SpellName[loc] << "]|h|r";
+    }
+
+    ai->TellMaster("here's my non-attack spells:");
+    ai->TellMaster(posOut);
+
+    ai->TellMaster("here's my attack spells:");
+    ai->TellMaster(negOut);
+
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/ListSpellsAction.h b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
new file mode 100644
index 0000000..2447055
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ListSpellsAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+
+namespace ai
+{
+    class ListSpellsAction : public Action {
+    public:
+        ListSpellsAction(PlayerbotAI* ai) : Action(ai, "spells") {}
+
+        virtual bool Execute(Event event);
+  
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
new file mode 100644
index 0000000..92005a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.cpp
@@ -0,0 +1,43 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LogLevelAction.h"
+
+
+using namespace ai;
+
+bool LogLevelAction::Execute(Event event)
+{
+    string param = event.getParam();
+    Value<LogLevel> *value = ai->GetAiObjectContext()->GetValue<LogLevel>("log level");
+
+    ostringstream out;
+    if (param != "?")
+    {
+        value->Set(string2logLevel(param));
+        out << "My log level set to " << logLevel2string(value->Get());
+    }
+    else
+    {
+        out << "My log level is " << logLevel2string(value->Get());
+    }
+    ai->TellMaster(out);
+    return true;
+}
+
+string LogLevelAction::logLevel2string(LogLevel level)
+{
+    switch (level)
+    {
+    case LOG_LEVEL_INFO:
+        return "info";
+    default:
+        return "debug";
+    }
+}
+LogLevel LogLevelAction::string2logLevel(string level)
+{
+    if (level == "debug")
+        return LOG_LEVEL_DEBUG;
+    else
+        return LOG_LEVEL_INFO;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LogLevelAction.h b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
new file mode 100644
index 0000000..4ad2a33
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LogLevelAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class LogLevelAction : public Action {
+    public:
+        LogLevelAction(PlayerbotAI* ai) : Action(ai, "log") {}
+        virtual bool Execute(Event event);
+
+    public:
+        static string logLevel2string(LogLevel level);
+        static LogLevel string2logLevel(string level);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.cpp b/src/plugins/playerbot/strategy/actions/LootAction.cpp
new file mode 100644
index 0000000..41c17aa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.cpp
@@ -0,0 +1,338 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootAction.h"
+
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../values/ItemUsageValue.h"
+#include "../../GuildTaskMgr.h"
+
+using namespace ai;
+
+bool LootAction::Execute(Event event)
+{
+    if (!AI_VALUE(bool, "has available loot"))
+        return false;
+
+    LootObject const& lootObject = AI_VALUE(LootObjectStack*, "available loot")->GetLoot(sPlayerbotAIConfig.lootDistance);
+    context->GetValue<LootObject>("loot target")->Set(lootObject);
+    return true;
+}
+
+enum ProfessionSpells
+{
+    ALCHEMY                      = 2259,
+    BLACKSMITHING                = 2018,
+    COOKING                      = 2550,
+    ENCHANTING                   = 7411,
+    ENGINEERING                  = 49383,
+    FIRST_AID                    = 3273,
+    FISHING                      = 7620,
+    HERB_GATHERING               = 2366,
+    INSCRIPTION                  = 45357,
+    JEWELCRAFTING                = 25229,
+    MINING                       = 2575,
+    SKINNING                     = 8613,
+    TAILORING                    = 3908
+};
+
+bool OpenLootAction::Execute(Event event)
+{
+    LootObject lootObject = AI_VALUE(LootObject, "loot target");
+    bool result = DoLoot(lootObject);
+    if (result)
+    {
+        AI_VALUE(LootObjectStack*, "available loot")->Remove(lootObject.guid);
+        context->GetValue<LootObject>("loot target")->Set(LootObject());
+    }
+    return result;
+}
+
+bool OpenLootAction::DoLoot(LootObject& lootObject)
+{
+    if (lootObject.IsEmpty())
+        return false;
+
+    Creature* creature = ai->GetCreature(lootObject.guid);
+    if (creature && bot->GetDistance(creature) > INTERACTION_DISTANCE)
+        return false;
+
+    if (creature && creature->HasFlag(UNIT_DYNAMIC_FLAGS, UNIT_DYNFLAG_LOOTABLE))
+    {
+        bot->GetMotionMaster()->Clear();
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT, 8);
+        *packet << lootObject.guid;
+        bot->GetSession()->QueuePacket(packet);
+        return true;
+    }
+
+    if (creature)
+    {
+        SkillType skill = creature->GetCreatureTemplate()->GetRequiredLootSkill();
+        if (!CanOpenLock(skill, lootObject.reqSkillValue))
+            return false;
+
+        bot->GetMotionMaster()->Clear();
+        switch (skill)
+        {
+        case SKILL_ENGINEERING:
+            return bot->HasSkill(SKILL_ENGINEERING) ? ai->CastSpell(ENGINEERING, creature) : false;
+        case SKILL_HERBALISM:
+            return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(32605, creature) : false;
+        case SKILL_MINING:
+            return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(32606, creature) : false;
+        default:
+            return bot->HasSkill(SKILL_SKINNING) ? ai->CastSpell(SKINNING, creature) : false;
+        }
+    }
+
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && bot->GetDistance(go) > INTERACTION_DISTANCE)
+        return false;
+
+    bot->GetMotionMaster()->Clear();
+    if (lootObject.skillId == SKILL_MINING)
+        return bot->HasSkill(SKILL_MINING) ? ai->CastSpell(MINING, bot) : false;
+
+    if (lootObject.skillId == SKILL_HERBALISM)
+        return bot->HasSkill(SKILL_HERBALISM) ? ai->CastSpell(HERB_GATHERING, bot) : false;
+
+    uint32 spellId = GetOpeningSpell(lootObject);
+    if (!spellId)
+        return false;
+
+    return ai->CastSpell(spellId, bot);
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject)
+{
+    GameObject* go = ai->GetGameObject(lootObject.guid);
+    if (go && go->isSpawned())
+        return GetOpeningSpell(lootObject, go);
+
+    return 0;
+}
+
+uint32 OpenLootAction::GetOpeningSpell(LootObject& lootObject, GameObject* go)
+{
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    for (uint32 spellId = 0; spellId < sSpellStore.GetNumRows(); spellId++)
+    {
+        if (spellId == MINING || spellId == HERB_GATHERING)
+            continue;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (CanOpenLock(lootObject, pSpellInfo, go))
+            return spellId;
+    }
+
+    return 0; //Spell 3365 = Opening?
+}
+
+bool OpenLootAction::CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go)
+{
+    for (int effIndex = 0; effIndex <= EFFECT_2; effIndex++)
+    {
+        if (pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_OPEN_LOCK && pSpellInfo->Effects[effIndex].Effect != SPELL_EFFECT_SKINNING)
+            return false;
+
+        uint32 lockId = go->GetGOInfo()->GetLockId();
+        if (!lockId)
+            return false;
+
+        LockEntry const *lockInfo = sLockStore.LookupEntry(lockId);
+        if (!lockInfo)
+            return false;
+
+        bool reqKey = false;                                    // some locks not have reqs
+
+        for(int j = 0; j < 8; ++j)
+        {
+            switch(lockInfo->Type[j])
+            {
+            /*
+            case LOCK_KEY_ITEM:
+                return true;
+            */
+            case LOCK_KEY_SKILL:
+                {
+                    if(uint32(pSpellInfo->Effects[effIndex].MiscValue) != lockInfo->Index[j])
+                        continue;
+
+                    uint32 skillId = SkillByLockType(LockType(lockInfo->Index[j]));
+                    if (skillId == SKILL_NONE)
+                        return true;
+
+                    if (CanOpenLock(skillId, lockInfo->Skill[j]))
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
+
+bool OpenLootAction::CanOpenLock(uint32 skillId, uint32 reqSkillValue)
+{
+    uint32 skillValue = bot->GetSkillValue(skillId);
+    return skillValue >= reqSkillValue || !reqSkillValue;
+}
+
+bool StoreLootAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket()); // (8+1+4+1+1+4+4+4+4+4+1)
+    ObjectGuid guid;
+    uint8 loot_type;
+    uint32 gold = 0;
+    uint8 items = 0;
+
+    p.rpos(0);
+    p >> guid;      // 8 corpse guid
+    p >> loot_type; // 1 loot type
+
+    if (p.size() > 10)
+    {
+        p >> gold;      // 4 money on corpse
+        p >> items;     // 1 number of items on corpse
+    }
+
+    if (gold > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_LOOT_MONEY, 0);
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    for (uint8 i = 0; i < items; ++i)
+    {
+        uint32 itemid;
+        uint32 itemcount;
+        uint8 lootslot_type;
+        uint8 itemindex;
+        bool grab = false;
+
+        p >> itemindex;
+        p >> itemid;
+        p >> itemcount;
+        p.read_skip<uint32>();  // display id
+        p.read_skip<uint32>();  // randomSuffix
+        p.read_skip<uint32>();  // randomPropertyId
+        p >> lootslot_type;     // 0 = can get, 1 = look only, 2 = master get
+
+        if (lootslot_type != LOOT_SLOT_TYPE_ALLOW_LOOT && lootslot_type != LOOT_SLOT_TYPE_OWNER)
+            continue;
+
+        if (loot_type != LOOT_SKINNING && !IsLootAllowed(itemid))
+            continue;
+
+        if (sRandomPlayerbotMgr.IsRandomBot(bot))
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+            if (proto)
+            {
+                uint32 price = itemcount * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) + gold;
+                uint32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                if (bot->GetGroup() && price)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, lootAmount + price);
+                }
+                else if (lootAmount)
+                {
+                    sRandomPlayerbotMgr.SetLootAmount(bot, 0);
+                }
+
+                Group* group = bot->GetGroup();
+                if (group)
+                {
+                    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+                    {
+                        if( ref->GetSource() != bot)
+                            sGuildTaskMgr.CheckItemTask(itemid, itemcount, ref->GetSource(), bot);
+                    }
+                }
+            }
+        }
+
+        WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_LOOT_ITEM, 1);
+        *packet << itemindex;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    AI_VALUE(LootObjectStack*, "available loot")->Remove(guid);
+
+    // release loot
+    WorldPacket* const packet = new WorldPacket(CMSG_LOOT_RELEASE, 8);
+    *packet << guid;
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool StoreLootAction::IsLootAllowed(uint32 itemid)
+{
+    LootStrategy lootStrategy = AI_VALUE(LootStrategy, "loot strategy");
+
+    if (lootStrategy == LOOTSTRATEGY_ALL)
+        return true;
+
+    set<uint32>& lootItems = AI_VALUE(set<uint32>&, "always loot list");
+    if (lootItems.find(itemid) != lootItems.end())
+        return true;
+
+    ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemid);
+    if (!proto)
+        return false;
+
+    uint32 max = proto->MaxCount;
+    if (max > 0 && bot->HasItemCount(itemid, max, true))
+        return false;
+
+    if (proto->StartQuest ||
+        proto->Bonding == BIND_QUEST_ITEM ||
+        proto->Bonding == BIND_QUEST_ITEM1 ||
+        proto->Class == ITEM_CLASS_QUEST)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_QUEST)
+        return false;
+
+    ostringstream out; out << itemid;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_SKILL || usage == ITEM_USAGE_USE || usage == ITEM_USAGE_GUILD_TASK)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_SKILL)
+        return false;
+
+    if (proto->Class == ITEM_CLASS_MONEY || proto->Quality == ITEM_QUALITY_POOR)
+        return true;
+
+    if (lootStrategy == LOOTSTRATEGY_GRAY)
+        return true;
+
+    if (proto->Bonding == BIND_WHEN_PICKED_UP)
+        return false;
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootAction.h b/src/plugins/playerbot/strategy/actions/LootAction.h
new file mode 100644
index 0000000..c18fbb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootAction.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class LootAction : public MovementAction
+    {
+    public:
+        LootAction(PlayerbotAI* ai) : MovementAction(ai, "loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class OpenLootAction : public MovementAction
+    {
+    public:
+        OpenLootAction(PlayerbotAI* ai) : MovementAction(ai, "open loot") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool DoLoot(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject);
+        uint32 GetOpeningSpell(LootObject& lootObject, GameObject* go);
+        bool CanOpenLock(LootObject& lootObject, const SpellInfo* pSpellInfo, GameObject* go);
+        bool CanOpenLock(uint32 skillId, uint32 reqSkillValue);
+    };
+
+    class StoreLootAction : public MovementAction
+    {
+    public:
+        StoreLootAction(PlayerbotAI* ai) : MovementAction(ai, "store loot") {}
+        virtual bool Execute(Event event);
+
+    protected:
+        bool IsLootAllowed(uint32 itemid);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.cpp b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
new file mode 100644
index 0000000..498cb42
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootRollAction.h"
+#include "../../../Groups/Group.h"
+
+
+using namespace ai;
+
+bool LootRollAction::Execute(Event event)
+{
+    Player *bot = QueryItemUsageAction::ai->GetBot();
+
+    WorldPacket p(event.getPacket()); //WorldPacket packet for CMSG_LOOT_ROLL, (8+4+1)
+    ObjectGuid guid;
+    uint32 slot;
+    uint8 rollType;
+    p.rpos(0); //reset packet pointer
+    p >> guid; //guid of the item rolled
+    p >> slot; //number of players invited to roll
+    p >> rollType; //need,greed or pass on roll
+
+    Group* group = bot->GetGroup();
+    if(!group)
+        return false;
+
+    RollVote vote = PASS;
+    for (vector<Roll*>::iterator i = group->GetRolls()->begin(); i != group->GetRolls()->end(); ++i)
+    {
+        if ((*i)->isValid() && (*i)->itemGUID == guid && (*i)->itemSlot == slot)
+        {
+            uint32 itemId = (*i)->itemid;
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(itemId);
+            if (!proto)
+                continue;
+
+            switch (proto->Class)
+            {
+            case ITEM_CLASS_WEAPON:
+            case ITEM_CLASS_ARMOR:
+                if (QueryItemUsage(proto))
+                    vote = NEED;
+                else if (bot->HasSkill(SKILL_ENCHANTING))
+                    vote = DISENCHANT;
+                break;
+            default:
+                if (IsLootAllowed(itemId))
+                    vote = NEED;
+                break;
+            }
+            break;
+        }
+    }
+
+    switch (group->GetLootMethod())
+    {
+    case MASTER_LOOT:
+    case FREE_FOR_ALL:
+        group->CountRollVote(bot->GetGUID(), guid, PASS);
+        break;
+    default:
+        group->CountRollVote(bot->GetGUID(), guid, vote);
+        break;
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootRollAction.h b/src/plugins/playerbot/strategy/actions/LootRollAction.h
new file mode 100644
index 0000000..05651a4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootRollAction.h
@@ -0,0 +1,15 @@
+#pragma once
+
+#include "../Action.h"
+#include "QueryItemUsageAction.h"
+#include "LootAction.h"
+
+namespace ai
+{
+    class LootRollAction : public QueryItemUsageAction, public StoreLootAction {
+    public:
+        LootRollAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "loot roll"), StoreLootAction(ai) {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
new file mode 100644
index 0000000..633429e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.cpp
@@ -0,0 +1,100 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootStrategyAction.h"
+
+
+using namespace ai;
+
+
+bool LootStrategyAction::Execute(Event event)
+{
+    string strategy = event.getParam();
+
+    LootObjectStack* lootItems = AI_VALUE(LootObjectStack*, "available loot");
+    set<uint32>& alwaysLootItems = AI_VALUE(set<uint32>&, "always loot list");
+    Value<LootStrategy>* lootStrategy = context->GetValue<LootStrategy>("loot strategy");
+
+    if (strategy == "?")
+    {
+        ostringstream out;
+        out << "Loot strategy: ";
+        out << LootStrategy2string(lootStrategy->Get());
+        out << ", always loot items: ";
+
+        for (set<uint32>::iterator i = alwaysLootItems.begin(); i != alwaysLootItems.end(); i++)
+        {
+            ItemTemplate const *proto = sObjectMgr->GetItemTemplate(*i);
+            if (!proto)
+                continue;
+
+            out << chat->formatItem(proto);
+        }
+        ai->TellMaster(out);
+    }
+    else
+    {
+        ItemIds items = chat->parseItems(strategy);
+
+        if (items.size() == 0)
+        {
+            lootStrategy->Set(String2LootStrategy(strategy));
+            ostringstream out;
+            out << "Loot strategy set to " << LootStrategy2string(lootStrategy->Get());
+            ai->TellMaster(out);
+            return true;
+        }
+
+        bool remove = strategy.size() > 1 && strategy.substr(0, 1) == "-";
+        for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+        {
+            uint32 itemid = *i;
+            if (remove)
+            {
+                set<uint32>::iterator j = alwaysLootItems.find(itemid);
+                if (j != alwaysLootItems.end())
+                    alwaysLootItems.erase(j);
+
+                ai->TellMaster("Item(s) removed from always loot list");
+            }
+            else
+            {
+                alwaysLootItems.insert(itemid);
+                ai->TellMaster("Item(s) added to always loot list");
+            }
+        }
+    }
+
+    return true;
+}
+
+
+LootStrategy LootStrategyAction::String2LootStrategy(string strategy)
+{
+    if (strategy == "*" || strategy == "all")
+        return LOOTSTRATEGY_ALL;
+    else if (strategy == "q" || strategy == "quest")
+        return LOOTSTRATEGY_QUEST;
+    else if (strategy == "s" || strategy == "skill")
+        return LOOTSTRATEGY_SKILL;
+    else if (strategy == "g" || strategy == "gray")
+        return LOOTSTRATEGY_GRAY;
+    else
+        return LOOTSTRATEGY_NORMAL;
+}
+
+string LootStrategyAction::LootStrategy2string(LootStrategy lootStrategy)
+{
+    switch (lootStrategy)
+    {
+    case LOOTSTRATEGY_ALL:
+        return "all";
+    case LOOTSTRATEGY_QUEST:
+        return "quest";
+    case LOOTSTRATEGY_SKILL:
+        return "skill";
+    case LOOTSTRATEGY_GRAY:
+        return "gray";
+    default:
+        return "normal";
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/LootStrategyAction.h b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
new file mode 100644
index 0000000..51e1f23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/LootStrategyAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class LootStrategyAction : public Action {
+    public:
+        LootStrategyAction(PlayerbotAI* ai) : Action(ai, "ll") {}
+        virtual bool Execute(Event event);
+
+    private:
+        static LootStrategy String2LootStrategy(string strategy);
+        static string LootStrategy2string(LootStrategy lootStrategy);
+   
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.cpp b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
new file mode 100644
index 0000000..f1fcfc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.cpp
@@ -0,0 +1,373 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../values/LastMovementValue.h"
+#include "MovementActions.h"
+#include "../../../Movement/MotionMaster.h"
+#include "../../../Movement/MovementGenerator.h"
+#include "../../FleeManager.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool MovementAction::MoveNear(uint32 mapId, float x, float y, float z, float distance)
+{
+    float angle = GetFollowAngle();
+    return MoveTo(mapId, x + cos(angle) * distance, y + sin(angle) * distance, z);
+}
+
+bool MovementAction::MoveNear(WorldObject* target, float distance)
+{
+    if (!target)
+        return false;
+
+    distance += target->GetObjectSize() / 2.0f;
+
+    float followAngle = GetFollowAngle();
+    for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+    {
+        bool moved = MoveTo(target->GetMapId(),
+            target->GetPositionX() + cos(angle) * distance,
+            target->GetPositionY()+ sin(angle) * distance,
+            target->GetPositionZ());
+        if (moved)
+            return true;
+    }
+    return false;
+}
+
+bool MovementAction::MoveTo(uint32 mapId, float x, float y, float z)
+{
+    bot->UpdateGroundPositionZ(x, y, z);
+    if (!IsMovingAllowed(mapId, x, y, z))
+        return false;
+
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.contactDistance)
+    {
+        WaitForReach(distance);
+
+        if (bot->IsSitState())
+            bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+        if (bot->IsNonMeleeSpellCast(true))
+        {
+            bot->CastStop();
+            ai->InterruptSpell();
+        }
+
+        bool generatePath = bot->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) &&
+                !bot->IsFlying() && !bot->IsUnderWater();
+        MotionMaster &mm = *bot->GetMotionMaster();
+        mm.Clear();
+
+        float botZ = bot->GetPositionZ();
+        if (z - botZ > 0.5f && bot->GetDistance2d(x, y) <= 5.0f)
+        {
+            float speed = bot->GetSpeed(MOVE_RUN);
+            mm.MoveJump(x, y, botZ + 0.5f, speed, speed, 1);
+        }
+        else
+            mm.MovePoint(mapId, x, y, z, generatePath);
+    }
+
+    AI_VALUE(LastMovement&, "last movement").Set(x, y, z, bot->GetOrientation());
+    return true;
+}
+
+bool MovementAction::MoveTo(Unit* target, float distance)
+{
+    if (!IsMovingAllowed(target))
+        return false;
+
+    float bx = bot->GetPositionX();
+    float by = bot->GetPositionY();
+    float bz = bot->GetPositionZ();
+
+    float tx = target->GetPositionX();
+    float ty = target->GetPositionY();
+    float tz = target->GetPositionZ();
+
+    float distanceToTarget = bot->GetDistance(target);
+    float angle = bot->GetAngle(target);
+    float needToGo = distanceToTarget - distance;
+
+    float maxDistance = sPlayerbotAIConfig.spellDistance;
+    if (needToGo > 0 && needToGo > maxDistance)
+        needToGo = maxDistance;
+    else if (needToGo < 0 && needToGo < -maxDistance)
+        needToGo = -maxDistance;
+
+    float dx = cos(angle) * needToGo + bx;
+    float dy = sin(angle) * needToGo + by;
+
+    return MoveTo(target->GetMapId(), dx, dy, tz);
+}
+
+float MovementAction::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+bool MovementAction::IsMovingAllowed(Unit* target)
+{
+    if (!target)
+        return false;
+
+    if (bot->GetMapId() != target->GetMapId())
+        return false;
+
+    float distance = bot->GetDistance(target);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed(uint32 mapId, float x, float y, float z)
+{
+    float distance = bot->GetDistance(x, y, z);
+    if (distance > sPlayerbotAIConfig.reactDistance)
+        return false;
+
+    return IsMovingAllowed();
+}
+
+bool MovementAction::IsMovingAllowed()
+{
+    if (bot->isFrozen() || bot->IsPolymorphed() ||
+            (bot->isDead() && !bot->GetCorpse()) ||
+            bot->IsBeingTeleported() ||
+            bot->isInRoots() ||
+            bot->HasAuraType(SPELL_AURA_MOD_CONFUSE) || bot->IsCharmed() ||
+            bot->HasAuraType(SPELL_AURA_MOD_STUN) || bot->IsFlying())
+        return false;
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    return mm.GetCurrentMovementGeneratorType() != FLIGHT_MOTION_TYPE;
+}
+
+bool MovementAction::Follow(Unit* target, float distance)
+{
+    return Follow(target, distance, GetFollowAngle());
+}
+
+bool MovementAction::Follow(Unit* target, float distance, float angle)
+{
+    MotionMaster &mm = *bot->GetMotionMaster();
+
+    if (!target)
+        return false;
+
+    if (bot->GetDistance2d(target->GetPositionX(), target->GetPositionY()) <= sPlayerbotAIConfig.sightDistance &&
+            abs(bot->GetPositionZ() - target->GetPositionZ()) >= sPlayerbotAIConfig.spellDistance)
+    {
+        mm.Clear();
+        float x = bot->GetPositionX(), y = bot->GetPositionY(), z = target->GetPositionZ();
+        if (target->GetMapId() && bot->GetMapId() != target->GetMapId())
+        {
+            bot->TeleportTo(target->GetMapId(), x, y, z, bot->GetOrientation());
+        }
+        else
+        {
+            bot->Relocate(x, y, z, bot->GetOrientation());
+        }
+        AI_VALUE(LastMovement&, "last movement").Set(target);
+        return true;
+    }
+
+    if (!IsMovingAllowed(target))
+        return false;
+
+    if (target->IsFriendlyTo(bot) && bot->IsMounted() && AI_VALUE(list<ObjectGuid>, "possible targets").empty())
+        distance += angle;
+
+    if (bot->GetDistance(target) <= sPlayerbotAIConfig.followDistance)
+        return false;
+
+    if (bot->IsSitState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (bot->IsNonMeleeSpellCast(true))
+    {
+        bot->CastStop();
+        ai->InterruptSpell();
+    }
+
+    mm.MoveFollow(target, distance, angle);
+
+    AI_VALUE(LastMovement&, "last movement").Set(target);
+    return true;
+}
+
+void MovementAction::WaitForReach(float distance)
+{
+    float delay = 1000.0f * distance / bot->GetSpeed(MOVE_RUN) + sPlayerbotAIConfig.reactDelay;
+
+    if (delay > sPlayerbotAIConfig.maxWaitForMove)
+        delay = sPlayerbotAIConfig.maxWaitForMove;
+
+    Unit* target = *ai->GetAiObjectContext()->GetValue<Unit*>("current target");
+    Unit* player = *ai->GetAiObjectContext()->GetValue<Unit*>("enemy player target");
+    if ((player || target) && delay > sPlayerbotAIConfig.globalCoolDown)
+        delay = sPlayerbotAIConfig.globalCoolDown;
+
+    ai->SetNextCheckDelay((uint32)delay);
+}
+
+bool MovementAction::Flee(Unit *target)
+{
+    Player* master = GetMaster();
+    if (!target)
+        target = master;
+
+    if (!target)
+        return false;
+
+    if (!sPlayerbotAIConfig.fleeingEnabled)
+        return false;
+
+    if (!IsMovingAllowed())
+        return false;
+
+    FleeManager manager(bot, sPlayerbotAIConfig.fleeDistance, GetFollowAngle());
+
+    float rx, ry, rz;
+    if (!manager.CalculateDestination(&rx, &ry, &rz))
+        return false;
+
+    return MoveTo(target->GetMapId(), rx, ry, rz);
+}
+
+bool FleeAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "current target"));
+}
+
+bool FleeAction::isUseful()
+{
+    return AI_VALUE(uint8, "attacker count") > 0 &&
+            AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.tooCloseDistance;
+}
+
+bool RunAwayAction::Execute(Event event)
+{
+    return Flee(AI_VALUE(Unit*, "master target"));
+}
+
+bool MoveRandomAction::Execute(Event event)
+{
+    WorldObject* target = NULL;
+
+    if (!(rand() % 3))
+    {
+        list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+        for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+        {
+            target = ai->GetUnit(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    if (!target || !(rand() % 3))
+    {
+        list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+        for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+        {
+            target = ai->GetGameObject(*i);
+
+            if (target && bot->GetDistance(target) > sPlayerbotAIConfig.tooCloseDistance)
+                break;
+        }
+    }
+
+    float distance = sPlayerbotAIConfig.tooCloseDistance + sPlayerbotAIConfig.grindDistance * urand(3, 10) / 10.0f;
+
+    Map* map = bot->GetMap();
+    if (target)
+    {
+        float x = target->GetPositionX();
+        float y = target->GetPositionY();
+        float z = target->GetPositionZ();
+        if (!map->IsInWater(x, y, z))
+        {
+            return MoveNear(target);
+        }
+    }
+
+    for (int i = 0; i < 10; ++i)
+    {
+        float x = bot->GetPositionX();
+        float y = bot->GetPositionY();
+        float z = bot->GetPositionZ();
+        x += urand(0, distance) - distance / 2;
+        y += urand(0, distance) - distance / 2;
+        bot->UpdateGroundPositionZ(x, y, z);
+
+        if (map->IsInWater(x, y, z))
+            continue;
+
+        bool moved = MoveNear(bot->GetMapId(), x, y, z);
+        if (moved)
+            return true;
+    }
+
+    return false;
+}
+
+bool MoveToLootAction::Execute(Event event)
+{
+    LootObject loot = AI_VALUE(LootObject, "loot target");
+    if (!loot.IsLootPossible(bot))
+        return false;
+
+    return MoveNear(loot.GetWorldObject(bot));
+}
+
+bool MoveOutOfEnemyContactAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    return MoveNear(target, sPlayerbotAIConfig.meleeDistance);
+}
+
+bool MoveOutOfEnemyContactAction::isUseful()
+{
+    return AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+}
+
+bool SetFacingTargetAction::Execute(Event event)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    if (!target)
+        return false;
+
+    bot->SetFacingTo(bot->GetAngle(target));
+    ai->SetNextCheckDelay(sPlayerbotAIConfig.globalCoolDown);
+    return true;
+}
+
+bool SetFacingTargetAction::isUseful()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/MovementActions.h b/src/plugins/playerbot/strategy/actions/MovementActions.h
new file mode 100644
index 0000000..dc27b92
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/MovementActions.h
@@ -0,0 +1,92 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class MovementAction : public Action {
+    public:
+        MovementAction(PlayerbotAI* ai, string name) : Action(ai, name)
+        {
+            bot = ai->GetBot();
+        }
+
+    protected:
+        bool MoveNear(uint32 mapId, float x, float y, float z, float distance = sPlayerbotAIConfig.followDistance);
+        bool MoveTo(uint32 mapId, float x, float y, float z);
+        bool MoveTo(Unit* target, float distance = 0.0f);
+        bool MoveNear(WorldObject* target, float distance = sPlayerbotAIConfig.followDistance);
+        float GetFollowAngle();
+        bool Follow(Unit* target, float distance = sPlayerbotAIConfig.followDistance);
+        bool Follow(Unit* target, float distance, float angle);
+        void WaitForReach(float distance);
+        bool IsMovingAllowed(Unit* target);
+        bool IsMovingAllowed(uint32 mapId, float x, float y, float z);
+        bool IsMovingAllowed();
+        bool Flee(Unit *target);
+
+    protected:
+        Player* bot;
+    };
+
+    class FleeAction : public MovementAction
+    {
+    public:
+        FleeAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : MovementAction(ai, "flee")
+        {
+			this->distance = distance;
+		}
+
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+
+	private:
+		float distance;
+    };
+
+
+    class RunAwayAction : public MovementAction
+    {
+    public:
+        RunAwayAction(PlayerbotAI* ai) : MovementAction(ai, "runaway") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveRandomAction : public MovementAction
+    {
+    public:
+        MoveRandomAction(PlayerbotAI* ai) : MovementAction(ai, "move random") {}
+        virtual bool Execute(Event event);
+        virtual bool isPossible()
+        {
+            return MovementAction::isPossible() &&
+                    AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.mediumHealth &&
+                    (!AI_VALUE2(uint8, "mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumMana);
+        }
+    };
+
+    class MoveToLootAction : public MovementAction
+    {
+    public:
+        MoveToLootAction(PlayerbotAI* ai) : MovementAction(ai, "move to loot") {}
+        virtual bool Execute(Event event);
+    };
+
+    class MoveOutOfEnemyContactAction : public MovementAction
+    {
+    public:
+        MoveOutOfEnemyContactAction(PlayerbotAI* ai) : MovementAction(ai, "move out of enemy contact") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+    class SetFacingTargetAction : public MovementAction
+    {
+    public:
+        SetFacingTargetAction(PlayerbotAI* ai) : MovementAction(ai, "set facing") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
new file mode 100644
index 0000000..56961c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/actions/NonCombatActions.h b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
new file mode 100644
index 0000000..d66e92c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/NonCombatActions.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+#include "UseItemAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class DrinkAction : public UseItemAction
+    {
+    public:
+        DrinkAction(PlayerbotAI* ai) : UseItemAction(ai, "drink") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+        }
+    };
+
+    class EatAction : public UseItemAction
+    {
+    public:
+        EatAction(PlayerbotAI* ai) : UseItemAction(ai, "food") {}
+
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsInCombat())
+                return false;
+
+            return UseItemAction::Execute(event);
+        }
+
+        virtual bool isUseful()
+        {
+            return UseItemAction::isUseful() && AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.lowHealth;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
new file mode 100644
index 0000000..fb558df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PassLeadershipToMasterAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class PassLeadershipToMasterAction : public Action {
+    public:
+        PassLeadershipToMasterAction(PlayerbotAI* ai) : Action(ai, "leader") {}
+
+        virtual bool Execute(Event event)
+        {
+            Player* master = GetMaster();
+            if (master && bot->GetGroup() && bot->GetGroup()->IsMember(master->GetGUID()))
+            {
+                WorldPacket p(SMSG_GROUP_SET_LEADER, 8);
+                p << master->GetGUID();
+                bot->GetSession()->HandleGroupSetLeaderOpcode(p);
+                return true;
+            }
+
+            return false;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.cpp b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
new file mode 100644
index 0000000..242c7fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionAction.h"
+#include "../values/PositionValue.h"
+
+using namespace ai;
+
+bool PositionAction::Execute(Event event)
+{
+	string qualifier = event.getParam();
+	if (qualifier.empty())
+		return false;
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    pos.Set( master->GetPositionX(), master->GetPositionY(), master->GetPositionZ());
+
+    ostringstream out; out << "Position " << qualifier << " is set";
+    ai->TellMaster(out);
+    return true;
+}
+
+bool MoveToPositionAction::Execute(Event event)
+{
+	ai::Position& pos = context->GetValue<ai::Position&>("position", qualifier)->Get();
+    if (!pos.isSet())
+    {
+        ostringstream out; out << "Position " << qualifier << " is not set";
+        ai->TellMaster(out);
+        return false;
+    }
+
+    return MoveTo(bot->GetMapId(), pos.x, pos.y, pos.z);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/PositionAction.h b/src/plugins/playerbot/strategy/actions/PositionAction.h
new file mode 100644
index 0000000..f96553b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/PositionAction.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class PositionAction : public Action
+    {
+    public:
+        PositionAction(PlayerbotAI* ai) : Action(ai, "position")
+        {}
+
+        virtual bool Execute(Event event);
+
+    };
+
+    class MoveToPositionAction : public MovementAction
+    {
+    public:
+        MoveToPositionAction(PlayerbotAI* ai, string qualifier) : MovementAction(ai, "move to position"), qualifier(qualifier)
+        {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        string qualifier;
+    };
+
+    class GuardAction : public MoveToPositionAction
+    {
+    public:
+        GuardAction(PlayerbotAI* ai) : MoveToPositionAction(ai, "guard")
+        {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
new file mode 100644
index 0000000..4cbd973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.cpp
@@ -0,0 +1,172 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryItemUsageAction.h"
+#include "../values/ItemUsageValue.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+
+using namespace ai;
+
+
+bool QueryItemUsageAction::Execute(Event event)
+{
+    WorldPacket& data = event.getPacket();
+    if (!data.empty())
+    {
+        data.rpos(0);
+
+        ObjectGuid guid;
+        data >> guid;
+        if (guid.GetRawValue() != bot->GetGUID())
+            return false;
+
+        uint32 received, created, isShowChatMessage, notUsed, itemId,
+            suffixFactor, itemRandomPropertyId, count, invCount;
+        uint8 bagSlot;
+
+        data >> received;                               // 0=looted, 1=from npc
+        data >> created;                                // 0=received, 1=created
+        data >> isShowChatMessage;                                      // IsShowChatMessage
+        data >> bagSlot;
+                                                                // item slot, but when added to stack: 0xFFFFFFFF
+        data >> notUsed;
+        data >> itemId;
+        data >> suffixFactor;
+        data >> itemRandomPropertyId;
+        data >> count;
+        data >> invCount;
+
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(itemId);
+        if (!item)
+            return false;
+
+        ostringstream out; out << chat->formatItem(item, count);
+        if (created)
+            out << " created";
+        else if (received)
+            out << " received";
+        ai->TellMaster(out);
+
+        QueryItemUsage(item);
+        QueryQuestItem(itemId);
+        return true;
+    }
+
+    string text = event.getParam();
+
+    ItemIds items = chat->parseItems(text);
+    QueryItemsUsage(items);
+    return true;
+}
+
+bool QueryItemUsageAction::QueryItemUsage(ItemTemplate const *item)
+{
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    switch (usage)
+    {
+    case ITEM_USAGE_EQUIP:
+        ai->TellMaster("Equip");
+        return true;
+    case ITEM_USAGE_REPLACE:
+        ai->TellMaster("Equip (replace)");
+        return true;
+    case ITEM_USAGE_SKILL:
+        ai->TellMaster("Tradeskill");
+        return true;
+    case ITEM_USAGE_USE:
+        ai->TellMaster("Use");
+        return true;
+    case ITEM_USAGE_GUILD_TASK:
+        ai->TellMaster("Guild task");
+        return true;
+    }
+
+    return false;
+}
+
+void QueryItemUsageAction::QueryItemPrice(ItemTemplate const *item)
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    if (item->Bonding == BIND_WHEN_PICKED_UP)
+        return;
+
+    list<Item*> items = InventoryAction::parseItems(item->Name1);
+    if (!items.empty())
+    {
+        for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        {
+            Item* sell = *i;
+            int32 sellPrice = sell->GetCount() * auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+            ostringstream out;
+            out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+            ai->TellMaster(out.str());
+        }
+    }
+
+    ostringstream out; out << item->ItemId;
+    ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+    if (usage == ITEM_USAGE_NONE)
+        return;
+
+    int32 buyPrice = auctionbot.GetBuyPrice(item) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+    if (buyPrice)
+    {
+        ostringstream out;
+        out << "Will buy for " << chat->formatMoney(buyPrice);
+        ai->TellMaster(out.str());
+    }
+}
+
+void QueryItemUsageAction::QueryItemsUsage(ItemIds items)
+{
+    for (ItemIds::iterator i = items.begin(); i != items.end(); i++)
+    {
+        ItemTemplate const *item = sObjectMgr->GetItemTemplate(*i);
+        QueryItemUsage(item);
+        QueryQuestItem(*i);
+        QueryItemPrice(item);
+    }
+}
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId)
+{
+    Player *bot = ai->GetBot();
+    QuestStatusMap const& questMap = bot->getQuestStatusMap();
+    for (QuestStatusMap::const_iterator i = questMap.begin(); i != questMap.end(); i++)
+    {
+        const Quest *questTemplate = sObjectMgr->GetQuestTemplate( i->first );
+        if( !questTemplate )
+            continue;
+
+        uint32 questId = questTemplate->GetQuestId();
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || (status == QUEST_STATE_COMPLETE && !bot->GetQuestRewardStatus(questId)))
+        {
+            QuestStatusData const& questStatus = i->second;
+            QueryQuestItem(itemId, questTemplate, &questStatus);
+        }
+    }
+}
+
+
+void QueryItemUsageAction::QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus)
+{
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (questTemplate->RequiredItemId[i] != itemId)
+            continue;
+
+        int required = questTemplate->RequiredItemCount[i];
+        int available = questStatus->ItemCount[i];
+
+        if (!required)
+            continue;
+
+        ai->TellMaster(chat->formatQuestObjective(chat->formatQuest(questTemplate), available, required));
+    }
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
new file mode 100644
index 0000000..643ae96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryItemUsageAction.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class QueryItemUsageAction : public InventoryAction {
+    public:
+        QueryItemUsageAction(PlayerbotAI* ai, string name = "query item usage") : InventoryAction(ai, name) {}
+        virtual bool Execute(Event event);
+
+    protected:
+        void QueryItemsUsage(ItemIds items);
+        bool QueryItemUsage(ItemTemplate const *item);
+        void QueryItemPrice(ItemTemplate const *item);
+        void QueryQuestItem(uint32 itemId, const Quest *questTemplate, const QuestStatusData *questStatus);
+        void QueryQuestItem(uint32 itemId);
+
+    private:
+        ostringstream out;
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
new file mode 100644
index 0000000..33eddca
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.cpp
@@ -0,0 +1,89 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QueryQuestAction.h"
+
+
+using namespace ai;
+
+void QueryQuestAction::TellObjective(string name, int available, int required)
+{
+    ai->TellMaster(chat->formatQuestObjective(name, available, required));
+}
+
+
+bool QueryQuestAction::Execute(Event event)
+{
+
+    Player *bot = ai->GetBot();
+    string text = event.getParam();
+
+    PlayerbotChatHandler ch(bot);
+    uint32 questId = ch.extractQuestId(text);
+    if (!questId)
+        return false;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        if(questId != bot->GetQuestSlotQuestId(slot))
+            continue;
+
+        ostringstream out;
+        out << "--- " << chat->formatQuest(sObjectMgr->GetQuestTemplate(questId)) << " ";
+        if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        {
+            out << "|c0000FF00completed|r ---";
+            ai->TellMaster(out);
+        }
+        else
+        {
+            out << "|c00FF0000not completed|r ---";
+            ai->TellMaster(out);
+            TellObjectives(questId);
+        }
+
+        return true;
+    }
+
+    return false;
+}
+
+void QueryQuestAction::TellObjectives(uint32 questId)
+{
+    Quest const* questTemplate = sObjectMgr->GetQuestTemplate(questId);
+    QuestStatusMap &questMap = bot->getQuestStatusMap();
+    QuestStatusData questStatus = questMap[questId];
+
+    for (int i = 0; i < QUEST_OBJECTIVES_COUNT; i++)
+    {
+        if (!questTemplate->ObjectiveText[i].empty())
+            ai->TellMaster(questTemplate->ObjectiveText[i]);
+
+        if (questTemplate->RequiredItemId[i])
+        {
+            int required = questTemplate->RequiredItemCount[i];
+            int available = questStatus.ItemCount[i];
+            ItemTemplate const* proto = sObjectMgr->GetItemTemplate(questTemplate->RequiredItemId[i]);
+            TellObjective(chat->formatItem(proto), available, required);
+        }
+
+        if (questTemplate->RequiredNpcOrGo[i])
+        {
+            int required = questTemplate->RequiredNpcOrGoCount[i];
+            int available = questStatus.CreatureOrGOCount[i];
+
+            if (questTemplate->RequiredNpcOrGo[i] < 0)
+            {
+                GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->name, available, required);
+            }
+            else
+            {
+
+                CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(questTemplate->RequiredNpcOrGo[i]);
+                if (info)
+                    TellObjective(info->Name, available, required);
+            }
+        }
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/QueryQuestAction.h b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
new file mode 100644
index 0000000..1822293
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QueryQuestAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class QueryQuestAction : public Action {
+    public:
+        QueryQuestAction(PlayerbotAI* ai) : Action(ai, "query quest") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void TellObjectives(uint32 questId);
+        void TellObjective(string name, int available, int required);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.cpp b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
new file mode 100644
index 0000000..2b1cfbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool QuestAction::Execute(Event event)
+{
+    ObjectGuid guid = event.getObject();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (!guid)
+    {
+        Unit* target = master->GetSelectedUnit();
+        if (target)
+            guid = target->GetGUID();
+    }
+
+    if (!guid)
+        return false;
+
+    return ProcessQuests(guid);
+}
+
+bool QuestAction::ProcessQuests(ObjectGuid questGiver)
+{
+    GameObject *gameObject = ai->GetGameObject(questGiver);
+    if (gameObject && gameObject->GetGoType() == GAMEOBJECT_TYPE_QUESTGIVER)
+        return ProcessQuests(gameObject);
+
+    Creature* creature = ai->GetCreature(questGiver);
+    if (creature)
+        return ProcessQuests(creature);
+
+    return false;
+}
+
+bool QuestAction::ProcessQuests(WorldObject* questGiver)
+{
+    ObjectGuid guid = questGiver->GetGUID();
+
+    if (bot->GetDistance(questGiver) > INTERACTION_DISTANCE)
+    {
+        ai->TellMaster("Cannot talk to quest giver");
+        return false;
+    }
+
+    if (!bot->isInFront(questGiver, M_PI / 2))
+        bot->SetFacingTo(bot->GetAngle(questGiver));
+
+    bot->SetSelection(guid);
+    bot->PrepareQuestMenu(guid);
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 i = 0; i < questMenu.GetMenuItemCount(); ++i)
+    {
+        QuestMenuItem const& menuItem = questMenu.GetItem(i);
+        uint32 questID = menuItem.QuestId;
+        Quest const* quest = sObjectMgr->GetQuestTemplate(questID);
+        if (!quest)
+            continue;
+
+        ProcessQuest(quest, questGiver);
+    }
+
+    return true;
+}
+
+bool QuestAction::AcceptQuest(Quest const* quest, uint64 questGiver)
+{
+    std::ostringstream out;
+
+    uint32 questId = quest->GetQuestId();
+
+    if (bot->GetQuestStatus(questId) == QUEST_STATUS_COMPLETE)
+        out << "Already completed";
+    else if (! bot->CanTakeQuest(quest, false))
+    {
+        if (! bot->SatisfyQuestStatus(quest, false))
+            out << "Already on";
+        else
+            out << "Can't take";
+    }
+    else if (! bot->SatisfyQuestLog(false))
+        out << "Quest log is full";
+    else if (! bot->CanAddQuest(quest, false))
+        out << "Bags are full";
+
+    else
+    {
+        WorldPacket p(CMSG_QUESTGIVER_ACCEPT_QUEST);
+        uint32 unk1 = 0;
+        p << questGiver << questId << unk1;
+        p.rpos(0);
+        bot->GetSession()->HandleQuestgiverAcceptQuestOpcode(p);
+
+        if (bot->GetQuestStatus(questId) != QUEST_STATUS_NONE)
+        {
+            out << "Accepted " << chat->formatQuest(quest);
+            ai->TellMaster(out);
+            return true;
+        }
+    }
+
+    out << " " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+    return false;
+}
+
+bool QuestObjectiveCompletedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    uint32 entry, questId, available, required;
+    ObjectGuid guid;
+    p >> questId >> entry >> available >> required >> guid;
+
+    if (entry & 0x80000000)
+    {
+        entry &= 0x7FFFFFFF;
+        GameObjectTemplate const* info = sObjectMgr->GetGameObjectTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->name, available, required));
+    }
+    else
+    {
+        CreatureTemplate const* info = sObjectMgr->GetCreatureTemplate(entry);
+        if (info)
+            ai->TellMaster(chat->formatQuestObjective(info->Name, available, required));
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/QuestAction.h b/src/plugins/playerbot/strategy/actions/QuestAction.h
new file mode 100644
index 0000000..97010ed
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/QuestAction.h
@@ -0,0 +1,33 @@
+#pragma once
+
+#include "../Action.h"
+#include "../../../Quests/QuestDef.h"
+
+namespace ai
+{
+    class QuestAction : public Action
+    {
+    public:
+        QuestAction(PlayerbotAI* ai, string name) : Action(ai, name) {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver) = 0;
+
+    protected:
+        bool AcceptQuest(Quest const* quest, uint64 questGiver);
+        bool ProcessQuests(ObjectGuid questGiver);
+        bool ProcessQuests(WorldObject* questGiver);
+    };
+
+    class QuestObjectiveCompletedAction : public Action
+    {
+    public:
+        QuestObjectiveCompletedAction(PlayerbotAI* ai) : Action(ai, "quest objective completed") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReachTargetActions.h b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
new file mode 100644
index 0000000..c988365
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReachTargetActions.h
@@ -0,0 +1,57 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ReachTargetAction : public MovementAction
+    {
+    public:
+        ReachTargetAction(PlayerbotAI* ai, string name, float distance) : MovementAction(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool Execute(Event event)
+		{
+			return MoveTo(AI_VALUE(Unit*, "current target"), distance);
+        }
+        virtual bool isUseful()
+		{
+            return AI_VALUE2(float, "distance", "current target") > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class CastReachTargetSpellAction : public CastSpellAction
+    {
+    public:
+        CastReachTargetSpellAction(PlayerbotAI* ai, string spell, float distance) : CastSpellAction(ai, spell)
+		{
+            this->distance = distance;
+        }
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(float, "distance", "current target") > distance;
+		}
+
+    protected:
+        float distance;
+    };
+
+    class ReachMeleeAction : public ReachTargetAction
+	{
+    public:
+        ReachMeleeAction(PlayerbotAI* ai) : ReachTargetAction(ai, "reach melee", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class ReachSpellAction : public ReachTargetAction
+	{
+    public:
+        ReachSpellAction(PlayerbotAI* ai, float distance = sPlayerbotAIConfig.spellDistance) : ReachTargetAction(ai, "reach spell", distance) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
new file mode 100644
index 0000000..98f8c4b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.cpp
@@ -0,0 +1,84 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReadyCheckAction.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+bool ReadyCheckAction::Execute(Event event)
+{
+    WorldPacket &p = event.getPacket();
+	ObjectGuid player;
+	p.rpos(0);
+    if (!p.empty())
+        p >> player;
+
+	if (player.GetRawValue() == bot->GetGUID())
+        return false;
+
+	return ReadyCheck();
+}
+
+bool ReadyCheckAction::ReadyCheck()
+{
+    bool health = AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.almostFullHealth;
+    if (!health)
+    {
+        ai->TellMaster("Low health!");
+        return false;
+    }
+
+    bool mana = !AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.mediumHealth;
+    if (!mana)
+    {
+        ai->TellMaster("Low mana!");
+        return false;
+    }
+
+    Player* master = GetMaster();
+    if (master)
+    {
+        bool distance = bot->GetDistance(master) <= sPlayerbotAIConfig.sightDistance;
+        if (!distance)
+        {
+            ai->TellMaster("Too far away!");
+            return false;
+        }
+    }
+
+    if (bot->getClass() == CLASS_HUNTER)
+    {
+        if (!bot->GetUInt32Value(PLAYER_AMMO_ID))
+        {
+            ai->TellMaster("Out of ammo!");
+            return false;
+        }
+
+        if (!bot->GetPet())
+        {
+            ai->TellMaster("No pet!");
+            return false;
+        }
+
+        if (bot->GetPet()->GetHappinessState() == UNHAPPY)
+        {
+            ai->TellMaster("Pet is unhappy!");
+            return false;
+        }
+    }
+
+    WorldPacket* const packet = new WorldPacket(MSG_RAID_READY_CHECK);
+    *packet << bot->GetGUID();
+    *packet << uint8(1);
+    bot->GetSession()->QueuePacket(packet);
+
+    ai->ChangeStrategy("-ready check", BOT_STATE_NON_COMBAT);
+
+    return true;
+}
+
+bool FinishReadyCheckAction::Execute(Event event)
+{
+    return ReadyCheck();
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
new file mode 100644
index 0000000..0e26b61
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReadyCheckAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class ReadyCheckAction : public Action
+    {
+    public:
+        ReadyCheckAction(PlayerbotAI* ai, string name = "ready check") : Action(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool ReadyCheck();
+    };
+
+    class FinishReadyCheckAction : public ReadyCheckAction
+    {
+    public:
+        FinishReadyCheckAction(PlayerbotAI* ai) : ReadyCheckAction(ai, "finish ready check") {}
+
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
new file mode 100644
index 0000000..47ce1e5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReleaseSpiritAction.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+	class ReleaseSpiritAction : public Action {
+	public:
+		ReleaseSpiritAction(PlayerbotAI* ai) : Action(ai, "release") {}
+
+    public:
+        virtual bool Execute(Event event)
+        {
+            if (bot->IsAlive() || bot->GetCorpse())
+                return false;
+
+            ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+            bot->SetBotDeathTimer();
+            bot->BuildPlayerRepop();
+
+            bot->RepopAtGraveyard();
+            return true;
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
new file mode 100644
index 0000000..7b17096
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RememberTaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool RememberTaxiAction::Execute(Event event)
+{
+    
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+
+    switch (p.GetOpcode())
+    {
+    case CMSG_ACTIVATETAXI:
+        {
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            movement.taxiNodes.resize(2);
+
+            p >> movement.taxiMaster >> movement.taxiNodes[0] >> movement.taxiNodes[1];
+            return true;
+        }
+    case CMSG_ACTIVATETAXIEXPRESS:
+        {
+            ObjectGuid guid;
+            uint32 node_count;
+            p >> guid >> node_count;
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            movement.taxiNodes.clear();
+            for (uint32 i = 0; i < node_count; ++i)
+            {
+                uint32 node;
+                p >> node;
+                movement.taxiNodes.push_back(node);
+            }
+
+            return true;
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
new file mode 100644
index 0000000..16c1f07
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RememberTaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class RememberTaxiAction : public Action {
+	public:
+		RememberTaxiAction(PlayerbotAI* ai) : Action(ai, "remember taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
new file mode 100644
index 0000000..7104792
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RepairAllAction.h"
+
+
+using namespace ai;
+
+bool RepairAllAction::Execute(Event event)
+{
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_REPAIR);
+        if (!unit)
+            continue;
+
+        bot->SetFacingToObject(unit);
+        float discountMod = bot->GetReputationPriceDiscount(unit);
+        uint32 totalCost = bot->DurabilityRepairAll(true, discountMod, false);
+
+        ostringstream out;
+        out << "Repair: " << chat->formatMoney(totalCost) << " (" << unit->GetName() << ")";
+        ai->TellMasterNoFacing(out.str());
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any npc to repair at");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RepairAllAction.h b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
new file mode 100644
index 0000000..33c7abf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RepairAllAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RepairAllAction : public Action 
+    {
+    public:
+        RepairAllAction(PlayerbotAI* ai) : Action(ai, "repair") {}
+        virtual bool Execute(Event event);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
new file mode 100644
index 0000000..995f241
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ResetAiAction.h"
+
+using namespace ai;
+
+bool ResetAiAction::Execute(Event event)
+{
+    ai->ResetStrategies();
+    ai->TellMaster("AI was reset to defaults");
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ResetAiAction.h b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
new file mode 100644
index 0000000..929abcb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ResetAiAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class ResetAiAction : public Action {
+    public:
+        ResetAiAction(PlayerbotAI* ai) : Action(ai, "reset ai") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
new file mode 100644
index 0000000..88e4a23
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ReviveFromCorpseAction.h"
+#include "../../PlayerbotFactory.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool ReviveFromCorpseAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    time_t reclaimTime = corpse->GetGhostTime() + bot->GetCorpseReclaimDelay( corpse->GetType()==CORPSE_RESURRECTABLE_PVP );
+    if (reclaimTime > time(0) || corpse->GetDistance(bot) > sPlayerbotAIConfig.spellDistance)
+        return false;
+
+    bot->ResurrectPlayer(0.5f);
+    bot->SpawnCorpseBones();
+    bot->SaveToDB();
+    context->GetValue<Unit*>("current target")->Set(NULL);
+    bot->SetSelection(ObjectGuid::Empty);
+    return true;
+}
+
+bool SpiritHealerAction::Execute(Event event)
+{
+    Corpse* corpse = bot->GetCorpse();
+    if (!corpse)
+        return false;
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit && unit->IsSpiritHealer())
+        {
+            PlayerbotChatHandler ch(bot);
+            bot->ResurrectPlayer(0.5f);
+            bot->SpawnCorpseBones();
+            bot->SaveToDB();
+            context->GetValue<Unit*>("current target")->Set(NULL);
+            bot->SetSelection(ObjectGuid::Empty);
+            return true;
+        }
+    }
+
+    ai->TellMaster("Cannot find any spirit healer nearby");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
new file mode 100644
index 0000000..0e3a8cb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/ReviveFromCorpseAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+	class ReviveFromCorpseAction : public Action {
+	public:
+		ReviveFromCorpseAction(PlayerbotAI* ai) : Action(ai, "revive") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+	class SpiritHealerAction : public Action {
+	public:
+	    SpiritHealerAction(PlayerbotAI* ai) : Action(ai, "spirit healer") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.cpp b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
new file mode 100644
index 0000000..c85db71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RewardAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool RewardAction::Execute(Event event)
+{
+    string link = event.getParam();
+
+    ItemIds itemIds = chat->parseItems(link);
+    if (itemIds.empty())
+        return false;
+
+    uint32 itemId = *itemIds.begin();
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Unit* npc = ai->GetUnit(*i);
+        if (npc && Reward(itemId, npc))
+            return true;
+    }
+
+    list<ObjectGuid> gos = AI_VALUE(list<ObjectGuid>, "nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go && Reward(itemId, go))
+            return true;
+    }
+
+    ai->TellMaster("Cannot talk to quest giver");
+    return false;
+}
+
+bool RewardAction::Reward(uint32 itemId, Object* questGiver)
+{
+    QuestMenu& questMenu = bot->PlayerTalkClass->GetQuestMenu();
+    for (uint32 iI = 0; iI < questMenu.GetMenuItemCount(); ++iI)
+    {
+        QuestMenuItem const& qItem = questMenu.GetItem(iI);
+
+        uint32 questID = qItem.QuestId;
+        Quest const* pQuest = sObjectMgr->GetQuestTemplate(questID);
+        QuestStatus status = bot->GetQuestStatus(questID);
+
+        // if quest is complete, turn it in
+        if (status == QUEST_STATUS_COMPLETE &&
+            ! bot->GetQuestRewardStatus(questID) &&
+            pQuest->GetRewChoiceItemsCount() > 1 &&
+            bot->CanRewardQuest(pQuest, false))
+        {
+            for (uint8 rewardIdx=0; rewardIdx < pQuest->GetRewChoiceItemsCount(); ++rewardIdx)
+            {
+                ItemTemplate const * const pRewardItem = sObjectMgr->GetItemTemplate(pQuest->RewardChoiceItemId[rewardIdx]);
+                if (itemId == pRewardItem->ItemId)
+                {
+                    bot->RewardQuest(pQuest, rewardIdx, questGiver, false);
+
+                    string questTitle  = pQuest->GetTitle();
+                    string itemName = pRewardItem->Name1;
+
+                    ostringstream out; out << chat->formatItem(pRewardItem) << " rewarded";
+                    ai->TellMaster(out);
+                    return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/RewardAction.h b/src/plugins/playerbot/strategy/actions/RewardAction.h
new file mode 100644
index 0000000..f4eda13
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RewardAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class RewardAction : public InventoryAction {
+    public:
+        RewardAction(PlayerbotAI* ai) : InventoryAction(ai, "reward") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool Reward(uint32 itemId, Object* pNpc);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/RtiAction.h b/src/plugins/playerbot/strategy/actions/RtiAction.h
new file mode 100644
index 0000000..f0cca94
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/RtiAction.h
@@ -0,0 +1,44 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class RtiAction : public Action
+    {
+    public:
+        RtiAction(PlayerbotAI* ai) : Action(ai, "rti")
+        {}
+
+        virtual bool Execute(Event event)
+        {
+            string text = event.getParam();
+            if (text.empty() || text == "?")
+            {
+                ostringstream out; out << "RTI: ";
+                AppendRti(out);
+                ai->TellMaster(out);
+                return true;
+            }
+
+            context->GetValue<string>("rti")->Set(text);
+            ostringstream out; out << "RTI set to: ";
+            AppendRti(out);
+            ai->TellMaster(out);
+            return true;
+        }
+
+    private:
+        void AppendRti(ostringstream & out)
+        {
+            out << AI_VALUE(string, "rti");
+
+            Unit* target = AI_VALUE(Unit*, "rti target");
+            if(target)
+                out << " (" << target->GetName() << ")";
+
+        }
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
new file mode 100644
index 0000000..c5d56a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SaveManaAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+bool SaveManaAction::Execute(Event event)
+{
+    string text = event.getParam();
+    double value = AI_VALUE(double, "mana save level");
+
+    if (text == "?")
+    {
+        ostringstream out; out << "Mana save level: " << format(value);
+        ai->TellMaster(out);
+        return true;
+    }
+
+    if (text == "*")
+    {
+        switch (bot->getClass())
+        {
+        case CLASS_HUNTER:
+        case CLASS_SHAMAN:
+        case CLASS_DRUID:
+            value = 5.0;
+            break;
+        case CLASS_MAGE:
+        case CLASS_PRIEST:
+        case CLASS_WARLOCK:
+            value = 2.0;
+            break;
+        default:
+            value = 3.0;
+        }
+    }
+    else if (text.empty())
+    {
+        value = 1.0;
+    }
+    else
+    {
+        value = atof(text.c_str());
+    }
+
+    value = min(10.0, value);
+    value = max(1.0, value);
+    value = floor(value * 100 + 0.5) / 100.0;
+
+    ai->GetAiObjectContext()->GetValue<double>("mana save level")->Set(value);
+
+    ostringstream out; out << "Mana save level set: " << format(value);
+    ai->TellMaster(out);
+
+    return true;
+}
+
+string SaveManaAction::format(double value)
+{
+    ostringstream out;
+    if (value <= 1.0)
+        out << "|cFF808080";
+    else if (value <= 5.0)
+        out << "|cFF00FF00";
+    else if (value <= 7.0)
+        out << "|cFFFFFF00";
+    else
+        out << "|cFFFF0000";
+    out << value << "|cffffffff";
+    return out.str();
+}
diff --git a/src/plugins/playerbot/strategy/actions/SaveManaAction.h b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
new file mode 100644
index 0000000..3d9b3e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SaveManaAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SaveManaAction : public Action
+    {
+    public:
+        SaveManaAction(PlayerbotAI* ai) : Action(ai, "save mana") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        string format(double value);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
new file mode 100644
index 0000000..891b03c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "SecurityCheckAction.h"
+#include "../../../Groups/Group.h"
+
+using namespace ai;
+
+
+bool SecurityCheckAction::isUseful()
+{
+    return sRandomPlayerbotMgr.IsRandomBot(bot) && ai->GetMaster() && ai->GetMaster()->GetSession()->GetSecurity() < SEC_GAMEMASTER;
+}
+
+bool SecurityCheckAction::Execute(Event event)
+{
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        LootMethod method = group->GetLootMethod();
+        ItemQualities threshold = group->GetLootThreshold();
+        if (method == MASTER_LOOT || method == FREE_FOR_ALL || threshold > ITEM_QUALITY_UNCOMMON)
+        {
+            ai->TellMaster("I won't do anything until you change loot type to group loot with green threshold");
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_NON_COMBAT);
+            ai->ChangeStrategy("+passive,+stay", BOT_STATE_COMBAT);
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
new file mode 100644
index 0000000..4ae38f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SecurityCheckAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class SecurityCheckAction : public Action
+    {
+    public:
+        SecurityCheckAction(PlayerbotAI* ai) : Action(ai, "security check") {}
+        virtual bool isUseful();
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.cpp b/src/plugins/playerbot/strategy/actions/SellAction.cpp
new file mode 100644
index 0000000..1af725c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.cpp
@@ -0,0 +1,95 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SellAction.h"
+#include "../ItemVisitors.h"
+
+using namespace ai;
+
+class SellItemsVisitor : public IterateItemsVisitor
+{
+public:
+    SellItemsVisitor(SellAction* action) : IterateItemsVisitor()
+    {
+        this->action = action;
+    }
+
+    virtual bool Visit(Item* item)
+    {
+        action->Sell(item);
+        return true;
+    }
+
+private:
+    SellAction* action;
+};
+
+class SellGrayItemsVisitor : public SellItemsVisitor
+{
+public:
+    SellGrayItemsVisitor(SellAction* action) : SellItemsVisitor(action) {}
+
+    virtual bool Visit(Item* item)
+    {
+        if (item->GetTemplate()->Quality != ITEM_QUALITY_POOR)
+            return true;
+
+        return SellItemsVisitor::Visit(item);
+    }
+};
+
+
+bool SellAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    string text = event.getParam();
+
+    if (text == "gray" || text == "*")
+    {
+        SellGrayItemsVisitor visitor(this);
+        IterateItems(&visitor);
+        return true;
+    }
+
+    ItemIds ids = chat->parseItems(text);
+
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        Sell(&visitor);
+    }
+
+    return true;
+}
+
+
+void SellAction::Sell(FindItemVisitor* visitor)
+{
+    IterateItems(visitor);
+    list<Item*> items = visitor->GetResult();
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+        Sell(*i);
+}
+
+void SellAction::Sell(Item* item)
+{
+    Player* master = GetMaster();
+    Unit* vendor = master->GetSelectedUnit();
+    if (!vendor)
+    {
+        ai->TellMaster("Select a vendor first");
+        return;
+    }
+
+    ObjectGuid itemguid = item->GetGUID();
+    uint32 count = item->GetCount();
+
+    WorldPacket p;
+    p << vendor->GetGUID() << itemguid << count;
+    bot->GetSession()->HandleSellItemOpcode(p);
+
+    ostringstream out; out << chat->formatItem(item->GetTemplate()) << " sold";
+    ai->TellMaster(out);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SellAction.h b/src/plugins/playerbot/strategy/actions/SellAction.h
new file mode 100644
index 0000000..c1f0915
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SellAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SellAction : public InventoryAction {
+    public:
+        SellAction(PlayerbotAI* ai) : InventoryAction(ai, "sell") {}
+        virtual bool Execute(Event event);
+
+        void Sell(FindItemVisitor* visitor);
+        void Sell(Item* item);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
new file mode 100644
index 0000000..1b2d22f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SetHomeAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+
+using namespace ai;
+
+bool SetHomeAction::Execute(Event event)
+{
+    Player* master = ai->GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (unit && unit->IsInnkeeper())
+    {
+        float angle = GetFollowAngle();
+        float x = unit->GetPositionX() + sPlayerbotAIConfig.followDistance * cos(angle);
+        float y = unit->GetPositionY() + sPlayerbotAIConfig.followDistance * sin(angle);
+        float z = unit->GetPositionZ();
+        WorldLocation loc(unit->GetMapId(), x, y, z);
+        bot->SetHomebind(loc, unit->GetAreaId());
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    list<ObjectGuid> npcs = AI_VALUE(list<ObjectGuid>, "nearest npcs");
+    for (list<ObjectGuid>::iterator i = npcs.begin(); i != npcs.end(); i++)
+    {
+        Creature *unit = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_INNKEEPER);
+        if (!unit)
+            continue;
+
+        bot->GetSession()->SendBindPoint(unit);
+        ai->TellMaster("This inn is my new home");
+        return true;
+    }
+
+    ai->TellMaster("Can't find any innkeeper around");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/SetHomeAction.h b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
new file mode 100644
index 0000000..b98a5b5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SetHomeAction.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SetHomeAction : public MovementAction {
+    public:
+        SetHomeAction(PlayerbotAI* ai) : MovementAction(ai, "home") {}
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.cpp b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
new file mode 100644
index 0000000..50f6669
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.cpp
@@ -0,0 +1,145 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsAction.h"
+
+
+using namespace ai;
+
+bool StatsAction::Execute(Event event)
+{
+    ostringstream out;
+
+    ListGold(out);
+
+    out << ", ";
+    ListBagSlots(out);
+
+    out << ", ";
+    ListRepairCost(out);
+
+    if (bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP))
+    {
+        out << ", ";
+        ListXP(out);
+    }
+
+    ai->TellMaster(out);
+    return true;
+}
+
+void StatsAction::ListGold(ostringstream &out)
+{
+    out << chat->formatMoney(bot->GetMoney());
+}
+
+void StatsAction::ListBagSlots(ostringstream &out)
+{
+    uint32 totalused = 0, total = 16;
+    // list out items in main backpack
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        const Item* const pItem = bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+        if (pItem)
+            totalused++;
+    }
+    uint32 totalfree = 16 - totalused;
+    // list out items in other removable backpacks
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+	string color = "ff00ff00";
+	if (totalfree < total / 2)
+		color = "ffffff00";
+	if (totalfree < total / 4)
+		color = "ffff0000";
+    out << "|h|c" << color << (total - totalfree) << "/" << total << "|h|cffffffff Bag";
+}
+
+void StatsAction::ListXP( ostringstream &out )
+{
+    uint32 curXP = bot->GetUInt32Value(PLAYER_XP);
+    uint32 nextLevelXP = bot->GetUInt32Value(PLAYER_NEXT_LEVEL_XP);
+    uint32 xpPercent = 0;
+    if (nextLevelXP)
+        xpPercent = 100 * curXP / nextLevelXP;
+
+    out << "|r|cff00ff00" << xpPercent << "|r|cffffd333%" << "|h|cffffffff XP";
+}
+
+void StatsAction::ListRepairCost(ostringstream &out)
+{
+    out << chat->formatMoney(EstRepairAll()) << " Repair";
+}
+
+uint32 StatsAction::EstRepairAll()
+{
+    uint32 TotalCost = 0;
+    // equipped, backpack, bags itself
+    for(int i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        TotalCost += EstRepair(( (INVENTORY_SLOT_BAG_0 << 8) | i ));
+
+    // bank, buyback and keys not repaired
+
+    // items in inventory bags
+    for(int j = INVENTORY_SLOT_BAG_START; j < INVENTORY_SLOT_BAG_END; ++j)
+        for(int i = 0; i < MAX_BAG_SIZE; ++i)
+            TotalCost += EstRepair(( (j << 8) | i ));
+    return TotalCost;
+}
+
+uint32 StatsAction::EstRepair(uint16 pos)
+{
+    Item* item = bot->GetItemByPos(pos);
+
+    uint32 TotalCost = 0;
+    if(!item)
+        return TotalCost;
+
+    uint32 maxDurability = item->GetUInt32Value(ITEM_FIELD_MAXDURABILITY);
+    if(!maxDurability)
+        return TotalCost;
+
+    uint32 curDurability = item->GetUInt32Value(ITEM_FIELD_DURABILITY);
+
+    uint32 LostDurability = maxDurability - curDurability;
+    if(LostDurability>0)
+    {
+        ItemTemplate const *ditemProto = item->GetTemplate();
+
+        DurabilityCostsEntry const *dcost = sDurabilityCostsStore.LookupEntry(ditemProto->ItemLevel);
+        if(!dcost)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong item lvl %u", ditemProto->ItemLevel);
+            return TotalCost;
+        }
+
+        uint32 dQualitymodEntryId = (ditemProto->Quality+1)*2;
+        DurabilityQualityEntry const *dQualitymodEntry = sDurabilityQualityStore.LookupEntry(dQualitymodEntryId);
+        if(!dQualitymodEntry)
+        {
+            sLog->outMessage("playerbot", LOG_LEVEL_ERROR, "RepairDurability: Wrong dQualityModEntry %u", dQualitymodEntryId);
+            return TotalCost;
+        }
+
+        uint32 dmultiplier = dcost->multiplier[ItemSubClassToDurabilityMultiplierId(ditemProto->Class,ditemProto->SubClass)];
+        uint32 costs = uint32(LostDurability*dmultiplier*double(dQualitymodEntry->quality_mod));
+
+        if (costs==0)                                   //fix for ITEM_QUALITY_ARTIFACT
+            costs = 1;
+
+        TotalCost = costs;
+    }
+    return TotalCost;
+}
diff --git a/src/plugins/playerbot/strategy/actions/StatsAction.h b/src/plugins/playerbot/strategy/actions/StatsAction.h
new file mode 100644
index 0000000..e30558c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StatsAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class StatsAction : public Action {
+    public:
+        StatsAction(PlayerbotAI* ai) : Action(ai, "stats") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListBagSlots(ostringstream &out);
+        void ListXP(ostringstream &out);
+        void ListRepairCost(ostringstream &out);
+        void ListGold(ostringstream &out);
+        uint32 EstRepairAll();
+        uint32 EstRepair(uint16 pos);
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.cpp b/src/plugins/playerbot/strategy/actions/StayActions.cpp
new file mode 100644
index 0000000..32ebd0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayActions.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+void StayActionBase::Stay()
+{
+    AI_VALUE(LastMovement&, "last movement").Set(NULL);
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    if (mm.GetCurrentMovementGeneratorType() == FLIGHT_MOTION_TYPE || bot->IsFlying())
+        return;
+
+    mm.Clear();
+    mm.MoveIdle();
+    bot->ClearUnitState( UNIT_STATE_ALL_STATE_SUPPORTED );
+
+    if (!bot->IsStandState())
+        bot->SetStandState(UNIT_STAND_STATE_STAND);
+}
+
+bool StayAction::Execute(Event event)
+{
+    Stay();
+
+    return true;
+}
+
+bool StayAction::isUseful()
+{
+    return !AI_VALUE2(bool, "moving", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/actions/StayActions.h b/src/plugins/playerbot/strategy/actions/StayActions.h
new file mode 100644
index 0000000..ccbe2e3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/StayActions.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class StayActionBase : public MovementAction {
+    public:
+        StayActionBase(PlayerbotAI* ai, string name) : MovementAction(ai, name) {}
+
+    protected:
+        void Stay();
+    };
+
+    class StayAction : public StayActionBase {
+    public:
+        StayAction(PlayerbotAI* ai) : StayActionBase(ai, "stay") {}
+        virtual bool Execute(Event event);
+        virtual bool isUseful();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
new file mode 100644
index 0000000..3f46f77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.cpp
@@ -0,0 +1,255 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SuggestWhatToDoAction.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+SuggestWhatToDoAction::SuggestWhatToDoAction(PlayerbotAI* ai) : InventoryAction(ai, "suggest what to do"), suggested(false)
+{
+    suggestions.push_back(&SuggestWhatToDoAction::instance);
+    suggestions.push_back(&SuggestWhatToDoAction::specificQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::newQuest);
+    suggestions.push_back(&SuggestWhatToDoAction::grindMaterials);
+    suggestions.push_back(&SuggestWhatToDoAction::trade);
+    suggestions.push_back(&SuggestWhatToDoAction::grindReputation);
+    suggestions.push_back(&SuggestWhatToDoAction::nothing);
+    suggestions.push_back(&SuggestWhatToDoAction::relax);
+    suggestions.push_back(&SuggestWhatToDoAction::achievement);
+}
+
+bool SuggestWhatToDoAction::Execute(Event event)
+{
+    if (suggested)
+    {
+        trade();
+        return true;
+    }
+
+    if (bot->GetInstanceId() || suggested)
+        return false;
+
+    int index = rand() % suggestions.size();
+    (this->*suggestions[index])();
+
+    return suggested = true;
+}
+
+void SuggestWhatToDoAction::instance()
+{
+    uint32 level = bot->getLevel();
+    if (level > 15)
+    {
+        switch (urand(0, 5))
+        {
+        case 0:
+            spam("Need a tank for an instance run");
+            break;
+        case 1:
+            spam("Need a healer for an instance run");
+            break;
+        case 2:
+            spam("I would like to do an instance run. Would you like to join me?");
+            break;
+        case 3:
+            spam("Need better equipment. Why not do an instance run?");
+            break;
+        case 4:
+            spam("Have dungeon quests? Can join your group!");
+            break;
+        case 5:
+            spam("Have group quests? Invite me!");
+            break;
+        default:
+            spam("Hey, why not join Dungeon Finder?");
+        }
+    }
+}
+
+vector<uint32> SuggestWhatToDoAction::GetIncompletedQuests()
+{
+    vector<uint32> result;
+
+    for (uint16 slot = 0; slot < MAX_QUEST_LOG_SIZE; ++slot)
+    {
+        uint32 questId = bot->GetQuestSlotQuestId(slot);
+        if (!questId)
+            continue;
+
+        QuestStatus status = bot->GetQuestStatus(questId);
+        if (status == QUEST_STATUS_INCOMPLETE || status == QUEST_STATUS_NONE)
+            result.push_back(questId);
+    }
+
+    return result;
+}
+
+void SuggestWhatToDoAction::specificQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.empty())
+        return;
+
+    int index = rand() % quests.size();
+
+    Quest const* quest = sObjectMgr->GetQuestTemplate(quests[index]);
+    ostringstream out; out << "We could do some quest, for instance " << chat->formatQuest(quest);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::newQuest()
+{
+    vector<uint32> quests = GetIncompletedQuests();
+    if (quests.size() < MAX_QUEST_LOG_SIZE - 5)
+        spam("I would like to pick up and do a new quest. Just invite me!");
+}
+
+void SuggestWhatToDoAction::grindMaterials()
+{
+    if (bot->getLevel() <= 5)
+        return;
+
+    switch (urand(0, 5))
+    {
+    case 0:
+        spam("Need help for tradeskill?");
+        break;
+    case 1:
+        spam("Can we have some trade material grinding?");
+        break;
+    case 2:
+        spam("I have some trade materials for sell");
+        break;
+    default:
+        spam("I am going to grind some trade materials. Would you like to join me?");
+    }
+}
+
+void SuggestWhatToDoAction::grindReputation()
+{
+    if (bot->getLevel() > 15)
+        ai->TellMasterNoFacing("I think we should do something to improve our reputation", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::nothing()
+{
+    ai->TellMasterNoFacing("I don't want to do anything", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::relax()
+{
+    ai->TellMasterNoFacing("It is so boring... We could relax a bit", PLAYERBOT_SECURITY_ALLOW_ALL);
+}
+
+void SuggestWhatToDoAction::achievement()
+{
+    if (bot->getLevel() > 15)
+        spam("I would like to get some achievement. Would you like to join me?");
+}
+
+class FindTradeItemsVisitor : public IterateItemsVisitor
+{
+public:
+    FindTradeItemsVisitor(uint32 quality) : quality(quality), IterateItemsVisitor() {}
+
+    virtual bool Visit(Item* item)
+    {
+        ItemTemplate const* proto = item->GetTemplate();
+        if (proto->Quality != quality)
+            return true;
+
+        if (proto->Class == ITEM_CLASS_TRADE_GOODS && proto->Bonding == NO_BIND)
+        {
+            if(proto->Quality == ITEM_QUALITY_NORMAL && item->GetCount() > 1 && item->GetCount() == item->GetMaxStackCount())
+                stacks.push_back(proto->ItemId);
+
+            items.push_back(proto->ItemId);
+            count[proto->ItemId] += item->GetCount();
+        }
+
+        return true;
+    }
+
+    map<uint32, int > count;
+    vector<uint32> stacks;
+    vector<uint32> items;
+
+private:
+    uint32 quality;
+};
+
+
+void SuggestWhatToDoAction::trade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return;
+
+    uint32 quality = urand(0, 100);
+    if (quality > 90)
+        quality = ITEM_QUALITY_EPIC;
+    else if (quality >75)
+        quality = ITEM_QUALITY_RARE;
+    else if (quality > 50)
+        quality = ITEM_QUALITY_UNCOMMON;
+    else
+        quality = ITEM_QUALITY_NORMAL;
+
+    uint32 item = 0, count = 0;
+    while (quality-- > ITEM_QUALITY_POOR)
+    {
+        FindTradeItemsVisitor visitor(quality);
+        IterateItems(&visitor);
+        if (!visitor.stacks.empty())
+        {
+            int index = urand(0, visitor.stacks.size() - 1);
+            item = visitor.stacks[index];
+        }
+
+        if (!item)
+        {
+            if (!visitor.items.empty())
+            {
+                int index = urand(0, visitor.items.size() - 1);
+                item = visitor.items[index];
+            }
+        }
+
+        if (item)
+        {
+            count = visitor.count[item];
+            break;
+        }
+    }
+
+    if (!item || !count)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item);
+    if (!proto)
+        return;
+
+    uint32 price = auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * count;
+    if (!price)
+        return;
+
+    ostringstream out; out << "Selling " << chat->formatItem(proto, count) << " for " << chat->formatMoney(price);
+    spam(out.str());
+}
+
+void SuggestWhatToDoAction::spam(string msg)
+{
+    Player* player = sRandomPlayerbotMgr.GetRandomPlayer();
+    if (!player || !player->IsInWorld())
+        return;
+
+    if (!ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_TALK, true, player))
+        return;
+
+    if (sPlayerbotAIConfig.whisperDistance && !bot->GetGroup() && sRandomPlayerbotMgr.IsRandomBot(bot) &&
+            player->GetSession()->GetSecurity() < SEC_GAMEMASTER &&
+            (bot->GetMapId() != player->GetMapId() || bot->GetDistance(player) > sPlayerbotAIConfig.whisperDistance))
+        return;
+
+    bot->Whisper(msg, LANG_UNIVERSAL, player);
+}
diff --git a/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
new file mode 100644
index 0000000..750bb08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/SuggestWhatToDoAction.h
@@ -0,0 +1,34 @@
+#pragma once
+
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class SuggestWhatToDoAction : public InventoryAction
+    {
+    public:
+        SuggestWhatToDoAction(PlayerbotAI* ai);
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (SuggestWhatToDoAction::*Suggestion) ();
+        vector<Suggestion> suggestions;
+
+    private:
+        void instance();
+        void specificQuest();
+        void newQuest();
+        void grindMaterials();
+        void grindReputation();
+        void nothing();
+        void relax();
+        void achievement();
+        void trade();
+        void spam(string msg);
+
+        vector<uint32> GetIncompletedQuests();
+
+    private:
+        bool suggested;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
new file mode 100644
index 0000000..747abb2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TalkToQuestGiverAction.h"
+
+
+using namespace ai;
+
+void TalkToQuestGiverAction::ProcessQuest(Quest const* quest, WorldObject* questGiver)
+{
+    std::ostringstream out; out << "Quest ";
+
+    QuestStatus status = bot->GetQuestStatus(quest->GetQuestId());
+    switch (status)
+    {
+    case QUEST_STATUS_COMPLETE:
+        TurnInQuest(quest, questGiver, out);
+        break;
+    case QUEST_STATUS_INCOMPLETE:
+        out << "|cffff0000Incompleted|r";
+        break;
+    case QUEST_STATUS_NONE:
+        out << "|cff00ff00Available|r";
+        break;
+    case QUEST_STATUS_FAILED:
+        out << "|cffff0000Failed|r";
+        break;
+    }
+
+    out << ": " << chat->formatQuest(quest);
+    ai->TellMaster(out);
+}
+
+void TalkToQuestGiverAction::TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    uint32 questID = quest->GetQuestId();
+
+    if (bot->GetQuestRewardStatus(questID))
+        return;
+
+    if (quest->GetRewChoiceItemsCount() == 0)
+        RewardNoItem(quest, questGiver, out);
+    else if (quest->GetRewChoiceItemsCount() == 1)
+        RewardSingleItem(quest, questGiver, out);
+    else {
+        AskToSelectReward(quest, out);
+    }
+}
+
+void TalkToQuestGiverAction::RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    if (bot->CanRewardQuest(quest, false))
+    {
+        bot->RewardQuest(quest, 0, questGiver, false);
+        out << "Completed";
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in|r";
+    }
+}
+
+void TalkToQuestGiverAction::RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out)
+{
+    int index = 0;
+    ItemTemplate const *item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[index]);
+    if (bot->CanRewardQuest(quest, index, false))
+    {
+        bot->RewardQuest(quest, index, questGiver, true);
+
+        out << "Rewarded " << chat->formatItem(item);
+    }
+    else
+    {
+        out << "|cffff0000Unable to turn in:|r, reward: " << chat->formatItem(item);
+    }
+}
+
+void TalkToQuestGiverAction::AskToSelectReward(Quest const* quest, ostringstream& out)
+{
+    ostringstream msg;
+    msg << "Choose reward: ";
+    for (uint8 i=0; i < quest->GetRewChoiceItemsCount(); ++i)
+    {
+        ItemTemplate const* item = sObjectMgr->GetItemTemplate(quest->RewardChoiceItemId[i]);
+        msg << chat->formatItem(item);
+    }
+    ai->TellMaster(msg);
+
+    out << "Reward pending";
+}
diff --git a/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
new file mode 100644
index 0000000..374dc69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TalkToQuestGiverAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+#include "QuestAction.h"
+
+namespace ai
+{
+    class TalkToQuestGiverAction : public QuestAction {
+    public:
+        TalkToQuestGiverAction(PlayerbotAI* ai) : QuestAction(ai, "talk to quest giver") {}
+
+    protected:
+        virtual void ProcessQuest(Quest const* quest, WorldObject* questGiver);
+
+    private:
+        void TurnInQuest(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardNoItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void RewardSingleItem(Quest const* quest, WorldObject* questGiver, ostringstream& out);
+        void AskToSelectReward(Quest const* quest, ostringstream& out);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.cpp b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
new file mode 100644
index 0000000..8037679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TaxiAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TaxiAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+
+    WorldPacket& p = event.getPacket();
+	if (!p.empty() && p.GetOpcode() == CMSG_MOVE_SPLINE_DONE)
+    {
+        WorldPacket p1(p);
+        p1.rpos(0);
+        bot->GetSession()->HandleMoveSplineDoneOpcode(p1);
+        movement.taxiNodes.clear();
+        movement.Set(NULL);
+        return true;
+    }
+
+    list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Creature *npc = bot->GetNPCIfCanInteractWith(*i, UNIT_NPC_FLAG_FLIGHTMASTER);
+        if (!npc)
+            continue;
+
+        if (movement.taxiNodes.empty())
+        {
+            ostringstream out;
+            out << "I will order the taxi from " << npc->GetName() << ". Please start flying, then instruct me again";
+            ai->TellMaster(out);
+            return true;
+        }
+
+        if (!bot->ActivateTaxiPathTo(movement.taxiNodes, npc))
+        {
+            ai->TellMaster("I can't fly with you");
+            return false;
+        }
+
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any flightmaster to talk");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TaxiAction.h b/src/plugins/playerbot/strategy/actions/TaxiAction.h
new file mode 100644
index 0000000..84bbe4d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TaxiAction.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+	class TaxiAction : public Action {
+	public:
+		TaxiAction(PlayerbotAI* ai) : Action(ai, "taxi") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.cpp b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
new file mode 100644
index 0000000..ef82a7a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TeleportAction.h"
+#include "../values/LastMovementValue.h"
+
+using namespace ai;
+
+bool TeleportAction::Execute(Event event)
+{
+    list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (!go)
+            continue;
+
+        GameObjectTemplate const *goInfo = go->GetGOInfo();
+        if (goInfo->type != GAMEOBJECT_TYPE_SPELLCASTER)
+            continue;
+
+        uint32 spellId = goInfo->spellcaster.spellId;
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Effects[0].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[1].Effect != SPELL_EFFECT_TELEPORT_UNITS && pSpellInfo->Effects[2].Effect != SPELL_EFFECT_TELEPORT_UNITS)
+            continue;
+
+        ostringstream out; out << "Teleporting using " << goInfo->name;
+        ai->TellMasterNoFacing(out.str());
+
+        ai->ChangeStrategy("-follow,+stay", BOT_STATE_NON_COMBAT);
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        SpellCastTargets targets;
+        targets.SetUnitTarget(bot);
+        spell->prepare(&targets);
+        spell->cast(true);
+        return true;
+    }
+
+
+    LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+    if (movement.lastAreaTrigger)
+    {
+        WorldPacket p(CMSG_AREATRIGGER);
+        p << movement.lastAreaTrigger;
+        p.rpos(0);
+
+        bot->GetSession()->HandleAreaTriggerOpcode(p);
+        movement.lastAreaTrigger = 0;
+        return true;
+    }
+
+    ai->TellMaster("Cannot find any portal to teleport");
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TeleportAction.h b/src/plugins/playerbot/strategy/actions/TeleportAction.h
new file mode 100644
index 0000000..96b5973
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TeleportAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+	class TeleportAction : public Action {
+	public:
+		TeleportAction(PlayerbotAI* ai) : Action(ai, "teleport") {}
+
+    public:
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
new file mode 100644
index 0000000..2469816
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellCastFailedAction.h"
+
+
+using namespace ai;
+
+bool TellCastFailedAction::Execute(Event event)
+{
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint8 castCount, result;
+    uint32 spellId;
+    p >> castCount >> spellId >> result;
+    ai->SpellInterrupted(spellId);
+
+    if (result == SPELL_CAST_OK)
+        return false;
+
+    const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+    ostringstream out; out << chat->formatSpell(pSpellInfo) << ": ";
+    switch (result)
+    {
+    case SPELL_FAILED_NOT_READY:
+        out << "not ready";
+        break;
+    case SPELL_FAILED_REQUIRES_SPELL_FOCUS:
+        out << "requires spell focus";
+        break;
+    case SPELL_FAILED_REQUIRES_AREA:
+        out << "cannot cast here";
+        break;
+    case SPELL_FAILED_TOTEMS:
+    case SPELL_FAILED_TOTEM_CATEGORY:
+        out << "requires totem";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS:
+        out << "requires item";
+        break;
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND:
+    case SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND:
+        out << "requires weapon";
+        break;
+    case SPELL_FAILED_PREVENTED_BY_MECHANIC:
+        out << "interrupted";
+        break;
+    default:
+        out << "cannot cast";
+    }
+    Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+    int32 castTime = spell->GetCastTime();
+    delete spell;
+
+    if (castTime >= 2000)
+        ai->TellMasterNoFacing(out.str());
+
+    return true;
+}
+
+
+bool TellSpellAction::Execute(Event event)
+{
+    string spell = event.getParam();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    if (!spellId)
+        return false;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellId );
+    if (!spellInfo)
+        return false;
+
+    ostringstream out; out << chat->formatSpell(spellInfo);
+    ai->TellMaster(out);
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
new file mode 100644
index 0000000..e454596
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellCastFailedAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellSpellAction : public Action
+    {
+    public:
+        TellSpellAction(PlayerbotAI* ai) : Action(ai, "spell") {}
+
+        virtual bool Execute(Event event);
+    };
+
+    class TellCastFailedAction : public Action 
+    {
+    public:
+        TellCastFailedAction(PlayerbotAI* ai) : Action(ai, "tell cast failed") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
new file mode 100644
index 0000000..fdbe0d3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellItemCountAction.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TellItemCountAction::Execute(Event event)
+{
+    string text = event.getParam();
+    list<Item*> found = parseItems(text);
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TellItem((*i)->GetTemplate(), (*i)->GetCount());
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellItemCountAction.h b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
new file mode 100644
index 0000000..093b0e0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellItemCountAction.h
@@ -0,0 +1,14 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TellItemCountAction : public InventoryAction {
+    public:
+        TellItemCountAction(PlayerbotAI* ai) : InventoryAction(ai, "c") {}
+        virtual bool Execute(Event event);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.cpp b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
new file mode 100644
index 0000000..02227f9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.cpp
@@ -0,0 +1,61 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellLosAction.h"
+
+
+using namespace ai;
+
+bool TellLosAction::Execute(Event event)
+{
+    string param = event.getParam();
+
+    if (param.empty() || param == "targets")
+    {
+        list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+        ListUnits("--- Targets ---", targets);
+    }
+
+    if (param.empty() || param == "npcs")
+    {
+        list<ObjectGuid> npcs = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+        ListUnits("--- NPCs ---", npcs);
+    }
+
+    if (param.empty() || param == "corpses")
+    {
+        list<ObjectGuid> corpses = *context->GetValue<list<ObjectGuid> >("nearest corpses");
+        ListUnits("--- Corpses ---", corpses);
+    }
+
+    if (param.empty() || param == "gos" || param == "game objects")
+    {
+        list<ObjectGuid> gos = *context->GetValue<list<ObjectGuid> >("nearest game objects");
+        ListGameObjects("--- Game objects ---", gos);
+    }
+
+    return true;
+}
+
+void TellLosAction::ListUnits(string title, list<ObjectGuid> units)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (unit)
+            ai->TellMaster(unit->GetName());
+    }
+
+}
+void TellLosAction::ListGameObjects(string title, list<ObjectGuid> gos)
+{
+    ai->TellMaster(title);
+
+    for (list<ObjectGuid>::iterator i = gos.begin(); i != gos.end(); i++)
+    {
+        GameObject* go = ai->GetGameObject(*i);
+        if (go)
+            ai->TellMaster(chat->formatGameobject(go));
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellLosAction.h b/src/plugins/playerbot/strategy/actions/TellLosAction.h
new file mode 100644
index 0000000..15d83fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellLosAction.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellLosAction : public Action {
+    public:
+        TellLosAction(PlayerbotAI* ai) : Action(ai, "los") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void ListUnits(string title, list<ObjectGuid> units);
+        void ListGameObjects(string title, list<ObjectGuid> gos);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellMasterAction.h b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
new file mode 100644
index 0000000..4174708
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellMasterAction.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellMasterAction : public Action {
+    public:
+        TellMasterAction(PlayerbotAI* ai, string text) : Action(ai, "tell master"), text(text) {}
+
+        virtual bool Execute(Event event)
+        {
+            ai->TellMaster(text);
+            return true;
+        }
+
+    private:
+        string text;
+    };
+
+    class OutOfReactRangeAction : public MovementAction {
+    public:
+        OutOfReactRangeAction(PlayerbotAI* ai) : MovementAction(ai, "tell out of react range") {}
+
+        virtual bool Execute(Event event)
+        {
+            bool canFollow = Follow(AI_VALUE(Unit*, "master target"));
+            if (!canFollow)
+            {
+                ai->SetNextCheckDelay(5000);
+                return false;
+            }
+
+            ai->TellMaster("Wait for me!");
+            return true;
+        }
+   };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
new file mode 100644
index 0000000..f1bd104
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.cpp
@@ -0,0 +1,68 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellReputationAction.h"
+#include "../../../Reputation/ReputationMgr.h"
+
+
+using namespace ai;
+
+bool TellReputationAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* unit = master->GetSelectedUnit();
+    if (!unit)
+        return false;
+
+    const FactionTemplateEntry *factionTemplate = unit->GetFactionTemplateEntry();
+    uint32 faction = factionTemplate->faction;
+    const FactionEntry* entry = sFactionStore.LookupEntry(faction);
+    int32 reputation = bot->GetReputationMgr().GetReputation(faction);
+
+    ostringstream out;
+    out << entry->name[0] << ": ";
+    out << "|cff";
+    ReputationRank rank = bot->GetReputationMgr().GetRank(entry);
+    switch (rank) {
+        case REP_HATED:
+            out << "cc2222hated";
+            break;
+        case REP_HOSTILE:
+            out << "ff0000hostile";
+            break;
+        case REP_UNFRIENDLY:
+            out << "ee6622unfriendly";
+            break;
+        case REP_NEUTRAL:
+            out << "ffff00neutral";
+            break;
+        case REP_FRIENDLY:
+            out << "00ff00friendly";
+            break;
+        case REP_HONORED:
+            out << "00ff88honored";
+            break;
+        case REP_REVERED:
+            out << "00ffccrevered";
+            break;
+        case REP_EXALTED:
+            out << "00ffffexalted";
+            break;
+        default:
+            out << "808080unknown";
+            break;
+    }
+
+    out << "|cffffffff";
+
+    int32 base = ReputationMgr::Reputation_Cap + 1;
+    for (int i = MAX_REPUTATION_RANK - 1; i >= rank; --i)
+        base -= ReputationMgr::PointsInRank[i];
+
+    out << " (" << (reputation - base) << "/" << ReputationMgr::PointsInRank[rank] << ")";
+    ai->TellMaster(out);
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellReputationAction.h b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
new file mode 100644
index 0000000..449e67f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellReputationAction.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellReputationAction : public Action {
+    public:
+        TellReputationAction(PlayerbotAI* ai) : Action(ai, "reputation") {}
+        virtual bool Execute(Event event);
+
+    private:
+
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
new file mode 100644
index 0000000..a302772
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.cpp
@@ -0,0 +1,53 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetAction.h"
+
+
+using namespace ai;
+
+bool TellTargetAction::Execute(Event event)
+{
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    if (target)
+    {
+        ostringstream out;
+		out << "Attacking " << target->GetName();
+        ai->TellMaster(out);
+
+        context->GetValue<Unit*>("old target")->Set(target);
+    }
+    return true;
+}
+
+bool TellAttackersAction::Execute(Event event)
+{
+    ai->TellMaster("--- Attackers ---");
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        ai->TellMaster(unit->GetName());
+    }
+
+    ai->TellMaster("--- Threat ---");
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *unit = threatManager->GetOwner();
+        float threat = ref->getThreat();
+
+        ostringstream out; out << unit->GetName() << " (" << threat << ")";
+        ai->TellMaster(out);
+
+        ref = ref->next();
+    }
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TellTargetAction.h b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
new file mode 100644
index 0000000..7995100
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TellTargetAction.h
@@ -0,0 +1,21 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+    class TellTargetAction : public Action
+    {
+    public:
+        TellTargetAction(PlayerbotAI* ai) : Action(ai, "tell target") {}
+        virtual bool Execute(Event event);
+    };
+
+    class TellAttackersAction : public Action
+    {
+    public:
+        TellAttackersAction(PlayerbotAI* ai) : Action(ai, "tell attackers") {}
+        virtual bool Execute(Event event);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.cpp b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
new file mode 100644
index 0000000..62f1c45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeAction.h"
+#include "../ItemVisitors.h"
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool TradeAction::Execute(Event event)
+{
+    string text = event.getParam();
+    uint32 copper = chat->parseMoney(text);
+    if (copper > 0)
+    {
+        WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_GOLD, 4);
+        *packet << copper;
+        bot->GetSession()->QueuePacket(packet);
+    }
+
+    int8 slot = -1;
+
+    list<Item*> found = parseItems(text);
+    if (found.empty())
+        return false;
+
+    for (list<Item*>::iterator i = found.begin(); i != found.end(); i++)
+        TradeItem(**i, slot);
+
+    return true;
+}
+
+bool TradeAction::TradeItem(const Item& item, int8 slot)
+{
+    if (!bot->GetTrader() || item.IsInTrade())
+        return false;
+
+    if (!item.CanBeTraded() && slot != TRADE_SLOT_NONTRADED)
+        slot = TRADE_SLOT_NONTRADED;
+
+    int8 tradeSlot = -1;
+    Item* itemPtr = const_cast<Item*>(&item);
+
+    TradeData* pTrade = bot->GetTradeData();
+    if ((slot >= 0 && slot < TRADE_SLOT_COUNT) && pTrade->GetItem(TradeSlots(slot)) == NULL)
+        tradeSlot = slot;
+
+    if (slot == TRADE_SLOT_NONTRADED)
+        pTrade->SetItem(TRADE_SLOT_NONTRADED, itemPtr);
+    else
+    {
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == itemPtr)
+            {
+                tradeSlot = i;
+
+                WorldPacket* const packet = new WorldPacket(CMSG_CLEAR_TRADE_ITEM, 1);
+                *packet << (uint8) tradeSlot;
+                bot->GetSession()->QueuePacket(packet);
+                pTrade->SetItem(TradeSlots(i), NULL);
+                return true;
+            }
+        }
+
+        for (uint8 i = 0; i < TRADE_SLOT_TRADED_COUNT && tradeSlot == -1; i++)
+        {
+            if (pTrade->GetItem(TradeSlots(i)) == NULL)
+            {
+                pTrade->SetItem(TradeSlots(i), itemPtr);
+                tradeSlot = i;
+            }
+        }
+    }
+
+    if (tradeSlot == -1) return false;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_SET_TRADE_ITEM, 3);
+    *packet << (uint8) tradeSlot << (uint8) item.GetBagSlot()
+        << (uint8) item.GetSlot();
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/TradeAction.h b/src/plugins/playerbot/strategy/actions/TradeAction.h
new file mode 100644
index 0000000..050a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeAction.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class TradeAction : public InventoryAction {
+    public:
+        TradeAction(PlayerbotAI* ai) : InventoryAction(ai, "trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        bool TradeItem(const Item& item, int8 slot);
+
+        static map<string, uint32> slots;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
new file mode 100644
index 0000000..df30a5c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.cpp
@@ -0,0 +1,216 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TradeStatusAction.h"
+
+#include "../ItemVisitors.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+#include "../../GuildTaskMgr.h"
+#include "../values/ItemUsageValue.h"
+
+using namespace ai;
+
+
+
+bool TradeStatusAction::Execute(Event event)
+{
+    Player* trader = bot->GetTrader();
+    Player* master = GetMaster();
+    if (!trader)
+        return false;
+
+    if (trader != master)
+    {
+		bot->Whisper("I'm kind of busy now", LANG_UNIVERSAL, trader);
+    }
+
+    if (trader != master || !ai->GetSecurity()->CheckLevelFor(PLAYERBOT_SECURITY_ALLOW_ALL, true, master))
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+        bot->GetSession()->HandleCancelTradeOpcode(p);
+        return false;
+    }
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    uint32 status;
+    p >> status;
+
+    if (status == TRADE_STATUS_TRADE_ACCEPT)
+    {
+        WorldPacket p;
+        uint32 status = 0;
+        p << status;
+
+        if (CheckTrade())
+        {
+            int32 botMoney = CalculateCost(bot->GetTradeData(), true);
+
+            map<uint32, uint32> itemIds;
+            for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+            {
+                Item* item = master->GetTradeData()->GetItem((TradeSlots)slot);
+                if (item)
+                    itemIds[item->GetTemplate()->ItemId] += item->GetCount();
+            }
+
+            bot->GetSession()->HandleAcceptTradeOpcode(p);
+            if (bot->GetTradeData())
+                return false;
+
+            for (map<uint32, uint32>::iterator i = itemIds.begin(); i != itemIds.end(); ++i)
+                sGuildTaskMgr.CheckItemTask(i->first, i->second, master, bot);
+
+            if (sRandomPlayerbotMgr.IsRandomBot(bot))
+            {
+                int32 lootAmount = sRandomPlayerbotMgr.GetLootAmount(bot);
+                sRandomPlayerbotMgr.SetLootAmount(bot, max(0, lootAmount - botMoney * 10));
+            }
+            return true;
+        }
+    }
+    else if (status == TRADE_STATUS_BEGIN_TRADE)
+    {
+        if (!bot->isInFront(trader, M_PI / 2))
+            bot->SetFacingToObject(trader);
+        BeginTrade();
+        return true;
+    }
+
+    return false;
+}
+
+
+void TradeStatusAction::BeginTrade()
+{
+    WorldPacket p;
+    bot->GetSession()->HandleBeginTradeOpcode(p);
+
+    ListItemsVisitor visitor;
+    IterateItems(&visitor);
+
+    ai->TellMaster("=== Trade ===");
+    TellItems(visitor.items);
+
+    if (sRandomPlayerbotMgr.IsRandomBot(bot))
+    {
+        uint32 discount = sRandomPlayerbotMgr.GetTradeDiscount(bot);
+        if (discount)
+        {
+            ostringstream out; out << "Discount up to: " << chat->formatMoney(discount);
+            ai->TellMaster(out);
+        }
+    }
+}
+
+bool TradeStatusAction::CheckTrade()
+{
+    if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+        return true;
+
+    Player* master = GetMaster();
+    if (!bot->GetTradeData() || !master->GetTradeData())
+        return false;
+
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = bot->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item && !auctionbot.GetSellPrice(item->GetTemplate()))
+        {
+            ostringstream out;
+            out << chat->formatItem(item->GetTemplate()) << " - This is not for sale";
+            ai->TellMaster(out);
+            return false;
+        }
+
+        item = master->GetTradeData()->GetItem((TradeSlots)slot);
+        if (item)
+        {
+            ostringstream out; out << item->GetTemplate()->ItemId;
+            ItemUsage usage = AI_VALUE2(ItemUsage, "item usage", out.str());
+            if (!auctionbot.GetBuyPrice(item->GetTemplate()) || usage == ITEM_USAGE_NONE)
+            {
+                ostringstream out;
+                out << chat->formatItem(item->GetTemplate()) << " - I don't need this";
+                ai->TellMaster(out);
+                return false;
+            }
+        }
+    }
+
+    int32 botItemsMoney = CalculateCost(bot->GetTradeData(), true);
+    int32 botMoney = bot->GetTradeData()->GetMoney() + botItemsMoney;
+    int32 playerItemsMoney = CalculateCost(master->GetTradeData(), false);
+    int32 playerMoney = master->GetTradeData()->GetMoney() + playerItemsMoney;
+
+    if (!botMoney && !playerMoney)
+        return true;
+
+    if (!botItemsMoney && !playerItemsMoney)
+    {
+        ai->TellMaster("There are no items to trade");
+        return false;
+    }
+
+    int32 discount = min(botItemsMoney, (int32)sRandomPlayerbotMgr.GetTradeDiscount(bot));
+    botMoney = max(0, botMoney - discount);
+
+    if (playerMoney >= botMoney)
+    {
+        switch (urand(0, 4)) {
+        case 0:
+            ai->TellMaster("A pleasure doing business with you");
+            break;
+        case 1:
+            ai->TellMaster("Fair trade");
+            break;
+        case 2:
+            ai->TellMaster("Thanks");
+            break;
+        case 3:
+            ai->TellMaster("Off with you");
+            break;
+        }
+        return true;
+    }
+
+    ostringstream out;
+    out << "I want " << chat->formatMoney(botMoney - playerMoney) << " for this";
+    ai->TellMaster(out);
+    return false;
+}
+
+int32 TradeStatusAction::CalculateCost(TradeData* data, bool sell)
+{
+    if (!data)
+        return 0;
+
+    uint32 sum = 0;
+    for (uint32 slot = 0; slot < TRADE_SLOT_TRADED_COUNT; ++slot)
+    {
+        Item* item = data->GetItem((TradeSlots)slot);
+        if (!item)
+            continue;
+
+        ItemTemplate const* proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        if (proto->Quality < ITEM_QUALITY_NORMAL)
+            return 0;
+
+        if (sell)
+        {
+            sum += item->GetCount() * auctionbot.GetSellPrice(proto) * sRandomPlayerbotMgr.GetSellMultiplier(bot);
+        }
+        else
+        {
+            sum += item->GetCount() * auctionbot.GetBuyPrice(proto) * sRandomPlayerbotMgr.GetBuyMultiplier(bot);
+        }
+    }
+
+    return sum;
+}
diff --git a/src/plugins/playerbot/strategy/actions/TradeStatusAction.h b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
new file mode 100644
index 0000000..7500a64
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TradeStatusAction.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+#include "QueryItemUsageAction.h"
+
+namespace ai
+{
+    class TradeStatusAction : public QueryItemUsageAction
+    {
+    public:
+        TradeStatusAction(PlayerbotAI* ai) : QueryItemUsageAction(ai, "accept trade") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void BeginTrade();
+        bool CheckTrade();
+        int32 CalculateCost(TradeData* data, bool sell);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.cpp b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
new file mode 100644
index 0000000..e261a2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.cpp
@@ -0,0 +1,114 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TrainerAction.h"
+
+using namespace ai;
+
+void TrainerAction::Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg)
+{
+    if (bot->GetMoney() < cost)
+        return;
+
+    bot->ModifyMoney(-int32(cost));
+    if (tSpell->IsCastable())
+        bot->CastSpell(bot, tSpell->spell, true);
+    else
+        bot->LearnSpell(tSpell->learnedSpell[0], false, false);
+
+    msg << " - learned";
+}
+
+void TrainerAction::List(Creature* creature, TrainerSpellAction action, SpellIds& spells)
+{
+    TellHeader(creature);
+
+    TrainerSpellData const* trainer_spells = creature->GetTrainerSpells();
+    float fDiscountMod =  bot->GetReputationPriceDiscount(creature);
+    uint32 totalCost = 0;
+
+    for (TrainerSpellMap::const_iterator itr =  trainer_spells->spellList.begin(); itr !=  trainer_spells->spellList.end(); ++itr)
+    {
+        TrainerSpell const* tSpell = &itr->second;
+
+        if (!tSpell)
+            continue;
+
+        if (!tSpell->learnedSpell && !bot->IsSpellFitByClassAndRace(tSpell->learnedSpell[0]))
+            continue;
+
+        TrainerSpellState state = bot->GetTrainerSpellState(tSpell);
+        if (state != TRAINER_SPELL_GREEN)
+            continue;
+
+        uint32 spellId = tSpell->spell;
+        const SpellInfo *const pSpellInfo =  sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        uint32 cost = uint32(floor(tSpell->spellCost *  fDiscountMod));
+        totalCost += cost;
+
+        ostringstream out;
+        out << chat->formatSpell(pSpellInfo) << chat->formatMoney(cost);
+
+        if (action && (spells.empty() || spells.find(tSpell->spell) != spells.end() || spells.find(tSpell->learnedSpell[0]) != spells.end()))
+            (this->*action)(cost, tSpell, out);
+
+        ai->TellMaster(out);
+    }
+
+    TellFooter(totalCost);
+}
+
+
+bool TrainerAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    Unit* target = master->GetSelectedUnit();
+    if (!target)
+        return false;
+
+    Creature *creature = ai->GetCreature(target->GetGUID());
+    if (!creature)
+        return false;
+
+    // check present spell in trainer spell list
+    TrainerSpellData const* cSpells = creature->GetTrainerSpells();
+    if (!cSpells)
+    {
+        ai->TellMaster("No spells can be learned from this trainer");
+        return false;
+    }
+
+    uint32 spell = chat->parseSpell(text);
+    SpellIds spells;
+    if (spell)
+        spells.insert(spell);
+
+    if (text == "learn")
+        List(creature, &TrainerAction::Learn, spells);
+    else
+        List(creature, NULL, spells);
+
+    return true;
+}
+
+void TrainerAction::TellHeader(Creature* creature)
+{
+    ostringstream out; out << "--- can learn from " << creature->GetName() << " ---";
+    ai->TellMaster(out);
+}
+
+void TrainerAction::TellFooter(uint32 totalCost)
+{
+    if (totalCost)
+    {
+        ostringstream out; out << "Total cost: " << chat->formatMoney(totalCost);
+        ai->TellMaster(out);
+    }
+}
diff --git a/src/plugins/playerbot/strategy/actions/TrainerAction.h b/src/plugins/playerbot/strategy/actions/TrainerAction.h
new file mode 100644
index 0000000..3dbe18f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/TrainerAction.h
@@ -0,0 +1,22 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class TrainerAction : public Action {
+	public:
+		TrainerAction(PlayerbotAI* ai) : Action(ai, "trainer") {}
+
+    public:
+        virtual bool Execute(Event event);
+
+    private:
+        typedef void (TrainerAction::*TrainerSpellAction)(uint32, TrainerSpell const*, ostringstream& msg);
+        void List(Creature* creature, TrainerSpellAction action, SpellIds& spells);
+        void Learn(uint32 cost, TrainerSpell const* tSpell, ostringstream& msg);
+        void TellHeader(Creature* creature);
+        void TellFooter(uint32 totalCost);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.cpp b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
new file mode 100644
index 0000000..cf70f80
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UnequipAction.h"
+
+#include "../values/ItemCountValue.h"
+
+using namespace ai;
+
+bool UnequipAction::Execute(Event event)
+{
+    string text = event.getParam();
+
+    ItemIds ids = chat->parseItems(text);
+    for (ItemIds::iterator i =ids.begin(); i != ids.end(); i++)
+    {
+        FindItemByIdVisitor visitor(*i);
+        UnequipItem(&visitor);
+    }
+
+    return true;
+}
+
+
+void UnequipAction::UnequipItem(FindItemVisitor* visitor)
+{
+    IterateItems(visitor, ITERATE_ALL_ITEMS);
+    list<Item*> items = visitor->GetResult();
+	if (!items.empty()) UnequipItem(**items.begin());
+}
+
+void UnequipAction::UnequipItem(Item& item)
+{
+    uint8 bagIndex = item.GetBagSlot();
+    uint8 slot = item.GetSlot();
+    uint8 dstBag = NULL_BAG;
+
+
+    WorldPacket* const packet = new WorldPacket(CMSG_AUTOSTORE_BAG_ITEM, 3);
+    *packet << bagIndex << slot << dstBag;
+    bot->GetSession()->QueuePacket(packet);
+
+    ostringstream out; out << chat->formatItem(item.GetTemplate()) << " unequipped";
+    ai->TellMaster(out);
+}
+
diff --git a/src/plugins/playerbot/strategy/actions/UnequipAction.h b/src/plugins/playerbot/strategy/actions/UnequipAction.h
new file mode 100644
index 0000000..fdf7ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UnequipAction.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class UnequipAction : public InventoryAction {
+    public:
+        UnequipAction(PlayerbotAI* ai) : InventoryAction(ai, "unequip") {}
+        virtual bool Execute(Event event);
+
+    private:
+        void UnequipItem(Item& item);
+        void UnequipItem(FindItemVisitor* visitor);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.cpp b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
new file mode 100644
index 0000000..1ec05bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.cpp
@@ -0,0 +1,302 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseItemAction.h"
+
+using namespace ai;
+
+bool UseItemAction::Execute(Event event)
+{
+    string name = event.getParam();
+    if (name.empty())
+        name = getName();
+
+    list<Item*> items = AI_VALUE2(list<Item*>, "inventory items", name);
+    list<ObjectGuid> gos = chat->parseGameobjects(name);
+
+    if (gos.empty())
+    {
+        if (items.size() > 1)
+        {
+            list<Item*>::iterator i = items.begin();
+            Item* itemTarget = *i++;
+            Item* item = *i;
+            return UseItemOnItem(item, itemTarget);
+        }
+        else if (!items.empty())
+            return UseItemAuto(*items.begin());
+    }
+    else
+    {
+        if (items.empty())
+            return UseGameObject(*gos.begin());
+        else
+            return UseItemOnGameObject(*items.begin(), *gos.begin());
+    }
+
+    ai->TellMaster("No items (or game objects) available");
+    return false;
+}
+
+bool UseItemAction::UseGameObject(ObjectGuid guid)
+{
+    GameObject* go = ai->GetGameObject(guid);
+    if (!go || !go->isSpawned())
+        return false;
+
+    go->Use(bot);
+    ostringstream out; out << "Using " << chat->formatGameobject(go);
+    ai->TellMasterNoFacing(out.str());
+    return true;
+}
+
+bool UseItemAction::UseItemAuto(Item* item)
+{
+    return UseItem(item, ObjectGuid(), NULL);
+}
+
+bool UseItemAction::UseItemOnGameObject(Item* item, ObjectGuid go)
+{
+    return UseItem(item, go, NULL);
+}
+
+bool UseItemAction::UseItemOnItem(Item* item, Item* itemTarget)
+{
+    return UseItem(item, ObjectGuid(), itemTarget);
+}
+
+bool UseItemAction::UseItem(Item* item, ObjectGuid goGuid, Item* itemTarget)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return false;
+
+    if (bot->IsNonMeleeSpellCast(true))
+        return false;
+
+    if (bot->IsInCombat() && item->IsPotion() && bot->GetLastPotionId())
+        return false;
+
+    uint8 bagIndex = item->GetBagSlot();
+    uint8 slot = item->GetSlot();
+    uint8 cast_count = 1;
+    uint64 item_guid = item->GetGUID();
+    uint32 glyphIndex = 0;
+    uint8 unk_flags = 0;
+
+    WorldPacket* const packet = new WorldPacket(CMSG_USE_ITEM, 1 + 1 + 1 + 4 + 8 + 4 + 1 + 8 + 1);
+    *packet << bagIndex << slot << cast_count << uint32(0) << item_guid
+        << glyphIndex << unk_flags;
+
+    bool targetSelected = false;
+    ostringstream out; out << "Using " << chat->formatItem(item->GetTemplate());
+    if (item->GetTemplate()->Stackable)
+    {
+        uint32 count = item->GetCount();
+        if (count > 1)
+            out << " (" << count << " available) ";
+        else
+            out << " (the last one!)";
+    }
+
+    if (goGuid)
+    {
+        GameObject* go = ai->GetGameObject(goGuid);
+        if (go && go->isSpawned())
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT_ENEMY;
+            *packet << targetFlag;
+            packet->appendPackGUID(goGuid.GetRawValue());
+            out << " on " << chat->formatGameobject(go);
+            targetSelected = true;
+        }
+    }
+
+    if (itemTarget)
+    {
+        if (item->GetTemplate()->Class == ITEM_CLASS_GEM)
+        {
+            bool fit = SocketItem(itemTarget, item) || SocketItem(itemTarget, item, true);
+            if (!fit)
+                ai->TellMaster("Socket does not fit");
+            return fit;
+        }
+        else
+        {
+            uint32 targetFlag = TARGET_FLAG_ITEM;
+            *packet << targetFlag;
+            packet->appendPackGUID(itemTarget->GetGUID());
+            out << " on " << chat->formatItem(itemTarget->GetTemplate());
+            targetSelected = true;
+        }
+    }
+
+    Player* master = GetMaster();
+    if (!targetSelected && item->GetTemplate()->Class != ITEM_CLASS_CONSUMABLE && master)
+    {
+        Unit* masterSelection = master->GetSelectedUnit();
+        if (masterSelection)
+        {
+            uint32 targetFlag = TARGET_FLAG_UNIT;
+            *packet << targetFlag;
+            packet->appendPackGUID(masterSelection->GetGUID());
+            out << " on " << masterSelection->GetName();
+            targetSelected = true;
+        }
+    }
+
+    if(uint32 questid = item->GetTemplate()->StartQuest)
+    {
+        Quest const* qInfo = sObjectMgr->GetQuestTemplate(questid);
+        if (qInfo)
+        {
+            WorldPacket* const packet = new WorldPacket(CMSG_QUESTGIVER_ACCEPT_QUEST, 8+4+4);
+            *packet << item_guid;
+            *packet << questid;
+            *packet << uint32(0);
+            bot->GetSession()->QueuePacket(packet); // queue the packet to get around race condition
+            ostringstream out; out << "Got quest " << chat->formatQuest(qInfo);
+            ai->TellMasterNoFacing(out.str());
+            return true;
+        }
+    }
+
+    MotionMaster &mm = *bot->GetMotionMaster();
+    mm.Clear();
+    bot->ClearUnitState( UNIT_STATE_CHASE );
+    bot->ClearUnitState( UNIT_STATE_FOLLOW );
+
+    if (bot->isMoving())
+        return false;
+
+    for (int i=0; i<MAX_ITEM_PROTO_SPELLS; i++)
+    {
+        uint32 spellId = item->GetTemplate()->Spells[i].SpellId;
+        if (!spellId)
+            continue;
+
+        if (!ai->CanCastSpell(spellId, bot, false))
+            continue;
+
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (pSpellInfo->Targets & TARGET_FLAG_ITEM)
+        {
+            Item* itemForSpell = AI_VALUE2(Item*, "item for spell", spellId);
+            if (!itemForSpell)
+                continue;
+
+            if (itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+                continue;
+
+            if (bot->GetTrader())
+            {
+                if (selfOnly)
+                    return false;
+
+                *packet << TARGET_FLAG_TRADE_ITEM << (uint8)1 << (uint64)TRADE_SLOT_NONTRADED;
+                targetSelected = true;
+                out << " on traded item";
+            }
+            else
+            {
+                *packet << TARGET_FLAG_ITEM;
+                packet->appendPackGUID(itemForSpell->GetGUID());
+                targetSelected = true;
+                out << " on "<< chat->formatItem(itemForSpell->GetTemplate());
+            }
+
+            Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE, ObjectGuid::Empty, true);
+            ai->WaitForSpellCast(spell);
+            delete spell;
+        }
+        else
+        {
+            *packet << TARGET_FLAG_NONE;
+            targetSelected = true;
+            out << " on self";
+        }
+        break;
+    }
+
+    if (!targetSelected)
+        return false;
+
+    if (item->GetTemplate()->Class == ITEM_CLASS_CONSUMABLE && item->GetTemplate()->SubClass == ITEM_SUBCLASS_FOOD)
+    {
+        if (bot->IsInCombat())
+            return false;
+
+        ai->InterruptSpell();
+        ai->SetNextCheckDelay(30000);
+    }
+
+    ai->TellMasterNoFacing(out.str());
+    bot->GetSession()->QueuePacket(packet);
+    return true;
+}
+
+bool UseItemAction::SocketItem(Item* item, Item* gem, bool replace)
+{
+    WorldPacket* const packet = new WorldPacket(CMSG_SOCKET_GEMS);
+    *packet << item->GetGUID();
+
+    bool fits = false;
+    for (uint32 enchant_slot = SOCK_ENCHANTMENT_SLOT; enchant_slot < SOCK_ENCHANTMENT_SLOT + MAX_GEM_SOCKETS; ++enchant_slot)
+    {
+        uint8 SocketColor = item->GetTemplate()->Socket[enchant_slot-SOCK_ENCHANTMENT_SLOT].Color;
+        GemPropertiesEntry const* gemProperty = sGemPropertiesStore.LookupEntry(gem->GetTemplate()->GemProperties);
+        if (gemProperty && (gemProperty->color & SocketColor))
+        {
+            if (fits)
+            {
+                *packet << ObjectGuid();
+                continue;
+            }
+
+            uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(enchant_slot));
+            if (!enchant_id)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+            SpellItemEnchantmentEntry const* enchantEntry = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+            if (!enchantEntry || !enchantEntry->GemID)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+			if (replace && enchantEntry->GemID != gem->GetTemplate()->ItemId)
+            {
+                *packet << gem->GetGUID();
+                fits = true;
+                continue;
+            }
+
+        }
+
+        *packet << ObjectGuid();
+    }
+
+    if (fits)
+    {
+        ostringstream out; out << "Socketing " << chat->formatItem(item->GetTemplate());
+        out << " with "<< chat->formatItem(gem->GetTemplate());
+        ai->TellMasterNoFacing(out.str());
+
+        bot->GetSession()->QueuePacket(packet);
+    }
+    return fits;
+}
+
+
+bool UseItemAction::isPossible()
+{
+    return getName() == "use" || AI_VALUE2(uint8, "item count", getName()) > 0;
+}
+
+bool UseSpellItemAction::isUseful()
+{
+    return AI_VALUE2(bool, "spell cast useful", getName());
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseItemAction.h b/src/plugins/playerbot/strategy/actions/UseItemAction.h
new file mode 100644
index 0000000..ef65561
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseItemAction.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "../Action.h"
+
+namespace ai
+{
+	class UseItemAction : public Action {
+	public:
+		UseItemAction(PlayerbotAI* ai, string name = "use", bool selfOnly = false) : Action(ai, name), selfOnly(selfOnly) {}
+
+    public:
+        virtual bool Execute(Event event);
+        virtual bool isPossible();
+
+    private:
+        bool UseItemAuto(Item* item);
+        bool UseItemOnGameObject(Item* item, ObjectGuid go);
+        bool UseItemOnItem(Item* item, Item* itemTarget);
+        bool UseItem(Item* item, ObjectGuid go, Item* itemTarget);
+        bool UseGameObject(ObjectGuid guid);
+        bool SocketItem(Item* item, Item* gem, bool replace = false);
+
+    private:
+        bool selfOnly;
+    };
+
+    class UseSpellItemAction : public UseItemAction {
+    public:
+        UseSpellItemAction(PlayerbotAI* ai, string name, bool selfOnly = false) : UseItemAction(ai, name, selfOnly) {}
+
+    public:
+        virtual bool isUseful();
+    };
+
+    class UseHealingPotion : public UseItemAction {
+    public:
+        UseHealingPotion(PlayerbotAI* ai) : UseItemAction(ai, "healing potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+
+    class UseManaPotion : public UseItemAction
+    {
+    public:
+        UseManaPotion(PlayerbotAI* ai) : UseItemAction(ai, "mana potion") {}
+        virtual bool isUseful() { return AI_VALUE2(bool, "combat", "self target"); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
new file mode 100644
index 0000000..fd42c37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.cpp
@@ -0,0 +1,81 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseMeetingStoneAction.h"
+#include "../../PlayerbotAIConfig.h"
+
+bool UseMeetingStoneAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    WorldPacket p(event.getPacket());
+    p.rpos(0);
+    ObjectGuid guid;
+    p >> guid;
+
+    if (master->GetSelectedPlayer() && master->GetSelectedPlayer() != bot)
+        return false;
+
+    if (!master->GetSelectedPlayer() && master->GetGroup() != bot->GetGroup())
+        return false;
+
+    if (master->IsBeingTeleported())
+        return false;
+
+    if (bot->IsInCombat())
+    {
+        ai->TellMasterNoFacing("I am in combat");
+        return false;
+    }
+
+    GameObject *gameObject = ai->GetGameObject(guid);
+    if (!gameObject)
+        return false;
+
+    const GameObjectTemplate* goInfo = gameObject->GetGOInfo();
+    if (!goInfo || goInfo->type != GAMEOBJECT_TYPE_SUMMONING_RITUAL)
+        return false;
+
+    return Teleport();
+}
+
+
+bool SummonAction::Execute(Event event)
+{
+    Player* master = GetMaster();
+    if (!master)
+        return false;
+
+    if (master->GetSession()->GetSecurity() < SEC_GAMEMASTER)
+    {
+        ai->TellMasterNoFacing("You cannot summon me");
+        return false;
+    }
+
+    return Teleport();
+}
+
+bool SummonAction::Teleport()
+{
+    Player* master = GetMaster();
+    if (!master->IsBeingTeleported())
+    {
+        float followAngle = GetFollowAngle();
+        for (float angle = followAngle - M_PI; angle <= followAngle + M_PI; angle += M_PI / 4)
+        {
+            uint32 mapId = master->GetMapId();
+            float x = master->GetPositionX() + cos(angle) * sPlayerbotAIConfig.followDistance;
+            float y = master->GetPositionY()+ sin(angle) * sPlayerbotAIConfig.followDistance;
+            float z = master->GetPositionZ();
+            if (master->IsWithinLOS(x, y, z))
+            {
+                bot->GetMotionMaster()->Clear();
+                bot->TeleportTo(mapId, x, y, z, 0);
+                return true;
+            }
+        }
+    }
+
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
new file mode 100644
index 0000000..e787d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/UseMeetingStoneAction.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#include "../Action.h"
+#include "MovementActions.h"
+
+namespace ai
+{
+    class SummonAction : public MovementAction
+    {
+    public:
+        SummonAction(PlayerbotAI* ai, string name = "summon") : MovementAction(ai, name) {}
+
+        virtual bool Execute(Event event);
+
+    protected:
+        bool Teleport();
+    };
+
+    class UseMeetingStoneAction : public SummonAction
+    {
+    public:
+        UseMeetingStoneAction(PlayerbotAI* ai) : SummonAction(ai, "use meeting stone") {}
+
+        virtual bool Execute(Event event);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.cpp b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
new file mode 100644
index 0000000..9dd7f95
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.cpp
@@ -0,0 +1,160 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WhoAction.h"
+#include "../../AiFactory.h"
+#include "../ItemVisitors.h"
+#include "../../../ahbot/AhBot.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+map<uint32, string> WhoAction::skills;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+bool WhoAction::Execute(Event event)
+{
+    Player* owner = event.getOwner();
+    if (!owner)
+        return false;
+
+    string tell = "";
+    string text = event.getParam();
+    if (!text.empty())
+    {
+        if (!sRandomPlayerbotMgr.IsRandomBot(bot))
+            return false;
+
+        tell = QuerySkill(text);
+        if (tell.empty())
+        {
+            tell = QueryTrade(text);
+        }
+    }
+    else
+    {
+        tell = QuerySpec(text);
+    }
+
+    if (tell.empty())
+        return false;
+
+    // ignore random bot chat filter
+	bot->Whisper(tell, LANG_UNIVERSAL, owner);
+    return true;
+}
+
+
+string WhoAction::QueryTrade(string text)
+{
+    ostringstream out;
+
+    list<Item*> items = InventoryAction::parseItems(text);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* sell = *i;
+        int32 sellPrice = auctionbot.GetSellPrice(sell->GetTemplate()) * sRandomPlayerbotMgr.GetSellMultiplier(bot) * sell->GetCount();
+        if (!sellPrice)
+            continue;
+
+        out << "Selling " << chat->formatItem(sell->GetTemplate(), sell->GetCount()) << " for " << chat->formatMoney(sellPrice);
+        return out.str();
+    }
+
+    return "";
+}
+
+string WhoAction::QuerySkill(string text)
+{
+    ostringstream out;
+    InitSkills();
+
+    for (map<uint32, string>::iterator i = skills.begin(); i != skills.end(); ++i)
+    {
+        string name = i->second;
+        uint16 skill = i->first;
+        if (!strcmpi(text.c_str(), name.c_str()) && bot->HasSkill(skill))
+        {
+            string skillName = i->second;
+            uint32 spellId = AI_VALUE2(uint32, "spell id", skillName);
+            uint16 value = bot->GetSkillValue(skill);
+            uint16 maxSkill = bot->GetMaxSkillValue(skill);
+            ObjectGuid guid = bot->GetGUID();
+            string data = "0";
+            out << "|cFFFFFF00|Htrade:" << spellId << ":" << value << ":" << maxSkill << ":"
+                    << std::hex << std::uppercase << guid.GetRawValue()
+                    << std::nouppercase << std::dec << ":" << data
+                    << "|h[" << skills[skill] << "]|h|r"
+                    << " |h|cff00ff00" << value << "|h|cffffffff/"
+                    << "|h|cff00ff00" << maxSkill << "|h|cffffffff ";
+        }
+    }
+
+    return out.str();
+}
+
+string WhoAction::QuerySpec(string text)
+{
+    ostringstream out;
+
+    int spec = AiFactory::GetPlayerSpecTab(bot);
+    out << "|h|cffffffff" << chat->formatClass(bot, spec);
+    out << " (|h|cff00ff00" << (uint32)bot->getLevel() << "|h|cffffffff lvl), ";
+    out << "|h|cff00ff00" << ai->GetEquipGearScore(bot, false, false) << "|h|cffffffff GS (";
+
+    ItemCountByQuality visitor;
+    IterateItems(&visitor, ITERATE_ITEMS_IN_EQUIP);
+
+    bool needSlash = false;
+    if (visitor.count[ITEM_QUALITY_EPIC])
+    {
+        out << "|h|cffff00ff" << visitor.count[ITEM_QUALITY_EPIC] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_RARE])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff8080ff" << visitor.count[ITEM_QUALITY_RARE] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    if (visitor.count[ITEM_QUALITY_UNCOMMON])
+    {
+        if (needSlash) out << "/";
+        out << "|h|cff00ff00" << visitor.count[ITEM_QUALITY_UNCOMMON] << "|h|cffffffff";
+        needSlash = true;
+    }
+
+    out << ")";
+
+    return out.str();
+}
+
+
+void WhoAction::InitSkills()
+{
+    if (!skills.empty())
+        return;
+
+    skills[SKILL_ALCHEMY] = "Alchemy";
+    skills[SKILL_ENCHANTING] = "Enchanting";
+    skills[SKILL_SKINNING] = "Skinning";
+    skills[SKILL_JEWELCRAFTING] = "Jewelcrafting";
+    skills[SKILL_INSCRIPTION] = "Inscription";
+    skills[SKILL_TAILORING] = "Tailoring";
+    skills[SKILL_LEATHERWORKING] = "Leatherworking";
+    skills[SKILL_ENGINEERING] = "Engineering";
+    skills[SKILL_HERBALISM] = "Herbalism";
+    skills[SKILL_MINING] = "Mining";
+    skills[SKILL_BLACKSMITHING] = "Blacksmithing";
+    skills[SKILL_COOKING] = "Cooking";
+    skills[SKILL_FIRST_AID] = "First Aid";
+    skills[SKILL_FISHING] = "Fishing";
+}
diff --git a/src/plugins/playerbot/strategy/actions/WhoAction.h b/src/plugins/playerbot/strategy/actions/WhoAction.h
new file mode 100644
index 0000000..92ed834
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WhoAction.h
@@ -0,0 +1,23 @@
+#pragma once
+
+#include "../Action.h"
+#include "InventoryAction.h"
+
+namespace ai
+{
+    class WhoAction : public InventoryAction {
+    public:
+        WhoAction(PlayerbotAI* ai) : InventoryAction(ai, "who") {}
+
+    public:
+        virtual bool Execute(Event event);
+        static map<uint32, string> skills;
+
+    private:
+        void InitSkills();
+        string QueryTrade(string text);
+        string QuerySkill(string text);
+        string QuerySpec(string text);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
new file mode 100644
index 0000000..268f2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/actions/WorldPacketActionContext.h
@@ -0,0 +1,108 @@
+#pragma once
+
+#include "AcceptInvitationAction.h"
+#include "PassLeadershipToMasterAction.h"
+#include "TellMasterAction.h"
+#include "TalkToQuestGiverAction.h"
+#include "AcceptQuestAction.h"
+#include "LootRollAction.h"
+#include "ReviveFromCorpseAction.h"
+#include "AcceptResurrectAction.h"
+#include "UseMeetingStoneAction.h"
+#include "AreaTriggerAction.h"
+#include "CheckMountStateAction.h"
+#include "RememberTaxiAction.h"
+#include "TradeStatusAction.h"
+#include "InventoryChangeFailureAction.h"
+#include "LootAction.h"
+#include "QuestAction.h"
+#include "LeaveGroupAction.h"
+#include "TellCastFailedAction.h"
+#include "AcceptDuelAction.h"
+#include "ReadyCheckAction.h"
+#include "LfgActions.h"
+#include "SecurityCheckAction.h"
+#include "GuildAcceptAction.h"
+
+namespace ai
+{
+    class WorldPacketActionContext : public NamedObjectContext<Action>
+    {
+    public:
+        WorldPacketActionContext()
+        {
+            creators["accept invitation"] = &WorldPacketActionContext::accept_invitation;
+            creators["leader"] = &WorldPacketActionContext::pass_leadership_to_master;
+            creators["tell not enough money"] = &WorldPacketActionContext::tell_not_enough_money;
+            creators["tell not enough reputation"] = &WorldPacketActionContext::tell_not_enough_reputation;
+            creators["tell cannot equip"] = &WorldPacketActionContext::tell_cannot_equip;
+            creators["talk to quest giver"] = &WorldPacketActionContext::turn_in_quest;
+            creators["accept quest"] = &WorldPacketActionContext::accept_quest;
+            creators["accept all quests"] = &WorldPacketActionContext::accept_all_quests;
+            creators["accept quest share"] = &WorldPacketActionContext::accept_quest_share;
+            creators["loot roll"] = &WorldPacketActionContext::loot_roll;
+            creators["revive from corpse"] = &WorldPacketActionContext::revive_from_corpse;
+            creators["accept resurrect"] = &WorldPacketActionContext::accept_resurrect;
+            creators["use meeting stone"] = &WorldPacketActionContext::use_meeting_stone;
+            creators["area trigger"] = &WorldPacketActionContext::area_trigger;
+            creators["reach area trigger"] = &WorldPacketActionContext::reach_area_trigger;
+            creators["check mount state"] = &WorldPacketActionContext::check_mount_state;
+            creators["remember taxi"] = &WorldPacketActionContext::remember_taxi;
+            creators["accept trade"] = &WorldPacketActionContext::accept_trade;
+            creators["store loot"] = &WorldPacketActionContext::store_loot;
+            creators["tell out of react range"] = &WorldPacketActionContext::tell_out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketActionContext::quest_objective_completed;
+            creators["party command"] = &WorldPacketActionContext::party_command;
+            creators["tell cast failed"] = &WorldPacketActionContext::tell_cast_failed;
+            creators["accept duel"] = &WorldPacketActionContext::accept_duel;
+            creators["ready check"] = &WorldPacketActionContext::ready_check;
+            creators["ready check finished"] = &WorldPacketActionContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketActionContext::uninvite;
+            creators["lfg join"] = &WorldPacketActionContext::lfg_join;
+            creators["lfg accept"] = &WorldPacketActionContext::lfg_accept;
+            creators["lfg role check"] = &WorldPacketActionContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketActionContext::lfg_leave;
+            creators["lfg teleport"] = &WorldPacketActionContext::lfg_teleport;
+            creators["security check"] = &WorldPacketActionContext::security_check;
+            creators["guild accept"] = &WorldPacketActionContext::guild_accept;
+        }
+
+    private:
+        static Action* guild_accept(PlayerbotAI* ai) { return new GuildAcceptAction(ai); }
+        static Action* security_check(PlayerbotAI* ai) { return new SecurityCheckAction(ai); }
+        static Action* lfg_teleport(PlayerbotAI* ai) { return new LfgTeleportAction(ai); }
+        static Action* lfg_leave(PlayerbotAI* ai) { return new LfgLeaveAction(ai); }
+        static Action* lfg_accept(PlayerbotAI* ai) { return new LfgAcceptAction(ai); }
+        static Action* lfg_role_check(PlayerbotAI* ai) { return new LfgRoleCheckAction(ai); }
+        static Action* lfg_join(PlayerbotAI* ai) { return new LfgJoinAction(ai); }
+        static Action* uninvite(PlayerbotAI* ai) { return new UninviteAction(ai); }
+        static Action* ready_check_finished(PlayerbotAI* ai) { return new FinishReadyCheckAction(ai); }
+        static Action* ready_check(PlayerbotAI* ai) { return new ReadyCheckAction(ai); }
+        static Action* accept_duel(PlayerbotAI* ai) { return new AcceptDuelAction(ai); }
+        static Action* tell_cast_failed(PlayerbotAI* ai) { return new TellCastFailedAction(ai); }
+        static Action* party_command(PlayerbotAI* ai) { return new PartyCommandAction(ai); }
+        static Action* quest_objective_completed(PlayerbotAI* ai) { return new QuestObjectiveCompletedAction(ai); }
+        static Action* store_loot(PlayerbotAI* ai) { return new StoreLootAction(ai); }
+        static Action* tell_out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeAction(ai); }
+        static Action* accept_trade(PlayerbotAI* ai) { return new TradeStatusAction(ai); }
+        static Action* remember_taxi(PlayerbotAI* ai) { return new RememberTaxiAction(ai); }
+        static Action* check_mount_state(PlayerbotAI* ai) { return new CheckMountStateAction(ai); }
+        static Action* area_trigger(PlayerbotAI* ai) { return new AreaTriggerAction(ai); }
+        static Action* reach_area_trigger(PlayerbotAI* ai) { return new ReachAreaTriggerAction(ai); }
+        static Action* use_meeting_stone(PlayerbotAI* ai) { return new UseMeetingStoneAction(ai); }
+        static Action* accept_resurrect(PlayerbotAI* ai) { return new AcceptResurrectAction(ai); }
+        static Action* revive_from_corpse(PlayerbotAI* ai) { return new ReviveFromCorpseAction(ai); }
+        static Action* accept_invitation(PlayerbotAI* ai) { return new AcceptInvitationAction(ai); }
+        static Action* pass_leadership_to_master(PlayerbotAI* ai) { return new PassLeadershipToMasterAction(ai); }
+        static Action* tell_not_enough_money(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough money"); }
+        static Action* tell_not_enough_reputation(PlayerbotAI* ai) { return new TellMasterAction(ai, "Not enough reputation"); }
+        static Action* tell_cannot_equip(PlayerbotAI* ai) { return new InventoryChangeFailureAction(ai); }
+        static Action* turn_in_quest(PlayerbotAI* ai) { return new TalkToQuestGiverAction(ai); }
+        static Action* accept_quest(PlayerbotAI* ai) { return new AcceptQuestAction(ai); }
+        static Action* accept_all_quests(PlayerbotAI* ai) { return new AcceptAllQuestsAction(ai); }
+        static Action* accept_quest_share(PlayerbotAI* ai) { return new AcceptQuestShareAction(ai); }
+        static Action* loot_roll(PlayerbotAI* ai) { return (QueryItemUsageAction*)new LootRollAction(ai); }
+    };
+
+
+};
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
new file mode 100644
index 0000000..fa86bb1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.cpp
@@ -0,0 +1,171 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "BearTankDruidStrategy.h"
+
+using namespace ai;
+
+class BearTankDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    BearTankDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["feral charge - bear"] = &feral_charge_bear;
+        creators["swipe (bear)"] = &swipe_bear;
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["bear form"] = &bear_form;
+        creators["dire bear form"] = &dire_bear_form;
+        creators["mangle (bear)"] = &mangle_bear;
+        creators["maul"] = &maul;
+        creators["bash"] = &bash;
+        creators["swipe"] = &swipe;
+        creators["lacerate"] = &lacerate;
+        creators["demoralizing roar"] = &demoralizing_roar;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - bear",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe (bear)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - bear"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bear form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* dire_bear_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dire bear form",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("bear form"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_bear(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (bear)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lacerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* maul(PlayerbotAI* ai)
+    {
+        return new ActionNode ("maul",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* swipe(PlayerbotAI* ai)
+    {
+        return new ActionNode ("swipe",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lacerate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lacerate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("maul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* growl(PlayerbotAI* ai)
+    {
+        return new ActionNode ("growl",
+            /*P*/ NextAction::array(0, new NextAction("reach spell"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* demoralizing_roar(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demoralizing roar",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+BearTankDruidStrategy::BearTankDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new BearTankDruidStrategyActionNodeFactory());
+}
+
+NextAction** BearTankDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0,
+            new NextAction("lacerate", ACTION_NORMAL + 4),
+            new NextAction("mangle (bear)", ACTION_NORMAL + 3),
+            new NextAction("maul", ACTION_NORMAL + 2),
+            new NextAction("faerie fire (feral)", ACTION_NORMAL + 1),
+            NULL);
+}
+
+void BearTankDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "thorns",
+        NextAction::array(0, new NextAction("thorns", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bear form",
+        NextAction::array(0, new NextAction("dire bear form", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("growl", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("demoralizing roar", ACTION_HIGH + 6), new NextAction("swipe (bear)", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("swipe (bear)", ACTION_HIGH + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash",
+        NextAction::array(0, new NextAction("bash", ACTION_INTERRUPT + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bash on enemy healer",
+        NextAction::array(0, new NextAction("bash on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
new file mode 100644
index 0000000..1e8a3f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/BearTankDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+
+namespace ai
+{
+    class BearTankDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        BearTankDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bear"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
new file mode 100644
index 0000000..bb07940
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CasterDruidStrategy.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class CasterDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire"] = &faerie_fire;
+        creators["hibernate"] = &hibernate;
+        creators["entangling roots"] = &entangling_roots;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["wrath"] = &wrath;
+        creators["starfall"] = &starfall;
+        creators["insect swarm"] = &insect_swarm;
+        creators["moonfire"] = &moonfire;
+        creators["starfire"] = &starfire;
+        creators["nature's grasp"] = &natures_grasp;
+    }
+private:
+    static ActionNode* faerie_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* hibernate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hibernate",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("entangling roots"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("flee", 49.0f), NULL));
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* wrath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("wrath",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfall",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("hurricane"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* insect_swarm(PlayerbotAI* ai)
+    {
+        return new ActionNode ("insect swarm",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* moonfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("moonfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* starfire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("starfire",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* natures_grasp(PlayerbotAI* ai)
+    {
+        return new ActionNode ("nature's grasp",
+            /*P*/ NextAction::array(0, new NextAction("moonkin form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CasterDruidStrategy::CasterDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+NextAction** CasterDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 2), new NextAction("wrath", ACTION_NORMAL + 1), NULL);
+}
+
+void CasterDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_MOVE), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+
+	triggers.push_back(new TriggerNode(
+		"insect swarm",
+		NextAction::array(0, new NextAction("insect swarm", ACTION_NORMAL + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"moonfire",
+		NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (solar)",
+        NextAction::array(0, new NextAction("wrath", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "eclipse (lunar)",
+        NextAction::array(0, new NextAction("starfire", ACTION_NORMAL + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "moonfire",
+        NextAction::array(0, new NextAction("moonfire", ACTION_NORMAL + 4), NULL)));
+
+
+
+	triggers.push_back(new TriggerNode(
+		"nature's grasp",
+		NextAction::array(0, new NextAction("nature's grasp", ACTION_EMERGENCY), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 2), NULL)));
+}
+
+void CasterDruidAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("starfall", ACTION_HIGH + 1), NULL)));
+}
+
+void CasterDruidDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "faerie fire",
+        NextAction::array(0, new NextAction("faerie fire", ACTION_HIGH), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
new file mode 100644
index 0000000..66ac838
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CasterDruidStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CasterDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        CasterDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterDruidAoeStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+
+    class CasterDruidDebuffStrategy : public CombatStrategy
+    {
+    public:
+        CasterDruidDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
new file mode 100644
index 0000000..67515b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.cpp
@@ -0,0 +1,139 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "CatDpsDruidStrategy.h"
+
+using namespace ai;
+
+class CatDpsDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CatDpsDruidStrategyActionNodeFactory()
+    {
+        creators["faerie fire (feral)"] = &faerie_fire_feral;
+        creators["melee"] = &melee;
+        creators["feral charge - cat"] = &feral_charge_cat;
+        creators["cat form"] = &cat_form;
+        creators["claw"] = &claw;
+        creators["mangle (cat)"] = &mangle_cat;
+        creators["rake"] = &rake;
+        creators["ferocious bite"] = &ferocious_bite;
+        creators["rip"] = &rip;
+    }
+private:
+    static ActionNode* faerie_fire_feral(PlayerbotAI* ai)
+    {
+        return new ActionNode ("faerie fire (feral)",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("feral charge - cat"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* feral_charge_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feral charge - cat",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* cat_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cat form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* claw(PlayerbotAI* ai)
+    {
+        return new ActionNode ("claw",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mangle_cat(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mangle (cat)",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("claw"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rake(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rake",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* ferocious_bite(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ferocious bite",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rip"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rip(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rip",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+CatDpsDruidStrategy::CatDpsDruidStrategy(PlayerbotAI* ai) : FeralDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new CatDpsDruidStrategyActionNodeFactory());
+}
+
+NextAction** CatDpsDruidStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mangle (cat)", ACTION_NORMAL + 1), NULL);
+}
+
+void CatDpsDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    FeralDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "cat form",
+        NextAction::array(0, new NextAction("cat form", ACTION_MOVE + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rake",
+        NextAction::array(0, new NextAction("rake", ACTION_NORMAL + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("ferocious bite", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("cower", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "faerie fire (feral)",
+        NextAction::array(0, new NextAction("faerie fire (feral)", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"tiger's fury",
+		NextAction::array(0, new NextAction("tiger's fury", ACTION_EMERGENCY + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+
+}
+
+void CatAoeDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("swipe (cat)", ACTION_HIGH + 2), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
new file mode 100644
index 0000000..397f0b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/CatDpsDruidStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "FeralDruidStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class CatDpsDruidStrategy : public FeralDruidStrategy
+    {
+    public:
+        CatDpsDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+    class CatAoeDruidStrategy : public CombatStrategy
+    {
+    public:
+        CatAoeDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "cat aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.cpp b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
new file mode 100644
index 0000000..fc49e68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
+bool CastCasterFormAction::Execute(Event event)
+{
+    ai->RemoveShapeshift();
+    return true;
+}
+
+NextAction** CastAbolishPoisonAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison"), NULL), CastSpellAction::getPrerequisites());
+}
+
+NextAction** CastAbolishPoisonOnPartyAction::getAlternatives()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("cure poison on party"), NULL), CastSpellAction::getPrerequisites());
+}
+
+Value<Unit*>* CastEntanglingRootsCcAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "entangling roots");
+}
+
+bool CastEntanglingRootsCcAction::Execute(Event event)
+{
+    return ai->CastSpell("entangling roots", GetTarget()); 
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidActions.h b/src/plugins/playerbot/strategy/druid/DruidActions.h
new file mode 100644
index 0000000..965f454
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "DruidShapeshiftActions.h"
+#include "DruidBearActions.h"
+#include "DruidCatActions.h"
+
+namespace ai
+{
+	class CastFaerieFireAction : public CastSpellAction
+	{
+	public:
+		CastFaerieFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire") {}
+	};
+
+    class CastFaerieFireFeralAction : public CastSpellAction
+    {
+    public:
+        CastFaerieFireFeralAction(PlayerbotAI* ai) : CastSpellAction(ai, "faerie fire (feral)") {}
+    };
+
+	class CastRejuvenationAction : public CastHealingSpellAction {
+	public:
+		CastRejuvenationAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "rejuvenation") {}
+	};
+
+	class CastRegrowthAction : public CastHealingSpellAction {
+	public:
+		CastRegrowthAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "regrowth") {}
+
+	};
+
+    class CastHealingTouchAction : public CastHealingSpellAction {
+    public:
+        CastHealingTouchAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing touch") {}
+
+    };
+
+    class CastRejuvenationOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRejuvenationOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "rejuvenation") {}
+    };
+
+    class CastRegrowthOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRegrowthOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "regrowth") {}
+    };
+
+    class CastHealingTouchOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingTouchOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing touch") {}
+    };
+
+	class CastReviveAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastReviveAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "revive") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastRebirthAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRebirthAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "rebirth") {}
+
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("caster form"), NULL), ResurrectPartyMemberAction::getPrerequisites());
+		}
+	};
+
+	class CastMarkOfTheWildAction : public CastBuffSpellAction {
+	public:
+		CastMarkOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mark of the wild") {}
+	};
+
+	class CastMarkOfTheWildOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastMarkOfTheWildOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "mark of the wild") {}
+	};
+
+	class CastSurvivalInstinctsAction : public CastBuffSpellAction {
+	public:
+		CastSurvivalInstinctsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "survival instincts") {}
+	};
+
+	class CastThornsAction : public CastBuffSpellAction {
+	public:
+		CastThornsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "thorns") {}
+	};
+
+	class CastWrathAction : public CastSpellAction
+	{
+	public:
+		CastWrathAction(PlayerbotAI* ai) : CastSpellAction(ai, "wrath") {}
+	};
+
+	class CastStarfallAction : public CastSpellAction
+	{
+	public:
+		CastStarfallAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfall") {}
+	};
+
+	class CastHurricaneAction : public CastSpellAction
+	{
+	public:
+	    CastHurricaneAction(PlayerbotAI* ai) : CastSpellAction(ai, "hurricane") {}
+	};
+
+	class CastMoonfireAction : public CastDebuffSpellAction
+	{
+	public:
+		CastMoonfireAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "moonfire") {}
+	};
+
+	class CastInsectSwarmAction : public CastDebuffSpellAction
+	{
+	public:
+		CastInsectSwarmAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "insect swarm") {}
+	};
+
+	class CastStarfireAction : public CastSpellAction
+	{
+	public:
+		CastStarfireAction(PlayerbotAI* ai) : CastSpellAction(ai, "starfire") {}
+	};
+
+	class CastEntanglingRootsAction : public CastSpellAction
+	{
+	public:
+		CastEntanglingRootsAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots") {}
+	};
+
+    class CastEntanglingRootsCcAction : public CastSpellAction
+    {
+    public:
+        CastEntanglingRootsCcAction(PlayerbotAI* ai) : CastSpellAction(ai, "entangling roots on cc") {}
+        virtual Value<Unit*>* GetTargetValue();
+        virtual bool Execute(Event event);
+    };
+
+	class CastNaturesGraspAction : public CastBuffSpellAction
+	{
+	public:
+		CastNaturesGraspAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "nature's grasp") {}
+	};
+
+	class CastHibernateAction : public CastSpellAction
+	{
+	public:
+		CastHibernateAction(PlayerbotAI* ai) : CastSpellAction(ai, "hibernate") {}
+	};
+
+	class CastCurePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCurePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure poison") {}
+	};
+
+    class CastCurePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCurePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+	class CastAbolishPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastAbolishPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish poison") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish poison", DISPEL_POISON) {}
+
+        virtual NextAction** getAlternatives();
+    };
+
+    class CastBarskinAction : public CastBuffSpellAction
+    {
+    public:
+        CastBarskinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "barskin") {}
+    };
+
+    class CastInnervateAction : public CastSpellAction
+    {
+    public:
+        CastInnervateAction(PlayerbotAI* ai) : CastSpellAction(ai, "innervate") {}
+
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastTranquilityAction : public CastAoeHealSpellAction
+    {
+    public:
+        CastTranquilityAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "tranquility") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
new file mode 100644
index 0000000..65c9fc9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.cpp
@@ -0,0 +1,258 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidActions.h"
+#include "DruidAiObjectContext.h"
+#include "BearTankDruidStrategy.h"
+#include "CatDpsDruidStrategy.h"
+#include "CasterDruidStrategy.h"
+#include "GenericDruidNonCombatStrategy.h"
+#include "../NamedObjectContext.h"
+#include "DruidTriggers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &druid::StrategyFactoryInternal::nc;
+                creators["cat aoe"] = &druid::StrategyFactoryInternal::cat_aoe;
+                creators["caster aoe"] = &druid::StrategyFactoryInternal::caster_aoe;
+                creators["caster debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+                creators["dps debuff"] = &druid::StrategyFactoryInternal::caster_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericDruidNonCombatStrategy(ai); }
+            static Strategy* cat_aoe(PlayerbotAI* ai) { return new CatAoeDruidStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterDruidAoeStrategy(ai); }
+            static Strategy* caster_debuff(PlayerbotAI* ai) { return new CasterDruidDebuffStrategy(ai); }
+        };
+
+        class DruidStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            DruidStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bear"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["tank"] = &druid::DruidStrategyFactoryInternal::bear;
+                creators["cat"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["caster"] = &druid::DruidStrategyFactoryInternal::caster;
+                creators["dps"] = &druid::DruidStrategyFactoryInternal::cat;
+                creators["heal"] = &druid::DruidStrategyFactoryInternal::heal;
+            }
+
+        private:
+            static Strategy* bear(PlayerbotAI* ai) { return new BearTankDruidStrategy(ai); }
+            static Strategy* cat(PlayerbotAI* ai) { return new CatDpsDruidStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterDruidStrategy(ai); }
+            static Strategy* heal(PlayerbotAI* ai) { return new HealDruidStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["thorns"] = &TriggerFactoryInternal::Thorns;
+                creators["bash"] = &TriggerFactoryInternal::bash;
+                creators["faerie fire (feral)"] = &TriggerFactoryInternal::faerie_fire_feral;
+                creators["faerie fire"] = &TriggerFactoryInternal::faerie_fire;
+                creators["insect swarm"] = &TriggerFactoryInternal::insect_swarm;
+                creators["moonfire"] = &TriggerFactoryInternal::moonfire;
+                creators["nature's grasp"] = &TriggerFactoryInternal::natures_grasp;
+                creators["tiger's fury"] = &TriggerFactoryInternal::tigers_fury;
+                creators["rake"] = &TriggerFactoryInternal::rake;
+                creators["mark of the wild"] = &TriggerFactoryInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &TriggerFactoryInternal::mark_of_the_wild_on_party;
+                creators["cure poison"] = &TriggerFactoryInternal::cure_poison;
+                creators["party member cure poison"] = &TriggerFactoryInternal::party_member_cure_poison;
+                creators["entangling roots"] = &TriggerFactoryInternal::entangling_roots;
+                creators["bear form"] = &TriggerFactoryInternal::bear_form;
+                creators["cat form"] = &TriggerFactoryInternal::cat_form;
+                creators["tree form"] = &TriggerFactoryInternal::tree_form;
+                creators["eclipse (solar)"] = &TriggerFactoryInternal::eclipse_solar;
+                creators["eclipse (lunar)"] = &TriggerFactoryInternal::eclipse_lunar;
+                creators["bash on enemy healer"] = &TriggerFactoryInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* eclipse_solar(PlayerbotAI* ai) { return new EclipseSolarTrigger(ai); }
+            static Trigger* eclipse_lunar(PlayerbotAI* ai) { return new EclipseLunarTrigger(ai); }
+            static Trigger* Thorns(PlayerbotAI* ai) { return new ThornsTrigger(ai); }
+            static Trigger* bash(PlayerbotAI* ai) { return new BashInterruptSpellTrigger(ai); }
+            static Trigger* faerie_fire_feral(PlayerbotAI* ai) { return new FaerieFireFeralTrigger(ai); }
+            static Trigger* insect_swarm(PlayerbotAI* ai) { return new InsectSwarmTrigger(ai); }
+            static Trigger* moonfire(PlayerbotAI* ai) { return new MoonfireTrigger(ai); }
+            static Trigger* faerie_fire(PlayerbotAI* ai) { return new FaerieFireTrigger(ai); }
+            static Trigger* natures_grasp(PlayerbotAI* ai) { return new NaturesGraspTrigger(ai); }
+            static Trigger* tigers_fury(PlayerbotAI* ai) { return new TigersFuryTrigger(ai); }
+            static Trigger* rake(PlayerbotAI* ai) { return new RakeTrigger(ai); }
+            static Trigger* mark_of_the_wild(PlayerbotAI* ai) { return new MarkOfTheWildTrigger(ai); }
+            static Trigger* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new MarkOfTheWildOnPartyTrigger(ai); }
+            static Trigger* cure_poison(PlayerbotAI* ai) { return new CurePoisonTrigger(ai); }
+            static Trigger* party_member_cure_poison(PlayerbotAI* ai) { return new PartyMemberCurePoisonTrigger(ai); }
+            static Trigger* entangling_roots(PlayerbotAI* ai) { return new EntanglingRootsTrigger(ai); }
+            static Trigger* bear_form(PlayerbotAI* ai) { return new BearFormTrigger(ai); }
+            static Trigger* cat_form(PlayerbotAI* ai) { return new CatFormTrigger(ai); }
+            static Trigger* tree_form(PlayerbotAI* ai) { return new TreeFormTrigger(ai); }
+            static Trigger* bash_on_enemy_healer(PlayerbotAI* ai) { return new BashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace druid
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["feral charge - bear"] = &AiObjectContextInternal::feral_charge_bear;
+                creators["feral charge - cat"] = &AiObjectContextInternal::feral_charge_cat;
+                creators["swipe (bear)"] = &AiObjectContextInternal::swipe_bear;
+                creators["faerie fire (feral)"] = &AiObjectContextInternal::faerie_fire_feral;
+                creators["faerie fire"] = &AiObjectContextInternal::faerie_fire;
+                creators["bear form"] = &AiObjectContextInternal::bear_form;
+                creators["dire bear form"] = &AiObjectContextInternal::dire_bear_form;
+                creators["moonkin form"] = &AiObjectContextInternal::moonkin_form;
+                creators["cat form"] = &AiObjectContextInternal::cat_form;
+                creators["tree form"] = &AiObjectContextInternal::tree_form;
+                creators["caster form"] = &AiObjectContextInternal::caster_form;
+                creators["mangle (bear)"] = &AiObjectContextInternal::mangle_bear;
+                creators["maul"] = &AiObjectContextInternal::maul;
+                creators["bash"] = &AiObjectContextInternal::bash;
+                creators["swipe"] = &AiObjectContextInternal::swipe;
+                creators["growl"] = &AiObjectContextInternal::growl;
+                creators["demoralizing roar"] = &AiObjectContextInternal::demoralizing_roar;
+                creators["hibernate"] = &AiObjectContextInternal::hibernate;
+                creators["entangling roots"] = &AiObjectContextInternal::entangling_roots;
+                creators["entangling roots on cc"] = &AiObjectContextInternal::entangling_roots_on_cc;
+                creators["wrath"] = &AiObjectContextInternal::wrath;
+                creators["starfall"] = &AiObjectContextInternal::starfall;
+                creators["insect swarm"] = &AiObjectContextInternal::insect_swarm;
+                creators["moonfire"] = &AiObjectContextInternal::moonfire;
+                creators["starfire"] = &AiObjectContextInternal::starfire;
+                creators["nature's grasp"] = &AiObjectContextInternal::natures_grasp;
+                creators["claw"] = &AiObjectContextInternal::claw;
+                creators["mangle (cat)"] = &AiObjectContextInternal::mangle_cat;
+                creators["swipe (cat)"] = &AiObjectContextInternal::swipe_cat;
+                creators["rake"] = &AiObjectContextInternal::rake;
+                creators["ferocious bite"] = &AiObjectContextInternal::ferocious_bite;
+                creators["rip"] = &AiObjectContextInternal::rip;
+                creators["cower"] = &AiObjectContextInternal::cower;
+                creators["survival instincts"] = &AiObjectContextInternal::survival_instincts;
+                creators["thorns"] = &AiObjectContextInternal::thorns;
+                creators["cure poison"] = &AiObjectContextInternal::cure_poison;
+                creators["cure poison on party"] = &AiObjectContextInternal::cure_poison_on_party;
+                creators["abolish poison"] = &AiObjectContextInternal::abolish_poison;
+                creators["abolish poison on party"] = &AiObjectContextInternal::abolish_poison_on_party;
+                creators["berserk"] = &AiObjectContextInternal::berserk;
+                creators["tiger's fury"] = &AiObjectContextInternal::tigers_fury;
+                creators["mark of the wild"] = &AiObjectContextInternal::mark_of_the_wild;
+                creators["mark of the wild on party"] = &AiObjectContextInternal::mark_of_the_wild_on_party;
+                creators["regrowth"] = &AiObjectContextInternal::regrowth;
+                creators["rejuvenation"] = &AiObjectContextInternal::rejuvenation;
+                creators["healing touch"] = &AiObjectContextInternal::healing_touch;
+                creators["regrowth on party"] = &AiObjectContextInternal::regrowth_on_party;
+                creators["rejuvenation on party"] = &AiObjectContextInternal::rejuvenation_on_party;
+                creators["healing touch on party"] = &AiObjectContextInternal::healing_touch_on_party;
+                creators["rebirth"] = &AiObjectContextInternal::rebirth;
+                creators["revive"] = &AiObjectContextInternal::revive;
+                creators["barskin"] = &AiObjectContextInternal::barskin;
+                creators["lacerate"] = &AiObjectContextInternal::lacerate;
+                creators["hurricane"] = &AiObjectContextInternal::hurricane;
+                creators["innervate"] = &AiObjectContextInternal::innervate;
+                creators["tranquility"] = &AiObjectContextInternal::tranquility;
+                creators["bash on enemy healer"] = &AiObjectContextInternal::bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* tranquility(PlayerbotAI* ai) { return new CastTranquilityAction(ai); }
+            static Action* feral_charge_bear(PlayerbotAI* ai) { return new CastFeralChargeBearAction(ai); }
+            static Action* feral_charge_cat(PlayerbotAI* ai) { return new CastFeralChargeCatAction(ai); }
+            static Action* swipe_bear(PlayerbotAI* ai) { return new CastSwipeBearAction(ai); }
+            static Action* faerie_fire_feral(PlayerbotAI* ai) { return new CastFaerieFireFeralAction(ai); }
+            static Action* faerie_fire(PlayerbotAI* ai) { return new CastFaerieFireAction(ai); }
+            static Action* bear_form(PlayerbotAI* ai) { return new CastBearFormAction(ai); }
+            static Action* dire_bear_form(PlayerbotAI* ai) { return new CastDireBearFormAction(ai); }
+            static Action* cat_form(PlayerbotAI* ai) { return new CastCatFormAction(ai); }
+            static Action* tree_form(PlayerbotAI* ai) { return new CastTreeFormAction(ai); }
+            static Action* caster_form(PlayerbotAI* ai) { return new CastCasterFormAction(ai); }
+            static Action* mangle_bear(PlayerbotAI* ai) { return new CastMangleBearAction(ai); }
+            static Action* maul(PlayerbotAI* ai) { return new CastMaulAction(ai); }
+            static Action* bash(PlayerbotAI* ai) { return new CastBashAction(ai); }
+            static Action* swipe(PlayerbotAI* ai) { return new CastSwipeAction(ai); }
+            static Action* growl(PlayerbotAI* ai) { return new CastGrowlAction(ai); }
+            static Action* demoralizing_roar(PlayerbotAI* ai) { return new CastDemoralizingRoarAction(ai); }
+            static Action* moonkin_form(PlayerbotAI* ai) { return new CastMoonkinFormAction(ai); }
+            static Action* hibernate(PlayerbotAI* ai) { return new CastHibernateAction(ai); }
+            static Action* entangling_roots(PlayerbotAI* ai) { return new CastEntanglingRootsAction(ai); }
+            static Action* entangling_roots_on_cc(PlayerbotAI* ai) { return new CastEntanglingRootsCcAction(ai); }
+            static Action* wrath(PlayerbotAI* ai) { return new CastWrathAction(ai); }
+            static Action* starfall(PlayerbotAI* ai) { return new CastStarfallAction(ai); }
+            static Action* insect_swarm(PlayerbotAI* ai) { return new CastInsectSwarmAction(ai); }
+            static Action* moonfire(PlayerbotAI* ai) { return new CastMoonfireAction(ai); }
+            static Action* starfire(PlayerbotAI* ai) { return new CastStarfireAction(ai); }
+            static Action* natures_grasp(PlayerbotAI* ai) { return new CastNaturesGraspAction(ai); }
+            static Action* claw(PlayerbotAI* ai) { return new CastClawAction(ai); }
+            static Action* mangle_cat(PlayerbotAI* ai) { return new CastMangleCatAction(ai); }
+            static Action* swipe_cat(PlayerbotAI* ai) { return new CastSwipeCatAction(ai); }
+            static Action* rake(PlayerbotAI* ai) { return new CastRakeAction(ai); }
+            static Action* ferocious_bite(PlayerbotAI* ai) { return new CastFerociousBiteAction(ai); }
+            static Action* rip(PlayerbotAI* ai) { return new CastRipAction(ai); }
+            static Action* cower(PlayerbotAI* ai) { return new CastCowerAction(ai); }
+            static Action* survival_instincts(PlayerbotAI* ai) { return new CastSurvivalInstinctsAction(ai); }
+            static Action* thorns(PlayerbotAI* ai) { return new CastThornsAction(ai); }
+            static Action* cure_poison(PlayerbotAI* ai) { return new CastCurePoisonAction(ai); }
+            static Action* cure_poison_on_party(PlayerbotAI* ai) { return new CastCurePoisonOnPartyAction(ai); }
+            static Action* abolish_poison(PlayerbotAI* ai) { return new CastAbolishPoisonAction(ai); }
+            static Action* abolish_poison_on_party(PlayerbotAI* ai) { return new CastAbolishPoisonOnPartyAction(ai); }
+            static Action* berserk(PlayerbotAI* ai) { return new CastBerserkAction(ai); }
+            static Action* tigers_fury(PlayerbotAI* ai) { return new CastTigersFuryAction(ai); }
+            static Action* mark_of_the_wild(PlayerbotAI* ai) { return new CastMarkOfTheWildAction(ai); }
+            static Action* mark_of_the_wild_on_party(PlayerbotAI* ai) { return new CastMarkOfTheWildOnPartyAction(ai); }
+            static Action* regrowth(PlayerbotAI* ai) { return new CastRegrowthAction(ai); }
+            static Action* rejuvenation(PlayerbotAI* ai) { return new CastRejuvenationAction(ai); }
+            static Action* healing_touch(PlayerbotAI* ai) { return new CastHealingTouchAction(ai); }
+            static Action* regrowth_on_party(PlayerbotAI* ai) { return new CastRegrowthOnPartyAction(ai); }
+            static Action* rejuvenation_on_party(PlayerbotAI* ai) { return new CastRejuvenationOnPartyAction(ai); }
+            static Action* healing_touch_on_party(PlayerbotAI* ai) { return new CastHealingTouchOnPartyAction(ai); }
+            static Action* rebirth(PlayerbotAI* ai) { return new CastRebirthAction(ai); }
+            static Action* revive(PlayerbotAI* ai) { return new CastReviveAction(ai); }
+            static Action* barskin(PlayerbotAI* ai) { return new CastBarskinAction(ai); }
+            static Action* lacerate(PlayerbotAI* ai) { return new CastLacerateAction(ai); }
+            static Action* hurricane(PlayerbotAI* ai) { return new CastHurricaneAction(ai); }
+            static Action* innervate(PlayerbotAI* ai) { return new CastInnervateAction(ai); }
+            static Action* bash_on_enemy_healer(PlayerbotAI* ai) { return new CastBashOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+DruidAiObjectContext::DruidAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::druid::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::druid::DruidStrategyFactoryInternal());
+    actionContexts.Add(new ai::druid::AiObjectContextInternal());
+    triggerContexts.Add(new ai::druid::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
new file mode 100644
index 0000000..b5d7a2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class DruidAiObjectContext : public AiObjectContext
+    {
+    public:
+        DruidAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidBearActions.h b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
new file mode 100644
index 0000000..81bc8ab
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidBearActions.h
@@ -0,0 +1,64 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeBearAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeBearAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - bear", 1.5f) {}
+	};
+
+	class CastGrowlAction : public CastSpellAction
+	{
+	public:
+		CastGrowlAction(PlayerbotAI* ai) : CastSpellAction(ai, "growl") {}
+	};
+
+	class CastMaulAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMaulAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "maul") {}
+		virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "rage", "self target") >= 45; }
+	};
+
+	class CastBashAction : public CastMeleeSpellAction
+	{
+	public:
+		CastBashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bash") {}
+	};
+
+	class CastSwipeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe") {}
+	};
+
+	class CastDemoralizingRoarAction : public CastDebuffSpellAction
+	{
+	public:
+		CastDemoralizingRoarAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing roar") {}
+	};
+
+	class CastMangleBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastMangleBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (bear)") {}
+	};
+
+	class CastSwipeBearAction : public CastMeleeSpellAction
+	{
+	public:
+		CastSwipeBearAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (bear)") {}
+	};
+
+    class CastLacerateAction : public CastMeleeSpellAction
+    {
+    public:
+        CastLacerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lacerate") {}
+    };
+
+    class CastBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidCatActions.h b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
new file mode 100644
index 0000000..90f50c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidCatActions.h
@@ -0,0 +1,69 @@
+#pragma once
+
+namespace ai {
+	class CastFeralChargeCatAction : public CastReachTargetSpellAction
+	{
+	public:
+		CastFeralChargeCatAction(PlayerbotAI* ai) : CastReachTargetSpellAction(ai, "feral charge - cat", 1.5f) {}
+	};
+
+	class CastCowerAction : public CastBuffSpellAction
+	{
+	public:
+		CastCowerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cower") {}
+	};
+
+
+	class CastBerserkAction : public CastBuffSpellAction
+	{
+	public:
+		CastBerserkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserk") {}
+	};
+
+	class CastTigersFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastTigersFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tiger's fury") {}
+	};
+
+	class CastRakeAction : public CastDebuffSpellAction
+	{
+	public:
+		CastRakeAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "rake") {}
+
+        virtual NextAction** getPrerequisites()
+        {
+            return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+        }
+	};
+
+
+	class CastClawAction : public CastMeleeSpellAction {
+	public:
+		CastClawAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "claw") {}
+	};
+
+	class CastMangleCatAction : public CastMeleeSpellAction {
+	public:
+		CastMangleCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mangle (cat)") {}
+	};
+
+	class CastSwipeCatAction : public CastMeleeSpellAction {
+	public:
+		CastSwipeCatAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "swipe (cat)") {}
+	};
+
+	class CastFerociousBiteAction : public CastMeleeSpellAction {
+	public:
+		CastFerociousBiteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "ferocious bite") {}
+	};
+
+
+	class CastRipAction : public CastMeleeSpellAction {
+	public:
+		CastRipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rip") {}
+	};
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
new file mode 100644
index 0000000..d273c7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "DruidActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidMultipliers.h b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
new file mode 100644
index 0000000..746c635
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidShapeshiftActions.h
@@ -0,0 +1,53 @@
+#pragma once
+
+namespace ai {
+	class CastBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bear form") {} 
+
+        virtual bool isPossible() {
+			return CastBuffSpellAction::isPossible() && !ai->HasAura("dire bear form", GetTarget());
+		}
+        virtual bool isUseful() {
+			return CastBuffSpellAction::isUseful() && !ai->HasAura("dire bear form", GetTarget());
+		}
+	};
+
+	class CastDireBearFormAction : public CastBuffSpellAction { 
+	public: 
+		CastDireBearFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "dire bear form") {} 
+        
+        virtual NextAction** getAlternatives() {
+			return NextAction::merge(NextAction::array(0, new NextAction("bear form"), NULL), CastSpellAction::getAlternatives());
+		}
+	};
+
+	class CastCatFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCatFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "cat form") {} 
+	};
+
+	class CastTreeFormAction : public CastBuffSpellAction {
+	public:
+		CastTreeFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "tree of life") {}
+	};
+
+	class CastMoonkinFormAction : public CastBuffSpellAction { 
+	public: 
+		CastMoonkinFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "moonkin form") {} 
+	};
+
+	class CastCasterFormAction : public CastBuffSpellAction { 
+	public: 
+		CastCasterFormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "caster form") {} 
+
+		virtual bool isUseful() {
+			return ai->HasAnyAuraOf(GetTarget(), "dire bear form", "bear form", "cat form", "travel form", "aquatic form", 
+				"flight form", "swift flight form", "moonkin form", "tree of life", NULL);
+		}
+		virtual bool isPossible() { return true; }
+		
+		virtual bool Execute(Event event);
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
new file mode 100644
index 0000000..963c9fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidTriggers.h"
+#include "DruidActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/druid/DruidTriggers.h b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
new file mode 100644
index 0000000..1c0d4d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/DruidTriggers.h
@@ -0,0 +1,127 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai {
+    class MarkOfTheWildOnPartyTrigger : public BuffOnPartyTrigger
+    {
+    public:
+        MarkOfTheWildOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "mark of the wild") {}
+    };
+
+    class MarkOfTheWildTrigger : public BuffTrigger
+    {
+    public:
+        MarkOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mark of the wild") {}
+    };
+
+    class ThornsTrigger : public BuffTrigger
+    {
+    public:
+        ThornsTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "thorns") {}
+    };
+
+    class RakeTrigger : public DebuffTrigger
+    {
+    public:
+        RakeTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rake") {}
+    };
+
+    class InsectSwarmTrigger : public DebuffTrigger
+    {
+    public:
+        InsectSwarmTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "insect swarm") {}
+    };
+
+    class MoonfireTrigger : public DebuffTrigger
+    {
+    public:
+        MoonfireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "moonfire") {}
+    };
+
+    class FaerieFireTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire") {}
+    };
+
+    class FaerieFireFeralTrigger : public DebuffTrigger
+    {
+    public:
+        FaerieFireFeralTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "faerie fire (feral)") {}
+    };
+
+    class BashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        BashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "bash") {}
+    };
+
+    class TigersFuryTrigger : public BoostTrigger
+    {
+    public:
+        TigersFuryTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "tiger's fury") {}
+    };
+
+    class NaturesGraspTrigger : public BoostTrigger
+    {
+    public:
+        NaturesGraspTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "nature's grasp") {}
+    };
+
+    class EntanglingRootsTrigger : public HasCcTargetTrigger
+    {
+    public:
+        EntanglingRootsTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "entangling roots") {}
+    };
+
+    class CurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCurePoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCurePoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure poison", DISPEL_POISON) {}
+    };
+
+    class BearFormTrigger : public BuffTrigger
+    {
+    public:
+        BearFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "bear form") {}
+        virtual bool IsActive() { return !ai->HasAnyAuraOf(bot, "bear form", "dire bear form", NULL); }
+    };
+
+    class TreeFormTrigger : public BuffTrigger
+    {
+    public:
+        TreeFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "tree of life") {}
+        virtual bool IsActive() { return !ai->HasAura("tree of life", bot); }
+    };
+
+    class CatFormTrigger : public BuffTrigger
+    {
+    public:
+        CatFormTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "cat form") {}
+        virtual bool IsActive() { return !ai->HasAura("cat form", bot); }
+    };
+
+    class EclipseSolarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseSolarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (solar)") {}
+    };
+
+    class EclipseLunarTrigger : public HasAuraTrigger
+    {
+    public:
+        EclipseLunarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "eclipse (lunar)") {}
+    };
+
+    class BashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        BashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
new file mode 100644
index 0000000..1956573
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FeralDruidStrategy.h"
+
+using namespace ai;
+
+class FeralDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    FeralDruidStrategyActionNodeFactory()
+    {
+        creators["survival instincts"] = &survival_instincts;
+        creators["thorns"] = &thorns;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+    }
+private:
+    static ActionNode* survival_instincts(PlayerbotAI* ai)
+    {
+        return new ActionNode ("survival instincts",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("barskin"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* thorns(PlayerbotAI* ai)
+    {
+        return new ActionNode ("thorns",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+};
+
+FeralDruidStrategy::FeralDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new FeralDruidStrategyActionNodeFactory());
+    actionNodeFactories.Add(new ShapeshiftDruidStrategyActionNodeFactory());
+}
+
+void FeralDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("survival instincts", ACTION_EMERGENCY + 1), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
new file mode 100644
index 0000000..0ee4a8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/FeralDruidStrategy.h
@@ -0,0 +1,75 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+namespace ai
+{
+    class ShapeshiftDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShapeshiftDruidStrategyActionNodeFactory()
+        {
+            creators["rejuvenation"] = &rejuvenation;
+            creators["regrowth"] = &regrowth;
+            creators["healing touch"] = &healing_touch;
+            creators["rejuvenation on party"] = &rejuvenation_on_party;
+            creators["regrowth on party"] = &regrowth_on_party;
+            creators["healing touch on party"] = &healing_touch_on_party;
+        }
+    private:
+        static ActionNode* regrowth(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* regrowth_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("regrowth on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("healing touch on party"), NULL),
+                /*C*/ NextAction::array(0, new NextAction("melee", 10.0f), NULL));
+        }
+        static ActionNode* rejuvenation_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("rejuvenation on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* healing_touch_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("healing touch on party",
+                /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+    };
+
+    class FeralDruidStrategy : public GenericDruidStrategy
+    {
+    protected:
+        FeralDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
new file mode 100644
index 0000000..e6377da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "GenericDruidNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericDruidNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidNonCombatStrategyActionNodeFactory()
+    {
+        creators["mark of the wild"] = &mark_of_the_wild;
+        creators["mark of the wild on party"] = &mark_of_the_wild_on_party;
+        creators["innervate"] = &innervate;
+    }
+private:
+    static ActionNode* mark_of_the_wild(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mark_of_the_wild_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mark of the wild on party",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drink"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidNonCombatStrategy::GenericDruidNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidNonCombatStrategyActionNodeFactory());
+}
+
+void GenericDruidNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild",
+        NextAction::array(0, new NextAction("mark of the wild", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mark of the wild on party",
+        NextAction::array(0, new NextAction("mark of the wild on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("revive", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
new file mode 100644
index 0000000..82cba15
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericDruidNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericDruidNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
new file mode 100644
index 0000000..e4f1921
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.cpp
@@ -0,0 +1,132 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericDruidStrategy.h"
+#include "DruidAiObjectContext.h"
+
+using namespace ai;
+
+class GenericDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericDruidStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["caster form"] = &caster_form;
+        creators["cure poison"] = &cure_poison;
+        creators["cure poison on party"] = &cure_poison_on_party;
+        creators["abolish poison"] = &abolish_poison;
+        creators["abolish poison on party"] = &abolish_poison_on_party;
+        creators["rebirth"] = &rebirth;
+        creators["entangling roots on cc"] = &entangling_roots_on_cc;
+        creators["innervate"] = &innervate;
+    }
+
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* caster_form(PlayerbotAI* ai)
+    {
+        return new ActionNode ("caster form",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* cure_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("cure poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* abolish_poison_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("abolish poison on party",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rebirth(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rebirth",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* entangling_roots_on_cc(PlayerbotAI* ai)
+    {
+        return new ActionNode ("entangling roots on cc",
+            /*P*/ NextAction::array(0, new NextAction("caster form"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* innervate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("innervate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericDruidStrategy::GenericDruidStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericDruidStrategyActionNodeFactory());
+}
+
+void GenericDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_CRITICAL_HEAL + 2), new NextAction("healing touch", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0,  new NextAction("regrowth on party", ACTION_CRITICAL_HEAL + 1), new NextAction("healing touch on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure poison",
+        NextAction::array(0, new NextAction("abolish poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure poison",
+        NextAction::array(0, new NextAction("abolish poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("rebirth", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("innervate", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
new file mode 100644
index 0000000..dc12a85
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/GenericDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericDruidStrategy : public CombatStrategy
+    {
+    protected:
+        GenericDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
new file mode 100644
index 0000000..5b1cfb3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.cpp
@@ -0,0 +1,57 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DruidMultipliers.h"
+#include "HealDruidStrategy.h"
+
+using namespace ai;
+
+class HealDruidStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealDruidStrategyActionNodeFactory()
+    {
+    }
+private:
+};
+
+HealDruidStrategy::HealDruidStrategy(PlayerbotAI* ai) : GenericDruidStrategy(ai)
+{
+    actionNodeFactories.Add(new HealDruidStrategyActionNodeFactory());
+}
+
+void HealDruidStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericDruidStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tree form",
+        NextAction::array(0, new NextAction("tree form", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("regrowth", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("regrowth on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("rejuvenation", ACTION_LIGHT_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("rejuvenation on party", ACTION_LIGHT_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("tranquility", ACTION_MEDIUM_HEAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "entangling roots",
+        NextAction::array(0, new NextAction("entangling roots on cc", ACTION_HIGH + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
new file mode 100644
index 0000000..a0440ba
--- /dev/null
+++ b/src/plugins/playerbot/strategy/druid/HealDruidStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericDruidStrategy.h"
+
+namespace ai
+{
+    class HealDruidStrategy : public GenericDruidStrategy
+    {
+    public:
+        HealDruidStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+        virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
new file mode 100644
index 0000000..43db065
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackEnemyPlayersStrategy.h"
+
+using namespace ai;
+
+void AttackEnemyPlayersStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy player is attacking",
+        NextAction::array(0, new NextAction("attack enemy player", 61.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
new file mode 100644
index 0000000..cd9ce7c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackEnemyPlayersStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackEnemyPlayersStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackEnemyPlayersStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "pvp"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
new file mode 100644
index 0000000..d33bb74
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackRtiStrategy.h"
+
+using namespace ai;
+
+
+void AttackRtiStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack rti target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
new file mode 100644
index 0000000..ad9662a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackRtiStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackRtiStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackRtiStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack rti"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
new file mode 100644
index 0000000..d3a832a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackWeakStrategy.h"
+
+using namespace ai;
+
+void AttackWeakStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "not least hp target active",
+        NextAction::array(0, new NextAction("attack least hp target", 60.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
new file mode 100644
index 0000000..c6c20c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/AttackWeakStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class AttackWeakStrategy : public NonCombatStrategy
+    {
+    public:
+        AttackWeakStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "attack weak"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
new file mode 100644
index 0000000..7d1a483
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.cpp
@@ -0,0 +1,42 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CastTimeStrategy.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float CastTimeMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    string name = action->getName();
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastSpellAction*>(action))
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", name);
+        const SpellInfo* const pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            return 1.0f;
+
+        Spell *spell = new Spell(bot, pSpellInfo, TRIGGERED_NONE);
+        int32 castTime = spell->GetCastTime();
+        delete spell;
+
+        if (spellId && castTime >= 3000)
+            return 0.0f;
+        else if (spellId && castTime >= 1500)
+            return 0.5f;
+    }
+
+    return 1.0f;
+}
+
+
+void CastTimeStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new CastTimeMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
new file mode 100644
index 0000000..a483fc0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CastTimeStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+
+    class CastTimeMultiplier : public Multiplier
+    {
+    public:
+        CastTimeMultiplier(PlayerbotAI* ai) : Multiplier(ai, "cast time") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class CastTimeStrategy : public Strategy
+    {
+    public:
+        CastTimeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "cast time"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
new file mode 100644
index 0000000..991551e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.cpp
@@ -0,0 +1,177 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ChatCommandHandlerStrategy.h"
+
+using namespace ai;
+
+class ChatCommandActionNodeFactoryInternal : public NamedObjectFactory<ActionNode>
+{
+public:
+    ChatCommandActionNodeFactoryInternal()
+    {
+        creators["tank attack chat shortcut"] = &tank_attack_chat_shortcut;
+    }
+
+private:
+    static ActionNode* tank_attack_chat_shortcut(PlayerbotAI* ai)
+    {
+        return new ActionNode ("tank attack chat shortcut",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("attack my target", 100.0f), NULL));
+    }
+};
+
+void ChatCommandHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "rep",
+        NextAction::array(0, new NextAction("reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "q",
+        NextAction::array(0,
+            new NextAction("query quest", relevance),
+            new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "add all loot",
+        NextAction::array(0, new NextAction("add all loot", relevance), new NextAction("loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "u",
+        NextAction::array(0, new NextAction("use", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "c",
+        NextAction::array(0, new NextAction("item count", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "e",
+        NextAction::array(0, new NextAction("equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ue",
+        NextAction::array(0, new NextAction("unequip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "t",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "nt",
+        NextAction::array(0, new NextAction("trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "s",
+        NextAction::array(0, new NextAction("sell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "b",
+        NextAction::array(0, new NextAction("buy", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "r",
+        NextAction::array(0, new NextAction("reward", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attack",
+        NextAction::array(0, new NextAction("attack my target", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "accept",
+        NextAction::array(0, new NextAction("accept quest", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "follow",
+        NextAction::array(0, new NextAction("follow chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "stay",
+        NextAction::array(0, new NextAction("stay chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flee",
+        NextAction::array(0, new NextAction("flee chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "tank attack",
+        NextAction::array(0, new NextAction("tank attack chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "grind",
+        NextAction::array(0, new NextAction("grind chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "talk",
+        NextAction::array(0, new NextAction("gossip hello", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cast",
+        NextAction::array(0, new NextAction("cast custom spell", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "revive",
+        NextAction::array(0, new NextAction("spirit healer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "runaway",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "warning",
+        NextAction::array(0, new NextAction("runaway chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "max dps",
+        NextAction::array(0, new NextAction("max dps chat shortcut", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "attackers",
+        NextAction::array(0, new NextAction("tell attackers", relevance), NULL)));
+}
+
+
+
+ChatCommandHandlerStrategy::ChatCommandHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    actionNodeFactories.Add(new ChatCommandActionNodeFactoryInternal());
+
+    supported.push_back("quests");
+    supported.push_back("stats");
+    supported.push_back("leave");
+    supported.push_back("reputation");
+    supported.push_back("log");
+    supported.push_back("los");
+    supported.push_back("drop");
+    supported.push_back("ll");
+    supported.push_back("release");
+    supported.push_back("teleport");
+    supported.push_back("taxi");
+    supported.push_back("repair");
+    supported.push_back("talents");
+    supported.push_back("spells");
+    supported.push_back("co");
+    supported.push_back("nc");
+    supported.push_back("dead");
+    supported.push_back("trainer");
+    supported.push_back("chat");
+    supported.push_back("home");
+    supported.push_back("destroy");
+    supported.push_back("reset ai");
+    supported.push_back("emote");
+    supported.push_back("buff");
+    supported.push_back("help");
+    supported.push_back("gb");
+    supported.push_back("bank");
+    supported.push_back("invite");
+    supported.push_back("spell");
+    supported.push_back("rti");
+    supported.push_back("position");
+    supported.push_back("summon");
+    supported.push_back("who");
+    supported.push_back("save mana");
+    supported.push_back("formation");
+}
diff --git a/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
new file mode 100644
index 0000000..c8c93b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ChatCommandHandlerStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class ChatCommandHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        ChatCommandHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "chat"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
new file mode 100644
index 0000000..4ef95b1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CombatStrategy.h"
+
+using namespace ai;
+
+void CombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "invalid target",
+        NextAction::array(0, new NextAction("drop target", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/CombatStrategy.h b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
new file mode 100644
index 0000000..475922f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/CombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+namespace ai
+{
+    class CombatStrategy : public Strategy
+    {
+    public:
+        CombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
new file mode 100644
index 0000000..b1c13fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ConserveManaStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+#include "../values/LastSpellCastValue.h"
+
+using namespace ai;
+
+float ConserveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL) return 1.0f;
+
+    uint8 health = AI_VALUE2(uint8, "health", "self target");
+    uint8 targetHealth = AI_VALUE2(uint8, "health", "current target");
+    uint8 mana = AI_VALUE2(uint8, "mana", "self target");
+    bool hasMana = AI_VALUE2(bool, "has mana", "self target");
+    bool mediumMana = hasMana && mana < sPlayerbotAIConfig.mediumMana;
+
+    string name = action->getName();
+
+    if (health < sPlayerbotAIConfig.lowHealth)
+        return 1.0f;
+
+    if (name == "melee" || name == "reach melee" || name == "reach spell")
+        return 1.0f;
+
+    if (mediumMana && dynamic_cast<CastBuffSpellAction*>(action))
+        return 0.0f;
+
+    if (action->GetTarget() != AI_VALUE(Unit*, "current target"))
+        return 1.0f;
+
+    if (AI_VALUE(uint8, "balance") <= 50)
+        return 1.0f;
+
+    if (targetHealth < sPlayerbotAIConfig.lowHealth && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    if (mediumMana && dynamic_cast<CastDebuffSpellAction*>(action))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+float SaveManaMultiplier::GetValue(Action* action)
+{
+    if (action == NULL)
+        return 1.0f;
+
+    double saveLevel = AI_VALUE(double, "mana save level");
+    if (saveLevel <= 1.0)
+        return 1.0f;
+
+    CastSpellAction* spellAction = dynamic_cast<CastSpellAction*>(action);
+    if (!spellAction)
+        return 1.0f;
+
+    string spell = spellAction->getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    const SpellInfo* const spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo || spellInfo->PowerType != POWER_MANA)
+        return 1.0f;
+
+    int32 cost = spellInfo->ManaCost;
+    if (spellInfo->ManaCostPercentage)
+        cost += spellInfo->ManaCostPercentage * bot->GetCreateMana() / 100;
+
+    uint32 mana = bot->GetMaxPower(POWER_MANA);
+    double percent = (double)cost / (double)mana * 100.0f;
+
+    time_t lastCastTime = AI_VALUE2(time_t, "last spell cast time", spell);
+    if (!lastCastTime)
+        return 1.0f;
+
+    time_t elapsed = time(0) - lastCastTime;
+    if ((double)elapsed < 10 + pow(saveLevel, sqrt(percent)))
+        return 0.0f;
+
+    return 1.0f;
+}
+
+
+void ConserveManaStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ConserveManaMultiplier(ai));
+    multipliers.push_back(new SaveManaMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
new file mode 100644
index 0000000..a206934
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ConserveManaStrategy.h
@@ -0,0 +1,32 @@
+#pragma once
+
+namespace ai
+{
+    class ConserveManaMultiplier : public Multiplier
+    {
+    public:
+        ConserveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "conserve mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class SaveManaMultiplier : public Multiplier
+    {
+    public:
+        SaveManaMultiplier(PlayerbotAI* ai) : Multiplier(ai, "save mana") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ConserveManaStrategy : public Strategy
+    {
+    public:
+        ConserveManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "conserve mana"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
new file mode 100644
index 0000000..1c31adb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "DeadStrategy.h"
+
+using namespace ai;
+
+void DeadStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "dead",
+        NextAction::array(0, new NextAction("revive from corpse", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "resurrect request",
+        NextAction::array(0, new NextAction("accept resurrect", relevance), NULL)));
+}
+
+DeadStrategy::DeadStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DeadStrategy.h b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
new file mode 100644
index 0000000..4008570
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DeadStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DeadStrategy : public PassTroughStrategy
+    {
+    public:
+        DeadStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dead"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
new file mode 100644
index 0000000..40fa703
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAoeStrategy.h"
+
+using namespace ai;
+
+void DpsAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
new file mode 100644
index 0000000..61ac9b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
new file mode 100644
index 0000000..c38860d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsAssistStrategy.h"
+
+using namespace ai;
+
+void DpsAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("dps assist", 50.0f), NULL)));
+}
+
+
+
diff --git a/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
new file mode 100644
index 0000000..4368d7b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DpsAssistStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class DpsAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        DpsAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "dps assist"; }
+		virtual int GetType() { return STRATEGY_TYPE_DPS; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
new file mode 100644
index 0000000..92e9049
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.cpp
@@ -0,0 +1,24 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelStrategy.h"
+
+using namespace ai;
+
+void DuelStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "duel requested",
+        NextAction::array(0, new NextAction("accept duel", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("attack duel opponent", 70.0f), NULL)));
+}
+
+
+
+DuelStrategy::DuelStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/DuelStrategy.h b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
new file mode 100644
index 0000000..5828406
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/DuelStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class DuelStrategy : public PassTroughStrategy
+    {
+    public:
+        DuelStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "duel"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
new file mode 100644
index 0000000..408ecd1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EmoteStrategy.h"
+
+using namespace ai;
+
+
+void EmoteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("emote", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("suggest what to do", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/EmoteStrategy.h b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
new file mode 100644
index 0000000..7acbc70
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/EmoteStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class EmoteStrategy : public Strategy
+    {
+    public:
+        EmoteStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "emote"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
new file mode 100644
index 0000000..4b16bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FleeStrategy.h"
+
+using namespace ai;
+
+void FleeStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "panic",
+        NextAction::array(0, new NextAction("flee", ACTION_EMERGENCY + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+       "critical health",
+       NextAction::array(0, new NextAction("flee", ACTION_MOVE + 9), NULL)));
+
+   triggers.push_back(new TriggerNode(
+       "low mana",
+       NextAction::array(0,  new NextAction("flee", ACTION_MOVE + 9), NULL)));}
+
+void FleeFromAddsStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has nearest adds",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FleeStrategy.h b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
new file mode 100644
index 0000000..4aa96b9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FleeStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class FleeStrategy : public Strategy
+    {
+    public:
+        FleeStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee"; };
+    };
+
+    class FleeFromAddsStrategy : public Strategy
+    {
+    public:
+        FleeFromAddsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "flee from adds"; };
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
new file mode 100644
index 0000000..753811b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "FollowMasterStrategy.h"
+
+using namespace ai;
+
+NextAction** FollowMasterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("follow", 1.0f), NULL);
+}
+
+void FollowMasterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "out of react range",
+        NextAction::array(0, new NextAction("tell out of react range", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
new file mode 100644
index 0000000..a43e330
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/FollowMasterStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class FollowMasterStrategy : public NonCombatStrategy
+    {
+    public:
+        FollowMasterStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "follow"; }
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
new file mode 100644
index 0000000..259cc96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindingStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GrindingStrategy::getDefaultActions()
+{
+    return NULL;
+}
+
+void GrindingStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no target",
+        NextAction::array(0,
+        new NextAction("attack anything", 5.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GrindingStrategy.h b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
new file mode 100644
index 0000000..ce42140
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GrindingStrategy.h
@@ -0,0 +1,20 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GrindingStrategy : public NonCombatStrategy
+    {
+    public:
+        GrindingStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "grind"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
new file mode 100644
index 0000000..301322c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GuardStrategy.h"
+
+using namespace ai;
+
+
+NextAction** GuardStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("guard", 4.0f), NULL);
+}
+
+void GuardStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/GuardStrategy.h b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
new file mode 100644
index 0000000..8705ba3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/GuardStrategy.h
@@ -0,0 +1,19 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class GuardStrategy : public NonCombatStrategy
+    {
+    public:
+        GuardStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "guard"; }
+        NextAction** getDefaultActions();
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
new file mode 100644
index 0000000..e329162
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.cpp
@@ -0,0 +1,16 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "KiteStrategy.h"
+
+using namespace ai;
+
+KiteStrategy::KiteStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+}
+
+void KiteStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "has aggro",
+        NextAction::array(0, new NextAction("runaway", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/KiteStrategy.h b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
new file mode 100644
index 0000000..2436a3d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/KiteStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class KiteStrategy : public Strategy
+    {
+    public:
+        KiteStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "kite"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
new file mode 100644
index 0000000..0701cf5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootNonCombatStrategy.h"
+
+using namespace ai;
+
+void LootNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "loot available",
+        NextAction::array(0, new NextAction("loot", 6.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "far from loot target",
+        NextAction::array(0, new NextAction("move to loot", 7.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "can loot",
+        NextAction::array(0, new NextAction("open loot", 8.0f), NULL)));
+}
+
+void GatherStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("add gathering loot", 2.0f), NULL)));
+}
+
+
diff --git a/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
new file mode 100644
index 0000000..5eecd63
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/LootNonCombatStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+    class LootNonCombatStrategy : public Strategy
+    {
+    public:
+        LootNonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "loot"; }
+    };
+
+    class GatherStrategy : public Strategy
+    {
+    public:
+        GatherStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "gather"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
new file mode 100644
index 0000000..6bc8267
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MeleeCombatStrategy.h"
+
+using namespace ai;
+
+
+void MeleeCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
new file mode 100644
index 0000000..eeeb90a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MeleeCombatStrategy.h
@@ -0,0 +1,16 @@
+#include "CombatStrategy.h"
+#include "../generic/CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MeleeCombatStrategy : public CombatStrategy
+    {
+    public:
+        MeleeCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_MELEE; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
new file mode 100644
index 0000000..c941dd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MoveRandomStrategy.h"
+
+using namespace ai;
+
+void MoveRandomStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "random",
+        NextAction::array(0, new NextAction("move random", 1.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
new file mode 100644
index 0000000..ff453bf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/MoveRandomStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class MoveRandomStrategy : public NonCombatStrategy
+    {
+    public:
+        MoveRandomStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "move random"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
new file mode 100644
index 0000000..38b8227
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.cpp
@@ -0,0 +1,28 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NonCombatStrategy.h"
+
+using namespace ai;
+
+void NonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("check mount state", 1.0f), NULL)));
+}
+
+
+void LfgStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no possible targets",
+        NextAction::array(0, new NextAction("lfg join", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lfg proposal active",
+        NextAction::array(0, new NextAction("lfg accept", 1.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
new file mode 100644
index 0000000..5216679
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/NonCombatStrategy.h
@@ -0,0 +1,21 @@
+#pragma once
+
+namespace ai
+{
+    class NonCombatStrategy : public Strategy
+    {
+    public:
+        NonCombatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class LfgStrategy : public Strategy
+    {
+    public:
+        LfgStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+		virtual int GetType() { return STRATEGY_TYPE_NONCOMBAT; }
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "lfg"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
new file mode 100644
index 0000000..eddb031
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassTroughStrategy.h
@@ -0,0 +1,26 @@
+#pragma once
+
+namespace ai
+{
+    class PassTroughStrategy : public Strategy
+    {
+    public:
+        PassTroughStrategy(PlayerbotAI* ai, float relevance = 100.0f) : Strategy(ai), relevance(relevance) {}
+
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers)
+        {
+            for (list<string>::iterator i = supported.begin(); i != supported.end(); i++)
+            {
+                string s = i->c_str();
+
+                triggers.push_back(new TriggerNode(
+                    s, 
+                    NextAction::array(0, new NextAction(s, relevance), NULL)));
+            }
+        }
+
+    protected:
+        list<string> supported;
+        float relevance;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
new file mode 100644
index 0000000..a4bb3fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PassiveStrategy.h"
+#include "../PassiveMultiplier.h"
+
+using namespace ai;
+
+
+void PassiveStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new PassiveMultiplier(ai));
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PassiveStrategy.h b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
new file mode 100644
index 0000000..8e96388
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PassiveStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class PassiveStrategy : public Strategy
+    {
+    public:
+        PassiveStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "passive"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.cpp b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
new file mode 100644
index 0000000..5d82db3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.cpp
@@ -0,0 +1,52 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../PassiveMultiplier.h"
+#include "PullStrategy.h"
+
+using namespace ai;
+
+class MagePullMultiplier : public PassiveMultiplier
+{
+public:
+    MagePullMultiplier(PlayerbotAI* ai, string action) : PassiveMultiplier(ai)
+    {
+        this->action = action;
+    }
+
+public:
+    virtual float GetValue(Action* action);
+
+private:
+    string action;
+};
+
+float MagePullMultiplier::GetValue(Action* action) 
+{
+    if (!action) 
+        return 1.0f;
+
+    string name = action->getName();
+    if (this->action == name ||
+        name == "reach spell" ||
+        name == "change strategy")
+        return 1.0f;
+
+    return PassiveMultiplier::GetValue(action);
+}
+
+NextAction** PullStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction(action, 105.0f), new NextAction("follow", 104.0f), new NextAction("end pull", 103.0f), NULL);
+}
+
+void PullStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+}
+
+void PullStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new MagePullMultiplier(ai, action));
+    RangedCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/PullStrategy.h b/src/plugins/playerbot/strategy/generic/PullStrategy.h
new file mode 100644
index 0000000..b19210a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/PullStrategy.h
@@ -0,0 +1,24 @@
+#pragma once
+
+#include "RangedCombatStrategy.h"
+
+namespace ai
+{
+    class PullStrategy : public RangedCombatStrategy
+    {
+    public:
+        PullStrategy(PlayerbotAI* ai, string action) : RangedCombatStrategy(ai) 
+        {
+            this->action = action;
+        }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "pull"; }
+        virtual NextAction** getDefaultActions();
+
+    private:
+        string action;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
new file mode 100644
index 0000000..62b3e43
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.cpp
@@ -0,0 +1,69 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "QuestStrategies.h"
+
+using namespace ai;
+
+QuestStrategy::QuestStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("accept quest");
+}
+
+void QuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "quest share",
+        NextAction::array(0, new NextAction("accept quest share", relevance), NULL)));
+}
+
+
+void DefaultQuestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, new NextAction("talk to quest giver", relevance), NULL)));
+}
+
+DefaultQuestStrategy::DefaultQuestStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
+
+
+
+void AcceptAllQuestsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    QuestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "complete quest",
+        NextAction::array(0, 
+            new NextAction("talk to quest giver", relevance), new NextAction("accept all quests", relevance), NULL)));
+}
+
+AcceptAllQuestsStrategy::AcceptAllQuestsStrategy(PlayerbotAI* ai) : QuestStrategy(ai)
+{
+}
diff --git a/src/plugins/playerbot/strategy/generic/QuestStrategies.h b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
new file mode 100644
index 0000000..08423dd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/QuestStrategies.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class QuestStrategy : public PassTroughStrategy
+    {
+    public:
+        QuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class DefaultQuestStrategy : public QuestStrategy
+    {
+    public:
+        DefaultQuestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "quest"; }
+    };
+
+    class AcceptAllQuestsStrategy : public QuestStrategy
+    {
+    public:
+        AcceptAllQuestsStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "accept all quests"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
new file mode 100644
index 0000000..58fa904
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.cpp
@@ -0,0 +1,39 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RacialsStrategy.h"
+
+using namespace ai;
+
+
+class RacialsStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    RacialsStrategyActionNodeFactory()
+    {
+        creators["lifeblood"] = &lifeblood;
+    }
+private:
+    static ActionNode* lifeblood(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lifeblood",  
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("gift of the naaru"), NULL), 
+            /*C*/ NULL);
+    }
+};
+
+void RacialsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"low health", 
+		NextAction::array(0, new NextAction("lifeblood", 71.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana", 
+        NextAction::array(0, new NextAction("arcane torrent", ACTION_EMERGENCY + 6), NULL)));
+}
+
+RacialsStrategy::RacialsStrategy(PlayerbotAI* ai) : Strategy(ai)
+{
+    actionNodeFactories.Add(new RacialsStrategyActionNodeFactory());
+}
diff --git a/src/plugins/playerbot/strategy/generic/RacialsStrategy.h b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
new file mode 100644
index 0000000..6802178
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RacialsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class RacialsStrategy : public Strategy
+    {
+    public:
+        RacialsStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "racials"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
new file mode 100644
index 0000000..9fd6ad9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RangedCombatStrategy.h"
+
+using namespace ai;
+
+
+void RangedCombatStrategy::InitTriggers(list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
new file mode 100644
index 0000000..a00cbc1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RangedCombatStrategy.h
@@ -0,0 +1,15 @@
+#include "CombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RangedCombatStrategy : public CombatStrategy
+    {
+    public:
+        RangedCombatStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_RANGED; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
new file mode 100644
index 0000000..5ac877b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RunawayStrategy.h"
+
+using namespace ai;
+
+
+NextAction** RunawayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("runaway", 50.0f), NULL);
+}
+
+void RunawayStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("runaway", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/RunawayStrategy.h b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
new file mode 100644
index 0000000..d1c3ef5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/RunawayStrategy.h
@@ -0,0 +1,16 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class RunawayStrategy : public NonCombatStrategy
+       {
+       public:
+           RunawayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+           virtual string getName() { return "runaway"; }
+           virtual NextAction** getDefaultActions();
+           virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+       };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.cpp b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
new file mode 100644
index 0000000..f8cbf96
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StayStrategy.h"
+
+using namespace ai;
+
+NextAction** StayStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stay", 1.0f), NULL);
+}
+
diff --git a/src/plugins/playerbot/strategy/generic/StayStrategy.h b/src/plugins/playerbot/strategy/generic/StayStrategy.h
new file mode 100644
index 0000000..d9f4229
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/StayStrategy.h
@@ -0,0 +1,14 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class StayStrategy : public NonCombatStrategy
+    {
+    public:
+        StayStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "stay"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
new file mode 100644
index 0000000..29afdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.cpp
@@ -0,0 +1,12 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAoeStrategy.h"
+
+using namespace ai;
+
+void TankAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "tank aoe",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
new file mode 100644
index 0000000..f9ed2fb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAoeStrategy.h
@@ -0,0 +1,18 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAoeStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAoeStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank aoe"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
new file mode 100644
index 0000000..d54b8ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankAssistStrategy.h"
+
+using namespace ai;
+
+
+void TankAssistStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no attackers",
+        NextAction::array(0, new NextAction("tank assist", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
new file mode 100644
index 0000000..3ecbbb9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TankAssistStrategy.h
@@ -0,0 +1,17 @@
+#include "../generic/NonCombatStrategy.h"
+#pragma once
+
+namespace ai
+{
+    class TankAssistStrategy : public NonCombatStrategy
+    {
+    public:
+        TankAssistStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "tank assist"; }
+        virtual int GetType() { return STRATEGY_TYPE_TANK; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
new file mode 100644
index 0000000..ce1340d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.cpp
@@ -0,0 +1,13 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TellTargetStrategy.h"
+
+using namespace ai;
+
+
+void TellTargetStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "target changed",
+        NextAction::array(0, new NextAction("tell target", 51.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
new file mode 100644
index 0000000..22b2e2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/TellTargetStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+namespace ai
+{
+    class TellTargetStrategy : public Strategy
+    {
+    public:
+        TellTargetStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "TellTarget"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
new file mode 100644
index 0000000..155dc24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatStrategy.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../actions/GenericSpellActions.h"
+
+using namespace ai;
+
+float ThreatMultiplier::GetValue(Action* action)
+{
+    if (action == NULL || action->getThreatType() == ACTION_THREAT_NONE)
+        return 1.0f;
+
+    if (action->getThreatType() == ACTION_THREAT_AOE)
+    {
+        uint8 threat = AI_VALUE2(uint8, "threat", "aoe");
+        if (threat >= 90)
+            return 0.0f;
+    }
+
+    uint8 threat = AI_VALUE2(uint8, "threat", "current target");
+
+    if (threat >= 90)
+        return 0.0f;
+
+    return 1.0f;
+}
+
+void ThreatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    multipliers.push_back(new ThreatMultiplier(ai));
+}
diff --git a/src/plugins/playerbot/strategy/generic/ThreatStrategy.h b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
new file mode 100644
index 0000000..406f433
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/ThreatStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+
+namespace ai
+{
+    class ThreatMultiplier : public Multiplier
+    {
+    public:
+        ThreatMultiplier(PlayerbotAI* ai) : Multiplier(ai, "threat") {}
+
+    public:
+        virtual float GetValue(Action* action);
+    };
+
+    class ThreatStrategy : public Strategy
+    {
+    public:
+        ThreatStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "threat"; }
+    };
+
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
new file mode 100644
index 0000000..b141a46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UseFoodStrategy.h"
+
+using namespace ai;
+
+void UseFoodStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("food", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("drink", 2.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
new file mode 100644
index 0000000..b68ab35
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UseFoodStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UseFoodStrategy : public Strategy
+    {
+    public:
+        UseFoodStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "food"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
new file mode 100644
index 0000000..09616bb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.cpp
@@ -0,0 +1,18 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "UsePotionsStrategy.h"
+
+using namespace ai;
+
+void UsePotionsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    Strategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing potion", ACTION_MEDIUM_HEAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0,  new NextAction("mana potion", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
new file mode 100644
index 0000000..b48f89f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/UsePotionsStrategy.h
@@ -0,0 +1,15 @@
+#pragma once
+
+namespace ai
+{
+    class UsePotionsStrategy : public Strategy
+    {
+    public:
+        UsePotionsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "potions"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
new file mode 100644
index 0000000..e05fec5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.cpp
@@ -0,0 +1,106 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WorldPacketHandlerStrategy.h"
+
+using namespace ai;
+
+void WorldPacketHandlerStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    PassTroughStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "group invite",
+        NextAction::array(0, new NextAction("accept invitation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "group set leader",
+        NextAction::array(0, new NextAction("leader", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough money",
+        NextAction::array(0, new NextAction("tell not enough money", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not enough reputation",
+        NextAction::array(0, new NextAction("tell not enough reputation", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cannot equip",
+        NextAction::array(0, new NextAction("tell cannot equip", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "use game object",
+        NextAction::array(0,
+            new NextAction("add loot", relevance),
+            new NextAction("use meeting stone", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "gossip hello",
+        NextAction::array(0,
+            new NextAction("trainer", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "activate taxi",
+        NextAction::array(0, new NextAction("remember taxi", relevance), new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "taxi done",
+        NextAction::array(0, new NextAction("taxi", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "trade status",
+        NextAction::array(0, new NextAction("accept trade", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "area trigger",
+        NextAction::array(0, new NextAction("reach area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "within area trigger",
+        NextAction::array(0, new NextAction("area trigger", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "loot response",
+        NextAction::array(0, new NextAction("store loot", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "item push result",
+        NextAction::array(0, new NextAction("query item usage", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "ready check finished",
+        NextAction::array(0, new NextAction("finish ready check", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "often",
+        NextAction::array(0, new NextAction("security check", relevance), new NextAction("check mail", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "guild invite",
+        NextAction::array(0, new NextAction("guild accept", relevance), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "seldom",
+        NextAction::array(0, new NextAction("lfg leave", relevance), NULL)));
+
+}
+
+WorldPacketHandlerStrategy::WorldPacketHandlerStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai)
+{
+    supported.push_back("loot roll");
+    supported.push_back("check mount state");
+    supported.push_back("quest objective completed");
+    supported.push_back("party command");
+    supported.push_back("ready check");
+    supported.push_back("uninvite");
+    supported.push_back("lfg role check");
+    supported.push_back("lfg teleport");
+}
+
+
+void ReadyCheckStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "timer",
+        NextAction::array(0, new NextAction("ready check", relevance), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
new file mode 100644
index 0000000..6a5a44d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/generic/WorldPacketHandlerStrategy.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "PassTroughStrategy.h"
+
+namespace ai
+{
+    class WorldPacketHandlerStrategy : public PassTroughStrategy
+    {
+    public:
+        WorldPacketHandlerStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "default"; }
+    };
+
+    class ReadyCheckStrategy : public PassTroughStrategy
+    {
+    public:
+        ReadyCheckStrategy(PlayerbotAI* ai) : PassTroughStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "ready check"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
new file mode 100644
index 0000000..bb6c477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.cpp
@@ -0,0 +1,118 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+
+#include "HunterMultipliers.h"
+#include "DpsHunterStrategy.h"
+
+using namespace ai;
+
+class DpsHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsHunterStrategyActionNodeFactory()
+    {
+        creators["aimed shot"] = &aimed_shot;
+        creators["chimera shot"] = &chimera_shot;
+        creators["explosive shot"] = &explosive_shot;
+        creators["concussive shot"] = &concussive_shot;
+        creators["viper sting"] = &viper_sting;
+    }
+private:
+    static ActionNode* viper_sting(PlayerbotAI* ai)
+    {
+        return new ActionNode ("viper sting",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aimed_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aimed shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("chimera shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chimera_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chimera shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane shot", 10.0f), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* explosive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("explosive shot",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aimed shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* concussive_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("concussive shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("wyvern sting", 11.0f), NULL));
+    }
+
+};
+
+DpsHunterStrategy::DpsHunterStrategy(PlayerbotAI* ai) : GenericHunterStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsHunterStrategyActionNodeFactory());
+}
+
+NextAction** DpsHunterStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("explosive shot", 11.0f), new NextAction("auto shot", 10.0f), NULL);
+}
+
+void DpsHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericHunterStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "black arrow",
+        NextAction::array(0, new NextAction("black arrow", 51.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("viper sting", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunter's mark",
+        NextAction::array(0, new NextAction("hunter's mark", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "freezing trap",
+        NextAction::array(0, new NextAction("freezing trap", 83.0f), NULL)));
+}
+
+void DpsAoeHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("multi-shot", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("volley", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"serpent sting on attacker",
+		NextAction::array(0, new NextAction("serpent sting on attacker", 49.0f), NULL)));
+}
+
+void DpsHunterDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "no stings",
+        NextAction::array(0, new NextAction("serpent sting", 50.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
new file mode 100644
index 0000000..4992e0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/DpsHunterStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsHunterStrategy : public GenericHunterStrategy
+    {
+    public:
+        DpsHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+
+    };
+
+    class DpsAoeHunterStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeHunterStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsHunterDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsHunterDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
new file mode 100644
index 0000000..6fab572
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.cpp
@@ -0,0 +1,58 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "GenericHunterNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericHunterNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterNonCombatStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterNonCombatStrategy::GenericHunterNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterNonCombatStrategyActionNodeFactory());
+}
+
+void GenericHunterNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "trueshot aura",
+        NextAction::array(0, new NextAction("trueshot aura", 2.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("call pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet dead",
+        NextAction::array(0, new NextAction("revive pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
new file mode 100644
index 0000000..d01486d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericHunterNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericHunterNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
new file mode 100644
index 0000000..e4c5d45
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.cpp
@@ -0,0 +1,66 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericHunterStrategy.h"
+#include "HunterAiObjectContext.h"
+
+using namespace ai;
+
+class GenericHunterStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericHunterStrategyActionNodeFactory()
+    {
+        creators["rapid fire"] = &rapid_fire;
+        creators["boost"] = &rapid_fire;
+        creators["aspect of the pack"] = &aspect_of_the_pack;
+        creators["feign death"] = &feign_death;
+    }
+private:
+    static ActionNode* rapid_fire(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rapid fire",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("readiness"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* aspect_of_the_pack(PlayerbotAI* ai)
+    {
+        return new ActionNode ("aspect of the pack",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("aspect of the cheetah"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* feign_death(PlayerbotAI* ai)
+    {
+        return new ActionNode ("feign death",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericHunterStrategy::GenericHunterStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericHunterStrategyActionNodeFactory());
+}
+
+void GenericHunterStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("wing clip", 50.0f), new NextAction("flee",49.0f), new NextAction("concussive shot", 48.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("feign death", 52.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hunters pet low health",
+        NextAction::array(0, new NextAction("mend pet", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rapid fire",
+        NextAction::array(0, new NextAction("rapid fire", 55.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
new file mode 100644
index 0000000..f2db28c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/GenericHunterStrategy.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericHunterStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericHunterStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "hunter"; }
+    };
+}
+
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.cpp b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
new file mode 100644
index 0000000..bdf6761
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../actions/GenericActions.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool CastSerpentStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "health", "current target") > 50;
+}
+
+bool CastViperStingAction::isUseful()
+{
+    return AI_VALUE2(uint8, "mana", "self target") < 50 && AI_VALUE2(uint8, "mana", "current target") >= 30;
+}
+
+bool CastAspectOfTheCheetahAction::isUseful() 
+{
+    return !ai->HasAnyAuraOf(GetTarget(), "aspect of the cheetah", "aspect of the pack", NULL);
+}
+
+Value<Unit*>* CastFreezingTrap::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", "freezing trap");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterActions.h b/src/plugins/playerbot/strategy/hunter/HunterActions.h
new file mode 100644
index 0000000..74611ce
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterActions.h
@@ -0,0 +1,154 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    BEGIN_RANGED_SPELL_ACTION(CastHuntersMarkAction, "hunter's mark")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastAutoShotAction, "auto shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastArcaneShotAction, "arcane shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastExplosiveShotAction, "explosive shot")
+    END_SPELL_ACTION()
+
+
+    BEGIN_RANGED_SPELL_ACTION(CastAimedShotAction, "aimed shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastChimeraShotAction, "chimera shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastConcussiveShotAction, "concussive shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastDistractingShotAction, "distracting shot")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMultiShotAction, "multi-shot")
+    END_SPELL_ACTION()
+
+	BEGIN_RANGED_SPELL_ACTION(CastVolleyAction, "volley")
+	END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSerpentStingAction, "serpent sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastWyvernStingAction, "wyvern sting")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastViperStingAction, "viper sting")
+    virtual bool isUseful();
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastScorpidStingAction, "scorpid sting")
+    END_SPELL_ACTION()
+
+	class CastAspectOfTheHawkAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheHawkAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the hawk") {}
+	};
+
+	class CastAspectOfTheWildAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheWildAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the wild") {}
+	};
+
+	class CastAspectOfTheCheetahAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheCheetahAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the cheetah") {}
+		virtual bool isUseful();
+	};
+
+	class CastAspectOfThePackAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfThePackAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the pack") {}
+	};
+
+	class CastAspectOfTheViperAction : public CastBuffSpellAction
+	{
+	public:
+		CastAspectOfTheViperAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "aspect of the viper") {}
+	};
+
+	class CastCallPetAction : public CastBuffSpellAction
+	{
+	public:
+		CastCallPetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "call pet") {}
+	};
+
+	class CastMendPetAction : public CastAuraSpellAction
+	{
+	public:
+		CastMendPetAction(PlayerbotAI* ai) : CastAuraSpellAction(ai, "mend pet") {}
+		virtual string GetTargetName() { return "pet target"; }
+	};
+
+	class CastRevivePetAction : public CastBuffSpellAction
+	{
+	public:
+		CastRevivePetAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "revive pet") {}
+	};
+
+    class CastTrueshotAuraAction : public CastBuffSpellAction
+    {
+    public:
+        CastTrueshotAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "trueshot aura") {}
+    };
+
+    class CastFeignDeathAction : public CastBuffSpellAction
+    {
+    public:
+        CastFeignDeathAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feign death") {}
+    };
+
+	class CastRapidFireAction : public CastBuffSpellAction
+	{
+	public:
+		CastRapidFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "rapid fire") {}
+	};
+
+	class CastReadinessAction : public CastBuffSpellAction
+	{
+	public:
+		CastReadinessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "readiness") {}
+	};
+
+	class CastBlackArrow : public CastDebuffSpellAction
+	{
+	public:
+		CastBlackArrow(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "black arrow") {}
+	};
+
+    class CastFreezingTrap : public CastDebuffSpellAction
+    {
+    public:
+        CastFreezingTrap(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "freezing trap") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+    class CastWingClipAction : public CastMeleeSpellAction
+    {
+    public:
+        CastWingClipAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "wing clip") {}
+        virtual bool isUseful()
+        {
+            return CastMeleeSpellAction::isUseful() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class CastSerpentStingOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastSerpentStingOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
new file mode 100644
index 0000000..dd62523
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.cpp
@@ -0,0 +1,191 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterActions.h"
+#include "HunterTriggers.h"
+#include "HunterAiObjectContext.h"
+#include "DpsHunterStrategy.h"
+#include "GenericHunterNonCombatStrategy.h"
+#include "HunterBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &hunter::StrategyFactoryInternal::dps;
+                creators["nc"] = &hunter::StrategyFactoryInternal::nc;
+                creators["aoe"] = &hunter::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &hunter::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeHunterStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsHunterStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericHunterNonCombatStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsHunterDebuffStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bspeed"] = &hunter::BuffStrategyFactoryInternal::bspeed;
+                creators["bdps"] = &hunter::BuffStrategyFactoryInternal::bdps;
+                creators["bmana"] = &hunter::BuffStrategyFactoryInternal::bmana;
+                creators["rnature"] = &hunter::BuffStrategyFactoryInternal::rnature;
+            }
+
+        private:
+            static Strategy* bspeed(PlayerbotAI* ai) { return new HunterBuffSpeedStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new HunterBuffDpsStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new HunterBuffManaStrategy(ai); }
+            static Strategy* rnature(PlayerbotAI* ai) { return new HunterNatureResistanceStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["black arrow"] = &TriggerFactoryInternal::black_arrow;
+                creators["no stings"] = &TriggerFactoryInternal::NoStings;
+                creators["hunters pet dead"] = &TriggerFactoryInternal::hunters_pet_dead;
+                creators["hunters pet low health"] = &TriggerFactoryInternal::hunters_pet_low_health;
+                creators["hunter's mark"] = &TriggerFactoryInternal::hunters_mark;
+                creators["freezing trap"] = &TriggerFactoryInternal::freezing_trap;
+                creators["aspect of the pack"] = &TriggerFactoryInternal::aspect_of_the_pack;
+                creators["rapid fire"] = &TriggerFactoryInternal::rapid_fire;
+                creators["aspect of the hawk"] = &TriggerFactoryInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &TriggerFactoryInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &TriggerFactoryInternal::aspect_of_the_viper;
+                creators["trueshot aura"] = &TriggerFactoryInternal::trueshot_aura;
+                creators["serpent sting on attacker"] = &TriggerFactoryInternal::serpent_sting_on_attacker;
+            }
+
+        private:
+            static Trigger* serpent_sting_on_attacker(PlayerbotAI* ai) { return new SerpentStingOnAttackerTrigger(ai); }
+            static Trigger* trueshot_aura(PlayerbotAI* ai) { return new TrueshotAuraTrigger(ai); }
+            static Trigger* aspect_of_the_viper(PlayerbotAI* ai) { return new HunterAspectOfTheViperTrigger(ai); }
+            static Trigger* black_arrow(PlayerbotAI* ai) { return new BlackArrowTrigger(ai); }
+            static Trigger* NoStings(PlayerbotAI* ai) { return new HunterNoStingsActiveTrigger(ai); }
+            static Trigger* hunters_pet_dead(PlayerbotAI* ai) { return new HuntersPetDeadTrigger(ai); }
+            static Trigger* hunters_pet_low_health(PlayerbotAI* ai) { return new HuntersPetLowHealthTrigger(ai); }
+            static Trigger* hunters_mark(PlayerbotAI* ai) { return new HuntersMarkTrigger(ai); }
+            static Trigger* freezing_trap(PlayerbotAI* ai) { return new FreezingTrapTrigger(ai); }
+            static Trigger* aspect_of_the_pack(PlayerbotAI* ai) { return new HunterAspectOfThePackTrigger(ai); }
+            static Trigger* rapid_fire(PlayerbotAI* ai) { return new RapidFireTrigger(ai); }
+            static Trigger* aspect_of_the_hawk(PlayerbotAI* ai) { return new HunterAspectOfTheHawkTrigger(ai); }
+            static Trigger* aspect_of_the_wild(PlayerbotAI* ai) { return new HunterAspectOfTheWildTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace hunter
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["auto shot"] = &AiObjectContextInternal::auto_shot;
+                creators["aimed shot"] = &AiObjectContextInternal::aimed_shot;
+                creators["chimera shot"] = &AiObjectContextInternal::chimera_shot;
+                creators["explosive shot"] = &AiObjectContextInternal::explosive_shot;
+                creators["arcane shot"] = &AiObjectContextInternal::arcane_shot;
+                creators["concussive shot"] = &AiObjectContextInternal::concussive_shot;
+                creators["distracting shot"] = &AiObjectContextInternal::distracting_shot;
+                creators["multi-shot"] = &AiObjectContextInternal::multi_shot;
+                creators["volley"] = &AiObjectContextInternal::volley;
+                creators["serpent sting"] = &AiObjectContextInternal::serpent_sting;
+                creators["serpent sting on attacker"] = &AiObjectContextInternal::serpent_sting_on_attacker;
+                creators["wyvern sting"] = &AiObjectContextInternal::wyvern_sting;
+                creators["viper sting"] = &AiObjectContextInternal::viper_sting;
+                creators["scorpid sting"] = &AiObjectContextInternal::scorpid_sting;
+                creators["hunter's mark"] = &AiObjectContextInternal::hunters_mark;
+                creators["mend pet"] = &AiObjectContextInternal::mend_pet;
+                creators["revive pet"] = &AiObjectContextInternal::revive_pet;
+                creators["call pet"] = &AiObjectContextInternal::call_pet;
+                creators["black arrow"] = &AiObjectContextInternal::black_arrow;
+                creators["freezing trap"] = &AiObjectContextInternal::freezing_trap;
+                creators["rapid fire"] = &AiObjectContextInternal::rapid_fire;
+                creators["boost"] = &AiObjectContextInternal::rapid_fire;
+                creators["readiness"] = &AiObjectContextInternal::readiness;
+                creators["aspect of the hawk"] = &AiObjectContextInternal::aspect_of_the_hawk;
+                creators["aspect of the wild"] = &AiObjectContextInternal::aspect_of_the_wild;
+                creators["aspect of the viper"] = &AiObjectContextInternal::aspect_of_the_viper;
+                creators["aspect of the pack"] = &AiObjectContextInternal::aspect_of_the_pack;
+                creators["aspect of the cheetah"] = &AiObjectContextInternal::aspect_of_the_cheetah;
+                creators["trueshot aura"] = &AiObjectContextInternal::trueshot_aura;
+                creators["feign death"] = &AiObjectContextInternal::feign_death;
+                creators["wing clip"] = &AiObjectContextInternal::wing_clip;
+            }
+
+        private:
+            static Action* feign_death(PlayerbotAI* ai) { return new CastFeignDeathAction(ai); }
+            static Action* trueshot_aura(PlayerbotAI* ai) { return new CastTrueshotAuraAction(ai); }
+            static Action* auto_shot(PlayerbotAI* ai) { return new CastAutoShotAction(ai); }
+            static Action* aimed_shot(PlayerbotAI* ai) { return new CastAimedShotAction(ai); }
+            static Action* chimera_shot(PlayerbotAI* ai) { return new CastChimeraShotAction(ai); }
+            static Action* explosive_shot(PlayerbotAI* ai) { return new CastExplosiveShotAction(ai); }
+            static Action* arcane_shot(PlayerbotAI* ai) { return new CastArcaneShotAction(ai); }
+            static Action* concussive_shot(PlayerbotAI* ai) { return new CastConcussiveShotAction(ai); }
+            static Action* distracting_shot(PlayerbotAI* ai) { return new CastDistractingShotAction(ai); }
+            static Action* multi_shot(PlayerbotAI* ai) { return new CastMultiShotAction(ai); }
+            static Action* volley(PlayerbotAI* ai) { return new CastVolleyAction(ai); }
+            static Action* serpent_sting(PlayerbotAI* ai) { return new CastSerpentStingAction(ai); }
+            static Action* serpent_sting_on_attacker(PlayerbotAI* ai) { return new CastSerpentStingOnAttackerAction(ai); }
+            static Action* wyvern_sting(PlayerbotAI* ai) { return new CastWyvernStingAction(ai); }
+            static Action* viper_sting(PlayerbotAI* ai) { return new CastViperStingAction(ai); }
+            static Action* scorpid_sting(PlayerbotAI* ai) { return new CastScorpidStingAction(ai); }
+            static Action* hunters_mark(PlayerbotAI* ai) { return new CastHuntersMarkAction(ai); }
+            static Action* mend_pet(PlayerbotAI* ai) { return new CastMendPetAction(ai); }
+            static Action* revive_pet(PlayerbotAI* ai) { return new CastRevivePetAction(ai); }
+            static Action* call_pet(PlayerbotAI* ai) { return new CastCallPetAction(ai); }
+            static Action* black_arrow(PlayerbotAI* ai) { return new CastBlackArrow(ai); }
+            static Action* freezing_trap(PlayerbotAI* ai) { return new CastFreezingTrap(ai); }
+            static Action* rapid_fire(PlayerbotAI* ai) { return new CastRapidFireAction(ai); }
+            static Action* readiness(PlayerbotAI* ai) { return new CastReadinessAction(ai); }
+            static Action* aspect_of_the_hawk(PlayerbotAI* ai) { return new CastAspectOfTheHawkAction(ai); }
+            static Action* aspect_of_the_wild(PlayerbotAI* ai) { return new CastAspectOfTheWildAction(ai); }
+            static Action* aspect_of_the_viper(PlayerbotAI* ai) { return new CastAspectOfTheViperAction(ai); }
+            static Action* aspect_of_the_pack(PlayerbotAI* ai) { return new CastAspectOfThePackAction(ai); }
+            static Action* aspect_of_the_cheetah(PlayerbotAI* ai) { return new CastAspectOfTheCheetahAction(ai); }
+            static Action* wing_clip(PlayerbotAI* ai) { return new CastWingClipAction(ai); }
+        };
+    };
+};
+
+HunterAiObjectContext::HunterAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::hunter::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::hunter::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::hunter::AiObjectContextInternal());
+    triggerContexts.Add(new ai::hunter::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
new file mode 100644
index 0000000..8891a54
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class HunterAiObjectContext : public AiObjectContext
+    {
+    public:
+        HunterAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
new file mode 100644
index 0000000..33f7612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+#include "HunterBuffStrategies.h"
+
+using namespace ai;
+
+void HunterBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the hawk", 
+		NextAction::array(0, new NextAction("aspect of the hawk", 90.0f), NULL)));
+}
+
+void HunterNatureResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"aspect of the wild", 
+		NextAction::array(0, new NextAction("aspect of the wild", 90.0f), NULL)));
+}
+
+
+void HunterBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the pack",
+        NextAction::array(0, new NextAction("aspect of the pack", 10.0f), NULL)));
+}
+
+void HunterBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "aspect of the viper",
+        NextAction::array(0, new NextAction("aspect of the viper", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
new file mode 100644
index 0000000..d59f245
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterBuffStrategies.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include "GenericHunterStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class HunterBuffSpeedStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffSpeedStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bspeed"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class HunterBuffManaStrategy : public NonCombatStrategy
+    {
+    public:
+        HunterBuffManaStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "bmana"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+	class HunterBuffDpsStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterBuffDpsStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "bdps"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+
+	class HunterNatureResistanceStrategy : public NonCombatStrategy
+	{
+	public:
+		HunterNatureResistanceStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+		virtual string getName() { return "rnature"; }
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
new file mode 100644
index 0000000..9d0bdec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterMultipliers.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
new file mode 100644
index 0000000..c356a0e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.cpp
@@ -0,0 +1,29 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HunterTriggers.h"
+#include "HunterActions.h"
+
+using namespace ai;
+
+bool HunterNoStingsActiveTrigger::IsActive()
+{
+	Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(uint8, "health", "current target") > 40 &&
+        !ai->HasAura("serpent sting", target) &&
+        !ai->HasAura("scorpid sting", target) &&
+        !ai->HasAura("viper sting", target);
+}
+
+bool HuntersPetDeadTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
+
+
+bool HuntersPetLowHealthTrigger::IsActive()
+{
+    Unit* pet = AI_VALUE(Unit*, "pet target");
+    return pet && AI_VALUE2(uint8, "health", "pet target") < 40 &&
+        !AI_VALUE2(bool, "dead", "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+}
diff --git a/src/plugins/playerbot/strategy/hunter/HunterTriggers.h b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
new file mode 100644
index 0000000..9466218
--- /dev/null
+++ b/src/plugins/playerbot/strategy/hunter/HunterTriggers.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BEGIN_TRIGGER(HunterNoStingsActiveTrigger, Trigger)
+    END_TRIGGER()
+
+    class HunterAspectOfTheHawkTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheHawkTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the hawk") {
+			checkInterval = 1;
+		}
+    };
+
+	class HunterAspectOfTheWildTrigger : public BuffTrigger
+	{
+	public:
+		HunterAspectOfTheWildTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the wild") {
+			checkInterval = 1;
+		}
+	};
+
+    class HunterAspectOfTheViperTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfTheViperTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the viper") {}
+        virtual bool IsActive()
+        {
+            return SpellTrigger::IsActive() && !ai->HasAura(spell, GetTarget());
+        }
+    };
+
+    class HunterAspectOfThePackTrigger : public BuffTrigger
+    {
+    public:
+        HunterAspectOfThePackTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "aspect of the pack") {}
+        virtual bool IsActive() {
+			return BuffTrigger::IsActive() && !ai->HasAura("aspect of the cheetah", GetTarget());
+        };
+    };
+
+    BEGIN_TRIGGER(HuntersPetDeadTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(HuntersPetLowHealthTrigger, Trigger)
+    END_TRIGGER()
+
+    class BlackArrowTrigger : public DebuffTrigger
+    {
+    public:
+        BlackArrowTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "black arrow") {}
+    };
+
+    class HuntersMarkTrigger : public DebuffTrigger
+    {
+    public:
+        HuntersMarkTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "hunter's mark") {}
+    };
+
+    class FreezingTrapTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FreezingTrapTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "freezing trap") {}
+    };
+
+    class RapidFireTrigger : public BoostTrigger
+    {
+    public:
+        RapidFireTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "rapid fire") {}
+    };
+
+    class TrueshotAuraTrigger : public BuffTrigger
+    {
+    public:
+        TrueshotAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "trueshot aura") {}
+    };
+
+    class SerpentStingOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        SerpentStingOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "serpent sting") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
new file mode 100644
index 0000000..0779477
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.cpp
@@ -0,0 +1,64 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "ArcaneMageStrategy.h"
+
+using namespace ai;
+
+class ArcaneMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    ArcaneMageStrategyActionNodeFactory()
+    {
+        creators["arcane blast"] = &arcane_blast;
+        creators["arcane barrage"] = &arcane_barrage;
+        creators["arcane missiles"] = &arcane_missiles;
+    }
+private:
+    static ActionNode* arcane_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_barrage(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane barrage",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("arcane missiles"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* arcane_missiles(PlayerbotAI* ai)
+    {
+        return new ActionNode ("arcane missiles",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+ArcaneMageStrategy::ArcaneMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+    actionNodeFactories.Add(new ArcaneMageStrategyActionNodeFactory());
+}
+
+NextAction** ArcaneMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("arcane barrage", 10.0f), NULL);
+}
+
+void ArcaneMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane blast",
+        NextAction::array(0, new NextAction("arcane blast", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "missile barrage",
+        NextAction::array(0, new NextAction("arcane missiles", 15.0f), NULL)));
+
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
new file mode 100644
index 0000000..ac053a8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/ArcaneMageStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+
+namespace ai
+{
+    class ArcaneMageStrategy : public GenericMageStrategy
+    {
+    public:
+        ArcaneMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "arcane"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
new file mode 100644
index 0000000..47c4bc2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FireMageStrategy.h"
+
+using namespace ai;
+
+NextAction** FireMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("scorch", 7.0f), new NextAction("fireball", 6.0f), new NextAction("fire blast", 5.0f), NULL);
+}
+
+void FireMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "pyroblast",
+        NextAction::array(0, new NextAction("pyroblast", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "hot streak",
+        NextAction::array(0, new NextAction("pyroblast", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "combustion",
+        NextAction::array(0, new NextAction("combustion", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("dragon's breath", 70.0f), NULL)));
+}
+
+void FireMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flamestrike", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "living bomb",
+        NextAction::array(0, new NextAction("living bomb", 25.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/mage/FireMageStrategy.h b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
new file mode 100644
index 0000000..fc0cd7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FireMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FireMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FireMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FireMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FireMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "fire aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
new file mode 100644
index 0000000..e6fb861
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.cpp
@@ -0,0 +1,32 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "FrostMageStrategy.h"
+
+using namespace ai;
+
+
+FrostMageStrategy::FrostMageStrategy(PlayerbotAI* ai) : GenericMageStrategy(ai)
+{
+}
+
+NextAction** FrostMageStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("frostbolt", 7.0f), NULL);
+}
+
+void FrostMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericMageStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "icy veins",
+        NextAction::array(0, new NextAction("icy veins", 50.0f), NULL)));
+}
+
+void FrostMageAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"high aoe",
+		NextAction::array(0, new NextAction("blizzard", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
new file mode 100644
index 0000000..15fac2f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/FrostMageStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class FrostMageStrategy : public GenericMageStrategy
+    {
+    public:
+        FrostMageStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost"; }
+        virtual NextAction** getDefaultActions();
+    };
+
+    class FrostMageAoeStrategy : public CombatStrategy
+    {
+    public:
+        FrostMageAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "frost aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
new file mode 100644
index 0000000..f4111de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.cpp
@@ -0,0 +1,87 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericMageNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageNonCombatStrategyActionNodeFactory()
+    {
+        creators["molten armor"] = &molten_armor;
+        creators["mage armor"] = &mage_armor;
+        creators["ice armor"] = &ice_armor;
+    }
+private:
+    static ActionNode* molten_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("molten armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mage armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mage_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mage armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("ice armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* ice_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("ice armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost armor"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericMageNonCombatStrategy::GenericMageNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageNonCombatStrategyActionNodeFactory());
+}
+
+void GenericMageNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect",
+        NextAction::array(0, new NextAction("arcane intellect", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "arcane intellect on party",
+        NextAction::array(0, new NextAction("arcane intellect on party", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no drink",
+		NextAction::array(0, new NextAction("conjure water", 16.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no food",
+		NextAction::array(0, new NextAction("conjure food", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+}
+
+void MageBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("mage armor", 19.0f), NULL)));
+}
+
+void MageBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "mage armor",
+        NextAction::array(0, new NextAction("molten armor", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
new file mode 100644
index 0000000..5319bf9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageNonCombatStrategy.h
@@ -0,0 +1,37 @@
+#pragma once
+
+#include "GenericMageStrategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericMageNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+
+    class MageBuffManaStrategy : public Strategy
+    {
+    public:
+        MageBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class MageBuffDpsStrategy : public Strategy
+    {
+    public:
+        MageBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
new file mode 100644
index 0000000..7f137c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.cpp
@@ -0,0 +1,137 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "GenericMageStrategy.h"
+
+using namespace ai;
+
+class GenericMageStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericMageStrategyActionNodeFactory()
+    {
+        creators["frostbolt"] = &frostbolt;
+        creators["fire blast"] = &fire_blast;
+        creators["scorch"] = &scorch;
+        creators["frost nova"] = &frost_nova;
+        creators["icy veins"] = &icy_veins;
+        creators["combustion"] = &combustion;
+        creators["evocation"] = &evocation;
+        creators["dragon's breath"] = &dragons_breath;
+        creators["blast wave"] = &blast_wave;
+    }
+private:
+    static ActionNode* frostbolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* fire_blast(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fire blast",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("scorch"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* scorch(PlayerbotAI* ai)
+    {
+        return new ActionNode ("scorch",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frost_nova(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frost nova",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flee"), NULL));
+    }
+    static ActionNode* icy_veins(PlayerbotAI* ai)
+    {
+        return new ActionNode ("icy veins",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* combustion(PlayerbotAI* ai)
+    {
+        return new ActionNode ("combustion",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* evocation(PlayerbotAI* ai)
+    {
+        return new ActionNode ("evocation",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* dragons_breath(PlayerbotAI* ai)
+    {
+        return new ActionNode ("dragon's breath",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blast wave"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+    static ActionNode* blast_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blast wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frost nova"), NULL),
+            /*C*/ NextAction::array(0, new NextAction("flamestrike", 71.0f), NULL));
+    }
+};
+
+GenericMageStrategy::GenericMageStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericMageStrategyActionNodeFactory());
+}
+
+void GenericMageStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "remove curse",
+        NextAction::array(0, new NextAction("remove curse", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "remove curse on party",
+        NextAction::array(0, new NextAction("remove curse on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("frost nova", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell",
+        NextAction::array(0, new NextAction("counterspell", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "counterspell on enemy healer",
+        NextAction::array(0, new NextAction("counterspell on enemy healer", 40.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("ice block", 80.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "polymorph",
+        NextAction::array(0, new NextAction("polymorph", 30.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"spellsteal",
+		NextAction::array(0, new NextAction("spellsteal", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("invisibility", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("evocation", ACTION_EMERGENCY + 5), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
new file mode 100644
index 0000000..4dcb9d9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/GenericMageStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericMageStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericMageStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "mage"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.cpp b/src/plugins/playerbot/strategy/mage/MageActions.cpp
new file mode 100644
index 0000000..ee4d6fc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+Value<Unit*>* CastPolymorphAction::GetTargetValue()
+{
+    return context->GetValue<Unit*>("cc target", getName());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageActions.h b/src/plugins/playerbot/strategy/mage/MageActions.h
new file mode 100644
index 0000000..ea541a9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageActions.h
@@ -0,0 +1,205 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastFireballAction : public CastSpellAction
+    {
+    public:
+        CastFireballAction(PlayerbotAI* ai) : CastSpellAction(ai, "fireball") {}
+    };
+
+    class CastScorchAction : public CastSpellAction
+    {
+    public:
+        CastScorchAction(PlayerbotAI* ai) : CastSpellAction(ai, "scorch") {}
+    };
+
+    class CastFireBlastAction : public CastSpellAction
+    {
+    public:
+        CastFireBlastAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire blast") {}
+    };
+
+    class CastArcaneBlastAction : public CastBuffSpellAction
+    {
+    public:
+        CastArcaneBlastAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane blast") {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class CastArcaneBarrageAction : public CastSpellAction
+    {
+    public:
+        CastArcaneBarrageAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane barrage") {}
+    };
+
+    class CastArcaneMissilesAction : public CastSpellAction
+    {
+    public:
+        CastArcaneMissilesAction(PlayerbotAI* ai) : CastSpellAction(ai, "arcane missiles") {}
+    };
+
+    class CastPyroblastAction : public CastSpellAction
+    {
+    public:
+        CastPyroblastAction(PlayerbotAI* ai) : CastSpellAction(ai, "pyroblast") {}
+    };
+
+    class CastFlamestrikeAction : public CastSpellAction
+    {
+    public:
+        CastFlamestrikeAction(PlayerbotAI* ai) : CastSpellAction(ai, "flamestrike") {}
+    };
+
+    class CastFrostNovaAction : public CastSpellAction
+    {
+    public:
+        CastFrostNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "frost nova") {}
+        virtual bool isUseful() { return AI_VALUE2(float, "distance", GetTargetName()) <= sPlayerbotAIConfig.tooCloseDistance; }
+    };
+
+	class CastFrostboltAction : public CastSpellAction
+	{
+	public:
+		CastFrostboltAction(PlayerbotAI* ai) : CastSpellAction(ai, "frostbolt") {}
+	};
+
+	class CastBlizzardAction : public CastSpellAction
+	{
+	public:
+		CastBlizzardAction(PlayerbotAI* ai) : CastSpellAction(ai, "blizzard") {}
+	};
+
+	class CastArcaneIntellectAction : public CastBuffSpellAction
+    {
+	public:
+		CastArcaneIntellectAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "arcane intellect") {}
+	};
+
+	class CastArcaneIntellectOnPartyAction : public BuffOnPartyAction
+    {
+	public:
+		CastArcaneIntellectOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "arcane intellect") {}
+	};
+
+	class CastRemoveCurseAction : public CastCureSpellAction
+    {
+	public:
+		CastRemoveCurseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "remove curse") {}
+	};
+
+	class CastIcyVeinsAction : public CastBuffSpellAction
+    {
+	public:
+		CastIcyVeinsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "icy veins") {}
+	};
+
+	class CastCombustionAction : public CastBuffSpellAction
+    {
+	public:
+		CastCombustionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "combustion") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastCounterspellAction, "counterspell")
+    END_SPELL_ACTION()
+
+    class CastRemoveCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastRemoveCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+	class CastConjureFoodAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureFoodAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure food") {}
+	};
+
+	class CastConjureWaterAction : public CastBuffSpellAction
+    {
+	public:
+		CastConjureWaterAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "conjure water") {}
+	};
+
+	class CastIceBlockAction : public CastBuffSpellAction
+    {
+	public:
+		CastIceBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice block") {}
+	};
+
+    class CastMoltenArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMoltenArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "molten armor") {}
+    };
+
+    class CastMageArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastMageArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "mage armor") {}
+    };
+
+    class CastIceArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastIceArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "ice armor") {}
+    };
+
+    class CastFrostArmorAction : public CastBuffSpellAction
+    {
+    public:
+        CastFrostArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost armor") {}
+    };
+
+    class CastPolymorphAction : public CastBuffSpellAction
+    {
+    public:
+        CastPolymorphAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "polymorph") {}
+        virtual Value<Unit*>* GetTargetValue();
+    };
+
+	class CastSpellstealAction : public CastSpellAction
+	{
+	public:
+		CastSpellstealAction(PlayerbotAI* ai) : CastSpellAction(ai, "spellsteal") {}
+	};
+
+	class CastLivingBombAction : public CastDebuffSpellAction
+	{
+	public:
+	    CastLivingBombAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "living bomb") {}
+	};
+
+	class CastDragonsBreathAction : public CastSpellAction
+	{
+	public:
+	    CastDragonsBreathAction(PlayerbotAI* ai) : CastSpellAction(ai, "dragon's breath") {}
+	};
+
+	class CastBlastWaveAction : public CastSpellAction
+	{
+	public:
+	    CastBlastWaveAction(PlayerbotAI* ai) : CastSpellAction(ai, "blast wave") {}
+	};
+
+	class CastInvisibilityAction : public CastBuffSpellAction
+	{
+	public:
+	    CastInvisibilityAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "invisibility") {}
+	};
+
+	class CastEvocationAction : public CastSpellAction
+	{
+	public:
+	    CastEvocationAction(PlayerbotAI* ai) : CastSpellAction(ai, "evocation") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+    class CastCounterspellOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+	    CastCounterspellOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
new file mode 100644
index 0000000..366ef77
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.cpp
@@ -0,0 +1,221 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "../Strategy.h"
+#include "MageActions.h"
+#include "MageAiObjectContext.h"
+#include "FrostMageStrategy.h"
+#include "ArcaneMageStrategy.h"
+#include "GenericMageNonCombatStrategy.h"
+#include "FireMageStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "MageTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &mage::StrategyFactoryInternal::nc;
+                creators["pull"] = &mage::StrategyFactoryInternal::pull;
+                creators["fire aoe"] = &mage::StrategyFactoryInternal::fire_aoe;
+                creators["frost aoe"] = &mage::StrategyFactoryInternal::frost_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericMageNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* fire_aoe(PlayerbotAI* ai) { return new FireMageAoeStrategy(ai); }
+            static Strategy* frost_aoe(PlayerbotAI* ai) { return new FrostMageAoeStrategy(ai); }
+        };
+
+        class MageStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["frost"] = &mage::MageStrategyFactoryInternal::frost;
+                creators["fire"] = &mage::MageStrategyFactoryInternal::fire;
+                creators["arcane"] = &mage::MageStrategyFactoryInternal::arcane;
+            }
+
+        private:
+            static Strategy* frost(PlayerbotAI* ai) { return new FrostMageStrategy(ai); }
+            static Strategy* fire(PlayerbotAI* ai) { return new FireMageStrategy(ai); }
+            static Strategy* arcane(PlayerbotAI* ai) { return new ArcaneMageStrategy(ai); }
+        };
+
+        class MageBuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            MageBuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &mage::MageBuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &mage::MageBuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new MageBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new MageBuffDpsStrategy(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["fireball"] = &TriggerFactoryInternal::fireball;
+                creators["pyroblast"] = &TriggerFactoryInternal::pyroblast;
+                creators["combustion"] = &TriggerFactoryInternal::combustion;
+                creators["icy veins"] = &TriggerFactoryInternal::icy_veins;
+                creators["arcane intellect"] = &TriggerFactoryInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &TriggerFactoryInternal::arcane_intellect_on_party;
+                creators["mage armor"] = &TriggerFactoryInternal::mage_armor;
+                creators["remove curse"] = &TriggerFactoryInternal::remove_curse;
+                creators["remove curse on party"] = &TriggerFactoryInternal::remove_curse_on_party;
+                creators["counterspell"] = &TriggerFactoryInternal::counterspell;
+                creators["polymorph"] = &TriggerFactoryInternal::polymorph;
+                creators["spellsteal"] = &TriggerFactoryInternal::spellsteal;
+                creators["hot streak"] = &TriggerFactoryInternal::hot_streak;
+                creators["living bomb"] = &TriggerFactoryInternal::living_bomb;
+                creators["missile barrage"] = &TriggerFactoryInternal::missile_barrage;
+                creators["arcane blast"] = &TriggerFactoryInternal::arcane_blast;
+                creators["counterspell on enemy healer"] = &TriggerFactoryInternal::counterspell_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hot_streak(PlayerbotAI* ai) { return new HotStreakTrigger(ai); }
+            static Trigger* fireball(PlayerbotAI* ai) { return new FireballTrigger(ai); }
+            static Trigger* pyroblast(PlayerbotAI* ai) { return new PyroblastTrigger(ai); }
+            static Trigger* combustion(PlayerbotAI* ai) { return new CombustionTrigger(ai); }
+            static Trigger* icy_veins(PlayerbotAI* ai) { return new IcyVeinsTrigger(ai); }
+            static Trigger* arcane_intellect(PlayerbotAI* ai) { return new ArcaneIntellectTrigger(ai); }
+            static Trigger* arcane_intellect_on_party(PlayerbotAI* ai) { return new ArcaneIntellectOnPartyTrigger(ai); }
+            static Trigger* mage_armor(PlayerbotAI* ai) { return new MageArmorTrigger(ai); }
+            static Trigger* remove_curse(PlayerbotAI* ai) { return new RemoveCurseTrigger(ai); }
+            static Trigger* remove_curse_on_party(PlayerbotAI* ai) { return new PartyMemberRemoveCurseTrigger(ai); }
+            static Trigger* counterspell(PlayerbotAI* ai) { return new CounterspellInterruptSpellTrigger(ai); }
+            static Trigger* polymorph(PlayerbotAI* ai) { return new PolymorphTrigger(ai); }
+            static Trigger* spellsteal(PlayerbotAI* ai) { return new SpellstealTrigger(ai); }
+            static Trigger* living_bomb(PlayerbotAI* ai) { return new LivingBombTrigger(ai); }
+            static Trigger* missile_barrage(PlayerbotAI* ai) { return new MissileBarrageTrigger(ai); }
+            static Trigger* arcane_blast(PlayerbotAI* ai) { return new ArcaneBlastTrigger(ai); }
+            static Trigger* counterspell_enemy_healer(PlayerbotAI* ai) { return new CounterspellEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace mage
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["frostbolt"] = &AiObjectContextInternal::frostbolt;
+                creators["blizzard"] = &AiObjectContextInternal::blizzard;
+                creators["frost nova"] = &AiObjectContextInternal::frost_nova;
+                creators["arcane intellect"] = &AiObjectContextInternal::arcane_intellect;
+                creators["arcane intellect on party"] = &AiObjectContextInternal::arcane_intellect_on_party;
+                creators["conjure water"] = &AiObjectContextInternal::conjure_water;
+                creators["conjure food"] = &AiObjectContextInternal::conjure_food;
+                creators["molten armor"] = &AiObjectContextInternal::molten_armor;
+                creators["mage armor"] = &AiObjectContextInternal::mage_armor;
+                creators["ice armor"] = &AiObjectContextInternal::ice_armor;
+                creators["frost armor"] = &AiObjectContextInternal::frost_armor;
+                creators["fireball"] = &AiObjectContextInternal::fireball;
+                creators["pyroblast"] = &AiObjectContextInternal::pyroblast;
+                creators["flamestrike"] = &AiObjectContextInternal::flamestrike;
+                creators["fire blast"] = &AiObjectContextInternal::fire_blast;
+                creators["scorch"] = &AiObjectContextInternal::scorch;
+                creators["counterspell"] = &AiObjectContextInternal::counterspell;
+                creators["remove curse"] = &AiObjectContextInternal::remove_curse;
+                creators["remove curse on party"] = &AiObjectContextInternal::remove_curse_on_party;
+                creators["icy veins"] = &AiObjectContextInternal::icy_veins;
+                creators["combustion"] = &AiObjectContextInternal::combustion;
+                creators["ice block"] = &AiObjectContextInternal::ice_block;
+                creators["polymorph"] = &AiObjectContextInternal::polymorph;
+                creators["spellsteal"] = &AiObjectContextInternal::spellsteal;
+                creators["living bomb"] = &AiObjectContextInternal::living_bomb;
+                creators["dragon's breath"] = &AiObjectContextInternal::dragons_breath;
+                creators["blast wave"] = &AiObjectContextInternal::blast_wave;
+                creators["invisibility"] = &AiObjectContextInternal::invisibility;
+                creators["evocation"] = &AiObjectContextInternal::evocation;
+                creators["arcane blast"] = &AiObjectContextInternal::arcane_blast;
+                creators["arcane barrage"] = &AiObjectContextInternal::arcane_barrage;
+                creators["arcane missiles"] = &AiObjectContextInternal::arcane_missiles;
+                creators["counterspell on enemy healer"] = &AiObjectContextInternal::counterspell_on_enemy_healer;
+            }
+
+        private:
+            static Action* arcane_missiles(PlayerbotAI* ai) { return new CastArcaneMissilesAction(ai); }
+            static Action* arcane_barrage(PlayerbotAI* ai) { return new CastArcaneBarrageAction(ai); }
+            static Action* arcane_blast(PlayerbotAI* ai) { return new CastArcaneBlastAction(ai); }
+            static Action* frostbolt(PlayerbotAI* ai) { return new CastFrostboltAction(ai); }
+            static Action* blizzard(PlayerbotAI* ai) { return new CastBlizzardAction(ai); }
+            static Action* frost_nova(PlayerbotAI* ai) { return new CastFrostNovaAction(ai); }
+            static Action* arcane_intellect(PlayerbotAI* ai) { return new CastArcaneIntellectAction(ai); }
+            static Action* arcane_intellect_on_party(PlayerbotAI* ai) { return new CastArcaneIntellectOnPartyAction(ai); }
+            static Action* conjure_water(PlayerbotAI* ai) { return new CastConjureWaterAction(ai); }
+            static Action* conjure_food(PlayerbotAI* ai) { return new CastConjureFoodAction(ai); }
+            static Action* molten_armor(PlayerbotAI* ai) { return new CastMoltenArmorAction(ai); }
+            static Action* mage_armor(PlayerbotAI* ai) { return new CastMageArmorAction(ai); }
+            static Action* ice_armor(PlayerbotAI* ai) { return new CastIceArmorAction(ai); }
+            static Action* frost_armor(PlayerbotAI* ai) { return new CastFrostArmorAction(ai); }
+            static Action* fireball(PlayerbotAI* ai) { return new CastFireballAction(ai); }
+            static Action* pyroblast(PlayerbotAI* ai) { return new CastPyroblastAction(ai); }
+            static Action* flamestrike(PlayerbotAI* ai) { return new CastFlamestrikeAction(ai); }
+            static Action* fire_blast(PlayerbotAI* ai) { return new CastFireBlastAction(ai); }
+            static Action* scorch(PlayerbotAI* ai) { return new CastScorchAction(ai); }
+            static Action* counterspell(PlayerbotAI* ai) { return new CastCounterspellAction(ai); }
+            static Action* remove_curse(PlayerbotAI* ai) { return new CastRemoveCurseAction(ai); }
+            static Action* remove_curse_on_party(PlayerbotAI* ai) { return new CastRemoveCurseOnPartyAction(ai); }
+            static Action* icy_veins(PlayerbotAI* ai) { return new CastIcyVeinsAction(ai); }
+            static Action* combustion(PlayerbotAI* ai) { return new CastCombustionAction(ai); }
+            static Action* ice_block(PlayerbotAI* ai) { return new CastIceBlockAction(ai); }
+            static Action* polymorph(PlayerbotAI* ai) { return new CastPolymorphAction(ai); }
+            static Action* spellsteal(PlayerbotAI* ai) { return new CastSpellstealAction(ai); }
+            static Action* living_bomb(PlayerbotAI* ai) { return new CastLivingBombAction(ai); }
+            static Action* dragons_breath(PlayerbotAI* ai) { return new CastDragonsBreathAction(ai); }
+            static Action* blast_wave(PlayerbotAI* ai) { return new CastBlastWaveAction(ai); }
+            static Action* invisibility(PlayerbotAI* ai) { return new CastInvisibilityAction(ai); }
+            static Action* evocation(PlayerbotAI* ai) { return new CastEvocationAction(ai); }
+            static Action* counterspell_on_enemy_healer(PlayerbotAI* ai) { return new CastCounterspellOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+MageAiObjectContext::MageAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::mage::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageStrategyFactoryInternal());
+    strategyContexts.Add(new ai::mage::MageBuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::mage::AiObjectContextInternal());
+    triggerContexts.Add(new ai::mage::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
new file mode 100644
index 0000000..0fe90e2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class MageAiObjectContext : public AiObjectContext
+    {
+    public:
+        MageAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
new file mode 100644
index 0000000..8ebe45f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageMultipliers.h"
+#include "MageActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageMultipliers.h b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.cpp b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
new file mode 100644
index 0000000..48750fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.cpp
@@ -0,0 +1,15 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "MageTriggers.h"
+#include "MageActions.h"
+
+using namespace ai;
+
+bool MageArmorTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+    return !ai->HasAura("ice armor", target) &&
+        !ai->HasAura("frost armor", target) &&
+        !ai->HasAura("molten armor", target) &&
+        !ai->HasAura("mage armor", target);
+}
diff --git a/src/plugins/playerbot/strategy/mage/MageTriggers.h b/src/plugins/playerbot/strategy/mage/MageTriggers.h
new file mode 100644
index 0000000..a07b4f2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/mage/MageTriggers.h
@@ -0,0 +1,92 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(ArcaneIntellectOnPartyTrigger, "arcane intellect", "arcane intellect on party")
+    BUFF_TRIGGER(ArcaneIntellectTrigger, "arcane intellect", "arcane intellect")
+
+    class MageArmorTrigger : public BuffTrigger {
+    public:
+        MageArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "mage armor") {}
+        virtual bool IsActive();
+    };
+
+    class LivingBombTrigger : public DebuffTrigger {
+    public:
+        LivingBombTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "living bomb") {}
+	};
+
+    class FireballTrigger : public DebuffTrigger {
+    public:
+        FireballTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "fireball") {}
+	};
+
+    class PyroblastTrigger : public DebuffTrigger {
+    public:
+        PyroblastTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "pyroblast") {}
+    };
+
+    class HotStreakTrigger : public HasAuraTrigger {
+    public:
+        HotStreakTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "hot streak") {}
+    };
+
+    class MissileBarrageTrigger : public HasAuraTrigger {
+    public:
+        MissileBarrageTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "missile barrage") {}
+    };
+
+    class ArcaneBlastTrigger : public BuffTrigger {
+    public:
+        ArcaneBlastTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "arcane blast") {}
+    };
+
+    class CounterspellInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        CounterspellInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "counterspell") {}
+    };
+
+    class CombustionTrigger : public BoostTrigger
+    {
+    public:
+        CombustionTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "combustion") {}
+    };
+
+    class IcyVeinsTrigger : public BoostTrigger
+    {
+    public:
+        IcyVeinsTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "icy veins") {}
+    };
+
+    class PolymorphTrigger : public HasCcTargetTrigger
+    {
+    public:
+        PolymorphTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "polymorph") {}
+    };
+
+    class RemoveCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        RemoveCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberRemoveCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberRemoveCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "remove curse", DISPEL_CURSE) {}
+    };
+
+    class SpellstealTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        SpellstealTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "spellsteal", DISPEL_MAGIC) {}
+    };
+
+    class CounterspellEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        CounterspellEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "counterspell") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
new file mode 100644
index 0000000..02c4a57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.cpp
@@ -0,0 +1,83 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "DpsPaladinStrategy.h"
+
+using namespace ai;
+
+class DpsPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsPaladinStrategyActionNodeFactory()
+    {
+        creators["seal of vengeance"] = &seal_of_vengeance;
+        creators["seal of command"] = &seal_of_command;
+        creators["blessing of might"] = &blessing_of_might;
+        creators["crusader strike"] = &crusader_strike;
+    }
+
+private:
+    static ActionNode* seal_of_vengeance(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of vengeance",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of command"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* seal_of_command(PlayerbotAI* ai)
+    {
+        return new ActionNode ("seal of command",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("seal of wisdom"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* blessing_of_might(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of might",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* crusader_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("crusader strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsPaladinStrategy::DpsPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsPaladinStrategyActionNodeFactory());
+}
+
+NextAction** DpsPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("crusader strike", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+    
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine shield", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "judgement of wisdom",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of might", ACTION_HIGH + 8), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("divine storm", ACTION_HIGH + 1), new NextAction("consecration", ACTION_HIGH + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"art of war",
+		NextAction::array(0, new NextAction("exorcism", ACTION_HIGH + 2), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
new file mode 100644
index 0000000..cff5fd2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/DpsPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class DpsPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        DpsPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
new file mode 100644
index 0000000..fda1619
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPaladinNonCombatStrategy::GenericPaladinNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "blessing of kings on party",
+        NextAction::array(0, new NextAction("blessing of kings on party", 11.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("redemption", 30.0f), NULL)));
+
+	 triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("holy light", 50.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure magic",
+        NextAction::array(0, new NextAction("cleanse magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure magic",
+        NextAction::array(0, new NextAction("cleanse magic on party", 40.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
new file mode 100644
index 0000000..cf03f6d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericPaladinNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+   };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
new file mode 100644
index 0000000..d218be1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.cpp
@@ -0,0 +1,77 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericPaladinStrategy.h"
+#include "GenericPaladinStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+
+GenericPaladinStrategy::GenericPaladinStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPaladinStrategyActionNodeFactory());
+}
+
+void GenericPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash of light", ACTION_MEDIUM_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash of light on party", ACTION_MEDIUM_HEAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("divine protection", ACTION_CRITICAL_HEAL + 2), new NextAction("holy light", ACTION_CRITICAL_HEAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("holy light on party", ACTION_CRITICAL_HEAL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice interrupt",
+		NextAction::array(0, new NextAction("hammer of justice", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hammer of justice on enemy healer",
+		NextAction::array(0, new NextAction("hammer of justice on enemy healer", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("lay on hands", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member critical health",
+		NextAction::array(0, new NextAction("lay on hands on party", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("hammer of wrath", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure disease",
+        NextAction::array(0, new NextAction("cleanse disease", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure disease",
+        NextAction::array(0, new NextAction("cleanse disease on party", ACTION_DISPEL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse cure poison",
+        NextAction::array(0, new NextAction("cleanse poison", ACTION_DISPEL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse party member cure poison",
+        NextAction::array(0, new NextAction("cleanse poison on party", ACTION_DISPEL + 1), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse cure magic",
+		NextAction::array(0, new NextAction("cleanse magic", ACTION_DISPEL + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"cleanse party member cure magic",
+		NextAction::array(0, new NextAction("cleanse magic on party", ACTION_DISPEL + 1), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
new file mode 100644
index 0000000..000f785
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "PaladinAiObjectContext.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class GenericPaladinStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "paladin"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
new file mode 100644
index 0000000..560784d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/GenericPaladinStrategyActionNodeFactory.h
@@ -0,0 +1,142 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPaladinStrategyActionNodeFactory()
+        {
+            creators["seal of light"] = &seal_of_light;
+            creators["cleanse poison"] = &cleanse_poison;
+            creators["cleanse disease"] = &cleanse_disease;
+            creators["cleanse magic"] = &cleanse_magic;
+            creators["cleanse poison on party"] = &cleanse_poison_on_party;
+            creators["cleanse disease on party"] = &cleanse_disease_on_party;
+            creators["seal of wisdom"] = &seal_of_wisdom;
+            creators["seal of justice"] = &seal_of_justice;
+            creators["hand of reckoning"] = &hand_of_reckoning;
+            creators["judgement of wisdom"] = &judgement_of_wisdom;
+            creators["divine shield"] = &divine_shield;
+            creators["flash of light"] = &flash_of_light;
+            creators["flash of light on party"] = &flash_of_light_on_party;
+            creators["holy wrath"] = &holy_wrath;
+            creators["lay on hands"] = &lay_on_hands;
+            creators["lay on hands on party"] = &lay_on_hands_on_party;
+        }
+    private:
+        static ActionNode* lay_on_hands(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine shield"), new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lay_on_hands_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lay on hands on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flash of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_magic(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse magic",
+                /*P*/ NULL,
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_poison_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse poison on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify poison on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* cleanse_disease_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("cleanse disease on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("purify disease on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* seal_of_justice(PlayerbotAI* ai)
+        {
+            return new ActionNode ("seal of justice",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("seal of righteousness"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* hand_of_reckoning(PlayerbotAI* ai)
+        {
+            return new ActionNode ("hand of reckoning",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of justice"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* judgement_of_wisdom(PlayerbotAI* ai)
+        {
+            return new ActionNode ("judgement of wisdom",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("judgement of light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("divine protection"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_of_light_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash of light on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("holy light on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_wrath(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy wrath",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("consecration"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+};
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
new file mode 100644
index 0000000..47def40
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinActions.h b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
new file mode 100644
index 0000000..78f782c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinActions.h
@@ -0,0 +1,365 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastJudgementOfLightAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfLightAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of light") {}
+    };
+
+    class CastJudgementOfWisdomAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfWisdomAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of wisdom") {}
+    };
+
+    class CastJudgementOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastJudgementOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "judgement of justice") {}
+    };
+
+	class CastRighteousFuryAction : public CastBuffSpellAction
+	{
+	public:
+		CastRighteousFuryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "righteous fury") {}
+	};
+
+	class CastDevotionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastDevotionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "devotion aura") {}
+	};
+
+	class CastRetributionAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastRetributionAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "retribution aura") {}
+	};
+
+	class CastConcentrationAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastConcentrationAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "concentration aura") {}
+	};
+
+	class CastDivineStormAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineStormAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine storm") {}
+	};
+
+	class CastCrusaderStrikeAction : public CastMeleeSpellAction
+	{
+	public:
+		CastCrusaderStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "crusader strike") {}
+	};
+
+	class CastShadowResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastShadowResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadow resistance aura") {}
+	};
+
+	class CastFrostResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFrostResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "frost resistance aura") {}
+	};
+
+	class CastFireResistanceAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastFireResistanceAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fire resistance aura") {}
+	};
+
+	class CastCrusaderAuraAction : public CastBuffSpellAction
+	{
+	public:
+		CastCrusaderAuraAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "crusader aura") {}
+	};
+
+	class CastSealOfRighteousnessAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfRighteousnessAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of righteousness") {}
+	};
+
+	class CastSealOfJusticeAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfJusticeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of justice") {}
+	};
+
+
+	class CastSealOfLightAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfLightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of light") {}
+	};
+
+	class CastSealOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of wisdom") {}
+	};
+
+	class CastSealOfCommandAction : public CastBuffSpellAction
+	{
+	public:
+		CastSealOfCommandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of command") {}
+	};
+
+	class CastSealOfVengeanceAction : public CastBuffSpellAction
+	{
+	public:
+	    CastSealOfVengeanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "seal of vengeance") {}
+	};
+
+
+	class CastBlessingOfMightAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfMightAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of might") {}
+	};
+
+	class CastBlessingOfMightOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfMightOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of might") {}
+        virtual string getName() { return "blessing of might on party";}
+	};
+
+	class CastBlessingOfWisdomAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfWisdomAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of wisdom") {}
+	};
+
+	class CastBlessingOfWisdomOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfWisdomOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of wisdom") {}
+        virtual string getName() { return "blessing of wisdom on party";}
+	};
+
+	class CastBlessingOfKingsAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfKingsAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of kings") {}
+	};
+
+	class CastBlessingOfKingsOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfKingsOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of kings") {}
+        virtual string getName() { return "blessing of kings on party";}
+	};
+
+	class CastBlessingOfSanctuaryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBlessingOfSanctuaryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blessing of sanctuary") {}
+	};
+
+	class CastBlessingOfSanctuaryOnPartyAction : public BuffOnPartyAction
+	{
+	public:
+		CastBlessingOfSanctuaryOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "blessing of sanctuary") {}
+        virtual string getName() { return "blessing of sanctuary on party";}
+	};
+
+    class CastHolyLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastHolyLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "holy light") {}
+    };
+
+    class CastHolyLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHolyLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "holy light") {}
+
+        virtual string getName() { return "holy light on party"; }
+    };
+
+    class CastFlashOfLightAction : public CastHealingSpellAction
+    {
+    public:
+        CastFlashOfLightAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash of light") {}
+    };
+
+    class CastFlashOfLightOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashOfLightOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash of light") {}
+
+        virtual string getName() { return "flash of light on party"; }
+    };
+
+    class CastLayOnHandsAction : public CastHealingSpellAction
+    {
+    public:
+        CastLayOnHandsAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lay on hands") {}
+    };
+
+    class CastLayOnHandsOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLayOnHandsOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lay on hands") {}
+
+        virtual string getName() { return "lay on hands on party"; }
+    };
+
+	class CastDivineProtectionAction : public CastBuffSpellAction
+	{
+	public:
+		CastDivineProtectionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine protection") {}
+	};
+
+    class CastDivineProtectionOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastDivineProtectionOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "divine protection") {}
+
+        virtual string getName() { return "divine protection on party"; }
+    };
+
+	class CastDivineShieldAction: public CastBuffSpellAction
+	{
+	public:
+		CastDivineShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine shield") {}
+	};
+
+    class CastConsecrationAction : public CastMeleeSpellAction
+    {
+    public:
+	    CastConsecrationAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "consecration") {}
+    };
+
+    class CastHolyWrathAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHolyWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "holy wrath") {}
+    };
+
+    class CastHammerOfJusticeAction : public CastMeleeSpellAction
+    {
+    public:
+        CastHammerOfJusticeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of justice") {}
+    };
+
+	class CastHammerOfWrathAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfWrathAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of wrath") {}
+	};
+
+	class CastHammerOfTheRighteousAction : public CastMeleeSpellAction
+	{
+	public:
+		CastHammerOfTheRighteousAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hammer of the righteous") {}
+	};
+
+	class CastPurifyPoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyPoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+	class CastPurifyDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastPurifyDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "purify") {}
+	};
+
+    class CastPurifyPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastPurifyPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_POISON) {}
+
+        virtual string getName() { return "purify poison on party"; }
+    };
+
+	class CastPurifyDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastPurifyDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "purify", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "purify disease on party"; }
+	};
+
+	class CastHandOfReckoningAction : public CastSpellAction
+	{
+	public:
+		CastHandOfReckoningAction(PlayerbotAI* ai) : CastSpellAction(ai, "hand of reckoning") {}
+	};
+
+	class CastCleansePoisonAction : public CastCureSpellAction
+	{
+	public:
+		CastCleansePoisonAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseDiseaseAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+	class CastCleanseMagicAction : public CastCureSpellAction
+	{
+	public:
+		CastCleanseMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse") {}
+	};
+
+    class CastCleansePoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleansePoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse poison on party"; }
+    };
+
+	class CastCleanseDiseaseOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_DISEASE) {}
+
+		virtual string getName() { return "cleanse disease on party"; }
+	};
+
+	class CastCleanseMagicOnPartyAction : public CurePartyMemberAction
+	{
+	public:
+		CastCleanseMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse", DISPEL_MAGIC) {}
+
+		virtual string getName() { return "cleanse magic on party"; }
+	};
+
+    BEGIN_SPELL_ACTION(CastAvengersShieldAction, "avenger's shield")
+    END_SPELL_ACTION()
+
+	BEGIN_SPELL_ACTION(CastExorcismAction, "exorcism")
+	END_SPELL_ACTION()
+
+	class CastHolyShieldAction : public CastBuffSpellAction
+	{
+	public:
+		CastHolyShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "holy shield") {}
+	};
+
+	class CastRedemptionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastRedemptionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "redemption") {}
+	};
+
+    class CastHammerOfJusticeOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastHammerOfJusticeOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
new file mode 100644
index 0000000..37c7468
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.cpp
@@ -0,0 +1,279 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinActions.h"
+#include "PaladinTriggers.h"
+#include "PaladinAiObjectContext.h"
+#include "GenericPaladinNonCombatStrategy.h"
+#include "TankPaladinStrategy.h"
+#include "DpsPaladinStrategy.h"
+#include "PaladinBuffStrategies.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &paladin::StrategyFactoryInternal::nc;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericPaladinNonCombatStrategy(ai); }
+        };
+
+        class ResistanceStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            ResistanceStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["rshadow"] = &paladin::ResistanceStrategyFactoryInternal::rshadow;
+                creators["rfrost"] = &paladin::ResistanceStrategyFactoryInternal::rfrost;
+                creators["rfire"] = &paladin::ResistanceStrategyFactoryInternal::rfire;
+            }
+
+        private:
+            static Strategy* rshadow(PlayerbotAI* ai) { return new PaladinShadowResistanceStrategy(ai); }
+            static Strategy* rfrost(PlayerbotAI* ai) { return new PaladinFrostResistanceStrategy(ai); }
+            static Strategy* rfire(PlayerbotAI* ai) { return new PaladinFireResistanceStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bhealth"] = &paladin::BuffStrategyFactoryInternal::bhealth;
+                creators["bmana"] = &paladin::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &paladin::BuffStrategyFactoryInternal::bdps;
+                creators["barmor"] = &paladin::BuffStrategyFactoryInternal::barmor;
+                creators["bspeed"] = &paladin::BuffStrategyFactoryInternal::bspeed;
+            }
+
+        private:
+            static Strategy* bhealth(PlayerbotAI* ai) { return new PaladinBuffHealthStrategy(ai); }
+            static Strategy* bmana(PlayerbotAI* ai) { return new PaladinBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new PaladinBuffDpsStrategy(ai); }
+            static Strategy* barmor(PlayerbotAI* ai) { return new PaladinBuffArmorStrategy(ai); }
+            static Strategy* bspeed(PlayerbotAI* ai) { return new PaladinBuffSpeedStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &paladin::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &paladin::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankPaladinStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsPaladinStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["judgement of wisdom"] = &TriggerFactoryInternal::judgement_of_wisdom;
+                creators["judgement of light"] = &TriggerFactoryInternal::judgement_of_light;
+                creators["blessing"] = &TriggerFactoryInternal::blessing;
+                creators["seal"] = &TriggerFactoryInternal::seal;
+                creators["art of war"] = &TriggerFactoryInternal::art_of_war;
+                creators["blessing of kings on party"] = &TriggerFactoryInternal::blessing_of_kings_on_party;
+                creators["crusader aura"] = &TriggerFactoryInternal::crusader_aura;
+                creators["retribution aura"] = &TriggerFactoryInternal::retribution_aura;
+                creators["devotion aura"] = &TriggerFactoryInternal::devotion_aura;
+                creators["shadow resistance aura"] = &TriggerFactoryInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &TriggerFactoryInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &TriggerFactoryInternal::fire_resistance_aura;
+                creators["hammer of justice snare"] = &TriggerFactoryInternal::hammer_of_justice_snare;
+                creators["hammer of justice interrupt"] = &TriggerFactoryInternal::hammer_of_justice_interrupt;
+                creators["cleanse cure disease"] = &TriggerFactoryInternal::CleanseCureDisease;
+                creators["cleanse party member cure disease"] = &TriggerFactoryInternal::CleanseCurePartyMemberDisease;
+                creators["cleanse cure poison"] = &TriggerFactoryInternal::CleanseCurePoison;
+                creators["cleanse party member cure poison"] = &TriggerFactoryInternal::CleanseCurePartyMemberPoison;
+                creators["cleanse cure magic"] = &TriggerFactoryInternal::CleanseCureMagic;
+                creators["cleanse party member cure magic"] = &TriggerFactoryInternal::CleanseCurePartyMemberMagic;
+                creators["righteous fury"] = &TriggerFactoryInternal::righteous_fury;
+                creators["holy shield"] = &TriggerFactoryInternal::holy_shield;
+                creators["hammer of justice on enemy healer"] = &TriggerFactoryInternal::hammer_of_justice_on_enemy_target;
+            }
+
+        private:
+            static Trigger* holy_shield(PlayerbotAI* ai) { return new HolyShieldTrigger(ai); }
+            static Trigger* righteous_fury(PlayerbotAI* ai) { return new RighteousFuryTrigger(ai); }
+            static Trigger* judgement_of_wisdom(PlayerbotAI* ai) { return new JudgementOfWisdomTrigger(ai); }
+            static Trigger* judgement_of_light(PlayerbotAI* ai) { return new JudgementOfLightTrigger(ai); }
+            static Trigger* blessing(PlayerbotAI* ai) { return new BlessingTrigger(ai); }
+            static Trigger* seal(PlayerbotAI* ai) { return new SealTrigger(ai); }
+            static Trigger* art_of_war(PlayerbotAI* ai) { return new ArtOfWarTrigger(ai); }
+            static Trigger* blessing_of_kings_on_party(PlayerbotAI* ai) { return new BlessingOfKingsOnPartyTrigger(ai); }
+            static Trigger* crusader_aura(PlayerbotAI* ai) { return new CrusaderAuraTrigger(ai); }
+            static Trigger* retribution_aura(PlayerbotAI* ai) { return new RetributionAuraTrigger(ai); }
+            static Trigger* devotion_aura(PlayerbotAI* ai) { return new DevotionAuraTrigger(ai); }
+            static Trigger* shadow_resistance_aura(PlayerbotAI* ai) { return new ShadowResistanceAuraTrigger(ai); }
+            static Trigger* frost_resistance_aura(PlayerbotAI* ai) { return new FrostResistanceAuraTrigger(ai); }
+            static Trigger* fire_resistance_aura(PlayerbotAI* ai) { return new FireResistanceAuraTrigger(ai); }
+            static Trigger* hammer_of_justice_snare(PlayerbotAI* ai) { return new HammerOfJusticeSnareTrigger(ai); }
+            static Trigger* hammer_of_justice_interrupt(PlayerbotAI* ai) { return new HammerOfJusticeInterruptSpellTrigger(ai); }
+            static Trigger* CleanseCureDisease(PlayerbotAI* ai) { return new CleanseCureDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberDisease(PlayerbotAI* ai) { return new CleanseCurePartyMemberDiseaseTrigger(ai); }
+            static Trigger* CleanseCurePoison(PlayerbotAI* ai) { return new CleanseCurePoisonTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberPoison(PlayerbotAI* ai) { return new CleanseCurePartyMemberPoisonTrigger(ai); }
+            static Trigger* CleanseCureMagic(PlayerbotAI* ai) { return new CleanseCureMagicTrigger(ai); }
+            static Trigger* CleanseCurePartyMemberMagic(PlayerbotAI* ai) { return new CleanseCurePartyMemberMagicTrigger(ai); }
+            static Trigger* hammer_of_justice_on_enemy_target(PlayerbotAI* ai) { return new HammerOfJusticeEnemyHealerTrigger(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace paladin
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["seal of command"] = &AiObjectContextInternal::seal_of_command;
+                creators["seal of vengeance"] = &AiObjectContextInternal::seal_of_vengeance;
+                creators["blessing of might"] = &AiObjectContextInternal::blessing_of_might;
+                creators["divine storm"] = &AiObjectContextInternal::divine_storm;
+                creators["blessing of kings on party"] = &AiObjectContextInternal::blessing_of_kings_on_party;
+                creators["redemption"] = &AiObjectContextInternal::redemption;
+                creators["crusader strike"] = &AiObjectContextInternal::crusader_strike;
+                creators["crusader aura"] = &AiObjectContextInternal::crusader_aura;
+                creators["seal of light"] = &AiObjectContextInternal::seal_of_light;
+                creators["devotion aura"] = &AiObjectContextInternal::devotion_aura;
+                creators["holy wrath"] = &AiObjectContextInternal::holy_wrath;
+                creators["consecration"] = &AiObjectContextInternal::consecration;
+                creators["cleanse disease"] = &AiObjectContextInternal::cleanse_disease;
+                creators["cleanse poison"] = &AiObjectContextInternal::cleanse_poison;
+                creators["cleanse magic"] = &AiObjectContextInternal::cleanse_magic;
+                creators["purify disease"] = &AiObjectContextInternal::purify_disease;
+                creators["purify poison"] = &AiObjectContextInternal::purify_poison;
+                creators["cleanse poison on party"] = &AiObjectContextInternal::cleanse_poison_on_party;
+                creators["cleanse disease on party"] = &AiObjectContextInternal::cleanse_disease_on_party;
+                creators["cleanse magic on party"] = &AiObjectContextInternal::cleanse_magic_on_party;
+                creators["purify poison on party"] = &AiObjectContextInternal::purify_poison_on_party;
+                creators["purify disease on party"] = &AiObjectContextInternal::purify_disease_on_party;
+                creators["seal of wisdom"] = &AiObjectContextInternal::seal_of_wisdom;
+                creators["seal of justice"] = &AiObjectContextInternal::seal_of_justice;
+                creators["seal of righteousness"] = &AiObjectContextInternal::seal_of_righteousness;
+                creators["flash of light"] = &AiObjectContextInternal::flash_of_light;
+                creators["hand of reckoning"] = &AiObjectContextInternal::hand_of_reckoning;
+                creators["avenger's shield"] = &AiObjectContextInternal::avengers_shield;
+                creators["exorcism"] = &AiObjectContextInternal::exorcism;
+                creators["judgement of light"] = &AiObjectContextInternal::judgement_of_light;
+                creators["judgement of wisdom"] = &AiObjectContextInternal::judgement_of_wisdom;
+                creators["divine shield"] = &AiObjectContextInternal::divine_shield;
+                creators["divine protection"] = &AiObjectContextInternal::divine_protection;
+                creators["divine protection on party"] =&AiObjectContextInternal::divine_protection_on_party;
+                creators["hammer of justice"] = &AiObjectContextInternal::hammer_of_justice;
+                creators["flash of light on party"] = &AiObjectContextInternal::flash_of_light_on_party;
+                creators["holy light"] = &AiObjectContextInternal::holy_light;
+                creators["holy light on party"] = &AiObjectContextInternal::holy_light_on_party;
+                creators["lay on hands"] = &AiObjectContextInternal::lay_on_hands;
+                creators["lay on hands on party"] = &AiObjectContextInternal::lay_on_hands_on_party;
+                creators["judgement of justice"] = &AiObjectContextInternal::judgement_of_justice;
+                creators["hammer of wrath"] = &AiObjectContextInternal::hammer_of_wrath;
+                creators["holy shield"] = &AiObjectContextInternal::holy_shield;
+                creators["hammer of the righteous"] = &AiObjectContextInternal::hammer_of_the_righteous;
+                creators["blessing of kings"] = &AiObjectContextInternal::blessing_of_kings;
+                creators["retribution aura"] = &AiObjectContextInternal::retribution_aura;
+                creators["shadow resistance aura"] = &AiObjectContextInternal::shadow_resistance_aura;
+                creators["frost resistance aura"] = &AiObjectContextInternal::frost_resistance_aura;
+                creators["fire resistance aura"] = &AiObjectContextInternal::fire_resistance_aura;
+                creators["righteous fury"] = &AiObjectContextInternal::righteous_fury;
+                creators["blessing of sanctuary"] = &AiObjectContextInternal::blessing_of_sanctuary;
+                creators["hammer of justice on enemy healer"] = &AiObjectContextInternal::hammer_of_justice_on_enemy_healer;
+            }
+
+        private:
+            static Action* righteous_fury(PlayerbotAI* ai) { return new CastRighteousFuryAction(ai); }
+            static Action* blessing_of_sanctuary(PlayerbotAI* ai) { return new CastBlessingOfSanctuaryAction(ai); }
+            static Action* seal_of_command(PlayerbotAI* ai) { return new CastSealOfCommandAction(ai); }
+            static Action* seal_of_vengeance(PlayerbotAI* ai) { return new CastSealOfVengeanceAction(ai); }
+            static Action* blessing_of_might(PlayerbotAI* ai) { return new CastBlessingOfMightAction(ai); }
+            static Action* divine_storm(PlayerbotAI* ai) { return new CastDivineStormAction(ai); }
+            static Action* blessing_of_kings_on_party(PlayerbotAI* ai) { return new CastBlessingOfKingsOnPartyAction(ai); }
+            static Action* redemption(PlayerbotAI* ai) { return new CastRedemptionAction(ai); }
+            static Action* crusader_strike(PlayerbotAI* ai) { return new CastCrusaderStrikeAction(ai); }
+            static Action* crusader_aura(PlayerbotAI* ai) { return new CastCrusaderAuraAction(ai); }
+            static Action* seal_of_light(PlayerbotAI* ai) { return new CastSealOfLightAction(ai); }
+            static Action* devotion_aura(PlayerbotAI* ai) { return new CastDevotionAuraAction(ai); }
+            static Action* holy_wrath(PlayerbotAI* ai) { return new CastHolyWrathAction(ai); }
+            static Action* consecration(PlayerbotAI* ai) { return new CastConsecrationAction(ai); }
+            static Action* cleanse_poison(PlayerbotAI* ai) { return new CastCleansePoisonAction(ai); }
+            static Action* cleanse_disease(PlayerbotAI* ai) { return new CastCleanseDiseaseAction(ai); }
+            static Action* cleanse_magic(PlayerbotAI* ai) { return new CastCleanseMagicAction(ai); }
+            static Action* purify_poison(PlayerbotAI* ai) { return new CastPurifyPoisonAction(ai); }
+            static Action* purify_disease(PlayerbotAI* ai) { return new CastPurifyDiseaseAction(ai); }
+            static Action* cleanse_poison_on_party(PlayerbotAI* ai) { return new CastCleansePoisonOnPartyAction(ai); }
+            static Action* cleanse_disease_on_party(PlayerbotAI* ai) { return new CastCleanseDiseaseOnPartyAction(ai); }
+            static Action* cleanse_magic_on_party(PlayerbotAI* ai) { return new CastCleanseMagicOnPartyAction(ai); }
+            static Action* purify_poison_on_party(PlayerbotAI* ai) { return new CastPurifyPoisonOnPartyAction(ai); }
+            static Action* purify_disease_on_party(PlayerbotAI* ai) { return new CastPurifyDiseaseOnPartyAction(ai); }
+            static Action* seal_of_wisdom(PlayerbotAI* ai) { return new CastSealOfWisdomAction(ai); }
+            static Action* seal_of_justice(PlayerbotAI* ai) { return new CastSealOfJusticeAction(ai); }
+            static Action* seal_of_righteousness(PlayerbotAI* ai) { return new CastSealOfRighteousnessAction(ai); }
+            static Action* flash_of_light(PlayerbotAI* ai) { return new CastFlashOfLightAction(ai); }
+            static Action* hand_of_reckoning(PlayerbotAI* ai) { return new CastHandOfReckoningAction(ai); }
+            static Action* avengers_shield(PlayerbotAI* ai) { return new CastAvengersShieldAction(ai); }
+            static Action* exorcism(PlayerbotAI* ai) { return new CastExorcismAction(ai); }
+            static Action* judgement_of_light(PlayerbotAI* ai) { return new CastJudgementOfLightAction(ai); }
+            static Action* judgement_of_wisdom(PlayerbotAI* ai) { return new CastJudgementOfWisdomAction(ai); }
+            static Action* divine_shield(PlayerbotAI* ai) { return new CastDivineShieldAction(ai); }
+            static Action* divine_protection(PlayerbotAI* ai) { return new CastDivineProtectionAction(ai); }
+            static Action* divine_protection_on_party(PlayerbotAI* ai) { return new CastDivineProtectionOnPartyAction(ai); }
+            static Action* hammer_of_justice(PlayerbotAI* ai) { return new CastHammerOfJusticeAction(ai); }
+            static Action* flash_of_light_on_party(PlayerbotAI* ai) { return new CastFlashOfLightOnPartyAction(ai); }
+            static Action* holy_light(PlayerbotAI* ai) { return new CastHolyLightAction(ai); }
+            static Action* holy_light_on_party(PlayerbotAI* ai) { return new CastHolyLightOnPartyAction(ai); }
+            static Action* lay_on_hands(PlayerbotAI* ai) { return new CastLayOnHandsAction(ai); }
+            static Action* lay_on_hands_on_party(PlayerbotAI* ai) { return new CastLayOnHandsOnPartyAction(ai); }
+            static Action* judgement_of_justice(PlayerbotAI* ai) { return new CastJudgementOfJusticeAction(ai); }
+            static Action* hammer_of_wrath(PlayerbotAI* ai) { return new CastHammerOfWrathAction(ai); }
+            static Action* holy_shield(PlayerbotAI* ai) { return new CastHolyShieldAction(ai); }
+            static Action* hammer_of_the_righteous(PlayerbotAI* ai) { return new CastHammerOfTheRighteousAction(ai); }
+            static Action* blessing_of_kings(PlayerbotAI* ai) { return new CastBlessingOfKingsAction(ai); }
+            static Action* retribution_aura(PlayerbotAI* ai) { return new CastRetributionAuraAction(ai); }
+            static Action* shadow_resistance_aura(PlayerbotAI* ai) { return new CastShadowResistanceAuraAction(ai); }
+            static Action* frost_resistance_aura(PlayerbotAI* ai) { return new CastFrostResistanceAuraAction(ai); }
+            static Action* fire_resistance_aura(PlayerbotAI* ai) { return new CastFireResistanceAuraAction(ai); }
+            static Action* hammer_of_justice_on_enemy_healer(PlayerbotAI* ai) { return new CastHammerOfJusticeOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+PaladinAiObjectContext::PaladinAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::paladin::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::BuffStrategyFactoryInternal());
+    strategyContexts.Add(new ai::paladin::ResistanceStrategyFactoryInternal());
+    actionContexts.Add(new ai::paladin::AiObjectContextInternal());
+    triggerContexts.Add(new ai::paladin::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
new file mode 100644
index 0000000..1af3343
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PaladinAiObjectContext : public AiObjectContext
+    {
+    public:
+        PaladinAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
new file mode 100644
index 0000000..5124024
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.cpp
@@ -0,0 +1,72 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinBuffStrategies.h"
+
+using namespace ai;
+
+void PaladinBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of wisdom", 90.0f), NULL)));
+}
+
+void PaladinBuffHealthStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 90.0f), NULL)));
+}
+
+void PaladinBuffSpeedStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "crusader aura",
+        NextAction::array(0, new NextAction("crusader aura", 40.0f), NULL)));
+}
+
+void PaladinBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of vengeance", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"retribution aura",
+		NextAction::array(0, new NextAction("retribution aura", 90.0f), NULL)));
+}
+
+void PaladinShadowResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"shadow resistance aura",
+		NextAction::array(0, new NextAction("shadow resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFrostResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"frost resistance aura",
+		NextAction::array(0, new NextAction("frost resistance aura", 90.0f), NULL)));
+}
+
+void PaladinFireResistanceStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+	triggers.push_back(new TriggerNode(
+		"fire resistance aura",
+		NextAction::array(0, new NextAction("fire resistance aura", 90.0f), NULL)));
+}
+
+
+void PaladinBuffArmorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "seal",
+        NextAction::array(0, new NextAction("seal of light", 89.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"devotion aura",
+		NextAction::array(0, new NextAction("devotion aura", 90.0f), NULL)));
+}
+
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
new file mode 100644
index 0000000..e5051a1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinBuffStrategies.h
@@ -0,0 +1,86 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class PaladinBuffManaStrategy : public Strategy
+    {
+    public:
+        PaladinBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+    };
+
+    class PaladinBuffHealthStrategy : public Strategy
+    {
+    public:
+        PaladinBuffHealthStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bhealth"; }
+    };
+
+    class PaladinBuffDpsStrategy : public Strategy
+    {
+    public:
+        PaladinBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+    };
+
+	class PaladinBuffArmorStrategy : public Strategy
+	{
+	public:
+		PaladinBuffArmorStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "barmor"; }
+	};
+
+	class PaladinBuffSpeedStrategy : public Strategy
+	{
+	public:
+		PaladinBuffSpeedStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "bspeed"; }
+	};
+
+	class PaladinShadowResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinShadowResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rshadow"; }
+	};
+
+	class PaladinFrostResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFrostResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfrost"; }
+	};
+
+	class PaladinFireResistanceStrategy : public Strategy
+	{
+	public:
+		PaladinFireResistanceStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+	public:
+		virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+		virtual string getName() { return "rfire"; }
+	};
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
new file mode 100644
index 0000000..3082abb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
new file mode 100644
index 0000000..1948441
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinTriggers.h"
+#include "PaladinActions.h"
+
+using namespace ai;
+
+bool SealTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("seal of justice", target) &&
+        !ai->HasAura("seal of command", target) &&
+        !ai->HasAura("seal of vengeance", target) &&
+		!ai->HasAura("seal of righteousness", target) &&
+		!ai->HasAura("seal of light", target) &&
+		!ai->HasAura("seal of wisdom", target);
+}
+
+bool CrusaderAuraTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return AI_VALUE2(bool, "mounted", "self target") && !ai->HasAura("crusader aura", target);
+}
diff --git a/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
new file mode 100644
index 0000000..3f53b4e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/PaladinTriggers.h
@@ -0,0 +1,114 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	BUFF_TRIGGER(HolyShieldTrigger, "holy shield", "holy shield")
+    BUFF_TRIGGER(RighteousFuryTrigger, "righteous fury", "righteous fury")
+
+    BUFF_TRIGGER(RetributionAuraTrigger, "retribution aura", "retribution aura")
+
+	class CrusaderAuraTrigger : public BuffTrigger
+	{
+	public:
+		CrusaderAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "crusader aura") {}
+		virtual bool IsActive();
+	};
+
+	class SealTrigger : public BuffTrigger
+	{
+	public:
+		SealTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "seal of justice") {}
+		virtual bool IsActive();
+	};
+
+    DEBUFF_TRIGGER(JudgementOfLightTrigger, "judgement of light", "judgement of light")
+    DEBUFF_TRIGGER(JudgementOfWisdomTrigger, "judgement of wisdom", "judgement of wisdom")
+
+    BUFF_ON_PARTY_TRIGGER(BlessingOfKingsOnPartyTrigger, "blessing of kings", "blessing of kings on party")
+    BUFF_TRIGGER(BlessingTrigger, "blessing of sanctuary", "blessing of sanctuary")
+
+    class HammerOfJusticeInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        HammerOfJusticeInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "hammer of justice") {}
+    };
+
+    class HammerOfJusticeSnareTrigger : public SnareTargetTrigger
+    {
+    public:
+        HammerOfJusticeSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hammer of justice") {}
+    };
+
+    class ArtOfWarTrigger : public HasAuraTrigger
+    {
+    public:
+        ArtOfWarTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "the art of war") {}
+    };
+
+    class ShadowResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        ShadowResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadow resistance aura") {}
+    };
+
+    class FrostResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FrostResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "frost resistance aura") {}
+    };
+
+    class FireResistanceAuraTrigger : public BuffTrigger
+    {
+    public:
+        FireResistanceAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "fire resistance aura") {}
+    };
+
+    class DevotionAuraTrigger : public BuffTrigger
+    {
+    public:
+        DevotionAuraTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "devotion aura") {}
+    };
+
+    class CleanseCureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePartyMemberDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_DISEASE) {}
+    };
+
+    class CleanseCurePoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCurePoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCurePartyMemberPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_POISON) {}
+    };
+
+    class CleanseCureMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseCureMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class CleanseCurePartyMemberMagicTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        CleanseCurePartyMemberMagicTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse", DISPEL_MAGIC) {}
+    };
+
+    class HammerOfJusticeEnemyHealerTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        HammerOfJusticeEnemyHealerTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "hammer of justice") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
new file mode 100644
index 0000000..6e6b51f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PaladinMultipliers.h"
+#include "TankPaladinStrategy.h"
+
+using namespace ai;
+
+class TankPaladinStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankPaladinStrategyActionNodeFactory()
+    {
+        creators["blessing of sanctuary"] = &blessing_of_sanctuary;
+    }
+private:
+    static ActionNode* blessing_of_sanctuary(PlayerbotAI* ai)
+    {
+        return new ActionNode ("blessing of sanctuary",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("blessing of kings"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankPaladinStrategy::TankPaladinStrategy(PlayerbotAI* ai) : GenericPaladinStrategy(ai)
+{
+    actionNodeFactories.Add(new TankPaladinStrategyActionNodeFactory());
+}
+
+NextAction** TankPaladinStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("melee", ACTION_NORMAL), NULL);
+}
+
+void TankPaladinStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPaladinStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "judgement of light",
+        NextAction::array(0, new NextAction("judgement of light", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium mana",
+        NextAction::array(0, new NextAction("judgement of wisdom", ACTION_NORMAL + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "righteous fury",
+        NextAction::array(0, new NextAction("righteous fury", ACTION_HIGH + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("hammer of the righteous", ACTION_HIGH + 6), new NextAction("avenger's shield", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("consecration", ACTION_HIGH + 6), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("hand of reckoning", ACTION_HIGH + 7), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"holy shield",
+		NextAction::array(0, new NextAction("holy shield", ACTION_HIGH + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "blessing",
+        NextAction::array(0, new NextAction("blessing of sanctuary", ACTION_HIGH + 9), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
new file mode 100644
index 0000000..d5cf955
--- /dev/null
+++ b/src/plugins/playerbot/strategy/paladin/TankPaladinStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPaladinStrategy.h"
+
+namespace ai
+{
+    class TankPaladinStrategy : public GenericPaladinStrategy
+    {
+    public:
+        TankPaladinStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+		virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
new file mode 100644
index 0000000..19103da
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.cpp
@@ -0,0 +1,67 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+#include "GenericPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+GenericPriestStrategy::GenericPriestStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericPriestStrategyActionNodeFactory());
+}
+
+void GenericPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("flash heal", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member medium health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("flash heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("flash heal on party", 60.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("power word: shield", 60.0f), new NextAction("greater heal", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("power word: shield on party", 50.0f), new NextAction("greater heal on party", 50.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "medium threat",
+        NextAction::array(0, new NextAction("psychic scream", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
new file mode 100644
index 0000000..4633e8d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericPriestStrategy : public CombatStrategy
+    {
+    public:
+        GenericPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..d3ef00b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/GenericPriestStrategyActionNodeFactory.h
@@ -0,0 +1,173 @@
+#pragma once
+
+namespace ai
+{
+    class GenericPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        GenericPriestStrategyActionNodeFactory()
+        {
+            creators["inner fire"] = &inner_fire;
+            creators["holy nova"] = &holy_nova;
+            creators["power word: fortitude"] = &power_word_fortitude;
+            creators["power word: fortitude on party"] = &power_word_fortitude_on_party;
+            creators["divine spirit"] = &divine_spirit;
+            creators["divine spirit on party"] = &divine_spirit_on_party;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["psychic scream"] = &psychic_scream;
+            creators["fade"] = &fade;
+        }
+    private:
+        static ActionNode* inner_fire(PlayerbotAI* ai)
+        {
+            return new ActionNode ("inner fire",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_fortitude_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: fortitude on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* divine_spirit_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("divine spirit on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("greater heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* psychic_scream(PlayerbotAI* ai)
+        {
+            return new ActionNode ("psychic scream",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("fade"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* fade(PlayerbotAI* ai)
+        {
+            return new ActionNode ("fade",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("flee"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
new file mode 100644
index 0000000..68e6f37
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HealPriestStrategy.h"
+
+using namespace ai;
+
+NextAction** HealPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void HealPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "almost full health",
+        NextAction::array(0, new NextAction("renew", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member almost full health",
+        NextAction::array(0, new NextAction("renew on party", 10.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for spell",
+        NextAction::array(0, new NextAction("fade", 50.0f), new NextAction("flee", 49.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
new file mode 100644
index 0000000..7f5603f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HealPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericPriestStrategy.h"
+
+namespace ai
+{
+    class HealPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        HealPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
new file mode 100644
index 0000000..abeea31
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.cpp
@@ -0,0 +1,46 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "HolyPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        HolyPriestStrategyActionNodeFactory()
+        {
+            creators["smite"] = &smite;
+        }
+    private:
+        static ActionNode* smite(PlayerbotAI* ai)
+        {
+            return new ActionNode ("smite",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
+
+using namespace ai;
+
+HolyPriestStrategy::HolyPriestStrategy(PlayerbotAI* ai) : HealPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new HolyPriestStrategyActionNodeFactory());
+}
+
+NextAction** HolyPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("holy fire", 10.0f), new NextAction("smite", 10.0f), NULL);
+}
+
+void HolyPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    HealPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
new file mode 100644
index 0000000..c21bcf1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/HolyPriestStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class HolyPriestStrategy : public HealPriestStrategy
+    {
+    public:
+        HolyPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "holy"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.cpp b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
new file mode 100644
index 0000000..8760005
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
+
+NextAction** CastAbolishDiseaseAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease"), NULL), CastSpellAction::getAlternatives());
+}
+
+NextAction** CastAbolishDiseaseOnPartyAction::getAlternatives()
+{
+    return NextAction::merge(NextAction::array(0, new NextAction("cure disease on party"), NULL), CastSpellAction::getAlternatives());
+}
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestActions.h b/src/plugins/playerbot/strategy/priest/PriestActions.h
new file mode 100644
index 0000000..bf2ea2d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestActions.h
@@ -0,0 +1,246 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastGreaterHealAction : public CastHealingSpellAction {
+    public:
+        CastGreaterHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "greater heal") {}
+    };
+
+    class CastGreaterHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastGreaterHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "greater heal") {}
+
+        virtual string getName() { return "greater heal on party"; }
+    };
+
+    class CastLesserHealAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser heal") {}
+    };
+
+    class CastLesserHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser heal") {}
+
+        virtual string getName() { return "lesser heal on party"; }
+    };
+
+    class CastFlashHealAction : public CastHealingSpellAction {
+    public:
+        CastFlashHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "flash heal") {}
+    };
+
+    class CastFlashHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastFlashHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "flash heal") {}
+
+        virtual string getName() { return "flash heal on party"; }
+    };
+
+    class CastHealAction : public CastHealingSpellAction {
+    public:
+        CastHealAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "heal") {}
+    };
+
+    class CastHealOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "heal") {}
+
+        virtual string getName() { return "heal on party"; }
+    };
+
+    class CastRenewAction : public CastHealingSpellAction {
+    public:
+        CastRenewAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "renew") {}
+    };
+
+    class CastRenewOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRenewOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "renew") {}
+
+        virtual string getName() { return "renew on party"; }
+    };
+
+    class CastFadeAction : public CastBuffSpellAction {
+    public:
+        CastFadeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fade") {}
+    };
+
+    class CastShadowformAction : public CastBuffSpellAction {
+    public:
+        CastShadowformAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shadowform") {}
+    };
+
+    class CastRemoveShadowformAction : public Action {
+    public:
+        CastRemoveShadowformAction(PlayerbotAI* ai) : Action(ai, "remove shadowform") {}
+        virtual bool isUseful() { return ai->HasAura("shadowform", AI_VALUE(Unit*, "self target")); }
+        virtual bool isPossible() { return true; }
+        virtual bool Execute(Event event) {
+            ai->RemoveAura("shadowform");
+            return true;
+        }
+    };
+
+	class CastVampiricEmbraceAction : public CastBuffSpellAction {
+	public:
+		CastVampiricEmbraceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vampiric embrace") {}
+	};
+
+	class CastPowerWordShieldAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: shield") {}
+	};
+
+    class CastPowerWordShieldOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastPowerWordShieldOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "power word: shield") {}
+
+        virtual string getName() { return "power word: shield on party"; }
+    };
+
+	class CastPowerWordFortitudeAction : public CastBuffSpellAction {
+	public:
+		CastPowerWordFortitudeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritAction : public CastBuffSpellAction {
+	public:
+		CastDivineSpiritAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "divine spirit") {}
+	};
+
+	class CastInnerFireAction : public CastBuffSpellAction {
+	public:
+		CastInnerFireAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "inner fire") {}
+	};
+
+    BEGIN_SPELL_ACTION(CastHolyNovaAction, "holy nova")
+    virtual bool isUseful() {
+        return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+    }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastHolyFireAction, "holy fire")
+        virtual bool isUseful() {
+            return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastSmiteAction, "smite")
+        virtual bool isUseful() {
+			return !ai->HasAura("shadowform", AI_VALUE(Unit*, "self target"));
+        }
+    END_SPELL_ACTION()
+
+	class CastPowerWordFortitudeOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastPowerWordFortitudeOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "power word: fortitude") {}
+	};
+
+	class CastDivineSpiritOnPartyAction : public BuffOnPartyAction {
+	public:
+		CastDivineSpiritOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "divine spirit") {}
+	};
+
+	class CastPowerWordPainAction : public CastDebuffSpellAction
+	{
+    public:
+	    CastPowerWordPainAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "shadow word: pain") {}
+	};
+
+	class CastPowerWordPainOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+    public:
+	    CastPowerWordPainOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "shadow word: pain") {}
+	};
+
+    BEGIN_DEBUFF_ACTION(CastDevouringPlagueAction, "devouring plague")
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastVampiricTouchAction, "vampiric touch")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindBlastAction, "mind blast")
+    END_SPELL_ACTION()
+
+    BEGIN_RANGED_SPELL_ACTION(CastMindFlayAction, "mind flay")
+    END_SPELL_ACTION()
+
+	class CastCureDiseaseAction : public CastCureSpellAction {
+	public:
+		CastCureDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cure disease") {}
+	};
+
+    class CastCureDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCureDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cure disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "cure disease on party"; }
+    };
+
+	class CastAbolishDiseaseAction : public CastCureSpellAction {
+	public:
+		CastAbolishDiseaseAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "abolish disease") {}
+		virtual NextAction** getAlternatives();
+	};
+
+    class CastAbolishDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastAbolishDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "abolish disease", DISPEL_DISEASE) {}
+        virtual string getName() { return "abolish disease on party"; }
+        virtual NextAction** getAlternatives();
+    };
+
+	class CastDispelMagicAction : public CastCureSpellAction {
+	public:
+		CastDispelMagicAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "dispel magic") {}
+	};
+
+    class CastDispelMagicOnTargetAction : public CastSpellAction {
+    public:
+        CastDispelMagicOnTargetAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispel magic") {}
+    };
+
+    class CastDispelMagicOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastDispelMagicOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "dispel magic", DISPEL_MAGIC) {}
+        virtual string getName() { return "dispel magic on party"; }
+    };
+
+	class CastResurrectionAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastResurrectionAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "resurrection") {}
+	};
+
+	class CastCircleOfHealingAction : public CastAoeHealSpellAction
+	{
+	public:
+		CastCircleOfHealingAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "circle of healing") {}
+	};
+
+	class CastPsychicScreamAction : public CastSpellAction
+	{
+	public:
+	    CastPsychicScreamAction(PlayerbotAI* ai) : CastSpellAction(ai, "psychic scream") {}
+	};
+
+	class CastDispersionAction : public CastSpellAction
+	{
+	public:
+	    CastDispersionAction(PlayerbotAI* ai) : CastSpellAction(ai, "dispersion") {}
+	    virtual string GetTargetName() { return "self target"; }
+	};
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
new file mode 100644
index 0000000..8a40b2b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.cpp
@@ -0,0 +1,217 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestActions.h"
+#include "PriestAiObjectContext.h"
+#include "PriestNonCombatStrategy.h"
+#include "ShadowPriestStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "PriestTriggers.h"
+#include "../NamedObjectContext.h"
+#include "HolyPriestStrategy.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &priest::StrategyFactoryInternal::nc;
+                creators["pull"] = &priest::StrategyFactoryInternal::pull;
+                creators["aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["shadow aoe"] = &priest::StrategyFactoryInternal::shadow_aoe;
+                creators["dps debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+                creators["shadow debuff"] = &priest::StrategyFactoryInternal::shadow_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new PriestNonCombatStrategy(ai); }
+            static Strategy* shadow_aoe(PlayerbotAI* ai) { return new ShadowPriestAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+            static Strategy* shadow_debuff(PlayerbotAI* ai) { return new ShadowPriestDebuffStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &priest::CombatStrategyFactoryInternal::heal;
+                creators["shadow"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &priest::CombatStrategyFactoryInternal::dps;
+                creators["holy"] = &priest::CombatStrategyFactoryInternal::holy;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealPriestStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new ShadowPriestStrategy(ai); }
+            static Strategy* holy(PlayerbotAI* ai) { return new HolyPriestStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["devouring plague"] = &TriggerFactoryInternal::devouring_plague;
+                creators["shadow word: pain"] = &TriggerFactoryInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &TriggerFactoryInternal::shadow_word_pain_on_attacker;
+                creators["dispel magic"] = &TriggerFactoryInternal::dispel_magic;
+                creators["dispel magic on party"] = &TriggerFactoryInternal::dispel_magic_party_member;
+                creators["cure disease"] = &TriggerFactoryInternal::cure_disease;
+                creators["party member cure disease"] = &TriggerFactoryInternal::party_member_cure_disease;
+                creators["power word: fortitude"] = &TriggerFactoryInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &TriggerFactoryInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &TriggerFactoryInternal::divine_spirit;
+                creators["divine spirit on party"] = &TriggerFactoryInternal::divine_spirit_on_party;
+                creators["inner fire"] = &TriggerFactoryInternal::inner_fire;
+                creators["vampiric touch"] = &TriggerFactoryInternal::vampiric_touch;
+                creators["shadowform"] = &TriggerFactoryInternal::shadowform;
+                creators["vampiric embrace"] = &TriggerFactoryInternal::vampiric_embrace;
+
+            }
+
+        private:
+            static Trigger* vampiric_embrace(PlayerbotAI* ai) { return new VampiricEmbraceTrigger(ai); }
+            static Trigger* shadowform(PlayerbotAI* ai) { return new ShadowformTrigger(ai); }
+            static Trigger* vampiric_touch(PlayerbotAI* ai) { return new VampiricTouchTrigger(ai); }
+            static Trigger* devouring_plague(PlayerbotAI* ai) { return new DevouringPlagueTrigger(ai); }
+            static Trigger* shadow_word_pain(PlayerbotAI* ai) { return new PowerWordPainTrigger(ai); }
+            static Trigger* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new PowerWordPainOnAttackerTrigger(ai); }
+            static Trigger* dispel_magic(PlayerbotAI* ai) { return new DispelMagicTrigger(ai); }
+            static Trigger* dispel_magic_party_member(PlayerbotAI* ai) { return new DispelMagicPartyMemberTrigger(ai); }
+            static Trigger* cure_disease(PlayerbotAI* ai) { return new CureDiseaseTrigger(ai); }
+            static Trigger* party_member_cure_disease(PlayerbotAI* ai) { return new PartyMemberCureDiseaseTrigger(ai); }
+            static Trigger* power_word_fortitude(PlayerbotAI* ai) { return new PowerWordFortitudeTrigger(ai); }
+            static Trigger* power_word_fortitude_on_party(PlayerbotAI* ai) { return new PowerWordFortitudeOnPartyTrigger(ai); }
+            static Trigger* divine_spirit(PlayerbotAI* ai) { return new DivineSpiritTrigger(ai); }
+            static Trigger* divine_spirit_on_party(PlayerbotAI* ai) { return new DivineSpiritOnPartyTrigger(ai); }
+            static Trigger* inner_fire(PlayerbotAI* ai) { return new InnerFireTrigger(ai); }
+        };
+    };
+};
+
+
+
+namespace ai
+{
+    namespace priest
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["shadow word: pain"] = &AiObjectContextInternal::shadow_word_pain;
+                creators["shadow word: pain on attacker"] = &AiObjectContextInternal::shadow_word_pain_on_attacker;
+                creators["devouring plague"] = &AiObjectContextInternal::devouring_plague;
+                creators["mind flay"] = &AiObjectContextInternal::mind_flay;
+                creators["holy fire"] = &AiObjectContextInternal::holy_fire;
+                creators["smite"] = &AiObjectContextInternal::smite;
+                creators["mind blast"] = &AiObjectContextInternal::mind_blast;
+                creators["shadowform"] = &AiObjectContextInternal::shadowform;
+                creators["remove shadowform"] = &AiObjectContextInternal::remove_shadowform;
+                creators["holy nova"] = &AiObjectContextInternal::holy_nova;
+                creators["power word: fortitude"] = &AiObjectContextInternal::power_word_fortitude;
+                creators["power word: fortitude on party"] = &AiObjectContextInternal::power_word_fortitude_on_party;
+                creators["divine spirit"] = &AiObjectContextInternal::divine_spirit;
+                creators["divine spirit on party"] = &AiObjectContextInternal::divine_spirit_on_party;
+                creators["power word: shield"] = &AiObjectContextInternal::power_word_shield;
+                creators["power word: shield on party"] = &AiObjectContextInternal::power_word_shield_on_party;
+                creators["renew"] = &AiObjectContextInternal::renew;
+                creators["renew on party"] = &AiObjectContextInternal::renew_on_party;
+                creators["greater heal"] = &AiObjectContextInternal::greater_heal;
+                creators["greater heal on party"] = &AiObjectContextInternal::greater_heal_on_party;
+                creators["heal"] = &AiObjectContextInternal::heal;
+                creators["heal on party"] = &AiObjectContextInternal::heal_on_party;
+                creators["lesser heal"] = &AiObjectContextInternal::lesser_heal;
+                creators["lesser heal on party"] = &AiObjectContextInternal::lesser_heal_on_party;
+                creators["flash heal"] = &AiObjectContextInternal::flash_heal;
+                creators["flash heal on party"] = &AiObjectContextInternal::flash_heal_on_party;
+                creators["dispel magic"] = &AiObjectContextInternal::dispel_magic;
+                creators["dispel magic on party"] = &AiObjectContextInternal::dispel_magic_on_party;
+                creators["dispel magic on target"] = &AiObjectContextInternal::dispel_magic_on_target;
+                creators["cure disease"] = &AiObjectContextInternal::cure_disease;
+                creators["cure disease on party"] = &AiObjectContextInternal::cure_disease_on_party;
+                creators["abolish disease"] = &AiObjectContextInternal::abolish_disease;
+                creators["abolish disease on party"] = &AiObjectContextInternal::abolish_disease_on_party;
+                creators["fade"] = &AiObjectContextInternal::fade;
+                creators["inner fire"] = &AiObjectContextInternal::inner_fire;
+                creators["resurrection"] = &AiObjectContextInternal::resurrection;
+                creators["circle of healing"] = &AiObjectContextInternal::circle_of_healing;
+                creators["psychic scream"] = &AiObjectContextInternal::psychic_scream;
+                creators["vampiric touch"] = &AiObjectContextInternal::vampiric_touch;
+                creators["vampiric embrace"] = &AiObjectContextInternal::vampiric_embrace;
+                creators["dispersion"] = &AiObjectContextInternal::dispersion;
+            }
+
+        private:
+            static Action* dispersion(PlayerbotAI* ai) { return new CastDispersionAction(ai); }
+            static Action* vampiric_embrace(PlayerbotAI* ai) { return new CastVampiricEmbraceAction(ai); }
+            static Action* vampiric_touch(PlayerbotAI* ai) { return new CastVampiricTouchAction(ai); }
+            static Action* psychic_scream(PlayerbotAI* ai) { return new CastPsychicScreamAction(ai); }
+            static Action* circle_of_healing(PlayerbotAI* ai) { return new CastCircleOfHealingAction(ai); }
+            static Action* resurrection(PlayerbotAI* ai) { return new CastResurrectionAction(ai); }
+            static Action* shadow_word_pain(PlayerbotAI* ai) { return new CastPowerWordPainAction(ai); }
+            static Action* shadow_word_pain_on_attacker(PlayerbotAI* ai) { return new CastPowerWordPainOnAttackerAction(ai); }
+            static Action* devouring_plague(PlayerbotAI* ai) { return new CastDevouringPlagueAction(ai); }
+            static Action* mind_flay(PlayerbotAI* ai) { return new CastMindFlayAction(ai); }
+            static Action* holy_fire(PlayerbotAI* ai) { return new CastHolyFireAction(ai); }
+            static Action* smite(PlayerbotAI* ai) { return new CastSmiteAction(ai); }
+            static Action* mind_blast(PlayerbotAI* ai) { return new CastMindBlastAction(ai); }
+            static Action* shadowform(PlayerbotAI* ai) { return new CastShadowformAction(ai); }
+            static Action* remove_shadowform(PlayerbotAI* ai) { return new CastRemoveShadowformAction(ai); }
+            static Action* holy_nova(PlayerbotAI* ai) { return new CastHolyNovaAction(ai); }
+            static Action* power_word_fortitude(PlayerbotAI* ai) { return new CastPowerWordFortitudeAction(ai); }
+            static Action* power_word_fortitude_on_party(PlayerbotAI* ai) { return new CastPowerWordFortitudeOnPartyAction(ai); }
+            static Action* divine_spirit(PlayerbotAI* ai) { return new CastDivineSpiritAction(ai); }
+            static Action* divine_spirit_on_party(PlayerbotAI* ai) { return new CastDivineSpiritOnPartyAction(ai); }
+            static Action* power_word_shield(PlayerbotAI* ai) { return new CastPowerWordShieldAction(ai); }
+            static Action* power_word_shield_on_party(PlayerbotAI* ai) { return new CastPowerWordShieldOnPartyAction(ai); }
+            static Action* renew(PlayerbotAI* ai) { return new CastRenewAction(ai); }
+            static Action* renew_on_party(PlayerbotAI* ai) { return new CastRenewOnPartyAction(ai); }
+            static Action* greater_heal(PlayerbotAI* ai) { return new CastGreaterHealAction(ai); }
+            static Action* greater_heal_on_party(PlayerbotAI* ai) { return new CastGreaterHealOnPartyAction(ai); }
+            static Action* heal(PlayerbotAI* ai) { return new CastHealAction(ai); }
+            static Action* heal_on_party(PlayerbotAI* ai) { return new CastHealOnPartyAction(ai); }
+            static Action* lesser_heal(PlayerbotAI* ai) { return new CastLesserHealAction(ai); }
+            static Action* lesser_heal_on_party(PlayerbotAI* ai) { return new CastLesserHealOnPartyAction(ai); }
+            static Action* flash_heal(PlayerbotAI* ai) { return new CastFlashHealAction(ai); }
+            static Action* flash_heal_on_party(PlayerbotAI* ai) { return new CastFlashHealOnPartyAction(ai); }
+            static Action* dispel_magic(PlayerbotAI* ai) { return new CastDispelMagicAction(ai); }
+            static Action* dispel_magic_on_party(PlayerbotAI* ai) { return new CastDispelMagicOnPartyAction(ai); }
+            static Action* dispel_magic_on_target(PlayerbotAI* ai) { return new CastDispelMagicOnTargetAction(ai); }
+            static Action* cure_disease(PlayerbotAI* ai) { return new CastCureDiseaseAction(ai); }
+            static Action* cure_disease_on_party(PlayerbotAI* ai) { return new CastCureDiseaseOnPartyAction(ai); }
+            static Action* abolish_disease(PlayerbotAI* ai) { return new CastAbolishDiseaseAction(ai); }
+            static Action* abolish_disease_on_party(PlayerbotAI* ai) { return new CastAbolishDiseaseOnPartyAction(ai); }
+            static Action* fade(PlayerbotAI* ai) { return new CastFadeAction(ai); }
+            static Action* inner_fire(PlayerbotAI* ai) { return new CastInnerFireAction(ai); }
+        };
+    };
+};
+
+PriestAiObjectContext::PriestAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::priest::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::priest::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::priest::AiObjectContextInternal());
+    triggerContexts.Add(new ai::priest::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
new file mode 100644
index 0000000..315c335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class PriestAiObjectContext : public AiObjectContext
+    {
+    public:
+        PriestAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
new file mode 100644
index 0000000..fced53e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestMultipliers.h b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
new file mode 100644
index 0000000..a4d846b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "PriestNonCombatStrategy.h"
+#include "PriestNonCombatStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+PriestNonCombatStrategy::PriestNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new PriestNonCombatStrategyActionNodeFactory());
+}
+
+void PriestNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude",
+        NextAction::array(0, new NextAction("power word: fortitude", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "power word: fortitude on party",
+        NextAction::array(0, new NextAction("power word: fortitude on party", 11.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit",
+        NextAction::array(0, new NextAction("divine spirit", 14.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "divine spirit on party",
+        NextAction::array(0, new NextAction("divine spirit on party", 13.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "inner fire",
+        NextAction::array(0, new NextAction("inner fire", 10.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("power word: shield", 70.0f), new NextAction("greater heal", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("power word: shield on party", 60.0f), new NextAction("greater heal on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low health",
+        NextAction::array(0, new NextAction("flash heal", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member low health",
+        NextAction::array(0, new NextAction("flash heal on party", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("circle of healing", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("resurrection", 30.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic",
+        NextAction::array(0, new NextAction("dispel magic", 41.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "dispel magic on party",
+        NextAction::array(0, new NextAction("dispel magic on party", 40.0f), NULL)));
+
+
+    triggers.push_back(new TriggerNode(
+        "cure disease",
+        NextAction::array(0, new NextAction("abolish disease", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cure disease",
+        NextAction::array(0, new NextAction("abolish disease on party", 30.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
new file mode 100644
index 0000000..da82e1a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class PriestNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        PriestNonCombatStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "nc"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
new file mode 100644
index 0000000..05edd68
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestNonCombatStrategyActionNodeFactory.h
@@ -0,0 +1,126 @@
+#pragma once
+
+namespace ai
+{
+    class PriestNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        PriestNonCombatStrategyActionNodeFactory()
+        {
+            creators["holy nova"] = &holy_nova;
+            creators["power word: shield"] = &power_word_shield;
+            creators["power word: shield on party"] = &power_word_shield_on_party;
+            creators["renew"] = &renew;
+            creators["renew on party"] = &renew_on_party;
+            creators["greater heal"] = &greater_heal;
+            creators["greater heal on party"] = &greater_heal_on_party;
+            creators["heal"] = &heal;
+            creators["heal on party"] = &heal_on_party;
+            creators["lesser heal"] = &lesser_heal;
+            creators["lesser heal on party"] = &lesser_heal_on_party;
+            creators["flash heal"] = &flash_heal;
+            creators["flash heal on party"] = &flash_heal_on_party;
+            creators["circle of healing"] = &circle_of_healing;
+        }
+    private:
+        static ActionNode* holy_nova(PlayerbotAI* ai)
+        {
+            return new ActionNode ("holy nova",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* power_word_shield_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("power word: shield on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("renew on party", 50.0f), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* renew(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* renew_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("renew on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* greater_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("greater heal on party",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("lesser heal on party"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* lesser_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("lesser heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* flash_heal_on_party(PlayerbotAI* ai)
+        {
+            return new ActionNode ("flash heal on party",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NULL,
+                /*C*/ NULL);
+        }
+        static ActionNode* circle_of_healing(PlayerbotAI* ai)
+        {
+            return new ActionNode ("circle of healing",
+                /*P*/ NextAction::array(0, new NextAction("remove shadowform"), NULL),
+                /*A*/ NextAction::array(0, new NextAction("flash heal on party"), NULL),
+                /*C*/ NULL);
+        }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
new file mode 100644
index 0000000..941041c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestTriggers.h"
+#include "PriestActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/priest/PriestTriggers.h b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
new file mode 100644
index 0000000..83b43c2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/PriestTriggers.h
@@ -0,0 +1,54 @@
+#pragma once
+
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_ON_PARTY_TRIGGER(PowerWordFortitudeOnPartyTrigger, "power word: fortitude", "power word: fortitude on party")
+    BUFF_TRIGGER(PowerWordFortitudeTrigger, "power word: fortitude", "power word: fortitude")
+
+    BUFF_ON_PARTY_TRIGGER(DivineSpiritOnPartyTrigger, "divine spirit", "divine spirit on party")
+    BUFF_TRIGGER(DivineSpiritTrigger, "divine spirit", "divine spirit")
+    BUFF_TRIGGER(InnerFireTrigger, "inner fire", "inner fire")
+    BUFF_TRIGGER(VampiricEmbraceTrigger, "vampiric embrace", "vampiric embrace")
+
+    class PowerWordPainOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        PowerWordPainOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "shadow word: pain") {}
+    };
+
+    DEBUFF_TRIGGER(PowerWordPainTrigger, "shadow word: pain", "shadow word: pain")
+    DEBUFF_TRIGGER(DevouringPlagueTrigger, "devouring plague", "devouring plague")
+    DEBUFF_TRIGGER(VampiricTouchTrigger, "vampiric touch", "vampiric touch")
+
+    class DispelMagicTrigger : public NeedCureTrigger
+    {
+    public:
+        DispelMagicTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class DispelMagicPartyMemberTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        DispelMagicPartyMemberTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "dispel magic", DISPEL_MAGIC) {}
+    };
+
+    class CureDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CureDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCureDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCureDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cure disease", DISPEL_DISEASE) {}
+    };
+
+    class ShadowformTrigger : public BuffTrigger {
+    public:
+        ShadowformTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "shadowform") {}
+        virtual bool IsActive() { return !ai->HasAura("shadowform", bot); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
new file mode 100644
index 0000000..718794c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PriestMultipliers.h"
+#include "ShadowPriestStrategy.h"
+#include "ShadowPriestStrategyActionNodeFactory.h"
+
+using namespace ai;
+
+ShadowPriestStrategy::ShadowPriestStrategy(PlayerbotAI* ai) : GenericPriestStrategy(ai)
+{
+    actionNodeFactories.Add(new ShadowPriestStrategyActionNodeFactory());
+}
+
+NextAction** ShadowPriestStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("mind blast", 10.0f), NULL);
+}
+
+void ShadowPriestStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericPriestStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadowform",
+        NextAction::array(0, new NextAction("shadowform", 15.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("dispersion", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric embrace",
+        NextAction::array(0, new NextAction("vampiric embrace", 16.0f), NULL)));
+}
+
+void ShadowPriestAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain on attacker",
+        NextAction::array(0, new NextAction("shadow word: pain on attacker", 11.0f), NULL)));
+}
+
+void ShadowPriestDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "devouring plague",
+        NextAction::array(0, new NextAction("devouring plague", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "vampiric touch",
+        NextAction::array(0, new NextAction("vampiric touch", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shadow word: pain",
+        NextAction::array(0, new NextAction("shadow word: pain", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
new file mode 100644
index 0000000..3097f4a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategy.h
@@ -0,0 +1,38 @@
+#pragma once
+
+#include "HealPriestStrategy.h"
+
+namespace ai
+{
+    class ShadowPriestStrategy : public GenericPriestStrategy
+    {
+    public:
+        ShadowPriestStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual NextAction** getDefaultActions();
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow"; }
+        virtual int GetType() { return STRATEGY_TYPE_DPS|STRATEGY_TYPE_RANGED; }
+    };
+
+    class ShadowPriestAoeStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow aoe"; }
+    };
+
+    class ShadowPriestDebuffStrategy : public CombatStrategy
+    {
+    public:
+        ShadowPriestDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "shadow debuff"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
new file mode 100644
index 0000000..1b9c533
--- /dev/null
+++ b/src/plugins/playerbot/strategy/priest/ShadowPriestStrategyActionNodeFactory.h
@@ -0,0 +1,37 @@
+#pragma once
+
+namespace ai
+{
+    class ShadowPriestStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+    {
+    public:
+        ShadowPriestStrategyActionNodeFactory()
+        {
+            creators["mind flay"] = &mind_flay;
+            creators["mind blast"] = &mind_blast;
+            creators["dispersion"] = &dispersion;
+        }
+    private:
+        static ActionNode* mind_flay(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind flay",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* mind_blast(PlayerbotAI* ai)
+        {
+            return new ActionNode ("mind blast",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mind flay"), NULL),
+                /*C*/ NULL);
+        }
+        static ActionNode* dispersion(PlayerbotAI* ai)
+        {
+            return new ActionNode ("dispersion",
+                /*P*/ NULL,
+                /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+                /*C*/ NULL);
+        }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
new file mode 100644
index 0000000..650ac60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.cpp
@@ -0,0 +1,110 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "DpsRogueStrategy.h"
+
+using namespace ai;
+
+class DpsRogueStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsRogueStrategyActionNodeFactory()
+    {
+        creators["riposte"] = &riposte;
+        creators["mutilate"] = &mutilate;
+        creators["sinister strike"] = &sinister_strike;
+        creators["kick"] = &kick;
+        creators["kidney shot"] = &kidney_shot;
+        creators["rupture"] = &rupture;
+        creators["backstab"] = &backstab;
+    }
+private:
+    static ActionNode* riposte(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riposte",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mutilate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mutilate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sinister strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* sinister_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("sinister strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kick(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kick",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("kidney shot"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* kidney_shot(PlayerbotAI* ai)
+    {
+        return new ActionNode ("kidney shot",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* rupture(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rupture",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("eviscerate"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* backstab(PlayerbotAI* ai)
+    {
+        return new ActionNode ("backstab",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mutilate"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsRogueStrategy::DpsRogueStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsRogueStrategyActionNodeFactory());
+}
+
+NextAction** DpsRogueStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("riposte", ACTION_NORMAL), NULL);
+}
+
+void DpsRogueStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "combo points available",
+        NextAction::array(0, new NextAction("rupture", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium threat",
+		NextAction::array(0, new NextAction("vanish", ACTION_HIGH), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("evasion", ACTION_EMERGENCY), new NextAction("feint", ACTION_EMERGENCY), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick",
+		NextAction::array(0, new NextAction("kick", ACTION_INTERRUPT + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"kick on enemy healer",
+		NextAction::array(0, new NextAction("kick on enemy healer", ACTION_INTERRUPT + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "behind target",
+        NextAction::array(0, new NextAction("backstab", ACTION_NORMAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
new file mode 100644
index 0000000..77e2249
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/DpsRogueStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class DpsRogueStrategy : public MeleeCombatStrategy
+    {
+    public:
+        DpsRogueStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
new file mode 100644
index 0000000..0afb767
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.cpp
@@ -0,0 +1,14 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueMultipliers.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
+void GenericRogueNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+        
+}
diff --git a/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
new file mode 100644
index 0000000..2d78612
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/GenericRogueNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericRogueNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericRogueNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+    
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.cpp b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
new file mode 100644
index 0000000..aba6061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/rogue/RogueActions.h b/src/plugins/playerbot/strategy/rogue/RogueActions.h
new file mode 100644
index 0000000..a7a78eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueActions.h
@@ -0,0 +1,82 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+#include "RogueComboActions.h"
+#include "RogueOpeningActions.h"
+#include "RogueFinishingActions.h"
+
+namespace ai
+{
+	class CastEvasionAction : public CastBuffSpellAction
+	{
+	public:
+		CastEvasionAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "evasion") {}
+	};
+
+	class CastSprintAction : public CastBuffSpellAction
+	{
+	public:
+		CastSprintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "sprint") {}
+	};
+
+	class CastKickAction : public CastSpellAction
+	{
+	public:
+		CastKickAction(PlayerbotAI* ai) : CastSpellAction(ai, "kick") {}
+	};
+
+	class CastFeintAction : public CastBuffSpellAction
+	{
+	public:
+		CastFeintAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "feint") {}
+	};
+
+	class CastDismantleAction : public CastSpellAction
+	{
+	public:
+		CastDismantleAction(PlayerbotAI* ai) : CastSpellAction(ai, "dismantle") {}
+	};
+
+	class CastDistractAction : public CastSpellAction
+	{
+	public:
+		CastDistractAction(PlayerbotAI* ai) : CastSpellAction(ai, "distract") {}
+	};
+
+	class CastVanishAction : public CastBuffSpellAction
+	{
+	public:
+		CastVanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "vanish") {}
+	};
+
+	class CastBlindAction : public CastDebuffSpellAction
+	{
+	public:
+		CastBlindAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "blind") {}
+	};
+
+
+	class CastBladeFlurryAction : public CastBuffSpellAction
+	{
+	public:
+		CastBladeFlurryAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "blade flurry") {}
+	};
+
+	class CastAdrenalineRushAction : public CastBuffSpellAction
+	{
+	public:
+		CastAdrenalineRushAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "adrenaline rush") {}
+	};
+
+	class CastKillingSpreeAction : public CastBuffSpellAction
+	{
+	public:
+		CastKillingSpreeAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "killing spree") {}
+	};
+
+    class CastKickOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastKickOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
new file mode 100644
index 0000000..fdca0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.cpp
@@ -0,0 +1,119 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueActions.h"
+#include "RogueTriggers.h"
+#include "RogueAiObjectContext.h"
+#include "DpsRogueStrategy.h"
+#include "GenericRogueNonCombatStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["dps"] = &rogue::StrategyFactoryInternal::dps;
+                creators["nc"] = &rogue::StrategyFactoryInternal::nc;
+                creators["pull"] = &rogue::StrategyFactoryInternal::pull;
+            }
+
+        private:
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsRogueStrategy(ai); }
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericRogueNonCombatStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["kick"] = &TriggerFactoryInternal::kick;
+                creators["rupture"] = &TriggerFactoryInternal::rupture;
+                creators["slice and dice"] = &TriggerFactoryInternal::slice_and_dice;
+                creators["expose armor"] = &TriggerFactoryInternal::expose_armor;
+                creators["kick on enemy healer"] = &TriggerFactoryInternal::kick_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* kick(PlayerbotAI* ai) { return new KickInterruptSpellTrigger(ai); }
+            static Trigger* rupture(PlayerbotAI* ai) { return new RuptureTrigger(ai); }
+            static Trigger* slice_and_dice(PlayerbotAI* ai) { return new SliceAndDiceTrigger(ai); }
+            static Trigger* expose_armor(PlayerbotAI* ai) { return new ExposeArmorTrigger(ai); }
+            static Trigger* kick_on_enemy_healer(PlayerbotAI* ai) { return new KickInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace rogue
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["riposte"] = &AiObjectContextInternal::riposte;
+                creators["mutilate"] = &AiObjectContextInternal::mutilate;
+                creators["sinister strike"] = &AiObjectContextInternal::sinister_strike;
+                creators["kidney shot"] = &AiObjectContextInternal::kidney_shot;
+                creators["rupture"] = &AiObjectContextInternal::rupture;
+                creators["slice and dice"] = &AiObjectContextInternal::slice_and_dice;
+                creators["eviscerate"] = &AiObjectContextInternal::eviscerate;
+                creators["vanish"] = &AiObjectContextInternal::vanish;
+                creators["evasion"] = &AiObjectContextInternal::evasion;
+                creators["kick"] = &AiObjectContextInternal::kick;
+                creators["feint"] = &AiObjectContextInternal::feint;
+                creators["backstab"] = &AiObjectContextInternal::backstab;
+                creators["expose armor"] = &AiObjectContextInternal::expose_armor;
+                creators["kick on enemy healer"] = &AiObjectContextInternal::kick_on_enemy_healer;
+            }
+
+        private:
+            static Action* riposte(PlayerbotAI* ai) { return new CastRiposteAction(ai); }
+            static Action* mutilate(PlayerbotAI* ai) { return new CastMutilateAction(ai); }
+            static Action* sinister_strike(PlayerbotAI* ai) { return new CastSinisterStrikeAction(ai); }
+            static Action* kidney_shot(PlayerbotAI* ai) { return new CastKidneyShotAction(ai); }
+            static Action* rupture(PlayerbotAI* ai) { return new CastRuptureAction(ai); }
+            static Action* slice_and_dice(PlayerbotAI* ai) { return new CastSliceAndDiceAction(ai); }
+            static Action* eviscerate(PlayerbotAI* ai) { return new CastEviscerateAction(ai); }
+            static Action* vanish(PlayerbotAI* ai) { return new CastVanishAction(ai); }
+            static Action* evasion(PlayerbotAI* ai) { return new CastEvasionAction(ai); }
+            static Action* kick(PlayerbotAI* ai) { return new CastKickAction(ai); }
+            static Action* feint(PlayerbotAI* ai) { return new CastFeintAction(ai); }
+            static Action* backstab(PlayerbotAI* ai) { return new CastBackstabAction(ai); }
+            static Action* expose_armor(PlayerbotAI* ai) { return new CastExposeArmorAction(ai); }
+            static Action* kick_on_enemy_healer(PlayerbotAI* ai) { return new CastKickOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+RogueAiObjectContext::RogueAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::rogue::StrategyFactoryInternal());
+    actionContexts.Add(new ai::rogue::AiObjectContextInternal());
+    triggerContexts.Add(new ai::rogue::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
new file mode 100644
index 0000000..ba34626
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class RogueAiObjectContext : public AiObjectContext
+    {
+    public:
+        RogueAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueComboActions.h b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
new file mode 100644
index 0000000..186e2eb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueComboActions.h
@@ -0,0 +1,45 @@
+#pragma once
+
+namespace ai
+{
+	class CastComboAction : public CastMeleeSpellAction
+	{
+	public:
+	    CastComboAction(PlayerbotAI* ai, string name) : CastMeleeSpellAction(ai, name) {}
+
+	    virtual bool isUseful()
+	    {
+	        return CastMeleeSpellAction::isUseful() && AI_VALUE2(uint8, "combo", "self target") < 5;
+	    }
+	};
+
+	class CastSinisterStrikeAction : public CastComboAction
+	{
+	public:
+		CastSinisterStrikeAction(PlayerbotAI* ai) : CastComboAction(ai, "sinister strike") {}
+	};
+
+    class CastMutilateAction : public CastComboAction
+    {
+    public:
+        CastMutilateAction(PlayerbotAI* ai) : CastComboAction(ai, "mutilate") {}
+    };
+
+    class CastRiposteAction : public CastComboAction
+    {
+    public:
+        CastRiposteAction(PlayerbotAI* ai) : CastComboAction(ai, "riposte") {}
+    };
+
+	class CastGougeAction : public CastComboAction
+	{
+	public:
+		CastGougeAction(PlayerbotAI* ai) : CastComboAction(ai, "gouge") {}
+	};
+
+    class CastBackstabAction : public CastComboAction
+    {
+    public:
+        CastBackstabAction(PlayerbotAI* ai) : CastComboAction(ai, "backstab") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
new file mode 100644
index 0000000..91a078b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueFinishingActions.h
@@ -0,0 +1,35 @@
+#pragma once
+
+namespace ai
+{
+	class CastEviscerateAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastEviscerateAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "eviscerate") {} 
+	};
+
+	class CastSliceAndDiceAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastSliceAndDiceAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slice and dice") {} 
+	};
+
+	class CastExposeArmorAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastExposeArmorAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "expose armor") {} 
+	};
+
+	class CastRuptureAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastRuptureAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "rupture") {} 
+	};
+	
+	class CastKidneyShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastKidneyShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "kidney shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
new file mode 100644
index 0000000..136fd0d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueMultipliers.h"
+#include "RogueActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
new file mode 100644
index 0000000..35e0fc3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueOpeningActions.h
@@ -0,0 +1,24 @@
+#pragma once
+
+namespace ai
+{
+	class CastSapAction : public CastMeleeSpellAction
+	{ 
+	public: 
+		CastSapAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "sap") {} 
+	};
+
+	class CastGarroteAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastGarroteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "garrote") {} 
+	};
+
+
+	class CastCheapShotAction : public CastMeleeSpellAction 
+	{ 
+	public: 
+		CastCheapShotAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cheap shot") {} 
+	};
+	
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
new file mode 100644
index 0000000..8f57d24
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RogueTriggers.h"
+#include "RogueActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/rogue/RogueTriggers.h b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
new file mode 100644
index 0000000..8d20e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/rogue/RogueTriggers.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+
+    class KickInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        KickInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "kick") {}
+    };
+
+    class SliceAndDiceTrigger : public BuffTrigger
+    {
+    public:
+        SliceAndDiceTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "slice and dice") {}
+    };
+
+    class RuptureTrigger : public DebuffTrigger
+    {
+    public:
+        RuptureTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "rupture") {}
+    };
+
+    class ExposeArmorTrigger : public DebuffTrigger
+    {
+    public:
+        ExposeArmorTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "expose armor") {}
+    };
+
+    class KickInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        KickInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "kick") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
new file mode 100644
index 0000000..aa1b6a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.cpp
@@ -0,0 +1,75 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+class CasterShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    CasterShamanStrategyActionNodeFactory()
+    {
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+CasterShamanStrategy::CasterShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new CasterShamanStrategyActionNodeFactory());
+}
+
+NextAction** CasterShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("lightning bolt", 10.0f), NULL);
+}
+
+void CasterShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("flametongue weapon", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "frost shock snare",
+        NextAction::array(0, new NextAction("frost shock", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("flametongue totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void CasterAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeAoeShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("chain lightning", 25.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("thunderstorm", 26.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
new file mode 100644
index 0000000..f9444c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/CasterShamanStrategy.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+
+namespace ai
+{
+    class CasterShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        CasterShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "caster"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_RANGED; }
+    };
+
+    class CasterAoeShamanStrategy : public MeleeAoeShamanStrategy
+    {
+    public:
+        CasterAoeShamanStrategy(PlayerbotAI* ai) : MeleeAoeShamanStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "caster aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
new file mode 100644
index 0000000..18a9c3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.cpp
@@ -0,0 +1,159 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class GenericShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericShamanStrategyActionNodeFactory()
+    {
+        creators["flametongue weapon"] = &flametongue_weapon;
+        creators["frostbrand weapon"] = &frostbrand_weapon;
+        creators["windfury weapon"] = &windfury_weapon;
+        creators["lesser healing wave"] = &lesser_healing_wave;
+        creators["lesser healing wave on party"] = &lesser_healing_wave_on_party;
+        creators["chain heal"] = &chain_heal;
+        creators["riptide"] = &riptide;
+        creators["chain heal on party"] = &chain_heal_on_party;
+        creators["riptide on party"] = &riptide_on_party;
+        creators["earth shock"] = &earth_shock;
+    }
+private:
+    static ActionNode* earth_shock(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earth shock",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flame shock"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* flametongue_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("flametongue weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("frostbrand weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* frostbrand_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("frostbrand weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* windfury_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("windfury weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("rockbiter weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lesser_healing_wave_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lesser healing wave on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* chain_heal_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("chain heal on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lesser healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* riptide_on_party(PlayerbotAI* ai)
+    {
+        return new ActionNode ("riptide on party",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("healing wave on party"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericShamanStrategy::GenericShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericShamanStrategyActionNodeFactory());
+}
+
+void GenericShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    CombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "wind shear",
+        NextAction::array(0, new NextAction("wind shear", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "wind shear on enemy healer",
+        NextAction::array(0, new NextAction("wind shear on enemy healer", 23.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "purge",
+		NextAction::array(0, new NextAction("purge", 10.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member medium health",
+		NextAction::array(0, new NextAction("lesser healing wave on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "party member low health",
+		NextAction::array(0, new NextAction("riptide on party", 25.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe heal",
+		NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium health",
+		NextAction::array(0, new NextAction("lesser healing wave", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"low health",
+		NextAction::array(0, new NextAction("riptide", 26.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"heroism",
+		NextAction::array(0, new NextAction("heroism", 31.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"bloodlust",
+		NextAction::array(0, new NextAction("bloodlust", 30.0f), NULL)));
+}
+
+void ShamanBuffDpsStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "lightning shield",
+        NextAction::array(0, new NextAction("lightning shield", 22.0f), NULL)));
+}
+
+void ShamanBuffManaStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "water shield",
+        NextAction::array(0, new NextAction("water shield", 22.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
new file mode 100644
index 0000000..fdac460
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/GenericShamanStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class GenericShamanStrategy : public CombatStrategy
+    {
+    public:
+        GenericShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+
+    };
+
+    class ShamanBuffDpsStrategy : public Strategy
+    {
+    public:
+        ShamanBuffDpsStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bdps"; }
+
+    };
+
+    class ShamanBuffManaStrategy : public Strategy
+    {
+    public:
+        ShamanBuffManaStrategy(PlayerbotAI* ai) : Strategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "bmana"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
new file mode 100644
index 0000000..0d05326
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.cpp
@@ -0,0 +1,82 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "HealShamanStrategy.h"
+
+using namespace ai;
+
+class HealShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    HealShamanStrategyActionNodeFactory()
+    {
+        creators["earthliving weapon"] = &earthliving_weapon;
+        creators["mana tide totem"] = &mana_tide_totem;
+    }
+private:
+    static ActionNode* earthliving_weapon(PlayerbotAI* ai)
+    {
+        return new ActionNode ("earthliving weapon",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("flametongue weapon"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* mana_tide_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mana tide totem",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mana potion"), NULL),
+            /*C*/ NULL);
+    }
+
+};
+
+HealShamanStrategy::HealShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new HealShamanStrategyActionNodeFactory());
+}
+
+void HealShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of spell",
+        NextAction::array(0, new NextAction("reach spell", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("earthliving weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("mana tide totem", ACTION_EMERGENCY + 5), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit", 24.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit poison",
+        NextAction::array(0, new NextAction("cleanse spirit poison on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit curse",
+        NextAction::array(0, new NextAction("cleanse spirit curse on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member cleanse spirit disease",
+        NextAction::array(0, new NextAction("cleanse spirit disease on party", 23.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("healing stream totem", ACTION_LIGHT_HEAL), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
new file mode 100644
index 0000000..e5d4ff1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/HealShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class HealShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        HealShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "heal"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
new file mode 100644
index 0000000..34eab8c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.cpp
@@ -0,0 +1,93 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "MeleeShamanStrategy.h"
+
+using namespace ai;
+
+class MeleeShamanStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    MeleeShamanStrategyActionNodeFactory()
+    {
+        creators["stormstrike"] = &stormstrike;
+        creators["lava lash"] = &lava_lash;
+        creators["magma totem"] = &magma_totem;
+    }
+private:
+    static ActionNode* stormstrike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("stormstrike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("lava lash"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* lava_lash(PlayerbotAI* ai)
+    {
+        return new ActionNode ("lava lash",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* magma_totem(PlayerbotAI* ai)
+    {
+        return new ActionNode ("magma totem",
+            /*P*/ NULL,
+            /*A*/ NULL,
+            /*C*/ NextAction::array(0, new NextAction("fire nova"), NULL));
+    }
+};
+
+MeleeShamanStrategy::MeleeShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+    actionNodeFactories.Add(new MeleeShamanStrategyActionNodeFactory());
+}
+
+NextAction** MeleeShamanStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("stormstrike", 10.0f), NULL);
+}
+
+void MeleeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "shaman weapon",
+        NextAction::array(0, new NextAction("windfury weapon", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "searing totem",
+        NextAction::array(0, new NextAction("searing totem", 22.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shock",
+        NextAction::array(0, new NextAction("earth shock", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "not facing target",
+        NextAction::array(0, new NextAction("set facing", ACTION_NORMAL + 7), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "enemy too close for melee",
+        NextAction::array(0, new NextAction("move out of enemy contact", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("strength of earth totem", ACTION_LIGHT_HEAL), NULL)));
+}
+
+void MeleeAoeShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("reach melee", ACTION_NORMAL + 8), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "magma totem",
+        NextAction::array(0, new NextAction("magma totem", 26.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("fire nova", 25.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
new file mode 100644
index 0000000..6c18fb6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/MeleeShamanStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class MeleeShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        MeleeShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+        virtual string getName() { return "melee"; }
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class MeleeAoeShamanStrategy : public CombatStrategy
+    {
+    public:
+        MeleeAoeShamanStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "melee aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
new file mode 100644
index 0000000..ab8b070
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanActions.h b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
new file mode 100644
index 0000000..478d08a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanActions.h
@@ -0,0 +1,304 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    class CastLesserHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastLesserHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "lesser healing wave") {}
+    };
+
+    class CastLesserHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastLesserHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "lesser healing wave") {}
+    };
+
+
+    class CastHealingWaveAction : public CastHealingSpellAction {
+    public:
+        CastHealingWaveAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "healing wave") {}
+    };
+
+    class CastHealingWaveOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastHealingWaveOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "healing wave") {}
+    };
+
+    class CastChainHealAction : public CastAoeHealSpellAction {
+    public:
+        CastChainHealAction(PlayerbotAI* ai) : CastAoeHealSpellAction(ai, "chain heal") {}
+    };
+
+    class CastRiptideAction : public CastHealingSpellAction {
+    public:
+        CastRiptideAction(PlayerbotAI* ai) : CastHealingSpellAction(ai, "riptide") {}
+    };
+
+    class CastRiptideOnPartyAction : public HealPartyMemberAction
+    {
+    public:
+        CastRiptideOnPartyAction(PlayerbotAI* ai) : HealPartyMemberAction(ai, "riptide") {}
+    };
+
+
+    class CastEarthShieldAction : public CastBuffSpellAction {
+    public:
+        CastEarthShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "earth shield") {}
+    };
+
+    class CastEarthShieldOnPartyAction : public BuffOnPartyAction
+    {
+    public:
+        CastEarthShieldOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "earth shield") {}
+    };
+
+    class CastWaterShieldAction : public CastBuffSpellAction {
+    public:
+        CastWaterShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water shield") {}
+    };
+
+	class CastLightningShieldAction : public CastBuffSpellAction {
+	public:
+		CastLightningShieldAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "lightning shield") {}
+	};
+
+    class CastEarthlivingWeaponAction : public CastEnchantItemAction {
+    public:
+        CastEarthlivingWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "earthliving weapon") {}
+    };
+
+    class CastRockbiterWeaponAction : public CastEnchantItemAction {
+    public:
+        CastRockbiterWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "rockbiter weapon") {}
+    };
+
+    class CastFlametongueWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFlametongueWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "flametongue weapon") {}
+    };
+
+    class CastFrostbrandWeaponAction : public CastEnchantItemAction {
+    public:
+        CastFrostbrandWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "frostbrand weapon") {}
+    };
+
+    class CastWindfuryWeaponAction : public CastEnchantItemAction {
+    public:
+        CastWindfuryWeaponAction(PlayerbotAI* ai) : CastEnchantItemAction(ai, "windfury weapon") {}
+    };
+
+    class CastTotemAction : public CastBuffSpellAction
+    {
+    public:
+        CastTotemAction(PlayerbotAI* ai, string spell) : CastBuffSpellAction(ai, spell) {}
+        virtual bool isUseful() { return CastBuffSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastStoneskinTotemAction : public CastTotemAction
+    {
+    public:
+        CastStoneskinTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "stoneskin totem") {}
+    };
+
+    class CastEarthbindTotemAction : public CastTotemAction
+    {
+    public:
+        CastEarthbindTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "earthbind totem") {}
+    };
+
+    class CastStrengthOfEarthTotemAction : public CastTotemAction
+    {
+    public:
+        CastStrengthOfEarthTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "strength of earth totem") {}
+    };
+
+    class CastManaSpringTotemAction : public CastTotemAction
+    {
+    public:
+        CastManaSpringTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana spring totem") {}
+    };
+
+	class CastManaTideTotemAction : public CastTotemAction
+	{
+	public:
+		CastManaTideTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "mana tide totem") {}
+		virtual string GetTargetName() { return "self target"; }
+	};
+
+	class CastHealingStreamTotemAction : public CastTotemAction
+	{
+	public:
+		CastHealingStreamTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "healing stream totem") {}
+	};
+
+    class CastCleansingTotemAction : public CastTotemAction
+    {
+    public:
+        CastCleansingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "cleansing totem") {}
+    };
+
+    class CastFlametongueTotemAction : public CastTotemAction
+    {
+    public:
+        CastFlametongueTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "flametongue totem") {}
+    };
+
+    class CastWindfuryTotemAction : public CastTotemAction
+    {
+    public:
+        CastWindfuryTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "windfury totem") {}
+    };
+
+    class CastSearingTotemAction : public CastTotemAction
+    {
+    public:
+        CastSearingTotemAction(PlayerbotAI* ai) : CastTotemAction(ai, "searing totem") {}
+        virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CastMagmaTotemAction : public CastMeleeSpellAction
+    {
+    public:
+        CastMagmaTotemAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "magma totem") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return CastMeleeSpellAction::isUseful() && !AI_VALUE2(bool, "has totem", name); }
+    };
+
+    class CastFireNovaAction : public CastSpellAction {
+    public:
+        CastFireNovaAction(PlayerbotAI* ai) : CastSpellAction(ai, "fire nova") {}
+    };
+
+    class CastWindShearAction : public CastSpellAction {
+    public:
+        CastWindShearAction(PlayerbotAI* ai) : CastSpellAction(ai, "wind shear") {}
+    };
+
+	class CastAncestralSpiritAction : public ResurrectPartyMemberAction
+	{
+	public:
+		CastAncestralSpiritAction(PlayerbotAI* ai) : ResurrectPartyMemberAction(ai, "ancestral spirit") {}
+	};
+
+
+	class CastPurgeAction : public CastSpellAction
+	{
+	public:
+		CastPurgeAction(PlayerbotAI* ai) : CastSpellAction(ai, "purge") {}
+	};
+
+	class CastStormstrikeAction : public CastMeleeSpellAction {
+	public:
+		CastStormstrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "stormstrike") {}
+	};
+
+	class CastLavaLashAction : public CastMeleeSpellAction {
+	public:
+		CastLavaLashAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "lava lash") {}
+	};
+
+    class CastWaterBreathingAction : public CastBuffSpellAction {
+    public:
+        CastWaterBreathingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingAction : public CastBuffSpellAction {
+    public:
+        CastWaterWalkingAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "water walking") {}
+    };
+
+    class CastWaterBreathingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterBreathingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water breathing") {}
+    };
+
+    class CastWaterWalkingOnPartyAction : public BuffOnPartyAction {
+    public:
+        CastWaterWalkingOnPartyAction(PlayerbotAI* ai) : BuffOnPartyAction(ai, "water walking") {}
+    };
+
+
+    class CastCleanseSpiritAction : public CastCureSpellAction {
+    public:
+        CastCleanseSpiritAction(PlayerbotAI* ai) : CastCureSpellAction(ai, "cleanse spirit") {}
+    };
+
+    class CastCleanseSpiritPoisonOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritPoisonOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_POISON) {}
+
+        virtual string getName() { return "cleanse spirit poison on party"; }
+    };
+    class CastCleanseSpiritCurseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritCurseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_CURSE) {}
+
+        virtual string getName() { return "cleanse spirit curse on party"; }
+    };
+    class CastCleanseSpiritDiseaseOnPartyAction : public CurePartyMemberAction
+    {
+    public:
+        CastCleanseSpiritDiseaseOnPartyAction(PlayerbotAI* ai) : CurePartyMemberAction(ai, "cleanse spirit", DISPEL_DISEASE) {}
+
+        virtual string getName() { return "cleanse spirit disease on party"; }
+    };
+
+    class CastFlameShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFlameShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "flame shock") {}
+    };
+
+    class CastEarthShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastEarthShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "earth shock") {}
+    };
+
+    class CastFrostShockAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFrostShockAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "frost shock") {}
+    };
+
+    class CastChainLightningAction : public CastSpellAction
+    {
+    public:
+        CastChainLightningAction(PlayerbotAI* ai) : CastSpellAction(ai, "chain lightning") {}
+    };
+
+    class CastLightningBoltAction : public CastSpellAction
+    {
+    public:
+        CastLightningBoltAction(PlayerbotAI* ai) : CastSpellAction(ai, "lightning bolt") {}
+    };
+
+    class CastThunderstormAction : public CastMeleeSpellAction
+    {
+    public:
+        CastThunderstormAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "thunderstorm") {}
+    };
+
+    class CastHeroismAction : public CastBuffSpellAction
+    {
+    public:
+        CastHeroismAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "heroism") {}
+    };
+
+    class CastBloodlustAction : public CastBuffSpellAction
+    {
+    public:
+        CastBloodlustAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodlust") {}
+    };
+
+    class CastWindShearOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastWindShearOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
new file mode 100644
index 0000000..cbd8ec3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.cpp
@@ -0,0 +1,268 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanActions.h"
+#include "ShamanAiObjectContext.h"
+#include "ShamanNonCombatStrategy.h"
+#include "HealShamanStrategy.h"
+#include "MeleeShamanStrategy.h"
+#include "ShamanTriggers.h"
+#include "../NamedObjectContext.h"
+#include "TotemsShamanStrategy.h"
+#include "CasterShamanStrategy.h"
+
+using namespace ai;
+
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &shaman::StrategyFactoryInternal::nc;
+                creators["totems"] = &shaman::StrategyFactoryInternal::totems;
+                creators["melee aoe"] = &shaman::StrategyFactoryInternal::melee_aoe;
+                creators["caster aoe"] = &shaman::StrategyFactoryInternal::caster_aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new ShamanNonCombatStrategy(ai); }
+            static Strategy* totems(PlayerbotAI* ai) { return new TotemsShamanStrategy(ai); }
+            static Strategy* melee_aoe(PlayerbotAI* ai) { return new MeleeAoeShamanStrategy(ai); }
+            static Strategy* caster_aoe(PlayerbotAI* ai) { return new CasterAoeShamanStrategy(ai); }
+        };
+
+        class BuffStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            BuffStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["bmana"] = &shaman::BuffStrategyFactoryInternal::bmana;
+                creators["bdps"] = &shaman::BuffStrategyFactoryInternal::bdps;
+            }
+
+        private:
+            static Strategy* bmana(PlayerbotAI* ai) { return new ShamanBuffManaStrategy(ai); }
+            static Strategy* bdps(PlayerbotAI* ai) { return new ShamanBuffDpsStrategy(ai); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["heal"] = &shaman::CombatStrategyFactoryInternal::heal;
+                creators["melee"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["dps"] = &shaman::CombatStrategyFactoryInternal::dps;
+                creators["caster"] = &shaman::CombatStrategyFactoryInternal::caster;
+            }
+
+        private:
+            static Strategy* heal(PlayerbotAI* ai) { return new HealShamanStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new MeleeShamanStrategy(ai); }
+            static Strategy* caster(PlayerbotAI* ai) { return new CasterShamanStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["windfury totem"] = &TriggerFactoryInternal::windfury_totem;
+                creators["mana spring totem"] = &TriggerFactoryInternal::mana_spring_totem;
+                creators["flametongue totem"] = &TriggerFactoryInternal::flametongue_totem;
+                creators["strength of earth totem"] = &TriggerFactoryInternal::strength_of_earth_totem;
+                creators["magma totem"] = &TriggerFactoryInternal::magma_totem;
+                creators["searing totem"] = &TriggerFactoryInternal::searing_totem;
+                creators["wind shear"] = &TriggerFactoryInternal::wind_shear;
+                creators["purge"] = &TriggerFactoryInternal::purge;
+                creators["shaman weapon"] = &TriggerFactoryInternal::shaman_weapon;
+                creators["water shield"] = &TriggerFactoryInternal::water_shield;
+                creators["lightning shield"] = &TriggerFactoryInternal::lightning_shield;
+                creators["water breathing"] = &TriggerFactoryInternal::water_breathing;
+                creators["water walking"] = &TriggerFactoryInternal::water_walking;
+                creators["water breathing on party"] = &TriggerFactoryInternal::water_breathing_on_party;
+                creators["water walking on party"] = &TriggerFactoryInternal::water_walking_on_party;
+                creators["cleanse spirit poison"] = &TriggerFactoryInternal::cleanse_poison;
+                creators["cleanse spirit curse"] = &TriggerFactoryInternal::cleanse_curse;
+                creators["cleanse spirit disease"] = &TriggerFactoryInternal::cleanse_disease;
+                creators["party member cleanse spirit poison"] = &TriggerFactoryInternal::party_member_cleanse_poison;
+                creators["party member cleanse spirit curse"] = &TriggerFactoryInternal::party_member_cleanse_curse;
+                creators["party member cleanse spirit disease"] = &TriggerFactoryInternal::party_member_cleanse_disease;
+                creators["shock"] = &TriggerFactoryInternal::shock;
+                creators["frost shock snare"] = &TriggerFactoryInternal::frost_shock_snare;
+                creators["heroism"] = &TriggerFactoryInternal::heroism;
+                creators["bloodlust"] = &TriggerFactoryInternal::bloodlust;
+                creators["maelstrom weapon"] = &TriggerFactoryInternal::maelstrom_weapon;
+                creators["wind shear on enemy healer"] = &TriggerFactoryInternal::wind_shear_on_enemy_healer;
+            }
+
+        private:
+            static Trigger* maelstrom_weapon(PlayerbotAI* ai) { return new MaelstromWeaponTrigger(ai); }
+            static Trigger* heroism(PlayerbotAI* ai) { return new HeroismTrigger(ai); }
+            static Trigger* bloodlust(PlayerbotAI* ai) { return new BloodlustTrigger(ai); }
+            static Trigger* party_member_cleanse_disease(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* party_member_cleanse_curse(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritCurseTrigger(ai); }
+            static Trigger* party_member_cleanse_poison(PlayerbotAI* ai) { return new PartyMemberCleanseSpiritPoisonTrigger(ai); }
+            static Trigger* cleanse_disease(PlayerbotAI* ai) { return new CleanseSpiritDiseaseTrigger(ai); }
+            static Trigger* cleanse_curse(PlayerbotAI* ai) { return new CleanseSpiritCurseTrigger(ai); }
+            static Trigger* cleanse_poison(PlayerbotAI* ai) { return new CleanseSpiritPoisonTrigger(ai); }
+            static Trigger* water_breathing(PlayerbotAI* ai) { return new WaterBreathingTrigger(ai); }
+            static Trigger* water_walking(PlayerbotAI* ai) { return new WaterWalkingTrigger(ai); }
+            static Trigger* water_breathing_on_party(PlayerbotAI* ai) { return new WaterBreathingOnPartyTrigger(ai); }
+            static Trigger* water_walking_on_party(PlayerbotAI* ai) { return new WaterWalkingOnPartyTrigger(ai); }
+            static Trigger* windfury_totem(PlayerbotAI* ai) { return new WindfuryTotemTrigger(ai); }
+            static Trigger* mana_spring_totem(PlayerbotAI* ai) { return new ManaSpringTotemTrigger(ai); }
+            static Trigger* flametongue_totem(PlayerbotAI* ai) { return new FlametongueTotemTrigger(ai); }
+            static Trigger* strength_of_earth_totem(PlayerbotAI* ai) { return new StrengthOfEarthTotemTrigger(ai); }
+            static Trigger* magma_totem(PlayerbotAI* ai) { return new MagmaTotemTrigger(ai); }
+            static Trigger* searing_totem(PlayerbotAI* ai) { return new SearingTotemTrigger(ai); }
+            static Trigger* wind_shear(PlayerbotAI* ai) { return new WindShearInterruptSpellTrigger(ai); }
+            static Trigger* purge(PlayerbotAI* ai) { return new PurgeTrigger(ai); }
+            static Trigger* shaman_weapon(PlayerbotAI* ai) { return new ShamanWeaponTrigger(ai); }
+            static Trigger* water_shield(PlayerbotAI* ai) { return new WaterShieldTrigger(ai); }
+            static Trigger* lightning_shield(PlayerbotAI* ai) { return new LightningShieldTrigger(ai); }
+            static Trigger* shock(PlayerbotAI* ai) { return new ShockTrigger(ai); }
+            static Trigger* frost_shock_snare(PlayerbotAI* ai) { return new FrostShockSnareTrigger(ai); }
+            static Trigger* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new WindShearInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace shaman
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["water shield"] = &AiObjectContextInternal::water_shield;
+                creators["lightning shield"] = &AiObjectContextInternal::lightning_shield;
+                creators["strength of earth totem"] = &AiObjectContextInternal::strength_of_earth_totem;
+                creators["flametongue totem"] = &AiObjectContextInternal::flametongue_totem;
+                creators["searing totem"] = &AiObjectContextInternal::searing_totem;
+                creators["magma totem"] = &AiObjectContextInternal::magma_totem;
+                creators["windfury totem"] = &AiObjectContextInternal::windfury_totem;
+                creators["mana spring totem"] = &AiObjectContextInternal::mana_spring_totem;
+                creators["mana tide totem"] = &AiObjectContextInternal::mana_tide_totem;
+                creators["healing stream totem"] = &AiObjectContextInternal::healing_stream_totem;
+                creators["wind shear"] = &AiObjectContextInternal::wind_shear;
+                creators["wind shear on enemy healer"] = &AiObjectContextInternal::wind_shear_on_enemy_healer;
+                creators["rockbiter weapon"] = &AiObjectContextInternal::rockbiter_weapon;
+                creators["flametongue weapon"] = &AiObjectContextInternal::flametongue_weapon;
+                creators["frostbrand weapon"] = &AiObjectContextInternal::frostbrand_weapon;
+                creators["windfury weapon"] = &AiObjectContextInternal::windfury_weapon;
+                creators["earthliving weapon"] = &AiObjectContextInternal::earthliving_weapon;
+                creators["purge"] = &AiObjectContextInternal::purge;
+                creators["healing wave"] = &AiObjectContextInternal::healing_wave;
+                creators["lesser healing wave"] = &AiObjectContextInternal::lesser_healing_wave;
+                creators["healing wave on party"] = &AiObjectContextInternal::healing_wave_on_party;
+                creators["lesser healing wave on party"] = &AiObjectContextInternal::lesser_healing_wave_on_party;
+                creators["earth shield"] = &AiObjectContextInternal::earth_shield;
+                creators["earth shield on party"] = &AiObjectContextInternal::earth_shield_on_party;
+                creators["chain heal"] = &AiObjectContextInternal::chain_heal;
+                creators["riptide"] = &AiObjectContextInternal::riptide;
+                creators["riptide on party"] = &AiObjectContextInternal::riptide_on_party;
+                creators["stormstrike"] = &AiObjectContextInternal::stormstrike;
+                creators["lava lash"] = &AiObjectContextInternal::lava_lash;
+                creators["fire nova"] = &AiObjectContextInternal::fire_nova;
+                creators["ancestral spirit"] = &AiObjectContextInternal::ancestral_spirit;
+                creators["water walking"] = &AiObjectContextInternal::water_walking;
+                creators["water breathing"] = &AiObjectContextInternal::water_breathing;
+                creators["water walking on party"] = &AiObjectContextInternal::water_walking_on_party;
+                creators["water breathing on party"] = &AiObjectContextInternal::water_breathing_on_party;
+                creators["cleanse spirit"] = &AiObjectContextInternal::cleanse_spirit;
+                creators["cleanse spirit poison on party"] = &AiObjectContextInternal::cleanse_spirit_poison_on_party;
+                creators["cleanse spirit disease on party"] = &AiObjectContextInternal::cleanse_spirit_disease_on_party;
+                creators["cleanse spirit curse on party"] = &AiObjectContextInternal::cleanse_spirit_curse_on_party;
+                creators["flame shock"] = &AiObjectContextInternal::flame_shock;
+                creators["earth shock"] = &AiObjectContextInternal::earth_shock;
+                creators["frost shock"] = &AiObjectContextInternal::frost_shock;
+                creators["chain lightning"] = &AiObjectContextInternal::chain_lightning;
+                creators["lightning bolt"] = &AiObjectContextInternal::lightning_bolt;
+                creators["thunderstorm"] = &AiObjectContextInternal::thunderstorm;
+                creators["heroism"] = &AiObjectContextInternal::heroism;
+                creators["bloodlust"] = &AiObjectContextInternal::bloodlust;
+            }
+
+        private:
+            static Action* heroism(PlayerbotAI* ai) { return new CastHeroismAction(ai); }
+            static Action* bloodlust(PlayerbotAI* ai) { return new CastBloodlustAction(ai); }
+            static Action* thunderstorm(PlayerbotAI* ai) { return new CastThunderstormAction(ai); }
+            static Action* lightning_bolt(PlayerbotAI* ai) { return new CastLightningBoltAction(ai); }
+            static Action* chain_lightning(PlayerbotAI* ai) { return new CastChainLightningAction(ai); }
+            static Action* frost_shock(PlayerbotAI* ai) { return new CastFrostShockAction(ai); }
+            static Action* earth_shock(PlayerbotAI* ai) { return new CastEarthShockAction(ai); }
+            static Action* flame_shock(PlayerbotAI* ai) { return new CastFlameShockAction(ai); }
+            static Action* cleanse_spirit_poison_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritPoisonOnPartyAction(ai); }
+            static Action* cleanse_spirit_disease_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritDiseaseOnPartyAction(ai); }
+            static Action* cleanse_spirit_curse_on_party(PlayerbotAI* ai) { return new CastCleanseSpiritCurseOnPartyAction(ai); }
+            static Action* cleanse_spirit(PlayerbotAI* ai) { return new CastCleanseSpiritAction(ai); }
+            static Action* water_walking(PlayerbotAI* ai) { return new CastWaterWalkingAction(ai); }
+            static Action* water_breathing(PlayerbotAI* ai) { return new CastWaterBreathingAction(ai); }
+            static Action* water_walking_on_party(PlayerbotAI* ai) { return new CastWaterWalkingOnPartyAction(ai); }
+            static Action* water_breathing_on_party(PlayerbotAI* ai) { return new CastWaterBreathingOnPartyAction(ai); }
+            static Action* water_shield(PlayerbotAI* ai) { return new CastWaterShieldAction(ai); }
+            static Action* lightning_shield(PlayerbotAI* ai) { return new CastLightningShieldAction(ai); }
+            static Action* strength_of_earth_totem(PlayerbotAI* ai) { return new CastStrengthOfEarthTotemAction(ai); }
+            static Action* flametongue_totem(PlayerbotAI* ai) { return new CastFlametongueTotemAction(ai); }
+            static Action* magma_totem(PlayerbotAI* ai) { return new CastMagmaTotemAction(ai); }
+            static Action* searing_totem(PlayerbotAI* ai) { return new CastSearingTotemAction(ai); }
+            static Action* fire_nova(PlayerbotAI* ai) { return new CastFireNovaAction(ai); }
+            static Action* windfury_totem(PlayerbotAI* ai) { return new CastWindfuryTotemAction(ai); }
+            static Action* mana_spring_totem(PlayerbotAI* ai) { return new CastManaSpringTotemAction(ai); }
+            static Action* mana_tide_totem(PlayerbotAI* ai) { return new CastManaTideTotemAction(ai); }
+            static Action* healing_stream_totem(PlayerbotAI* ai) { return new CastHealingStreamTotemAction(ai); }
+            static Action* wind_shear(PlayerbotAI* ai) { return new CastWindShearAction(ai); }
+            static Action* rockbiter_weapon(PlayerbotAI* ai) { return new CastRockbiterWeaponAction(ai); }
+            static Action* flametongue_weapon(PlayerbotAI* ai) { return new CastFlametongueWeaponAction(ai); }
+            static Action* frostbrand_weapon(PlayerbotAI* ai) { return new CastFrostbrandWeaponAction(ai); }
+            static Action* windfury_weapon(PlayerbotAI* ai) { return new CastWindfuryWeaponAction(ai); }
+            static Action* earthliving_weapon(PlayerbotAI* ai) { return new CastEarthlivingWeaponAction(ai); }
+            static Action* purge(PlayerbotAI* ai) { return new CastPurgeAction(ai); }
+            static Action* healing_wave(PlayerbotAI* ai) { return new CastHealingWaveAction(ai); }
+            static Action* lesser_healing_wave(PlayerbotAI* ai) { return new CastLesserHealingWaveAction(ai); }
+            static Action* healing_wave_on_party(PlayerbotAI* ai) { return new CastHealingWaveOnPartyAction(ai); }
+            static Action* lesser_healing_wave_on_party(PlayerbotAI* ai) { return new CastLesserHealingWaveOnPartyAction(ai); }
+            static Action* earth_shield(PlayerbotAI* ai) { return new CastEarthShieldAction(ai); }
+            static Action* earth_shield_on_party(PlayerbotAI* ai) { return new CastEarthShieldOnPartyAction(ai); }
+            static Action* chain_heal(PlayerbotAI* ai) { return new CastChainHealAction(ai); }
+            static Action* riptide(PlayerbotAI* ai) { return new CastRiptideAction(ai); }
+            static Action* riptide_on_party(PlayerbotAI* ai) { return new CastRiptideOnPartyAction(ai); }
+            static Action* stormstrike(PlayerbotAI* ai) { return new CastStormstrikeAction(ai); }
+            static Action* lava_lash(PlayerbotAI* ai) { return new CastLavaLashAction(ai); }
+            static Action* ancestral_spirit(PlayerbotAI* ai) { return new CastAncestralSpiritAction(ai); }
+            static Action* wind_shear_on_enemy_healer(PlayerbotAI* ai) { return new CastWindShearOnEnemyHealerAction(ai); }
+        };
+    };
+};
+
+
+
+ShamanAiObjectContext::ShamanAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::shaman::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::CombatStrategyFactoryInternal());
+    strategyContexts.Add(new ai::shaman::BuffStrategyFactoryInternal());
+    actionContexts.Add(new ai::shaman::AiObjectContextInternal());
+    triggerContexts.Add(new ai::shaman::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
new file mode 100644
index 0000000..718084a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class ShamanAiObjectContext : public AiObjectContext
+    {
+    public:
+        ShamanAiObjectContext(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
new file mode 100644
index 0000000..6c72f20
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
new file mode 100644
index 0000000..044c6bc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.cpp
@@ -0,0 +1,49 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "ShamanNonCombatStrategy.h"
+
+using namespace ai;
+
+void ShamanNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"party member dead",
+		NextAction::array(0, new NextAction("ancestral spirit", 33.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water breathing",
+		NextAction::array(0, new NextAction("water breathing", 12.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"water walking",
+		NextAction::array(0, new NextAction("water walking", 12.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water breathing on party",
+        NextAction::array(0, new NextAction("water breathing on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "water walking on party",
+        NextAction::array(0, new NextAction("water walking on party", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "critical health",
+        NextAction::array(0, new NextAction("healing wave", 70.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "party member critical health",
+        NextAction::array(0, new NextAction("healing wave on party", 60.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe heal",
+        NextAction::array(0, new NextAction("chain heal", 27.0f), NULL)));
+}
+
+void ShamanNonCombatStrategy::InitMultipliers(std::list<Multiplier*> &multipliers)
+{
+    NonCombatStrategy::InitMultipliers(multipliers);
+}
+
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
new file mode 100644
index 0000000..a6859ee
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanNonCombatStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class ShamanNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        ShamanNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual void InitMultipliers(std::list<Multiplier*> &multipliers);
+        virtual string getName() { return "nc"; }
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
new file mode 100644
index 0000000..2a6c51e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.cpp
@@ -0,0 +1,38 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanTriggers.h"
+#include "ShamanActions.h"
+
+using namespace ai;
+
+list<string> ShamanWeaponTrigger::spells;
+
+bool ShamanWeaponTrigger::IsActive()
+{
+    if (spells.empty())
+    {
+        spells.push_back("frostbrand weapon");
+        spells.push_back("rockbiter weapon");
+        spells.push_back("flametongue weapon");
+        spells.push_back("earthliving weapon");
+        spells.push_back("windfury weapon");
+    }
+
+    for (list<string>::iterator i = spells.begin(); i != spells.end(); ++i)
+    {
+        uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+        if (!spellId)
+            continue;
+
+        if (AI_VALUE2(Item*, "item for spell", spellId))
+            return true;
+    }
+
+    return false;
+}
+
+bool ShockTrigger::IsActive()
+{
+    return SpellTrigger::IsActive()
+            && !ai->HasAnyAuraOf(GetTarget(), "frost shock", "earth shock", "flame shock", NULL);
+}
diff --git a/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
new file mode 100644
index 0000000..afa6d62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/ShamanTriggers.h
@@ -0,0 +1,197 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    class ShamanWeaponTrigger : public BuffTrigger {
+    public:
+        ShamanWeaponTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "rockbiter weapon") {}
+        virtual bool IsActive();
+    private:
+        static list<string> spells;
+    };
+
+    class TotemTrigger : public Trigger {
+    public:
+        TotemTrigger(PlayerbotAI* ai, string spell, int attackerCount = 0) : Trigger(ai, spell), attackerCount(attackerCount) {}
+
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= attackerCount && !AI_VALUE2(bool, "has totem", name);
+        }
+
+    protected:
+        int attackerCount;
+    };
+
+    class WindfuryTotemTrigger : public TotemTrigger {
+    public:
+        WindfuryTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "windfury totem") {}
+    };
+
+    class ManaSpringTotemTrigger : public TotemTrigger {
+    public:
+        ManaSpringTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "mana spring totem") {}
+        virtual bool IsActive()
+        {
+            return AI_VALUE(uint8, "attacker count") >= attackerCount &&
+                    !AI_VALUE2(bool, "has totem", "mana tide totem") &&
+                    !AI_VALUE2(bool, "has totem", name);
+        }
+    };
+
+    class FlametongueTotemTrigger : public TotemTrigger {
+    public:
+        FlametongueTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "flametongue totem") {}
+    };
+
+    class StrengthOfEarthTotemTrigger : public TotemTrigger {
+    public:
+        StrengthOfEarthTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "strength of earth totem") {}
+    };
+
+    class MagmaTotemTrigger : public TotemTrigger {
+    public:
+        MagmaTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "magma totem", 3) {}
+    };
+
+    class SearingTotemTrigger : public TotemTrigger {
+    public:
+        SearingTotemTrigger(PlayerbotAI* ai) : TotemTrigger(ai, "searing totem", 1) {}
+    };
+
+    class WindShearInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        WindShearInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "wind shear") {}
+    };
+
+    class WaterShieldTrigger : public BuffTrigger
+    {
+    public:
+        WaterShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water shield") {}
+    };
+
+    class LightningShieldTrigger : public BuffTrigger
+    {
+    public:
+        LightningShieldTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "lightning shield") {}
+    };
+
+    class PurgeTrigger : public TargetAuraDispelTrigger
+    {
+    public:
+        PurgeTrigger(PlayerbotAI* ai) : TargetAuraDispelTrigger(ai, "purge", DISPEL_MAGIC) {}
+    };
+
+    class WaterWalkingTrigger : public BuffTrigger {
+    public:
+        WaterWalkingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water walking") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingTrigger : public BuffTrigger {
+    public:
+        WaterBreathingTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "water breathing") {}
+
+        virtual bool IsActive()
+        {
+            return BuffTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterWalkingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterWalkingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water walking on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class WaterBreathingOnPartyTrigger : public BuffOnPartyTrigger {
+    public:
+        WaterBreathingOnPartyTrigger(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, "water breathing on party") {}
+
+        virtual bool IsActive()
+        {
+            return BuffOnPartyTrigger::IsActive() && AI_VALUE2(bool, "swimming", "self target");
+        }
+    };
+
+    class CleanseSpiritPoisonTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritPoisonTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class PartyMemberCleanseSpiritPoisonTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritPoisonTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_POISON) {}
+    };
+
+    class CleanseSpiritCurseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritCurseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class PartyMemberCleanseSpiritCurseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritCurseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_CURSE) {}
+    };
+
+    class CleanseSpiritDiseaseTrigger : public NeedCureTrigger
+    {
+    public:
+        CleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : NeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class PartyMemberCleanseSpiritDiseaseTrigger : public PartyMemberNeedCureTrigger
+    {
+    public:
+        PartyMemberCleanseSpiritDiseaseTrigger(PlayerbotAI* ai) : PartyMemberNeedCureTrigger(ai, "cleanse spirit", DISPEL_DISEASE) {}
+    };
+
+    class ShockTrigger : public DebuffTrigger {
+    public:
+        ShockTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "earth shock") {}
+        virtual bool IsActive();
+    };
+
+    class FrostShockSnareTrigger : public SnareTargetTrigger {
+    public:
+        FrostShockSnareTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "frost shock") {}
+    };
+
+    class HeroismTrigger : public BoostTrigger
+    {
+    public:
+        HeroismTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "heroism") {}
+    };
+
+    class BloodlustTrigger : public BoostTrigger
+    {
+    public:
+        BloodlustTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "bloodlust") {}
+    };
+
+    class MaelstromWeaponTrigger : public HasAuraTrigger
+    {
+    public:
+        MaelstromWeaponTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "maelstrom weapon") {}
+    };
+
+    class WindShearInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        WindShearInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "wind shear") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
new file mode 100644
index 0000000..e23c97d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ShamanMultipliers.h"
+#include "TotemsShamanStrategy.h"
+
+using namespace ai;
+
+TotemsShamanStrategy::TotemsShamanStrategy(PlayerbotAI* ai) : GenericShamanStrategy(ai)
+{
+}
+
+void TotemsShamanStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericShamanStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "windfury totem",
+        NextAction::array(0, new NextAction("windfury totem", 16.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "mana spring totem",
+        NextAction::array(0, new NextAction("mana spring totem", 19.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "strength of earth totem",
+        NextAction::array(0, new NextAction("strength of earth totem", 18.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "flametongue totem",
+        NextAction::array(0, new NextAction("flametongue totem", 17.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
new file mode 100644
index 0000000..978fa26
--- /dev/null
+++ b/src/plugins/playerbot/strategy/shaman/TotemsShamanStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericShamanStrategy.h"
+
+namespace ai
+{
+    class TotemsShamanStrategy : public GenericShamanStrategy
+    {
+    public:
+        TotemsShamanStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "totems"; }
+		virtual int GetType() { return STRATEGY_TYPE_HEAL; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
new file mode 100644
index 0000000..0e43d16
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatCommandTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class ChatCommandTrigger : public Trigger {
+    public:
+        ChatCommandTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(string param, Player* owner = NULL)
+        {
+            this->param = param;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), param, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+   private:
+        string param;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
new file mode 100644
index 0000000..239e0ec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/ChatTriggerContext.h
@@ -0,0 +1,140 @@
+#pragma once
+
+#include "ChatCommandTrigger.h"
+
+namespace ai
+{
+    class ChatTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        ChatTriggerContext()
+        {
+            creators["quests"] = &ChatTriggerContext::quests;
+            creators["stats"] = &ChatTriggerContext::stats;
+            creators["leave"] = &ChatTriggerContext::leave;
+            creators["rep"] = &ChatTriggerContext::reputation;
+            creators["reputation"] = &ChatTriggerContext::reputation;
+            creators["log"] = &ChatTriggerContext::log;
+            creators["los"] = &ChatTriggerContext::los;
+            creators["drop"] = &ChatTriggerContext::drop;
+            creators["q"] = &ChatTriggerContext::q;
+            creators["ll"] = &ChatTriggerContext::ll;
+            creators["loot all"] = &ChatTriggerContext::loot_all;
+            creators["add all loot"] = &ChatTriggerContext::loot_all;
+            creators["release"] = &ChatTriggerContext::release;
+            creators["teleport"] = &ChatTriggerContext::teleport;
+            creators["taxi"] = &ChatTriggerContext::taxi;
+            creators["repair"] = &ChatTriggerContext::repair;
+            creators["u"] = &ChatTriggerContext::use;
+            creators["use"] = &ChatTriggerContext::use;
+            creators["c"] = &ChatTriggerContext::item_count;
+            creators["e"] = &ChatTriggerContext::equip;
+            creators["ue"] = &ChatTriggerContext::uneqip;
+            creators["s"] = &ChatTriggerContext::sell;
+            creators["b"] = &ChatTriggerContext::buy;
+            creators["r"] = &ChatTriggerContext::reward;
+            creators["t"] = &ChatTriggerContext::trade;
+            creators["nt"] = &ChatTriggerContext::nontrade;
+            creators["talents"] = &ChatTriggerContext::talents;
+            creators["spells"] = &ChatTriggerContext::spells;
+            creators["co"] = &ChatTriggerContext::co;
+            creators["nc"] = &ChatTriggerContext::nc;
+            creators["dead"] = &ChatTriggerContext::dead;
+            creators["trainer"] = &ChatTriggerContext::trainer;
+            creators["attack"] = &ChatTriggerContext::attack;
+            creators["chat"] = &ChatTriggerContext::chat;
+            creators["accept"] = &ChatTriggerContext::accept;
+            creators["home"] = &ChatTriggerContext::home;
+            creators["reset ai"] = &ChatTriggerContext::reset_ai;
+            creators["destroy"] = &ChatTriggerContext::destroy;
+            creators["emote"] = &ChatTriggerContext::emote;
+            creators["buff"] = &ChatTriggerContext::buff;
+            creators["help"] = &ChatTriggerContext::help;
+            creators["gb"] = &ChatTriggerContext::gb;
+            creators["bank"] = &ChatTriggerContext::bank;
+            creators["follow"] = &ChatTriggerContext::follow;
+            creators["stay"] = &ChatTriggerContext::stay;
+            creators["flee"] = &ChatTriggerContext::flee;
+            creators["grind"] = &ChatTriggerContext::grind;
+            creators["tank attack"] = &ChatTriggerContext::tank_attack;
+            creators["talk"] = &ChatTriggerContext::talk;
+            creators["cast"] = &ChatTriggerContext::talk;
+            creators["invite"] = &ChatTriggerContext::invite;
+            creators["spell"] = &ChatTriggerContext::spell;
+            creators["rti"] = &ChatTriggerContext::rti;
+            creators["revive"] = &ChatTriggerContext::revive;
+            creators["runaway"] = &ChatTriggerContext::runaway;
+            creators["warning"] = &ChatTriggerContext::warning;
+            creators["position"] = &ChatTriggerContext::position;
+            creators["summon"] = &ChatTriggerContext::summon;
+            creators["who"] = &ChatTriggerContext::who;
+            creators["save mana"] = &ChatTriggerContext::save_mana;
+            creators["max dps"] = &ChatTriggerContext::max_dps;
+            creators["attackers"] = &ChatTriggerContext::attackers;
+            creators["formation"] = &ChatTriggerContext::formation;
+        }
+
+    private:
+        static Trigger* formation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "formation"); }
+        static Trigger* attackers(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attackers"); }
+        static Trigger* max_dps(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "max dps"); }
+        static Trigger* save_mana(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "save mana"); }
+        static Trigger* who(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "who"); }
+        static Trigger* summon(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "summon"); }
+        static Trigger* position(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "position"); }
+        static Trigger* runaway(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "runaway"); }
+        static Trigger* warning(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "warning"); }
+        static Trigger* revive(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "revive"); }
+        static Trigger* rti(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "rti"); }
+        static Trigger* invite(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "invite"); }
+        static Trigger* cast(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "cast"); }
+        static Trigger* talk(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talk"); }
+        static Trigger* flee(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "flee"); }
+        static Trigger* grind(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "grind"); }
+        static Trigger* tank_attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "tank attack"); }
+        static Trigger* stay(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stay"); }
+        static Trigger* follow(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "follow"); }
+        static Trigger* gb(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "gb"); }
+        static Trigger* bank(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "bank"); }
+        static Trigger* help(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "help"); }
+        static Trigger* buff(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "buff"); }
+        static Trigger* emote(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "emote"); }
+        static Trigger* destroy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "destroy"); }
+        static Trigger* home(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "home"); }
+        static Trigger* accept(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "accept"); }
+        static Trigger* chat(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "chat"); }
+        static Trigger* attack(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "attack"); }
+        static Trigger* trainer(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "trainer"); }
+        static Trigger* co(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "co"); }
+        static Trigger* nc(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nc"); }
+        static Trigger* dead(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "dead"); }
+        static Trigger* spells(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spells"); }
+        static Trigger* talents(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "talents"); }
+        static Trigger* equip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "e"); }
+        static Trigger* uneqip(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ue"); }
+        static Trigger* sell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "s"); }
+        static Trigger* buy(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "b"); }
+        static Trigger* reward(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "r"); }
+        static Trigger* trade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "t"); }
+        static Trigger* nontrade(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "nt"); }
+
+        static Trigger* item_count(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "c"); }
+        static Trigger* use(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "use"); }
+        static Trigger* repair(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "repair"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "taxi"); }
+        static Trigger* teleport(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "teleport"); }
+        static Trigger* q(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "q"); }
+        static Trigger* ll(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "ll"); }
+        static Trigger* drop(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "drop"); }
+        static Trigger* quests(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "quests"); }
+        static Trigger* stats(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "stats"); }
+        static Trigger* leave(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "leave"); }
+        static Trigger* reputation(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reputation"); }
+        static Trigger* log(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "log"); }
+        static Trigger* los(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "los"); }
+        static Trigger* loot_all(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "add all loot"); }
+        static Trigger* release(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "release"); }
+        static Trigger* reset_ai(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "reset ai"); }
+        static Trigger* spell(PlayerbotAI* ai) { return new ChatCommandTrigger(ai, "spell"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
new file mode 100644
index 0000000..0be6ff6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.cpp
@@ -0,0 +1,17 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "CureTriggers.h"
+
+using namespace ai;
+
+bool NeedCureTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return target && ai->HasAuraToDispel(target, dispelType);
+}
+
+Value<Unit*>* PartyMemberNeedCureTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member to dispel", dispelType);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/CureTriggers.h b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
new file mode 100644
index 0000000..2321953
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/CureTriggers.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Trigger.h"
+
+namespace ai
+{
+	class SpellTrigger;
+
+    class NeedCureTrigger : public SpellTrigger {
+    public:
+        NeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : SpellTrigger(ai, spell) 
+  	    {
+			this->dispelType = dispelType;
+        }
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+
+    protected:
+        uint32 dispelType;
+    };
+
+    class TargetAuraDispelTrigger : public NeedCureTrigger {
+    public:
+        TargetAuraDispelTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+			NeedCureTrigger(ai, spell, dispelType) {}
+		virtual string GetTargetName() { return "current target"; }
+    };
+
+    class PartyMemberNeedCureTrigger : public NeedCureTrigger {
+    public:
+        PartyMemberNeedCureTrigger(PlayerbotAI* ai, string spell, uint32 dispelType) : 
+            NeedCureTrigger(ai, spell, dispelType) {}
+
+		virtual Value<Unit*>* GetTargetValue();
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
new file mode 100644
index 0000000..ebd6dbf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.cpp
@@ -0,0 +1,242 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericTriggers.h"
+#include "../../LootObjectStack.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool LowManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana;
+}
+
+bool MediumManaTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has mana", "self target") && AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.mediumMana;
+}
+
+
+bool RageAvailable::IsActive()
+{
+    return AI_VALUE2(uint8, "rage", "self target") >= amount;
+}
+
+bool EnergyAvailable::IsActive()
+{
+	return AI_VALUE2(uint8, "energy", "self target") >= amount;
+}
+
+bool ComboPointsAvailableTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "combo", "current target") >= amount;
+}
+
+bool LoseAggroTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool HasAggroTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "has aggro", "current target");
+}
+
+bool PanicTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "health", "self target") < sPlayerbotAIConfig.criticalHealth &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") < sPlayerbotAIConfig.lowMana);
+}
+
+bool BuffTrigger::IsActive()
+{
+    Unit* target = GetTarget();
+	return SpellTrigger::IsActive() &&
+		!ai->HasAura(spell, target) &&
+		(!AI_VALUE2(bool, "has mana", "self target") || AI_VALUE2(uint8, "mana", "self target") > sPlayerbotAIConfig.lowMana);
+}
+
+Value<Unit*>* BuffOnPartyTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("party member without aura", spell);
+}
+
+Value<Unit*>* DebuffOnAttackerTrigger::GetTargetValue()
+{
+	return context->GetValue<Unit*>("attacker without aura", spell);
+}
+
+bool NoAttackersTrigger::IsActive()
+{
+    return !AI_VALUE(Unit*, "current target") && AI_VALUE(uint8, "attacker count") > 0;
+}
+
+bool InvalidTargetTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "invalid target", "current target");
+}
+
+bool NoTargetTrigger::IsActive()
+{
+	return !AI_VALUE(Unit*, "current target");
+}
+
+bool MyAttackerCountTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "my attacker count") >= amount;
+}
+
+bool AoeTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") >= amount;
+}
+
+bool DebuffTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE2(uint8, "health", "current target") > 25;
+}
+
+bool SpellTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool SpellCanBeCastTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return target && ai->CanCastSpell(spell, target);
+}
+
+bool RandomTrigger::IsActive()
+{
+    int vl  = rand() % (int)(1 + probability * 10 / sPlayerbotAIConfig.randomChangeMultiplier);
+    return vl == 0;
+}
+
+bool AndTrigger::IsActive()
+{
+    return ls->IsActive() && rs->IsActive();
+}
+
+string AndTrigger::getName()
+{
+    std::string name(ls->getName());
+    name = name + " and ";
+    name = name + rs->getName();
+    return name;
+}
+
+bool BoostTrigger::IsActive()
+{
+	return BuffTrigger::IsActive() && AI_VALUE(uint8, "balance") <= balance;
+}
+
+bool SnareTargetTrigger::IsActive()
+{
+	Unit* target = GetTarget();
+	return DebuffTrigger::IsActive() && AI_VALUE2(bool, "moving", "current target") && !ai->HasAura(spell, target);
+}
+
+bool ItemCountTrigger::IsActive()
+{
+	return AI_VALUE2(uint8, "item count", item) < count;
+}
+
+bool InterruptSpellTrigger::IsActive()
+{
+	return SpellTrigger::IsActive() && ai->IsInterruptableSpellCasting(GetTarget(), getName());
+}
+
+bool HasAuraTrigger::IsActive()
+{
+	return ai->HasAura(getName(), GetTarget());
+}
+
+bool TankAoeTrigger::IsActive()
+{
+    if (!AI_VALUE(uint8, "attacker count"))
+        return false;
+
+    Unit* currentTarget = AI_VALUE(Unit*, "current target");
+    if (!currentTarget)
+        return true;
+
+    Unit* tankTarget = AI_VALUE(Unit*, "tank target");
+    if (!tankTarget || currentTarget == tankTarget)
+        return false;
+
+    return currentTarget->GetVictim() == AI_VALUE(Unit*, "self target");
+}
+
+bool IsBehindTargetTrigger::IsActive()
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return target && AI_VALUE2(bool, "behind", "current target");
+}
+
+bool IsNotFacingTargetTrigger::IsActive()
+{
+    return !AI_VALUE2(bool, "facing", "current target");
+}
+
+bool HasCcTargetTrigger::IsActive()
+{
+    return AI_VALUE(uint8, "attacker count") > 2 && AI_VALUE2(Unit*, "cc target", getName()) &&
+        !AI_VALUE2(Unit*, "current cc target", getName());
+}
+
+bool NoMovementTrigger::IsActive()
+{
+	return !AI_VALUE2(bool, "moving", "self target");
+}
+
+bool NoPossibleTargetsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "possible targets");
+    return !targets.size();
+}
+
+bool NotLeastHpTargetActiveTrigger::IsActive()
+{
+    Unit* leastHp = AI_VALUE(Unit*, "least hp target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return leastHp && target != leastHp;
+}
+
+bool EnemyPlayerIsAttacking::IsActive()
+{
+    Unit* enemyPlayer = AI_VALUE(Unit*, "enemy player target");
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return enemyPlayer && target != enemyPlayer;
+}
+
+bool IsSwimmingTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "swimming", "self target");
+}
+
+bool HasNearestAddsTrigger::IsActive()
+{
+    list<ObjectGuid> targets = AI_VALUE(list<ObjectGuid>, "nearest adds");
+    return targets.size();
+}
+
+bool HasItemForSpellTrigger::IsActive()
+{
+	string spell = getName();
+    uint32 spellId = AI_VALUE2(uint32, "spell id", spell);
+    return spellId && AI_VALUE2(Item*, "item for spell", spellId);
+}
+
+
+bool TargetChangedTrigger::IsActive()
+{
+    Unit* oldTarget = context->GetValue<Unit*>("old target")->Get();
+    Unit* target = context->GetValue<Unit*>("current target")->Get();
+    return target && oldTarget != target;
+}
+
+Value<Unit*>* InterruptEnemyHealerTrigger::GetTargetValue()
+{
+    return context->GetValue<Unit*>("enemy healer target", spell);
+}
diff --git a/src/plugins/playerbot/strategy/triggers/GenericTriggers.h b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
new file mode 100644
index 0000000..f176429
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/GenericTriggers.h
@@ -0,0 +1,540 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+#define BUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffTrigger(ai, spell) {} \
+    };
+
+#define BUFF_ON_PARTY_TRIGGER(clazz, spell, action) \
+    class clazz : public BuffOnPartyTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : BuffOnPartyTrigger(ai, spell) {}  \
+    };
+
+#define DEBUFF_TRIGGER(clazz, spell, action) \
+    class clazz : public DebuffTrigger \
+    { \
+    public: \
+        clazz(PlayerbotAI* ai) : DebuffTrigger(ai, spell) {} \
+    };
+
+namespace ai
+{
+	class StatAvailable : public Trigger
+	{
+	public:
+		StatAvailable(PlayerbotAI* ai, int amount, string name = "stat available") : Trigger(ai, name)
+		{
+			this->amount = amount;
+		}
+
+	protected:
+		int amount;
+	};
+
+	class RageAvailable : public StatAvailable
+    {
+    public:
+        RageAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "rage available") {}
+        virtual bool IsActive();
+    };
+
+    class LightRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        LightRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 20) {}
+    };
+
+    class MediumRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        MediumRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 40) {}
+    };
+
+    class HighRageAvailableTrigger : public RageAvailable
+    {
+    public:
+        HighRageAvailableTrigger(PlayerbotAI* ai) : RageAvailable(ai, 60) {}
+    };
+
+	class EnergyAvailable : public StatAvailable
+	{
+	public:
+		EnergyAvailable(PlayerbotAI* ai, int amount) : StatAvailable(ai, amount, "energy available") {}
+		virtual bool IsActive();
+	};
+
+    class LightEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        LightEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 20) {}
+    };
+
+    class MediumEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        MediumEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 40) {}
+    };
+
+    class HighEnergyAvailableTrigger : public EnergyAvailable
+    {
+    public:
+        HighEnergyAvailableTrigger(PlayerbotAI* ai) : EnergyAvailable(ai, 60) {}
+    };
+
+	class ComboPointsAvailableTrigger : public StatAvailable
+	{
+	public:
+	    ComboPointsAvailableTrigger(PlayerbotAI* ai, int amount = 5) : StatAvailable(ai, amount, "combo points available") {}
+		virtual bool IsActive();
+	};
+
+	class LoseAggroTrigger : public Trigger {
+	public:
+		LoseAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "lose aggro") {}
+		virtual bool IsActive();
+	};
+
+	class HasAggroTrigger : public Trigger {
+	public:
+	    HasAggroTrigger(PlayerbotAI* ai) : Trigger(ai, "have aggro") {}
+		virtual bool IsActive();
+	};
+
+	class SpellTrigger : public Trigger
+	{
+	public:
+		SpellTrigger(PlayerbotAI* ai, string spell, int checkInterval = 1) : Trigger(ai, spell, checkInterval)
+		{
+			this->spell = spell;
+		}
+
+		virtual string GetTargetName() { return "current target"; }
+		virtual string getName() { return spell; }
+		virtual bool IsActive();
+
+	protected:
+		string spell;
+	};
+
+	class SpellCanBeCastTrigger : public SpellTrigger
+	{
+	public:
+		SpellCanBeCastTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+		virtual bool IsActive();
+	};
+
+	// TODO: check other targets
+    class InterruptSpellTrigger : public SpellTrigger
+	{
+    public:
+        InterruptSpellTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+        virtual bool IsActive();
+    };
+
+
+    class AttackerCountTrigger : public Trigger
+    {
+    public:
+        AttackerCountTrigger(PlayerbotAI* ai, int amount, float distance = sPlayerbotAIConfig.sightDistance) : Trigger(ai)
+        {
+            this->amount = amount;
+            this->distance = distance;
+        }
+    public:
+        virtual bool IsActive()
+		{
+            return AI_VALUE(uint8, "attacker count") >= amount;
+        }
+        virtual string getName() { return "attacker count"; }
+
+    protected:
+        int amount;
+        float distance;
+    };
+
+    class HasAttackersTrigger : public AttackerCountTrigger
+    {
+    public:
+        HasAttackersTrigger(PlayerbotAI* ai) : AttackerCountTrigger(ai, 1) {}
+    };
+
+    class MyAttackerCountTrigger : public AttackerCountTrigger
+    {
+    public:
+        MyAttackerCountTrigger(PlayerbotAI* ai, int amount) : AttackerCountTrigger(ai, amount) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "my attacker count"; }
+    };
+
+    class MediumThreatTrigger : public MyAttackerCountTrigger
+    {
+    public:
+        MediumThreatTrigger(PlayerbotAI* ai) : MyAttackerCountTrigger(ai, 2) {}
+    };
+
+    class AoeTrigger : public AttackerCountTrigger
+    {
+    public:
+        AoeTrigger(PlayerbotAI* ai, int amount = 3, float range = 15.0f) : AttackerCountTrigger(ai, amount)
+        {
+            this->range = range;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "aoe"; }
+
+    private:
+        float range;
+    };
+
+    class NoFoodTrigger : public Trigger {
+    public:
+        NoFoodTrigger(PlayerbotAI* ai) : Trigger(ai, "no food trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "food").empty(); }
+    };
+
+    class NoDrinkTrigger : public Trigger {
+    public:
+        NoDrinkTrigger(PlayerbotAI* ai) : Trigger(ai, "no drink trigger") {}
+        virtual bool IsActive() { return AI_VALUE2(list<Item*>, "inventory items", "drink").empty(); }
+    };
+
+    class LightAoeTrigger : public AoeTrigger
+    {
+    public:
+        LightAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 2, 15.0f) {}
+    };
+
+    class MediumAoeTrigger : public AoeTrigger
+    {
+    public:
+        MediumAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 3, 17.0f) {}
+    };
+
+    class HighAoeTrigger : public AoeTrigger
+    {
+    public:
+        HighAoeTrigger(PlayerbotAI* ai) : AoeTrigger(ai, 4, 20.0f) {}
+    };
+
+    class BuffTrigger : public SpellTrigger
+    {
+    public:
+        BuffTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell, 5) {}
+    public:
+		virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class BuffOnPartyTrigger : public BuffTrigger
+    {
+    public:
+        BuffOnPartyTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {}
+    public:
+		virtual Value<Unit*>* GetTargetValue();
+    };
+
+    BEGIN_TRIGGER(NoAttackersTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(NoTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    BEGIN_TRIGGER(InvalidTargetTrigger, Trigger)
+    END_TRIGGER()
+
+    class TargetInSightTrigger : public Trigger {
+    public:
+        TargetInSightTrigger(PlayerbotAI* ai) : Trigger(ai, "target in sight") {}
+        virtual bool IsActive() { return AI_VALUE(Unit*, "grind target"); }
+    };
+
+    class DebuffTrigger : public BuffTrigger
+    {
+    public:
+        DebuffTrigger(PlayerbotAI* ai, string spell) : BuffTrigger(ai, spell) {
+			checkInterval = 1;
+		}
+    public:
+		virtual string GetTargetName() { return "current target"; }
+        virtual bool IsActive();
+    };
+
+    class DebuffOnAttackerTrigger : public DebuffTrigger
+    {
+    public:
+        DebuffOnAttackerTrigger(PlayerbotAI* ai, string spell) : DebuffTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on attacker"; }
+    };
+
+	class BoostTrigger : public BuffTrigger
+	{
+	public:
+		BoostTrigger(PlayerbotAI* ai, string spell, float balance = 50) : BuffTrigger(ai, spell)
+		{
+			this->balance = balance;
+		}
+	public:
+		virtual bool IsActive();
+
+	protected:
+		float balance;
+	};
+
+    class RandomTrigger : public Trigger
+    {
+    public:
+        RandomTrigger(PlayerbotAI* ai, int probability = 200) : Trigger(ai)
+        {
+            this->probability = probability;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "random"; }
+
+    protected:
+        int probability;
+    };
+
+    class SeldomTrigger : public RandomTrigger
+    {
+    public:
+        SeldomTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 9000) {}
+        virtual string getName() { return "seldom"; }
+    };
+
+    class OftenTrigger : public RandomTrigger
+    {
+    public:
+        OftenTrigger(PlayerbotAI* ai) : RandomTrigger(ai, 50) {}
+        virtual string getName() { return "often"; }
+    };
+
+    class AndTrigger : public Trigger
+    {
+    public:
+        AndTrigger(PlayerbotAI* ai, Trigger* ls, Trigger* rs) : Trigger(ai)
+        {
+            this->ls = ls;
+            this->rs = rs;
+        }
+        virtual ~AndTrigger()
+        {
+            delete ls;
+            delete rs;
+        }
+    public:
+        virtual bool IsActive();
+        virtual string getName();
+
+    protected:
+        Trigger* ls;
+        Trigger* rs;
+    };
+
+    class SnareTargetTrigger : public DebuffTrigger
+    {
+    public:
+        SnareTargetTrigger(PlayerbotAI* ai, string aura) : DebuffTrigger(ai, aura) {}
+    public:
+        virtual bool IsActive();
+        virtual string getName() { return "target is moving"; }
+    };
+
+	class LowManaTrigger : public Trigger
+	{
+	public:
+		LowManaTrigger(PlayerbotAI* ai) : Trigger(ai, "low mana") {}
+
+		virtual bool IsActive();
+	};
+
+	class MediumManaTrigger : public Trigger
+	{
+	public:
+		MediumManaTrigger(PlayerbotAI* ai) : Trigger(ai, "medium mana") {}
+
+		virtual bool IsActive();
+	};
+
+    BEGIN_TRIGGER(PanicTrigger, Trigger)
+        virtual string getName() { return "panic"; }
+    END_TRIGGER()
+
+
+	class NoPetTrigger : public Trigger
+	{
+	public:
+		NoPetTrigger(PlayerbotAI* ai) : Trigger(ai, "no pet", 5) {}
+
+		virtual bool IsActive() {
+			return !AI_VALUE(Unit*, "pet target") && !AI_VALUE2(bool, "mounted", "self target");
+		}
+	};
+
+	class ItemCountTrigger : public Trigger {
+	public:
+		ItemCountTrigger(PlayerbotAI* ai, string item, int count) : Trigger(ai, item, 5) {
+			this->item = item;
+			this->count = count;
+		}
+	public:
+		virtual bool IsActive();
+		virtual string getName() { return "item count"; }
+
+	protected:
+		string item;
+		int count;
+	};
+
+	class HasAuraTrigger : public Trigger {
+	public:
+		HasAuraTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell, 5) {}
+
+		virtual string GetTargetName() { return "self target"; }
+		virtual bool IsActive();
+
+	};
+
+    class TimerTrigger : public Trigger
+    {
+    public:
+        TimerTrigger(PlayerbotAI* ai, int checkInterval = 5) : Trigger(ai, "timer", checkInterval) {}
+
+    public:
+        virtual bool IsActive() { return true; }
+    };
+
+	class TankAoeTrigger : public NoAttackersTrigger
+	{
+	public:
+		TankAoeTrigger(PlayerbotAI* ai) : NoAttackersTrigger(ai) {}
+
+	public:
+		virtual bool IsActive();
+
+	};
+
+    class IsBehindTargetTrigger : public Trigger
+    {
+    public:
+        IsBehindTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsNotFacingTargetTrigger : public Trigger
+    {
+    public:
+        IsNotFacingTargetTrigger(PlayerbotAI* ai) : Trigger(ai) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasCcTargetTrigger : public Trigger
+    {
+    public:
+        HasCcTargetTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+	class NoMovementTrigger : public Trigger
+	{
+	public:
+		NoMovementTrigger(PlayerbotAI* ai, string name) : Trigger(ai, name) {}
+
+	public:
+		virtual bool IsActive();
+	};
+
+
+    class NoPossibleTargetsTrigger : public Trigger
+    {
+    public:
+        NoPossibleTargetsTrigger(PlayerbotAI* ai) : Trigger(ai, "no possible targets") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class NotLeastHpTargetActiveTrigger : public Trigger
+    {
+    public:
+        NotLeastHpTargetActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "not least hp target active") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class EnemyPlayerIsAttacking : public Trigger
+    {
+    public:
+        EnemyPlayerIsAttacking(PlayerbotAI* ai) : Trigger(ai, "enemy player is attacking") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class IsSwimmingTrigger : public Trigger
+    {
+    public:
+        IsSwimmingTrigger(PlayerbotAI* ai) : Trigger(ai, "swimming") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasNearestAddsTrigger : public Trigger
+    {
+    public:
+        HasNearestAddsTrigger(PlayerbotAI* ai) : Trigger(ai, "has nearest adds") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class HasItemForSpellTrigger : public Trigger
+    {
+    public:
+        HasItemForSpellTrigger(PlayerbotAI* ai, string spell) : Trigger(ai, spell) {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class TargetChangedTrigger : public Trigger
+    {
+    public:
+        TargetChangedTrigger(PlayerbotAI* ai) : Trigger(ai, "target changed") {}
+
+    public:
+        virtual bool IsActive();
+    };
+
+    class InterruptEnemyHealerTrigger : public SpellTrigger
+    {
+    public:
+        InterruptEnemyHealerTrigger(PlayerbotAI* ai, string spell) : SpellTrigger(ai, spell) {}
+    public:
+        virtual Value<Unit*>* GetTargetValue();
+        virtual string getName() { return spell + " on enemy healer"; }
+    };
+
+}
+
+#include "RangeTriggers.h"
+#include "HealthTriggers.h"
+#include "CureTriggers.h"
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
new file mode 100644
index 0000000..703f00c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "HealthTriggers.h"
+
+using namespace ai;
+
+float HealthInRangeTrigger::GetValue()
+{
+    return AI_VALUE2(uint8, "health", GetTargetName());
+}
+
+bool PartyMemberDeadTrigger::IsActive()
+{
+	return GetTarget();
+}
+
+bool DeadTrigger::IsActive()
+{
+    return AI_VALUE2(bool, "dead", GetTargetName());
+}
+
+bool AoeHealTrigger::IsActive()
+{
+    return AI_VALUE2(uint8, "aoe heal", type) >= count;
+}
+
diff --git a/src/plugins/playerbot/strategy/triggers/HealthTriggers.h b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
new file mode 100644
index 0000000..49dc17b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/HealthTriggers.h
@@ -0,0 +1,139 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class ValueInRangeTrigger : public Trigger
+    {
+    public:
+        ValueInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue) : Trigger(ai, name) {
+            this->maxValue = maxValue;
+            this->minValue = minValue;
+        }
+    public:
+        virtual float GetValue() = 0;
+        virtual bool IsActive() {
+            float value = GetValue();
+            return value < maxValue && value >= minValue;
+        }
+
+    protected:
+        float maxValue, minValue;
+    };
+
+	class HealthInRangeTrigger : public ValueInRangeTrigger
+	{
+	public:
+		HealthInRangeTrigger(PlayerbotAI* ai, string name, float maxValue, float minValue = 0) :
+		  ValueInRangeTrigger(ai, name, maxValue, minValue) {}
+
+		virtual bool IsActive()
+		{
+		    return ValueInRangeTrigger::IsActive() && !AI_VALUE2(bool, "dead", GetTargetName());
+		}
+
+		virtual float GetValue();
+	};
+
+    class LowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        LowHealthTrigger(PlayerbotAI* ai, string name = "low health",
+            float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+		virtual string GetTargetName() { return "self target"; }
+    };
+
+    class CriticalHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        CriticalHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class MediumHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        MediumHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "medium health", sPlayerbotAIConfig.mediumHealth, sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class AlmostFullHealthTrigger : public LowHealthTrigger
+    {
+    public:
+        AlmostFullHealthTrigger(PlayerbotAI* ai) :
+            LowHealthTrigger(ai, "almost full health", sPlayerbotAIConfig.almostFullHealth, sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class PartyMemberLowHealthTrigger : public HealthInRangeTrigger
+    {
+    public:
+        PartyMemberLowHealthTrigger(PlayerbotAI* ai, string name = "party member low health", float value = sPlayerbotAIConfig.lowHealth, float minValue = sPlayerbotAIConfig.criticalHealth) :
+            HealthInRangeTrigger(ai, name, value, minValue) {}
+
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class PartyMemberCriticalHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberCriticalHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member critical health", sPlayerbotAIConfig.criticalHealth, 0) {}
+    };
+
+    class PartyMemberMediumHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberMediumHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member medium health", sPlayerbotAIConfig.mediumHealth,sPlayerbotAIConfig.lowHealth) {}
+    };
+
+    class PartyMemberAlmostFullHealthTrigger : public PartyMemberLowHealthTrigger
+    {
+    public:
+        PartyMemberAlmostFullHealthTrigger(PlayerbotAI* ai) :
+            PartyMemberLowHealthTrigger(ai, "party member almost full health", sPlayerbotAIConfig.almostFullHealth,sPlayerbotAIConfig.mediumHealth) {}
+    };
+
+    class TargetLowHealthTrigger : public HealthInRangeTrigger {
+    public:
+        TargetLowHealthTrigger(PlayerbotAI* ai, float value, float minValue = 0) :
+            HealthInRangeTrigger(ai, "target low health", value, minValue) {}
+        virtual string GetTargetName() { return "current target"; }
+    };
+
+    class TargetCriticalHealthTrigger : public TargetLowHealthTrigger
+    {
+    public:
+        TargetCriticalHealthTrigger(PlayerbotAI* ai) : TargetLowHealthTrigger(ai, 20) {}
+    };
+
+	class PartyMemberDeadTrigger : public Trigger {
+	public:
+		PartyMemberDeadTrigger(PlayerbotAI* ai) : Trigger(ai, "resurrect", 10) {}
+        virtual string GetTargetName() { return "party member to resurrect"; }
+		virtual bool IsActive();
+	};
+
+    class DeadTrigger : public Trigger {
+    public:
+        DeadTrigger(PlayerbotAI* ai) : Trigger(ai, "dead", 10) {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool IsActive();
+    };
+
+    class AoeHealTrigger : public Trigger {
+    public:
+    	AoeHealTrigger(PlayerbotAI* ai, string name, string type, int count) :
+    		Trigger(ai, name), type(type), count(count) {}
+    public:
+        virtual bool IsActive();
+
+    protected:
+        int count;
+        string type;
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LfgTriggers.h b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
new file mode 100644
index 0000000..ec8133e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LfgTriggers.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+class LfgProposalActiveTrigger : public Trigger
+{
+public:
+    LfgProposalActiveTrigger(PlayerbotAI* ai) : Trigger(ai, "lfg proposal active", 5) {}
+
+    virtual bool IsActive()
+    {
+        return AI_VALUE(uint32, "lfg proposal");
+    }
+};
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
new file mode 100644
index 0000000..cac9b60
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.cpp
@@ -0,0 +1,20 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LootTriggers.h"
+
+using namespace ai;
+
+bool LootAvailableTrigger::IsActive()
+{
+    return AI_VALUE(bool, "has available loot") && AI_VALUE(uint8, "bag space") < 80;
+}
+
+bool FarFromCurrentLootTrigger::IsActive()
+{
+    return AI_VALUE2(float, "distance", "loot target") > INTERACTION_DISTANCE;
+}
+
+bool CanLootTrigger::IsActive()
+{
+    return AI_VALUE(bool, "can loot");
+}
diff --git a/src/plugins/playerbot/strategy/triggers/LootTriggers.h b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
new file mode 100644
index 0000000..063456b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/LootTriggers.h
@@ -0,0 +1,30 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class LootAvailableTrigger : public Trigger
+    {
+    public:
+        LootAvailableTrigger(PlayerbotAI* ai) : Trigger(ai, "loot available") {}
+
+        virtual bool IsActive();
+    };
+
+    class FarFromCurrentLootTrigger : public Trigger
+    {
+    public:
+        FarFromCurrentLootTrigger(PlayerbotAI* ai) : Trigger(ai, "far from current loot") {}
+
+        virtual bool IsActive();
+    };
+
+    class CanLootTrigger : public Trigger
+    {
+    public:
+        CanLootTrigger(PlayerbotAI* ai) : Trigger(ai, "can loot") {}
+
+        virtual bool IsActive();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/RangeTriggers.h b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
new file mode 100644
index 0000000..08aba8f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/RangeTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../Trigger.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class EnemyTooCloseForSpellTrigger : public Trigger {
+    public:
+        EnemyTooCloseForSpellTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for spell") {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.spellDistance / 2;
+        }
+    };
+
+    class EnemyTooCloseForMeleeTrigger : public Trigger {
+    public:
+        EnemyTooCloseForMeleeTrigger(PlayerbotAI* ai) : Trigger(ai, "enemy too close for melee", 5) {}
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, "current target");
+            return target && AI_VALUE2(float, "distance", "current target") <= sPlayerbotAIConfig.contactDistance;
+        }
+    };
+
+    class OutOfRangeTrigger : public Trigger {
+    public:
+        OutOfRangeTrigger(PlayerbotAI* ai, string name, float distance) : Trigger(ai, name)
+		{
+            this->distance = distance;
+        }
+        virtual bool IsActive()
+		{
+			Unit* target = AI_VALUE(Unit*, GetTargetName());
+			return target && AI_VALUE2(float, "distance", GetTargetName()) > distance;
+        }
+        virtual string GetTargetName() { return "current target"; }
+
+    protected:
+        float distance;
+    };
+
+    class EnemyOutOfMeleeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfMeleeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of melee range", sPlayerbotAIConfig.meleeDistance) {}
+    };
+
+    class EnemyOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        EnemyOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "enemy out of spell range", sPlayerbotAIConfig.spellDistance) {}
+    };
+
+    class PartyMemberToHealOutOfSpellRangeTrigger : public OutOfRangeTrigger
+	{
+    public:
+        PartyMemberToHealOutOfSpellRangeTrigger(PlayerbotAI* ai) : OutOfRangeTrigger(ai, "party member to heal out of spell range", sPlayerbotAIConfig.spellDistance) {}
+        virtual string GetTargetName() { return "party member to heal"; }
+    };
+
+    class FarFromMasterTrigger : public Trigger {
+    public:
+        FarFromMasterTrigger(PlayerbotAI* ai, string name = "far from master", float distance = 12.0f, int checkInterval = 1) : Trigger(ai, name, checkInterval), distance(distance) {}
+
+        virtual bool IsActive()
+        {
+            return AI_VALUE2(float, "distance", "master target") > distance;
+        }
+
+    private:
+        float distance;
+    };
+
+    class OutOfReactRangeTrigger : public FarFromMasterTrigger
+    {
+    public:
+        OutOfReactRangeTrigger(PlayerbotAI* ai) : FarFromMasterTrigger(ai, "out of react range", sPlayerbotAIConfig.reactDistance / 2, 10) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/TriggerContext.h b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
new file mode 100644
index 0000000..9906cae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/TriggerContext.h
@@ -0,0 +1,158 @@
+#pragma once
+
+#include "HealthTriggers.h"
+#include "GenericTriggers.h"
+#include "LootTriggers.h"
+#include "../triggers/GenericTriggers.h"
+#include "LfgTriggers.h"
+
+namespace ai
+{
+
+    class TriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        TriggerContext()
+        {
+            creators["timer"] = &TriggerContext::Timer;
+            creators["random"] = &TriggerContext::Random;
+            creators["seldom"] = &TriggerContext::seldom;
+            creators["often"] = &TriggerContext::often;
+
+            creators["target critical health"] = &TriggerContext::TargetCriticalHealth;
+
+            creators["critical health"] = &TriggerContext::CriticalHealth;
+            creators["low health"] = &TriggerContext::LowHealth;
+            creators["medium health"] = &TriggerContext::MediumHealth;
+            creators["almost full health"] = &TriggerContext::AlmostFullHealth;
+
+            creators["low mana"] = &TriggerContext::LowMana;
+            creators["medium mana"] = &TriggerContext::MediumMana;
+
+            creators["party member critical health"] = &TriggerContext::PartyMemberCriticalHealth;
+            creators["party member low health"] = &TriggerContext::PartyMemberLowHealth;
+            creators["party member medium health"] = &TriggerContext::PartyMemberMediumHealth;
+            creators["party member almost full health"] = &TriggerContext::PartyMemberAlmostFullHealth;
+
+            creators["light rage available"] = &TriggerContext::LightRageAvailable;
+            creators["medium rage available"] = &TriggerContext::MediumRageAvailable;
+            creators["high rage available"] = &TriggerContext::HighRageAvailable;
+
+            creators["light energy available"] = &TriggerContext::LightEnergyAvailable;
+            creators["medium energy available"] = &TriggerContext::MediumEnergyAvailable;
+            creators["high energy available"] = &TriggerContext::HighEnergyAvailable;
+
+            creators["loot available"] = &TriggerContext::LootAvailable;
+            creators["no attackers"] = &TriggerContext::NoAttackers;
+            creators["no target"] = &TriggerContext::NoTarget;
+            creators["target in sight"] = &TriggerContext::TargetInSight;
+            creators["not least hp target active"] = &TriggerContext::not_least_hp_target_active;
+            creators["has nearest adds"] = &TriggerContext::has_nearest_adds;
+            creators["enemy player is attacking"] = &TriggerContext::enemy_player_is_attacking;
+
+            creators["tank aoe"] = &TriggerContext::TankAoe;
+            creators["lose aggro"] = &TriggerContext::LoseAggro;
+            creators["has aggro"] = &TriggerContext::HasAggro;
+
+            creators["light aoe"] = &TriggerContext::LightAoe;
+            creators["medium aoe"] = &TriggerContext::MediumAoe;
+            creators["high aoe"] = &TriggerContext::HighAoe;
+
+            creators["enemy out of melee"] = &TriggerContext::EnemyOutOfMelee;
+            creators["enemy out of spell"] = &TriggerContext::EnemyOutOfSpell;
+            creators["enemy too close for spell"] = &TriggerContext::enemy_too_close_for_spell;
+            creators["enemy too close for melee"] = &TriggerContext::enemy_too_close_for_melee;
+
+            creators["combo points available"] = &TriggerContext::ComboPointsAvailable;
+
+            creators["medium threat"] = &TriggerContext::MediumThreat;
+
+            creators["dead"] = &TriggerContext::Dead;
+            creators["party member dead"] = &TriggerContext::PartyMemberDead;
+            creators["no pet"] = &TriggerContext::no_pet;
+            creators["has attackers"] = &TriggerContext::has_attackers;
+            creators["no possible targets"] = &TriggerContext::no_possible_targets;
+
+            creators["no drink"] = &TriggerContext::no_drink;
+            creators["no food"] = &TriggerContext::no_food;
+
+            creators["panic"] = &TriggerContext::panic;
+            creators["behind target"] = &TriggerContext::behind_target;
+            creators["not facing target"] = &TriggerContext::not_facing_target;
+            creators["far from master"] = &TriggerContext::far_from_master;
+            creators["far from loot target"] = &TriggerContext::far_from_loot_target;
+            creators["can loot"] = &TriggerContext::can_loot;
+            creators["swimming"] = &TriggerContext::swimming;
+            creators["target changed"] = &TriggerContext::target_changed;
+
+            creators["critical aoe heal"] = &TriggerContext::critical_aoe_heal;
+            creators["low aoe heal"] = &TriggerContext::low_aoe_heal;
+            creators["medium aoe heal"] = &TriggerContext::medium_aoe_heal;
+            creators["invalid target"] = &TriggerContext::invalid_target;
+            creators["lfg proposal active"] = &TriggerContext::lfg_proposal_active;
+        }
+
+    private:
+        static Trigger* lfg_proposal_active(PlayerbotAI* ai) { return new LfgProposalActiveTrigger(ai); }
+        static Trigger* invalid_target(PlayerbotAI* ai) { return new InvalidTargetTrigger(ai); }
+        static Trigger* critical_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "critical aoe heal", "critical", 2); }
+        static Trigger* low_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "low aoe heal", "low", 2); }
+        static Trigger* medium_aoe_heal(PlayerbotAI* ai) { return new AoeHealTrigger(ai, "medium aoe heal", "medium", 2); }
+        static Trigger* target_changed(PlayerbotAI* ai) { return new TargetChangedTrigger(ai); }
+        static Trigger* swimming(PlayerbotAI* ai) { return new IsSwimmingTrigger(ai); }
+        static Trigger* no_possible_targets(PlayerbotAI* ai) { return new NoPossibleTargetsTrigger(ai); }
+        static Trigger* can_loot(PlayerbotAI* ai) { return new CanLootTrigger(ai); }
+        static Trigger* far_from_loot_target(PlayerbotAI* ai) { return new FarFromCurrentLootTrigger(ai); }
+        static Trigger* far_from_master(PlayerbotAI* ai) { return new FarFromMasterTrigger(ai); }
+        static Trigger* behind_target(PlayerbotAI* ai) { return new IsBehindTargetTrigger(ai); }
+        static Trigger* not_facing_target(PlayerbotAI* ai) { return new IsNotFacingTargetTrigger(ai); }
+        static Trigger* panic(PlayerbotAI* ai) { return new PanicTrigger(ai); }
+        static Trigger* no_drink(PlayerbotAI* ai) { return new NoDrinkTrigger(ai); }
+        static Trigger* no_food(PlayerbotAI* ai) { return new NoFoodTrigger(ai); }
+        static Trigger* LightAoe(PlayerbotAI* ai) { return new LightAoeTrigger(ai); }
+        static Trigger* MediumAoe(PlayerbotAI* ai) { return new MediumAoeTrigger(ai); }
+        static Trigger* HighAoe(PlayerbotAI* ai) { return new HighAoeTrigger(ai); }
+        static Trigger* LoseAggro(PlayerbotAI* ai) { return new LoseAggroTrigger(ai); }
+        static Trigger* HasAggro(PlayerbotAI* ai) { return new HasAggroTrigger(ai); }
+        static Trigger* LowHealth(PlayerbotAI* ai) { return new LowHealthTrigger(ai); }
+        static Trigger* MediumHealth(PlayerbotAI* ai) { return new MediumHealthTrigger(ai); }
+        static Trigger* AlmostFullHealth(PlayerbotAI* ai) { return new AlmostFullHealthTrigger(ai); }
+        static Trigger* CriticalHealth(PlayerbotAI* ai) { return new CriticalHealthTrigger(ai); }
+        static Trigger* TargetCriticalHealth(PlayerbotAI* ai) { return new TargetCriticalHealthTrigger(ai); }
+        static Trigger* LowMana(PlayerbotAI* ai) { return new LowManaTrigger(ai); }
+        static Trigger* MediumMana(PlayerbotAI* ai) { return new MediumManaTrigger(ai); }
+        static Trigger* LightRageAvailable(PlayerbotAI* ai) { return new LightRageAvailableTrigger(ai); }
+        static Trigger* MediumRageAvailable(PlayerbotAI* ai) { return new MediumRageAvailableTrigger(ai); }
+        static Trigger* HighRageAvailable(PlayerbotAI* ai) { return new HighRageAvailableTrigger(ai); }
+        static Trigger* LightEnergyAvailable(PlayerbotAI* ai) { return new LightEnergyAvailableTrigger(ai); }
+        static Trigger* MediumEnergyAvailable(PlayerbotAI* ai) { return new MediumEnergyAvailableTrigger(ai); }
+        static Trigger* HighEnergyAvailable(PlayerbotAI* ai) { return new HighEnergyAvailableTrigger(ai); }
+        static Trigger* LootAvailable(PlayerbotAI* ai) { return new LootAvailableTrigger(ai); }
+        static Trigger* NoAttackers(PlayerbotAI* ai) { return new NoAttackersTrigger(ai); }
+        static Trigger* TankAoe(PlayerbotAI* ai) { return new TankAoeTrigger(ai); }
+        static Trigger* Timer(PlayerbotAI* ai) { return new TimerTrigger(ai); }
+        static Trigger* NoTarget(PlayerbotAI* ai) { return new NoTargetTrigger(ai); }
+        static Trigger* TargetInSight(PlayerbotAI* ai) { return new TargetInSightTrigger(ai); }
+        static Trigger* not_least_hp_target_active(PlayerbotAI* ai) { return new NotLeastHpTargetActiveTrigger(ai); }
+        static Trigger* has_nearest_adds(PlayerbotAI* ai) { return new HasNearestAddsTrigger(ai); }
+        static Trigger* enemy_player_is_attacking(PlayerbotAI* ai) { return new EnemyPlayerIsAttacking(ai); }
+        static Trigger* Random(PlayerbotAI* ai) { return new RandomTrigger(ai); }
+        static Trigger* seldom(PlayerbotAI* ai) { return new SeldomTrigger(ai); }
+        static Trigger* often(PlayerbotAI* ai) { return new OftenTrigger(ai); }
+        static Trigger* EnemyOutOfMelee(PlayerbotAI* ai) { return new EnemyOutOfMeleeTrigger(ai); }
+        static Trigger* EnemyOutOfSpell(PlayerbotAI* ai) { return new EnemyOutOfSpellRangeTrigger(ai); }
+        static Trigger* enemy_too_close_for_spell(PlayerbotAI* ai) { return new EnemyTooCloseForSpellTrigger(ai); }
+        static Trigger* enemy_too_close_for_melee(PlayerbotAI* ai) { return new EnemyTooCloseForMeleeTrigger(ai); }
+        static Trigger* ComboPointsAvailable(PlayerbotAI* ai) { return new ComboPointsAvailableTrigger(ai); }
+        static Trigger* MediumThreat(PlayerbotAI* ai) { return new MediumThreatTrigger(ai); }
+        static Trigger* Dead(PlayerbotAI* ai) { return new DeadTrigger(ai); }
+        static Trigger* PartyMemberDead(PlayerbotAI* ai) { return new PartyMemberDeadTrigger(ai); }
+        static Trigger* PartyMemberLowHealth(PlayerbotAI* ai) { return new PartyMemberLowHealthTrigger(ai); }
+        static Trigger* PartyMemberMediumHealth(PlayerbotAI* ai) { return new PartyMemberMediumHealthTrigger(ai); }
+        static Trigger* PartyMemberAlmostFullHealth(PlayerbotAI* ai) { return new PartyMemberAlmostFullHealthTrigger(ai); }
+        static Trigger* PartyMemberCriticalHealth(PlayerbotAI* ai) { return new PartyMemberCriticalHealthTrigger(ai); }
+        static Trigger* no_pet(PlayerbotAI* ai) { return new NoPetTrigger(ai); }
+        static Trigger* has_attackers(PlayerbotAI* ai) { return new HasAttackersTrigger(ai); }
+
+    };
+};
diff --git a/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
new file mode 100644
index 0000000..01c130a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WithinAreaTrigger.h
@@ -0,0 +1,76 @@
+#pragma once
+#include "../Trigger.h"
+#include "../values/LastMovementValue.h"
+
+namespace ai
+{
+    class WithinAreaTrigger : public Trigger {
+    public:
+        WithinAreaTrigger(PlayerbotAI* ai) : Trigger(ai, "within area trigger") {}
+
+        virtual bool IsActive()
+		{
+
+
+            LastMovement& movement = context->GetValue<LastMovement&>("last movement")->Get();
+            if (!movement.lastAreaTrigger)
+                return false;
+
+            AreaTriggerEntry const* atEntry = sAreaTriggerStore.LookupEntry(movement.lastAreaTrigger);
+            if(!atEntry)
+                return false;
+
+            AreaTrigger const* at = sObjectMgr->GetAreaTrigger(movement.lastAreaTrigger);
+            if (!at)
+                return false;
+
+            return IsPointInAreaTriggerZone(atEntry, bot->GetMapId(), bot->GetPositionX(), bot->GetPositionY(), bot->GetPositionZ(), 0.5f);
+        }
+
+    private:
+        bool IsPointInAreaTriggerZone(AreaTriggerEntry const* atEntry, uint32 mapid, float x, float y, float z, float delta)
+        {
+            if (mapid != atEntry->mapid)
+                return false;
+
+            if (atEntry->radius > 0)
+            {
+                // if we have radius check it
+                float dist2 = (x - atEntry->x) * (x - atEntry->x) + (y - atEntry->y) * (y - atEntry->y) + (z - atEntry->z) * (z - atEntry->z);
+                if (dist2 > (atEntry->radius + delta) * (atEntry->radius + delta))
+                    return false;
+            }
+            else
+            {
+                // we have only extent
+
+                // rotate the players position instead of rotating the whole cube, that way we can make a simplified
+                // is-in-cube check and we have to calculate only one point instead of 4
+
+                // 2PI = 360, keep in mind that ingame orientation is counter-clockwise
+                double rotation = 2 * M_PI - atEntry->box_orientation;
+                double sinVal = sin(rotation);
+                double cosVal = cos(rotation);
+
+                float playerBoxDistX = x - atEntry->x;
+                float playerBoxDistY = y - atEntry->y;
+
+                float rotPlayerX = float(atEntry->x + playerBoxDistX * cosVal - playerBoxDistY * sinVal);
+                float rotPlayerY = float(atEntry->y + playerBoxDistY * cosVal + playerBoxDistX * sinVal);
+
+                // box edges are parallel to coordiante axis, so we can treat every dimension independently :D
+                float dz = z - atEntry->z;
+                float dx = rotPlayerX - atEntry->x;
+                float dy = rotPlayerY - atEntry->y;
+                if ((fabs(dx) > atEntry->box_x / 2 + delta) ||
+                        (fabs(dy) > atEntry->box_y / 2 + delta) ||
+                        (fabs(dz) > atEntry->box_z / 2 + delta))
+                {
+                    return false;
+                }
+            }
+
+            return true;
+        }
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
new file mode 100644
index 0000000..b0f8b87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTrigger.h
@@ -0,0 +1,36 @@
+#pragma once
+
+#include "../Trigger.h"
+
+namespace ai
+{
+    class WorldPacketTrigger : public Trigger {
+    public:
+        WorldPacketTrigger(PlayerbotAI* ai, string command) : Trigger(ai, command), triggered(false) {}
+
+        virtual void ExternalEvent(WorldPacket &packet, Player* owner = NULL)
+        {
+            this->packet = packet;
+            this->owner = owner;
+            triggered = true;
+        }
+
+        virtual Event Check()
+        {
+            if (!triggered)
+                return Event();
+
+            return Event(getName(), packet, owner);
+        }
+
+        virtual void Reset()
+        {
+            triggered = false;
+        }
+
+    private:
+        WorldPacket packet;
+        bool triggered;
+        Player* owner;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
new file mode 100644
index 0000000..e1bda4f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/triggers/WorldPacketTriggerContext.h
@@ -0,0 +1,85 @@
+#pragma once
+
+#include "WorldPacketTrigger.h"
+#include "WithinAreaTrigger.h"
+
+namespace ai
+{
+    class WorldPacketTriggerContext : public NamedObjectContext<Trigger>
+    {
+    public:
+        WorldPacketTriggerContext()
+        {
+            creators["gossip hello"] = &WorldPacketTriggerContext::gossip_hello;
+            creators["group invite"] = &WorldPacketTriggerContext::group_invite;
+            creators["group set leader"] = &WorldPacketTriggerContext::group_set_leader;
+            creators["not enough money"] = &WorldPacketTriggerContext::no_money;
+            creators["not enough reputation"] = &WorldPacketTriggerContext::no_reputation;
+            creators["cannot equip"] = &WorldPacketTriggerContext::cannot_equip;
+            creators["use game object"] = &WorldPacketTriggerContext::use_game_object;
+            creators["complete quest"] = &WorldPacketTriggerContext::complete_quest;
+            creators["accept quest"] = &WorldPacketTriggerContext::accept_quest;
+            creators["quest share"] = &WorldPacketTriggerContext::quest_share;
+            creators["loot roll"] = &WorldPacketTriggerContext::loot_roll;
+            creators["resurrect request"] = &WorldPacketTriggerContext::resurrect_request;
+            creators["area trigger"] = &WorldPacketTriggerContext::area_trigger;
+            creators["within area trigger"] = &WorldPacketTriggerContext::within_area_trigger;
+            creators["check mount state"] = &WorldPacketTriggerContext::check_mount_state;
+            creators["activate taxi"] = &WorldPacketTriggerContext::taxi;
+            creators["trade status"] = &WorldPacketTriggerContext::trade_status;
+            creators["loot response"] = &WorldPacketTriggerContext::loot_response;
+            creators["out of react range"] = &WorldPacketTriggerContext::out_of_react_range;
+            creators["quest objective completed"] = &WorldPacketTriggerContext::quest_objective_completed;
+            creators["item push result"] = &WorldPacketTriggerContext::item_push_result;
+            creators["party command"] = &WorldPacketTriggerContext::party_command;
+            creators["taxi done"] = &WorldPacketTriggerContext::taxi_done;
+            creators["cast failed"] = &WorldPacketTriggerContext::cast_failed;
+            creators["duel requested"] = &WorldPacketTriggerContext::duel_requested;
+            creators["ready check"] = &WorldPacketTriggerContext::ready_check;
+            creators["ready check finished"] = &WorldPacketTriggerContext::ready_check_finished;
+            creators["uninvite"] = &WorldPacketTriggerContext::uninvite;
+            creators["lfg join"] = &WorldPacketTriggerContext::lfg_update;
+            creators["lfg proposal"] = &WorldPacketTriggerContext::lfg_proposal;
+            creators["lfg role check"] = &WorldPacketTriggerContext::lfg_role_check;
+            creators["lfg leave"] = &WorldPacketTriggerContext::lfg_leave;
+            creators["guild invite"] = &WorldPacketTriggerContext::guild_invite;
+            creators["lfg teleport"] = &WorldPacketTriggerContext::lfg_teleport;
+        }
+
+    private:
+        static Trigger* guild_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "guild invite"); }
+        static Trigger* lfg_teleport(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg teleport"); }
+        static Trigger* lfg_leave(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg leave"); }
+        static Trigger* lfg_proposal(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg proposal"); }
+        static Trigger* lfg_role_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg role check"); }
+        static Trigger* lfg_update(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "lfg join"); }
+        static Trigger* uninvite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "uninvite"); }
+        static Trigger* ready_check_finished(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check finished"); }
+        static Trigger* ready_check(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "ready check"); }
+        static Trigger* duel_requested(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "duel requested"); }
+        static Trigger* cast_failed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cast failed"); }
+        static Trigger* taxi_done(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "taxi done"); }
+        static Trigger* party_command(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "party command"); }
+        static Trigger* item_push_result(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "item push result"); }
+        static Trigger* quest_objective_completed(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest objective completed"); }
+        static Trigger* out_of_react_range(PlayerbotAI* ai) { return new OutOfReactRangeTrigger(ai); }
+        static Trigger* loot_response(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot response"); }
+        static Trigger* trade_status(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "trade status"); }
+        static Trigger* cannot_equip(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "cannot equip"); }
+        static Trigger* check_mount_state(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "check mount state"); }
+        static Trigger* area_trigger(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "area trigger"); }
+        static Trigger* within_area_trigger(PlayerbotAI* ai) { return new WithinAreaTrigger(ai); }
+        static Trigger* resurrect_request(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "resurrect request"); }
+        static Trigger* gossip_hello(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "gossip hello"); }
+        static Trigger* group_invite(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group invite"); }
+        static Trigger* group_set_leader(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "group set leader"); }
+        static Trigger* no_money(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough money"); }
+        static Trigger* no_reputation(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "not enough reputation"); }
+        static Trigger* use_game_object(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "use game object"); }
+        static Trigger* complete_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "complete quest"); }
+        static Trigger* accept_quest(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "accept quest"); }
+        static Trigger* quest_share(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "quest share"); }
+        static Trigger* loot_roll(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "loot roll"); }
+        static Trigger* taxi(PlayerbotAI* ai) { return new WorldPacketTrigger(ai, "activate taxi"); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
new file mode 100644
index 0000000..22c2f3a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AlwaysLootListValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AlwaysLootListValue : public ManualSetValue<set<uint32>&>
+	{
+	public:
+        AlwaysLootListValue(PlayerbotAI* ai) : ManualSetValue<set<uint32>&>(ai, list) {}
+
+    private:
+        set<uint32> list;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.cpp b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
new file mode 100644
index 0000000..14c50b2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AoeHealValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 AoeHealValue::Calculate()
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+    	return 0;
+
+    float range = 0;
+    if (qualifier == "low")
+    	range = sPlayerbotAIConfig.lowHealth;
+    else if (qualifier == "medium")
+    	range = sPlayerbotAIConfig.mediumHealth;
+    else if (qualifier == "critical")
+    	range = sPlayerbotAIConfig.criticalHealth;
+
+    uint8 count = 0;
+	Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+	for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+	{
+		Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+		if( !player || !player->IsAlive())
+			continue;
+
+	    float percent = (static_cast<float> (player->GetHealth()) / player->GetMaxHealth()) * 100;
+	    if (percent <= range)
+	    	count++;
+	}
+
+	return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AoeHealValues.h b/src/plugins/playerbot/strategy/values/AoeHealValues.h
new file mode 100644
index 0000000..d7d52c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AoeHealValues.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AoeHealValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+    	AoeHealValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
new file mode 100644
index 0000000..a406a90
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.cpp
@@ -0,0 +1,107 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerCountValues.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+uint8 MyAttackerCountValue::Calculate()
+{
+    return bot->getAttackers().size();
+}
+
+bool HasAggroValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return true;
+
+    HostileReference *ref = bot->getHostileRefManager().getFirst();
+    if (!ref)
+        return true; // simulate as target is not atacking anybody yet
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == bot && target == attacker)
+            return true;
+        ref = ref->next();
+    }
+    return false;
+}
+
+uint8 AttackerCountValue::Calculate()
+{
+    int count = 0;
+    float range = sPlayerbotAIConfig.sightDistance;
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        float distance = bot->GetDistance(unit);
+        if (distance <= range)
+            count++;
+    }
+
+    return count;
+}
+
+uint8 BalancePercentValue::Calculate()
+{
+    float playerLevel = 0,
+        attackerLevel = 0;
+
+    Group* group = bot->GetGroup();
+    if (group)
+    {
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !player || !player->IsAlive())
+                continue;
+
+            playerLevel += player->getLevel();
+        }
+    }
+
+    list<ObjectGuid> v = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+
+    for (list<ObjectGuid>::iterator i = v.begin(); i!=v.end(); i++)
+    {
+        Creature* creature = ai->GetCreature((*i));
+        if (!creature || !creature->IsAlive())
+            continue;
+
+        uint32 level = creature->getLevel();
+
+        switch (creature->GetCreatureTemplate()->rank) {
+        case CREATURE_ELITE_RARE:
+            level *= 2;
+            break;
+        case CREATURE_ELITE_ELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_RAREELITE:
+            level *= 3;
+            break;
+        case CREATURE_ELITE_WORLDBOSS:
+            level *= 5;
+            break;
+        }
+        attackerLevel += level;
+    }
+
+    if (!attackerLevel)
+        return 100;
+
+    float percent = playerLevel * 100 / attackerLevel;
+    return percent <= 200 ? (uint8)percent : 200;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/AttackerCountValues.h b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
new file mode 100644
index 0000000..9c77a3f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerCountValues.h
@@ -0,0 +1,59 @@
+#pragma once
+#include "StatsValues.h"
+
+namespace ai
+{
+
+    class AttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        AttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class MyAttackerCountValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        MyAttackerCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasAggroValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasAggroValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class BalancePercentValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        BalancePercentValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
new file mode 100644
index 0000000..10da8d2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* AttackerWithoutAuraTargetValue::Calculate()
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->HasAura(qualifier, unit))
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
new file mode 100644
index 0000000..70a8983
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackerWithoutAuraTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class AttackerWithoutAuraTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        AttackerWithoutAuraTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "attacker without aura") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.cpp b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
new file mode 100644
index 0000000..e24f99d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.cpp
@@ -0,0 +1,94 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "AttackersValue.h"
+
+#include "../../../../server/game/Entities/Pet/Pet.h"
+
+using namespace ai;
+
+list<ObjectGuid> AttackersValue::Calculate()
+{
+    set<Unit*> targets;
+
+    AddAttackersOf(bot, targets);
+
+    Group* group = bot->GetGroup();
+    if (group)
+        AddAttackersOf(group, targets);
+
+    RemoveNonThreating(targets);
+
+    list<ObjectGuid> result;
+	for (set<Unit*>::iterator i = targets.begin(); i != targets.end(); i++)
+		result.push_back((*i)->GetGUID());
+
+    if (bot->duel && bot->duel->opponent)
+        result.push_back(bot->duel->opponent->GetGUID());
+
+	return result;
+}
+
+void AttackersValue::AddAttackersOf(Group* group, set<Unit*>& targets)
+{
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if (!member || !member->IsAlive() || member == bot)
+            continue;
+
+        if (member->IsBeingTeleported())
+            return;
+
+        AddAttackersOf(member, targets);
+
+        Pet* pet = member->GetPet();
+        if (pet)
+            AddAttackersOf(pet, targets);
+    }
+}
+
+void AttackersValue::AddAttackersOf(Unit* unit, set<Unit*>& targets)
+{
+    HostileRefManager& refManager = unit->getHostileRefManager();
+    HostileReference *ref = refManager.getFirst();
+    if (!ref)
+        return;
+
+    while( ref )
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        if (victim == unit)
+            targets.insert(attacker);
+        ref = ref->next();
+    }
+}
+
+void AttackersValue::RemoveNonThreating(set<Unit*>& targets)
+{
+    for(set<Unit *>::iterator tIter = targets.begin(); tIter != targets.end();)
+    {
+        Unit* unit = *tIter;
+        if(!bot->IsWithinLOSInMap(unit) || bot->GetMapId() != unit->GetMapId() || !hasRealThreat(unit))
+        {
+            set<Unit *>::iterator tIter2 = tIter;
+            ++tIter;
+            targets.erase(tIter2);
+        }
+        else
+            ++tIter;
+    }
+}
+
+bool AttackersValue::hasRealThreat(Unit *attacker)
+{
+    return attacker &&
+        attacker->IsInWorld() &&
+        attacker->IsAlive() &&
+        !attacker->IsPolymorphed() &&
+        !attacker->isInRoots() &&
+        !attacker->IsFriendlyTo(bot) &&
+        (attacker->getThreatManager().getCurrentVictim() || dynamic_cast<Player*>(attacker));
+}
diff --git a/src/plugins/playerbot/strategy/values/AttackersValue.h b/src/plugins/playerbot/strategy/values/AttackersValue.h
new file mode 100644
index 0000000..02f1b62
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AttackersValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "NearestUnitsValue.h"
+
+namespace ai
+{
+    class AttackersValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        AttackersValue(PlayerbotAI* ai) : ObjectGuidListCalculatedValue(ai, "attackers", 5) {}
+        list<ObjectGuid> Calculate();
+
+	private:
+        void AddAttackersOf(Group* group, set<Unit*>& targets);
+        void AddAttackersOf(Unit* unit, set<Unit*>& targets);
+		void RemoveNonThreating(set<Unit*>& targets);
+		bool hasRealThreat(Unit* attacker);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/AvailableLootValue.h b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
new file mode 100644
index 0000000..806f2ef
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/AvailableLootValue.h
@@ -0,0 +1,40 @@
+#pragma once
+#include "../Value.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+   
+    class AvailableLootValue : public ManualSetValue<LootObjectStack*>
+	{
+	public:
+        AvailableLootValue(PlayerbotAI* ai) : ManualSetValue<LootObjectStack*>(ai, NULL) 
+        {
+            value = new LootObjectStack(ai->GetBot());
+        }
+
+        virtual ~AvailableLootValue()
+        {
+            if (value) 
+                delete value;
+        }
+    };
+
+    class LootTargetValue : public ManualSetValue<LootObject>
+    {
+    public:
+        LootTargetValue(PlayerbotAI* ai) : ManualSetValue<LootObject>(ai, LootObject()) {}
+    };
+
+    class CanLootValue : public BoolCalculatedValue
+    {
+    public:
+        CanLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            LootObject loot = AI_VALUE(LootObject, "loot target");
+            return !loot.IsEmpty() && loot.GetWorldObject(bot) && AI_VALUE2(float, "distance", "loot target") <= INTERACTION_DISTANCE;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
new file mode 100644
index 0000000..2660a81
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.cpp
@@ -0,0 +1,88 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CcTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../Action.h"
+
+using namespace ai;
+
+class FindTargetForCcStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForCcStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+        maxDistance = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("current target") == creature)
+            return;
+
+        uint8 health = creature->GetHealthPct();
+        if (health < sPlayerbotAIConfig.mediumHealth)
+            return;
+
+        if (!ai->CanCastSpell(spell, creature))
+            return;
+
+        if (*ai->GetAiObjectContext()->GetValue<Unit*>("rti target") == creature)
+        {
+            result = creature;
+            return;
+        }
+
+        float minDistance = sPlayerbotAIConfig.spellDistance;
+        Group* group = bot->GetGroup();
+        if (!group)
+            return;
+
+        if (group->GetTargetIcon(4) == creature->GetGUID())
+        {
+            result = creature;
+            return;
+        }
+
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+        if (!tankCount || !dpsCount)
+        {
+            result = creature;
+            return;
+        }
+
+        Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+        for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+        {
+            Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+            if( !member || !member->IsAlive() || member == bot)
+                continue;
+
+            if (!ai->IsTank(member))
+                continue;
+
+            float distance = member->GetDistance(creature);
+            if (distance < minDistance)
+                minDistance = distance;
+        }
+
+        if (!result || minDistance > maxDistance)
+        {
+            result = creature;
+            maxDistance = minDistance;
+        }
+    }
+
+private:
+    string spell;
+    float maxDistance;
+};
+
+Unit* CcTargetValue::Calculate()
+{
+    FindTargetForCcStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CcTargetValue.h b/src/plugins/playerbot/strategy/values/CcTargetValue.h
new file mode 100644
index 0000000..a27f8c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ChatValue.h b/src/plugins/playerbot/strategy/values/ChatValue.h
new file mode 100644
index 0000000..b39a583
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ChatValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ChatValue : public ManualSetValue<ChatMsg>
+	{
+	public:
+        ChatValue(PlayerbotAI* ai) : ManualSetValue<ChatMsg>(ai, CHAT_MSG_WHISPER) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
new file mode 100644
index 0000000..932b0c0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.cpp
@@ -0,0 +1,31 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentCcTargetValue.h"
+
+using namespace ai;
+
+class FindCurrentCcTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindCurrentCcTargetStrategy(PlayerbotAI* ai, string spell) : FindTargetStrategy(ai)
+    {
+        this->spell = spell;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (ai->HasAura(spell, attacker))
+            result = attacker;
+    }
+
+private:
+    string spell;
+};
+
+
+Unit* CurrentCcTargetValue::Calculate()
+{
+    FindCurrentCcTargetStrategy strategy(ai, qualifier);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
new file mode 100644
index 0000000..30646c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentCcTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class CurrentCcTargetValue : public TargetValue, public Qualified
+	{
+	public:
+        CurrentCcTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
new file mode 100644
index 0000000..4e97d2c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.cpp
@@ -0,0 +1,22 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "CurrentTargetValue.h"
+
+using namespace ai;
+
+Unit* CurrentTargetValue::Get()
+{
+    if (selection.IsEmpty())
+        return NULL;
+
+    Unit* unit = ObjectAccessor::GetUnit(*bot, selection);
+    if (unit && !bot->IsWithinLOSInMap(unit))
+        return NULL;
+
+    return unit;
+}
+
+void CurrentTargetValue::Set(Unit* target)
+{
+    selection = target ? target->GetGUID() : ObjectGuid::Empty;
+}
diff --git a/src/plugins/playerbot/strategy/values/CurrentTargetValue.h b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
new file mode 100644
index 0000000..6b9fb69
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/CurrentTargetValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class CurrentTargetValue : public UnitManualSetValue
+	{
+	public:
+        CurrentTargetValue(PlayerbotAI* ai) : UnitManualSetValue(ai, NULL) {}
+
+        virtual Unit* Get();
+        virtual void Set(Unit* unit);
+
+    private:
+        ObjectGuid selection;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DistanceValue.h b/src/plugins/playerbot/strategy/values/DistanceValue.h
new file mode 100644
index 0000000..43277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DistanceValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class DistanceValue : public FloatCalculatedValue, public Qualified
+	{
+	public:
+        DistanceValue(PlayerbotAI* ai) : FloatCalculatedValue(ai) {}
+
+    public:
+        float Calculate()
+        {
+            if (qualifier == "loot target")
+            {
+                LootObject loot = AI_VALUE(LootObject, qualifier);
+                if (loot.IsEmpty())
+                    return 0.0f;
+
+                WorldObject* obj = loot.GetWorldObject(bot);
+                if (!obj)
+                    return 0.0f;
+
+                return ai->GetBot()->GetDistance(obj);
+            }
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target || !target->IsInWorld())
+                return 0.0f;
+
+            return ai->GetBot()->GetDistance(target);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
new file mode 100644
index 0000000..afcdcbc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.cpp
@@ -0,0 +1,45 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DpsTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForDpsStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForDpsStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        maxTankCount = 0;
+        minDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        float threat = threatManager->getThreat(ai->GetBot());
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            minThreat >= threat && (maxTankCount <= tankCount || minDpsCount >= dpsCount))
+        {
+            minThreat = threat;
+            maxTankCount = tankCount;
+            minDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int maxTankCount;
+    int minDpsCount;
+};
+
+
+Unit* DpsTargetValue::Calculate()
+{
+    FindTargetForDpsStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/DpsTargetValue.h b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
new file mode 100644
index 0000000..dcfcc8b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DpsTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class DpsTargetValue : public TargetValue
+	{
+	public:
+        DpsTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
new file mode 100644
index 0000000..06c9bf3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "DuelTargetValue.h"
+
+using namespace ai;
+
+Unit* DuelTargetValue::Calculate()
+{
+    return bot->duel ? bot->duel->opponent : NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/DuelTargetValue.h b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
new file mode 100644
index 0000000..9e7d2d6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/DuelTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class DuelTargetValue : public TargetValue
+	{
+	public:
+        DuelTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
new file mode 100644
index 0000000..d4df967
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyHealerTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+Unit* EnemyHealerTargetValue::Calculate()
+{
+    string spell = qualifier;
+
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    Unit* target = ai->GetAiObjectContext()->GetValue<Unit*>("current target")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || unit == target)
+            continue;
+
+        if (bot->GetDistance(unit) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (!ai->IsInterruptableSpellCasting(unit, spell))
+            continue;
+
+        Spell* spell = unit->GetCurrentSpell(CURRENT_GENERIC_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+
+        spell = unit->GetCurrentSpell(CURRENT_CHANNELED_SPELL);
+        if (spell && spell->m_spellInfo->IsPositive())
+            return unit;
+    }
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
new file mode 100644
index 0000000..bea36c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyHealerTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class EnemyHealerTargetValue : public UnitCalculatedValue, public Qualified
+	{
+	public:
+        EnemyHealerTargetValue(PlayerbotAI* ai) :
+            UnitCalculatedValue(ai, "enemy healer target") {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
new file mode 100644
index 0000000..5576e75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.cpp
@@ -0,0 +1,34 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "EnemyPlayerValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindEnemyPlayerStrategy : public FindTargetStrategy
+{
+public:
+    FindEnemyPlayerStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result)
+        {
+            Player* enemy = dynamic_cast<Player*>(attacker);
+            if (enemy && ai->IsOpposing(enemy) && enemy->IsOutdoorPvPActive())
+                result = attacker;
+        }
+    }
+
+};
+
+
+Unit* EnemyPlayerValue::Calculate()
+{
+    FindEnemyPlayerStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
new file mode 100644
index 0000000..ea50739
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/EnemyPlayerValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class EnemyPlayerValue : public TargetValue
+	{
+	public:
+        EnemyPlayerValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.cpp b/src/plugins/playerbot/strategy/values/Formations.cpp
new file mode 100644
index 0000000..9294253
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.cpp
@@ -0,0 +1,346 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "Formations.h"
+#include "formations/Arrow.h"
+
+using namespace ai;
+
+WorldLocation Formation::NullLocation = WorldLocation();
+
+namespace ai
+{
+    class MeleeFormation : public FollowFormation
+    {
+    public:
+        MeleeFormation(PlayerbotAI* ai) : FollowFormation(ai, "melee") {}
+        virtual string GetTargetName() { return "master target"; }
+    };
+
+    class QueueFormation : public FollowFormation
+    {
+    public:
+        QueueFormation(PlayerbotAI* ai) : FollowFormation(ai, "queue") {}
+        virtual string GetTargetName() { return "line target"; }
+    };
+
+    class ChaosFormation : public MoveFormation
+    {
+    public:
+        ChaosFormation(PlayerbotAI* ai) : MoveFormation(ai, "chaos") {}
+        virtual WorldLocation GetLocation()
+        {
+            Player* master = GetMaster();
+            if (!master)
+                return WorldLocation();
+
+            float range = sPlayerbotAIConfig.lootDistance * (float)(rand() % 10) / 10;
+			float angle = GetFollowAngle();
+            float x = master->GetPositionX() + cos(angle) * range;
+            float y = master->GetPositionY() + sin(angle) * range;
+            float z = master->GetPositionZ();
+            float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(master->GetMapId(), x, y, ground + 0.5f);
+        }
+
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.lootDistance; }
+    };
+
+    class CircleFormation : public MoveFormation
+    {
+    public:
+        CircleFormation(PlayerbotAI* ai) : MoveFormation(ai, "circle") {}
+        virtual WorldLocation GetLocation()
+        {
+            float range = 2.0f;
+
+            Unit* target = AI_VALUE(Unit*, "current target");
+            Player* master = GetMaster();
+            if (!target)
+                target = master;
+
+            if (!target)
+				return Formation::NullLocation;
+
+            switch (bot->getClass())
+            {
+            case CLASS_HUNTER:
+            case CLASS_MAGE:
+            case CLASS_PRIEST:
+            case CLASS_WARLOCK:
+                range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_DRUID:
+                if (!ai->IsTank(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            case CLASS_SHAMAN:
+                if (ai->IsHeal(bot))
+                    range = sPlayerbotAIConfig.fleeDistance;
+                break;
+            }
+
+            float x = target->GetPositionX();
+            float y = target->GetPositionY();
+            float z = target->GetPositionZ();
+            float ground = target->GetMap()->GetHeight(x, y, z + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            float angle = GetFollowAngle();
+            return WorldLocation(bot->GetMapId(), x + cos(angle) * range, y + sin(angle) * range, ground + 0.5f);
+        }
+    };
+
+    class LineFormation : public MoveFormation
+    {
+    public:
+        LineFormation(PlayerbotAI* ai) : MoveFormation(ai, "line") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = 2.0f;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> players;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                    players.push_back(member);
+
+                gref = gref->next();
+            }
+
+            players.insert(players.begin() + group->GetMembersCount() / 2, master);
+
+            return MoveLine(players, 0.0f, x, y, z, orientation, range);
+        }
+    };
+
+    class ShieldFormation : public MoveFormation
+    {
+    public:
+        ShieldFormation(PlayerbotAI* ai) : MoveFormation(ai, "shield") {}
+        virtual WorldLocation GetLocation()
+        {
+            Group* group = bot->GetGroup();
+            if (!group)
+                return Formation::NullLocation;
+
+            float range = sPlayerbotAIConfig.followDistance;
+
+            Player* master = GetMaster();
+            if (!master)
+                return Formation::NullLocation;
+
+            float x = master->GetPositionX();
+            float y = master->GetPositionY();
+            float z = master->GetPositionZ();
+            float orientation = master->GetOrientation();
+
+            vector<Player*> tanks;
+            vector<Player*> dps;
+            GroupReference *gref = group->GetFirstMember();
+            while( gref )
+            {
+                Player* member = gref->GetSource();
+                if (member != master)
+                {
+                    if (ai->IsTank(member))
+                        tanks.push_back(member);
+                    else
+                        dps.push_back(member);
+                }
+
+                gref = gref->next();
+            }
+
+            if (ai->IsTank(master))
+                tanks.insert(tanks.begin() + (tanks.size() + 1) / 2, master);
+            else
+                dps.insert(dps.begin() + (dps.size() + 1) / 2, master);
+
+            if (ai->IsTank(bot) && ai->IsTank(master))
+            {
+                return MoveLine(tanks, 0.0f, x, y, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                return MoveLine(dps, 0.0f, x, y, z, orientation, range);
+            }
+            if (ai->IsTank(bot) && !ai->IsTank(master))
+            {
+                float diff = tanks.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(tanks, diff, x + cos(orientation) * range, y + sin(orientation) * range, z, orientation, range);
+            }
+            if (!ai->IsTank(bot) && ai->IsTank(master))
+            {
+                float diff = dps.size() % 2 == 0 ? -sPlayerbotAIConfig.tooCloseDistance / 2.0f : 0.0f;
+                return MoveLine(dps, diff, x - cos(orientation) * range, y - sin(orientation) * range, z, orientation, range);
+            }
+            return Formation::NullLocation;
+        }
+    };
+};
+
+float Formation::GetFollowAngle()
+{
+    Player* master = GetMaster();
+    Group* group = master ? master->GetGroup() : bot->GetGroup();
+    if (!group)
+        return 0.0f;
+
+    int index = 1;
+    for (GroupReference *ref = group->GetFirstMember(); ref; ref = ref->next())
+    {
+        if( ref->GetSource() == master)
+            continue;
+
+        if( ref->GetSource() == bot)
+            return 2 * M_PI / (group->GetMembersCount() -1) * index;
+
+        index++;
+    }
+    return 0;
+}
+
+FormationValue::FormationValue(PlayerbotAI* ai) : ManualSetValue<Formation*>(ai, new MeleeFormation(ai), "formation")
+{
+}
+
+bool SetFormationAction::Execute(Event event)
+{
+    string formation = event.getParam();
+
+	Value<Formation*>* value = context->GetValue<Formation*>("formation");
+    if (formation == "?" || formation.empty())
+    {
+        ostringstream str; str << "Formation: |cff00ff00" << value->Get()->getName();
+        ai->TellMaster(str);
+        return true;
+    }
+
+    if (formation == "melee" || formation == "default")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new MeleeFormation(ai));
+    }
+    else if (formation == "queue")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new QueueFormation(ai));
+    }
+    else if (formation == "chaos")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ChaosFormation(ai));
+    }
+    else if (formation == "circle")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new CircleFormation(ai));
+    }
+    else if (formation == "line")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new LineFormation(ai));
+    }
+    else if (formation == "shield")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ShieldFormation(ai));
+    }
+    else if (formation == "arrow")
+    {
+        if (value->Get()) delete value->Get();
+        value->Set(new ArrowFormation(ai));
+    }
+    else
+    {
+        ostringstream str; str << "Invalid formation: |cffff0000" << formation;
+        ai->TellMaster(str);
+        ai->TellMaster("Please set to any of:|cffffffff melee (default), queue, chaos, circle, line, shield, arrow");
+        return false;
+    }
+
+    ostringstream str; str << "Formation set to: " << formation;
+    ai->TellMaster(str);
+    return true;
+}
+
+
+WorldLocation MoveFormation::MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    if (line.size() < 5)
+    {
+        return MoveSingleLine(line, diff, cx, cy, cz, orientation, range);
+    }
+
+    int lines = ceil((double)line.size() / 5.0);
+    for (int i = 0; i < lines; i++)
+    {
+        float radius = range * i;
+        float x = cx + cos(orientation) * radius;
+        float y = cy + sin(orientation) * radius;
+        vector<Player*> singleLine;
+        for (int j = 0; j < 5 && !line.empty(); j++)
+        {
+            singleLine.push_back(line[line.size() - 1]);
+            line.pop_back();
+        }
+
+        WorldLocation loc = MoveSingleLine(singleLine, diff, x, y,cz, orientation, range);
+        if (loc != Formation::NullLocation)
+            return loc;
+    }
+
+    return Formation::NullLocation;
+}
+
+WorldLocation MoveFormation::MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range)
+{
+    float count = line.size();
+    float angle = orientation - M_PI / 2.0f;
+    float x = cx + cos(angle) * (range * floor(count / 2.0f) + diff);
+    float y = cy + sin(angle) * (range * floor(count / 2.0f) + diff);
+
+    int index = 0;
+    for (vector<Player*>::iterator i = line.begin(); i != line.end(); i++)
+    {
+        Player* member = *i;
+
+        if (member == bot)
+        {
+            float angle = orientation + M_PI / 2.0f;
+            float radius = range * index;
+
+            float lx = x + cos(angle) * radius;
+            float ly = y + sin(angle) * radius;
+            float lz = cz;
+            float ground = bot->GetMap()->GetHeight(lx, ly, lz + 0.5f);
+            if (ground <= INVALID_HEIGHT)
+                return Formation::NullLocation;
+
+            return WorldLocation(bot->GetMapId(), lx, ly, ground + 0.5f);
+        }
+
+        index++;
+    }
+
+    return Formation::NullLocation;
+}
diff --git a/src/plugins/playerbot/strategy/values/Formations.h b/src/plugins/playerbot/strategy/values/Formations.h
new file mode 100644
index 0000000..2589cd7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/Formations.h
@@ -0,0 +1,52 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class Formation : public AiNamedObject
+    {
+    public:
+        Formation(PlayerbotAI* ai, string name) : AiNamedObject (ai, name) {}
+
+    public:
+        virtual string GetTargetName() { return ""; }
+        virtual WorldLocation GetLocation() { return NullLocation; }
+        virtual float GetMaxDistance() { return sPlayerbotAIConfig.followDistance; }
+        static WorldLocation NullLocation;
+
+    protected:
+        float GetFollowAngle();
+    };
+
+    class FollowFormation : public Formation
+    {
+    public:
+        FollowFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+    };
+
+    class MoveFormation : public Formation
+    {
+    public:
+        MoveFormation(PlayerbotAI* ai, string name) : Formation(ai, name) {}
+
+    protected:
+        WorldLocation MoveLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+        WorldLocation MoveSingleLine(vector<Player*> line, float diff, float cx, float cy, float cz, float orientation, float range);
+    };
+
+    class FormationValue : public ManualSetValue<Formation*>
+	{
+	public:
+        FormationValue(PlayerbotAI* ai);
+        ~FormationValue() { if (value) { delete value; value = NULL; } }
+    };
+
+    class SetFormationAction : public Action
+    {
+    public:
+        SetFormationAction(PlayerbotAI* ai) : Action(ai, "set formation") {}
+        virtual bool Execute(Event event);
+    };
+};
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
new file mode 100644
index 0000000..451dbf7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GrindTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../RandomPlayerbotMgr.h"
+
+using namespace ai;
+
+Unit* GrindTargetValue::Calculate()
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    if (group)
+        memberCount = group->GetMembersCount();
+
+    Unit* target = NULL;
+    uint32 assistCount = 0;
+    while (!target && assistCount < memberCount)
+    {
+        target = FindTargetForGrinding(assistCount++);
+    }
+
+    return target;
+}
+
+
+Unit* GrindTargetValue::FindTargetForGrinding(int assistCount)
+{
+    uint32 memberCount = 1;
+    Group* group = bot->GetGroup();
+    Player* master = GetMaster();
+
+    list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit || !unit->IsAlive())
+            continue;
+
+        return unit;
+    }
+
+    list<ObjectGuid> targets = *context->GetValue<list<ObjectGuid> >("possible targets");
+
+    if(targets.empty())
+        return NULL;
+
+    float distance = 0;
+    Unit* result = NULL;
+    for(list<ObjectGuid>::iterator tIter = targets.begin(); tIter != targets.end(); tIter++)
+    {
+        Unit* unit = ai->GetUnit(*tIter);
+        if (!unit)
+            continue;
+
+        if (abs(bot->GetPositionZ() - unit->GetPositionZ()) > sPlayerbotAIConfig.spellDistance)
+            continue;
+
+        if (GetTargetingPlayerCount(unit) > assistCount)
+            continue;
+
+		if (master && master->GetDistance(unit) >= sPlayerbotAIConfig.grindDistance && !sRandomPlayerbotMgr.IsRandomBot(bot))
+            continue;
+
+		if ((int)unit->getLevel() - (int)bot->getLevel() > 4 && !unit->GetGUID().IsPlayer())
+		    continue;
+
+		Creature* creature = dynamic_cast<Creature*>(unit);
+		if (creature && creature->GetCreatureTemplate() && creature->GetCreatureTemplate()->rank > CREATURE_ELITE_NORMAL)
+		    continue;
+
+        if (group)
+        {
+            Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+            for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+            {
+                Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+                if( !member || !member->IsAlive())
+                    continue;
+
+                float d = member->GetDistance(unit);
+                if (!result || d < distance)
+                {
+                    distance = d;
+                    result = unit;
+                }
+            }
+        }
+        else
+        {
+            float d = bot->GetDistance(unit);
+            if (!result || d < distance)
+            {
+                distance = d;
+                result = unit;
+            }
+        }
+    }
+
+    return result;
+}
+
+
+int GrindTargetValue::GetTargetingPlayerCount( Unit* unit )
+{
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    int count = 0;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *member = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !member || !member->IsAlive() || member == bot)
+            continue;
+
+        PlayerbotAI* ai = member->GetPlayerbotAI();
+        if ((ai && *ai->GetAiObjectContext()->GetValue<Unit*>("current target") == unit) ||
+            (!ai && member->GetSelectedUnit() == unit))
+            count++;
+    }
+
+    return count;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/GrindTargetValue.h b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
new file mode 100644
index 0000000..f333297
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/GrindTargetValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class GrindTargetValue : public TargetValue
+	{
+	public:
+        GrindTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+
+    private:
+        int GetTargetingPlayerCount(Unit* unit);
+        Unit* FindTargetForGrinding(int assistCount);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
new file mode 100644
index 0000000..3dac17f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasAvailableLootValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class HasAvailableLootValue : public BoolCalculatedValue
+	{
+	public:
+        HasAvailableLootValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        virtual bool Calculate()
+        {
+            return !AI_VALUE(bool, "can loot") &&
+                    AI_VALUE(LootObjectStack*, "available loot")->CanLoot(sPlayerbotAIConfig.lootDistance) &&
+                    !bot->IsMounted();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/HasTotemValue.h b/src/plugins/playerbot/strategy/values/HasTotemValue.h
new file mode 100644
index 0000000..a65b3a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/HasTotemValue.h
@@ -0,0 +1,34 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+#include "../../LootObjectStack.h"
+
+namespace ai
+{
+    class HasTotemValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        HasTotemValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+    public:
+        bool Calculate()
+        {
+            list<ObjectGuid> units = *context->GetValue<list<ObjectGuid> >("nearest npcs");
+            for (list<ObjectGuid>::iterator i = units.begin(); i != units.end(); i++)
+            {
+                Unit* unit = ai->GetUnit(*i);
+                if (!unit)
+                    continue;
+
+                Creature* creature = dynamic_cast<Creature*>(unit);
+                if (!creature || !creature->IsTotem())
+                    continue;
+
+                if (strstri(creature->GetName().c_str(), qualifier.c_str()) && bot->GetDistance(creature) <= sPlayerbotAIConfig.spellDistance)
+                    return true;
+            }
+
+            return false;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
new file mode 100644
index 0000000..41440c9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.cpp
@@ -0,0 +1,26 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "InvalidTargetValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+
+bool InvalidTargetValue::Calculate()
+{
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    if (qualifier == "current target")
+    {
+        return !target ||
+                target->GetMapId() != bot->GetMapId() ||
+                target->isDead() ||
+                target->IsPolymorphed() ||
+                target->IsCharmed() ||
+                target->isFeared() ||
+                target->HasUnitState(UNIT_STATE_ISOLATED) ||
+                target->IsFriendlyTo(bot) ||
+                !bot->IsWithinDistInMap(target, sPlayerbotAIConfig.sightDistance) ||
+                !bot->IsWithinLOSInMap(target);
+    }
+
+    return !target;
+}
diff --git a/src/plugins/playerbot/strategy/values/InvalidTargetValue.h b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
new file mode 100644
index 0000000..5d277fd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/InvalidTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class InvalidTargetValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        InvalidTargetValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+	public:
+        virtual bool Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsBehindValue.h b/src/plugins/playerbot/strategy/values/IsBehindValue.h
new file mode 100644
index 0000000..da61670
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsBehindValue.h
@@ -0,0 +1,25 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsBehindValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsBehindValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate() 
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            
+            float targetOrientation = target->GetOrientation();
+            float orientation = bot->GetOrientation();
+            float distance = bot->GetDistance(target);
+
+            return distance <= ATTACK_DISTANCE && abs(targetOrientation - orientation) < M_PI / 2;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsFacingValue.h b/src/plugins/playerbot/strategy/values/IsFacingValue.h
new file mode 100644
index 0000000..814014f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsFacingValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsFacingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsFacingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+            if (!target)
+                return false;
+
+            return bot->isInFront(target, M_PI / 3.0f);
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/IsMovingValue.h b/src/plugins/playerbot/strategy/values/IsMovingValue.h
new file mode 100644
index 0000000..bbee8bd
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/IsMovingValue.h
@@ -0,0 +1,42 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class IsMovingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsMovingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            switch (target->GetMotionMaster()->GetCurrentMovementGeneratorType())
+            {
+            case IDLE_MOTION_TYPE:
+                return false;
+            }
+            return true;
+        }
+    };
+
+    class IsSwimmingValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        IsSwimmingValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        virtual bool Calculate()
+        {
+            Unit* target = AI_VALUE(Unit*, qualifier);
+
+            if (!target)
+                return false;
+
+            return target->IsUnderWater() || target->IsInWater();
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.cpp b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
new file mode 100644
index 0000000..2b6c0a2
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemCountValue.h"
+
+using namespace ai;
+
+list<Item*> InventoryItemValueBase::Find(string qualifier)
+{
+    list<Item*> result;
+
+    Player* bot = InventoryAction::ai->GetBot();
+
+    list<Item*> items = InventoryAction::parseItems(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); i++)
+        result.push_back(*i);
+
+    return result;
+}
+
+
+uint8 ItemCountValue::Calculate()
+{
+    uint8 count = 0;
+    list<Item*> items = Find(qualifier);
+    for (list<Item*>::iterator i = items.begin(); i != items.end(); ++i)
+    {
+        Item* item = *i;
+        count += item->GetCount();
+    }
+
+    return count;
+}
+
+list<Item*> InventoryItemValue::Calculate()
+{
+    return Find(qualifier);
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemCountValue.h b/src/plugins/playerbot/strategy/values/ItemCountValue.h
new file mode 100644
index 0000000..f81d9b3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemCountValue.h
@@ -0,0 +1,35 @@
+#pragma once
+#include "../Value.h"
+#include "../ItemVisitors.h"
+#include "../actions/InventoryAction.h"
+
+namespace ai
+{
+    class InventoryItemValueBase : public InventoryAction
+    {
+    public:
+        InventoryItemValueBase(PlayerbotAI* ai) : InventoryAction(ai, "empty") {}
+        virtual bool Execute(Event event) { return false; }
+
+    protected:
+        list<Item*> Find(string qualifier);
+    };
+
+    class ItemCountValue : public Uint8CalculatedValue, public Qualified, InventoryItemValueBase
+	{
+	public:
+        ItemCountValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual uint8 Calculate();
+	};
+
+    class InventoryItemValue : public CalculatedValue<list<Item*> >, public Qualified, InventoryItemValueBase
+    {
+    public:
+        InventoryItemValue(PlayerbotAI* ai) : CalculatedValue<list<Item*> >(ai), InventoryItemValueBase(ai) {}
+
+    public:
+        virtual list<Item*> Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
new file mode 100644
index 0000000..671cd97
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.cpp
@@ -0,0 +1,70 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemForSpellValue.h"
+
+using namespace ai;
+
+#ifndef WIN32
+inline int strcmpi(const char* s1, const char* s2)
+{
+    for (; *s1 && *s2 && (toupper(*s1) == toupper(*s2)); ++s1, ++s2);
+    return *s1 - *s2;
+}
+#endif
+
+Item* ItemForSpellValue::Calculate()
+{
+    uint32 spellid = atoi(qualifier.c_str());
+    if (!spellid)
+        return NULL;
+
+    SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+    if (!spellInfo)
+        return NULL;
+
+    Item* itemForSpell = NULL;
+    Player* trader = bot->GetTrader();
+    if (trader)
+    {
+        itemForSpell = trader->GetTradeData()->GetItem(TRADE_SLOT_NONTRADED);
+        if (itemForSpell && itemForSpell->IsFitToSpellRequirements(spellInfo))
+            return itemForSpell;
+    }
+
+    // Workaround as some spells have no item mask (e.g. shaman weapon enhancements)
+    if (!strcmpi(spellInfo->SpellName[0], "rockbiter weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "flametongue weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "earthliving weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "frostbrand weapon") ||
+            !strcmpi(spellInfo->SpellName[0], "windfury weapon"))
+    {
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_MAINHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        itemForSpell = GetItemFitsToSpellRequirements(EQUIPMENT_SLOT_OFFHAND, spellInfo);
+        if (itemForSpell && itemForSpell->GetTemplate()->Class == ITEM_CLASS_WEAPON)
+            return itemForSpell;
+
+        return NULL;
+    }
+
+    for( uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; slot++ ) {
+        itemForSpell = GetItemFitsToSpellRequirements(slot, spellInfo);
+        if (itemForSpell)
+            return itemForSpell;
+    }
+    return NULL;
+}
+
+Item* ItemForSpellValue::GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo)
+{
+    Item* const itemForSpell = bot->GetItemByPos( INVENTORY_SLOT_BAG_0, slot );
+    if (!itemForSpell || itemForSpell->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+        return NULL;
+
+    if (itemForSpell->IsFitToSpellRequirements(spellInfo))
+        return itemForSpell;
+
+    return NULL;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemForSpellValue.h b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
new file mode 100644
index 0000000..39ce6af
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemForSpellValue.h
@@ -0,0 +1,20 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class ItemForSpellValue : public CalculatedValue<Item*>, public Qualified
+	{
+	public:
+        ItemForSpellValue(PlayerbotAI* ai) : CalculatedValue<Item*>(ai) {}
+
+    public:
+        virtual Item* Calculate();
+
+    private:
+        Item* GetItemFitsToSpellRequirements(uint8 slot, SpellInfo const *spellInfo);
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
new file mode 100644
index 0000000..b7fbcfc
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.cpp
@@ -0,0 +1,146 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ItemUsageValue.h"
+
+#include "../../GuildTaskMgr.h"
+using namespace ai;
+
+ItemUsage ItemUsageValue::Calculate()
+{
+    uint32 itemId = atoi(qualifier.c_str());
+    if (!itemId)
+        return ITEM_USAGE_NONE;
+
+    const ItemTemplate* proto = sObjectMgr->GetItemTemplate(itemId);
+    if (!proto)
+        return ITEM_USAGE_NONE;
+
+    if (IsItemUsefulForSkill(proto))
+        return ITEM_USAGE_SKILL;
+
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_KEY:
+    case ITEM_CLASS_CONSUMABLE:
+        return ITEM_USAGE_USE;
+    }
+
+    if (bot->GetGuildId() && sGuildTaskMgr.IsGuildTaskItem(itemId, bot->GetGuildId()))
+        return ITEM_USAGE_GUILD_TASK;
+
+    return QueryItemUsageForEquip(proto);
+}
+
+ItemUsage ItemUsageValue::QueryItemUsageForEquip(ItemTemplate const * item)
+{
+    if (bot->CanUseItem(item) != EQUIP_ERR_OK)
+        return ITEM_USAGE_NONE;
+
+    if (item->InventoryType == INVTYPE_NON_EQUIP)
+        return ITEM_USAGE_NONE;
+
+    Item *pItem = Item::CreateItem(item->ItemId, 1, bot);
+    if (!pItem)
+        return ITEM_USAGE_NONE;
+
+    uint16 dest;
+    InventoryResult result = bot->CanEquipItem(NULL_SLOT, dest, pItem, true, false);
+    pItem->RemoveFromUpdateQueueOf(bot);
+    delete pItem;
+
+    if( result != EQUIP_ERR_OK )
+        return ITEM_USAGE_NONE;
+
+    Item* existingItem = bot->GetItemByPos(dest);
+    if (!existingItem)
+        return ITEM_USAGE_EQUIP;
+
+    const ItemTemplate* oldItem = existingItem->GetTemplate();
+    if (oldItem->ItemLevel < item->ItemLevel && oldItem->ItemId != item->ItemId)
+    {
+        switch (item->Class)
+        {
+        case ITEM_CLASS_ARMOR:
+            if (oldItem->SubClass <= item->SubClass) {
+                return ITEM_USAGE_REPLACE;
+            }
+            break;
+        default:
+            return ITEM_USAGE_EQUIP;
+        }
+    }
+
+    return ITEM_USAGE_NONE;
+}
+
+bool ItemUsageValue::IsItemUsefulForSkill(ItemTemplate const * proto)
+{
+    switch (proto->Class)
+    {
+    case ITEM_CLASS_GEM:
+        if (proto->SubClass == ITEM_SUBCLASS_GEM_SIMPLE && bot->HasSkill(SKILL_JEWELCRAFTING))
+            return true;
+        if (proto->SubClass != ITEM_SUBCLASS_GEM_SIMPLE)
+            return true;
+        break;
+    case ITEM_CLASS_TRADE_GOODS:
+        switch (proto->SubClass)
+        {
+        case ITEM_SUBCLASS_PARTS:
+        case ITEM_SUBCLASS_EXPLOSIVES:
+        case ITEM_SUBCLASS_DEVICES:
+            return bot->HasSkill(SKILL_ENGINEERING);
+        case ITEM_SUBCLASS_JEWELCRAFTING:
+            return bot->HasSkill(SKILL_JEWELCRAFTING);
+        case ITEM_SUBCLASS_CLOTH:
+            return bot->HasSkill(SKILL_TAILORING);
+        case ITEM_SUBCLASS_LEATHER:
+            return bot->HasSkill(SKILL_LEATHERWORKING) || bot->HasSkill(SKILL_SKINNING);
+        case ITEM_SUBCLASS_METAL_STONE:
+            return (bot->HasSkill(SKILL_BLACKSMITHING) ||
+                bot->HasSkill(SKILL_ENGINEERING) ||
+                bot->HasSkill(SKILL_MINING));
+        case ITEM_SUBCLASS_MEAT:
+            return bot->HasSkill(SKILL_COOKING);
+        case ITEM_SUBCLASS_HERB:
+            return (bot->HasSkill(SKILL_HERBALISM) ||
+                bot->HasSkill(SKILL_ALCHEMY) ||
+                bot->HasSkill(SKILL_INSCRIPTION));
+        case ITEM_SUBCLASS_ELEMENTAL:
+            return true;
+        case ITEM_SUBCLASS_ENCHANTING:
+            return bot->HasSkill(SKILL_ENCHANTING);
+        }
+        break;
+    case ITEM_CLASS_RECIPE:
+        {
+            if (bot->HasSpell(proto->Spells[2].SpellId))
+                break;
+
+            switch (proto->SubClass)
+            {
+            case ITEM_SUBCLASS_LEATHERWORKING_PATTERN:
+                return bot->HasSkill(SKILL_LEATHERWORKING);
+            case ITEM_SUBCLASS_TAILORING_PATTERN:
+                return bot->HasSkill(SKILL_TAILORING);
+            case ITEM_SUBCLASS_ENGINEERING_SCHEMATIC:
+                return bot->HasSkill(SKILL_ENGINEERING);
+            case ITEM_SUBCLASS_BLACKSMITHING:
+                return bot->HasSkill(SKILL_BLACKSMITHING);
+            case ITEM_SUBCLASS_COOKING_RECIPE:
+                return bot->HasSkill(SKILL_COOKING);
+            case ITEM_SUBCLASS_ALCHEMY_RECIPE:
+                return bot->HasSkill(SKILL_ALCHEMY);
+            case ITEM_SUBCLASS_FIRST_AID_MANUAL:
+                return bot->HasSkill(SKILL_FIRST_AID);
+            case ITEM_SUBCLASS_ENCHANTING_FORMULA:
+                return bot->HasSkill(SKILL_ENCHANTING);
+            case ITEM_SUBCLASS_FISHING_MANUAL:
+                return bot->HasSkill(SKILL_FISHING);
+            case ITEM_SUBCLASS_JEWELCRAFTING_RECIPE:
+                return bot->HasSkill(SKILL_JEWELCRAFTING);
+            }
+        }
+    }
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/ItemUsageValue.h b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
new file mode 100644
index 0000000..95e0a52
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ItemUsageValue.h
@@ -0,0 +1,28 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    enum ItemUsage
+    {
+        ITEM_USAGE_NONE = 0,
+        ITEM_USAGE_EQUIP = 1,
+        ITEM_USAGE_REPLACE = 2,
+        ITEM_USAGE_SKILL = 3,
+        ITEM_USAGE_USE = 4,
+        ITEM_USAGE_GUILD_TASK = 5
+    };
+
+    class ItemUsageValue : public CalculatedValue<ItemUsage>, public Qualified
+	{
+	public:
+        ItemUsageValue(PlayerbotAI* ai) : CalculatedValue<ItemUsage>(ai) {}
+
+    public:
+        virtual ItemUsage Calculate();
+
+    private:
+        ItemUsage QueryItemUsageForEquip(ItemTemplate const * proto);
+        bool IsItemUsefulForSkill(ItemTemplate const * proto);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LastMovementValue.h b/src/plugins/playerbot/strategy/values/LastMovementValue.h
new file mode 100644
index 0000000..0467833
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastMovementValue.h
@@ -0,0 +1,61 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastMovement
+    {
+    public:
+        LastMovement() 
+        {
+            lastMoveToX = 0;
+            lastMoveToY = 0;
+            lastMoveToZ = 0;
+            lastMoveToOri = 0;
+            lastFollow = NULL;
+        }
+
+        LastMovement(LastMovement& other)
+        {
+            taxiNodes = other.taxiNodes;
+            taxiMaster = other.taxiMaster;
+            lastFollow = other.lastFollow;
+            lastAreaTrigger = other.lastAreaTrigger;
+            lastMoveToX = other.lastMoveToX;
+            lastMoveToY = other.lastMoveToY;
+            lastMoveToZ = other.lastMoveToZ;
+            lastMoveToOri = other.lastMoveToOri;
+        }
+        
+        void Set(Unit* lastFollow)
+        {
+            Set(0.0f, 0.0f, 0.0f, 0.0f);
+            this->lastFollow = lastFollow;
+        }
+
+        void Set(float x, float y, float z, float ori)
+        {
+            lastMoveToX = x;
+            lastMoveToY = y;
+            lastMoveToZ = z;
+            lastMoveToOri = ori;
+            lastFollow = NULL;
+        }
+
+    public:
+        vector<uint32> taxiNodes;
+        ObjectGuid taxiMaster;
+        Unit* lastFollow;
+        uint32 lastAreaTrigger;
+        float lastMoveToX, lastMoveToY, lastMoveToZ, lastMoveToOri;
+    };
+
+    class LastMovementValue : public ManualSetValue<LastMovement&>
+	{
+	public:
+        LastMovementValue(PlayerbotAI* ai) : ManualSetValue<LastMovement&>(ai, data) {}
+
+    private:
+        LastMovement data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
new file mode 100644
index 0000000..bf0a17e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastTimeValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCastTimeValue : public ManualSetValue<time_t>, public Qualified
+	{
+	public:
+        LastSpellCastTimeValue(PlayerbotAI* ai) : ManualSetValue<time_t>(ai, 0), Qualified() {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LastSpellCastValue.h b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
new file mode 100644
index 0000000..5d05541
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LastSpellCastValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LastSpellCast 
+    {
+    public:
+        LastSpellCast() : id(0),time(0) {}
+
+    public:
+        void Set(uint32 id, ObjectGuid target, time_t time)
+        {
+            this->id = id;
+            this->target = target;
+            this->time = time;
+        }
+        
+        void Reset()
+        {
+            id = 0;
+            target.Set(0);
+            time = 0;
+        }
+    public:
+        uint32 id;
+        ObjectGuid target;
+        time_t time;
+    };
+   
+    class LastSpellCastValue : public ManualSetValue<LastSpellCast&>
+	{
+	public:
+        LastSpellCastValue(PlayerbotAI* ai) : ManualSetValue<LastSpellCast&>(ai, data) {}
+
+    private:
+        LastSpellCast data;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
new file mode 100644
index 0000000..39021c5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LeastHpTargetValue.h"
+#include "TargetValue.h"
+
+using namespace ai;
+using namespace std;
+
+class FindLeastHpTargetStrategy : public FindTargetStrategy
+{
+public:
+    FindLeastHpTargetStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minHealth = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager)
+    {
+        if (!result || result->GetHealth() > attacker->GetHealth())
+            result = attacker;
+    }
+
+protected:
+    float minHealth;
+};
+
+
+Unit* LeastHpTargetValue::Calculate()
+{
+    FindLeastHpTargetStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
new file mode 100644
index 0000000..e748e7f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LeastHpTargetValue.h
@@ -0,0 +1,15 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+    class LeastHpTargetValue : public TargetValue
+	{
+	public:
+        LeastHpTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/LfgValues.h b/src/plugins/playerbot/strategy/values/LfgValues.h
new file mode 100644
index 0000000..290a4c4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LfgValues.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../Value.h"
+
+namespace ai
+{
+class LfgProposalValue : public ManualSetValue<uint32>
+{
+public:
+    LfgProposalValue(PlayerbotAI* ai) : ManualSetValue<uint32>(ai, 0, "lfg proposal") {}
+};
+}
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.cpp b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
new file mode 100644
index 0000000..3546e12
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.cpp
@@ -0,0 +1,33 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "LineTargetValue.h"
+
+using namespace ai;
+
+Unit* LineTargetValue::Calculate()
+{
+    Player* master = GetMaster();
+    if (!master)
+        return NULL;
+
+    Group* group = master->GetGroup();
+    if (!group)
+        return NULL;
+
+    Player *prev = master;
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == master)
+            continue;
+
+        if (player == bot)
+            return prev;
+
+        prev = player;
+    }
+
+    return master;
+}
+
diff --git a/src/plugins/playerbot/strategy/values/LineTargetValue.h b/src/plugins/playerbot/strategy/values/LineTargetValue.h
new file mode 100644
index 0000000..57998fa
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LineTargetValue.h
@@ -0,0 +1,14 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LineTargetValue : public UnitCalculatedValue
+	{
+	public:
+        LineTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LogLevelValue.h b/src/plugins/playerbot/strategy/values/LogLevelValue.h
new file mode 100644
index 0000000..c5f9da9
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LogLevelValue.h
@@ -0,0 +1,12 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LogLevelValue : public ManualSetValue<LogLevel>
+	{
+	public:
+        LogLevelValue(PlayerbotAI* ai) :
+            ManualSetValue<LogLevel>(ai, LOG_LEVEL_DEBUG) {}
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/LootStrategyValue.h b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
new file mode 100644
index 0000000..210e518
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/LootStrategyValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class LootStrategyValue : public ManualSetValue<LootStrategy>
+	{
+	public:
+        LootStrategyValue(PlayerbotAI* ai) : ManualSetValue<LootStrategy>(ai, LOOTSTRATEGY_SKILL) {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
new file mode 100644
index 0000000..6c29f1f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ManaSaveLevelValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ManaSaveLevelValue : public ManualSetValue<double>
+	{
+	public:
+        ManaSaveLevelValue(PlayerbotAI* ai) : ManualSetValue<double>(ai, 1.0, "mana save level") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/MasterTargetValue.h b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
new file mode 100644
index 0000000..a137694
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/MasterTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class MasterTargetValue : public UnitCalculatedValue
+	{
+	public:
+        MasterTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetMaster(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
new file mode 100644
index 0000000..3370836
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.cpp
@@ -0,0 +1,11 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestAdsValue.h"
+
+using namespace ai;
+
+bool NearestAdsValue::AcceptUnit(Unit* unit)
+{
+    Unit* target = AI_VALUE(Unit*, "current target");
+    return unit != target;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestAdsValue.h b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
new file mode 100644
index 0000000..16e4a84
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestAdsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "PossibleTargetsValue.h"
+
+namespace ai
+{
+    class NearestAdsValue : public PossibleTargetsValue
+	{
+	public:
+        NearestAdsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.tooCloseDistance) :
+            PossibleTargetsValue(ai, range) {}
+
+    protected:
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
new file mode 100644
index 0000000..ad6e30a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestCorpsesValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyDeadUnitInObjectRangeCheck
+{
+public:
+    AnyDeadUnitInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(Unit* u)
+    {
+        return !u->IsAlive() && i_obj->IsWithinDistInMap(u, i_range);
+    }
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+void NearestCorpsesValue::FindUnits(list<Unit*> &targets)
+{
+    AnyDeadUnitInObjectRangeCheck u_check(bot, range);
+    UnitListSearcher<AnyDeadUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestCorpsesValue::AcceptUnit(Unit* unit)
+{
+    return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
new file mode 100644
index 0000000..c23a5b8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestCorpsesValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestCorpsesValue : public NearestUnitsValue
+	{
+	public:
+        NearestCorpsesValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
new file mode 100644
index 0000000..405b1c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestGameObjects.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+class AnyGameObjectInObjectRangeCheck
+{
+public:
+    AnyGameObjectInObjectRangeCheck(WorldObject const* obj, float range) : i_obj(obj), i_range(range) {}
+    WorldObject const& GetFocusObject() const { return *i_obj; }
+    bool operator()(GameObject* u)
+    {
+        if (u && i_obj->IsWithinDistInMap(u, i_range) && u->isSpawned() && u->GetGOInfo())
+            return true;
+
+        return false;
+    }
+
+private:
+    WorldObject const* i_obj;
+    float i_range;
+};
+
+list<ObjectGuid> NearestGameObjects::Calculate()
+{
+    list<GameObject*> targets;
+
+    AnyGameObjectInObjectRangeCheck u_check(bot, range);
+    GameObjectListSearcher<AnyGameObjectInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+
+    list<ObjectGuid> result;
+    for(list<GameObject*>::iterator tIter = targets.begin(); tIter != targets.end(); ++tIter)
+    {
+		GameObject* go = *tIter;
+        if(bot->IsWithinLOSInMap(go))
+			result.push_back(go->GetGUID());
+    }
+
+    return result;
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestGameObjects.h b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
new file mode 100644
index 0000000..78dcf57
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestGameObjects.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestGameObjects : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestGameObjects(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai), range(range) {}
+
+    protected:
+        virtual list<ObjectGuid> Calculate();
+
+    private:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
new file mode 100644
index 0000000..9f82f10
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "NearestNpcsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+
+using namespace ai;
+using namespace Trinity;
+
+void NearestNpcsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyFriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyFriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool NearestNpcsValue::AcceptUnit(Unit* unit)
+{
+    return !dynamic_cast<Player*>(unit);
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestNpcsValue.h b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
new file mode 100644
index 0000000..ebbbd75
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestNpcsValue.h
@@ -0,0 +1,18 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestNpcsValue : public NearestUnitsValue
+	{
+	public:
+        NearestNpcsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        void FindUnits(list<Unit*> &targets);
+        bool AcceptUnit(Unit* unit);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/NearestUnitsValue.h b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
new file mode 100644
index 0000000..c6d1ed5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/NearestUnitsValue.h
@@ -0,0 +1,36 @@
+#pragma once
+#include "../Value.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class NearestUnitsValue : public ObjectGuidListCalculatedValue
+	{
+	public:
+        NearestUnitsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+            ObjectGuidListCalculatedValue(ai, "nearest units", 5), range(range) {}
+
+	public:
+        list<ObjectGuid> Calculate()
+        {
+            list<Unit*> targets;
+            FindUnits(targets);
+
+            list<ObjectGuid> results;
+            for(list<Unit *>::iterator i = targets.begin(); i!= targets.end(); ++i)
+            {
+                Unit* unit = *i;
+                if(bot->IsWithinLOSInMap(unit) && AcceptUnit(unit))
+                    results.push_back(unit->GetGUID());
+            }
+            return results;
+        }
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets) = 0;
+        virtual bool AcceptUnit(Unit* unit) = 0;
+
+    protected:
+        float range;
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
new file mode 100644
index 0000000..1f50b6b
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.cpp
@@ -0,0 +1,37 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToDispel.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PartyMemberToDispelPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PartyMemberToDispelPredicate(PlayerbotAI* ai, uint32 dispelType) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), dispelType(dispelType) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && ai->HasAuraToDispel(unit, dispelType);
+    }
+
+private:
+    uint32 dispelType;
+};
+
+Unit* PartyMemberToDispel::Calculate()
+{
+    uint32 dispelType = atoi(qualifier.c_str());
+
+    PartyMemberToDispelPredicate predicate(ai, dispelType);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
new file mode 100644
index 0000000..dfbc809
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToDispel.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToDispel : public PartyMemberValue, Qualified
+	{
+	public:
+        PartyMemberToDispel(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
new file mode 100644
index 0000000..2ef8e3c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.cpp
@@ -0,0 +1,60 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToHeal.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class IsTargetOfHealingSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell) {
+        for (int i=0; i<3; i++) {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_HEAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MAX_HEALTH ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_MECHANICAL ||
+                spell->Effects[i].Effect == SPELL_EFFECT_HEAL_PCT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+Unit* PartyMemberToHeal::Calculate()
+{
+
+    IsTargetOfHealingSpell predicate;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    bool isRaid = bot->GetGroup()->isRaidGroup();
+    MinValueCalculator calc(100);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (!Check(player) || !player->IsAlive())
+            continue;
+
+        uint8 health = player->GetHealthPct();
+        if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+            calc.probe(health, player);
+
+        Pet* pet = player->GetPet();
+        if (pet && CanHealPet(pet))
+        {
+            health = ((Unit*)pet)->GetHealthPct();
+            if (isRaid || health < sPlayerbotAIConfig.mediumHealth || !IsTargetOfSpellCast(player, predicate))
+                calc.probe(health, player);
+        }
+    }
+    return (Unit*)calc.param;
+}
+
+bool PartyMemberToHeal::CanHealPet(Pet* pet)
+{
+    return HUNTER_PET == pet->getPetType();
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
new file mode 100644
index 0000000..bbbc2f4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToHeal.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToHeal : public PartyMemberValue
+	{
+	public:
+        PartyMemberToHeal(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+        bool CanHealPet(Pet* pet);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
new file mode 100644
index 0000000..58dd203
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberToResurrect.h"
+
+using namespace ai;
+
+class IsTargetOfResurrectSpell : public SpellEntryPredicate
+{
+public:
+    virtual bool Check(SpellInfo const* spell)
+    {
+        for (int i=0; i<3; i++)
+        {
+            if (spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT ||
+                spell->Effects[i].Effect == SPELL_EFFECT_RESURRECT_NEW ||
+                spell->Effects[i].Effect == SPELL_EFFECT_SELF_RESURRECT)
+                return true;
+        }
+        return false;
+    }
+
+};
+
+class FindDeadPlayer : public FindPlayerPredicate
+{
+public:
+    FindDeadPlayer(PartyMemberValue* value) : value(value) {}
+
+    virtual bool Check(Unit* unit)
+    {
+        Player* player = dynamic_cast<Player*>(unit);
+        return player && player->getDeathState() == CORPSE && !value->IsTargetOfSpellCast(player, predicate);
+    }
+
+private:
+    PartyMemberValue* value;
+    IsTargetOfResurrectSpell predicate;
+};
+
+Unit* PartyMemberToResurrect::Calculate()
+{
+	FindDeadPlayer finder(this);
+    return FindPartyMember(finder);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
new file mode 100644
index 0000000..36815f0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberToResurrect.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+
+namespace ai
+{
+    class PartyMemberToResurrect : public PartyMemberValue
+	{
+	public:
+        PartyMemberToResurrect(PlayerbotAI* ai) : 
+          PartyMemberValue(ai) {}
+    
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
new file mode 100644
index 0000000..2f5bcc4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+using namespace ai;
+using namespace std;
+
+Unit* PartyMemberValue::FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate)
+{
+    for (list<Player*>::iterator i = party->begin(); i != party->end(); ++i)
+    {
+        Player* player = *i;
+
+        if (!player)
+            continue;
+
+        if (Check(player) && predicate.Check(player))
+            return player;
+
+        Pet* pet = player->GetPet();
+        if (!pet)
+            continue;
+
+        Unit* unit = (Unit*)pet;
+        if (unit && Check(unit) && predicate.Check(unit))
+            return unit;
+    }
+
+    return NULL;
+}
+
+Unit* PartyMemberValue::FindPartyMember(FindPlayerPredicate &predicate)
+{
+    Player* master = GetMaster();
+    Group* group = bot->GetGroup();
+    if (!group)
+        return NULL;
+
+    list<Player*> healers, tanks, others, masters;
+    masters.push_back(master);
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+
+        if (ai->IsHeal(player))
+            healers.push_back(player);
+        else if (ai->IsTank(player))
+            tanks.push_back(player);
+        else if (player != master)
+            others.push_back(player);
+    }
+
+    list<list<Player*>* > lists;
+    lists.push_back(&healers);
+    lists.push_back(&tanks);
+    lists.push_back(&masters);
+    lists.push_back(&others);
+
+    for (list<list<Player*>* >::iterator i = lists.begin(); i != lists.end(); ++i)
+    {
+        list<Player*>* party = *i;
+        Unit* target = FindPartyMember(party, predicate);
+        if (target)
+            return target;
+    }
+
+    return NULL;
+}
+
+bool PartyMemberValue::Check(Unit* player)
+{
+
+
+    return player && player != bot && player->GetMapId() == bot->GetMapId() &&
+        bot->GetDistance(player) < sPlayerbotAIConfig.spellDistance &&
+        bot->IsWithinLOS(player->GetPositionX(), player->GetPositionY(), player->GetPositionZ());
+}
+
+bool PartyMemberValue::IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate)
+{
+
+    Group* group = bot->GetGroup();
+    ObjectGuid targetGuid = target ? target->GetGUID() : bot->GetGUID();
+    ObjectGuid corpseGuid = target && target->GetCorpse() ? target->GetCorpse()->GetGUID() : ObjectGuid();
+
+    for (GroupReference *gref = group->GetFirstMember(); gref; gref = gref->next())
+    {
+        Player* player = gref->GetSource();
+        if (player == bot)
+            continue;
+
+        if (player->IsNonMeleeSpellCast(true))
+        {
+            for (int type = CURRENT_GENERIC_SPELL; type < CURRENT_MAX_SPELL; type++) {
+                Spell* spell = player->GetCurrentSpell((CurrentSpellTypes)type);
+                if (spell && predicate.Check(spell->m_spellInfo)) {
+                    ObjectGuid unitTarget = spell->m_targets.GetUnitTargetGUID();
+                    if (unitTarget == targetGuid)
+                        return true;
+
+                    ObjectGuid corpseTarget = spell->m_targets.GetCorpseTargetGUID();
+                    if (corpseTarget == corpseGuid)
+                        return true;
+                }
+            }
+        }
+    }
+
+    return false;
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberValue.h b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
new file mode 100644
index 0000000..5229b46
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberValue.h
@@ -0,0 +1,31 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindPlayerPredicate
+    {
+    public:
+        virtual bool Check(Unit*) = 0;
+    };
+
+    class SpellEntryPredicate
+    {
+    public:
+        virtual bool Check(SpellInfo const*) = 0;
+    };
+
+    class PartyMemberValue : public UnitCalculatedValue
+	{
+	public:
+        PartyMemberValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    public:
+        bool IsTargetOfSpellCast(Player* target, SpellEntryPredicate &predicate);
+
+    protected:
+        Unit* FindPartyMember(FindPlayerPredicate &predicate);
+        Unit* FindPartyMember(list<Player*>* party, FindPlayerPredicate &predicate);
+        bool Check(Unit* player);
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
new file mode 100644
index 0000000..63f7008
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.cpp
@@ -0,0 +1,35 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+class PlayerWithoutAuraPredicate : public FindPlayerPredicate, public PlayerbotAIAware
+{
+public:
+    PlayerWithoutAuraPredicate(PlayerbotAI* ai, string aura) :
+        PlayerbotAIAware(ai), FindPlayerPredicate(), aura(aura) {}
+
+public:
+    virtual bool Check(Unit* unit)
+    {
+        if (unit->IsPet())
+        {
+            Pet* pet = unit->ToPet();
+            if (pet && pet->getPetType() == SUMMON_PET)
+                return false;
+        }
+
+        return unit->IsAlive() && !ai->HasAura(aura, unit);
+    }
+
+private:
+    string aura;
+};
+
+Unit* PartyMemberWithoutAuraValue::Calculate()
+{
+	PlayerWithoutAuraPredicate predicate(ai, qualifier);
+    return FindPartyMember(predicate);
+}
diff --git a/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
new file mode 100644
index 0000000..63961de
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PartyMemberWithoutAuraValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "PartyMemberValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PartyMemberWithoutAuraValue : public PartyMemberValue, public Qualified
+	{
+	public:
+        PartyMemberWithoutAuraValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          PartyMemberValue(ai) {}
+
+    protected:
+        virtual Unit* Calculate();
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/PetTargetValue.h b/src/plugins/playerbot/strategy/values/PetTargetValue.h
new file mode 100644
index 0000000..35705c7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PetTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class PetTargetValue : public UnitCalculatedValue
+	{
+	public:
+        PetTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return (Unit*)(ai->GetBot()->GetPet()); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.cpp b/src/plugins/playerbot/strategy/values/PositionValue.cpp
new file mode 100644
index 0000000..70424b0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.cpp
@@ -0,0 +1,10 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PositionValue.h"
+
+using namespace ai;
+
+PositionValue::PositionValue(PlayerbotAI* ai)
+    : ManualSetValue<ai::Position&>(ai, position), Qualified()
+{
+}
diff --git a/src/plugins/playerbot/strategy/values/PositionValue.h b/src/plugins/playerbot/strategy/values/PositionValue.h
new file mode 100644
index 0000000..4d453e1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PositionValue.h
@@ -0,0 +1,26 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class Position
+    {
+    public:
+        Position() : valueSet(false) {}
+        void Set(double x, double y, double z) { this->x = x; this->y = y; this->z = z; this->valueSet = true; }
+        void Reset() { valueSet = false; }
+        bool isSet() { return valueSet; }
+
+        double x, y, z;
+        bool valueSet;
+    };
+
+    class PositionValue : public ManualSetValue<Position&>, public Qualified
+	{
+	public:
+        PositionValue(PlayerbotAI* ai);
+
+	private:
+        Position position;
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
new file mode 100644
index 0000000..17e1c27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.cpp
@@ -0,0 +1,23 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "PossibleTargetsValue.h"
+
+#include "../../../Grids/Notifiers/GridNotifiers.h"
+#include "../../../Grids/Notifiers/GridNotifiersImpl.h"
+#include "../../../Grids/Cells/CellImpl.h"
+
+using namespace ai;
+using namespace Trinity;
+
+void PossibleTargetsValue::FindUnits(list<Unit*> &targets)
+{
+    AnyUnfriendlyUnitInObjectRangeCheck u_check(bot, bot, range);
+    UnitListSearcher<AnyUnfriendlyUnitInObjectRangeCheck> searcher(bot, targets, u_check);
+    bot->VisitNearbyObject(bot->GetMap()->GetVisibilityRange(), searcher);
+}
+
+bool PossibleTargetsValue::AcceptUnit(Unit* unit)
+{
+    return !unit->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NON_ATTACKABLE) &&
+            (unit->IsHostileTo(bot) || (unit->getLevel() > 1 && !unit->IsFriendlyTo(bot)));
+}
diff --git a/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
new file mode 100644
index 0000000..5a97a71
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/PossibleTargetsValue.h
@@ -0,0 +1,19 @@
+#pragma once
+#include "../Value.h"
+#include "NearestUnitsValue.h"
+#include "../../PlayerbotAIConfig.h"
+
+namespace ai
+{
+    class PossibleTargetsValue : public NearestUnitsValue
+	{
+	public:
+        PossibleTargetsValue(PlayerbotAI* ai, float range = sPlayerbotAIConfig.sightDistance) :
+          NearestUnitsValue(ai) {}
+
+    protected:
+        virtual void FindUnits(list<Unit*> &targets);
+        virtual bool AcceptUnit(Unit* unit);
+
+	};
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiTargetValue.h b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
new file mode 100644
index 0000000..01aac86
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiTargetValue.h
@@ -0,0 +1,51 @@
+#pragma once
+#include "../Value.h"
+#include "../../../Groups/Group.h"
+
+namespace ai
+{
+    class RtiTargetValue : public UnitCalculatedValue
+    {
+    public:
+        RtiTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai)
+        {}
+
+    public:
+        static int GetRtiIndex(string rti)
+        {
+            int index = -1;
+            if(rti == "star") index = 0;
+            else if(rti == "circle") index = 1;
+            else if(rti == "diamond") index = 2;
+            else if(rti == "triangle") index = 3;
+            else if(rti == "moon") index = 4;
+            else if(rti == "square") index = 5;
+            else if(rti == "cross") index = 6;
+            else if(rti == "skull") index = 7;
+            return index;
+        }
+
+        Unit *Calculate()
+        {
+            Group *group = bot->GetGroup();
+            if(!group)
+                return NULL;
+
+            string rti = AI_VALUE(string, "rti");
+            int index = GetRtiIndex(rti);
+
+            if (index == -1)
+                return NULL;
+
+            uint64 guid = group->GetTargetIcon(index);
+            if (!guid)
+                return NULL;
+
+            Unit* unit = ai->GetUnit(ObjectGuid(guid));
+            if (!unit || unit->isDead())
+                return NULL;
+
+            return unit;
+        }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.cpp b/src/plugins/playerbot/strategy/values/RtiValue.cpp
new file mode 100644
index 0000000..3698212
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.cpp
@@ -0,0 +1,36 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "RtiValue.h"
+
+using namespace ai;
+
+RtiValue::RtiValue(PlayerbotAI* ai)
+    : ManualSetValue<string>(ai, "none")
+{
+    switch (ai->GetBot()->getClass())
+    {
+    case CLASS_DRUID:
+        value = "circle";
+        break;
+    case CLASS_ROGUE:
+        value = "star";
+        break;
+    case CLASS_SHAMAN:
+        value = "square";
+        break;
+    case CLASS_HUNTER:
+        value = "triangle";
+        break;
+    case CLASS_WARLOCK:
+    case CLASS_PALADIN:
+        value = "diamond";
+        break;
+    case CLASS_PRIEST:
+    case CLASS_MAGE:
+        value = "moon";
+        break;
+    default:
+        value = "skull";
+        break;
+    }
+}
diff --git a/src/plugins/playerbot/strategy/values/RtiValue.h b/src/plugins/playerbot/strategy/values/RtiValue.h
new file mode 100644
index 0000000..760485e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/RtiValue.h
@@ -0,0 +1,11 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class RtiValue : public ManualSetValue<string>
+	{
+	public:
+        RtiValue(PlayerbotAI* ai);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SelfTargetValue.h b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
new file mode 100644
index 0000000..f64a0fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SelfTargetValue.h
@@ -0,0 +1,13 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class SelfTargetValue : public UnitCalculatedValue
+	{
+	public:
+        SelfTargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+        virtual Unit* Calculate() { return ai->GetBot(); }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
new file mode 100644
index 0000000..dec5e9f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.cpp
@@ -0,0 +1,44 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+
+using namespace ai;
+
+bool SpellCastUsefulValue::Calculate()
+{
+    uint32 spellid = AI_VALUE2(uint32, "spell id", qualifier);
+	if (!spellid)
+		return true; // there can be known alternatives
+
+	SpellInfo const *spellInfo = sSpellMgr->GetSpellInfo(spellid);
+	if (!spellInfo)
+		return true; // there can be known alternatives
+
+	if (spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING ||
+		spellInfo->Attributes & SPELL_ATTR0_ON_NEXT_SWING_2)
+	{
+		Spell* spell = bot->GetCurrentSpell(CURRENT_MELEE_SPELL);
+		if (spell && spell->m_spellInfo->Id == spellid && spell->IsNextMeleeSwingSpell())
+			return false;
+	}
+
+    uint32 lastSpellId = AI_VALUE(LastSpellCast&, "last spell cast").id;
+    if (spellid == lastSpellId)
+    {
+        Spell* const pSpell = bot->FindCurrentSpellBySpellId(lastSpellId);
+        if (pSpell)
+            return false;
+    }
+
+    // TODO: workaround
+    if (qualifier == "windfury weapon" || qualifier == "flametongue weapon" || qualifier == "frostbrand weapon" ||
+            qualifier == "rockbiter weapon" || qualifier == "earthliving weapon" || qualifier == "spellstone")
+    {
+        Item *item = AI_VALUE2(Item*, "item for spell", spellid);
+        if (item && item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT))
+            return false;
+    }
+
+	return true;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
new file mode 100644
index 0000000..8fa9386
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellCastUsefulValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class SpellCastUsefulValue : public BoolCalculatedValue, public Qualified
+	{
+	public:
+        SpellCastUsefulValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+      
+    public:
+        virtual bool Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.cpp b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
new file mode 100644
index 0000000..61755b7
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.cpp
@@ -0,0 +1,90 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "SpellIdValue.h"
+#include "../../PlayerbotAIConfig.h"
+#include "../../../Entities/Pet/Pet.h"
+
+using namespace ai;
+
+SpellIdValue::SpellIdValue(PlayerbotAI* ai) :
+        CalculatedValue<uint32>(ai, "spell id", 5)
+{
+}
+
+uint32 SpellIdValue::Calculate()
+{
+    string namepart = qualifier;
+    wstring wnamepart;
+
+    if (!Utf8toWStr(namepart, wnamepart))
+        return 0;
+
+    wstrToLower(wnamepart);
+    char firstSymbol = tolower(qualifier[0]);
+    int spellLength = wnamepart.length();
+
+    int loc = bot->GetSession()->GetSessionDbcLocale();
+
+    uint32 foundSpellId = 0;
+    bool foundMatchUsesNoReagents = false;
+
+    for (PlayerSpellMap::iterator itr = bot->GetSpellMap().begin(); itr != bot->GetSpellMap().end(); ++itr)
+    {
+        uint32 spellId = itr->first;
+
+        const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+        if (!pSpellInfo)
+            continue;
+
+        if (itr->second->state == PLAYERSPELL_REMOVED || itr->second->disabled || pSpellInfo->IsPassive())
+            continue;
+
+        if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+            continue;
+
+        char* spellName = pSpellInfo->SpellName[loc];
+        if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+            continue;
+
+        bool usesNoReagents = (pSpellInfo->Reagent[0] <= 0);
+
+        // if we already found a spell
+        bool useThisSpell = true;
+        if (foundSpellId > 0) {
+            if (usesNoReagents && !foundMatchUsesNoReagents) {}
+            else if (spellId > foundSpellId) {}
+            else
+                useThisSpell = false;
+        }
+        if (useThisSpell) {
+            foundSpellId = spellId;
+            foundMatchUsesNoReagents = usesNoReagents;
+        }
+    }
+
+    Pet* pet = bot->GetPet();
+    if (!foundSpellId && pet)
+    {
+        for (PetSpellMap::const_iterator itr = pet->m_spells.begin(); itr != pet->m_spells.end(); ++itr)
+        {
+            if(itr->second.state == PETSPELL_REMOVED)
+                continue;
+
+            uint32 spellId = itr->first;
+            const SpellInfo* pSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (!pSpellInfo)
+                continue;
+
+            if (pSpellInfo->Effects[0].Effect == SPELL_EFFECT_LEARN_SPELL)
+                continue;
+
+            char* spellName = pSpellInfo->SpellName[loc];
+            if (tolower(spellName[0]) != firstSymbol || strlen(spellName) != spellLength || !Utf8FitTo(spellName, wnamepart))
+                continue;
+
+            foundSpellId = spellId;
+        }
+    }
+
+    return foundSpellId;
+}
diff --git a/src/plugins/playerbot/strategy/values/SpellIdValue.h b/src/plugins/playerbot/strategy/values/SpellIdValue.h
new file mode 100644
index 0000000..1281b38
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/SpellIdValue.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+
+    class SpellIdValue : public CalculatedValue<uint32>, public Qualified
+	{
+	public:
+        SpellIdValue(PlayerbotAI* ai);
+
+    public:
+        virtual uint32 Calculate();
+
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.cpp b/src/plugins/playerbot/strategy/values/StatsValues.cpp
new file mode 100644
index 0000000..5bbfc55
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.cpp
@@ -0,0 +1,111 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "StatsValues.h"
+
+using namespace ai;
+
+uint8 HealthValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetHealth()) / target->GetMaxHealth()) * 100;
+}
+
+bool IsDeadValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->getDeathState() != ALIVE;
+}
+
+
+uint8 RageValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_RAGE)));
+}
+
+uint8 EnergyValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 0;
+    return (static_cast<float> (target->GetPower(POWER_ENERGY)));
+}
+
+uint8 ManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return 100;
+    return (static_cast<float> (target->GetPower(POWER_MANA)) / target->GetMaxPower(POWER_MANA)) * 100;
+}
+
+bool HasManaValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+    return target->GetPower(POWER_MANA);
+}
+
+
+uint8 ComboPointsValue::Calculate()
+{
+    Unit *target = GetTarget();
+    if (!target || target->GetGUID() != bot->GetComboTarget())
+        return 0;
+
+    return bot->GetComboPoints();
+}
+
+bool IsMountedValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsMounted();
+}
+
+
+bool IsInCombatValue::Calculate()
+{
+    Unit* target = GetTarget();
+    if (!target)
+        return false;
+
+    return target->IsInCombat();
+}
+
+uint8 BagSpaceValue::Calculate()
+{
+    uint32 totalused = 0, total = 16;
+    for (uint8 slot = INVENTORY_SLOT_ITEM_START; slot < INVENTORY_SLOT_ITEM_END; slot++)
+    {
+        if (bot->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+            totalused++;
+    }
+
+    uint32 totalfree = 16 - totalused;
+    for (uint8 bag = INVENTORY_SLOT_BAG_START; bag < INVENTORY_SLOT_BAG_END; ++bag)
+    {
+        const Bag* const pBag = (Bag*) bot->GetItemByPos(INVENTORY_SLOT_BAG_0, bag);
+        if (pBag)
+        {
+            ItemTemplate const* pBagProto = pBag->GetTemplate();
+            if (pBagProto->Class == ITEM_CLASS_CONTAINER && pBagProto->SubClass == ITEM_SUBCLASS_CONTAINER)
+            {
+                total += pBag->GetBagSize();
+                totalfree += pBag->GetFreeSlots();
+            }
+        }
+
+    }
+
+    return (static_cast<float> (totalused) / total) * 100;
+}
diff --git a/src/plugins/playerbot/strategy/values/StatsValues.h b/src/plugins/playerbot/strategy/values/StatsValues.h
new file mode 100644
index 0000000..4fcdbaf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/StatsValues.h
@@ -0,0 +1,133 @@
+#pragma once
+#include "../Value.h"
+
+class Unit;
+
+namespace ai
+{
+    class HealthValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        HealthValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsDeadValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsDeadValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class RageValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        RageValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class EnergyValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        EnergyValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class ManaValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ManaValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class HasManaValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        HasManaValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class ComboPointsValue : public Uint8CalculatedValue, public Qualified
+    {
+    public:
+        ComboPointsValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual uint8 Calculate();
+    };
+
+    class IsMountedValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsMountedValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate();
+    };
+
+    class IsInCombatValue : public BoolCalculatedValue, public Qualified
+    {
+    public:
+        IsInCombatValue(PlayerbotAI* ai) : BoolCalculatedValue(ai) {}
+
+        Unit* GetTarget()
+        {
+            AiObjectContext* ctx = AiObject::context;
+            return ctx->GetValue<Unit*>(qualifier)->Get();
+        }
+        virtual bool Calculate() ;
+    };
+
+    class BagSpaceValue : public Uint8CalculatedValue
+    {
+    public:
+        BagSpaceValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+        virtual uint8 Calculate();
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.cpp b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
new file mode 100644
index 0000000..01967f8
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.cpp
@@ -0,0 +1,47 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TankTargetValue.h"
+
+using namespace ai;
+
+class FindTargetForTankStrategy : public FindTargetStrategy
+{
+public:
+    FindTargetForTankStrategy(PlayerbotAI* ai) : FindTargetStrategy(ai)
+    {
+        minThreat = 0;
+        minTankCount = 0;
+        maxDpsCount = 0;
+    }
+
+public:
+    virtual void CheckAttacker(Unit* creature, ThreatManager* threatManager)
+    {
+        Player* bot = ai->GetBot();
+        float threat = threatManager->getThreat(bot);
+        int tankCount, dpsCount;
+        GetPlayerCount(creature, &tankCount, &dpsCount);
+
+        if (!result ||
+            (minThreat >= threat &&
+            (minTankCount >= tankCount || maxDpsCount <= dpsCount)))
+        {
+            minThreat = threat;
+            minTankCount = tankCount;
+            maxDpsCount = dpsCount;
+            result = creature;
+        }
+    }
+
+protected:
+    float minThreat;
+    int minTankCount;
+    int maxDpsCount;
+};
+
+
+Unit* TankTargetValue::Calculate()
+{
+    FindTargetForTankStrategy strategy(ai);
+    return FindTarget(&strategy);
+}
diff --git a/src/plugins/playerbot/strategy/values/TankTargetValue.h b/src/plugins/playerbot/strategy/values/TankTargetValue.h
new file mode 100644
index 0000000..f297eb0
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TankTargetValue.h
@@ -0,0 +1,16 @@
+#pragma once
+#include "../Value.h"
+#include "TargetValue.h"
+
+namespace ai
+{
+   
+    class TankTargetValue : public TargetValue
+	{
+	public:
+        TankTargetValue(PlayerbotAI* ai) : TargetValue(ai) {}
+
+    public:
+        Unit* Calculate();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.cpp b/src/plugins/playerbot/strategy/values/TargetValue.cpp
new file mode 100644
index 0000000..2586bad
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.cpp
@@ -0,0 +1,54 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "TargetValue.h"
+
+using namespace ai;
+
+Unit* TargetValue::FindTarget(FindTargetStrategy* strategy)
+{
+    list<ObjectGuid> attackers = ai->GetAiObjectContext()->GetValue<list<ObjectGuid> >("attackers")->Get();
+    for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); ++i)
+    {
+        Unit* unit = ai->GetUnit(*i);
+        if (!unit)
+            continue;
+
+        ThreatManager &threatManager = unit->getThreatManager();
+        strategy->CheckAttacker(unit, &threatManager);
+    }
+
+    return strategy->GetResult();
+}
+
+void FindTargetStrategy::GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount)
+{
+    Player* bot = ai->GetBot();
+    if (tankCountCache.find(creature) != tankCountCache.end())
+    {
+        *tankCount = tankCountCache[creature];
+        *dpsCount = dpsCountCache[creature];
+        return;
+    }
+
+    *tankCount = 0;
+    *dpsCount = 0;
+
+    for (HostileReference *ref = creature->getHostileRefManager().getFirst(); ref; ref = ref->next())
+    {
+        ThreatManager *threatManager = ref->GetSource();
+        Unit *attacker = threatManager->GetOwner();
+        Unit *victim = attacker->GetVictim();
+        Player *player = dynamic_cast<Player*>(victim);
+
+        if (!player)
+            continue;
+
+        if (ai->IsTank(player))
+            (*tankCount)++;
+        else
+            (*dpsCount)++;
+    }
+
+    tankCountCache[creature] = *tankCount;
+    dpsCountCache[creature] = *dpsCount;
+}
diff --git a/src/plugins/playerbot/strategy/values/TargetValue.h b/src/plugins/playerbot/strategy/values/TargetValue.h
new file mode 100644
index 0000000..700d51d
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/TargetValue.h
@@ -0,0 +1,39 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class FindTargetStrategy
+    {
+    public:
+        FindTargetStrategy(PlayerbotAI* ai)
+        {
+            result = NULL;
+            this->ai = ai;
+        }
+
+    public:
+        Unit* GetResult() { return result; }
+
+    public:
+        virtual void CheckAttacker(Unit* attacker, ThreatManager* threatManager) = 0;
+        void GetPlayerCount(Unit* creature, int* tankCount, int* dpsCount);
+
+    protected:
+        Unit* result;
+        PlayerbotAI* ai;
+
+    protected:
+        map<Unit*, int> tankCountCache;
+        map<Unit*, int> dpsCountCache;
+    };
+
+    class TargetValue : public UnitCalculatedValue
+	{
+	public:
+        TargetValue(PlayerbotAI* ai) : UnitCalculatedValue(ai) {}
+
+    protected:
+        Unit* FindTarget(FindTargetStrategy* strategy);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.cpp b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
new file mode 100644
index 0000000..b0e0a00
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.cpp
@@ -0,0 +1,62 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "ThreatValues.h"
+
+using namespace ai;
+
+uint8 ThreatValue::Calculate()
+{
+    if (qualifier == "aoe")
+    {
+        uint8 maxThreat = 0;
+        list<ObjectGuid> attackers = context->GetValue<list<ObjectGuid> >("attackers")->Get();
+        for (list<ObjectGuid>::iterator i = attackers.begin(); i != attackers.end(); i++)
+        {
+            Unit* unit = ai->GetUnit(*i);
+            if (!unit || !unit->IsAlive())
+                continue;
+
+            uint8 threat = Calculate(unit);
+            if (!maxThreat || threat > maxThreat)
+                maxThreat = threat;
+        }
+
+        return maxThreat;
+    }
+
+    Unit* target = AI_VALUE(Unit*, qualifier);
+    return Calculate(target);
+}
+
+uint8 ThreatValue::Calculate(Unit* target)
+{
+    if (!target)
+        return 0;
+
+    if (dynamic_cast<Player*>(target))
+        return 0;
+
+    Group* group = bot->GetGroup();
+    if (!group)
+        return 0;
+
+    float botThreat = target->getThreatManager().getThreat(bot);
+    float maxThreat = 0;
+
+    Group::MemberSlotList const& groupSlot = group->GetMemberSlots();
+    for (Group::member_citerator itr = groupSlot.begin(); itr != groupSlot.end(); itr++)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(itr->guid);
+        if( !player || !player->IsAlive() || player == bot)
+            continue;
+
+        float threat = target->getThreatManager().getThreat(player);
+        if (maxThreat < threat)
+            maxThreat = threat;
+    }
+
+    if (maxThreat <= 0)
+        return 0;
+
+    return botThreat * 100 / maxThreat;
+}
diff --git a/src/plugins/playerbot/strategy/values/ThreatValues.h b/src/plugins/playerbot/strategy/values/ThreatValues.h
new file mode 100644
index 0000000..7301f79
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ThreatValues.h
@@ -0,0 +1,17 @@
+#pragma once
+#include "../Value.h"
+
+namespace ai
+{
+    class ThreatValue : public Uint8CalculatedValue, public Qualified
+	{
+	public:
+        ThreatValue(PlayerbotAI* ai) : Uint8CalculatedValue(ai) {}
+
+    public:
+    	virtual uint8 Calculate();
+
+    protected:
+    	uint8 Calculate(Unit* target);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/values/ValueContext.h b/src/plugins/playerbot/strategy/values/ValueContext.h
new file mode 100644
index 0000000..adad335
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/ValueContext.h
@@ -0,0 +1,225 @@
+#pragma once
+
+#include "NearestGameObjects.h"
+#include "LogLevelValue.h"
+#include "NearestNpcsValue.h"
+#include "PossibleTargetsValue.h"
+#include "NearestAdsValue.h"
+#include "NearestCorpsesValue.h"
+#include "PartyMemberWithoutAuraValue.h"
+#include "PartyMemberToHeal.h"
+#include "PartyMemberToResurrect.h"
+#include "CurrentTargetValue.h"
+#include "SelfTargetValue.h"
+#include "MasterTargetValue.h"
+#include "LineTargetValue.h"
+#include "TankTargetValue.h"
+#include "DpsTargetValue.h"
+#include "CcTargetValue.h"
+#include "CurrentCcTargetValue.h"
+#include "PetTargetValue.h"
+#include "GrindTargetValue.h"
+#include "RtiTargetValue.h"
+#include "PartyMemberToDispel.h"
+#include "StatsValues.h"
+#include "AttackerCountValues.h"
+#include "AttackersValue.h"
+#include "AvailableLootValue.h"
+#include "AlwaysLootListValue.h"
+#include "LootStrategyValue.h"
+#include "HasAvailableLootValue.h"
+#include "LastMovementValue.h"
+#include "DistanceValue.h"
+#include "IsMovingValue.h"
+#include "IsBehindValue.h"
+#include "IsFacingValue.h"
+#include "ItemCountValue.h"
+#include "SpellIdValue.h"
+#include "ItemForSpellValue.h"
+#include "SpellCastUsefulValue.h"
+#include "LastSpellCastValue.h"
+#include "ChatValue.h"
+#include "HasTotemValue.h"
+#include "LeastHpTargetValue.h"
+#include "AoeHealValues.h"
+#include "RtiValue.h"
+#include "PositionValue.h"
+#include "ThreatValues.h"
+#include "DuelTargetValue.h"
+#include "InvalidTargetValue.h"
+#include "EnemyPlayerValue.h"
+#include "AttackerWithoutAuraTargetValue.h"
+#include "LastSpellCastTimeValue.h"
+#include "ManaSaveLevelValue.h"
+#include "LfgValues.h"
+#include "EnemyHealerTargetValue.h"
+#include "Formations.h"
+#include "ItemUsageValue.h"
+
+namespace ai
+{
+    class ValueContext : public NamedObjectContext<UntypedValue>
+    {
+    public:
+        ValueContext()
+        {
+            creators["nearest game objects"] = &ValueContext::nearest_game_objects;
+            creators["nearest npcs"] = &ValueContext::nearest_npcs;
+            creators["possible targets"] = &ValueContext::possible_targets;
+            creators["nearest adds"] = &ValueContext::nearest_adds;
+            creators["nearest corpses"] = &ValueContext::nearest_corpses;
+            creators["log level"] = &ValueContext::log_level;
+            creators["party member without aura"] = &ValueContext::party_member_without_aura;
+            creators["attacker without aura"] = &ValueContext::attacker_without_aura;
+            creators["party member to heal"] = &ValueContext::party_member_to_heal;
+            creators["party member to resurrect"] = &ValueContext::party_member_to_resurrect;
+            creators["current target"] = &ValueContext::current_target;
+            creators["self target"] = &ValueContext::self_target;
+            creators["master target"] = &ValueContext::master;
+            creators["line target"] = &ValueContext::line_target;
+            creators["tank target"] = &ValueContext::tank_target;
+            creators["dps target"] = &ValueContext::dps_target;
+            creators["least hp target"] = &ValueContext::least_hp_target;
+            creators["enemy player target"] = &ValueContext::enemy_player_target;
+            creators["cc target"] = &ValueContext::cc_target;
+            creators["current cc target"] = &ValueContext::current_cc_target;
+            creators["pet target"] = &ValueContext::pet_target;
+            creators["old target"] = &ValueContext::old_target;
+            creators["grind target"] = &ValueContext::grind_target;
+            creators["rti target"] = &ValueContext::rti_target;
+            creators["duel target"] = &ValueContext::duel_target;
+            creators["party member to dispel"] = &ValueContext::party_member_to_dispel;
+            creators["health"] = &ValueContext::health;
+            creators["rage"] = &ValueContext::rage;
+            creators["energy"] = &ValueContext::energy;
+            creators["mana"] = &ValueContext::mana;
+            creators["combo"] = &ValueContext::combo;
+            creators["dead"] = &ValueContext::dead;
+            creators["has mana"] = &ValueContext::has_mana;
+            creators["attacker count"] = &ValueContext::attacker_count;
+            creators["my attacker count"] = &ValueContext::my_attacker_count;
+            creators["has aggro"] = &ValueContext::has_aggro;
+            creators["mounted"] = &ValueContext::mounted;
+
+            creators["can loot"] = &ValueContext::can_loot;
+            creators["loot target"] = &ValueContext::loot_target;
+            creators["available loot"] = &ValueContext::available_loot;
+            creators["has available loot"] = &ValueContext::has_available_loot;
+            creators["always loot list"] = &ValueContext::always_loot_list;
+            creators["loot strategy"] = &ValueContext::loot_strategy;
+            creators["last movement"] = &ValueContext::last_movement;
+            creators["distance"] = &ValueContext::distance;
+            creators["moving"] = &ValueContext::moving;
+            creators["swimming"] = &ValueContext::swimming;
+            creators["behind"] = &ValueContext::behind;
+            creators["facing"] = &ValueContext::facing;
+
+            creators["item count"] = &ValueContext::item_count;
+            creators["inventory items"] = &ValueContext::inventory_item;
+
+            creators["spell id"] = &ValueContext::spell_id;
+            creators["item for spell"] = &ValueContext::item_for_spell;
+            creators["spell cast useful"] = &ValueContext::spell_cast_useful;
+            creators["last spell cast"] = &ValueContext::last_spell_cast;
+            creators["last spell cast time"] = &ValueContext::last_spell_cast_time;
+            creators["chat"] = &ValueContext::chat;
+            creators["has totem"] = &ValueContext::has_totem;
+
+            creators["aoe heal"] = &ValueContext::aoe_heal;
+
+            creators["rti"] = &ValueContext::rti;
+            creators["position"] = &ValueContext::position;
+            creators["threat"] = &ValueContext::threat;
+
+            creators["balance"] = &ValueContext::balance;
+            creators["attackers"] = &ValueContext::attackers;
+            creators["invalid target"] = &ValueContext::invalid_target;
+            creators["mana save level"] = &ValueContext::mana_save_level;
+            creators["combat"] = &ValueContext::combat;
+            creators["lfg proposal"] = &ValueContext::lfg_proposal;
+            creators["bag space"] = &ValueContext::bag_space;
+            creators["enemy healer target"] = &ValueContext::enemy_healer_target;
+            creators["formation"] = &ValueContext::formation;
+            creators["item usage"] = &ValueContext::item_usage;
+        }
+
+    private:
+        static UntypedValue* item_usage(PlayerbotAI* ai) { return new ItemUsageValue(ai); }
+        static UntypedValue* formation(PlayerbotAI* ai) { return new FormationValue(ai); }
+        static UntypedValue* mana_save_level(PlayerbotAI* ai) { return new ManaSaveLevelValue(ai); }
+        static UntypedValue* invalid_target(PlayerbotAI* ai) { return new InvalidTargetValue(ai); }
+        static UntypedValue* balance(PlayerbotAI* ai) { return new BalancePercentValue(ai); }
+        static UntypedValue* attackers(PlayerbotAI* ai) { return new AttackersValue(ai); }
+
+        static UntypedValue* position(PlayerbotAI* ai) { return new PositionValue(ai); }
+        static UntypedValue* rti(PlayerbotAI* ai) { return new RtiValue(ai); }
+
+        static UntypedValue* aoe_heal(PlayerbotAI* ai) { return new AoeHealValue(ai); }
+
+        static UntypedValue* chat(PlayerbotAI* ai) { return new ChatValue(ai); }
+        static UntypedValue* last_spell_cast(PlayerbotAI* ai) { return new LastSpellCastValue(ai); }
+        static UntypedValue* last_spell_cast_time(PlayerbotAI* ai) { return new LastSpellCastTimeValue(ai); }
+        static UntypedValue* spell_cast_useful(PlayerbotAI* ai) { return new SpellCastUsefulValue(ai); }
+        static UntypedValue* item_for_spell(PlayerbotAI* ai) { return new ItemForSpellValue(ai); }
+        static UntypedValue* spell_id(PlayerbotAI* ai) { return new SpellIdValue(ai); }
+        static UntypedValue* inventory_item(PlayerbotAI* ai) { return new InventoryItemValue(ai); }
+        static UntypedValue* item_count(PlayerbotAI* ai) { return new ItemCountValue(ai); }
+        static UntypedValue* behind(PlayerbotAI* ai) { return new IsBehindValue(ai); }
+        static UntypedValue* facing(PlayerbotAI* ai) { return new IsFacingValue(ai); }
+        static UntypedValue* moving(PlayerbotAI* ai) { return new IsMovingValue(ai); }
+        static UntypedValue* swimming(PlayerbotAI* ai) { return new IsSwimmingValue(ai); }
+        static UntypedValue* distance(PlayerbotAI* ai) { return new DistanceValue(ai); }
+        static UntypedValue* last_movement(PlayerbotAI* ai) { return new LastMovementValue(ai); }
+
+        static UntypedValue* can_loot(PlayerbotAI* ai) { return new CanLootValue(ai); }
+        static UntypedValue* available_loot(PlayerbotAI* ai) { return new AvailableLootValue(ai); }
+        static UntypedValue* loot_target(PlayerbotAI* ai) { return new LootTargetValue(ai); }
+        static UntypedValue* has_available_loot(PlayerbotAI* ai) { return new HasAvailableLootValue(ai); }
+        static UntypedValue* always_loot_list(PlayerbotAI* ai) { return new AlwaysLootListValue(ai); }
+        static UntypedValue* loot_strategy(PlayerbotAI* ai) { return new LootStrategyValue(ai); }
+
+        static UntypedValue* attacker_count(PlayerbotAI* ai) { return new AttackerCountValue(ai); }
+        static UntypedValue* my_attacker_count(PlayerbotAI* ai) { return new MyAttackerCountValue(ai); }
+        static UntypedValue* has_aggro(PlayerbotAI* ai) { return new HasAggroValue(ai); }
+        static UntypedValue* mounted(PlayerbotAI* ai) { return new IsMountedValue(ai); }
+        static UntypedValue* health(PlayerbotAI* ai) { return new HealthValue(ai); }
+        static UntypedValue* rage(PlayerbotAI* ai) { return new RageValue(ai); }
+        static UntypedValue* energy(PlayerbotAI* ai) { return new EnergyValue(ai); }
+        static UntypedValue* mana(PlayerbotAI* ai) { return new ManaValue(ai); }
+        static UntypedValue* combo(PlayerbotAI* ai) { return new ComboPointsValue(ai); }
+        static UntypedValue* dead(PlayerbotAI* ai) { return new IsDeadValue(ai); }
+        static UntypedValue* has_mana(PlayerbotAI* ai) { return new HasManaValue(ai); }
+        static UntypedValue* nearest_game_objects(PlayerbotAI* ai) { return new NearestGameObjects(ai); }
+        static UntypedValue* log_level(PlayerbotAI* ai) { return new LogLevelValue(ai); }
+        static UntypedValue* nearest_npcs(PlayerbotAI* ai) { return new NearestNpcsValue(ai); }
+        static UntypedValue* nearest_corpses(PlayerbotAI* ai) { return new NearestCorpsesValue(ai); }
+        static UntypedValue* possible_targets(PlayerbotAI* ai) { return new PossibleTargetsValue(ai); }
+        static UntypedValue* nearest_adds(PlayerbotAI* ai) { return new NearestAdsValue(ai); }
+        static UntypedValue* party_member_without_aura(PlayerbotAI* ai) { return new PartyMemberWithoutAuraValue(ai); }
+        static UntypedValue* attacker_without_aura(PlayerbotAI* ai) { return new AttackerWithoutAuraTargetValue(ai); }
+        static UntypedValue* party_member_to_heal(PlayerbotAI* ai) { return new PartyMemberToHeal(ai); }
+        static UntypedValue* party_member_to_resurrect(PlayerbotAI* ai) { return new PartyMemberToResurrect(ai); }
+        static UntypedValue* party_member_to_dispel(PlayerbotAI* ai) { return new PartyMemberToDispel(ai); }
+        static UntypedValue* current_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* old_target(PlayerbotAI* ai) { return new CurrentTargetValue(ai); }
+        static UntypedValue* self_target(PlayerbotAI* ai) { return new SelfTargetValue(ai); }
+        static UntypedValue* master(PlayerbotAI* ai) { return new MasterTargetValue(ai); }
+        static UntypedValue* line_target(PlayerbotAI* ai) { return new LineTargetValue(ai); }
+        static UntypedValue* tank_target(PlayerbotAI* ai) { return new TankTargetValue(ai); }
+        static UntypedValue* dps_target(PlayerbotAI* ai) { return new DpsTargetValue(ai); }
+        static UntypedValue* least_hp_target(PlayerbotAI* ai) { return new LeastHpTargetValue(ai); }
+        static UntypedValue* enemy_player_target(PlayerbotAI* ai) { return new EnemyPlayerValue(ai); }
+        static UntypedValue* cc_target(PlayerbotAI* ai) { return new CcTargetValue(ai); }
+        static UntypedValue* current_cc_target(PlayerbotAI* ai) { return new CurrentCcTargetValue(ai); }
+        static UntypedValue* pet_target(PlayerbotAI* ai) { return new PetTargetValue(ai); }
+        static UntypedValue* grind_target(PlayerbotAI* ai) { return new GrindTargetValue(ai); }
+        static UntypedValue* rti_target(PlayerbotAI* ai) { return new RtiTargetValue(ai); }
+        static UntypedValue* duel_target(PlayerbotAI* ai) { return new DuelTargetValue(ai); }
+        static UntypedValue* has_totem(PlayerbotAI* ai) { return new HasTotemValue(ai); }
+        static UntypedValue* threat(PlayerbotAI* ai) { return new ThreatValue(ai); }
+        static UntypedValue* combat(PlayerbotAI* ai) { return new IsInCombatValue(ai); }
+        static UntypedValue* lfg_proposal(PlayerbotAI* ai) { return new LfgProposalValue(ai); }
+        static UntypedValue* bag_space(PlayerbotAI* ai) { return new BagSpaceValue(ai); }
+        static UntypedValue* enemy_healer_target(PlayerbotAI* ai) { return new EnemyHealerTargetValue(ai); }
+    };
+};
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.cpp b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
new file mode 100644
index 0000000..7b3a07f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.cpp
@@ -0,0 +1,162 @@
+#include "../../../../pchdef.h"
+#include "../../../playerbot.h"
+#include "../Formations.h"
+#include "Arrow.h"
+
+using namespace ai;
+
+WorldLocation ArrowFormation::GetLocation()
+{
+    Build();
+
+    int tankLines = 1 + tanks.Size() / 6;
+    int meleeLines = 1 + melee.Size() / 6;
+    int rangedLines = 1 + ranged.Size() / 6;
+    int healerLines = 1 + healers.Size() / 6;
+    float offset = 0;
+
+    Player* master = ai->GetMaster();
+    float orientation = master->GetOrientation();
+    MultiLineUnitPlacer placer(orientation);
+
+    tanks.PlaceUnits(&placer);
+
+    offset = tankLines * sPlayerbotAIConfig.followDistance;
+    melee.PlaceUnits(&placer);
+    melee.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += meleeLines * sPlayerbotAIConfig.followDistance + sPlayerbotAIConfig.tooCloseDistance;
+    ranged.PlaceUnits(&placer);
+    ranged.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    offset += rangedLines * sPlayerbotAIConfig.followDistance;
+    healers.PlaceUnits(&placer);
+    healers.Move(-cos(orientation) * offset, -sin(orientation) * offset);
+
+    float x = master->GetPositionX() - masterUnit->GetX() + botUnit->GetX();
+    float y = master->GetPositionY() - masterUnit->GetY() + botUnit->GetY();
+    float z = master->GetPositionZ();
+
+    float ground = master->GetMap()->GetHeight(x, y, z + 0.5f);
+    if (ground <= INVALID_HEIGHT)
+        return Formation::NullLocation;
+
+    return WorldLocation(master->GetMapId(), x, y, 0.05f + ground);
+
+
+}
+
+void ArrowFormation::Build()
+{
+    if (built)
+        return;
+
+    FillSlotsExceptMaster();
+    AddMasterToSlot();
+
+    built = true;
+}
+
+FormationSlot* ArrowFormation::FindSlot(Player* member)
+{
+    if (ai->IsTank(member))
+        return &tanks;
+    else if (ai->IsHeal(member))
+        return &healers;
+    else if (ai->IsRanged(member))
+        return &ranged;
+    else
+        return &melee;
+}
+
+void ArrowFormation::FillSlotsExceptMaster()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == bot)
+            FindSlot(member)->AddLast(botUnit = new FormationUnit(index, false));
+        else if (member != ai->GetMaster())
+            FindSlot(member)->AddLast(new FormationUnit(index, false));
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void ArrowFormation::AddMasterToSlot()
+{
+    Group* group = bot->GetGroup();
+    GroupReference *gref = group->GetFirstMember();
+    uint32 index = 0;
+    while (gref)
+    {
+        Player* member = gref->GetSource();
+
+        if (member == ai->GetMaster())
+        {
+            FindSlot(member)->InsertAtCenter(masterUnit = new FormationUnit(index, true));
+            break;
+        }
+
+        gref = gref->next();
+        index++;
+    }
+}
+
+void FormationSlot::PlaceUnits(UnitPlacer* placer)
+{
+    uint32 index = 0;
+    uint32 count = units.size();
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(placer->Place(unit, index, count));
+        index++;
+    }
+}
+
+UnitPosition MultiLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    SingleLineUnitPlacer placer(orientation);
+    if (count <= 6)
+        return placer.Place(unit, index, count);
+
+    int lineNo = index / 6;
+    int indexInLine = index % 6;
+    int lineSize = max(count - lineNo * 6, uint32(6));
+    float x = cos(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    float y = sin(orientation) * sPlayerbotAIConfig.followDistance * lineNo;
+    return placer.Place(unit, indexInLine, lineSize);
+}
+
+UnitPosition SingleLineUnitPlacer::Place(FormationUnit *unit, uint32 index, uint32 count)
+{
+    float angle = orientation - M_PI / 2.0f;
+    float x = cos(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    float y = sin(angle) * sPlayerbotAIConfig.followDistance * ((float)index - (float)count / 2);
+    return UnitPosition(x, y);
+}
+
+void FormationSlot::Move(float dx, float dy)
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        unit->SetLocation(unit->GetX() + dx, unit->GetY() + dy);
+    }
+}
+
+FormationSlot::~FormationSlot()
+{
+    for (vector<FormationUnit*>::iterator i = units.begin(); i != units.end(); ++i)
+    {
+        FormationUnit* unit = *i;
+        delete unit;
+    }
+    units.clear();
+}
diff --git a/src/plugins/playerbot/strategy/values/formations/Arrow.h b/src/plugins/playerbot/strategy/values/formations/Arrow.h
new file mode 100644
index 0000000..e302c87
--- /dev/null
+++ b/src/plugins/playerbot/strategy/values/formations/Arrow.h
@@ -0,0 +1,109 @@
+#pragma once
+
+namespace ai
+{
+    class UnitPosition
+    {
+    public:
+        UnitPosition(float x, float y) : x(x), y(y) {}
+        UnitPosition(const UnitPosition& other) { x = other.x; y = other.y; }
+        float x, y;
+    };
+
+    class FormationUnit
+    {
+    public:
+        FormationUnit(uint32 groupIndex, bool master) : groupIndex(groupIndex), master(master), position(0, 0) {}
+        FormationUnit(const FormationUnit& other) : position(other.position.x, other.position.y)
+        {
+            groupIndex = other.groupIndex;
+            master = other.master;
+        }
+
+    public:
+        uint32 GetGroupIdex() { return groupIndex; }
+        void SetLocation(UnitPosition pos) { position = pos; }
+        void SetLocation(float x, float y) { position.x = x; position.y = y; }
+        float GetX() { return position.x; }
+        float GetY() { return position.y; }
+
+    private:
+        uint32 groupIndex;
+        bool master;
+        UnitPosition position;
+    };
+
+    class UnitPlacer
+    {
+    public:
+        UnitPlacer() {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count) = 0;
+    };
+
+    class FormationSlot
+    {
+    public:
+        FormationSlot() {}
+        virtual ~FormationSlot();
+
+    public:
+        void AddLast(FormationUnit* unit) { units.push_back(unit); }
+        void InsertAtCenter(FormationUnit* unit) { units.insert(units.begin() + (units.size() + 1) / 2, unit); }
+        void PlaceUnits(UnitPlacer* placer);
+        void Move(float dx, float dy);
+        int Size() { return units.size(); }
+
+    private:
+        WorldLocation center;
+        vector<FormationUnit*> units;
+    };
+
+
+    class MultiLineUnitPlacer : public UnitPlacer
+    {
+    public:
+        MultiLineUnitPlacer(float orientation) : UnitPlacer(), orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class SingleLineUnitPlacer
+    {
+    public:
+        SingleLineUnitPlacer(float orientation) : orientation(orientation) {}
+
+    public:
+        virtual UnitPosition Place(FormationUnit *unit, uint32 index, uint32 count);
+
+    private:
+        float orientation;
+    };
+
+    class ArrowFormation : public MoveFormation
+    {
+    public:
+        ArrowFormation(PlayerbotAI* ai) : MoveFormation(ai, "arrow"), built(false), masterUnit(NULL), botUnit(NULL) {}
+
+    public:
+        virtual WorldLocation GetLocation();
+
+    private:
+        void Build();
+        void FillSlotsExceptMaster();
+        void AddMasterToSlot();
+        FormationSlot* FindSlot(Player* member);
+
+    private:
+        FormationSlot tanks, melee, ranged, healers;
+        FormationUnit *masterUnit, *botUnit;
+        bool built;
+    };
+
+}
+
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
new file mode 100644
index 0000000..039fd53
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.cpp
@@ -0,0 +1,76 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockMultipliers.h"
+#include "DpsWarlockStrategy.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+class DpsWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarlockStrategyActionNodeFactory()
+    {
+        creators["shadow bolt"] = &shadow_bolt;
+    }
+private:
+    static ActionNode* shadow_bolt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shadow bolt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shoot"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarlockStrategy::DpsWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarlockStrategyActionNodeFactory());
+}
+
+
+NextAction** DpsWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("incinirate", 10.0f), new NextAction("shadow bolt", 10.0f), NULL);
+}
+
+void DpsWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+	triggers.push_back(new TriggerNode(
+		"shadow trance",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"backlash",
+		NextAction::array(0, new NextAction("shadow bolt", 20.0f), NULL)));
+}
+
+void DpsAoeWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("rain of fire", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("seed of corruption", 31.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("shadowfury", 29.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "corruption on attacker",
+        NextAction::array(0, new NextAction("corruption on attacker", 28.0f), NULL)));
+
+}
+
+void DpsWarlockDebuffStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "corruption",
+        NextAction::array(0, new NextAction("corruption", 12.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
new file mode 100644
index 0000000..846f9df
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/DpsWarlockStrategy.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+#include "../generic/CombatStrategy.h"
+
+namespace ai
+{
+    class DpsWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        DpsWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "dps"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+
+    class DpsAoeWarlockStrategy : public CombatStrategy
+    {
+    public:
+        DpsAoeWarlockStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+
+    class DpsWarlockDebuffStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarlockDebuffStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps debuff"; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
new file mode 100644
index 0000000..3dc73c6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.cpp
@@ -0,0 +1,65 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockNonCombatStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockNonCombatStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockNonCombatStrategyActionNodeFactory()
+    {
+        creators["fel armor"] = &fel_armor;
+        creators["demon armor"] = &demon_armor;
+    }
+private:
+    static ActionNode* fel_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("fel armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* demon_armor(PlayerbotAI* ai)
+    {
+        return new ActionNode ("demon armor",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("demon skin"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockNonCombatStrategy::GenericWarlockNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockNonCombatStrategyActionNodeFactory());
+}
+
+void GenericWarlockNonCombatStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    NonCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "demon armor",
+        NextAction::array(0, new NextAction("fel armor", 21.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no healthstone",
+		NextAction::array(0, new NextAction("create healthstone", 15.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no firestone",
+		NextAction::array(0, new NextAction("create firestone", 14.0f), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"no spellstone",
+		NextAction::array(0, new NextAction("create spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "spellstone",
+        NextAction::array(0, new NextAction("spellstone", 13.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon imp", 10.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
new file mode 100644
index 0000000..c5e483f
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockNonCombatStrategy.h
@@ -0,0 +1,16 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarlockNonCombatStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "nc"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
new file mode 100644
index 0000000..e880061
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.cpp
@@ -0,0 +1,74 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "GenericWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["banish"] = &banish;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* banish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("banish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("fear"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarlockStrategy::GenericWarlockStrategy(PlayerbotAI* ai) : RangedCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** GenericWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void GenericWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    RangedCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "curse of agony",
+        NextAction::array(0, new NextAction("curse of agony", 11.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("drain life", 40.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "low mana",
+        NextAction::array(0, new NextAction("life tap", ACTION_EMERGENCY + 5), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"target critical health",
+		NextAction::array(0, new NextAction("drain soul", 30.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "banish",
+        NextAction::array(0, new NextAction("banish", 21.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "fear",
+        NextAction::array(0, new NextAction("fear on cc", 20.0f), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "immolate",
+        NextAction::array(0, new NextAction("immolate", 19.0f), new NextAction("conflagrate", 19.0f), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
new file mode 100644
index 0000000..473da59
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/GenericWarlockStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/RangedCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarlockStrategy : public RangedCombatStrategy
+    {
+    public:
+        GenericWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "warlock"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
new file mode 100644
index 0000000..cb4f5a5
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.cpp
@@ -0,0 +1,51 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "TankWarlockStrategy.h"
+
+using namespace ai;
+
+class GenericWarlockStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarlockStrategyActionNodeFactory()
+    {
+        creators["summon voidwalker"] = &summon_voidwalker;
+        creators["summon felguard"] = &summon_felguard;
+    }
+private:
+    static ActionNode* summon_voidwalker(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon voidwalker",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("drain soul"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* summon_felguard(PlayerbotAI* ai)
+    {
+        return new ActionNode ("summon felguard",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("summon voidwalker"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarlockStrategy::TankWarlockStrategy(PlayerbotAI* ai) : GenericWarlockStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarlockStrategyActionNodeFactory());
+}
+
+NextAction** TankWarlockStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("shoot", 10.0f), NULL);
+}
+
+void TankWarlockStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarlockStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "no pet",
+        NextAction::array(0, new NextAction("summon felguard", 50.0f), NULL)));
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
new file mode 100644
index 0000000..9cdd6e6
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/TankWarlockStrategy.h
@@ -0,0 +1,17 @@
+#pragma once
+
+#include "GenericWarlockStrategy.h"
+
+namespace ai
+{
+    class TankWarlockStrategy : public GenericWarlockStrategy
+    {
+    public:
+        TankWarlockStrategy(PlayerbotAI* ai);
+        virtual string getName() { return "tank"; }
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual NextAction** getDefaultActions();
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
new file mode 100644
index 0000000..0a01ebb
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.cpp
@@ -0,0 +1,5 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+
+using namespace ai;
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockActions.h b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
new file mode 100644
index 0000000..fb1689a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockActions.h
@@ -0,0 +1,176 @@
+#pragma once
+
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+	class CastDemonSkinAction : public CastBuffSpellAction {
+	public:
+		CastDemonSkinAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon skin") {}
+	};
+
+	class CastDemonArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastDemonArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "demon armor") {}
+	};
+
+	class CastFelArmorAction : public CastBuffSpellAction
+	{
+	public:
+		CastFelArmorAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fel armor") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastShadowBoltAction, "shadow bolt")
+    END_SPELL_ACTION()
+
+	class CastDrainSoulAction : public CastSpellAction
+	{
+	public:
+		CastDrainSoulAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain soul") {}
+		virtual bool isUseful()
+		{
+			return AI_VALUE2(uint8, "item count", "soul shard") < 2;
+		}
+	};
+
+	class CastDrainManaAction : public CastSpellAction
+	{
+	public:
+		CastDrainManaAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain mana") {}
+	};
+
+	class CastDrainLifeAction : public CastSpellAction
+	{
+	public:
+		CastDrainLifeAction(PlayerbotAI* ai) : CastSpellAction(ai, "drain life") {}
+	};
+
+	class CastCurseOfAgonyAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfAgonyAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of agony") {}
+	};
+
+	class CastCurseOfWeaknessAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCurseOfWeaknessAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "curse of weakness") {}
+	};
+
+	class CastCorruptionAction : public CastDebuffSpellAction
+	{
+	public:
+		CastCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "corruption") {}
+	};
+
+	class CastCorruptionOnAttackerAction : public CastDebuffSpellOnAttackerAction
+	{
+	public:
+	    CastCorruptionOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "corruption") {}
+	};
+
+
+	class CastSummonVoidwalkerAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonVoidwalkerAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon voidwalker") {}
+	};
+
+	class CastSummonFelguardAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonFelguardAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon felguard") {}
+	};
+
+	class CastSummonImpAction : public CastBuffSpellAction
+	{
+	public:
+		CastSummonImpAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "summon imp") {}
+	};
+
+	class CastCreateHealthstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateHealthstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create healthstone") {}
+	};
+
+	class CastCreateFirestoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateFirestoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create firestone") {}
+	};
+
+	class CastCreateSpellstoneAction : public CastBuffSpellAction
+	{
+	public:
+		CastCreateSpellstoneAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "create spellstone") {}
+	};
+
+    class CastBanishAction : public CastBuffSpellAction
+    {
+    public:
+        CastBanishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "banish on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "banish"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("banish", GetTarget()); }
+    };
+
+    class CastSeedOfCorruptionAction : public CastDebuffSpellAction
+    {
+    public:
+        CastSeedOfCorruptionAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "seed of corruption") {}
+    };
+
+    class CastRainOfFireAction : public CastSpellAction
+    {
+    public:
+        CastRainOfFireAction(PlayerbotAI* ai) : CastSpellAction(ai, "rain of fire") {}
+    };
+
+    class CastShadowfuryAction : public CastSpellAction
+    {
+    public:
+        CastShadowfuryAction(PlayerbotAI* ai) : CastSpellAction(ai, "shadowfury") {}
+    };
+
+    class CastImmolateAction : public CastDebuffSpellAction
+    {
+    public:
+        CastImmolateAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "immolate") {}
+    };
+
+    class CastConflagrateAction : public CastSpellAction
+    {
+    public:
+        CastConflagrateAction(PlayerbotAI* ai) : CastSpellAction(ai, "conflagrate") {}
+    };
+
+    class CastIncinirateAction : public CastSpellAction
+    {
+    public:
+        CastIncinirateAction(PlayerbotAI* ai) : CastSpellAction(ai, "incinirate") {}
+    };
+
+    class CastFearAction : public CastDebuffSpellAction
+    {
+    public:
+        CastFearAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "fear") {}
+    };
+
+    class CastFearOnCcAction : public CastBuffSpellAction
+    {
+    public:
+        CastFearOnCcAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "fear on cc") {}
+        virtual Value<Unit*>* GetTargetValue() { return context->GetValue<Unit*>("cc target", "fear"); }
+        virtual bool Execute(Event event) { return ai->CastSpell("fear", GetTarget()); }
+    };
+
+    class CastLifeTapAction: public CastSpellAction
+    {
+    public:
+        CastLifeTapAction(PlayerbotAI* ai) : CastSpellAction(ai, "life tap") {}
+        virtual string GetTargetName() { return "self target"; }
+        virtual bool isUseful() { return AI_VALUE2(uint8, "health", "self target") > sPlayerbotAIConfig.lowHealth; }
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
new file mode 100644
index 0000000..8c25fd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.cpp
@@ -0,0 +1,183 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockActions.h"
+#include "WarlockAiObjectContext.h"
+#include "DpsWarlockStrategy.h"
+#include "GenericWarlockNonCombatStrategy.h"
+#include "TankWarlockStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarlockTriggers.h"
+#include "../NamedObjectContext.h"
+#include "../actions/UseItemAction.h"
+
+using namespace ai;
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warlock::StrategyFactoryInternal::nc;
+                creators["pull"] = &warlock::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warlock::StrategyFactoryInternal::aoe;
+                creators["dps debuff"] = &warlock::StrategyFactoryInternal::dps_debuff;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarlockNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsAoeWarlockStrategy(ai); }
+            static Strategy* dps_debuff(PlayerbotAI* ai) { return new DpsWarlockDebuffStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["dps"] = &warlock::CombatStrategyFactoryInternal::dps;
+                creators["tank"] = &warlock::CombatStrategyFactoryInternal::tank;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarlockStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarlockStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["shadow trance"] = &TriggerFactoryInternal::shadow_trance;
+                creators["demon armor"] = &TriggerFactoryInternal::demon_armor;
+                creators["no healthstone"] = &TriggerFactoryInternal::HasHealthstone;
+                creators["no firestone"] = &TriggerFactoryInternal::HasFirestone;
+                creators["no spellstone"] = &TriggerFactoryInternal::HasSpellstone;
+                creators["corruption"] = &TriggerFactoryInternal::corruption;
+                creators["corruption on attacker"] = &TriggerFactoryInternal::corruption_on_attacker;
+                creators["curse of agony"] = &TriggerFactoryInternal::curse_of_agony;
+                creators["banish"] = &TriggerFactoryInternal::banish;
+                creators["spellstone"] = &TriggerFactoryInternal::spellstone;
+                creators["backlash"] = &TriggerFactoryInternal::backlash;
+                creators["fear"] = &TriggerFactoryInternal::fear;
+                creators["immolate"] = &TriggerFactoryInternal::immolate;
+
+
+            }
+
+        private:
+            static Trigger* shadow_trance(PlayerbotAI* ai) { return new ShadowTranceTrigger(ai); }
+            static Trigger* demon_armor(PlayerbotAI* ai) { return new DemonArmorTrigger(ai); }
+            static Trigger* HasHealthstone(PlayerbotAI* ai) { return new HasHealthstoneTrigger(ai); }
+            static Trigger* HasFirestone(PlayerbotAI* ai) { return new HasFirestoneTrigger(ai); }
+            static Trigger* HasSpellstone(PlayerbotAI* ai) { return new HasSpellstoneTrigger(ai); }
+            static Trigger* corruption(PlayerbotAI* ai) { return new CorruptionTrigger(ai); }
+            static Trigger* corruption_on_attacker(PlayerbotAI* ai) { return new CorruptionOnAttackerTrigger(ai); }
+            static Trigger* curse_of_agony(PlayerbotAI* ai) { return new CurseOfAgonyTrigger(ai); }
+            static Trigger* banish(PlayerbotAI* ai) { return new BanishTrigger(ai); }
+            static Trigger* spellstone(PlayerbotAI* ai) { return new SpellstoneTrigger(ai); }
+            static Trigger* backlash(PlayerbotAI* ai) { return new BacklashTrigger(ai); }
+            static Trigger* fear(PlayerbotAI* ai) { return new FearTrigger(ai); }
+            static Trigger* immolate(PlayerbotAI* ai) { return new ImmolateTrigger(ai); }
+
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warlock
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["summon imp"] = &AiObjectContextInternal::summon_imp;
+                creators["fel armor"] = &AiObjectContextInternal::fel_armor;
+                creators["demon armor"] = &AiObjectContextInternal::demon_armor;
+                creators["demon skin"] = &AiObjectContextInternal::demon_skin;
+                creators["create healthstone"] = &AiObjectContextInternal::create_healthstone;
+                creators["create firestone"] = &AiObjectContextInternal::create_firestone;
+                creators["create spellstone"] = &AiObjectContextInternal::create_spellstone;
+                creators["spellstone"] = &AiObjectContextInternal::spellstone;
+                creators["summon voidwalker"] = &AiObjectContextInternal::summon_voidwalker;
+                creators["summon felguard"] = &AiObjectContextInternal::summon_felguard;
+                creators["immolate"] = &AiObjectContextInternal::immolate;
+                creators["corruption"] = &AiObjectContextInternal::corruption;
+                creators["corruption on attacker"] = &AiObjectContextInternal::corruption_on_attacker;
+                creators["curse of agony"] = &AiObjectContextInternal::curse_of_agony;
+                creators["shadow bolt"] = &AiObjectContextInternal::shadow_bolt;
+                creators["drain soul"] = &AiObjectContextInternal::drain_soul;
+                creators["drain mana"] = &AiObjectContextInternal::drain_mana;
+                creators["drain life"] = &AiObjectContextInternal::drain_life;
+                creators["banish"] = &AiObjectContextInternal::banish;
+                creators["seed of corruption"] = &AiObjectContextInternal::seed_of_corruption;
+                creators["rain of fire"] = &AiObjectContextInternal::rain_of_fire;
+                creators["shadowfury"] = &AiObjectContextInternal::shadowfury;
+                creators["life tap"] = &AiObjectContextInternal::life_tap;
+                creators["fear"] = &AiObjectContextInternal::fear;
+                creators["fear on cc"] = &AiObjectContextInternal::fear_on_cc;
+                creators["incinirate"] = &AiObjectContextInternal::incinirate;
+                creators["conflagrate"] = &AiObjectContextInternal::conflagrate;
+            }
+
+        private:
+            static Action* conflagrate(PlayerbotAI* ai) { return new CastConflagrateAction(ai); }
+            static Action* incinirate(PlayerbotAI* ai) { return new CastIncinirateAction(ai); }
+            static Action* fear_on_cc(PlayerbotAI* ai) { return new CastFearOnCcAction(ai); }
+            static Action* fear(PlayerbotAI* ai) { return new CastFearAction(ai); }
+            static Action* immolate(PlayerbotAI* ai) { return new CastImmolateAction(ai); }
+            static Action* summon_imp(PlayerbotAI* ai) { return new CastSummonImpAction(ai); }
+            static Action* fel_armor(PlayerbotAI* ai) { return new CastFelArmorAction(ai); }
+            static Action* demon_armor(PlayerbotAI* ai) { return new CastDemonArmorAction(ai); }
+            static Action* demon_skin(PlayerbotAI* ai) { return new CastDemonSkinAction(ai); }
+            static Action* create_healthstone(PlayerbotAI* ai) { return new CastCreateHealthstoneAction(ai); }
+            static Action* create_firestone(PlayerbotAI* ai) { return new CastCreateFirestoneAction(ai); }
+            static Action* create_spellstone(PlayerbotAI* ai) { return new CastCreateSpellstoneAction(ai); }
+            static Action* spellstone(PlayerbotAI* ai) { return new UseSpellItemAction(ai, "spellstone", true); }
+            static Action* summon_voidwalker(PlayerbotAI* ai) { return new CastSummonVoidwalkerAction(ai); }
+            static Action* summon_felguard(PlayerbotAI* ai) { return new CastSummonFelguardAction(ai); }
+            static Action* corruption(PlayerbotAI* ai) { return new CastCorruptionAction(ai); }
+            static Action* corruption_on_attacker(PlayerbotAI* ai) { return new CastCorruptionOnAttackerAction(ai); }
+            static Action* curse_of_agony(PlayerbotAI* ai) { return new CastCurseOfAgonyAction(ai); }
+            static Action* shadow_bolt(PlayerbotAI* ai) { return new CastShadowBoltAction(ai); }
+            static Action* drain_soul(PlayerbotAI* ai) { return new CastDrainSoulAction(ai); }
+            static Action* drain_mana(PlayerbotAI* ai) { return new CastDrainManaAction(ai); }
+            static Action* drain_life(PlayerbotAI* ai) { return new CastDrainLifeAction(ai); }
+            static Action* banish(PlayerbotAI* ai) { return new CastBanishAction(ai); }
+            static Action* seed_of_corruption(PlayerbotAI* ai) { return new CastSeedOfCorruptionAction(ai); }
+            static Action* rain_of_fire(PlayerbotAI* ai) { return new CastRainOfFireAction(ai); }
+            static Action* shadowfury(PlayerbotAI* ai) { return new CastShadowfuryAction(ai); }
+            static Action* life_tap(PlayerbotAI* ai) { return new CastLifeTapAction(ai); }
+
+        };
+    };
+};
+
+
+
+WarlockAiObjectContext::WarlockAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warlock::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warlock::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warlock::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warlock::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
new file mode 100644
index 0000000..0d3fa27
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarlockAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarlockAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
new file mode 100644
index 0000000..a75926a
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockMultipliers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
new file mode 100644
index 0000000..660e584
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.cpp
@@ -0,0 +1,19 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarlockTriggers.h"
+#include "WarlockActions.h"
+
+using namespace ai;
+
+bool DemonArmorTrigger::IsActive() 
+{
+	Unit* target = GetTarget();
+	return !ai->HasAura("demon skin", target) &&
+		!ai->HasAura("demon armor", target) &&
+		!ai->HasAura("fel armor", target);
+}
+
+bool SpellstoneTrigger::IsActive() 
+{
+    return BuffTrigger::IsActive() && AI_VALUE2(uint8, "item count", getName()) > 0;
+}
diff --git a/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
new file mode 100644
index 0000000..796f884
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warlock/WarlockTriggers.h
@@ -0,0 +1,81 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+	class DemonArmorTrigger : public BuffTrigger
+	{
+	public:
+		DemonArmorTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "demon armor") {}
+		virtual bool IsActive();
+	};
+
+    class SpellstoneTrigger : public BuffTrigger
+    {
+    public:
+        SpellstoneTrigger(PlayerbotAI* ai) : BuffTrigger(ai, "spellstone") {}
+        virtual bool IsActive();
+    };
+
+    DEBUFF_TRIGGER(CurseOfAgonyTrigger, "curse of agony", "curse of agony");
+    DEBUFF_TRIGGER(CorruptionTrigger, "corruption", "corruption");
+
+    class CorruptionOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        CorruptionOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "corruption") {}
+    };
+
+    DEBUFF_TRIGGER(ImmolateTrigger, "immolate", "immolate");
+
+    class ShadowTranceTrigger : public HasAuraTrigger
+    {
+    public:
+        ShadowTranceTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "shadow trance") {}
+    };
+
+    class BacklashTrigger : public HasAuraTrigger
+    {
+    public:
+        BacklashTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "backlash") {}
+    };
+
+    class BanishTrigger : public HasCcTargetTrigger
+    {
+    public:
+        BanishTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "banish") {}
+    };
+
+    class WarlockConjuredItemTrigger : public ItemCountTrigger
+    {
+    public:
+        WarlockConjuredItemTrigger(PlayerbotAI* ai, string item) : ItemCountTrigger(ai, item, 1) {}
+
+        virtual bool IsActive() { return ItemCountTrigger::IsActive() && AI_VALUE2(uint8, "item count", "soul shard") > 0; }
+    };
+
+    class HasSpellstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasSpellstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "spellstone") {}
+    };
+
+    class HasFirestoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasFirestoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "firestone") {}
+    };
+
+    class HasHealthstoneTrigger : public WarlockConjuredItemTrigger
+    {
+    public:
+        HasHealthstoneTrigger(PlayerbotAI* ai) : WarlockConjuredItemTrigger(ai, "healthstone") {}
+    };
+
+    class FearTrigger : public HasCcTargetTrigger
+    {
+    public:
+        FearTrigger(PlayerbotAI* ai) : HasCcTargetTrigger(ai, "fear") {}
+    };
+
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
new file mode 100644
index 0000000..7b13bec
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.cpp
@@ -0,0 +1,130 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "DpsWarriorStrategy.h"
+
+using namespace ai;
+
+class DpsWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    DpsWarriorStrategyActionNodeFactory()
+    {
+        creators["overpower"] = &overpower;
+        creators["melee"] = &melee;
+        creators["charge"] = &charge;
+        creators["bloodthirst"] = &bloodthirst;
+        creators["rend"] = &rend;
+        creators["mocking blow"] = &mocking_blow;
+        creators["death wish"] = &death_wish;
+        creators["execute"] = &execute;
+    }
+private:
+    static ActionNode* overpower(PlayerbotAI* ai)
+    {
+        return new ActionNode ("overpower",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("charge"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* charge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("charge",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("reach melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* bloodthirst(PlayerbotAI* ai)
+    {
+        return new ActionNode ("bloodthirst",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* mocking_blow(PlayerbotAI* ai)
+    {
+        return new ActionNode ("mocking blow",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* death_wish(PlayerbotAI* ai)
+    {
+        return new ActionNode ("death wish",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("berserker rage"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* execute(PlayerbotAI* ai)
+    {
+        return new ActionNode ("execute",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NextAction::array(0, new NextAction("heroic strike"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+DpsWarriorStrategy::DpsWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new DpsWarriorStrategyActionNodeFactory());
+}
+
+NextAction** DpsWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("bloodthirst", ACTION_NORMAL + 1), NULL);
+}
+
+void DpsWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "enemy out of melee",
+        NextAction::array(0, new NextAction("charge", ACTION_NORMAL + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "target critical health",
+        NextAction::array(0, new NextAction("execute", ACTION_HIGH + 4), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"hamstring",
+		NextAction::array(0, new NextAction("hamstring", ACTION_INTERRUPT), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"victory rush",
+		NextAction::array(0, new NextAction("victory rush", ACTION_HIGH + 3), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "death wish",
+        NextAction::array(0, new NextAction("death wish", ACTION_HIGH + 2), NULL)));
+}
+
+
+void DpsWarrirorAoeStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    triggers.push_back(new TriggerNode(
+        "rend on attacker",
+        NextAction::array(0, new NextAction("rend on attacker", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium aoe",
+        NextAction::array(0, new NextAction("cleave", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
new file mode 100644
index 0000000..3ef29c3
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/DpsWarriorStrategy.h
@@ -0,0 +1,28 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class DpsWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        DpsWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "dps"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_COMBAT | STRATEGY_TYPE_DPS | STRATEGY_TYPE_MELEE; }
+    };
+
+    class DpsWarrirorAoeStrategy : public CombatStrategy
+    {
+    public:
+        DpsWarrirorAoeStrategy(PlayerbotAI* ai) : CombatStrategy(ai) {}
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "aoe"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
new file mode 100644
index 0000000..6bd7d08
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "GenericWarriorNonCombatStrategy.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
new file mode 100644
index 0000000..1041a2e
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorNonCombatStrategy.h
@@ -0,0 +1,13 @@
+#pragma once
+
+#include "../generic/NonCombatStrategy.h"
+
+namespace ai
+{
+    class GenericWarriorNonCombatStrategy : public NonCombatStrategy
+    {
+    public:
+        GenericWarriorNonCombatStrategy(PlayerbotAI* ai) : NonCombatStrategy(ai) {}
+        virtual string getName() { return "nc"; }
+   };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
new file mode 100644
index 0000000..4d7b851
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.cpp
@@ -0,0 +1,73 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "GenericWarriorStrategy.h"
+#include "WarriorAiObjectContext.h"
+
+using namespace ai;
+
+class GenericWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    GenericWarriorStrategyActionNodeFactory()
+    {
+        creators["hamstring"] = &hamstring;
+        creators["heroic strike"] = &heroic_strike;
+        creators["battle shout"] = &battle_shout;
+    }
+private:
+    static ActionNode* hamstring(PlayerbotAI* ai)
+    {
+        return new ActionNode ("hamstring",
+            /*P*/ NextAction::array(0, new NextAction("battle stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* heroic_strike(PlayerbotAI* ai)
+    {
+        return new ActionNode ("heroic strike",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* battle_shout(PlayerbotAI* ai)
+    {
+        return new ActionNode ("battle shout",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+GenericWarriorStrategy::GenericWarriorStrategy(PlayerbotAI* ai) : MeleeCombatStrategy(ai)
+{
+    actionNodeFactories.Add(new GenericWarriorStrategyActionNodeFactory());
+}
+
+void GenericWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    MeleeCombatStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "battle shout",
+        NextAction::array(0, new NextAction("battle shout", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "rend",
+        NextAction::array(0, new NextAction("rend", ACTION_NORMAL + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "bloodrage",
+        NextAction::array(0, new NextAction("bloodrage", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash",
+        NextAction::array(0, new NextAction("shield bash", ACTION_INTERRUPT + 4), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "shield bash on enemy healer",
+        NextAction::array(0, new NextAction("shield bash on enemy healer", ACTION_INTERRUPT + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("intimidating shout", ACTION_EMERGENCY), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
new file mode 100644
index 0000000..0ef2dcf
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/GenericWarriorStrategy.h
@@ -0,0 +1,19 @@
+#pragma once
+
+#include "../Strategy.h"
+#include "../generic/MeleeCombatStrategy.h"
+
+namespace ai
+{
+    class AiObjectContext;
+
+    class GenericWarriorStrategy : public MeleeCombatStrategy
+    {
+    public:
+        GenericWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "warrior"; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
new file mode 100644
index 0000000..5bf206c
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.cpp
@@ -0,0 +1,126 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "TankWarriorStrategy.h"
+
+using namespace ai;
+
+class TankWarriorStrategyActionNodeFactory : public NamedObjectFactory<ActionNode>
+{
+public:
+    TankWarriorStrategyActionNodeFactory()
+    {
+        creators["melee"] = &melee;
+        creators["shield wall"] = &shield_wall;
+        creators["rend"] = &rend;
+        creators["revenge"] = &revenge;
+        creators["devastate"] = &devastate;
+        creators["shockwave"] = &shockwave;
+        creators["taunt"] = &taunt;
+    }
+private:
+    static ActionNode* melee(PlayerbotAI* ai)
+    {
+        return new ActionNode ("melee",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), new NextAction("reach melee"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* shield_wall(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shield wall",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("shield block"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* rend(PlayerbotAI* ai)
+    {
+        return new ActionNode ("rend",
+            /*P*/ NextAction::array(0, new NextAction("defensive stance"), NULL),
+            /*A*/ NULL,
+            /*C*/ NULL);
+    }
+    static ActionNode* revenge(PlayerbotAI* ai)
+    {
+        return new ActionNode ("revenge",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("melee"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* devastate(PlayerbotAI* ai)
+    {
+        return new ActionNode ("devastate",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("sunder armor"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* shockwave(PlayerbotAI* ai)
+    {
+        return new ActionNode ("shockwave",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("cleave"), NULL),
+            /*C*/ NULL);
+    }
+    static ActionNode* taunt(PlayerbotAI* ai)
+    {
+        return new ActionNode ("taunt",
+            /*P*/ NULL,
+            /*A*/ NextAction::array(0, new NextAction("mocking blow"), NULL),
+            /*C*/ NULL);
+    }
+};
+
+TankWarriorStrategy::TankWarriorStrategy(PlayerbotAI* ai) : GenericWarriorStrategy(ai)
+{
+    actionNodeFactories.Add(new TankWarriorStrategyActionNodeFactory());
+}
+
+NextAction** TankWarriorStrategy::getDefaultActions()
+{
+    return NextAction::array(0, new NextAction("devastate", ACTION_NORMAL + 1), new NextAction("revenge", ACTION_NORMAL + 1), NULL);
+}
+
+void TankWarriorStrategy::InitTriggers(std::list<TriggerNode*> &triggers)
+{
+    GenericWarriorStrategy::InitTriggers(triggers);
+
+    triggers.push_back(new TriggerNode(
+        "medium rage available",
+        NextAction::array(0, new NextAction("shield slam", ACTION_NORMAL + 2), new NextAction("heroic strike", ACTION_NORMAL + 2), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "disarm",
+        NextAction::array(0, new NextAction("disarm", ACTION_NORMAL), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "lose aggro",
+        NextAction::array(0, new NextAction("taunt", ACTION_HIGH + 9), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "medium health",
+        NextAction::array(0, new NextAction("shield wall", ACTION_MEDIUM_HEAL), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"critical health",
+		NextAction::array(0, new NextAction("last stand", ACTION_EMERGENCY + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"medium aoe",
+		NextAction::array(0, new NextAction("shockwave", ACTION_HIGH + 2), NULL)));
+
+	triggers.push_back(new TriggerNode(
+        "light aoe",
+        NextAction::array(0, new NextAction("thunder clap", ACTION_HIGH + 2), new NextAction("demoralizing shout", ACTION_HIGH + 2),  new NextAction("cleave", ACTION_HIGH + 1), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "high aoe",
+        NextAction::array(0, new NextAction("challenging shout", ACTION_HIGH + 3), NULL)));
+
+	triggers.push_back(new TriggerNode(
+		"concussion blow",
+		NextAction::array(0, new NextAction("concussion blow", ACTION_INTERRUPT), NULL)));
+
+    triggers.push_back(new TriggerNode(
+        "sword and board",
+        NextAction::array(0, new NextAction("shield slam", ACTION_HIGH + 3), NULL)));
+}
diff --git a/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
new file mode 100644
index 0000000..0f98946
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/TankWarriorStrategy.h
@@ -0,0 +1,18 @@
+#pragma once
+
+#include "GenericWarriorStrategy.h"
+
+namespace ai
+{
+    class TankWarriorStrategy : public GenericWarriorStrategy
+    {
+    public:
+        TankWarriorStrategy(PlayerbotAI* ai);
+
+    public:
+        virtual void InitTriggers(std::list<TriggerNode*> &triggers);
+        virtual string getName() { return "tank"; }
+        virtual NextAction** getDefaultActions();
+        virtual int GetType() { return STRATEGY_TYPE_TANK | STRATEGY_TYPE_MELEE; }
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
new file mode 100644
index 0000000..b6d44fe
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.cpp
@@ -0,0 +1,30 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
+NextAction** CastRendAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRendOnAttackerAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellOnAttackerAction::getPrerequisites());
+}
+
+NextAction** CastDisarmAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), new NextAction("defensive stance"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastSunderArmorAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("reach melee"), NULL), CastDebuffSpellAction::getPrerequisites());
+}
+
+NextAction** CastRevengeAction::getPrerequisites()
+{
+    return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorActions.h b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
new file mode 100644
index 0000000..65ac0ae
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorActions.h
@@ -0,0 +1,210 @@
+#pragma once
+#include "../actions/GenericActions.h"
+
+namespace ai
+{
+    // battle
+    class CastBattleMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastBattleMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("battle stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastDefensiveMeleeSpellAction : public CastMeleeSpellAction {
+    public:
+        CastDefensiveMeleeSpellAction(PlayerbotAI* ai, string spell) : CastMeleeSpellAction(ai, spell) {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastMeleeSpellAction::getPrerequisites());
+        }
+    };
+
+    // all
+    class CastHeroicStrikeAction : public CastMeleeSpellAction {
+    public:
+        CastHeroicStrikeAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "heroic strike") {}
+    };
+
+    // all
+    class CastCleaveAction : public CastMeleeSpellAction {
+    public:
+        CastCleaveAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "cleave") {}
+    };
+
+    // battle, berserker
+    class CastMockingBlowAction : public CastMeleeSpellAction {
+    public:
+        CastMockingBlowAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "mocking blow") {}
+    };
+
+    class CastBloodthirstAction : public CastMeleeSpellAction {
+    public:
+        CastBloodthirstAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "bloodthirst") {}
+    };
+
+    // battle, berserker
+    class CastExecuteAction : public CastMeleeSpellAction {
+    public:
+        CastExecuteAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "execute") {}
+    };
+
+    // battle
+    class CastOverpowerAction : public CastBattleMeleeSpellAction {
+    public:
+        CastOverpowerAction(PlayerbotAI* ai) : CastBattleMeleeSpellAction(ai, "overpower") {}
+    };
+
+    // battle, berserker
+    class CastHamstringAction : public CastMeleeSpellAction {
+    public:
+        CastHamstringAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "hamstring") {}
+    };
+
+    // defensive
+    class CastTauntAction : public CastSpellAction {
+    public:
+        CastTauntAction(PlayerbotAI* ai) : CastSpellAction(ai, "taunt") {}
+        virtual NextAction** getPrerequisites() {
+            return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+        }
+    };
+
+    // defensive
+    class CastShieldBlockAction : public CastBuffSpellAction {
+    public:
+        CastShieldBlockAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "shield block") {}
+		virtual NextAction** getPrerequisites() {
+			return NextAction::merge( NextAction::array(0, new NextAction("defensive stance"), NULL), CastSpellAction::getPrerequisites());
+		}
+    };
+
+    // defensive
+    class CastShieldWallAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastShieldWallAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shield wall") {}
+    };
+
+    class CastBloodrageAction : public CastBuffSpellAction {
+    public:
+        CastBloodrageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "bloodrage") {}
+    };
+
+    // defensive
+    class CastDevastateAction : public CastDefensiveMeleeSpellAction {
+    public:
+        CastDevastateAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "devastate") {}
+    };
+
+    // all
+    class CastSlamAction : public CastMeleeSpellAction {
+    public:
+        CastSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "slam") {}
+    };
+
+	// all
+	class CastShieldSlamAction : public CastMeleeSpellAction {
+	public:
+		CastShieldSlamAction(PlayerbotAI* ai) : CastMeleeSpellAction(ai, "shield slam") {}
+	};
+
+    // after dodge
+    BEGIN_MELEE_SPELL_ACTION(CastRevengeAction, "revenge")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+
+    //debuffs
+    BEGIN_DEBUFF_ACTION(CastRendAction, "rend")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastRendOnAttackerAction : public CastDebuffSpellOnAttackerAction
+    {
+    public:
+        CastRendOnAttackerAction(PlayerbotAI* ai) : CastDebuffSpellOnAttackerAction(ai, "rend") {}
+        virtual NextAction** getPrerequisites();
+    };
+
+    BEGIN_DEBUFF_ACTION(CastDisarmAction, "disarm")
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    BEGIN_DEBUFF_ACTION(CastSunderArmorAction, "sunder armor") // 5 times
+        virtual NextAction** getPrerequisites();
+    END_SPELL_ACTION()
+
+    class CastDemoralizingShoutAction : public CastDebuffSpellAction {
+    public:
+        CastDemoralizingShoutAction(PlayerbotAI* ai) : CastDebuffSpellAction(ai, "demoralizing shout") {}
+    };
+
+    BEGIN_MELEE_SPELL_ACTION(CastChallengingShoutAction, "challenging shout")
+    END_SPELL_ACTION()
+
+    // stuns
+    BEGIN_MELEE_SPELL_ACTION(CastShieldBashAction, "shield bash")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastIntimidatingShoutAction, "intimidating shout")
+    END_SPELL_ACTION()
+
+    BEGIN_MELEE_SPELL_ACTION(CastThunderClapAction, "thunder clap")
+    END_SPELL_ACTION()
+
+    // buffs
+	class CastBattleShoutAction : public CastBuffSpellAction {
+	public:
+		CastBattleShoutAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle shout") {}
+	};
+
+	class CastDefensiveStanceAction : public CastBuffSpellAction {
+	public:
+		CastDefensiveStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "defensive stance") {}
+	};
+
+	class CastBattleStanceAction : public CastBuffSpellAction {
+	public:
+		CastBattleStanceAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "battle stance") {}
+	};
+
+    BEGIN_RANGED_SPELL_ACTION(CastChargeAction, "charge")
+    END_SPELL_ACTION()
+
+	class CastDeathWishAction : public CastBuffSpellAction {
+	public:
+		CastDeathWishAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "death wish") {}
+	};
+
+	class CastBerserkerRageAction : public CastBuffSpellAction {
+	public:
+		CastBerserkerRageAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "berserker rage") {}
+	};
+
+	class CastLastStandAction : public CastBuffSpellAction {
+	public:
+		CastLastStandAction(PlayerbotAI* ai) : CastBuffSpellAction(ai, "last stand") {}
+	};
+
+	// defensive
+	class CastShockwaveAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastShockwaveAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "shockwave") {}
+	};
+
+	// defensive
+	class CastConcussionBlowAction : public CastDefensiveMeleeSpellAction {
+	public:
+		CastConcussionBlowAction(PlayerbotAI* ai) : CastDefensiveMeleeSpellAction(ai, "concussion blow") {}
+	};
+
+	BEGIN_MELEE_SPELL_ACTION(CastVictoryRushAction, "victory rush")
+	END_SPELL_ACTION()
+
+    class CastShieldBashOnEnemyHealerAction : public CastSpellOnEnemyHealerAction
+    {
+    public:
+        CastShieldBashOnEnemyHealerAction(PlayerbotAI* ai) : CastSpellOnEnemyHealerAction(ai, "shield bash") {}
+    };
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
new file mode 100644
index 0000000..bc74075
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.cpp
@@ -0,0 +1,192 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorActions.h"
+#include "WarriorAiObjectContext.h"
+#include "GenericWarriorNonCombatStrategy.h"
+#include "TankWarriorStrategy.h"
+#include "DpsWarriorStrategy.h"
+#include "../generic/PullStrategy.h"
+#include "WarriorTriggers.h"
+#include "../NamedObjectContext.h"
+
+using namespace ai;
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class StrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            StrategyFactoryInternal()
+            {
+                creators["nc"] = &warrior::StrategyFactoryInternal::nc;
+                creators["pull"] = &warrior::StrategyFactoryInternal::pull;
+                creators["aoe"] = &warrior::StrategyFactoryInternal::aoe;
+            }
+
+        private:
+            static Strategy* nc(PlayerbotAI* ai) { return new GenericWarriorNonCombatStrategy(ai); }
+            static Strategy* aoe(PlayerbotAI* ai) { return new DpsWarrirorAoeStrategy(ai); }
+            static Strategy* pull(PlayerbotAI* ai) { return new PullStrategy(ai, "shoot"); }
+        };
+
+        class CombatStrategyFactoryInternal : public NamedObjectContext<Strategy>
+        {
+        public:
+            CombatStrategyFactoryInternal() : NamedObjectContext<Strategy>(false, true)
+            {
+                creators["tank"] = &warrior::CombatStrategyFactoryInternal::tank;
+                creators["dps"] = &warrior::CombatStrategyFactoryInternal::dps;
+            }
+
+        private:
+            static Strategy* tank(PlayerbotAI* ai) { return new TankWarriorStrategy(ai); }
+            static Strategy* dps(PlayerbotAI* ai) { return new DpsWarriorStrategy(ai); }
+        };
+    };
+};
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class TriggerFactoryInternal : public NamedObjectContext<Trigger>
+        {
+        public:
+            TriggerFactoryInternal()
+            {
+                creators["hamstring"] = &TriggerFactoryInternal::hamstring;
+                creators["victory rush"] = &TriggerFactoryInternal::victory_rush;
+                creators["death wish"] = &TriggerFactoryInternal::death_wish;
+                creators["battle shout"] = &TriggerFactoryInternal::battle_shout;
+                creators["rend"] = &TriggerFactoryInternal::rend;
+                creators["rend on attacker"] = &TriggerFactoryInternal::rend_on_attacker;
+                creators["bloodrage"] = &TriggerFactoryInternal::bloodrage;
+                creators["shield bash"] = &TriggerFactoryInternal::shield_bash;
+                creators["disarm"] = &TriggerFactoryInternal::disarm;
+                creators["concussion blow"] = &TriggerFactoryInternal::concussion_blow;
+                creators["sword and board"] = &TriggerFactoryInternal::SwordAndBoard;
+                creators["shield bash on enemy healer"] = &TriggerFactoryInternal::shield_bash_on_enemy_healer;
+
+            }
+
+        private:
+            static Trigger* hamstring(PlayerbotAI* ai) { return new HamstringTrigger(ai); }
+            static Trigger* victory_rush(PlayerbotAI* ai) { return new VictoryRushTrigger(ai); }
+            static Trigger* death_wish(PlayerbotAI* ai) { return new DeathWishTrigger(ai); }
+            static Trigger* battle_shout(PlayerbotAI* ai) { return new BattleShoutTrigger(ai); }
+            static Trigger* rend(PlayerbotAI* ai) { return new RendDebuffTrigger(ai); }
+            static Trigger* rend_on_attacker(PlayerbotAI* ai) { return new RendDebuffOnAttackerTrigger(ai); }
+            static Trigger* bloodrage(PlayerbotAI* ai) { return new BloodrageDebuffTrigger(ai); }
+            static Trigger* shield_bash(PlayerbotAI* ai) { return new ShieldBashInterruptSpellTrigger(ai); }
+            static Trigger* disarm(PlayerbotAI* ai) { return new DisarmDebuffTrigger(ai); }
+            static Trigger* concussion_blow(PlayerbotAI* ai) { return new ConcussionBlowTrigger(ai); }
+            static Trigger* SwordAndBoard(PlayerbotAI* ai) { return new SwordAndBoardTrigger(ai); }
+            static Trigger* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new ShieldBashInterruptEnemyHealerSpellTrigger(ai); }
+        };
+    };
+};
+
+
+namespace ai
+{
+    namespace warrior
+    {
+        using namespace ai;
+
+        class AiObjectContextInternal : public NamedObjectContext<Action>
+        {
+        public:
+            AiObjectContextInternal()
+            {
+                creators["devastate"] = &AiObjectContextInternal::devastate;
+                creators["overpower"] = &AiObjectContextInternal::overpower;
+                creators["charge"] = &AiObjectContextInternal::charge;
+                creators["bloodthirst"] = &AiObjectContextInternal::bloodthirst;
+                creators["rend"] = &AiObjectContextInternal::rend;
+                creators["rend on attacker"] = &AiObjectContextInternal::rend_on_attacker;
+                creators["mocking blow"] = &AiObjectContextInternal::mocking_blow;
+                creators["death wish"] = &AiObjectContextInternal::death_wish;
+                creators["berserker rage"] = &AiObjectContextInternal::berserker_rage;
+                creators["victory rush"] = &AiObjectContextInternal::victory_rush;
+                creators["execute"] = &AiObjectContextInternal::execute;
+                creators["defensive stance"] = &AiObjectContextInternal::defensive_stance;
+                creators["hamstring"] = &AiObjectContextInternal::hamstring;
+                creators["shield bash"] = &AiObjectContextInternal::shield_bash;
+                creators["shield block"] = &AiObjectContextInternal::shield_block;
+                creators["bloodrage"] = &AiObjectContextInternal::bloodrage;
+                creators["battle stance"] = &AiObjectContextInternal::battle_stance;
+                creators["heroic strike"] = &AiObjectContextInternal::heroic_strike;
+                creators["intimidating shout"] = &AiObjectContextInternal::intimidating_shout;
+                creators["demoralizing shout"] = &AiObjectContextInternal::demoralizing_shout;
+                creators["challenging shout"] = &AiObjectContextInternal::challenging_shout;
+                creators["shield wall"] = &AiObjectContextInternal::shield_wall;
+                creators["battle shout"] = &AiObjectContextInternal::battle_shout;
+                creators["thunder clap"] = &AiObjectContextInternal::thunder_clap;
+                creators["taunt"] = &AiObjectContextInternal::taunt;
+                creators["revenge"] = &AiObjectContextInternal::revenge;
+                creators["slam"] = &AiObjectContextInternal::slam;
+                creators["shield slam"] = &AiObjectContextInternal::shield_slam;
+                creators["disarm"] = &AiObjectContextInternal::disarm;
+                creators["sunder armor"] = &AiObjectContextInternal::sunder_armor;
+                creators["last stand"] = &AiObjectContextInternal::last_stand;
+                creators["shockwave"] = &AiObjectContextInternal::shockwave;
+                creators["cleave"] = &AiObjectContextInternal::cleave;
+                creators["concussion blow"] = &AiObjectContextInternal::concussion_blow;
+                creators["shield bash on enemy healer"] = &AiObjectContextInternal::shield_bash_on_enemy_healer;
+            }
+
+        private:
+            static Action* devastate(PlayerbotAI* ai) { return new CastDevastateAction(ai); }
+            static Action* last_stand(PlayerbotAI* ai) { return new CastLastStandAction(ai); }
+            static Action* shockwave(PlayerbotAI* ai) { return new CastShockwaveAction(ai); }
+            static Action* cleave(PlayerbotAI* ai) { return new CastCleaveAction(ai); }
+            static Action* concussion_blow(PlayerbotAI* ai) { return new CastConcussionBlowAction(ai); }
+            static Action* taunt(PlayerbotAI* ai) { return new CastTauntAction(ai); }
+            static Action* revenge(PlayerbotAI* ai) { return new CastRevengeAction(ai); }
+            static Action* slam(PlayerbotAI* ai) { return new CastSlamAction(ai); }
+            static Action* shield_slam(PlayerbotAI* ai) { return new CastShieldSlamAction(ai); }
+            static Action* disarm(PlayerbotAI* ai) { return new CastDisarmAction(ai); }
+            static Action* sunder_armor(PlayerbotAI* ai) { return new CastSunderArmorAction(ai); }
+            static Action* overpower(PlayerbotAI* ai) { return new CastOverpowerAction(ai); }
+            static Action* charge(PlayerbotAI* ai) { return new CastChargeAction(ai); }
+            static Action* bloodthirst(PlayerbotAI* ai) { return new CastBloodthirstAction(ai); }
+            static Action* rend(PlayerbotAI* ai) { return new CastRendAction(ai); }
+            static Action* rend_on_attacker(PlayerbotAI* ai) { return new CastRendOnAttackerAction(ai); }
+            static Action* mocking_blow(PlayerbotAI* ai) { return new CastMockingBlowAction(ai); }
+            static Action* death_wish(PlayerbotAI* ai) { return new CastDeathWishAction(ai); }
+            static Action* berserker_rage(PlayerbotAI* ai) { return new CastBerserkerRageAction(ai); }
+            static Action* victory_rush(PlayerbotAI* ai) { return new CastVictoryRushAction(ai); }
+            static Action* execute(PlayerbotAI* ai) { return new CastExecuteAction(ai); }
+            static Action* defensive_stance(PlayerbotAI* ai) { return new CastDefensiveStanceAction(ai); }
+            static Action* hamstring(PlayerbotAI* ai) { return new CastHamstringAction(ai); }
+            static Action* shield_bash(PlayerbotAI* ai) { return new CastShieldBashAction(ai); }
+            static Action* shield_block(PlayerbotAI* ai) { return new CastShieldBlockAction(ai); }
+            static Action* bloodrage(PlayerbotAI* ai) { return new CastBloodrageAction(ai); }
+            static Action* battle_stance(PlayerbotAI* ai) { return new CastBattleStanceAction(ai); }
+            static Action* heroic_strike(PlayerbotAI* ai) { return new CastHeroicStrikeAction(ai); }
+            static Action* intimidating_shout(PlayerbotAI* ai) { return new CastIntimidatingShoutAction(ai); }
+            static Action* demoralizing_shout(PlayerbotAI* ai) { return new CastDemoralizingShoutAction(ai); }
+            static Action* challenging_shout(PlayerbotAI* ai) { return new CastChallengingShoutAction(ai); }
+            static Action* shield_wall(PlayerbotAI* ai) { return new CastShieldWallAction(ai); }
+            static Action* battle_shout(PlayerbotAI* ai) { return new CastBattleShoutAction(ai); }
+            static Action* thunder_clap(PlayerbotAI* ai) { return new CastThunderClapAction(ai); }
+            static Action* shield_bash_on_enemy_healer(PlayerbotAI* ai) { return new CastShieldBashOnEnemyHealerAction(ai); }
+
+        };
+    };
+};
+
+WarriorAiObjectContext::WarriorAiObjectContext(PlayerbotAI* ai) : AiObjectContext(ai)
+{
+    strategyContexts.Add(new ai::warrior::StrategyFactoryInternal());
+    strategyContexts.Add(new ai::warrior::CombatStrategyFactoryInternal());
+    actionContexts.Add(new ai::warrior::AiObjectContextInternal());
+    triggerContexts.Add(new ai::warrior::TriggerFactoryInternal());
+}
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
new file mode 100644
index 0000000..bc1b5d4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorAiObjectContext.h
@@ -0,0 +1,12 @@
+#pragma once
+
+#include "../AiObjectContext.h"
+
+namespace ai
+{
+    class WarriorAiObjectContext : public AiObjectContext
+    {
+    public:
+        WarriorAiObjectContext(PlayerbotAI* ai);
+    };
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
new file mode 100644
index 0000000..0698aa1
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.cpp
@@ -0,0 +1,6 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorMultipliers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
new file mode 100644
index 0000000..7cfbdd4
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorMultipliers.h
@@ -0,0 +1,6 @@
+#pragma once
+
+namespace ai
+{
+   
+}
\ No newline at end of file
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
new file mode 100644
index 0000000..0b8d183
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.cpp
@@ -0,0 +1,7 @@
+#include "../../../pchdef.h"
+#include "../../playerbot.h"
+#include "WarriorTriggers.h"
+#include "WarriorActions.h"
+
+using namespace ai;
+
diff --git a/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
new file mode 100644
index 0000000..72a1285
--- /dev/null
+++ b/src/plugins/playerbot/strategy/warrior/WarriorTriggers.h
@@ -0,0 +1,78 @@
+#pragma once
+#include "../triggers/GenericTriggers.h"
+
+namespace ai
+{
+    BUFF_TRIGGER(BattleShoutTrigger, "battle shout", "battle shout")
+
+    DEBUFF_TRIGGER(RendDebuffTrigger, "rend", "rend")
+    DEBUFF_TRIGGER(DisarmDebuffTrigger, "disarm", "disarm")
+    DEBUFF_TRIGGER(SunderArmorDebuffTrigger, "sunder armor", "sunder armor")
+
+    class RendDebuffOnAttackerTrigger : public DebuffOnAttackerTrigger
+    {
+    public:
+        RendDebuffOnAttackerTrigger(PlayerbotAI* ai) : DebuffOnAttackerTrigger(ai, "rend") {}
+    };
+
+	class RevengeAvailableTrigger : public SpellCanBeCastTrigger
+	{
+	public:
+		RevengeAvailableTrigger(PlayerbotAI* ai) : SpellCanBeCastTrigger(ai, "revenge") {}
+	};
+
+    class BloodrageDebuffTrigger : public DebuffTrigger
+    {
+    public:
+        BloodrageDebuffTrigger(PlayerbotAI* ai) : DebuffTrigger(ai, "bloodrage") {}
+        virtual bool IsActive()
+        {
+            return DebuffTrigger::IsActive() &&
+                AI_VALUE2(uint8, "health", "self target") >= 75 &&
+                AI_VALUE2(uint8, "rage", "self target") < 20;
+        }
+    };
+
+    class ShieldBashInterruptSpellTrigger : public InterruptSpellTrigger
+    {
+    public:
+        ShieldBashInterruptSpellTrigger(PlayerbotAI* ai) : InterruptSpellTrigger(ai, "shield bash") {}
+    };
+
+    class VictoryRushTrigger : public HasAuraTrigger
+    {
+    public:
+        VictoryRushTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "victory rush") {}
+    };
+
+    class SwordAndBoardTrigger : public HasAuraTrigger
+    {
+    public:
+        SwordAndBoardTrigger(PlayerbotAI* ai) : HasAuraTrigger(ai, "sword and board") {}
+    };
+
+    class ConcussionBlowTrigger : public SnareTargetTrigger
+    {
+    public:
+        ConcussionBlowTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "concussion blow") {}
+    };
+
+    class HamstringTrigger : public SnareTargetTrigger
+    {
+    public:
+        HamstringTrigger(PlayerbotAI* ai) : SnareTargetTrigger(ai, "hamstring") {}
+    };
+
+    class DeathWishTrigger : public BoostTrigger
+    {
+    public:
+        DeathWishTrigger(PlayerbotAI* ai) : BoostTrigger(ai, "death wish") {}
+    };
+
+    class ShieldBashInterruptEnemyHealerSpellTrigger : public InterruptEnemyHealerTrigger
+    {
+    public:
+        ShieldBashInterruptEnemyHealerSpellTrigger(PlayerbotAI* ai) : InterruptEnemyHealerTrigger(ai, "shield bash") {}
+    };
+
+}
diff --git a/src/server/database/Database/DatabaseWorkerPool.h b/src/server/database/Database/DatabaseWorkerPool.h
index 32837da..7f4c61a 100644
--- a/src/server/database/Database/DatabaseWorkerPool.h
+++ b/src/server/database/Database/DatabaseWorkerPool.h
@@ -30,7 +30,11 @@
 #include "AdhocStatement.h"
 #include "StringFormat.h"
 
+#ifdef _WIN32
 #include <mysqld_error.h>
+#else
+#include </usr/include/mysql/mysqld_error.h>
+#endif
 #include <memory>
 
 #define MIN_MYSQL_SERVER_VERSION 50100u
diff --git a/src/server/database/Database/Field.h b/src/server/database/Database/Field.h
index 72364f2..d1fe78c 100644
--- a/src/server/database/Database/Field.h
+++ b/src/server/database/Database/Field.h
@@ -21,7 +21,11 @@
 #include "Common.h"
 #include "Log.h"
 
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 
 /**
     @class Field
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.cpp b/src/server/database/Database/Implementation/CharacterDatabase.cpp
index 9bd2398..4be36fa 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/database/Database/Implementation/CharacterDatabase.cpp
@@ -621,7 +621,25 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     // 04
     // 05
     // 06
-    // 07
+    // New NPCBots
+    PrepareStatement(CHAR_SEL_NPCBOTS, "SELECT entry FROM characters_npcbot", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_OWNER, "SELECT owner FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER, "UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_NPCBOT_OWNER_ALL, "UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_ROLES, "SELECT roles FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_ROLES, "UPDATE characters_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP, "SELECT equipMhEx, equipOhEx, equipRhEx, "
+        "equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE, "SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+        "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+        "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+        "WHERE cn.entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_EQUIP, "UPDATE characters_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, "
+        "equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_DEL_NPCBOT, "DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_INS_NPCBOT, "INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_UPD_NPCBOT_FACTION, "UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_NPCBOT_FACTION, "SELECT faction FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH);
     // 08
     // 09
     // 10
diff --git a/src/server/database/Database/Implementation/CharacterDatabase.h b/src/server/database/Database/Implementation/CharacterDatabase.h
index 2f6827b..4d6327f 100644
--- a/src/server/database/Database/Implementation/CharacterDatabase.h
+++ b/src/server/database/Database/Implementation/CharacterDatabase.h
@@ -539,7 +539,20 @@ enum CharacterDatabaseStatements
     // 04
     // 05
     // 06
-    // 07
+    // New NPCBots
+    CHAR_SEL_NPCBOTS,
+    CHAR_SEL_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER,
+    CHAR_UPD_NPCBOT_OWNER_ALL,
+    CHAR_SEL_NPCBOT_ROLES,
+    CHAR_UPD_NPCBOT_ROLES,
+    CHAR_SEL_NPCBOT_EQUIP,
+    CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE,
+    CHAR_UPD_NPCBOT_EQUIP,
+    CHAR_DEL_NPCBOT,
+    CHAR_INS_NPCBOT,
+    CHAR_UPD_NPCBOT_FACTION,
+    CHAR_SEL_NPCBOT_FACTION,
     // 08
     // 09
     // 10
diff --git a/src/server/database/Database/Implementation/WorldDatabase.cpp b/src/server/database/Database/Implementation/WorldDatabase.cpp
index d9aad94..814585c 100644
--- a/src/server/database/Database/Implementation/WorldDatabase.cpp
+++ b/src/server/database/Database/Implementation/WorldDatabase.cpp
@@ -91,4 +91,9 @@ void WorldDatabaseConnection::DoPrepareStatements()
     PrepareStatement(WORLD_DEL_DISABLES, "DELETE FROM disables WHERE entry = ? AND sourceType = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_CREATURE_ZONE_AREA_DATA, "UPDATE creature SET zoneId = ?, areaId = ? WHERE guid = ?", CONNECTION_ASYNC);
     PrepareStatement(WORLD_UPD_GAMEOBJECT_ZONE_AREA_DATA, "UPDATE gameobject SET zoneId = ?, areaId = ? WHERE guid = ?", CONNECTION_ASYNC);
+
+    // Bot
+    PrepareStatement(WORLD_SEL_NPCBOT_INFO, "SELECT guid, map, position_x, position_y, position_z, orientation FROM creature WHERE id = ?", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS, "SELECT hp, mana, armor, str, agi, sta, inte, spi FROM pet_levelstats WHERE creature_entry = ? AND level = ?", CONNECTION_SYNCH);
+    PrepareStatement(WORLD_UPD_NPCBOT_POSITION, "UPDATE creature SET map = ?, position_x = ?, position_y = ?, position_z = ?, orientation = ? WHERE guid = ?", CONNECTION_ASYNC);
 }
diff --git a/src/server/database/Database/Implementation/WorldDatabase.h b/src/server/database/Database/Implementation/WorldDatabase.h
index c547583..4cf47b5 100644
--- a/src/server/database/Database/Implementation/WorldDatabase.h
+++ b/src/server/database/Database/Implementation/WorldDatabase.h
@@ -100,6 +100,11 @@ enum WorldDatabaseStatements
     WORLD_UPD_CREATURE_ZONE_AREA_DATA,
     WORLD_UPD_GAMEOBJECT_ZONE_AREA_DATA,
 
+    // Bot
+    WORLD_SEL_NPCBOT_INFO,
+    WORLD_SEL_NPCBOT_PET_LEVELSTATS,
+    WORLD_UPD_NPCBOT_POSITION,
+
     MAX_WORLDDATABASE_STATEMENTS
 };
 
diff --git a/src/server/database/Database/MySQLConnection.cpp b/src/server/database/Database/MySQLConnection.cpp
index 10f4a7b..77ff991 100644
--- a/src/server/database/Database/MySQLConnection.cpp
+++ b/src/server/database/Database/MySQLConnection.cpp
@@ -21,7 +21,11 @@
 #ifdef _WIN32
   #include <winsock2.h>
 #endif
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 #include <errmsg.h>
 
 #include "MySQLConnection.h"
diff --git a/src/server/database/Database/QueryResult.h b/src/server/database/Database/QueryResult.h
index 0447eca..44f889e 100644
--- a/src/server/database/Database/QueryResult.h
+++ b/src/server/database/Database/QueryResult.h
@@ -25,7 +25,11 @@
 #ifdef _WIN32
   #include <winsock2.h>
 #endif
+#ifdef _WIN32
 #include <mysql.h>
+#else
+#include </usr/include/mysql/mysql.h>
+#endif
 
 class ResultSet
 {
diff --git a/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
new file mode 100644
index 0000000..041834a
--- /dev/null
+++ b/src/server/game/AI/NpcBots/QBots/botQ_Airen.cpp
@@ -0,0 +1,121 @@
+#include "bot_ai.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "WorldSession.h"
+/*
+Bot Quest npc Airen by Graff onlysuffering@gmail.com
+Complete - 0%
+TODO:
+*/
+#define ACT                 GOSSIP_ACTION_INFO_DEF
+
+class Airen_chapter1 : public CreatureScript
+{
+public:
+    Airen_chapter1() : CreatureScript("npc_Airen_qI") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new Airen_AI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, "nothing here", 6000, ACT + 1, "nothing here either", 0 * COPPER, true);
+        player->PlayerTalkClass->SendGossipMenu(GOSSIP_MURDER, creature->GetGUID());
+
+        std::ostringstream msg;
+        msg << "..." << player->GetName() << ", huh?";
+        bot_ai::BotSpeak(msg.str(), CHAT_MSG_WHISPER, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1)
+                {
+                    if (!player->HasEnoughMoney(1 * COPPER))
+                    {
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, creature, 0, 0);
+                        break;
+                    }
+                    player->ModifyMoney(-(1 * COPPER));
+                }
+
+                break;
+            }
+            default:
+                break;
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        player->PlayerTalkClass->ClearMenus();
+        std::string answer = "asd";
+
+        switch (sender)
+        {
+            case 6000:
+            {
+                if (action == ACT + 1 && code == answer)
+                    bot_ai::BotSpeak("hehe", CHAT_MSG_YELL, LANG_UNIVERSAL, creature->GetGUID(), player->GetGUID());
+                break;
+            }
+        }
+
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    struct Airen_AI : public ScriptedAI
+    {
+        Airen_AI(Creature* creature) : ScriptedAI(creature) { }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { me->DisappearAndDie(); }
+
+        void UpdateAI(uint32 /*diff*/)
+        {
+        }
+
+        void Reset()
+        {
+            me->SetCreateHealth(213000213);
+            me->SetMaxHealth(me->GetCreateHealth());
+            me->SetFullHealth();
+
+            me->setPowerType(POWER_RAGE);
+            me->SetMaxPower(POWER_RAGE, 10000);
+            me->SetPower(POWER_RAGE, me->GetMaxPower(POWER_RAGE));
+        }
+
+        void DamageTaken(Unit* /*u*/, uint32& damage)
+        {
+            damage = me->GetHealth() > 1 ? 1 : 0;
+        }
+    };
+};
+
+void AddSC_BotQuests_chapter1()
+{
+    new Airen_chapter1();
+}
diff --git a/src/server/game/AI/NpcBots/bot_Events.h b/src/server/game/AI/NpcBots/bot_Events.h
new file mode 100644
index 0000000..d72af36
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_Events.h
@@ -0,0 +1,133 @@
+#ifndef _BOT_EVENTS_H
+#define _BOT_EVENTS_H
+
+//#include "Player.h"
+//#include "SpellAuras.h"
+//#include "bot_ai.h"
+#include "Creature.h"
+//#include "MapManager.h"
+/*
+Name: bot_Events
+%Complete: 1
+Comment: Custom event types for NPCBot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/events
+
+Notes:
+All events must be executed through botAI
+*/
+//DEPRECATED Visibility update: needed after near teleport
+//class VisibilityUpdateEvent : public BasicEvent
+//{
+//    friend class bot_minion_ai;
+//    protected:
+//        VisibilityUpdateEvent(uint64 botGuid, bool force = true) : _botGuid(botGuid), _force(force) { }
+//        ~VisibilityUpdateEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->GetBotMinionAI()->UpdateBotVisibility(_force);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        bool _force;
+//};
+//Teleport home: near or far, only used for free bots
+class TeleportHomeEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class bot_ai;
+    protected:
+        TeleportHomeEvent(bot_minion_ai* ai/*, uint64 botGuid*/) :
+             _ai(ai)/*, _botGuid(botGuid)*/
+             { }
+        ~TeleportHomeEvent() {}
+
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->TeleportHome();
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+        //uint64 _botGuid;
+};
+//DEPRECATEDEvade mode enable/disable: adds UNIT_STATE_EVADE
+//class EvadeEvent : public BasicEvent
+//{
+//    friend class bot_minion_ai;
+//    protected:
+//        EvadeEvent(uint64 botGuid, bool apply) : _botGuid(botGuid), _apply(apply) { }
+//        ~EvadeEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->GetBotMinionAI()->SetEvade(_apply);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        bool _apply;
+//};
+//Delayed teleport finish: adds bot back to world on new location
+class TeleportFinishEvent : public BasicEvent
+{
+    friend class bot_minion_ai;
+    friend class BotMgr;
+    protected:
+        TeleportFinishEvent(bot_minion_ai* ai/*, uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/) :
+             _ai(ai)//, _mapId(mapId), _instanceId(instanceId), _x(x), _y(y), _z(z), _o(o)
+             { }
+        ~TeleportFinishEvent() {}
+
+        //Execute is always called while creature is out of world so ai is never deleted
+        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+        {
+            _ai->FinishTeleport(/*_mapId, _instanceId, _x, _y, _z, _o*/);
+            return true;
+        }
+
+    private:
+        bot_minion_ai* _ai;
+        //uint32 _mapId;
+        //uint32 _instanceId;
+        //float _x;
+        //float _y;
+        //float _z;
+        //float _o;
+};
+//DEPRECATED
+//class NearTeleportEvent : public BasicEvent
+//{
+//    friend class bot_ai;
+//    protected:
+//        NearTeleportEvent(uint64 botGuid, Position* pos) : _botGuid(botGuid), _pos(pos) { }
+//        ~NearTeleportEvent() {}
+//
+//        bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+//        {
+//            if (Creature* bot = ObjectAccessor::GetObjectInWorld(_botGuid, (Creature*)NULL))
+//            {
+//                bot->Relocate(_pos);
+//                return true;
+//            }
+//            return false;
+//        }
+//
+//    private:
+//        uint64 _botGuid;
+//        Position* _pos;
+//};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_GridNotifiers.h b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
new file mode 100644
index 0000000..9f3c35d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_GridNotifiers.h
@@ -0,0 +1,724 @@
+#ifndef _BOT_GRIDNOTIFIERS_H
+#define _BOT_GRIDNOTIFIERS_H
+
+#include "Group.h"
+#include "Player.h"
+#include "SpellAuras.h"
+#include "bot_ai.h"
+/*
+Name: bot_GridNotifiers
+%Complete: 99+
+Comment: Custom grid notifiers for Bot system by Graff (onlysuffering@gmail.com)
+Category: creature_cripts/custom/bots/grids
+*/
+
+extern bool _botPvP;
+
+class NearestHostileUnitCheck
+{
+    public:
+        explicit NearestHostileUnitCheck(Unit const* unit, float dist, bool magic, bot_ai const* m_ai, bool targetCCed = false) :
+        me(unit), m_range(dist), byspell(magic), ai(m_ai), AttackCCed(targetCCed)
+        { free = ai->IAmFree(); }
+        bool operator()(Unit const* u)
+        {
+            if (u == me)
+                return false;
+            if (!_botPvP && !free && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!ai->CanBotAttack(u, byspell))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!AttackCCed && (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE)))
+                return false;//do not allow CCed units if checked
+            //if (u->HasUnitState(UNIT_STATE_CASTING) && (u->GetTypeId() == TYPEID_PLAYER || u->IsPet()))
+            //    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+            //        if (Spell* spell = u->GetCurrentSpell(i))
+            //            if (ai->IsInBotParty(spell->m_targets.GetUnitTarget()))
+            //                return true;
+            if (!ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer() && !u->IsInCombat())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            m_range = me->GetDistance(u);   // use found unit range as new range limit for next check
+            return true;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool byspell;
+        bot_ai const* ai;
+        bool AttackCCed;
+        bool free;
+        NearestHostileUnitCheck(NearestHostileUnitCheck const&);
+};
+
+class HostileDispelTargetCheck
+{
+    public:
+        explicit HostileDispelTargetCheck(Unit const* unit, float dist = 30, bool stealable = false, bot_ai const* m_ai = NULL) :
+        me(unit), m_range(dist), checksteal(stealable), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u->IsWithinDistInMap(me, m_range) &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) <= REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (checksteal && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(30449))) return false;//immune to steal
+                if (!checksteal)
+                {
+                    if (me->getLevel() >= 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(32375))) return false;//immune to mass dispel
+                    if (me->getLevel() < 70 && u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(527))) return false;//immune to direct dispel
+                }
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                SpellInfo const* Info;
+                uint32 id;
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    Info = aura->GetSpellInfo();
+                    id = Info->Id;
+                    if (id == 20050 || id == 20052 || id == 20053 || //Vengeance
+                        id == 50447 || id == 50448 || id == 50449) //Bloody Vengeance
+                        continue;
+                    if (Info->Dispel != DISPEL_MAGIC) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    if (checksteal && (Info->AttributesEx4 & SPELL_ATTR4_NOT_STEALABLE)) continue;
+                    AuraApplication const* aurApp = aura->GetApplicationOfTarget(u->GetGUID());
+
+                    if (aurApp && aurApp->IsPositive())
+                        return true;
+                }
+            }
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        bool checksteal;
+        bot_ai const* ai;
+        HostileDispelTargetCheck(HostileDispelTargetCheck const&);
+};
+
+class AffectedTargetCheck
+{
+    public:
+        explicit AffectedTargetCheck(ObjectGuid casterguid, float dist, uint32 spellId, Player const* groupCheck = 0, uint8 hostileCheckType = 0) :
+        caster(casterguid), m_range(dist), spell(spellId), checker(groupCheck), needhostile(hostileCheckType)
+        { gr = NULL; if (checker->GetTypeId() != TYPEID_PLAYER) return; gr = checker->GetGroup(); }
+        bool operator()(Unit const* u) const
+        {
+            if (caster && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_NOT_SELECTABLE))
+                return false;
+            if (needhostile == 0 && !u->IsHostileTo(checker)) return false;
+            if (needhostile == 1 && !(gr && gr->IsMember(u->GetGUID()) && u->GetTypeId() == TYPEID_PLAYER)) return false;
+            if (needhostile == 2 && !(gr && gr->IsMember(u->GetGUID()))) return false;
+            if (needhostile == 3 && !u->IsFriendlyTo(checker)) return false;
+
+            if (u->IsAlive() && checker->IsWithinDistInMap(u, m_range))
+            {
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    Aura* aura = itr->second;
+                    if (aura->GetId() == spell)
+                        if (caster == 0 || aura->GetCasterGUID() == caster)
+                            return true;
+                }
+            }
+            return false;
+        }
+    private:
+        ObjectGuid const caster;
+        float m_range;
+        uint32 const spell;
+        Player const* checker;
+        uint8 needhostile;
+        Group const* gr;
+        AffectedTargetCheck(AffectedTargetCheck const&);
+};
+
+class PolyUnitCheck
+{
+    public:
+        explicit PolyUnitCheck(Unit const* unit, float dist, Unit const* currTarget) : me(unit), m_range(dist), mytar(currTarget) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == mytar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat() || !u->IsAlive() || !u->GetVictim())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_HUMANOID &&
+                u->GetCreatureType() != CREATURE_TYPE_BEAST)
+                return false;
+            if (me->GetDistance(u) < 6 || mytar->GetDistance(u) < 5 ||
+                (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && u->GetHealthPct() < 70))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE ? !u->getAttackers().empty() : u->getAttackers().size() > 1)
+                return false;
+            if (!u->IsHostileTo(me))
+                return false;
+            if (u->IsPolymorphed() ||
+                u->isFrozen() ||
+                u->isInRoots() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(339)) || //entangling roots
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(16914)) || //hurricane
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(10)) || //blizzard
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(2121)) || //flamestrike
+                //u->HasAuraTypeWithAffectMask(SPELL_AURA_PERIODIC_DAMAGE, sSpellMgr->GetSpellInfo(20116)) || //consecration
+                u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_MAGE && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(118)))//Polymorph
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_SHAMAN && !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(51514)))//Hex
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        Unit const* mytar;
+        PolyUnitCheck(PolyUnitCheck const&);
+};
+
+class FearUnitCheck
+{
+    public:
+        explicit FearUnitCheck(Unit const* unit, float dist = 30) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetCreatureType() == CREATURE_TYPE_UNDEAD)
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_BEAST &&
+                me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (u->getAttackers().size() > 1 && u->GetVictim() != me)
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->isFeared())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_WARLOCK &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(5782)))//fear rank1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1513)))//scare beast rank1
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        FearUnitCheck(FearUnitCheck const&);
+};
+
+class StunUnitCheck
+{
+    public:
+        explicit StunUnitCheck(Unit const* unit, float dist = 20) : me(unit), m_range(dist) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetVictim() == u)
+                return false;
+            if (me->GetTypeId() == TYPEID_UNIT)
+                if (Player* mymaster = me->ToCreature()->GetBotOwner())
+                    if (mymaster->GetVictim() == u)
+                        return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER && u->isFeared())
+                return false;
+            if (me->GetDistance(u) < 10)//do not allow close cast to prevent break due to AOE damage
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic((1<<MECHANIC_SHACKLE)|(1<<MECHANIC_SLEEP)|(1<<MECHANIC_DISORIENTED)))
+                return false;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_PALADIN &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(20066)))//repentance
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(60210)))//freezing arrow effect
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19386)))//wyvern sting rank 1
+                return true;
+            if (me->ToCreature()->GetBotClass() == BOT_CLASS_HUNTER &&
+                !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(1991)))//scatter shot
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        StunUnitCheck(StunUnitCheck const&);
+};
+
+class UndeadCCUnitCheck
+{
+    public:
+        explicit UndeadCCUnitCheck(Unit const* unit, float dist = 30, uint32 spell = 0) : me(unit), m_range(dist), m_spellId(spell) { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (me->GetVictim() == u && u->GetVictim() == me)
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            //most horrible hacks
+            if (u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON &&
+                (m_spellId == 2812 || m_spellId == 10318 || //holy
+                m_spellId == 27139 || m_spellId == 48816 || //wra
+                m_spellId == 48817 ||                       //th or
+                m_spellId == 10326))                        //turn evil
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE))
+                return false;
+            if (u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE) &&
+                (m_spellId == 9484 || m_spellId == 9485 || m_spellId == 10955))//shackle undead
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range;
+        uint32 m_spellId;
+        UndeadCCUnitCheck(UndeadCCUnitCheck const&);
+};
+
+class RootUnitCheck
+{
+    public:
+        explicit RootUnitCheck(Unit const* unit, Unit const* mytarget, float dist = 30, uint32 spell = 0) : me(unit), curtar(mytarget), m_range(dist), m_spellId(spell)
+        { if (!spell) return; }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (u == curtar)
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->IsInCombat())
+                return false;
+            if (me->GetDistance(u) < 8)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!u->isTargetableForAttack())
+                return false;
+            if (u->GetReactionTo(me) > REP_NEUTRAL)
+                return false;
+            if (u->isFrozen() || u->isInRoots())
+                return false;
+            if (!u->getAttackers().empty())
+                return false;
+            if (u->IsPolymorphed() ||
+                u->HasAura(51514)/*hex*/ ||
+                u->HasAura(20066)/*repentance*/ ||
+                u->HasAuraWithMechanic(1<<MECHANIC_SHACKLE)/*shackle undead*/)
+                return false;
+            if (!u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spellId)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        Unit const* curtar;
+        float m_range;
+        uint32 m_spellId;
+        RootUnitCheck(RootUnitCheck const&);
+};
+
+class CastingUnitCheck
+{
+    public:
+        explicit CastingUnitCheck(Unit const* unit, float mindist = 0.f, float maxdist = 30, bool friendly = false, uint32 spell = 0) :
+        me(unit), min_range(mindist), max_range(maxdist), m_friend(friendly), m_spell(spell) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!m_friend && !_botPvP && !(me->ToCreature() && me->ToCreature()->IsFreeBot()) && u->IsControlledByPlayer())
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!u->IsAlive())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!u->IsVisible())
+                return false;
+            if (!m_friend && !u->isTargetableForAttack())
+                return false;
+            //if (!m_friend && u->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_SILENCED))//prevent double silence
+            //    return false;
+            if (!u->IsNonMeleeSpellCast(false))
+                return false;
+            if (m_friend == (u->GetReactionTo(me) < REP_FRIENDLY))
+                return false;
+            if (m_spell == 10326 && //turn evil
+                u->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                u->GetCreatureType() != CREATURE_TYPE_DEMON)
+                return false;
+            if (m_spell == 20066 && //repentance
+                !(u->GetCreatureType() == CREATURE_TYPE_HUMANOID ||
+                u->GetCreatureType() == CREATURE_TYPE_DEMON ||
+                u->GetCreatureType() == CREATURE_TYPE_DRAGONKIN ||
+                u->GetCreatureType() == CREATURE_TYPE_GIANT ||
+                u->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                return false;
+            if (!m_spell || !u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(m_spell)))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bool m_friend;
+        uint32 m_spell;
+        CastingUnitCheck(CastingUnitCheck const&);
+};
+
+class SecondEnemyCheck
+{
+    public:
+        explicit SecondEnemyCheck(Unit const* unit, float dist, float splashdist, Unit const* currtarget, bot_ai const* m_ai) :
+        me(unit), m_range(dist), m_splashrange(splashdist), mytar(currtarget), ai(m_ai) {}
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u == mytar)
+                return false;//We need to find SECONDARY target
+            if (!u->IsInCombat())
+                return false;
+            if (u->isMoving() != mytar->isMoving())//only when both targets idle or both moving
+                return false;
+            if (!me->IsWithinDistInMap(u, m_range + 1.f))//distance check
+                return false;
+            if (mytar->GetDistance(u) > m_splashrange)//not close enough to each other
+                return false;
+
+            if (ai->CanBotAttack(u))
+                return true;
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float m_range, m_splashrange;
+        Unit const* mytar;
+        bot_ai const* ai;
+        SecondEnemyCheck(SecondEnemyCheck const&);
+};
+
+class TranquilTargetCheck
+{
+    public:
+        explicit TranquilTargetCheck(Unit const* unit, float mindist, float maxdist, bot_ai const* m_ai) :
+        me(unit), min_range(mindist), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (u != me->GetVictim() &&//check hunter_bot::hunter_botAI::CheckTranquil(uint32)
+                u->IsWithinDistInMap(me, max_range) &&
+                u->GetDistance(me) > min_range &&
+                u->IsAlive() &&
+                u->InSamePhase(me) &&
+                u->IsInCombat() &&
+                u->isTargetableForAttack() &&
+                u->IsVisible() &&
+                u->GetReactionTo(me) <= REP_NEUTRAL &&
+                ai->IsInBotParty(u->GetVictim()))
+            {
+                if (u->IsImmunedToSpell(sSpellMgr->GetSpellInfo(19801))) return false;//immune to tranquilizing shot
+                Unit::AuraMap const &Auras = u->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = Auras.begin(); itr != Auras.end(); ++itr)
+                {
+                    SpellInfo const* Info = itr->second->GetSpellInfo();
+                    if (Info->Dispel != DISPEL_MAGIC && Info->Dispel != DISPEL_ENRAGE) continue;
+                    if (Info->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (Info->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(u->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        return true;
+                    }
+                }
+            }
+
+            return false;
+        }
+    private:
+        Unit const* me;
+        float min_range, max_range;
+        bot_ai const* ai;
+        TranquilTargetCheck(TranquilTargetCheck const&);
+};
+
+class NearbyHostileUnitCheck
+{
+    public:
+        explicit NearbyHostileUnitCheck(Unit const* unit, float maxdist, float mindist, bot_ai const* m_ai, bool forCC) :
+        me(unit), max_range(maxdist), min_range(mindist), ai(m_ai), m_forCC(forCC)
+        {
+            free = ai->IAmFree();
+        }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            if (me->HasUnitState(UNIT_STATE_ROOT) && (ai->HasRole(BOT_ROLE_RANGED) == me->IsWithinDistInMap(u, 8.f)))
+                return false;
+            if (/*!free && */!u->IsInCombat())
+                return false;
+            if (!free && !ai->CanBotAttack(u))
+                return false;
+            if (!_botPvP && !ai->IAmFree() && u->IsControlledByPlayer())
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (min_range > 0.1f && me->GetDistance(u) < min_range)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (u->HasUnitState(UNIT_STATE_CONFUSED|UNIT_STATE_STUNNED|UNIT_STATE_FLEEING|UNIT_STATE_DISTRACTED|UNIT_STATE_CONFUSED_MOVE))
+                return false;
+            if (m_forCC && u->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+
+            if (!free && !ai->IsInBotParty(u->GetVictim()))
+                return false;
+
+            if (free)
+            {
+                if (u->IsControlledByPlayer())
+                    return false;
+                if (!me->IsValidAttackTarget(u) || !u->isTargetableForAttack())
+                    return false;
+            }
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range, min_range;
+        bot_ai const* ai;
+        bool m_forCC;
+        bool free;
+        NearbyHostileUnitCheck(NearbyHostileUnitCheck const&);
+};
+
+class NearbyFriendlyUnitCheck
+{
+    public:
+        explicit NearbyFriendlyUnitCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(Unit const* u) const
+        {
+            if (u == me)
+                return false;
+            //if (!u->IsInCombat())
+            //    return false;
+            if (u->IsTotem() || u->IsSummon())
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (ai->InDuel(u))
+                return false;
+            if (!ai->IsInBotParty(u))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyFriendlyUnitCheck(NearbyFriendlyUnitCheck const&);
+};
+
+class NearbyRezTargetCheck
+{
+    public:
+        explicit NearbyRezTargetCheck(Unit const* unit, float maxdist, bot_ai const* m_ai) : me(unit), max_range(maxdist), ai(m_ai) { }
+        bool operator()(WorldObject const* u) const
+        {
+            if (u == me)
+                return false;
+            if (u->GetTypeId() != TYPEID_PLAYER && u->GetTypeId() != TYPEID_CORPSE)
+                return false;
+            if (!u->InSamePhase(me))
+                return false;
+            if (!me->IsWithinDistInMap(u, max_range))
+                return false;
+            if (Player const* p = u->ToPlayer())
+            {
+                if (p->IsAlive())
+                    return false;
+                if (p->isResurrectRequested())
+                    return false;
+                if (!ai->IsInBotParty(p))
+                    return false;
+            }
+            if (!me->CanSeeOrDetect(u))
+                return false;
+            if (urand(0,100) > 20)
+                return false;
+            if (u->GetTypeId() == TYPEID_CORPSE && !ObjectAccessor::FindPlayer(u->ToCorpse()->GetOwnerGUID()))
+                return false;
+
+            return true;
+        }
+    private:
+        Unit const* me;
+        float max_range;
+        bot_ai const* ai;
+        NearbyRezTargetCheck(NearbyRezTargetCheck const&);
+};
+
+template<class Check>
+struct UnitListSearcher
+{
+    uint32 i_phaseMask;
+    GuidList &i_objects;
+    Check& i_check;
+
+    UnitListSearcher(WorldObject const* searcher, GuidList &objects, Check &check)
+        : i_phaseMask(searcher->GetPhaseMask()), i_objects(objects), i_check(check) { }
+
+    void Visit(PlayerMapType &m)
+    {
+        for (PlayerMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+            if (itr->GetSource()->InSamePhase(i_phaseMask))
+                if (i_check(itr->GetSource()))
+                    i_objects.push_back(itr->GetSource()->GetGUID());
+    }
+    void Visit(CreatureMapType &m)
+    {
+        for (CreatureMapType::iterator itr = m.begin(); itr != m.end(); ++itr)
+            if (itr->GetSource()->InSamePhase(i_phaseMask))
+                if (i_check(itr->GetSource()))
+                    i_objects.push_back(itr->GetSource()->GetGUID());
+    }
+
+    template<class NOT_INTERESTED> void Visit(GridRefManager<NOT_INTERESTED> &) { }
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_ai.cpp b/src/server/game/AI/NpcBots/bot_ai.cpp
new file mode 100644
index 0000000..71867f7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.cpp
@@ -0,0 +1,8125 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "bot_GridNotifiers.h"
+#include "botmgr.h"
+#include "CellImpl.h"
+#include "Chat.h"
+#include "GameEventMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "MapManager.h"
+#include "ScriptedGossip.h"
+#include "SpellAuraEffects.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+TODO:
+Implement Racial Abilities
+Quests
+I NEED MORE
+*/
+const uint8 GroupIconsFlags[TARGETICONCOUNT] =
+{
+    /*STAR        = */0x001,
+    /*CIRCLE      = */0x002,
+    /*DIAMOND     = */0x004,
+    /*TRIANGLE    = */0x008,
+    /*MOON        = */0x010,
+    /*SQUARE      = */0x020,
+    /*CROSS       = */0x040,
+    /*SKULL       = */0x080
+};
+
+static std::set<uint32> BotCustomSpells;
+static bool SPELLS_DEFINED = false;
+
+extern bool _enableNpcBots;
+extern bool _botPvP;
+extern uint8 _maxClassNpcBots;
+extern uint8 _healTargetIconFlags;
+extern float _mult_dmg_melee;
+extern float _mult_dmg_spell;
+extern float _mult_healing;
+
+bot_minion_ai::bot_minion_ai(Creature* creature) : bot_ai(creature)
+{
+    Potion_cd = 0;
+    pvpTrinket_cd = 30000;
+    rezz_cd = 0;
+    myangle = 0.f;
+    mana_cd = 0;
+    health_cd = 0;
+    feast_health = false;
+    feast_mana = false;
+    _classinfo = new PlayerClassLevelInfo();
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        for (uint8 j = 0; j != MAX_BOT_ITEM_MOD; ++j)
+            _stats[i][j] = 0;
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        _equips[i] = NULL;
+
+    _reviveTimer = 0;
+    _saveTimer = 0;
+    _powersTimer = 0;
+    _chaseTimer = 0;
+
+    _jumpCount = 0;
+    _evadeCount = 0;
+
+    _lastTargetGuid.Clear();
+}
+bot_minion_ai::~bot_minion_ai()
+{
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        if (_equips[i])
+            delete _equips[i];
+    delete _classinfo;
+}
+
+bot_pet_ai::bot_pet_ai(Creature* creature) : bot_ai(creature)
+{
+    m_creatureOwner = me->GetCreatureOwner();
+    basearmor = 0;
+}
+bot_pet_ai::~bot_pet_ai() { }
+
+bot_ai::bot_ai(Creature* creature) : ScriptedAI(creature)
+{
+    bot_ai::InitBotCustomSpells();
+
+    ResetBotAI(BOTAI_RESET_INIT);
+    m_botCommandState = COMMAND_FOLLOW;
+    checkMasterTimer = urand(5000, 15000);
+    needparty = false;
+    spawned = false;
+    firstspawn = true;
+    _evadeMode = false;
+    _atHome = true;
+    _temp = me->GetSpawnId() ? false : true;
+    _roleMask = 0;
+    haste = 0;
+    blockvalue = 1;
+    hit = 0.f;
+    parry = 0.f;
+    dodge = 0.f;
+    block = 0.f;
+    crit = 0.f;
+    dmg_taken = 1.f;
+    expertise = 0;
+    spellpower = 0;
+    spellpen = 0;
+    regen_mp = 0;
+    regenTimer_hp = 0;
+    regenTimer_mp = 0;
+    m_botSpellInfo = NULL;
+    clear_cd = 2;
+    temptimer = 0;
+    wait = 15;
+    GC_Timer = 0;
+    lastdiff = 0;
+    _bootTimer = -1;
+    _updateTimerMedium = 0;
+    checkAurasTimer = 20;
+    roleTimer = 0;
+    cost = 0;
+    doHealth = false;
+    doMana = false;
+    //shouldUpdateStats = true;
+    pos.m_positionX = 0.f;
+    pos.m_positionY = 0.f;
+    pos.m_positionZ = 0.f;
+    aftercastTargetGuid.Clear();
+    currentSpell = 0;
+
+    //visUpEvent = NULL;
+    teleHomeEvent = NULL;
+    //evadeEvent = NULL;
+    teleFinishEvent = NULL;
+}
+bot_ai::~bot_ai() { }
+
+uint16 bot_ai::Rand() const
+{
+    return IAmFree() ? urand(0, 100) : urand(0, 100 + (master->GetNpcBotsCount() - 1) * 10);
+}
+
+void bot_ai::BotSay(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Say(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotWhisper(char const* text, Player* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Whisper(text, LANG_UNIVERSAL, target);
+}
+void bot_ai::BotYell(char const* text, Player const* target) const
+{
+    if (!target && master->GetTypeId() == TYPEID_PLAYER)
+        target = master;
+    if (!target)
+        return;
+
+    me->Yell(text, LANG_UNIVERSAL, target);
+}
+
+bool bot_ai::SetBotOwner(Player* newowner)
+{
+    ASSERT(newowner && "Trying to set NULL owner!!!");
+    ASSERT(newowner->GetGUID().IsPlayer() && "Trying to set a non-player as owner!!!");
+    //ASSERT(master->GetGUID() == me->GetGUID());
+    //ASSERT(!IsMinionAI() || IAmFree());
+
+    //have master already
+    if (master->GetGUID() != me->GetGUID())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): bot %s (id: %u) has master %s while trying to set to %s...",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+    if (IsMinionAI() && !IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): minion bot %s (id: %u) IS NOT FREE (has master %s) while trying to set to %s",
+            me->GetName().c_str(), me->GetEntry(), master->GetName().c_str(), newowner->GetName().c_str());
+        return false;
+    }
+
+    if (IsMinionAI())
+    {
+        BotMgr* mgr = newowner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(newowner);
+
+        bool takeMoney = (_ownerGuid != newowner->GetGUID().GetCounter());
+        if (mgr->AddBot(me, takeMoney) & BOT_ADD_FATAL)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai::SetBotOwner(): player %s (%u) can't add bot %s (FATAL), removing...",
+            //    master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str());
+            //failed to add bot
+            //if (_ownerGuid)
+            //{
+            //    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+            //    //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+            //    stmt->setUInt32(0, uint32(0));
+            //    stmt->setUInt32(1, me->GetEntry());
+            //    CharacterDatabase.Execute(stmt);
+            //}
+
+            if (_ownerGuid)
+            {
+                TC_LOG_ERROR("entities.player", "bot_ai::FindMaster(): %s's master %s (guid: %u) is found but bot failed to set owner (fatal)! Unbinding bot temporarily (until server restart)...",
+                    me->GetName().c_str(), newowner->GetName().c_str(), newowner->GetGUID().GetCounter());
+                _ownerGuid = 0;
+            }
+
+            checkMasterTimer = 30000;
+            ResetBotAI(BOTAI_RESET_LOST);
+            return false;
+        }
+
+        (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 &= ~(UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+        me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+    }
+
+    //recursive
+    if (master->GetGUID() == newowner->GetGUID())
+        return true;
+
+    master = newowner;
+    _ownerGuid = newowner->GetGUID().GetCounter();
+    spawned = false;
+
+    ASSERT(me->IsInWorld());
+    AbortTeleport();
+    return true;
+}
+
+void bot_ai::ResetBotAI(uint8 resetType)
+{
+    //ASSERT(me->IsInWorld());
+
+    master = reinterpret_cast<Player*>(me);
+    if (resetType & BOTAI_RESET_ABANDON_MASTER)
+        _ownerGuid = 0;
+
+    (const_cast<CreatureTemplate*>(me->GetCreatureTemplate()))->unit_flags2 |= (UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+    me->SetUInt32Value(UNIT_FIELD_FLAGS_2, me->GetCreatureTemplate()->unit_flags2);
+
+    me->IsAIEnabled = true;
+    me->SetCanUpdate(true);
+
+    if (spawned)
+        ReturnHome();
+
+    if (!me->IsInWorld())
+    {
+        ASSERT(IsMinionAI());
+        AbortTeleport();
+
+        //if no master - will teleport to spawn position
+        //otherwise - will teleport to master
+        teleHomeEvent = new TeleportHomeEvent(ToMinionAI());
+        events.AddEvent(teleHomeEvent, events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+    }
+    else
+    {
+        _atHome = false;
+        spawned = false;
+    }
+}
+
+SpellCastResult bot_ai::CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const
+{
+    if (spellId == 0)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (victim->GetTypeId() == TYPEID_PLAYER && victim->ToPlayer()->IsGameMaster())
+        return SPELL_FAILED_BAD_TARGETS;
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+        return SPELL_FAILED_DONT_REPORT;
+
+    if (me->IsMounted() && !(spellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_MOUNTED))
+        return SPELL_FAILED_NOT_MOUNTED;
+
+    //if (Powers(spellInfo->PowerType) == me->getPowerType() &&
+    //    (int32)me->GetPower(me->getPowerType()) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+    //    return SPELL_FAILED_NO_POWER;
+
+    if ((int32)me->GetPower(Powers(spellInfo->PowerType)) < spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()))
+        return SPELL_FAILED_NO_POWER;
+
+    if (victim->isType(TYPEMASK_UNIT) && InDuel(victim))
+        return SPELL_FAILED_BAD_TARGETS;
+
+    if (victim->isType(TYPEMASK_UNIT) && !spellInfo->IsPassive())
+    {
+        bool needRankSelection = false;
+        for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        {
+            if (spellInfo->IsPositiveEffect(i) &&
+                (spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AURA ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_PARTY ||
+                spellInfo->Effects[i].Effect == SPELL_EFFECT_APPLY_AREA_AURA_RAID))
+            {
+                needRankSelection = true;
+                break;
+            }
+        }
+        if (needRankSelection && victim->getLevel() < spellInfo->GetFirstRankSpell()->BaseLevel)
+            return SPELL_FAILED_LOWLEVEL;
+    }
+
+    //disarmed
+    if (spellInfo->EquippedItemClass == ITEM_CLASS_WEAPON)
+    {
+        if (spellInfo->EquippedItemInventoryTypeMask != 0)
+        {
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1 << INVTYPE_WEAPONMAINHAND)) &&
+                !me->CanUseAttackType(BASE_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & (1 << INVTYPE_WEAPONOFFHAND)) &&
+                !me->CanUseAttackType(OFF_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS_OFFHAND;
+            if ((spellInfo->EquippedItemInventoryTypeMask & ((1 << INVTYPE_RANGED) | (1 << INVTYPE_RANGEDRIGHT))) &&
+                !me->CanUseAttackType(RANGED_ATTACK))
+                return SPELL_FAILED_EQUIPPED_ITEM_CLASS;
+        }
+        else if (!me->CanUseAttackType(BASE_ATTACK))
+            return SPELL_FAILED_EQUIPPED_ITEM_CLASS_MAINHAND;
+    }
+
+    if (victim->isType(TYPEMASK_UNIT) && !CheckImmunities(spellId, victim))
+        return SPELL_FAILED_BAD_TARGETS;
+
+    switch (botclass)
+    {
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DRUID:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            if (Feasting() && !master->IsInCombat() && !master->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_WARRIOR:
+            //BladeStorm
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_BM:
+            //BladeStorm PLACEHOLDER
+            if (me->HasAura(46924/*67541*/))
+                return SPELL_FAILED_CANT_DO_THAT_RIGHT_NOW;
+            break;
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_DEATH_KNIGHT:
+            break;
+        default:
+            TC_LOG_ERROR("entities.player", "CheckBotCast(): Unknown bot class %u", botclass);
+            break;
+    }
+
+    return SPELL_CAST_OK;
+}
+
+bool bot_ai::doCast(Unit* victim, uint32 spellId, bool triggered, ObjectGuid originalCaster)
+{
+    if (spellId == 0) return false;
+    if (IsCasting()) return false;
+    if (!victim || !victim->IsInWorld() || me->GetMap() != victim->FindMap()) return false;
+
+    m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!m_botSpellInfo)
+        return false;
+
+    //select aura level
+    if (victim->isType(TYPEMASK_UNIT))
+        if (SpellInfo const* actualSpellInfo = m_botSpellInfo->GetAuraRankForLevel(victim->getLevel()))
+            m_botSpellInfo = actualSpellInfo;
+
+    if (m_botSpellInfo->CalcCastTime() && JumpingFlyingOrFalling())
+        return false;
+
+    if (spellId == MANAPOTION)
+    {
+        value = urand(me->GetMaxPower(POWER_MANA)/4, me->GetMaxPower(POWER_MANA)/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+    else if (spellId == HEALINGPOTION)
+    {
+        value = urand(me->GetMaxHealth()/3, me->GetMaxHealth()/2);
+        me->CastCustomSpell(victim, spellId, &value, 0, 0, true);
+        return true;
+    }
+
+    //check cooldown
+    if (!IsSpellReady(m_botSpellInfo->GetFirstRankSpell()->Id, lastdiff, false))
+        return false;
+
+    //remove shapeshifts manually to restore powers/stats
+    if (me->GetShapeshiftForm() != FORM_NONE)
+    {
+        if (m_botSpellInfo->CheckShapeshift(me->GetShapeshiftForm()) != SPELL_CAST_OK)
+            removeFeralForm(true);
+    }
+
+    if (!(m_botSpellInfo->Attributes & SPELL_ATTR0_CASTABLE_WHILE_SITTING))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+
+    if (!IAmFree() && victim->isType(TYPEMASK_UNIT) && !victim->IsWithinLOSInMap(me) && IsInBotParty(victim))
+    {
+        //std::ostringstream msg;
+        //msg << "casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+        //BotWhisper(msg.str().c_str(), master);
+        me->Relocate(victim);
+    }
+
+    if (me->isMoving() && m_botSpellInfo->CalcCastTime() > 0)
+        me->BotStopMovement();
+
+    TriggerCastFlags flags = triggered ? TRIGGERED_FULL_MASK : TRIGGERED_NONE;
+    SpellCastTargets targets;
+    targets.SetUnitTarget(victim);
+    Spell* spell = new Spell(me, m_botSpellInfo, flags, originalCaster);
+    spell->prepare(&targets); //sets current spell if succeed
+
+    bool casted = triggered; //triggered casts are casted immediately
+    for (uint8 i = 0; i != CURRENT_MAX_SPELL; ++i)
+    {
+        if (me->GetCurrentSpell(i) == spell)
+        {
+            casted = true;
+            break;
+        }
+    }
+
+    if (!casted)
+    {
+        //failed to cast
+        //delete spell; //crash due to invalid event added to master's eventmap
+        return false;
+    }
+
+    currentSpell = spellId;
+
+    float gcd;
+
+    if (_botclass == BOT_CLASS_ROGUE || GetBotStance() == DRUID_CAT_FORM || GetBotStance() == DEATH_KNIGHT_UNHOLY_PRESENCE)
+        gcd = 1000.f;
+    else
+        gcd = 1500.f;
+
+    ApplyBotSpellGlobalCooldownMods(m_botSpellInfo, gcd);
+
+    //Apply haste to cooldown
+    if (haste)
+        ApplyPercentModFloatVar(gcd, float(haste), false);
+    //global cd cannot be less than 500 ms
+    GC_Timer = std::max<int32>(gcd, 500);
+    //global cd cannot be greater than 1500 ms
+    GC_Timer = std::min<int32>(gcd, 1500);
+
+    return true;
+}
+//Follow point calculation
+void bot_minion_ai::_calculatePos(Position& pos)
+{
+    ASSERT(!IAmFree());
+
+    uint8 followdist = master->GetBotFollowDist();
+    float mydist, angle;
+
+    if (IsTank())
+    {
+        mydist = frand(1.5f, 4.5f); //stand a bit farther
+        angle = (M_PI/2.f) / 16.f * frand(-3.f, 3.f); //in front +-pi/5
+    }
+    else if (IsMelee())
+    {
+        mydist = frand(0.5f, 2.f);
+        angle = (M_PI/2.f) / 8.f * RAND(frand(5.f, 10.f), frand(-10.f, -5.f)); //to the sides +-(pi/3 to pi/1.6)
+    }
+    else
+    {
+        mydist = frand(0.15f, 0.8f);
+        angle = (M_PI/2.f) / 6.f * frand(10.5f, 13.5f); //behind pi+-pi/4.5
+    }
+    //myangle = angle used last time
+    //if difference between last angle and cur angle is too big, use new angle
+    //else use last angle (prevent constant struggling)
+    if (abs(abs(myangle) - abs(angle)) > M_PI/3.f)
+        myangle = angle;
+    else
+        angle = myangle;
+    mydist += std::max<float>(int8(followdist) - 30, 0) / 5.f; //0.f-9.f
+    //mydist += followdist > 10 ? float(followdist - 10)/4.f : 0.f; //distance from 10+ is reduced
+    //mydist = std::min<float>(mydist, 35.f); //do not spread bots too much
+    mydist = std::max<float>(mydist - 5.f, 0.0f); //get bots closer
+    angle += master->GetOrientation();
+    float x(0),y(0),z(0);
+    float size = me->GetObjectSize()/3.f;
+    bool over = false;
+    for (uint8 i = 0; i != 5 + over; ++i)
+    {
+        if (over)
+        {
+            mydist *= 0.2f;
+            break;
+        }
+        master->GetNearPoint(me, x, y, z, size, mydist, angle);
+        if (!master->IsWithinLOS(x,y,z)) //try to get much closer to master
+        {
+            mydist *= 0.4f - float(i*0.07f);
+            size *= 0.1f;
+            if (size < 0.1)
+                size = 0.f;
+            if (size == 0.f && me->GetPositionZ() < master->GetPositionZ())
+                z += 0.25f; //prevent going underground
+        }
+        else
+            over = true;
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+
+    //           TTT
+    //     m      T      m
+    //    mmmmmm MMM mmmmmm
+    //     m   ddddddd   m
+    //      ddddddddddddd
+    //        ddddddddd
+    //
+    //MMM - master
+    //T - bot tank (ROLE_TANK)
+    //m - melee (ROLE_MELEE)
+    //d - default
+}
+// Movement set
+void bot_minion_ai::SetBotCommandState(CommandStates st, bool force, Position* newpos)
+{
+    if (!me->IsAlive())
+        return;
+
+    if (JumpingFlyingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && !IsChanneling() && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)/* || master->HasUnitState(UNIT_STATE_FLEEING)*/) return;
+        if (me->isMoving() && Rand() > 20) return;
+        if (!newpos)
+            _calculatePos(pos);
+        else
+        {
+            pos.m_positionX = newpos->m_positionX;
+            pos.m_positionY = newpos->m_positionY;
+            pos.m_positionZ = newpos->m_positionZ;
+        }
+        if (me->getStandState() == UNIT_STAND_STATE_SIT && !Feasting())
+            me->SetStandState(UNIT_STAND_STATE_STAND);
+        me->GetMotionMaster()->MovePoint(master->GetMapId(), pos);
+        //me->GetMotionMaster()->MoveFollow(master, mydist, angle);
+    }
+    else if (st == COMMAND_STAY)
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+    if (Creature* m_botsPet = me->GetBotsPet())
+        m_botsPet->SetBotCommandState(st, force);
+}
+
+void bot_pet_ai::SetBotCommandState(CommandStates st, bool force, Position* /*newpos*/)
+{
+    if (me->isDead() || IAmDead())
+        return;
+
+    if (JumpingFlyingOrFalling())
+        return;
+
+    if (st == COMMAND_FOLLOW && ((!me->isMoving() && !IsCasting() && master->IsAlive()) || force))
+    {
+        if (!me->IsInMap(master)) return;
+        if (CCed(me, true)) return;
+        if (me->isMoving() && Rand() > 20) return;
+        Unit* followtarget = m_creatureOwner;
+        if (CCed(m_creatureOwner))
+            followtarget = master;
+        if (followtarget == m_creatureOwner)
+        {
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(master)*0.75f < me->GetDistance(m_creatureOwner))
+                me->GetMotionMaster()->MoveFollow(m_creatureOwner, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+        }
+        else
+            if (!me->HasUnitState(UNIT_STATE_FOLLOW) || me->GetDistance(m_creatureOwner)*0.75f < me->GetDistance(master))
+                me->GetMotionMaster()->MoveFollow(master, PET_FOLLOW_DIST, PET_FOLLOW_ANGLE);
+    }
+    else if (st == COMMAND_STAY)//NUY
+    {
+        me->BotStopMovement();
+    }
+    else if (st == COMMAND_ATTACK)
+    { }
+    m_botCommandState = st;
+}
+// Buffs And Heal (really)
+void bot_minion_ai::BuffAndHealGroup(Player* gPlayer, uint32 diff)
+{
+    if (GC_Timer > diff) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        if (HealTarget(me, GetHealthPCT(me), diff))
+            return;
+        if (BuffTarget(me, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+        {
+            if (HealTarget(pet, GetHealthPCT(pet), diff))
+                return;
+            if (BuffTarget(pet, diff))
+                return;
+        }
+
+        if (me->HasAura(BERSERK))
+            return;
+
+        GuidList targets;
+        GetNearbyFriendlyTargetsList(targets, 30);
+        for (GuidList::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+        {
+            if (Unit* u = ObjectAccessor::GetUnit(*me, *itr))
+            {
+                if (HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (BuffTarget(u, diff))
+                    return;
+            }
+        }
+
+        return;
+    }
+
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        if (!master->IsInWorld() || master->IsBeingTeleported())
+            return;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(master, GetHealthPCT(master), diff))
+            return;
+        if (BuffTarget(master, diff))
+            return;
+        for (Unit::ControlList::const_iterator itr = master->m_Controlled.begin(); itr != master->m_Controlled.end(); ++itr)
+        {
+            Unit* u = *itr;
+            if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+            if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                return;
+            if (Creature* cre = u->ToCreature())
+                if (cre->GetIAmABot() || cre->IsPet())
+                    if (BuffTarget(u, diff))
+                        return;
+        }
+        return;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        if (!tPlayer->m_Controlled.empty())
+            Bots = true;
+        if (!tPlayer->IsAlive()) continue;
+        if (HasRole(BOT_ROLE_HEAL) && HealTarget(tPlayer, GetHealthPCT(tPlayer), diff))
+            return;
+        if (BuffTarget(tPlayer, diff))
+            return;
+    }
+    if (Bots)
+    {
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || tPlayer->m_Controlled.empty()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            for (Unit::ControlList::const_iterator itr = tPlayer->m_Controlled.begin(); itr != tPlayer->m_Controlled.end(); ++itr)
+            {
+                Unit* u = *itr;
+                if (!u || !u->IsInWorld() || me->GetMap() != u->FindMap() || !u->IsAlive()) continue;
+                if (HasRole(BOT_ROLE_HEAL) && HealTarget(u, GetHealthPCT(u), diff))
+                    return;
+                if (Creature* cre = u->ToCreature())
+                    if (cre->GetIAmABot() || cre->IsPet())
+                        if (BuffTarget(u, diff))
+                            return;
+            }
+        }
+    }
+    //check if we have pointed heal target
+    if (HasRole(BOT_ROLE_HEAL))
+    {
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+        {
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+            {
+                if (ObjectGuid guid = pGroup->GetTargetIcons()[i])//check this one
+                {
+                    if (Unit* unit = ObjectAccessor::FindConnectedPlayer(guid))
+                    {
+                        if (unit->IsAlive() && me->GetMap() == unit->FindMap() &&
+                            master->GetVictim() != unit && unit->GetVictim() != master &&
+                            unit->GetReactionTo(master) >= REP_NEUTRAL)
+                        {
+                            if (HealTarget(unit, GetHealthPCT(unit), diff))
+                                return;
+                            //if (CureTarget(unit, getCureSpell(), diff))
+                            //    return;
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+// Attempt to resurrect dead players using class spells
+// Target is either player or its corpse
+void bot_minion_ai::RezGroup(uint32 REZZ, Player* gPlayer)
+{
+    if (!REZZ || !gPlayer || me->IsMounted()) return;
+    if (rezz_cd > 0 || Rand() > 10) return;
+
+    if (IAmFree())
+    {
+        if (me->HasAura(BERSERK))
+            return;
+
+        WorldObject* playerOrCorpse = GetNearbyRezTarget(30);
+        if (!playerOrCorpse)
+            return;
+
+        if (!playerOrCorpse->IsWithinLOSInMap(me))
+            me->Relocate(*playerOrCorpse);
+
+        Unit* target = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToUnit() : (Unit*)playerOrCorpse->ToCorpse();
+        if (doCast(target, REZZ)) //rezzing it
+        {
+            if (Player* player = playerOrCorpse->GetTypeId() == TYPEID_PLAYER ? playerOrCorpse->ToPlayer() : ObjectAccessor::FindPlayer(playerOrCorpse->ToCorpse()->GetOwnerGUID()))
+                BotWhisper("Rezzing You", player);
+            rezz_cd = 20;
+        }
+
+        return;
+    }
+
+    //TC_LOG_ERROR("entities.player", "RezGroup by %s", me->GetName().c_str());
+    Group* pGroup = gPlayer->GetGroup();
+    if (!pGroup)
+    {
+        Unit* target = master;
+        if (master->IsAlive()) return;
+        if (master->isResurrectRequested()) return; //resurrected
+        if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)master->GetCorpse();
+        if (!target || !target->IsInWorld()) return;
+        if (me->GetMap() != target->FindMap()) return;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", master);
+            rezz_cd = 60;
+        }
+        return;
+    }
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        Unit* target = tPlayer;
+        if (!tPlayer || tPlayer->IsAlive()) continue;
+        if (tPlayer->isResurrectRequested()) continue; //resurrected
+        if (Rand() > 5) continue;
+        if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+            target = (Unit*)tPlayer->GetCorpse();
+        if (!target || !target->IsInWorld()) continue;
+        if (master->GetMap() != target->FindMap()) continue;
+        if (me->GetDistance(target) > 30)
+        {
+            me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+            rezz_cd = 3;//6-9 sec reset
+            return;
+        }
+        else if (!target->IsWithinLOSInMap(me))
+            me->Relocate(*target);
+
+        if (doCast(target, REZZ))//rezzing it
+        {
+            BotWhisper("Rezzing You", tPlayer);
+            if (tPlayer != master)
+            {
+                std::string rezstr = "Rezzing ";
+                rezstr += tPlayer->GetName();
+                BotWhisper(rezstr.c_str(), master);
+            }
+            rezz_cd = 60;
+            return;
+        }
+    }
+}
+// CURES
+//cycle through the group sending members for cure
+void bot_minion_ai::CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff)
+{
+    if (!cureSpell || GC_Timer > diff) return;
+    if (me->getLevel() < 10 || pTarget->getLevel() < 10) return;
+    if (me->IsMounted()) return;
+    if (IsCasting() || Feasting()) return;
+
+    if (IAmFree())
+    {
+        if (CureTarget(me, cureSpell, diff))
+            return;
+        if (Creature* pet = me->GetBotsPet())
+            if (CureTarget(pet, cureSpell, diff))
+                return;
+
+        if (me->HasAura(BERSERK))
+            return;
+        /* stop spam buff/dispell from uncontrolled bots
+        GuidList targets;
+        GetNearbyFriendlyTargetsList(targets, 38);
+        for (GuidList::const_iterator itr = targets.begin(); itr != targets.end(); ++itr)
+            if (Unit* u = ObjectAccessor::GetUnit(*me, *itr))
+                if (CureTarget(u, cureSpell, diff))
+                    return;
+        */
+        return;
+    }
+
+    if (!master->GetMap()->IsRaid() && Rand() > 75) return;
+    //TC_LOG_ERROR("entities.player", "%s: CureGroup() on %s", me->GetName().c_str(), pTarget->GetName().c_str());
+    Group* pGroup = pTarget->GetGroup();
+    if (!pGroup)
+    {
+        if (CureTarget(master, cureSpell, diff))
+            return;
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* cre = itr->second;
+            if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+            if (CureTarget(cre, cureSpell, diff))
+                return;
+        }
+    }
+    else
+    {
+        bool Bots = false;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (!tPlayer || (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+            if (!Bots && tPlayer->HaveBot())
+                Bots = true;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            if (me->GetDistance(tPlayer) > 30) continue;
+            if (CureTarget(tPlayer, cureSpell, diff))
+                return;
+        }
+        if (!Bots) return;
+        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+        {
+            Player* tPlayer = itr->GetSource();
+            if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+            if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+            if (me->GetMap() != tPlayer->FindMap()) continue;
+            BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+            {
+                Creature* cre = it->second;
+                if (!cre || !cre->IsInWorld() || me->GetDistance(cre) > 30) continue;
+                if (CureTarget(cre, cureSpell, diff))
+                    return;
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::CureTarget(Unit* target, uint32 cureSpell, uint32 diff)
+{
+    return _canCureTarget(target, cureSpell, diff) ? doCast(target, cureSpell) : false;
+}
+// determines if unit has something to cure
+bool bot_minion_ai::_canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const
+{
+    if (!cureSpell || GC_Timer > diff) return false;
+    if (!target || !target->IsAlive()) return false;
+    if (me->getLevel() < 10 || target->getLevel() < 10) return false;
+    if (me->IsMounted()) return false;
+    if (IsCasting() || Feasting()) return false;
+    if (me->GetDistance(target) > 30) return false;
+    if (!IsInBotParty(target)) return false;
+
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(cureSpell);
+    if (!info)
+        return false;
+
+    uint32 dispelMask = 0;
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+        if (info->Effects[i].Effect == SPELL_EFFECT_DISPEL)
+            dispelMask |= SpellInfo::GetDispelMask(DispelType(info->Effects[i].MiscValue));
+
+    if (dispelMask == 0)
+        return false;
+
+    DispelChargesList dispel_list;
+    _getBotDispellableAuraList(target, me, dispelMask, dispel_list);
+
+    return !(dispel_list.empty());
+}
+
+void bot_minion_ai::_getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const
+{
+    if (dispelMask & (1 << DISPEL_DISEASE) && target->HasAura(50536))
+        dispelMask &= ~(1 << DISPEL_DISEASE);
+
+    Unit::AuraMap const& auras = target->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+    {
+        Aura* aura = itr->second;
+
+        if (aura->IsPassive())
+            continue;
+
+        AuraApplication* aurApp = aura->GetApplicationOfTarget(target->GetGUID());
+        if (!aurApp)
+            continue;
+
+        if (aura->GetSpellInfo()->GetDispelMask() & dispelMask)
+        {
+            //do not dispel positive auras from enemies and negative ones from friends
+            if (aurApp->IsPositive() == target->IsFriendlyTo(caster))
+                continue;
+
+            //skip Vampiric Touch to prevent being CCed just heal it out
+            if (aura->GetSpellInfo()->IsRankOf(sSpellMgr->GetSpellInfo(34914)))
+                continue;
+
+            uint8 charges = (aura->GetSpellInfo()->AttributesEx7 & SPELL_ATTR7_DISPEL_CHARGES) ? aura->GetCharges() : aura->GetStackAmount();
+            if (charges > 0)
+                dispelList.push_back(std::make_pair(aura, charges));
+        }
+    }
+}
+//protected
+bool bot_ai::HasAuraName(Unit* unit, uint32 spellId, ObjectGuid casterGuid, bool exclude) const
+{
+    ASSERT(spellId);
+
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::HasAuraName(uint32): no spellInfo found for spell %u!", spellId);
+        ASSERT(false);
+    }
+
+    uint8 loc = IAmFree() ? sWorld->GetDefaultDbcLocale() : master->GetSession()->GetSessionDbcLocale();
+    std::string const name = spellInfo->SpellName[loc];
+
+    return _hasAuraName(unit, name, casterGuid, exclude);
+}
+//private
+bool bot_ai::_hasAuraName(Unit* unit, std::string const spell, ObjectGuid casterGuid, bool exclude) const
+{
+    ASSERT(unit);
+    ASSERT(spell.length() != 0);
+
+    uint8 loc = IAmFree() ? sWorld->GetDefaultDbcLocale() : master->GetSession()->GetSessionDbcLocale();
+
+    Unit::AuraMap const& vAuras = unit->GetOwnedAuras();
+    SpellInfo const* spellInfo;
+    std::string name;
+
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        spellInfo = itr->second->GetSpellInfo();
+        name = spellInfo->SpellName[loc];
+        if (spell == name)
+            if (!casterGuid || (exclude == (casterGuid != itr->second->GetCasterGUID())))
+                return true;
+    }
+
+    return false;
+}
+//LIST AURAS
+// Debug: Returns bot's info to called player
+void bot_ai::_listAuras(Player* player, Unit* unit) const
+{
+    //if (player->GetSession()->GetSecurity() == SEC_PLAYER) return;
+    if (!player->IsGameMaster() && (IAmFree() || !IsInBotParty(player))) return;
+    if (!IsInBotParty(unit)) return;
+    ChatHandler ch(player->GetSession());
+    std::ostringstream botstring;
+    if (unit->GetTypeId() == TYPEID_PLAYER)
+        botstring << "player";
+    else if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        if (unit->ToCreature()->GetIAmABot())
+        {
+            botstring << "minion bot, master: ";
+            Player* owner = unit->ToCreature()->GetBotAI()->GetBotOwner();
+            botstring << (owner != unit ? owner->GetName() : "none");
+        }
+        else if (unit->ToCreature()->GetIAmABotsPet())
+        {
+            Player* owner = unit->ToCreature()->GetBotAI()->GetBotOwner();
+            Creature* creowner = unit->ToCreature()->GetBotPetAI()->GetCreatureOwner();
+            std::string const& ownername = owner != unit ? owner->GetName() : "none";
+            std::string const& creownername = creowner ? creowner->GetName() : "none";
+            botstring << "pet bot, master: ";
+            botstring << ownername;
+            botstring << ", creature owner: ";
+            botstring << creownername;
+            if (creowner)
+                botstring << " (" << creowner->GetGUID().GetCounter() << ')';
+        }
+    }
+    uint32 const bot_pet_player_class = unit->GetTypeId() == TYPEID_PLAYER ? unit->getClass() : unit->ToCreature()->GetBotAI()->GetBotClass();
+    ch.PSendSysMessage("ListAuras for %s (class: %u), %s", unit->GetName().c_str(), bot_pet_player_class, botstring.str().c_str());
+    uint8 locale = player->GetSession()->GetSessionDbcLocale();
+    Unit::AuraMap const &vAuras = unit->GetOwnedAuras();
+    for (Unit::AuraMap::const_iterator itr = vAuras.begin(); itr != vAuras.end(); ++itr)
+    {
+        SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+        if (!spellInfo)
+            continue;
+        uint32 id = spellInfo->Id;
+        SpellInfo const* learnSpellInfo = sSpellMgr->GetSpellInfo(spellInfo->Effects[0].TriggerSpell);
+        const std::string name = spellInfo->SpellName[locale];
+        std::ostringstream spellmsg;
+        spellmsg << id << " - |cffffffff|Hspell:" << id << "|h[" << name;
+        spellmsg << ' ' << localeNames[locale] << "]|h|r";
+        uint32 talentcost = GetTalentSpellCost(id);
+        uint32 rank = 0;
+        if (talentcost > 0 && spellInfo->GetNextRankSpell())
+            rank = talentcost;
+        else if (learnSpellInfo && learnSpellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        else if (spellInfo->GetNextRankSpell())
+            rank = spellInfo->GetRank();
+        if (rank > 0)
+            spellmsg << " Rank " << rank;
+        if (talentcost > 0)
+            spellmsg << " [talent]";
+        if (spellInfo->IsPassive())
+            spellmsg << " [passive]";
+        if ((spellInfo->Attributes & SPELL_ATTR0_HIDDEN_CLIENTSIDE) ||
+            (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+            spellmsg << " [hidden]";
+        if (unit->GetTypeId() == TYPEID_PLAYER && unit->ToPlayer()->HasSpell(id))
+            spellmsg << " [known]";
+        else if (unit == me && GetSpell(spellInfo->GetFirstRankSpell()->Id))
+            spellmsg << " [known]";
+
+        ch.PSendSysMessage(spellmsg.str().c_str());
+    }
+    for (uint8 i = STAT_STRENGTH; i != MAX_STATS; ++i)
+    {
+        std::string mystat;
+        switch (i)
+        {
+            case STAT_STRENGTH: mystat = "str"; break;
+            case STAT_AGILITY: mystat = "agi"; break;
+            case STAT_STAMINA: mystat = "sta"; break;
+            case STAT_INTELLECT: mystat = "int"; break;
+            case STAT_SPIRIT: mystat = "spi"; break;
+            default: mystat = "unk stat"; break;
+        }
+        float totalstat = unit->GetTotalStatValue(Stats(i));
+        if (unit == me && IsMinionAI())
+        {
+            int8 t = -1;
+            switch (i)
+            {
+                case STAT_STRENGTH:     t = BOT_ITEM_MOD_STRENGTH;  break;
+                case STAT_AGILITY:      t = BOT_ITEM_MOD_AGILITY;   break;
+                case STAT_STAMINA:      t = BOT_ITEM_MOD_STAMINA;   break;
+                case STAT_INTELLECT:    t = BOT_ITEM_MOD_INTELLECT; break;
+                case STAT_SPIRIT:       t = BOT_ITEM_MOD_SPIRIT;    break;
+                default:                                            break;
+            }
+
+            if (t >= BOT_ITEM_MOD_MANA)
+                totalstat += GetMinionAI()->GetTotalBotStat(t);
+        }
+        ch.PSendSysMessage("total %s: %.1f", mystat.c_str(), totalstat);
+    }
+    ch.PSendSysMessage("Melee AP: %.1f", unit->GetTotalAttackPowerValue(BASE_ATTACK));
+    ch.PSendSysMessage("Ranged AP: %.1f", unit->GetTotalAttackPowerValue(RANGED_ATTACK));
+    ch.PSendSysMessage("armor: %u", unit->GetArmor());
+    ch.PSendSysMessage("crit: %.2f pct", unit->GetUnitCriticalChance(BASE_ATTACK, me));
+    ch.PSendSysMessage("dodge: %.2f pct", unit->GetUnitDodgeChance());
+    ch.PSendSysMessage("parry: %.2f pct", unit->GetUnitParryChance());
+    ch.PSendSysMessage("block: %.2f pct", unit->GetUnitBlockChance());
+    ch.PSendSysMessage("block value: %u", unit->GetShieldBlockValue());
+    ch.PSendSysMessage("Damage taken melee: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_NORMAL));
+    ch.PSendSysMessage("Damage taken spell: %.3f", unit->GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, SPELL_SCHOOL_MASK_MAGIC));
+    if (unit != me || ap_mod > 0.0f)
+    {
+        WeaponAttackType type = BASE_ATTACK;
+        float attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+        ch.PSendSysMessage("Damage range mainhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+        ch.PSendSysMessage("Damage mult mainhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT));
+        ch.PSendSysMessage("Attack time mainhand: %.2f (%.1f DPS)", attSpeed,
+            ((unit->GetFloatValue(UNIT_FIELD_MINDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_MAINHAND, TOTAL_PCT) / attSpeed);
+        if (unit->haveOffhandWeapon())
+        {
+            type = OFF_ATTACK;
+            attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+            ch.PSendSysMessage("Damage range offhand: min: %.0f, max: %.0f", unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE));
+            ch.PSendSysMessage("Damage mult offhand: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT));
+            ch.PSendSysMessage("Attack time offhand: %.2f (%.1f DPS)", attSpeed,
+                ((unit->GetFloatValue(UNIT_FIELD_MINOFFHANDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXOFFHANDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_OFFHAND, TOTAL_PCT) / attSpeed);
+        }
+        if (unit != me ||
+            (me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2) &&
+            GetBotClass() != BOT_CLASS_PALADIN &&
+            GetBotClass() != BOT_CLASS_DEATH_KNIGHT &&
+            GetBotClass() != BOT_CLASS_DRUID &&
+            GetBotClass() != BOT_CLASS_SHAMAN))
+        {
+            type = RANGED_ATTACK;
+            attSpeed = (unit->GetAttackTime(type) * unit->m_modAttackSpeedPct[type])/1000.f;
+            ch.PSendSysMessage("Damage range ranged: min: %.1f, max: %.1f", unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE), unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE));
+            ch.PSendSysMessage("Damage mult ranged: %.3f", unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT)*unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT));
+            ch.PSendSysMessage("Attack time ranged: %.2f (%.1f DPS)", attSpeed,
+                ((unit->GetFloatValue(UNIT_FIELD_MINRANGEDDAMAGE) + unit->GetFloatValue(UNIT_FIELD_MAXRANGEDDAMAGE)) / 2) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, BASE_PCT) * unit->GetModifierValue(UNIT_MOD_DAMAGE_RANGED, TOTAL_PCT) / attSpeed);
+        }
+    }
+    ch.PSendSysMessage("base hp: %u", unit->GetCreateHealth());
+    ch.PSendSysMessage("total hp: %u", unit->GetMaxHealth());
+    ch.PSendSysMessage("base mana: %u", unit->GetCreateMana());
+    ch.PSendSysMessage("total mana: %u", unit->GetMaxPower(POWER_MANA));
+    if (unit->GetShapeshiftForm() != FORM_NONE && unit->getPowerType() != POWER_MANA)
+        ch.PSendSysMessage("cur mana: %u", unit->GetPower(POWER_MANA));
+    //DEBUG1
+    //ch.PSendSysMessage("STATS: ");
+    //ch.PSendSysMessage("Health");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_HEALTH, TOTAL_PCT));
+    //ch.PSendSysMessage("Mana");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_MANA, TOTAL_PCT));
+    //ch.PSendSysMessage("Stamina");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_STAMINA, TOTAL_PCT));
+    //ch.PSendSysMessage("Intellect");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_INTELLECT, TOTAL_PCT));
+    //ch.PSendSysMessage("Spirit");
+    //ch.PSendSysMessage("base value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_VALUE));
+    //ch.PSendSysMessage("base pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, BASE_PCT));
+    //ch.PSendSysMessage("total value: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_VALUE));
+    //ch.PSendSysMessage("total pct: %f", unit->GetModifierValue(UNIT_MOD_STAT_SPIRIT, TOTAL_PCT));
+    //END DEBUG1
+    if (unit == me)
+    {
+        ch.PSendSysMessage("melee damage mult: %.3f", _mult_dmg_melee);
+        ch.PSendSysMessage("spell damage mult: %.3f", _mult_dmg_spell);
+        ch.PSendSysMessage("healing done mult: %.3f", _mult_healing);
+        ch.PSendSysMessage("spell power: %i", me->SpellBaseDamageBonusDone(SPELL_SCHOOL_MASK_MAGIC));
+        ch.PSendSysMessage("mana regen: %.2f", float(regen_mp) + me->GetFloatValue(UNIT_FIELD_POWER_REGEN_FLAT_MODIFIER) * sWorld->getRate(RATE_POWER_MANA) * 0.001f);
+        ch.PSendSysMessage("haste: %s%.2f pct", (haste >= 0 ? "+" : ""), float(haste));
+        ch.PSendSysMessage("hit: +%.2f pct", hit);
+        ch.PSendSysMessage("expertise: %i (-%.2f pct)", expertise, float(expertise) * 0.25f);
+        ch.PSendSysMessage("spell penetration: %u", spellpen);
+
+        for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+        {
+            uint32 curresist = me->GetResistance(SpellSchools(i));
+
+            const char* resist = NULL;
+            switch (i)
+            {
+                case 1: resist = "holy";   break;
+                case 2: resist = "fire";   break;
+                case 3: resist = "nature"; break;
+                case 4: resist = "frost";  break;
+                case 5: resist = "shadow"; break;
+                case 6: resist = "arcane"; break;
+            }
+            ch.PSendSysMessage("Resistance %s: %u", resist, curresist);
+        }
+        ch.PSendSysMessage("BotCommandState: %s", m_botCommandState == COMMAND_FOLLOW ? "Follow" : m_botCommandState == COMMAND_ATTACK ? "Attack" : m_botCommandState == COMMAND_STAY ? "Stay" : m_botCommandState == COMMAND_ABANDON ? "Reset" : "none");
+        if (!IAmFree())
+            ch.PSendSysMessage("Follow distance: %u", master->GetBotFollowDist());
+
+        ch.PSendSysMessage("Boot timer: %i", _bootTimer);
+
+        //debug
+        //for (uint32 i = 0; i != 148; ++i)
+        //{
+        //    float val = me->GetFloatValue(i);
+        //    ch.PSendSysMessage("Float value at %u: %.9f", i, val);
+        //}
+
+        //ch.PSendSysMessage("healTargetIconFlags: %u", healTargetIconFlags);
+
+        //ch.PSendSysMessage("Roles:");
+        //for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+        //{
+        //    if (_roleMask & i)
+        //    {
+        //        switch (i)
+        //        {
+        //            case BOT_ROLE_TANK:
+        //                ch.PSendSysMessage("BOT_ROLE_TANK");
+        //                break;
+        //            case BOT_ROLE_DPS:
+        //                ch.PSendSysMessage("BOT_ROLE_DPS");
+        //                break;
+        //            case BOT_ROLE_HEAL:
+        //                ch.PSendSysMessage("BOT_ROLE_HEAL");
+        //                break;
+        //            //case BOT_ROLE_MELEE:
+        //            //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+        //            //    break;
+        //            case BOT_ROLE_RANGED:
+        //                ch.PSendSysMessage("BOT_ROLE_RANGED");
+        //                break;
+        //        }
+        //    }
+        //}
+
+        //ch.PSendSysMessage("Stat bonuses:");
+        //for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        //{
+        //    int32 val = 0;
+        //    uint32 const a = i;
+        //    for (uint8 j = 0; j != BOT_INVENTORY_SIZE; ++j)
+        //        val += static_cast<BotStat>(_stats[j])[a];
+
+        //    if (val != 0)
+        //        ch.PSendSysMessage("Item mod %u: bonus = %i", i, val);
+        //}
+    }
+}
+//SetStats
+// Health, Armor, Powers, Combat Ratings, and global update setup
+void bot_minion_ai::SetStats(bool force, bool shapeshift)
+{
+    uint8 myclass = _botclass;
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    if (myclass != DRUID_BEAR_FORM && myclass != DRUID_CAT_FORM && (master->isDead() || (!shouldUpdateStats && !force)))
+        return;
+    /*TC_LOG_ERROR("entities.player", "*etStats(): Updating bot %s, class: %u, race: %u, level %u, master: %s",
+        me->GetName().c_str(), myclass, myrace, mylevel, master->GetName().c_str());*/
+
+    switch (me->GetCreatureTemplate()->rank) //TODO: conditions
+    {
+        case CREATURE_ELITE_RARE:       mylevel += 1;   break;
+        case CREATURE_ELITE_ELITE:      mylevel += 2;   break;
+        case CREATURE_ELITE_RAREELITE:  mylevel += 3;   break;
+        default:                                        break;
+    }
+    mylevel = std::min<uint8>(mylevel, 83);
+
+    //Do not remove this code under any circumstances! You've been warned.
+    if (myclass == BOT_CLASS_DEATH_KNIGHT)
+        mylevel = std::max<uint8>(mylevel, 55);
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //reinit spells/passives/other
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells(); //this must stay before class passives
+        //ApplyPassives(_botclass);
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (!IsTempBot() && master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    //INIT STATS
+    //partially receive master's stats and get base class stats, we'll need all this later
+    uint8 tempclass = myclass == uint8(DRUID_BEAR_FORM) || myclass == uint8(DRUID_CAT_FORM) ? uint8(BOT_CLASS_DRUID) : myclass;
+    if (myclass >= BOT_CLASS_NORMAL_END)
+        sObjectMgr->GetPlayerClassLevelInfo(GetPlayerClass(), std::min<uint8>(mylevel, 80), _classinfo);
+    else
+        sObjectMgr->GetPlayerClassLevelInfo(tempclass, std::min<uint8>(mylevel, 80), _classinfo);
+    const CreatureBaseStats* const classstats = sObjectMgr->GetCreatureBaseStats(mylevel, me->getClass()); //use creature class
+
+    if (force)
+    {
+        PlayerLevelInfo info;
+        sObjectMgr->GetPlayerLevelInfo(me->getRace(), GetPlayerClass(), std::min<uint8>(mylevel, 80), &info);
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), info.stats[i]);
+    }
+
+    float value;
+    float tempval;
+
+    //INIT CLASS MODIFIERS
+    switch (myclass)
+    {
+        case BOT_CLASS_WARRIOR:      ap_mod = 1.0f; spp_mod = 0.0f; armor_mod = 1.4f;  crit_mod = 1.0f; haste_mod = 0.9f;  dodge_mod = 0.8f; parry_mod = 1.1f;  break;
+        case BOT_CLASS_DEATH_KNIGHT: ap_mod = 1.1f; spp_mod = 0.0f; armor_mod = 1.05f; crit_mod = 0.9f; haste_mod = 1.0f;  dodge_mod = 0.7f; parry_mod = 1.25f; break;
+        case BOT_CLASS_PALADIN:      ap_mod = 1.3f; spp_mod = 1.2f; armor_mod = 1.2f;  crit_mod = 0.8f; haste_mod = 0.85f; dodge_mod = 0.7f; parry_mod = 1.0f;  break;
+        case BOT_CLASS_ROGUE:        ap_mod = 1.3f; spp_mod = 0.3f; armor_mod = 0.9f;  crit_mod = 1.5f; haste_mod = 1.35f; dodge_mod = 1.5f; parry_mod = 0.8f;  break;
+        case BOT_CLASS_HUNTER:       ap_mod = 1.4f; spp_mod = 0.5f; armor_mod = 1.2f;  crit_mod = 1.2f; haste_mod = 1.5f;  dodge_mod = 1.1f; parry_mod = 1.15f; break;
+        case BOT_CLASS_SHAMAN:       ap_mod = 1.0f; spp_mod = 0.8f; armor_mod = 1.2f;  crit_mod = 1.0f; haste_mod = 1.3f;  dodge_mod = 1.0f; parry_mod = 0.8f;  break;
+        case BOT_CLASS_DRUID:        ap_mod = 0.0f; spp_mod = 1.3f; armor_mod = 0.9f;  crit_mod = 0.7f; haste_mod = 1.35f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_MAGE:         ap_mod = 0.0f; spp_mod = 0.9f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_PRIEST:       ap_mod = 0.0f; spp_mod = 1.2f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case BOT_CLASS_WARLOCK:      ap_mod = 0.0f; spp_mod = 1.0f; armor_mod = 0.7f;  crit_mod = 0.7f; haste_mod = 1.45f; dodge_mod = 0.5f; parry_mod = 0.0f;  break;
+        case DRUID_BEAR_FORM:        ap_mod = 1.2f; spp_mod = 1.0f; armor_mod = 1.85f; crit_mod = 1.0f; haste_mod = 0.75f; dodge_mod = 1.6f; parry_mod = 0.0f;  break;
+        case DRUID_CAT_FORM:         ap_mod = 1.5f; spp_mod = 1.0f; armor_mod = 1.2f;  crit_mod = 1.5f; haste_mod = 2.25f; dodge_mod = 1.4f; parry_mod = 0.0f;  break;
+
+        case BOT_CLASS_BM:           ap_mod = 2.5f; spp_mod = 0.0f; armor_mod = 0.8f;  crit_mod = 0.0f; haste_mod = 2.50f; dodge_mod = 0.0f; parry_mod = 0.0f;  break;
+
+        default:
+            TC_LOG_ERROR("entities.player", "minion_ai: *etStats():Init - unknown bot class %u, real class: %u, _botclass: %u", myclass, GetPlayerClass(), _botclass);
+            ap_mod = 0.0f; spp_mod = 0.0f; armor_mod = 0.0f;  crit_mod = 0.0f; haste_mod = 0.0f; dodge_mod = 0.0f;  parry_mod = 0.0f;  break;
+    }
+
+    //DAMAGE
+    _OnMeleeDamageUpdate(myclass);
+
+    //ARMOR
+    value = IAmFree() ? classstats->BaseArmor : me->getLevel() * 25; //over9000/2000 at 80
+    value += 2.f * (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY));
+    value += _getTotalBotStat(BOT_ITEM_MOD_ARMOR);
+
+    //class-specified
+    if (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE)
+        armor_mod += 0.6f;
+    if (GetPlayerClass() == BOT_CLASS_DRUID)
+    {
+        armor_mod += 0.1f;
+        if (myclass == DRUID_BEAR_FORM)
+            armor_mod += 0.33f;
+    }
+
+    value *= armor_mod;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor(); //buffs will be took in consideration here
+
+    //RESISTANCES
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = IAmFree() ? mylevel + 40 : std::max<int8>(int8(mylevel) - 20, 0);
+        value += _getTotalBotStat(BOT_ITEM_MOD_RESIST_HOLY + (i - 1));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, value);
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    value = IAmFree() ? 0.65f : 1.f;
+    if (mylevel > 77)
+        value -= ((mylevel - 77) * 0.05f); // +15% dmg reduction at 80
+
+    //class-specified
+    //Protector of the Pack
+    if (mylevel >= 45 && myclass == DRUID_BEAR_FORM)
+        value -= 0.12f;
+
+    dmg_taken = value;
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        //unapply old haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    value = std::max<int32>(int32(mylevel) - (IAmFree() ? 60 : 75), 0); //+20%/+5% haste at 80
+
+    //25.5 HR = 1% haste at 80
+    tempval = _getTotalBotStat(BOT_ITEM_MOD_HASTE_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HASTE_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HASTE_MELEE) | (1 << CR_HASTE_RANGED) | (1 << CR_HASTE_SPELL));
+    value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HASTE_RANGED) : std::max<float>(_getRatingMultiplier(CR_HASTE_MELEE), _getRatingMultiplier(CR_HASTE_SPELL)));
+    //value += (tempval / (25.5f * (mylevel < 11 ? 1.125f : mylevel - 5) / 75.f));
+    //value += (tempval / (25.5f * (float(mylevel - 5) / 75.f)));
+
+    value *= haste_mod;
+
+    if (myclass == DRUID_CAT_FORM) //give cat lots of haste
+        value += (mylevel/16) * 10.f; //or (mylevel/16) (+40...50% haste for cat);
+    if (myclass == CLASS_HUNTER)
+        value += 15.f; //ammo pouch haste bonus 15% for hunters (still applies to all haste types)
+
+    haste = int32(value);
+
+    if (haste)
+    {
+        //apply new haste
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    value = IAmFree() ? mylevel / 8 : mylevel / 16; // 10%/5% at 80
+
+    //32.5 HR = 1% hit at 80
+    tempval = _getTotalBotStat(BOT_ITEM_MOD_HIT_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_HIT_RATING);
+    tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_HIT_MELEE) | (1 << CR_HIT_RANGED) | (1 << CR_HIT_SPELL));
+    value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_HIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_HIT_MELEE), _getRatingMultiplier(CR_HIT_SPELL)));
+    //value += (tempval / (32.5f * (mylevel < 11 ? 0.72f : mylevel - 8) / 72.f));
+    //value += (tempval / (32.5f * (float(mylevel - 5) / 75.f)));
+
+    hit = value;
+
+    //EXPERTISE
+    if (IsMelee())
+    {
+        value = IAmFree() ? mylevel / 2 : mylevel / 20; //-10%/-1% dodge/parry at 80
+
+        //~8.0 ER = 1 expertise at 80
+        tempval = _getTotalBotStat(BOT_ITEM_MOD_EXPERTISE_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_EXPERTISE));
+        value += tempval * _getRatingMultiplier(CR_EXPERTISE);
+        //value += (tempval / (8.0f * (mylevel < 11 ? 0.9f : mylevel - 8) / 72.f));
+        //value += (tempval / (8.0f * (float(mylevel - 5) / 75.f)));
+
+        expertise = value;
+    }
+
+    //CRIT
+    if (crit_mod > 0.0f)
+    {
+        value = IAmFree() ? mylevel / 4 : mylevel / 16; //+20%/+5% at 80
+
+        if (GtChanceToMeleeCritEntry const* critRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY)) * critRatio->ratio * 100.0f;
+
+        //crit from intellect
+        if (GtChanceToSpellCritEntry const* critRatio = sGtChanceToSpellCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_INTELLECT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_INTELLECT)) * critRatio->ratio * 100.f;
+
+        //45 CR = 1% crit at 80
+        float tempval = _getTotalBotStat(BOT_ITEM_MOD_CRIT_MELEE_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_RANGED_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_SPELL_RATING) + _getTotalBotStat(BOT_ITEM_MOD_CRIT_RATING);
+        tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_CRIT_MELEE) | (1 << CR_CRIT_RANGED) | (1 << CR_CRIT_SPELL));
+        value += tempval * (myclass == BOT_CLASS_HUNTER ? _getRatingMultiplier(CR_CRIT_RANGED) : std::max<float>(_getRatingMultiplier(CR_CRIT_MELEE), _getRatingMultiplier(CR_CRIT_SPELL)));
+        //value += (tempval / (45.f * (mylevel < 11 ? 0.8f : mylevel - 8) / 72.f));
+        //value += (tempval / (45.f * (float(mylevel - 5) / 75.f)));
+
+        crit = value * crit_mod;
+    }
+
+    //PARRY
+    if (parry_mod > 0.0f)
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : mylevel / 16); //+10%/+5% at 80
+
+        if (mylevel >= 10)
+        {
+            //67 PR = 1% parry at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_PARRY_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_PARRY));
+            value += tempval * _getRatingMultiplier(CR_PARRY);
+            //value += (tempval / (67.f * (mylevel < 35 ? 5.5f : mylevel - 25) / 55.f));
+            //value += (tempval / (67.f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+        }
+
+        //if (IsTank()) //tanking bonus
+        //    value += 5.f;
+
+        //Forceful Deflection: 25% of strength goes to parry rating (~1% parry per 67 rating at 80)
+        if (myclass == BOT_CLASS_DEATH_KNIGHT/* && mylevel >= 55*/)
+            value += ((me->GetTotalStatValue(STAT_STRENGTH) - 18 + _getTotalBotStat(BOT_ITEM_MOD_STRENGTH)) / 4.f) / (float(mylevel) - (13.f / (float(mylevel - 40) / 40.f))); //~20 at 55, ~34 at 60 and 67 at 80
+
+        parry = value * parry_mod;
+    }
+
+    //DODGE
+    if (dodge_mod > 0.0f)
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 8 : mylevel / 16); //+10%/+5% at 80
+
+        if (GtChanceToMeleeCritEntry  const* dodgeRatio = sGtChanceToMeleeCritStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_LEVEL + mylevel-1))
+            value += (me->GetTotalStatValue(STAT_AGILITY) - 18 + _getTotalBotStat(BOT_ITEM_MOD_AGILITY)) * dodgeRatio->ratio * 100.0f;
+
+        if (mylevel >= 10)
+        {
+            //53 DR = 1% dodge at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_DODGE_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DODGE));
+            value += tempval * _getRatingMultiplier(CR_DODGE);
+            //value += (tempval / (53.f * (mylevel < 35 ? 7.15f : mylevel - 25) / 55.f));
+            //value += (tempval / (53.f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+        }
+
+        //if (IsTank())
+        //    value += 5.f;
+
+        dodge = value * dodge_mod;
+    }
+
+    //BLOCK
+    if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+    {
+        value = 5.0f + (IAmFree() ? mylevel / 4 : mylevel/ 16); //+20%/+5% at 80
+
+        if (mylevel >= 10)
+        {
+            //16.5 BR = 1% block at 80
+            float tempval = _getTotalBotStat(BOT_ITEM_MOD_BLOCK_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_BLOCK));
+            value += tempval * _getRatingMultiplier(CR_BLOCK);
+            //value += (tempval / (16.5f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (16.5f * (float(mylevel - 5) / 75.f)));
+            //125 DR = 1% block/parry/dodge at 80
+            tempval = _getTotalBotStat(BOT_ITEM_MOD_DEFENSE_SKILL_RATING);
+            tempval += me->GetTotalAuraModifierByMiscMask(SPELL_AURA_MOD_RATING, (1 << CR_DEFENSE_SKILL));
+            value += tempval * _getRatingMultiplier(CR_DEFENSE_SKILL) * 0.04f;
+            value += me->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_SKILL, SKILL_DEFENSE) * 0.04f;
+            //value += (tempval / (125.f * (mylevel < 35 ? 8.25f : mylevel - 25) / 55.f));
+            //value += (tempval / (125.f * (float(mylevel - 5) / 75.f)));
+
+            value += IsTank() * 10; //tank bonus
+        }
+
+        block = std::min<float>(value, 75.0f);
+
+        //BLOCK VALUE
+        value = float(mylevel + (mylevel >> 2)); //100 at 80
+        value += 0.5f * (me->GetTotalStatValue(STAT_STRENGTH) - 18);
+        value += 0.5f *_getTotalBotStat(BOT_ITEM_MOD_STRENGTH);
+        value += _getTotalBotStat(BOT_ITEM_MOD_BLOCK_VALUE);
+
+        //Shield Mastery
+        if (mylevel >= 20 && myclass == BOT_CLASS_WARRIOR)
+            value *= 1.3f;
+        //Redoubt
+        if (mylevel >= 45 && myclass == BOT_CLASS_PALADIN)
+            value *= 1.3f;
+
+        blockvalue = std::max<int32>(int32(value) - 10, 1);
+    }
+
+    //MANA
+    _OnManaUpdate(shapeshift);
+
+    //MANA REGEN
+    if (me->GetMaxPower(POWER_MANA) > 1)
+    {
+        value = IAmFree() ? mylevel * 5 : 0; //400/0 at 80
+        value += _getTotalBotStat(BOT_ITEM_MOD_MANA_REGENERATION);
+        //regen from spirit: 15 base, 1 per 5 spirit
+        value += 15.f + 0.2f * (me->GetTotalStatValue(STAT_SPIRIT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_SPIRIT));
+        //hunters just spend all mana in no time
+        //if (myclass == BOT_CLASS_HUNTER && mylevel > 20)
+        //    value += float((mylevel - 20) * 5); //300
+        if (myclass >= BOT_CLASS_EX_START)
+        {
+            if (myclass == BOT_CLASS_BM)
+                value = std::max<float>(value / 20, 1); //0.2 per sec
+        }
+
+        //regen from intellect: 1 int = 0.01 mana per second = 0.05 mp5
+        value += 0.05f * (me->GetTotalStatValue(STAT_INTELLECT) - 18 + _getTotalBotStat(BOT_ITEM_MOD_INTELLECT));
+
+        regen_mp = uint32(value);
+    }
+
+    //SPELL PENETRATION
+    value = IAmFree() ? mylevel : std::max<int32>((int8(mylevel) - 20), 0) / 3; //80/20 at 80
+    //~1 SPPR = 1 spell penetration
+    value += _getTotalBotStat(BOT_ITEM_MOD_SPELL_PENETRATION);
+    spellpen = uint32(value);
+
+    //SPELL POWER
+    if (spp_mod > 0.f)
+    {
+        value = IAmFree() ? std::max<int32>((int8(mylevel) - 30) * 80, 0) : std::max<int32>((int8(mylevel) - 30) * 3, 0); //+4000spp/+150spp at 80
+        value += _getTotalBotStat(BOT_ITEM_MOD_SPELL_POWER);
+
+        //class-specified mods
+        if (myclass == BOT_CLASS_PALADIN && mylevel >= 50)
+        {
+            //Touched by the Light / Sheath of Light - 60% of strength (30% attack power) to spell power
+            if (HasRole(BOT_ROLE_TANK | BOT_ROLE_DPS))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+            //Holy Guidance - 20% Intellect to spell power
+            else if (HasRole(BOT_ROLE_HEAL))
+                value += 0.2f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+        if (myclass == BOT_CLASS_PRIEST && mylevel >= 55)
+        {
+            //Spiritual Guidance - 25% Spirit to spell power
+            if (HasRole(BOT_ROLE_HEAL))
+                value += 0.25f * me->GetTotalStatValue(STAT_SPIRIT);
+            //Twisted Faith - 20% Spirit to spell power
+            else if (HasRole(BOT_ROLE_DPS))
+                value += 0.2f * me->GetTotalStatValue(STAT_SPIRIT);
+        }
+        if (myclass == BOT_CLASS_SHAMAN && mylevel >= 50)
+        {
+            //Mental Quickness - 30% attack power to spell power (only enhancement)
+            if (HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED))
+                value += 0.3f * me->GetTotalAttackPowerValue(BASE_ATTACK);
+        }
+        if (myclass == BOT_CLASS_DRUID && mylevel >= 30)
+        {
+            //Lunar Guidance - 12% Intellect to spell power (balance and resto possible)
+            if (HasRole(BOT_ROLE_DPS | BOT_ROLE_HEAL))
+                value += 0.12f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+        if (myclass == BOT_CLASS_MAGE && mylevel >= 45)
+        {
+            //Mind Mastery - 15% Intellect to spell power
+            //if (HasRole(BOT_ROLE_DPS))
+                value += 0.15f * me->GetTotalStatValue(STAT_INTELLECT);
+        }
+
+        spellpower = uint32(value * spp_mod);
+    }
+
+    //if init
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    //SetStats for pet
+    if (Creature* pet = me->GetBotsPet())
+        if (bot_pet_ai* petai = pet->GetBotPetAI())
+            petai->SetStats(force);
+
+    shouldUpdateStats = false;
+}
+
+void bot_pet_ai::SetStats(bool force, bool /*unk*/)
+{
+    uint8 mylevel = m_creatureOwner->getLevel();
+    uint8 petType = GetPetType(me);
+    if (petType == PET_TYPE_NONE || petType >= MAX_PET_TYPES) return;
+    if (!shouldUpdateStats && !force) return;
+    //TC_LOG_ERROR("entities.player", "*etStats(): Updating pet bot %s, type: %u, level %u, owner: %s, master: %s", me->GetName().c_str(), petType, mylevel, m_creatureOwner->GetName().c_str(), master->GetName().c_str());
+
+    //LEVEL
+    if (me->getLevel() != mylevel)
+    {
+        me->SetLevel(mylevel);
+        force = true; //restore powers on lvl update
+    }
+    if (force)
+    {
+        InitPowers();
+        InitSpells();
+        //ApplyPassives(_botclass);
+        ApplyClassPassives();
+    }
+
+    //PHASE
+    if (master->GetPhaseMask() != me->GetPhaseMask())
+        me->SetPhaseMask(master->GetPhaseMask(), true);
+
+    ////INIT STATS
+    if (force)
+        for (uint8 i = STAT_STRENGTH; i != MAX_STATS; i++)
+            me->SetCreateStat(Stats(i), 0.5f * m_creatureOwner->GetCreateStat(Stats(i)));
+
+    //INIT CLASS MODIFIERS
+    //STAT -- 'mod' -- used stat values to apply
+    //WARLOCK
+    //Stamina x0.3  -- health
+    //Armor   x0.35 -- armor
+    //Int     x0.3  -- crit/mana
+    //Spd     x0.15 -- spd (if has mana)
+    //AP      x0.57 -- attack power (if melee pet)
+    //Resist  x0.4  -- resistances
+    //MAGE
+    //
+    //SHAMAN
+    //
+    //HUNTER
+    //
+
+    switch (petType)
+    {
+        case PET_TYPE_VOIDWALKER:       ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;
+        //case PET_TYPE_FELHUNTER:        ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_FELGUARD:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_SUCCUBUS:         ap_mod = 0.57f; spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+        //case PET_TYPE_IMP:              ap_mod = 0.f;   spp_mod = 0.15f; crit_mod = 1.0f; break;//NYI
+
+        //case PET_TYPE_WATER_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_FIRE_ELEMENTAL:   ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+        //case PET_TYPE_EARTH_ELEMENTAL:  ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;//NYI
+
+        //case PET_TYPE_VULTURE:          ap_mod = 0.9f;  spp_mod = 1.0f; crit_mod = 1.2f; break;//NYI
+        default:
+            TC_LOG_ERROR("entities.player", "pet_ai: *etStats():Init - unknown pet type %u", petType);
+            ap_mod = 0.0f;  spp_mod = 0.0f; crit_mod = 0.0f; break;
+    }
+
+    //DAMAGE
+    if (ap_mod > 0.f)//do not bother casters
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                value = float(m_creatureOwner->GetBotAI()->GetBotSpellPower());
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case BOT_CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                TC_LOG_ERROR("entities.player", "*etStats():Damage - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+                value = 0.0f;
+                break;
+        }
+
+        me->SetModifierValue(UNIT_MOD_STAT_STRENGTH, BASE_VALUE, me->GetCreateStat(STAT_STRENGTH) - 9.f);
+        atpower = (me->GetTotalAuraModValue(UNIT_MOD_STAT_STRENGTH) * 2.f + value) * ap_mod;
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage();
+    }
+
+    //ARMOR
+    value = float(basearmor);
+    //get minion's armor and give 35% to pet (just as for real pets)
+    value += m_creatureOwner->GetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE) * 0.35f;
+    me->SetModifierValue(UNIT_MOD_ARMOR, BASE_VALUE, value);
+    me->UpdateArmor();
+
+    //RESISTANCES
+    //based on minion's resistances gain x0.4
+    for (uint8 i = SPELL_SCHOOL_HOLY; i != MAX_SPELL_SCHOOL; ++i)
+    {
+        value = float(m_creatureOwner->GetResistance(SpellSchools(i)));
+        me->SetModifierValue(UnitMods(UNIT_MOD_RESISTANCE_START + i), BASE_VALUE, 0.4f * value);
+        me->UpdateResistances(i);
+    }
+
+    //DAMAGE TAKEN
+    dmg_taken = m_creatureOwner->GetBotAI()->GetBotDamageTakenMod();
+
+    //HEALTH
+    _OnHealthUpdate();
+
+    //HASTE
+    if (haste)
+    {
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), false);
+        me->ApplyCastTimePercentMod(float(haste), false);
+    }
+
+    haste = m_creatureOwner->GetBotAI()->GetHaste();
+
+    if (haste)
+    {
+        for (uint8 att = BASE_ATTACK; att != MAX_ATTACK; ++att)
+            me->ApplyAttackTimePercentMod(WeaponAttackType(att), float(haste), true);
+        me->ApplyCastTimePercentMod(float(haste), true);
+    }
+
+    //HIT
+    hit = m_creatureOwner->GetBotAI()->GetHitRating();
+
+    //CRIT
+    if (CanCrit())
+    {
+        value = m_creatureOwner->GetUnitCriticalChance((BASE_ATTACK), me);
+        crit = value * crit_mod;
+    }
+
+    //PARRY
+    if (CanParry())
+    {
+        value = m_creatureOwner->GetUnitParryChance();
+        parry = value;
+    }
+
+    //DODGE
+    if (CanDodge())
+    {
+        value = m_creatureOwner->GetUnitDodgeChance();
+        value += IsTank() * 10;
+        dodge = value;
+    }
+
+    //MANA
+    _OnManaUpdate(false);
+
+    //MANA REGEN
+    regen_mp = m_creatureOwner->GetBotAI()->GetManaRegen();
+
+    //SPELL PENETRATION
+    spellpen = m_creatureOwner->GetBotAI()->GetBotSpellPenetration();
+
+    //SPELL POWER
+    if (spp_mod > 0.f)
+    {
+        switch (m_creatureOwner->GetBotClass())
+        {
+            case BOT_CLASS_WARLOCK:
+                value = m_creatureOwner->GetBotAI()->GetBotSpellPower();
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+                value = m_creatureOwner->GetTotalAttackPowerValue(BASE_ATTACK);
+                break;
+            case BOT_CLASS_HUNTER:
+                value = m_creatureOwner->GetTotalAttackPowerValue(RANGED_ATTACK);
+                break;
+            default: //some weird class or NYI
+                TC_LOG_ERROR("entities.player", "*etStats():Spellpower - unknown bot owner class %u", uint8(m_creatureOwner->GetBotClass()));
+                value = 0.f;
+                break;
+        }
+
+        spellpower = uint32(value * spp_mod);
+    }
+
+    if (force)
+    {
+        me->SetFullHealth();
+        me->SetPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+    }
+
+    shouldUpdateStats = false;
+}
+//Emotion-based action
+void bot_ai::ReceiveEmote(Player* player, uint32 emote)
+{
+    switch (emote)
+    {
+        case TEXT_EMOTE_BONK:
+            _listAuras(player, me);
+            break;
+        case TEXT_EMOTE_SALUTE:
+            _listAuras(player, player);
+            break;
+        case TEXT_EMOTE_STAND:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_STAY);
+            BotWhisper("Standing Still.", player);
+            break;
+        case TEXT_EMOTE_WAVE:
+            if (!IsMinionAI())
+                return;
+            if (master != player)
+            {
+                me->HandleEmoteCommand(EMOTE_ONESHOT_RUDE);
+                return;
+            }
+            SetBotCommandState(COMMAND_FOLLOW, true);
+            BotWhisper("Following!", player);
+            break;
+        default:
+            break;
+    }
+}
+
+//ISINBOTPARTY
+//Returns group members (and their npcbots too)
+//For now all your puppets are in your group automatically
+bool bot_ai::IsInBotParty(Unit const* unit) const
+{
+    if (!unit) return false;
+    if (unit == me || unit == master) return true;
+
+    if (IAmFree())
+    {
+        if (unit == me->GetBotsPet())
+            return true;
+
+        Player const* owner = NULL;
+
+        Creature const* bot = unit->ToCreature();
+        if (bot)
+        {
+            //controlled bot case
+            if (bot->GetBotAI() && !bot->IsFreeBot())
+                owner = bot->GetBotOwner();
+
+            //free bot / neutral case
+            if (bot->getFaction() == me->getFaction())
+                return true;
+        }
+
+        if (!owner)
+            owner = unit->GetCharmerOrOwnerPlayerOrPlayerItself();
+        if (owner && (owner->getFaction() == me->getFaction() || me->GetReactionTo(owner) >= REP_FRIENDLY))
+            return true;
+
+        if (unit->GetCharmerOrOwnerGUID() == me->GetGUID())
+            return true;
+
+        return false;
+    }
+
+    //cheap check
+    if (Group* gr = master->GetGroup())
+    {
+        //group member case
+        if (gr->IsMember(unit->GetGUID()))
+            return true;
+        //pointed target case
+        for (uint8 i = 0; i != TARGETICONCOUNT; ++i)
+            if (_healTargetIconFlags & GroupIconsFlags[i])
+                if (ObjectGuid guid = gr->GetTargetIcons()[i])//check this one
+                    if (guid == unit->GetGUID())
+                        if (unit->GetReactionTo(master) >= REP_NEUTRAL &&
+                            master->GetVictim() != unit &&
+                            unit->GetVictim() != master)
+                            return true;
+    }
+
+    //Player-controlled creature case
+    if (Creature const* cre = unit->ToCreature())
+    {
+        //npcbot/npcbot's pet case
+        if (Player* owner = cre->GetBotOwner())
+        {
+            if (owner == master)
+                return true;
+        }
+        //pets, minions, guardians etc.
+        else
+        {
+            ObjectGuid ownerGuid = unit->GetOwnerGUID();
+            //controlled by group member
+            if (Group* gr = master->GetGroup())
+                if (gr->IsMember(ownerGuid))
+                    return true;
+        }
+    }
+
+    return false;
+}
+
+//REFRESHAURA
+//Applies/reapplies aura stacks
+bool bot_ai::RefreshAura(uint32 spellId, int8 count) const
+{
+    if (!spellId)
+        return false;
+    SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+    if (!spellInfo)
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::RefreshAura(): Invalid spellInfo for spell %u! Bot - %s (botclass: %u, entry: %u)",
+            spellId, me->GetName().c_str(), _botclass, me->GetEntry());
+        return false;
+    }
+
+    if (me->HasAura(spellId))
+        me->RemoveAurasDueToSpell(spellId);
+
+    for (int8 i = 0; i < count; ++i)
+        me->AddAura(spellInfo, MAX_EFFECT_MASK, me);
+
+    return true;
+}
+//CHECKAURAS
+//Updates bot's condition once a while
+void bot_minion_ai::CheckAuras(bool force)
+{
+    opponent = me->GetVictim(); //safe
+
+    if (!force)
+    {
+        Regenerate();
+        _updateRations(); //safe
+    }
+
+    if (checkAurasTimer == 0)
+    {
+        checkAurasTimer = 10 + (IAmFree() ? 5 : master->GetNpcBotsCount() / 2);
+
+        if (needparty)
+        {
+            needparty = false;
+            if (!IAmFree()) //we could lose master
+                master->GetBotMgr()->AddBotToGroup(me);
+        }
+
+        if (_bootTimer == 0)
+        {
+            //timer will be cancelled at bot removal so we are always free here
+            //_bootTimer = -1; //Set in AbortTeleport()
+            master->m_Controlled.erase(me);
+            BotMgr::TeleportBot(me, master->GetMap(), master);
+            return;
+        }
+
+        if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY && opponent && !CCed(me, true))
+        {
+            if (IsMelee())
+            {
+                if (me->GetDistance(opponent) > 1.5f)
+                    GetInPosition(true);
+            }
+            else
+            {
+                CalculateAttackPos(opponent, attackpos);
+                if (me->GetDistance(attackpos) > 8)
+                    GetInPosition(true, opponent, &attackpos);
+            }
+        }
+        if (shouldUpdateStats && me->GetPhaseMask() == master->GetPhaseMask())
+            SetStats(false);
+        else if (!_powersTimer)
+        {
+            _powersTimer = 2000;
+            UpdateHealth();
+            UpdateMana();
+        }
+        if (rezz_cd > 0)
+            --rezz_cd;
+        if (clear_cd > 0)
+            --clear_cd;
+        else
+            clear_cd = 15;
+        if (_atHome && Rand() < 10)
+            _atHome = false;
+        return;
+    }
+    else if (force)
+    {
+        if (!opponent && !IAmFree())
+        {
+            if (master->isDead())
+            {
+                //If ghost move to corpse, else move to dead player
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                {
+                    Corpse* corpse = master->GetCorpse();
+                    if (corpse && me->GetMap() == corpse->FindMap() && !me->IsInCombat() && !me->HasUnitState(UNIT_STATE_MOVING) && !IsCasting() && !CCed(me) && me->GetDistance(corpse) > 5)
+                        me->GetMotionMaster()->MovePoint(corpse->GetMapId(), *corpse);
+                }
+                else
+                {
+                    if (m_botCommandState != COMMAND_FOLLOW || me->GetDistance(master) > 30 - 20 * (!me->IsWithinLOSInMap(master)))
+                        Follow(true);
+                }
+            }
+            else if (m_botCommandState != COMMAND_STAY && !IsCasting())
+            {
+                _calculatePos(pos);
+                uint8 followdist = master->GetBotFollowDist();
+                if (me->GetExactDist(&pos) > (followdist > 8 ? 4 + followdist/2*(!master->isMoving()) : 8))
+                    Follow(true, &pos); //check if doing nothing
+            }
+        }
+        if (!IsCasting())
+        {
+            if (me->IsInCombat() || !CanSheath())
+            {
+                if (!me->IsStandState())
+                {
+                    if (_botclass == BOT_CLASS_HUNTER)
+                    {
+                        if (me->GetSheath() != SHEATH_STATE_RANGED)
+                            me->SetSheath(SHEATH_STATE_RANGED);
+                    }
+                    else if (me->GetSheath() != SHEATH_STATE_MELEE)
+                        me->SetSheath(SHEATH_STATE_MELEE);
+                }
+            }
+            else if (me->IsStandState() && me->GetSheath() != SHEATH_STATE_UNARMED && Rand() < 50)
+            {
+                me->SetSheath(SHEATH_STATE_UNARMED);
+                if (_botclass == BOT_CLASS_HUNTER)
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_CHEER);
+            }
+        }
+
+        _updateMountedState();
+        _updateStandState();
+
+        //update flags
+        if (!me->IsInCombat() && !_evadeMode && _atHome && !me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+            me->SetFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+    }
+}
+void bot_pet_ai::CheckAuras(bool /*force*/)
+{
+    Regenerate();
+
+    if (checkAurasTimer > 0) return;
+    checkAurasTimer = 10 + IAmFree() ? 5 : master->GetNpcBotsCount() / 2;
+
+    if (m_botCommandState != COMMAND_FOLLOW && m_botCommandState != COMMAND_STAY)
+    {
+        opponent = me->GetVictim();
+        if (opponent)
+        {
+            switch (GetPetType(me))
+            {
+                case PET_TYPE_IMP:
+                    CalculateAttackPos(opponent, attackpos);
+                    if (me->GetDistance(attackpos) > 8)
+                        GetInPosition(true, opponent, &attackpos);
+                    break;
+                default:
+                    if (me->GetDistance(opponent) > 1.5f)
+                        GetInPosition(true);
+                    break;
+            }
+        }
+    }
+    if (clear_cd > 0)
+        --clear_cd;
+    else
+        clear_cd = 15;
+
+    return;
+}
+
+bool bot_ai::CanBotAttack(Unit const* target, int8 byspell) const
+{
+    if (!target)
+        return false;
+    if (!_botPvP && !IAmFree() && target->IsControlledByPlayer())
+        return false;
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    return
+       (target->IsAlive() &&
+       target->IsVisible() &&
+       //me->IsValidAttackTarget(target) &&
+       ((me->CanSeeOrDetect(target) && target->InSamePhase(me)) || CanSeeEveryone()) &&
+       //!target->HasStealthAura() && !target->HasInvisibilityAura() &&
+       (master->isDead() || target->GetTypeId() == TYPEID_PLAYER || target->IsPet() ||
+       (target->GetDistance(master) < foldist && me->GetDistance(master) < followdist)) &&//if master is killed pursue to the end
+        target->isTargetableForAttack() &&
+        !IsInBotParty(target) &&
+        (target->IsHostileTo(master) ||
+        (target->GetReactionTo(master) < REP_FRIENDLY/* && master->GetVictim() == target*/ && (master->IsInCombat() || target->IsInCombat())) ||//master has pointed this target
+        target->IsHostileTo(me)) &&//if master is controlled
+        //target->IsWithinLOSInMap(me) &&
+        (byspell == -1 || !target->IsImmunedToDamage(byspell ? SPELL_SCHOOL_MASK_MAGIC : SPELL_SCHOOL_MASK_NORMAL)));
+}
+//GETTARGET
+//Returns attack target or 'no target'
+Unit* bot_ai::_getTarget(bool byspell, bool ranged, bool &reset) const
+{
+    if (_evadeMode) //IAmFree() case only
+        return NULL;
+
+    Unit* u = master->GetVictim();
+    Unit* mytar = me->GetVictim();
+
+    //check if no need to change target
+    if (!mytar && IsMinionAI())
+        if (Creature* pet = me->GetBotsPet())
+            mytar = pet->GetVictim();
+    if (!mytar && IsPetAI())
+        mytar = me->GetBotPetAI()->GetCreatureOwner()->GetVictim();
+
+    //TC_LOG_ERROR("entities.player", "bot_ai::getTarget(): bot: %s, PvP = %u", me->GetName().c_str(), PvP);
+
+    if (u && u == mytar && !IAmFree())
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack common target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;//forced
+    }
+    //Follow if...
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float foldist = _getAttackDistance(float(followdist));
+    if (!u && master->IsAlive() && (me->GetDistance(master) > foldist || (mytar && master->GetDistance(mytar) > foldist && me->GetDistance(master) > foldist)))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s cannot attack target %s, too far away", me->GetName().c_str(), mytar ? mytar->GetName().c_str() : "");
+        return NULL;
+    }
+
+    if (u && !IAmFree() && (master->IsInCombat() || u->IsInCombat()) && !InDuel(u) && !IsInBotParty(u) && !(!_botPvP && !IAmFree() && u->IsControlledByPlayer()))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s starts attack master's target %s", me->GetName().c_str(), u->GetName().c_str());
+        return u;
+    }
+
+    if (mytar && (!IAmFree() || me->GetDistance(mytar) < BOT_MAX_CHASE_RANGE) && CanBotAttack(mytar, byspell) && !InDuel(mytar))
+    {
+        //TC_LOG_ERROR("entities.player", "bot %s continues attack its target %s", me->GetName().c_str(), mytar->GetName().c_str());
+        if (me->GetDistance(mytar) > (ranged ? 20.f : 5.f) && m_botCommandState != COMMAND_STAY && m_botCommandState != COMMAND_FOLLOW)
+            reset = true;
+        return mytar;
+    }
+
+    if (followdist == 0 && master->IsAlive())
+        return NULL; //do not bother
+
+    //check group
+    if (!IAmFree())
+    {
+        Group* gr = master->GetGroup();
+        if (!gr)
+        {
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                Creature* bot = itr->second;
+                if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                u = bot->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (bot->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                if (!pet || !pet->InSamePhase(me)) continue;
+                u = pet->GetVictim();
+                if (u && CanBotAttack(u, byspell) &&
+                    (pet->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+            }
+        }
+        else
+        {
+            for (GroupReference* ref = gr->GetFirstMember(); ref != NULL; ref = ref->next())
+            {
+                Player* pl = ref->GetSource();
+                if (!pl || !pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                if (me->GetMap() != pl->FindMap() || !pl->InSamePhase(me)) continue;
+                u = pl->GetVictim();
+                if (u && pl != master && CanBotAttack(u, byspell) &&
+                    (pl->IsInCombat() || u->IsInCombat()) &&
+                    (master->isDead() || master->GetDistance(u) < foldist))
+                {
+                    //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pl->GetName().c_str(), u->GetName().c_str());
+                    return u;
+                }
+                if (!pl->HaveBot()) continue;
+                BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                {
+                    Creature* bot = it->second;
+                    if (!bot || !bot->InSamePhase(me) || bot == me) continue;
+                    if (!bot->IsInWorld()) continue;
+                    if (me->GetMap() != bot->FindMap()) continue;
+                    u = bot->GetVictim();
+                    if (u && CanBotAttack(u, byspell) &&
+                        (bot->IsInCombat() || u->IsInCombat()) &&
+                        (master->isDead() || master->GetDistance(u) < foldist))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), bot->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                    Creature* pet = bot->GetIAmABot() ? bot->GetBotsPet() : NULL;
+                    if (!pet || !pet->InSamePhase(me)) continue;
+                    if (!pet->IsInWorld()) continue;
+                    if (me->GetMap() != pet->FindMap()) continue;
+                    u = pet->GetVictim();
+                    if (u && CanBotAttack(u, byspell) &&
+                        (pet->IsInCombat() || u->IsInCombat()) &&
+                        (master->isDead() || master->GetDistance(u) < foldist))
+                    {
+                        //TC_LOG_ERROR("entities.player", "bot %s hooked %s's victim %s", me->GetName().c_str(), pet->GetName().c_str(), u->GetName().c_str());
+                        return u;
+                    }
+                }
+            }
+        }
+    }
+
+    //check targets around
+    Unit* t = NULL;
+    float maxdist = InitAttackRange(float(followdist), ranged);
+    //first cycle we search non-cced target, then, if not found, check all
+    for (uint8 i = 0; i != 2; ++i)
+    {
+        if (!t)
+        {
+            bool attackCC = i;
+
+            CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+            Cell cell(p);
+            cell.SetNoCreate();
+
+            NearestHostileUnitCheck check(me, maxdist, byspell, this, attackCC);
+            Trinity::UnitLastSearcher <NearestHostileUnitCheck> searcher(master, t, check);
+            me->VisitNearbyObject(maxdist, searcher);
+        }
+    }
+
+    if (t && opponent && t != opponent)
+        reset = true;
+
+    //if (t)
+    //    TC_LOG_ERROR("entities.player", "bot %s has Found new target %s", me->GetName().c_str(), t->GetName().c_str());
+
+    return t;
+}
+//'CanAttack' function
+bool bot_ai::CheckAttackTarget(uint8 botOrPetType)
+{
+    if (IsDuringTeleport()/* || _evadeMode*/)
+    {
+        //me->AttackStop(); //already in CombatStop()
+        me->CombatStop(true);
+        return false;
+    }
+
+    if (IAmFree() && Feasting())
+        return false;
+
+    bool byspell = false, ranged = false, reset = false;
+
+    if (IsMinionAI())
+    {
+        switch (botOrPetType)
+        {
+            case BOT_CLASS_DRUID:
+                byspell = me->GetShapeshiftForm() == FORM_NONE ||
+                    me->GetShapeshiftForm() == FORM_TREE ||
+                    me->GetShapeshiftForm() == FORM_MOONKIN;
+                ranged = byspell;
+                break;
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_WARLOCK:
+            case BOT_CLASS_SHAMAN:
+                byspell = true;
+                break;
+            case BOT_CLASS_HUNTER:
+                ranged = true;
+                break;
+            case BOT_CLASS_DEATH_KNIGHT:
+            case BOT_CLASS_PALADIN:
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_BM:
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown bot class %u", botOrPetType);
+                return false;
+        }
+    }
+    else
+    {
+        switch (botOrPetType)
+        {
+            case PET_TYPE_IMP:
+                byspell = true;
+                ranged = true;
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - unknown pet type %u", botOrPetType);
+                return false;
+        }
+    }
+
+    opponent = _getTarget(byspell, ranged, reset);
+
+    if (!opponent)
+    {
+        //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s lost target", me->GetName().c_str());
+        if (me->GetVictim() || me->IsInCombat()/* || !me->getThreatManager().isThreatListEmpty()*/)
+        {
+            //TC_LOG_ERROR("entities.player", "bot_ai: CheckAttackTarget() - bot %s Evades", me->GetName().c_str());
+            if (me->GetVictim())
+                me->AttackStop();
+            else if (me->IsInCombat())
+                Evade(true);
+        }
+
+        return false;
+    }
+
+    if (reset)
+        m_botCommandState = COMMAND_ABANDON;//reset AttackStart()
+
+    if (opponent != me->GetVictim())
+        me->Attack(opponent, !ranged);
+
+    return true;
+}
+//POSITION
+void bot_ai::CalculateAttackPos(Unit* target, Position& pos) const
+{
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    float x(0),y(0),z(0),
+        dist = float(6 + urand(followdist/4, followdist/3)),
+        angle = target->GetAngle(me);
+    dist = std::min(dist, 20.f);
+    if (me->GetIAmABotsPet())
+        dist *= 0.5f;
+    float clockwise = RAND(1.f,-1.f);
+    for (uint8 i = 0; i != 5; ++i)
+    {
+        target->GetNearPoint(me, x, y, z, me->GetObjectSize()/2.f, dist, angle);
+        bool toofaraway = master->GetDistance(x,y,z) > (followdist > 28 ? 28.f : followdist < 20 ? 20.f : float(followdist));
+        bool outoflos = !target->IsWithinLOS(x,y,z);
+        if (toofaraway || outoflos)
+        {
+            if (toofaraway)
+                angle = target->GetAngle(master) + frand(0.f, M_PI*0.5f) * clockwise;
+            if (outoflos)
+                dist *= 0.5f;
+        }
+        else
+        {
+            dist *= 0.75f;
+            break;
+        }
+    }
+    pos.m_positionX = x;
+    pos.m_positionY = y;
+    pos.m_positionZ = z;
+}
+// Forces bot to chase opponent (if ranged then distance depends on follow distance)
+void bot_ai::GetInPosition(bool force, Unit* newtarget, Position* mypos)
+{
+    if (CCed(me, true) || JumpingFlyingOrFalling())
+        return;
+    if (!newtarget)
+        newtarget = me->GetVictim();
+    if (!newtarget)
+        return;
+    if ((!newtarget->IsInCombat() || m_botCommandState == COMMAND_STAY) && !force)
+        return;
+    if (IsCasting())
+        return;
+    if (UpdateImpossibleChase(newtarget))
+        return;
+    bool ranged = !IsMelee();
+    uint8 followdist = IAmFree() ? 100 : master->GetBotFollowDist();
+    if (ranged)
+    {
+        if (!force && newtarget->GetTypeId() == TYPEID_PLAYER &&
+            me->GetDistance(newtarget) < 6 + urand(followdist/4, followdist/3)) return;//do not allow constant runaway from player
+        if (!mypos)
+            CalculateAttackPos(newtarget, attackpos);
+        else
+        {
+            attackpos.m_positionX = mypos->m_positionX;
+            attackpos.m_positionY = mypos->m_positionY;
+            attackpos.m_positionZ = mypos->m_positionZ;
+        }
+        if (me->GetDistance(attackpos) > (_botclass == BOT_CLASS_HUNTER ? 4 : 8))
+            me->GetMotionMaster()->MovePoint(newtarget->GetMapId(), attackpos);
+    }
+    else if (!me->HasUnitState(UNIT_STATE_CHASE) || !me->HasUnitState(UNIT_STATE_CHASE_MOVE))
+        me->GetMotionMaster()->MoveChase(newtarget);
+
+    if (newtarget != me->GetVictim())
+        me->Attack(newtarget, !ranged);
+}
+
+void bot_ai::CheckAttackState()
+{
+    if (me->GetVictim())
+    {
+        if (HasRole(BOT_ROLE_DPS))
+            DoMeleeAttackIfReady();
+    }
+    else
+        Evade();
+}
+
+bool bot_ai::MoveBehind(Unit &target) const
+{
+    if (CCed(me, true)) return false;
+    if (JumpingFlyingOrFalling()) return false;
+    if (target.HasUnitState(UNIT_STATE_CASTING)) return false;
+    if (target.IsWithinCombatRange(me, ATTACK_DISTANCE) &&
+        target.HasInArc(M_PI, me)                       &&
+        !IsTank()                                       &&
+        (_botclass == BOT_CLASS_ROGUE ? target.GetVictim() != me || CCed(&target) : target.GetVictim() != me && !CCed(&target)))
+    {
+        float x(0),y(0),z(0);
+        target.GetNearPoint(me, x, y, z, me->GetObjectSize()/3, 0.1f, me->GetAngle(&target));
+        me->GetMotionMaster()->MovePoint(target.GetMapId(), x, y, z);
+        return true;
+    }
+    return false;
+}
+//MOUNT SUPPORT
+void bot_minion_ai::_updateMountedState()
+{
+    if (IAmFree())
+        return;
+    if (GetBotCommandState() != COMMAND_FOLLOW)
+        return;
+
+    bool aura = me->HasAuraType(SPELL_AURA_MOUNTED);
+    bool mounted = me->IsMounted();
+
+    //allow dismount
+    if (!CanMount() && !aura && !mounted)
+        return;
+
+    if ((!master->IsMounted() || aura != mounted || (me->IsInCombat() && opponent)) && (aura || mounted))
+    {
+        const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType &= ~INHABIT_AIR;
+        me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+        //me->RemoveUnitMovementFlag(MOVEMENTFLAG_HOVER);
+        me->SetCanFly(false);
+        me->SetDisableGravity(false);
+        me->RemoveUnitMovementFlag(MOVEMENTFLAG_FALLING);
+        me->Dismount();
+        return;
+    }
+    if (me->IsInCombat() || IsCasting() || me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING)) //IsInWater() is too much calculations
+        return;
+
+    if (master->IsMounted() && !me->IsMounted() && !master->IsInCombat() && !me->IsInCombat() && !me->GetVictim())
+    {
+        uint32 mount = 0;
+        Unit::AuraEffectList const &mounts = master->GetAuraEffectsByType(SPELL_AURA_MOUNTED);
+        if (!mounts.empty())
+        {
+            //Winter Veil addition
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                mount = master->CanFly() ? REINDEER_FLY : REINDEER;
+            else
+                mount = mounts.front()->GetId();
+        }
+        if (mount)
+        {
+            if (me->HasAuraType(SPELL_AURA_MOUNTED))
+                me->RemoveAurasByType(SPELL_AURA_MOUNTED);
+            if (Feasting())
+            {
+                me->RemoveAurasDueToSpell(DRINK);
+                me->RemoveAurasDueToSpell(EAT);
+            }
+
+            if (!GetSpell(mount))
+                InitSpellMap(mount, true); //learn
+
+            if (doCast(me, mount))
+            {
+                return;
+            }
+        }
+    }
+}
+//STANDSTATE
+void bot_minion_ai::_updateStandState() const
+{
+    if (IAmFree())
+    {
+        //if (!(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED) && !me->IsStandState())
+        //    me->SetStandState(UNIT_STAND_STATE_STAND);
+        return;
+    }
+    if (master->getStandState() == UNIT_STAND_STATE_STAND &&
+        me->getStandState() == UNIT_STAND_STATE_SIT &&
+        !(me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED))
+        me->SetStandState(UNIT_STAND_STATE_STAND);
+    if (CanSit() && !me->IsInCombat() && !me->isMoving() &&
+        (master->getStandState() == UNIT_STAND_STATE_SIT || (me->GetInterruptMask() & AURA_INTERRUPT_FLAG_NOT_SEATED) || Feasting()) &&
+        me->getStandState() == UNIT_STAND_STATE_STAND)
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+}
+//RATIONS
+void bot_minion_ai::_updateRations()
+{
+    bool noFeast = me->IsInCombat() || CCed(me);
+    if (noFeast || me->IsStandState())
+    {
+        if (feast_health)
+        {
+            feast_health = false;
+            me->RemoveAurasDueToSpell(EAT);
+        }
+        if (feast_mana)
+        {
+            feast_mana = false;
+            me->RemoveAurasDueToSpell(DRINK);
+        }
+
+        if (noFeast)
+            return;
+    }
+
+    //drink
+    if (!feast_mana && me->GetMaxPower(POWER_MANA) > 1 && !me->IsMounted() && !me->isMoving() && CanDrink() &&
+        !me->IsInCombat() && !IsCasting() && GetManaPCT(me) < 80 && urand(0, 100) < 20 &&
+        !me->HasAura(DRINK))
+    {
+        feast_mana = true;
+        mana_cd = 0;
+        me->CastSpell(me, DRINK);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (feast_mana)
+    {
+        mana_cd += lastdiff;
+        if (mana_cd >= RATIONS_CD && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA) && me->HasAura(DRINK))
+        {
+            while (mana_cd >= RATIONS_CD)
+            {
+                mana_cd -= RATIONS_CD;
+                //25000 / 1000 = 25: 4%
+                //25000 / 2000 = 12: 8.5%
+                me->ModifyPower(POWER_MANA, me->GetMaxPower(POWER_MANA) / (25000 / RATIONS_CD)); //4% per second if 1000
+            }
+        }
+    }
+
+    //eat
+    if (!feast_health && !me->IsMounted() && !me->isMoving() && CanEat() &&
+        !me->IsInCombat() && !IsCasting() && GetHealthPCT(me) < 80 && urand(0, 100) < 20 &&
+        !me->HasAura(EAT))
+    {
+        feast_health = true;
+        health_cd = 0;
+        me->CastSpell(me, EAT);
+        me->SetStandState(UNIT_STAND_STATE_SIT);
+    }
+    if (feast_health)
+    {
+        health_cd += lastdiff;
+        if (health_cd >= RATIONS_CD && me->GetHealth() < me->GetMaxHealth() && me->HasAura(EAT))
+        {
+            while (health_cd >= RATIONS_CD)
+            {
+                health_cd -= RATIONS_CD;
+                //20000 / 1000 = 20: 5%
+                //20000 / 2000 = 10: 10%
+                me->SetHealth(me->GetHealth() + me->GetMaxHealth() / (20000 / RATIONS_CD)); //5% per second if 1000
+            }
+        }
+    }
+
+    //check
+    if (feast_mana && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) >= me->GetMaxPower(POWER_MANA))
+    {
+        feast_mana = false;
+        me->RemoveAurasDueToSpell(DRINK);
+    }
+    if (feast_health && me->GetHealth() >= me->GetMaxHealth())
+    {
+        feast_health = false;
+        me->RemoveAurasDueToSpell(EAT);
+    }
+}
+
+void bot_minion_ai::Regenerate()
+{
+    if ((!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+    {
+        regenTimer_hp += lastdiff;
+        while (regenTimer_hp >= 2000)
+        {
+            regenTimer_hp -= 2000;
+            int32 add = me->IsPolymorphed() ? me->GetMaxHealth() / 3 : IAmFree() ? me->GetMaxHealth() / 5 : me->GetCreateHealth() / 50 + me->getLevel() / 3;
+            me->SetHealth(me->GetHealth() + add);
+        }
+    }
+
+    if (me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        regenTimer_mp += lastdiff;
+        while (regenTimer_mp >= 5000)
+        {
+            regenTimer_mp -= 5000;
+            int32 add = (!me->IsInCombat() && IAmFree()) ? me->GetMaxPower(POWER_MANA) / 5 : int32(regen_mp);
+            me->ModifyPower(POWER_MANA, add);
+        }
+    }
+}
+void bot_pet_ai::Regenerate()
+{
+    if (!regenTimer_hp && (!me->IsInCombat() || me->IsPolymorphed()) && me->GetHealth() < me->GetMaxHealth())
+    {
+        regenTimer_hp = 2000;
+        int32 add = me->IsPolymorphed() ? me->GetMaxHealth() / 3 : me->GetCreateHealth() / 33 + me->getLevel() / 3;
+        me->SetHealth(me->GetHealth() + add);
+    }
+
+    if (!regenTimer_mp && me->GetMaxPower(POWER_MANA) > 1 && me->GetPower(POWER_MANA) < me->GetMaxPower(POWER_MANA))
+    {
+        regenTimer_mp = 5000;
+        me->ModifyPower(POWER_MANA, regen_mp); //mp5
+    }
+}
+//PASSIVES
+// Used to apply common passives (run once)
+void bot_ai::ApplyPassives() const
+{
+    //me->ApplySpellImmune(0, IMMUNITY_STATE, SPELL_AURA_MOD_TAUNT, true);
+    //me->ApplySpellImmune(0, IMMUNITY_EFFECT, SPELL_EFFECT_ATTACK_ME, true);
+
+    ////DEPRECATEDmovement speed
+    //if (master->HasAuraType(SPELL_AURA_MOD_SPEED_ALWAYS) ||
+    //    master->HasAuraType(SPELL_AURA_MOD_SPEED_NOT_STACK) ||
+    //    master->HasAuraType(SPELL_AURA_MOD_INCREASE_SPEED))
+    //    RefreshAura(BOAR);
+
+    ////apply +healing taken
+    //RefreshAura(BOR, me->getLevel() >= 40 ? 1 : 0);//+40%
+
+    //if (IsTempBot())
+    //    return;
+
+    if (IsMinionAI())
+    {
+        //apply -threat mod
+        switch (_botclass)
+        {
+            case BOT_CLASS_WARRIOR:
+            case BOT_CLASS_DEATH_KNIGHT:
+                RefreshAura(RCP, 1 * !IsTank()); //-27%
+                break;
+            case BOT_CLASS_WARLOCK:
+            case BOT_CLASS_PRIEST:
+            case BOT_CLASS_MAGE:
+            case BOT_CLASS_ROGUE:
+            case BOT_CLASS_HUNTER:
+            case BOT_CLASS_SHAMAN:
+                RefreshAura(RCP, 3 * !IsTank()); //-87%
+                break;
+            case CLASS_PALADIN:
+            case CLASS_DRUID:
+            case BOT_CLASS_BM:
+                RefreshAura(RCP, 2 * !IsTank()); //-54%
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: ApplyPassives() - unknown bot class %u for bot %s (id: %u)",
+                    uint32(_botclass), me->GetName().c_str(), me->GetEntry());
+                break;
+        }
+        //apply +threat mods (1.43 * 1.45 = 2.0735; 1.0 + 0.43 + 0.45 = 1.88)
+        RefreshAura(THREAT, 1 * IsTank()); //+43%
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 1 * IsTank()); //+45%
+    }
+    else
+    {
+        switch (bot_pet_ai::GetPetType(me))
+        {
+            case PET_TYPE_VOIDWALKER:
+                break;
+            default:
+                TC_LOG_ERROR("entities.player", "bot_ai: ApplyPassives() - unknown pet type %u for bot %s (id: %u)",
+                    uint32(bot_pet_ai::GetPetType(me)), me->GetName().c_str(), me->GetEntry());
+                break;
+        }
+
+        RefreshAura(THREAT, 1 * IsTank()); //+43%
+        RefreshAura(DEFENSIVE_STANCE_PASSIVE, 2 * IsTank()); //+90%/-20%
+    }
+}
+//check if our party players are in duel. if so - ignore them, their opponents and any bots they have
+bool bot_ai::InDuel(Unit const* target) const
+{
+    if (!target) return false;
+    bool isbot = target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetBotAI();
+    Player const* player = target->GetTypeId() == TYPEID_PLAYER ? target->ToPlayer() : isbot ? target->ToCreature()->GetBotOwner()->ToPlayer() : NULL;
+    if (!player)
+    {
+        if (!target->IsControlledByPlayer())
+            return false;
+        player = target->GetCharmerOrOwnerPlayerOrPlayerItself();
+    }
+
+    return (player && player->duel && (IsInBotParty(player) || IsInBotParty(player->duel->opponent)));
+}
+////////////////
+//GRID SEARCHERS
+////////////////
+//Finds player or it's corpse for resurrection returned as WorldObject*
+WorldObject* bot_minion_ai::GetNearbyRezTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    WorldObject* target = NULL;
+
+    NearbyRezTargetCheck check(me, dist, this);
+    Trinity::WorldObjectSearcher <NearbyRezTargetCheck> searcher(me, target, check);
+
+    TypeContainerVisitor<Trinity::WorldObjectSearcher <NearbyRezTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+
+    return target;
+}
+//Used to find target for priest's dispels, mage's spellsteal and shaman's purge
+//Returns dispellable/stealable 'Any Hostile Unit Attacking BotParty'
+Unit* bot_minion_ai::FindHostileDispelTarget(float dist, bool stealable) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    HostileDispelTargetCheck check(me, dist, stealable, this);
+    Trinity::UnitLastSearcher <HostileDispelTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <HostileDispelTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds single target affected by given spell (and given caster if is)
+//Can check:
+//    hostile targets  (hostile = 0) <default>
+//    our party players (hostile = 1)
+//    our party members  (hostile = 2)
+//    any friendly target (hostile = 3)
+//    any target in range  (hostile = any other value)
+Unit* bot_minion_ai::FindAffectedTarget(uint32 spellId, ObjectGuid caster, float dist, uint8 hostile) const
+{
+    if (!spellId)
+        return NULL;
+    if ((hostile == 2 || hostile == 1) && IAmFree())
+    {
+        TC_LOG_ERROR("entities.player", "bot_ai::FindAffectedTarget(): hostile = %u while bot is free! Setting to 3...", hostile);
+        hostile = 3;
+    }
+    if (master->GetMap()->Instanceable())
+        dist = DEFAULT_VISIBILITY_INSTANCE;
+
+    CellCoord p(Trinity::ComputeCellCoord(master->GetPositionX(), master->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    AffectedTargetCheck check(caster, dist, spellId, master, hostile);
+    Trinity::UnitLastSearcher <AffectedTargetCheck> searcher(master, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <AffectedTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *master->GetMap(), *master, dist);
+    cell.Visit(p, grid_unit_searcher, *master->GetMap(), *master, dist);
+
+    return unit;
+}
+//Finds target for mage's polymorph or shaman's hex
+Unit* bot_minion_ai::FindPolyTarget(float dist, Unit* currTarget) const
+{
+    if (!currTarget)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    PolyUnitCheck check(me, dist, currTarget);
+    Trinity::UnitLastSearcher <PolyUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <PolyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for direct fear (warlock)
+Unit* bot_minion_ai::FindFearTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    FearUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <FearUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <FearUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for paladin's repentance
+Unit* bot_minion_ai::FindStunTarget(float dist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    StunUnitCheck check(me, dist);
+    Trinity::UnitLastSearcher <StunUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <StunUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for priest's shackles
+Unit* bot_minion_ai::FindUndeadCCTarget(float dist, uint32 spellId/* = 0*/) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    UndeadCCUnitCheck check(me, dist, spellId);
+    Trinity::UnitLastSearcher <UndeadCCUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <UndeadCCUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for druid's Entangling Roots
+Unit* bot_minion_ai::FindRootTarget(float dist, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    RootUnitCheck check(me, me->GetVictim(), dist, spellId);
+    Trinity::UnitLastSearcher <RootUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <RootUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds casting target (friend or enemy)
+Unit* bot_minion_ai::FindCastingTarget(float maxdist, float mindist, bool isFriend, uint32 spellId) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    CastingUnitCheck check(me, mindist, maxdist, isFriend, spellId);
+    Trinity::UnitLastSearcher <CastingUnitCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <CastingUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+// Returns target for AOE spell (blizzard, hurricane etc.) based on attackers count
+// Cycles through BotParty, first checks player and, if checked, npcbots
+// If checked, can return friendly target as target for AOE spell
+Unit* bot_minion_ai::FindAOETarget(float dist, bool checkbots, bool targetfriend) const
+{
+    if (IsCasting() || IAmFree())
+        return NULL;
+
+    Unit* unit = NULL;
+    Group* pGroup = master->GetGroup();
+    if (!pGroup)
+    {
+        AttackerSet m_attackers = master->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                    continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = master->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = master;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (!checkbots)
+            return unit;
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+        {
+            Creature* bot = itr->second;
+            if (!bot || !bot->IsAlive() || !bot->IsInWorld() || me->GetDistance(bot) > dist) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if ((*iter)->HasBreakableByDamageCrowdControlAura())
+                        continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+            if (unit) return unit;
+        }//end for
+        return unit;
+    }
+    bool Bots = false;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (!tPlayer) continue;
+        if (checkbots && tPlayer->HaveBot())
+            Bots = true;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+        if (me->GetDistance(tPlayer) > 40) continue;
+
+        AttackerSet m_attackers = tPlayer->getAttackers();
+        if (m_attackers.size() > 1)
+        {
+            uint32 mCount = 0;
+            for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+            {
+                if (!(*iter) || !(*iter)->IsAlive()) continue;
+                if ((*iter)->isMoving()) continue;
+                if (me->GetDistance(*iter) < dist)
+                    ++mCount;
+            }
+            if (mCount > 1)
+            {
+                Unit* u = tPlayer->GetVictim();
+                if (mCount > 3 && targetfriend == true)
+                    unit = tPlayer;
+                else if (u && FindSplashTarget(dist + 8, u))
+                    unit = u;
+            }//end if
+        }//end if
+        if (unit) return unit;
+    }//end for
+    if (!Bots) return NULL;
+    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+    {
+        Player* tPlayer = itr->GetSource();
+        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+        if (me->GetMap() != tPlayer->FindMap()) continue;
+        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+        {
+            Creature* bot = it->second;
+            if (!bot || !bot->IsAlive() || me->GetMap() != bot->FindMap()) continue;
+            if (!bot->IsInWorld()) continue;
+            if (me->GetDistance(bot) > 40) continue;
+
+            AttackerSet b_attackers = bot->getAttackers();
+            if (b_attackers.size() > 1)
+            {
+                uint32 mCount = 0;
+                for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                {
+                    if (!(*iter) || !(*iter)->IsAlive()) continue;
+                    if ((*iter)->isMoving()) continue;
+                    if (me->GetDistance(*iter) < dist)
+                        ++mCount;
+                }
+                if (mCount > 1)
+                {
+                    Unit* u = bot->GetVictim();
+                    if (mCount > 3 && targetfriend == true)
+                        unit = bot;
+                    else if (u && FindSplashTarget(dist + 8, u))
+                        unit = u;
+                }//end if
+            }//end if
+        }//end for
+        if (unit) return unit;
+    }//end for
+    return unit;
+}
+// Finds secondary target for spells like Cleave, Swipe, Mind Sear etc.
+Unit* bot_minion_ai::FindSplashTarget(float dist, Unit* To, float splashdist) const
+{
+    if (!To)
+        To = me->GetVictim();
+    if (!To)
+        return NULL;
+
+    if (me->GetDistance(To) > dist)
+        return NULL;
+
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    SecondEnemyCheck check(me, dist, splashdist, To, this);
+    Trinity::UnitLastSearcher <SecondEnemyCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <SecondEnemyCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, dist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, dist);
+
+    return unit;
+}
+//Finds target for hunter's Tranquilizing Shot (has dispellable magic or enrage effect)
+Unit* bot_minion_ai::FindTranquilTarget(float mindist, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    Unit* unit = NULL;
+
+    TranquilTargetCheck check(me, mindist, maxdist, this);
+    Trinity::UnitLastSearcher <TranquilTargetCheck> searcher(me, unit, check);
+
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitLastSearcher <TranquilTargetCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+
+    return unit;
+}
+//Finds all targets within given range with option for not having CC breaking auras
+//used for finding targets for spells which need reasonable amount of targets (ex. Death Knight AOE spells)
+void bot_minion_ai::GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist, float mindist, bool forCC) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyHostileUnitCheck check(me, maxdist, mindist, this, forCC);
+    Trinity::UnitListSearcher <NearbyHostileUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<Trinity::UnitListSearcher <NearbyHostileUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+//Finds all friendly targets within given range
+//used for finding targets to heal/buff for uncontrolled bots
+void bot_minion_ai::GetNearbyFriendlyTargetsList(GuidList &targets, float maxdist) const
+{
+    CellCoord p(Trinity::ComputeCellCoord(me->GetPositionX(), me->GetPositionY()));
+    Cell cell(p);
+    cell.SetNoCreate();
+
+    NearbyFriendlyUnitCheck check(me, maxdist, this);
+    UnitListSearcher <NearbyFriendlyUnitCheck> searcher(me, targets, check);
+
+    TypeContainerVisitor<UnitListSearcher <NearbyFriendlyUnitCheck>, WorldTypeMapContainer > world_unit_searcher(searcher);
+    TypeContainerVisitor<UnitListSearcher <NearbyFriendlyUnitCheck>, GridTypeMapContainer >  grid_unit_searcher(searcher);
+
+    cell.Visit(p, world_unit_searcher, *me->GetMap(), *me, maxdist);
+    cell.Visit(p, grid_unit_searcher, *me->GetMap(), *me, maxdist);
+}
+//////////
+//SPELLMAP
+//////////
+//Using first-rank spell as source, returns spell of max rank allowed for given caster
+uint32 bot_ai::InitSpell(Unit const* caster, uint32 spell)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(spell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpell(): No SpellInfo found for spell %u", spell);
+        return 0; //weird spell with no info, disable it
+    }
+
+    uint8 lvl = caster->getLevel();
+    if (lvl < info->BaseLevel) //only 1st rank spells check
+        return 0; //cannot use this spell
+
+    if (SpellInfo const* spInfo = info->GetNextRankSpell())
+    {
+        if (lvl < spInfo->BaseLevel)
+            return spell; //cannot use next rank, use this one
+        else
+            return InitSpell(caster, spInfo->Id); //can use next rank, forward check
+    }
+
+    return spell; //max rank, use this
+}
+//Using first-rank spell as source, returns spell of max rank allowed for given caster in given spellmap
+void bot_ai::InitSpellMap(uint32 basespell, bool forceadd, bool forwardRank)
+{
+    SpellInfo const* info = sSpellMgr->GetSpellInfo(basespell);
+    if (!info)
+    {
+        TC_LOG_ERROR("entities.player", "InitSpellMap(): No SpellInfo found for base spell %u", basespell);
+        return; //invalid spell id
+    }
+
+    uint8 lvl = me->getLevel();
+    uint32 spellId = 0;
+
+    while (info != NULL && forwardRank && (forceadd || lvl >= info->BaseLevel))
+    {
+        spellId = info->Id; //can use this spell
+        info = info->GetNextRankSpell(); //check next rank
+    }
+
+    BotSpell newSpell;
+    newSpell.first = spellId;
+    newSpell.second = GetSpellCooldown(basespell);
+    spells[basespell] = newSpell;
+}
+//Using first-rank spell as source, return current spell id
+uint32 bot_ai::GetSpell(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.first : 0;
+}
+//Using first-rank spell as source, returns cooldown on current spell
+uint32 bot_ai::GetSpellCooldown(uint32 basespell) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+    return itr != spells.end() ? itr->second.second : 0;
+}
+bool bot_ai::IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD, uint32 forcedTime) const
+{
+    BotSpellMap::const_iterator itr = spells.find(basespell);
+
+    if (itr != spells.end())
+    {
+        return
+        (itr->second.first != 0 &&
+        (!checkGCD || GC_Timer <= diff) &&
+        itr->second.second <= (forcedTime ? forcedTime : diff));
+    }
+
+    return false;
+}
+//Using first-rank spell as source, sets cooldown for current spell
+void bot_ai::SetSpellCooldown(uint32 basespell, uint32 msCooldown)
+{
+    //if (!msCooldown)
+    //    return;
+
+    BotSpellMap::iterator itr = spells.find(basespell);
+    if (itr != spells.end())
+    {
+        itr->second.second = msCooldown;
+        return;
+    }
+
+    InitSpellMap(basespell, true, false);
+
+    if (!GetSpell(basespell))
+        return;
+
+    SetSpellCooldown(basespell, msCooldown);
+}
+//Using first-rank spell as source, sets cooldown for spells of that category
+void bot_ai::SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown)
+{
+    if (!msCooldown)
+        return;
+
+    uint32 category = spellInfo->GetCategory();
+    if (!category)
+        return;
+
+    SpellInfo const* info;
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        //skip spell which has triggered this category cooldown
+        if (itr->second.first == spellInfo->Id && itr->second.second >= msCooldown)
+            continue;
+
+        info = sSpellMgr->GetSpellInfo(itr->second.first);
+        if (info && info->GetCategory() == category && itr->second.second < msCooldown)
+            itr->second.second = msCooldown;
+    }
+}
+//Using first-rank spell as source, disables certain spell for this bot
+void bot_ai::RemoveSpell(uint32 basespell)
+{
+    BotSpellMap::iterator itr = spells.find(basespell);
+    if (itr != spells.end())
+    {
+        itr->second.first = 0;
+        itr->second.second = 0; //unneeded
+    }
+}
+//Look in Creature::Update() for common timers
+void bot_ai::SpellTimers(uint32 diff)
+{
+    // spell must be initialized!!!
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        if (itr->second.second > diff)
+            itr->second.second -= diff;
+        else if (itr->second.second > 0)
+            itr->second.second = 0;
+    }
+}
+//Health magement for minions
+//Including health calcs, set
+void bot_minion_ai::_OnHealthUpdate() const
+{
+    if (IsTempBot())
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+    //TC_LOG_ERROR("entities.player", "_OnHealthUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetHealthPct(); // needs for regeneration
+    uint32 m_basehp = _classinfo->basehealth;
+    //TC_LOG_ERROR("entities.player", "class base health: %u", m_basehp);
+    me->SetCreateHealth(m_basehp);
+
+    float stamValue = std::max(me->GetTotalStatValue(STAT_STAMINA) - 18.f, 1.f); //remove base stamina (not calculated into health)
+    stamValue += _getTotalBotStat(BOT_ITEM_MOD_STAMINA);
+
+    //class-specified
+    if (GetPlayerClass() == BOT_CLASS_DRUID && myclass == DRUID_BEAR_FORM)
+    {
+        //Heart of the Wild: 10% stam bonus for bear
+        if (mylevel >= 35)
+            stamValue *= 1.1f;
+    }
+
+    //TC_LOG_ERROR("entities.player", "bot's stats to health add: Stamina (%f), value: %f", stamValue, stamValue * 10.f);
+    int32 hp_add = int32(stamValue) * 10;
+    hp_add += IAmFree() ? mylevel * 250.f : 0; //+20000/+0 hp at 80
+    hp_add += _getTotalBotStat(BOT_ITEM_MOD_HEALTH);
+    int32 miscVal = mylevel * 3 - 1;
+    hp_add += miscVal;
+    //TC_LOG_ERROR("entities.player", "health to add after slot mod: %i", hp_add);
+    uint32 m_totalhp = m_basehp + hp_add; //m_totalhp = uint32(float(m_basehp + hp_add) * stammod);
+    //TC_LOG_ERROR("entities.player", "total base health: %u", m_totalhp);
+    uint8 bonuspct = 0;
+    //bonuspct += 35 * IsTank();
+    bonuspct += 8 * (GetBotStance() == DEATH_KNIGHT_FROST_PRESENCE);
+    if (bonuspct)
+        m_totalhp = (m_totalhp * (100 + bonuspct)) / 100;
+    m_totalhp = float(uint32(m_totalhp) + (10 - (uint32(m_totalhp) % 10)));
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp)); //replaces base hp at max lvl
+    me->UpdateMaxHealth(); //will use our values we just set (update base health and buffs)
+    //TC_LOG_ERROR("entities.player", "overall hp: %u", me->GetMaxHealth());
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana management for minions
+//Including calcs and set
+void bot_minion_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    if (IsTempBot())
+        return;
+
+    uint8 myclass = _botclass;
+    uint8 mylevel = master->getLevel();
+    if (myclass == BOT_CLASS_DRUID && GetBotStance() != BOT_STANCE_NONE)
+        myclass = GetBotStance();
+
+    //TC_LOG_ERROR("entities.player", "_OnManaUpdate(): updating bot %s", me->GetName().c_str());
+    float pct = me->GetMaxPower(POWER_MANA) == 0 ? 100 : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = _classinfo->basemana;
+    if (myclass == BOT_CLASS_BM)
+        m_basemana = std::max<int32>(240 + (int32(mylevel - 20) * 5) - 225, 255); // 240 at 1, 540 at 81
+    //TC_LOG_ERROR("entities.player", "classinfo base mana = %f", m_basemana);
+
+    //decrease base mana for bots (allows using more mana)
+    me->SetCreateMana(uint32(m_basemana * 0.667f)); //set base mana, critical
+
+    float intValue = me->GetTotalStatValue(STAT_INTELLECT) - 18.f; //remove base int (not calculated into mana)
+    intValue += _getTotalBotStat(BOT_ITEM_MOD_INTELLECT);
+    m_basemana += intValue * 15.0f;
+    m_basemana += IAmFree() ? mylevel * 125.f : 0; //+10000/+0 mana at 80
+    m_basemana += _getTotalBotStat(BOT_ITEM_MOD_MANA);
+    m_basemana = float(uint32(m_basemana) - (uint32(m_basemana) % 5));
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f)); //restore pct
+}
+//Melee damage for minions (melee classes only)
+//Calculation is based on master's attack power if melee/hunter or spellpower
+void bot_minion_ai::_OnMeleeDamageUpdate(uint8 myclass) const
+{
+    if (IsTempBot())
+        return;
+
+    if (ap_mod < 0.1f) return; //do not bother casters
+    //TC_LOG_ERROR("entities.player", "_OnMeleeDamageUpdate: Updating bot %s", me->GetName().c_str());
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        float weap_damage_base = _getBotStat(i, BOT_ITEM_MOD_DAMAGE);
+        weap_damage_base += IAmFree() ? me->getLevel() * 3.75f : 0; //+300/+20 dam at 80
+        me->SetModifierValue(UnitMods(UNIT_MOD_DAMAGE_MAINHAND + i), BASE_VALUE, _getBotStat(i, BOT_ITEM_MOD_DAMAGE));
+    }
+
+    float atpower = IAmFree() ? me->getLevel() * 75.f : std::max(me->getLevel() - 40.f, 0.f) * 10.f; //+6000/+400 base ap at 80
+    atpower += _getTotalBotStat(BOT_ITEM_MOD_ATTACK_POWER) + _getTotalBotStat(BOT_ITEM_MOD_RANGED_ATTACK_POWER);
+    atpower += 2.f * ((me->GetTotalStatValue(STAT_STRENGTH) - 18) + (me->GetTotalStatValue(STAT_AGILITY) - 18));
+    atpower += 2.f * (_getTotalBotStat(BOT_ITEM_MOD_STRENGTH) + _getTotalBotStat(BOT_ITEM_MOD_AGILITY));
+
+    Unit::AuraEffectList const& mAPbyStat = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT);
+    for (Unit::AuraEffectList::const_iterator i = mAPbyStat.begin(); i != mAPbyStat.end(); ++i)
+        atpower += CalculatePct(me->GetStat(Stats((*i)->GetMiscValue())), (*i)->GetAmount());
+
+    Unit::AuraEffectList const& mAPbyArmor = me->GetAuraEffectsByType(SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR);
+    for (Unit::AuraEffectList::const_iterator iter = mAPbyArmor.begin(); iter != mAPbyArmor.end(); ++iter)
+        atpower += int32(me->GetArmor() / (*iter)->GetAmount());
+
+    if (GetPlayerClass() == CLASS_DRUID && (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM))
+    {
+        atpower += _getTotalBotStat(BOT_ITEM_MOD_FERAL_ATTACK_POWER);
+        //Predatory Strikes
+        if (me->getLevel() >= 25)
+        {
+            atpower += me->getLevel() * 2 / 3;
+            atpower += 0.2f * (
+                _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_FERAL_ATTACK_POWER)
+                + _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_ATTACK_POWER)
+                + _getBotStat(BOT_SLOT_MAINHAND, BOT_ITEM_MOD_RANGED_ATTACK_POWER)
+                );
+        }
+    }
+
+    atpower *= ap_mod;
+    me->SetModifierValue(UNIT_MOD_ATTACK_POWER, BASE_VALUE, atpower);
+    me->UpdateAttackPowerAndDamage();
+    if (myclass == BOT_CLASS_HUNTER || myclass == BOT_CLASS_ROGUE)
+    {
+        me->SetModifierValue(UNIT_MOD_ATTACK_POWER_RANGED, BASE_VALUE, atpower);
+        me->UpdateAttackPowerAndDamage(true);
+    }
+}
+//Health for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnHealthUpdate() const
+{
+    uint8 mylevel = master->getLevel();
+    float hp_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:   hp_mult = 11.f; break;
+        default:                    hp_mult = 10.f; break;
+    }
+    float pct = me->GetHealthPct();
+    uint32 m_basehp = me->GetCreateHealth();
+    float stamValue = me->GetTotalStatValue(STAT_STAMINA) - 18.f; //remove base stamina (not calculated into health)
+    uint32 hp_add = uint32(stamValue * hp_mult);
+    hp_add += (m_creatureOwner->GetMaxHealth() - m_creatureOwner->GetCreateHealth()) / 3;
+    uint8 miscVal = GetPetType(me) * mylevel;
+    hp_add += miscVal;
+    uint32 m_totalhp = m_basehp + hp_add;
+    if (IsTank())
+        m_totalhp = (m_totalhp * 135) / 100; //35% hp bonus for tanks
+    me->SetModifierValue(UNIT_MOD_HEALTH, BASE_VALUE, float(m_totalhp));
+    me->UpdateMaxHealth(); //will use values set (update base health and buffs)
+    me->SetHealth(uint32(0.5f + float(me->GetMaxHealth()) * pct / 100.f)); //restore pct
+}
+//Mana for pets
+//Same as for minions just simplified (modified to match real pets' values)
+void bot_pet_ai::_OnManaUpdate(bool /*shapeshift*/)
+{
+    if (me->GetMaxPower(POWER_MANA) <= 1)
+        return;
+
+    uint8 mylevel = m_creatureOwner->getLevel();
+    float mana_mult;
+    switch (GetPetType(me))
+    {
+        case PET_TYPE_VOIDWALKER:   mana_mult = 11.5f;  break;
+        default:                    mana_mult = 15.f;   break;
+    }
+    float pct = me->GetMaxPower(POWER_MANA) == 0 ? 100 : (float(me->GetPower(POWER_MANA)) * 100.f) / float(me->GetMaxPower(POWER_MANA));
+    float m_basemana = float(me->GetCreateMana());
+    m_basemana += me->GetTotalStatValue(STAT_INTELLECT) * mana_mult; //remove base stamina (not calculated into mana)
+    m_basemana += (m_creatureOwner->GetMaxPower(POWER_MANA) - m_creatureOwner->GetCreateMana()) / 3;
+    m_basemana += (GetPetType(me) * mylevel);
+    me->SetModifierValue(UNIT_MOD_MANA, BASE_VALUE, m_basemana);
+    me->UpdateMaxPower(POWER_MANA);
+    me->SetPower(POWER_MANA, uint32(0.5f + float(me->GetMaxPower(POWER_MANA)) * pct / 100.f));//restore pct
+}
+//Sends all master's bots a message to not try to evade for a certain period of time
+//void bot_ai::SendPartyEvadeAbort() const
+//{
+//    ASSERT(!IAmFree());
+//
+//    BotMap const* map = master->GetBotMgr()->GetBotMap();
+//    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+//        if (Creature* bot = itr->second)
+//            if (bot_minion_ai* ai = bot->GetBotMinionAI())
+//                ai->SetEvadeTimer(50);
+//}
+//Removes buggy bots' threat from party, so no 'stuck in combat' bugs form bot mod
+//optionally interrupts casted spell if target is dead for bot and it's pet
+void bot_minion_ai::Evade(bool force)
+{
+    if (me->HasUnitState(UNIT_STATE_CASTING))
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = me->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            me->InterruptSpell(CurrentSpellTypes(i), false, false);
+    }
+
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet && m_botsPet->HasUnitState(UNIT_STATE_CASTING))
+    {
+        for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+            if (Spell* spell = m_botsPet->GetCurrentSpell(CurrentSpellTypes(i)))
+                if (!spell->GetSpellInfo()->IsChanneled())
+                    if (Unit* u = spell->m_targets.GetUnitTarget())
+                        if (!u->IsAlive() && !IsInBotParty(u))
+                            m_botsPet->InterruptSpell(CurrentSpellTypes(i), false, false);
+    }
+
+    if (CCed(me)) return;
+    if (!force && Rand() > 10) return;
+    EnterEvadeMode(force);
+    if (!force && !master->IsInCombat() && !me->IsInCombat() && (!m_botsPet || !m_botsPet->IsInCombat())) return;
+    if (!force && CheckAttackTarget(_botclass)) return;
+
+    if (master->IsInCombat() && !IAmFree())
+    {
+        if (!master->getHostileRefManager().isEmpty())
+        {
+            GuidSet Set;
+            HostileReference* ref = master->getHostileRefManager().getFirst();
+            while (ref)
+            {
+                Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                Set.insert(ref->getUnitGuid());
+                ref = ref->next();
+            }
+            for (GuidSet::const_iterator i = Set.begin(); i != Set.end(); ++i)
+            {
+                Unit* unit = ObjectAccessor::FindConnectedPlayer(*i);
+                if (unit && (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat()))
+                {
+                    master->getHostileRefManager().deleteReference(unit);
+                    //unit->getHostileRefManager().deleteReference(master);
+                }
+            }
+        }
+
+        return;
+    }
+
+    if (!master->IsInCombat() || IAmFree())
+    {
+        if (IAmFree())
+        {
+            //me->DeleteThreatList();
+            if (!me->getHostileRefManager().isEmpty())
+            {
+                GuidSet Set;
+                HostileReference* ref = me->getHostileRefManager().getFirst();
+                while (ref)
+                {
+                    Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                    Set.insert(ref->getUnitGuid());
+                    ref = ref->next();
+                }
+                for (GuidSet::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = ObjectAccessor::FindConnectedPlayer(*i);
+                    if (!unit || !unit->InSamePhase(me)) continue;
+                    if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        me->getHostileRefManager().deleteReference(unit);
+                        //unit->getHostileRefManager().deleteReference(me);
+                    }
+                }
+            }
+            if (Creature* m_botsPet = me->GetBotsPet())
+            {
+                //m_botsPet->DeleteThreatList();
+                if (!m_botsPet->getHostileRefManager().isEmpty())
+                {
+                    GuidSet Set;
+                    HostileReference* ref = m_botsPet->getHostileRefManager().getFirst();
+                    while (ref)
+                    {
+                        Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                        Set.insert(ref->getUnitGuid());
+                        ref = ref->next();
+                    }
+                    for (GuidSet::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = ObjectAccessor::FindConnectedPlayer(*i);
+                        if (!unit || !unit->InSamePhase(me)) continue;
+                        if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            m_botsPet->getHostileRefManager().deleteReference(unit);
+                            //unit->getHostileRefManager().deleteReference(m_botsPet);
+                        }
+                    }
+                }
+            }
+
+            return;
+        }
+        //SendPartyEvadeAbort();
+        BotMap const* map = master->GetBotMgr()->GetBotMap();
+        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+        {
+            Creature* cre = it->second;
+            if (!cre) continue;
+            if (cre->IsInCombat())
+            {
+                //cre->DeleteThreatList();
+                if (!cre->getHostileRefManager().isEmpty())
+                {
+                    GuidSet Set;
+                    HostileReference* ref = cre->getHostileRefManager().getFirst();
+                    while (ref)
+                    {
+                        Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                        Set.insert(ref->getUnitGuid());
+                        ref = ref->next();
+                    }
+                    for (GuidSet::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                    {
+                        Unit* unit = ObjectAccessor::FindConnectedPlayer(*i);
+                        if (!unit || !unit->InSamePhase(me)) continue;
+                        if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                        {
+                            cre->getHostileRefManager().deleteReference(unit);
+                            //unit->getHostileRefManager().deleteReference(cre);
+                        }
+                    }
+                }
+            }
+
+            Creature* m_botsPet = cre->GetBotsPet();
+            if (!m_botsPet || !m_botsPet->IsInCombat()) continue;
+            //m_botsPet->DeleteThreatList();
+            if (!m_botsPet->getHostileRefManager().isEmpty())
+            {
+                GuidSet Set;
+                HostileReference* ref = m_botsPet->getHostileRefManager().getFirst();
+                while (ref)
+                {
+                    Set.insert(ref->GetSource()->GetOwner()->GetGUID());
+                    Set.insert(ref->getUnitGuid());
+                    ref = ref->next();
+                }
+                for (GuidSet::const_iterator i = Set.begin(); i != Set.end(); ++i)
+                {
+                    Unit* unit = ObjectAccessor::FindConnectedPlayer(*i);
+                    if (!unit || !unit->InSamePhase(me)) continue;
+                    if (unit->IsFriendlyTo(me) || IsInBotParty(unit) || !unit->IsInCombat())
+                    {
+                        m_botsPet->getHostileRefManager().deleteReference(unit);
+                        //unit->getHostileRefManager().deleteReference(m_botsPet);
+                    }
+                }
+            }
+        }
+    }
+}
+//SpellHit()... OnSpellHit()
+void bot_ai::OnSpellHit(Unit* caster, SpellInfo const* spell)
+{
+    for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+    {
+        uint32 auraname = spell->Effects[i].ApplyAuraName;
+        //remove pet on mount
+        if (auraname == SPELL_AURA_MOUNTED)
+        {
+            me->SetBotsPetDied();
+            if (master->HasAuraType(SPELL_AURA_MOD_INCREASE_VEHICLE_FLIGHT_SPEED) ||
+                master->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED))
+            {
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->InhabitType |= INHABIT_AIR;
+                //me->AddUnitMovementFlag(MOVEMENTFLAG_HOVER);
+                me->SetCanFly(true);
+                me->SetDisableGravity(true);
+                me->SetSpeed(MOVE_FLIGHT, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_FLIGHT) * 1.37f);
+            }
+            else
+                me->SetSpeed(MOVE_RUN, master->GetSpeedRate(MOVE_RUN) * 1.25f);
+        }
+
+        //update stats
+        if (auraname == SPELL_AURA_MOD_STAT || auraname == SPELL_AURA_MOD_PERCENT_STAT ||
+            auraname == SPELL_AURA_MOD_TOTAL_STAT_PERCENTAGE || auraname == SPELL_AURA_MOD_SKILL ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER || auraname == SPELL_AURA_MOD_ATTACK_POWER_PCT ||
+            auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_STAT_PERCENT || auraname == SPELL_AURA_MOD_ATTACK_POWER_OF_ARMOR ||
+            auraname == SPELL_AURA_MOD_RATING/* || auraname == SPELL_AURA_MOD_RATING_FROM_STAT*/) //NYI TODO:
+        {
+            shouldUpdateStats = true;
+        }
+        else
+        {
+            if (auraname == SPELL_AURA_MOD_INCREASE_HEALTH ||
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_2 ||
+                auraname == SPELL_AURA_230 ||//SPELL_AURA_MOD_INCREASE_HEALTH_2
+                auraname == SPELL_AURA_MOD_INCREASE_HEALTH_PERCENT)
+                doHealth = true;
+            else if (auraname == SPELL_AURA_MOD_INCREASE_ENERGY ||
+                auraname == SPELL_AURA_MOD_INCREASE_ENERGY_PERCENT)
+                doMana = true;
+        }
+    }
+
+    //TODO:
+    if (/*!(spell->AttributesEx & SPELL_ATTR1_NO_THREAT) &&
+        !(spell->AttributesEx3 & SPELL_ATTR3_NO_INITIAL_AGGRO) &&*/
+        IsMinionAI() && /*!CCed(me) && */(me->IsHostileTo(caster) || caster->IsHostileTo(me)))
+    {
+        //_atHome = false;
+        if (!me->CanSeeOrDetect(caster))
+        {
+            if (_evadeMode)
+                me->BotStopMovement();
+        }
+        else if (caster->IsInCombat() || me->IsInCombat())
+            this->OwnerAttackedBy(caster);
+        //if (_evadeMode == true && me->isMoving() && IAmFree())
+    }
+}
+//Messed up
+//Hp + Mana update
+//target update
+//returns fake wait time between overall AI updates (if it is even understandable)
+uint8 bot_ai::GetWait()
+{
+    if (doHealth)
+    {
+        doHealth = false;
+        _OnHealthUpdate();
+    }
+    if (doMana)
+    {
+        doMana = false;
+        _OnManaUpdate();
+    }
+    CheckAuras(true);
+    FindMaster();
+    //SavePosition();
+    //0 to 2 plus 1 for every 3 bots except first one
+    return IAmFree() ? 3 : (1 + (master->GetNpcBotsCount() - 1)/3 + (irand(0,100) <= 50)*int8(RAND(-1,1)));
+}
+//Damage/Healing Mods
+//1) Apply class-specified damage/healing/crit chance/crit damage/crit healing bonuses
+//2) Apply bot damage/healing multipliers
+//Bug with config reload (creatures do not update their damage on reload) is not bot-related but still annoying
+void bot_ai::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    //WHITE ATTACKS damage bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo);
+    damage = uint32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    //MELEE ABILITIES damage/crit bonus
+    ApplyClassDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_melee);
+}
+void bot_ai::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    //DAMAGE SPELLS damage/crit bonus
+    ApplyClassDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+    damage = int32(damage * _mult_dmg_spell);
+}
+void bot_ai::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    //HEALING SPELLS amount bonus
+    ApplyClassDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+    heal = (heal * _mult_healing);
+}
+void bot_ai::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    //ALL SPELLS crit base
+    //for base use bot_ai::crit, for healing spells crit bonus use class specified func
+    //bonuses for damage spells are handled in ApplyBotDamageMultiplierSpell()
+    ApplyClassCritMultiplierHeal(victim, crit_chance, spellInfo, schoolMask, attackType);
+    crit_chance += crit;
+}
+void bot_ai::ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    //ALL SPELLS power cost bonus
+    ApplyClassSpellCostMods(spellInfo, cost);
+}
+void bot_ai::ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    //ALL SPELLS cast time bonus
+    ApplyClassSpellCastTimeMods(spellInfo, casttime);
+}
+void bot_ai::ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS cooldown bonus
+    ApplyClassSpellCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+{
+    //ALL SPELLS category cooldown bonus
+    ApplyClassSpellCategoryCooldownMods(spellInfo, cooldown);
+}
+void bot_ai::ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+{
+    //ALL SPELLS global cooldown bonus
+    ApplyClassSpellGlobalCooldownMods(spellInfo, cooldown);
+}
+//////////
+//GOSSIP//
+//////////
+//GossipHello (static)
+bool bot_minion_ai::OnGossipHello(Player* player, Creature* creature, uint32 /*option*/)
+{
+    ASSERT(player);
+    ASSERT(creature);
+
+    if (!_enableNpcBots || creature->IsInCombat() || bot_ai::CCed(creature) || creature->GetBotAI()->IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->GetBotAI()->IsTempBot()) //Blademaster illusion etc.
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    if (creature->isMoving())
+        creature->StopMoving();
+
+    uint32 gossipTextId = (player->GetGUID().GetCounter() == creature->GetBotAI()->GetBotOwnerGuid() || !creature->GetBotAI()->IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    bool menus = false;
+
+    if (player->IsGameMaster() &&
+        (creature->IsFreeBot() || player->GetGUID().GetCounter() != creature->GetBotAI()->GetBotOwnerGuid()))
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Debug>", GOSSIP_SENDER_DEBUG, GOSSIP_ACTION_INFO_DEF + 1);
+        menus = true;
+    }
+
+    if (player->GetGUID().GetCounter() != creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        if (creature->IsFreeBot() && !player->IsGameMaster())
+        {
+            uint32 cost = BotMgr::GetNpcBotCost(player->getLevel(), creature);
+
+            int8 reason = 0;
+            if (creature->IsHostileTo(player) || player->IsHostileTo(creature) ||
+                creature->HasAura(BERSERK))
+                reason = -1;
+            if (!reason && creature->GetBotAI()->GetBotOwnerGuid())
+                reason = 1;
+            if (!reason && player->GetNpcBotsCount() >= BotMgr::GetMaxNpcBots())
+                reason = 2;
+            if (!reason && !player->HasEnoughMoney(cost))
+                reason = 3;
+
+            if (!reason && _maxClassNpcBots && player->HaveBot())
+            {
+                uint8 count = 0;
+                BotMap const* map = player->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    if (itr->second->GetBotClass() == creature->GetBotClass())
+                        ++count;
+
+                if (!reason && count >= _maxClassNpcBots)
+                    reason = 4;
+            }
+
+            if (!reason)
+            {
+                std::ostringstream message;
+                message << "Do you wish to hire " << creature->GetName() << '?';
+                player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "Will you follow me?",
+                    GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + 0, message.str().c_str(), cost, false);
+            }
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TAXI, "Will you follow me?", GOSSIP_SENDER_HIRE, GOSSIP_ACTION_INFO_DEF + reason);
+
+            if (creature->GetBotClass() >= BOT_CLASS_EX_START)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "<Take a better look on this one>", GOSSIP_SENDER_SCAN, GOSSIP_ACTION_INFO_DEF + 1);
+
+            menus = true;
+        }
+    }
+
+    if (creature->GetBotAI()->GetBotOwnerGuid())
+    {
+        Group const* gr = player->GetGroup();
+
+        if (player == creature->GetBotOwner())
+        {
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage equipment...", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage roles...", GOSSIP_SENDER_ROLES, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Manage formation...", GOSSIP_SENDER_FORMATION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Use ability...", GOSSIP_SENDER_ABILITIES, GOSSIP_ACTION_INFO_DEF + 1);
+            if (creature->GetBotClass() >= BOT_CLASS_EX_START)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Abilities status...", GOSSIP_SENDER_SCAN_OWNER, GOSSIP_ACTION_INFO_DEF + 1);
+
+            if (!gr)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Create group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+            else if (!gr->IsMember(creature->GetGUID()))
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Add to group>", GOSSIP_SENDER_JOIN_GROUP, GOSSIP_ACTION_INFO_DEF + 2);
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Remove from group>", GOSSIP_SENDER_LEAVE_GROUP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            menus = true;
+        }
+        if (player == creature->GetBotOwner() || (gr && gr->IsMember(creature->GetBotOwner()->GetGUID())))
+        {
+            switch (creature->GetBotClass())
+            {
+                case BOT_CLASS_MAGE:
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need food", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 1);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "I need drink", GOSSIP_SENDER_CLASS, GOSSIP_ACTION_INFO_DEF + 2);
+                    menus = true;
+                    break;
+                default:
+                    break;
+            }
+        }
+
+        if (player == creature->GetBotOwner())
+        {
+            std::ostringstream astr;
+            astr << "Are you going to abandon " << creature->GetName() << "? You may regret it...";
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_TAXI, "You are dismissed",
+                GOSSIP_SENDER_DISMISS, GOSSIP_ACTION_INFO_DEF + 1, astr.str().c_str(), 0, false);
+
+            menus = true;
+        }
+    }
+
+    if (menus)
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Nevermind", 0, GOSSIP_ACTION_INFO_DEF + 1);
+
+    player->PlayerTalkClass->SendGossipMenu(gossipTextId, creature->GetGUID());
+    return true;
+}
+
+//GossipSelect
+bool bot_minion_ai::OnGossipSelect(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action)
+{
+    //if (!IsInBotParty(player))
+    //{
+    //    player->CLOSE_GOSSIP_MENU();
+    //    return true;
+    //}
+
+    if (!_enableNpcBots || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = (player->GetGUID().GetCounter() == _ownerGuid || !IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    player->PlayerTalkClass->ClearMenus();
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case 0: //any kind of fail
+        {
+            BotSay("...", player);
+            break;
+        }
+        case 1: //return to main menu
+        {
+            return bot_minion_ai::OnGossipHello(player, creature, 0);
+        }
+        case GOSSIP_SENDER_CLASS: //food/drink (classes: MAGE)
+        {
+            switch (_botclass)
+            {
+                case BOT_CLASS_MAGE:
+                {
+                    //Prevent high-leveled consumables for low-level characters
+                    Unit* checker;
+                    if (player->getLevel() < me->getLevel())
+                        checker = player;
+                    else
+                        checker = me;
+
+                    // Conjure Refreshment rank 1
+                    uint32 food = InitSpell(checker, 42955);
+                    bool iswater = (action == GOSSIP_ACTION_INFO_DEF + 2);
+                    if (!food)
+                    {
+                        if (!iswater)// Conjure Food rank 1
+                            food = InitSpell(checker, 587);
+                        else// Conjure Water rank 1
+                            food = InitSpell(checker, 5504);
+                    }
+                    if (!food)
+                    {
+                        std::string errorstr = "I can't conjure ";
+                        errorstr += iswater ? "water" : "food";
+                        errorstr += " yet";
+                        BotWhisper(errorstr.c_str(), player);
+                        //player->PlayerTalkClass->ClearMenus();
+                        //return OnGossipHello(player, me);
+                        break;
+                    }
+                    SpellInfo const* Info = sSpellMgr->GetSpellInfo(food);
+                    Spell* foodspell = new Spell(me, Info, TRIGGERED_NONE, player->GetGUID());
+                    SpellCastTargets targets;
+                    targets.SetUnitTarget(player);
+                    //TODO implement checkcast for bots
+                    SpellCastResult result = me->IsMounted() || CCed(me) ? SPELL_FAILED_CUSTOM_ERROR : foodspell->CheckPetCast(player);
+                    if (result != SPELL_CAST_OK)
+                    {
+                        foodspell->finish(false);
+                        delete foodspell;
+                        BotWhisper("I can't do it right now", player);
+                    }
+                    else
+                    {
+                        aftercastTargetGuid = player->GetGUID();
+                        foodspell->prepare(&targets);
+                        BotWhisper("Here you go...", player);
+                    }
+                    break;
+                }
+                default:
+                    break;
+            }
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT: //equips change s1: send what slots we can use
+        {
+            subMenu = true;
+
+            //general
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Show me your inventory", GOSSIP_SENDER_EQUIPMENT_LIST, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //auto-equip
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Auto-equip...", GOSSIP_SENDER_EQUIP_AUTOEQUIP, GOSSIP_ACTION_INFO_DEF + 1);
+
+            //weapons
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Main hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_MAINHAND);
+            if (_canUseOffHand())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Off-hand...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_OFFHAND);
+            if (_canUseRanged())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Ranged...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+            else
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Relic...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_RANGED);
+
+            //armor
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Head...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HEAD);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shoulders...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_SHOULDERS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Chest...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_CHEST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Waist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WAIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Legs...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_LEGS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Feet...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FEET);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Wrist...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_WRIST);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Hands...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_HANDS);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BACK);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Shirt...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_BODY);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Finger2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_FINGER2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket1...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Trinket2...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_TRINKET2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Neck...", GOSSIP_SENDER_EQUIPMENT_SHOW, GOSSIP_ACTION_INFO_DEF + BOT_SLOT_NECK);
+
+            //if (player->IsGameMaster())
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip all", GOSSIP_SENDER_UNEQUIP_ALL, GOSSIP_ACTION_INFO_DEF + 1);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_LIST: //list inventory
+        {
+            //if (action - GOSSIP_ACTION_INFO_DEF != BOT_SLOT_NONE)
+            //    break;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment list for bot with no equip info!");
+
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                Item* item = _equips[i];
+                if (!item) continue;
+                std::ostringstream msg;
+                _AddItemLink(player, item, msg);
+                msg << " in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ')';
+                if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+                    msg << " |cffe6cc80|h[!standard item!]|h|r";
+                BotWhisper(msg.str().c_str(), player);
+            }
+
+            break;
+        }
+        case GOSSIP_SENDER_EQUIPMENT_INFO: //request equip item info
+        {
+            //GOSSIP ITEMS RESTRICTED
+            //subMenu = true; //needed for return
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment info for bot with no equip info!");
+
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            Item* item = _equips[slot];
+            ASSERT(item);
+
+            std::ostringstream msg;
+            _AddItemLink(player, item, msg);
+
+            if (slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == item->GetEntry())
+                msg << " |cffe6cc80|h[!standard item!]|h|r";
+
+            BotWhisper(msg.str().c_str(), player);
+
+            //break; //no break here - return to menu
+        }
+        case GOSSIP_SENDER_EQUIPMENT_SHOW: //equips change s2: send list of equippable items
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send equipment show for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //s2.1: build list
+            //s2.1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+                    if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) && itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //s2.1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+                            if (_canEquip(pItem->GetTemplate(), action - GOSSIP_ACTION_INFO_DEF, true) && itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //s2.2: add gossips
+
+            //s2.2.0 add current item (with return)
+            uint8 slot = action - (GOSSIP_ACTION_INFO_DEF + 1);
+            std::ostringstream str;
+            str << "Equipped: ";
+            if (Item* item = _equips[slot])
+            {
+                _AddItemLink(player, item, str);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_INFO, action);
+            }
+            else
+            {
+                str << "nothing";
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, str.str().c_str(), GOSSIP_SENDER_EQUIPMENT_SHOW, action);
+            }
+
+            //s2.2.1 add unequip option if have weapon (GMs only)
+            if (action - GOSSIP_ACTION_INFO_DEF <= BOT_SLOT_RANGED)
+                //if (player->IsGameMaster())
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Use your old equipment", GOSSIP_SENDER_EQUIP_RESET, action);
+
+            //s2.2.2 add unequip option for non-weapons
+            if (slot >= BOT_SLOT_RANGED && _equips[slot])
+                //if (player->IsGameMaster())
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Unequip it", GOSSIP_SENDER_UNEQUIP, action);
+
+            //s2.2.3a: add an empty submenu with info if no items are found
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 4; //unequip, reset, current, back
+                uint32 slot = action - GOSSIP_ACTION_INFO_DEF;
+                Item* item;
+                //s2.2.3b: add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP + (slot - 1), GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+
+            //TC_LOG_ERROR("entities.player", "OnGossipSelect(bot): added %u item(s) to list of %s (requester: %s)",
+            //    counter, me->GetName().c_str(), player->GetName().c_str());
+
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP: //equips change s3: Unequip DEPRECATED
+        {
+            if (_unequip(action - (GOSSIP_ACTION_INFO_DEF + 1)))
+                BotSay("Hm...", player);
+            break;
+        }
+        case GOSSIP_SENDER_UNEQUIP_ALL:
+        {
+            bool suc = true;
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i < BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    suc = false;
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ")!";
+                    BotWhisper(estr.str().c_str(), player);
+                }
+
+                if (suc)
+                    me->HandleEmoteCommand(EMOTE_ONESHOT_CRY);
+            }
+            break;
+        }
+        //autoequips change s5b: AtoEquip item
+        //base is GOSSIP_SENDER_EQUIP_AUTOEQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK:      //18 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP, item)){}
+
+            //break;
+        }
+        case GOSSIP_SENDER_EQUIP_AUTOEQUIP:
+        {
+            subMenu = true;
+
+            int8 id = 1;
+            EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+            ASSERT(einfo && "Trying to send auto-equip for bot with no equip info!");
+
+            std::set<uint32> itemList, idsList;
+
+            //1: build list
+            //1.1: backpack
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+                {
+                    bool standard = false;
+                    for (uint8 j = 0; j != MAX_EQUIPMENT_ITEMS; ++j)
+                    {
+                        if (einfo->ItemEntry[j] == pItem->GetEntry())
+                        {
+                            standard = true;
+                            break;
+                        }
+                    }
+                    if (standard)
+                        continue;
+
+                    bool canEquip = false;
+
+                    for (uint8 k = 0; k != BOT_INVENTORY_SIZE; ++k)
+                    {
+                        if (_canEquip(pItem->GetTemplate(), k + 1))
+                        {
+                            canEquip = true;
+                            break;
+                        }
+                    }
+
+                    if (canEquip && itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                    {
+                        itemList.insert(pItem->GetGUID().GetCounter());
+                        idsList.insert(pItem->GetEntry());
+                    }
+                }
+            }
+
+            //1.2: other bags
+            for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+            {
+                if (Bag* pBag = player->GetBagByPos(i))
+                {
+                    for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                    {
+                        if (Item* pItem = player->GetItemByPos(i, j))
+                        {
+                            bool standard = false;
+                            for (uint8 k = 0; k != MAX_EQUIPMENT_ITEMS; ++k)
+                            {
+                                if (einfo->ItemEntry[k] == pItem->GetEntry())
+                                {
+                                    standard = true;
+                                    break;
+                                }
+                            }
+                            if (standard)
+                                continue;
+
+                            bool canEquip = false;
+
+                            for (uint8 k = 0; k != BOT_INVENTORY_SIZE; ++k)
+                            {
+                                if (_canEquip(pItem->GetTemplate(), k + 1))
+                                {
+                                    canEquip = true;
+                                    break;
+                                }
+                            }
+
+                            if (canEquip && itemList.find(pItem->GetGUID().GetCounter()) == itemList.end() && idsList.find(pItem->GetEntry()) == idsList.end())
+                            {
+                                itemList.insert(pItem->GetGUID().GetCounter());
+                                idsList.insert(pItem->GetEntry());
+                            }
+                        }
+                    }
+                }
+            }
+
+            //2: add gossips
+
+            if (itemList.empty())
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Hm... I have nothing to give you", 0, GOSSIP_ACTION_INFO_DEF + 1);
+            }
+            else
+            {
+                uint32 counter = 0;
+                uint32 maxcounter = GOSSIP_MAX_MENU_ITEMS - 1; // back
+                Item* item;
+                //add items as gossip options
+                for (std::set<uint32>::const_iterator itr = itemList.begin(); itr != itemList.end() && counter < maxcounter; ++itr)
+                {
+                    bool found = false;
+                    for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                        if (item && item->GetGUID().GetCounter() == (*itr))
+                        {
+                            uint8 k = 0;
+                            for (; k != BOT_INVENTORY_SIZE; ++k)
+                                if (_canEquip(item->GetTemplate(), k + 1))
+                                    break;
+
+                            std::ostringstream name;
+                            _AddItemLink(player, item, name);
+                            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                            ++counter;
+                            found = true;
+                            break;
+                        }
+                    }
+
+                    if (found)
+                        continue;
+
+                    for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                    {
+                        if (Bag* pBag = player->GetBagByPos(i))
+                        {
+                            for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                            {
+                                item = player->GetItemByPos(i, j);
+                                if (item && item->GetGUID().GetCounter() == (*itr))
+                                {
+                                    uint8 k = 0;
+                                    for (; k != BOT_INVENTORY_SIZE; ++k)
+                                        if (_canEquip(item->GetTemplate(), k + 1))
+                                            break;
+
+                                    std::ostringstream name;
+                                    _AddItemLink(player, item, name);
+                                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, name.str().c_str(), GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP + k, GOSSIP_ACTION_INFO_DEF + item->GetGUID().GetCounter());
+                                    ++counter;
+                                    found = true;
+                                    break;
+                                }
+                            }
+                        }
+
+                        if (found)
+                            break;
+                    }
+
+                    if (found)
+                        continue;
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", GOSSIP_SENDER_EQUIPMENT, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_EQUIP_RESET: //equips change s4a: reset equipment
+        {
+            if (_resetEquipment(action - (GOSSIP_ACTION_INFO_DEF + 1))){}
+            break;
+        }
+        //equips change s4b: Equip item
+        //base is GOSSIP_SENDER_EQUIP + 0...1...2... etc.
+        case GOSSIP_SENDER_EQUIP_MHAND:     //1 - 1 main hand
+        case GOSSIP_SENDER_EQUIP_OHAND:     //2 - 1 off hand
+        case GOSSIP_SENDER_EQUIP_RANGED:    //3 - 1 ranged
+        case GOSSIP_SENDER_EQUIP_HEAD:      //4 - 1 head
+        case GOSSIP_SENDER_EQUIP_SHOULDERS: //5 - 1 shoulders
+        case GOSSIP_SENDER_EQUIP_CHEST:     //6 - 1 chest
+        case GOSSIP_SENDER_EQUIP_WAIST:     //7 - 1 waist
+        case GOSSIP_SENDER_EQUIP_LEGS:      //8 - 1 legs
+        case GOSSIP_SENDER_EQUIP_FEET:      //9 - 1 feet
+        case GOSSIP_SENDER_EQUIP_WRIST:     //10 - 1 wrist
+        case GOSSIP_SENDER_EQUIP_HANDS:     //11 - 1 hands
+        case GOSSIP_SENDER_EQUIP_BACK:      //12 - 1 back
+        case GOSSIP_SENDER_EQUIP_BODY:      //13 - 1 body
+        case GOSSIP_SENDER_EQUIP_FINGER1:   //14 - 1 finger
+        case GOSSIP_SENDER_EQUIP_FINGER2:   //15 - 1 finger
+        case GOSSIP_SENDER_EQUIP_TRINKET1:  //16 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_TRINKET2:  //17 - 1 trinket
+        case GOSSIP_SENDER_EQUIP_NECK:      //18 - 1 neck
+        {
+            Item* item = NULL;
+            uint32 guidLow = action - GOSSIP_ACTION_INFO_DEF;
+
+            bool found = false;
+            for (uint8 i = INVENTORY_SLOT_ITEM_START; i != INVENTORY_SLOT_ITEM_END; i++)
+            {
+                item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                if (item && item->GetGUID().GetCounter() == guidLow)
+                {
+                    found = true;
+                    break;
+                }
+            }
+
+            if (!found)
+            {
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i != INVENTORY_SLOT_BAG_END; i++)
+                {
+                    if (Bag* pBag = player->GetBagByPos(i))
+                    {
+                        for (uint32 j = 0; j != pBag->GetBagSize(); j++)
+                        {
+                            item = player->GetItemByPos(i, j);
+                            if (item && item->GetGUID().GetCounter() == guidLow)
+                            {
+                                found = true;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (found)
+                        break;
+                }
+            }
+
+            if (found && _equip(sender - GOSSIP_SENDER_EQUIP, item)){}
+            break;
+        }
+        case GOSSIP_SENDER_ROLES_TOGGLE: //ROLES 2: set/unset
+        {
+            ToggleRole(action - GOSSIP_ACTION_INFO_DEF, false);
+
+            //break;
+        }
+        case GOSSIP_SENDER_ROLES: //ROLES 1: list
+        {
+            subMenu = true;
+
+            uint8 role = BOT_ROLE_TANK;
+
+            for (; role != BOT_MAX_ROLE; role <<= 1)
+            {
+                if (role == BOT_ROLE_PARTY) //hidden
+                    continue;
+                if (role == BOT_ROLE_HEAL && !CanHeal())
+                    continue;
+
+                player->ADD_GOSSIP_ITEM(_onOffIcon(role), GetRoleString(role), GOSSIP_SENDER_ROLES_TOGGLE, GOSSIP_ACTION_INFO_DEF + role);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + role + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_ABILITIES_USE:
+        {
+            if (uint32 basespell = action - GOSSIP_ACTION_INFO_DEF)
+                //if (CheckBotCast(me, basespell, me->GetBotClass()) == SPELL_CAST_OK)
+                    if (IsSpellReady(basespell, lastdiff, true))
+                        doCast(player, GetSpell(basespell));
+
+            //break;
+        }
+        case GOSSIP_SENDER_ABILITIES:
+        {
+            subMenu = true;
+
+            uint32 basespell;
+            SpellInfo const* spellInfo;
+            BotSpellMap const& myspells = GetSpellMap();
+            for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+            {
+                //if (currentSpell == itr->second.first) continue; //prevent spam
+                basespell = itr->first; //always valid
+                if (!CanUseManually(basespell)) continue;
+                if (!IsSpellReady(basespell, 0, false, 5000)) continue;
+                spellInfo = sSpellMgr->GetSpellInfo(basespell); //always valid
+
+                std::ostringstream name;
+                _AddSpellLink(player, spellInfo, name);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, name.str().c_str(), GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF + basespell);
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update", GOSSIP_SENDER_ABILITIES_USE, GOSSIP_ACTION_INFO_DEF);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+
+            break;
+        }
+        case GOSSIP_SENDER_HIRE:
+        {
+            int32 reason = action - GOSSIP_ACTION_INFO_DEF;
+            if (!reason)
+            {
+                if (_ownerGuid)
+                {
+                    std::ostringstream ostr;
+                    std::string name;
+                    ostr << "Go away. I serve my master ";
+                    if (sObjectMgr->GetPlayerNameByGUID(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                        ostr << name;
+                    else
+                        ostr << "unknown (" << _ownerGuid << ')';
+                    BotSay(ostr.str().c_str(), player);
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s will not join you until owner dismisses %s", me->GetName().c_str(), (me->getGender() == GENDER_MALE ? "him" : "her"));
+                    break;
+                }
+
+                if (SetBotOwner(player))
+                    BotWhisper("I am ready", player);
+                else
+                    BotSay("...", player);
+            }
+            else if (reason == -1)
+            {
+                me->setFaction(14);
+                if (Creature* pet = me->GetBotsPet())
+                    pet->setFaction(14);
+                BotYell("Die!", player);
+                me->Attack(player, IsMelee());
+                break;
+            }
+            else
+            {
+                ChatHandler ch(player->GetSession());
+                switch (reason)
+                {
+                    case 1: //has owner, unexpected
+                        ch.PSendSysMessage("%s will not join you, already has master: %s",
+                            me->GetName().c_str(), master->GetName().c_str());
+                        break;
+                    case 2: //max npcbots exceed
+                        ch.PSendSysMessage("You exceed max npcbots (%u)", BotMgr::GetMaxNpcBots());
+                        break;
+                    case 3: //not enough money
+                    {
+                        std::string str = "You don't have enough money (";
+                        str += BotMgr::GetNpcBotCostStr(player->getLevel(), me);
+                        str += ")!";
+                        ch.SendSysMessage(str.c_str());
+                        player->SendBuyError(BUY_ERR_NOT_ENOUGHT_MONEY, 0, 0, 0);
+                        break;
+                    }
+                    case 4: //class bots exceed
+                    {
+                        uint8 count = 0;
+                        BotMap const* map = player->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                            if (itr->second->GetBotClass() == GetBotClass())
+                                ++count;
+
+                        ch.PSendSysMessage("You cannot have more bots of that class! %u of %u",
+                            count, _maxClassNpcBots);
+                        break;
+                    }
+                    default:
+                        break;
+                }
+
+                BotSay("...", player);
+            }
+            break;
+        }
+        case GOSSIP_SENDER_DISMISS:
+        {
+            BotMgr* mgr = player->GetBotMgr();
+            ASSERT(mgr);
+
+            //send items to owner -- Unequip all
+            bool abort = false;
+            for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (!(i < BOT_SLOT_RANGED ? _resetEquipment(i) : _unequip(i)))
+                {
+                    std::ostringstream estr;
+                    estr << "Cannot reset equipment in slot " << uint32(i) << " (" << _getNameForSlot(i + 1) << ")! Cannot dismiss bot!";
+                    ChatHandler ch(player->GetSession());
+                    ch.SendSysMessage(estr.str().c_str());
+                    abort = true;
+                    break;
+                }
+            }
+
+            if (abort)
+                break;
+
+            mgr->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+            if (Aura* bers = me->AddAura(BERSERK, me))
+            {
+                uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                bers->SetDuration(dur);
+                bers->SetMaxDuration(dur);
+            }
+            if (urand(1,100) <= 25)
+            {
+                me->setFaction(14);
+                if (Creature* pet = me->GetBotsPet())
+                    pet->setFaction(14);
+                BotSay("Fool...", player);
+                me->Attack(player, IsMelee());
+            }
+            else
+                BotSay("...", player);
+
+            break;
+        }
+        case GOSSIP_SENDER_JOIN_GROUP:
+        {
+            player->GetBotMgr()->AddBotToGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_LEAVE_GROUP:
+        {
+            player->GetBotMgr()->RemoveBotFromGroup(me);
+            break;
+        }
+        case GOSSIP_SENDER_FORMATION:
+        {
+            subMenu = true;
+            std::ostringstream diststr;
+            diststr << "Set distance (current: " << uint32(player->GetBotFollowDist()) << ')';
+            player->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, GOSSIP_ICON_CHAT, diststr.str(),
+                GOSSIP_SENDER_FORMATION_DISTANCE, GOSSIP_ACTION_INFO_DEF + 1, "", 0, true);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 2);
+            break;
+        }
+        case GOSSIP_SENDER_DEBUG_ACTION:
+        {
+            //!!! player != owner !!!
+            bool close = true;
+            switch (action - GOSSIP_ACTION_INFO_DEF)
+            {
+                case 1: //reset owner
+                    if (!IAmFree())
+                        master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_DISMISS);
+                    else
+                    {
+                        ResetBotAI(BOTAI_RESET_DISMISS);
+                        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+                        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+                        stmt->setUInt32(0, uint32(0));
+                        stmt->setUInt32(1, me->GetEntry());
+                        CharacterDatabase.Execute(stmt);
+                    }
+                    break;
+                case 2: //reset stats
+                    spawned = false;
+                    DefaultInit();
+                    break;
+                case 3: //list stats
+                    close = false;
+                    ReceiveEmote(player, TEXT_EMOTE_BONK);
+                    break;
+                case 4: //list roles
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Roles:", me->GetName().c_str());
+                    for (uint8 i = BOT_MAX_ROLE; i != BOT_ROLE_NONE; i >>= 1)
+                    {
+                        if (_roleMask & i)
+                        {
+                            switch (i)
+                            {
+                                case BOT_ROLE_TANK:
+                                    ch.PSendSysMessage("BOT_ROLE_TANK");
+                                    break;
+                                case BOT_ROLE_DPS:
+                                    ch.PSendSysMessage("BOT_ROLE_DPS");
+                                    break;
+                                case BOT_ROLE_HEAL:
+                                    ch.PSendSysMessage("BOT_ROLE_HEAL");
+                                    break;
+                                //case BOT_ROLE_MELEE:
+                                //    ch.PSendSysMessage("BOT_ROLE_MELEE");
+                                //    break;
+                                case BOT_ROLE_RANGED:
+                                    ch.PSendSysMessage("BOT_ROLE_RANGED");
+                                    break;
+                                case BOT_ROLE_PARTY:
+                                    ch.PSendSysMessage("BOT_ROLE_PARTY");
+                                    break;
+                            }
+                        }
+                    }
+                    break;
+                }
+                case 5: //list spells
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+                    ch.PSendSysMessage("%s's Spells:", me->GetName().c_str());
+                    uint32 counter = 0;
+                    SpellInfo const* spellInfo;
+                    BotSpellMap const& myspells = GetSpellMap();
+                    for (BotSpellMap::const_iterator itr = myspells.begin(); itr != myspells.end(); ++itr)
+                    {
+                        ++counter;
+                        std::ostringstream sstr;
+                        spellInfo = sSpellMgr->GetSpellInfo(itr->first); //always valid
+                        _AddSpellLink(player, spellInfo, sstr);
+                        sstr << " id: " <<  itr->second.first << ", base: " << itr->first
+                            << ", cd: " << itr->second.second << ", base: " << std::max<uint32>(spellInfo->RecoveryTime, spellInfo->CategoryRecoveryTime);
+                        ch.PSendSysMessage("%u) %s", counter, sstr.str().c_str());
+                    }
+                    break;
+                }
+                case 6: //reload config
+                {
+                    close = false;
+                    ChatHandler ch(player->GetSession());
+
+                    TC_LOG_INFO("misc", "Re-Loading config settings...");
+                    sWorld->LoadConfigSettings(true);
+                    sMapMgr->InitializeVisibilityDistanceInfo();
+                    ch.SendGlobalGMSysMessage("World config settings reloaded.");
+                    BotMgr::ReloadConfig();
+                    ch.SendGlobalGMSysMessage("NpcBot config settings reloaded.");
+
+                    break;
+                }
+                default:
+                    close = false;
+                    break;
+            }
+
+            if (close)
+                break;
+        }
+        case GOSSIP_SENDER_DEBUG:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            std::ostringstream ostr;
+            std::string name;
+            ostr << "Bot: " << me->GetName()
+                << " (Id: " << me->GetEntry()
+                << ", guidlow: " << me->GetGUID().GetCounter()
+                << ", faction: " << me->getFaction()
+                << "). owner: ";
+            if (_ownerGuid && sObjectMgr->GetPlayerNameByGUID(ObjectGuid(HighGuid::Player, _ownerGuid), name))
+                ostr << name << " (" << _ownerGuid << ')';
+            else
+                ostr << "none";
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, ostr.str().c_str(), GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 0);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Owner>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 1);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reset Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 2);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Stats>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 3);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Roles>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 4);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<List Spells>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 5);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "<Reload Config>", GOSSIP_SENDER_DEBUG_ACTION, GOSSIP_ACTION_INFO_DEF + 6);
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+            break;
+        }
+        case GOSSIP_SENDER_SCAN:
+        {
+            //!!! player != owner !!!
+            subMenu = true;
+
+            //ListAbilities(true);
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    gossipTextId = GOSSIP_CLASS_BM;
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER_ABILITY:
+        {
+            uint32 Id = action - GOSSIP_ACTION_INFO_DEF;
+            SpellInfo const* info = sSpellMgr->GetSpellInfo(Id);
+            ASSERT(info);
+
+            ChatHandler ch(player->GetSession());
+            std::ostringstream smsg1, smsg2;
+            switch (Id)
+            {
+                //Blademaster
+                case SPELL_NETHERWALK:
+                    _AddSpellLink(player, info, smsg1, false, "ffffff00"/*yellow*/);
+                    smsg2 << "    Invisibilty: |cff00ff00" << uint32(100 + (me->getLevel() * 5) / 2) << "|r, speed: +|cff00ff00" << uint32(10 + me->getLevel() / 2) << "|r%, |cff00ff00150|r% normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Allows Blademaster to become invisible, and move faster for a set amount of time. When the Blademaster attacks a unit to break invisibility, he will deal bonus damage.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_MIRROR_IMAGE_BM:
+                    _AddSpellLink(player, info, smsg1, false, "ffffff00"/*yellow*/);
+                    smsg2 << "    |cff00ff00" << uint32(GetSpellMiscValue(Id)) << "|r " << (GetSpellMiscValue(Id) == 1 ? "illusion" : "illusions");
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Confuses the enemy by creating illusions of the Blademaster and dispelling all magic from the Blademaster.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                case SPELL_CRITICAL_STRIKE:
+                    _AddSpellLink(player, info, smsg1, false, "ffff0000"/*red*/);
+                    smsg1 << " |cffffff00(Passive)|r";
+                    smsg2 << "    |cff00ff0015|r% chance to deal |cff00ff00" << uint32(GetSpellMiscValue(Id)) << "|r times normal damage";
+                    ch.SendSysMessage(smsg1.str().c_str());
+                    ch.SendSysMessage("Gives a 15% chance that the Blademaster will do more damage on his attacks.");
+                    ch.SendSysMessage(smsg2.str().c_str());
+                    break;
+                //case SPELL_BLADESTORM_BM: TODO:
+                default:
+                    break;
+            }
+
+            //break;
+        }
+        case GOSSIP_SENDER_SCAN_OWNER:
+        {
+            subMenu = true;
+
+            std::ostringstream abmsg1, abmsg2, abmsg3/*, abmsg4*/;
+            switch (_botclass)
+            {
+                case BOT_CLASS_BM:
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_NETHERWALK), abmsg1);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg1.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_NETHERWALK);
+                    }
+                    if (me->getLevel() >= 20)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_MIRROR_IMAGE_BM), abmsg2);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg2.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_MIRROR_IMAGE_BM);
+                    }
+                    if (me->getLevel() >= 10)
+                    {
+                        _AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg3);
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg3.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_CRITICAL_STRIKE);
+                    }
+                    //TODO:
+                    //_AddSpellLink(player, sSpellMgr->GetSpellInfo(SPELL_CRITICAL_STRIKE), abmsg4);
+                    //player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, abmsg4.str().c_str(), GOSSIP_SENDER_SCAN_OWNER_ABILITY, GOSSIP_ACTION_INFO_DEF + SPELL_BLADESTORM_BM);
+                    break;
+                default:
+                    break;
+            }
+
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "BACK", 1, GOSSIP_ACTION_INFO_DEF + 1);
+
+            break;
+        }
+        default:
+            break;
+    }
+
+    //if we add submenus send them else we should return
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+
+    return true;
+}
+
+//GossipSelectCode
+bool bot_minion_ai::OnGossipSelectCode(Player* player, Creature* creature/* == me*/, uint32 sender, uint32 action, char const* code)
+{
+    if (!*code)
+        return true;
+
+    if (!_enableNpcBots || CCed(me) || IsDuringTeleport())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        return true;
+    }
+
+    uint32 gossipTextId = (player->GetGUID().GetCounter() == _ownerGuid || !IAmFree()) ? GOSSIP_SERVE_MASTER : GOSSIP_NEED_SMTH;
+
+    player->PlayerTalkClass->ClearMenus();
+
+    bool subMenu = false;
+
+    switch (sender)
+    {
+        case GOSSIP_SENDER_FORMATION_DISTANCE:
+        {
+            char* dist = strtok((char*)code, "");
+            int8 distance = std::min<uint8>((uint8)atoi(dist), 75);
+
+            player->SetBotFollowDist(distance);
+
+            player->CLOSE_GOSSIP_MENU();
+            return OnGossipSelect(player, creature, GOSSIP_SENDER_FORMATION, action);
+        }
+        default:
+            break;
+    }
+
+    if (subMenu)
+        player->PlayerTalkClass->SendGossipMenu(gossipTextId, me->GetGUID());
+    else
+        player->CLOSE_GOSSIP_MENU();
+    return true;
+}
+//Summons pet for bot
+void bot_minion_ai::SummonBotsPet(uint32 entry)
+{
+    Creature* m_botsPet = me->GetBotsPet();
+    if (m_botsPet)
+        me->SetBotsPetDied();
+
+    uint8 mylevel = std::min<uint8>(master->getLevel(), 80);
+    uint32 originalentry = bot_pet_ai::GetPetOriginalEntry(entry);
+    if (!originalentry)
+    {
+        //annoy master
+        if (!IAmFree())
+            BotWhisper("Why am I trying to summon unknown pet!?", master);
+        return;
+    }
+    float x(0),y(0),z(0);
+    me->GetClosePoint(x, y, z, me->GetObjectSize());
+    m_botsPet = me->SummonCreature(entry, x, y, z, 0, TEMPSUMMON_DEAD_DESPAWN);
+
+    if (!m_botsPet)
+    {
+        if (!IAmFree())
+            BotWhisper("Failed to summon pet!", master);
+        return;
+    }
+
+    //std::string name = sObjectMgr->GeneratePetName(originalentry);//voidwalker
+    //if (!name.empty())
+    //    m_botsPet->SetName(name);
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_PET_LEVELSTATS);
+    stmt->setUInt32(0, originalentry);
+    stmt->setUInt8(1, mylevel);
+    PreparedQueryResult result = WorldDatabase.Query(stmt);
+    //QueryResult result = WorldDatabase.PQuery("SELECT hp, mana, armor, str, agi, sta, inte, spi FROM `pet_levelstats` WHERE `creature_entry` = '%u' AND `level` = '%u'", originalentry, mylevel);
+
+    if (result)
+    {
+        Field* fields = result->Fetch();
+        uint32 hp = fields[0].GetUInt16();
+        uint32 mana = fields[1].GetUInt16();
+        //armor = fields[2].GetUInt32();
+        uint32 str = fields[3].GetUInt16();
+        uint32 agi = fields[4].GetUInt16();
+        uint32 sta = fields[5].GetUInt16();
+        uint32 inte = fields[6].GetUInt16();
+        uint32 spi = fields[7].GetUInt16();
+
+        m_botsPet->SetCreateHealth(hp);
+        m_botsPet->SetMaxHealth(hp);
+        m_botsPet->SetCreateMana(mana);
+        m_botsPet->SetMaxPower(POWER_MANA, mana);
+
+        m_botsPet->SetCreateStat(STAT_STRENGTH, str);
+        m_botsPet->SetCreateStat(STAT_AGILITY, agi);
+        m_botsPet->SetCreateStat(STAT_STAMINA, sta);
+        m_botsPet->SetCreateStat(STAT_INTELLECT, inte);
+        m_botsPet->SetCreateStat(STAT_SPIRIT, spi);
+    }
+
+    m_botsPet->SetBotOwner(master);
+    m_botsPet->SetCreatureOwner(me);
+    //m_botsPet->SetBotClass(bot_pet_ai::GetPetClass(m_botsPet));
+    master->SetMinion((Minion*)m_botsPet, true);
+    m_botsPet->SetGuidValue(UNIT_FIELD_CREATEDBY, me->GetGUID());
+    //m_botsPet->DeleteThreatList();
+    m_botsPet->AddUnitTypeMask(UNIT_MASK_MINION);
+    //m_botsPet->SetLevel(master->getLevel());
+    m_botsPet->AIM_Initialize();
+    //m_botsPet->InitBotAI(true);
+    m_botsPet->setFaction(master->getFaction());
+    //bot_pet_ai* petai = m_botsPet->GetBotPetAI();
+    //petai->SetCreatureOwner(me);
+    //petai->SetBaseArmor(armor);
+    m_botsPet->SetBotCommandState(COMMAND_FOLLOW, true);
+
+    me->SetBotsPet(m_botsPet);
+
+    m_botsPet->SendUpdateToPlayer(master);
+}
+
+//Returns pet type (maybe unneeded)
+uint8 bot_pet_ai::GetPetType(Creature* pet)
+{
+    switch (pet->GetEntry())
+    {
+        case PET_VOIDWALKER:
+            return PET_TYPE_VOIDWALKER;
+    }
+    return PET_TYPE_NONE;
+}
+//Returns pet's class
+uint8 bot_pet_ai::GetPetClass(Creature* pet)
+{
+    switch (GetPetType(pet))
+    {
+        case PET_TYPE_IMP:
+            return BOT_CLASS_MAGE;
+        default:
+            return BOT_CLASS_PALADIN;
+    }
+}
+//Return entry used to summon real pets
+uint32 bot_pet_ai::GetPetOriginalEntry(uint32 entry)
+{
+    switch (entry)
+    {
+        case PET_VOIDWALKER:
+            return ORIGINAL_ENTRY_VOIDWALKER;
+        default:
+            return 0;
+    }
+}
+//PvP trinket for minions
+void bot_minion_ai::BreakCC(uint32 diff)
+{
+    if (pvpTrinket_cd <= diff && CCed(me, true) && (me->GetVictim() || !me->getAttackers().empty()))
+    {
+        temptimer = GC_Timer;
+        if (doCast(me, PVPTRINKET))
+        {
+            pvpTrinket_cd = 120000; //2 minutes default pvp trinket CD
+            GC_Timer = temptimer;
+            return;
+        }
+    }
+}
+//Returns attack range based on given range
+//If mounted: 20%
+//If ranged: 125%
+//If master is dead: max range
+float bot_ai::InitAttackRange(float origRange, bool ranged) const
+{
+    if (me->IsMounted())
+        origRange *= 0.2f;
+    else
+    {
+        if (ranged)
+            origRange *= 1.25f;
+        if (master->isDead())
+            origRange += sWorld->GetMaxVisibleDistanceOnContinents();
+        else if (IAmFree())
+        {
+            origRange =
+                //me->GetMap()->IsBattlegroundOrArena() ? sWorld->GetMaxVisibleDistanceInBGArenas() :
+                //me->GetMap()->Instanceable() ? sWorld->GetMaxVisibleDistanceInInstances() :
+                sWorld->GetMaxVisibleDistanceOnContinents();
+        }
+    }
+    return origRange;
+}
+//Force bots to start attack anyone who tries to DAMAGE me or master
+//This means that anyone who attacks party will be attacked by whole bot party (see GetTarget())
+void bot_minion_ai::OnOwnerDamagedBy(Unit* attacker)
+{
+    if (me->GetVictim() && (!IAmFree() || me->GetDistance(me->GetVictim()) < me->GetDistance(attacker)))
+        return;
+    if (InDuel(attacker))
+        return;
+
+    bool byspell = false;
+    bool ranged = !IsMelee();
+    switch (_botclass)
+    {
+        case BOT_CLASS_DRUID:
+            byspell = GetBotStance() == BOT_STANCE_NONE || GetBotStance() == DRUID_MOONKIN_FORM;
+            break;
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_SHAMAN:
+            byspell = true;
+            break;
+        default:
+            //TC_LOG_ERROR("entities.player", "minion_ai: OnOwnerDamagedBy() - unknown bot class %u", uint8(_botclass));
+            break;
+    }
+    float maxdist = InitAttackRange(float(IAmFree() ? 100 : master->GetBotFollowDist()), ranged); //use increased range
+    if (!attacker->IsWithinDist(me, maxdist))
+        return;
+    if (!CanBotAttack(attacker, byspell))
+        return;
+
+    m_botCommandState = COMMAND_ABANDON; //reset AttackStart()
+    me->Attack(attacker, !ranged);
+}
+
+bool bot_minion_ai::_canUseOffHand() const
+{
+    if (_botclass == BOT_CLASS_BM)
+        return false;
+
+    //warriot can wield any offhand with titan's grip
+    if (_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60)
+        return true;
+
+    //no offhand: check we are using one-handed weapon in main hand
+    if (!_equips[1])
+    {
+        ItemTemplate const* proto = _equips[0] ? _equips[0]->GetTemplate() : NULL;
+        //no mainhand weapon - can use offhand
+        //mainhand is an one-hand weapon
+        if (!proto)
+            return true;
+        else if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+    }
+    else if (ItemTemplate const* proto = _equips[1]->GetTemplate())
+    {
+        //Now we have something in off-hand
+        //1 check if it is one-handed weapon
+        if (proto->Class == ITEM_CLASS_WEAPON &&
+            (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_DAGGER ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_FIST ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE ||
+            proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD))
+            return true;
+        //2 check of it is a shield
+        if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            return true;
+        //3 check of it is a 'held in off-hand' item
+        if (proto->InventoryType == INVTYPE_HOLDABLE)
+            return true;
+    }
+
+    //NO
+    return false;
+}
+
+bool bot_minion_ai::_canUseRanged() const
+{
+    return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+        _botclass == BOT_CLASS_WARRIOR || _botclass == BOT_CLASS_PRIEST ||
+        _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK);
+}
+//slot = BotEquipSlot
+bool bot_minion_ai::_canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel) const
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    if (Item* oldItem = _equips[slot - 1])
+    {
+        ItemTemplate const* oldProto = oldItem->GetTemplate();
+        //prevent reequipping same items
+        if (item->ItemId == oldProto->ItemId)
+            return false;
+        //prevent equipping worse items (only standard or not)
+        if (!ignoreItemLevel)
+            if (slot > BOT_SLOT_RANGED || einfo->ItemEntry[slot - 1] != oldProto->ItemId)
+                if (IAmFree() || !master->IsGameMaster())
+                    if (oldProto->GetItemLevelIncludingQuality() > item->GetItemLevelIncludingQuality())
+                        return false;
+    }
+
+    //level requirements
+    if (me->getLevel() < item->RequiredLevel)
+        return false;
+
+    //class requirements
+    if (!(item->AllowableClass & (1<<(GetPlayerClass()-1))))
+        return false;
+
+    //skip race requirements
+    //Weapons requirements
+    if (item->Class == ITEM_CLASS_WEAPON)
+    {
+        if (slot > BOT_SLOT_RANGED)
+            return false;
+        //polearms cannot be equipped into offhand
+        if (slot == BOT_SLOT_OFFHAND && item->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+            return false;
+        //only some classes can use offhand
+        if (slot == BOT_SLOT_OFFHAND && _botclass != BOT_CLASS_WARRIOR &&
+            _botclass != BOT_CLASS_ROGUE && _botclass != BOT_CLASS_HUNTER &&
+            _botclass != BOT_CLASS_SHAMAN && _botclass != BOT_CLASS_DEATH_KNIGHT)
+            return false;
+        //bot rogues only use daggers in mainhand
+        if (slot == BOT_SLOT_MAINHAND && item->SubClass != ITEM_SUBCLASS_WEAPON_DAGGER &&
+            _botclass == BOT_CLASS_ROGUE)
+            return false;
+        //simple check for ranged weapon
+        if (item->InventoryType == INVTYPE_THROWN ||
+            item->InventoryType == INVTYPE_RANGED ||
+            item->InventoryType == INVTYPE_RANGEDRIGHT)
+        {
+            if (slot != BOT_SLOT_RANGED || !_canUseRanged())
+                return false;
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+                item->SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+                item->SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW)
+                return (_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR/* || _botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK*/);
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_THROWN)
+                return (/*_botclass == BOT_CLASS_HUNTER || */_botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR/* || _botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK*/);
+
+            if (item->SubClass == ITEM_SUBCLASS_WEAPON_WAND)
+                return (/*_botclass == BOT_CLASS_HUNTER || _botclass == BOT_CLASS_ROGUE ||
+                    _botclass == BOT_CLASS_WARRIOR || */_botclass == BOT_CLASS_PRIEST ||
+                    _botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_WARLOCK);
+        }
+        else if (item->InventoryType == INVTYPE_2HWEAPON)
+        {
+            //warriors can equip any 2H weapon in any hand
+            if (_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60 &&
+                (slot == BOT_SLOT_MAINHAND || slot == BOT_SLOT_OFFHAND))
+                return true;
+            //2H weapons for casters - only staves
+            if ((_botclass == BOT_CLASS_MAGE || _botclass == BOT_CLASS_PRIEST ||
+                _botclass == BOT_CLASS_WARLOCK || _botclass == BOT_CLASS_DRUID) &&
+                item->SubClass != ITEM_SUBCLASS_WEAPON_STAFF)
+                return false;
+            //can equip 2H only in mainhand
+            return (slot == BOT_SLOT_MAINHAND);
+        }
+        else if (item->InventoryType == INVTYPE_WEAPON ||
+            item->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            item->InventoryType == INVTYPE_WEAPONOFFHAND)
+        {
+            //separate classes which can equip weapons or shields in offhand
+            return (slot == BOT_SLOT_MAINHAND ||
+                (slot == BOT_SLOT_OFFHAND/* && _botclass != BOT_CLASS_PALADIN*/ && _canUseOffHand()));
+        }
+    }
+    else if (item->Class == ITEM_CLASS_ARMOR)
+    {
+        //conditions for inventory slots
+        switch (item->InventoryType)
+        {
+            case INVTYPE_HEAD:
+                if (slot != BOT_SLOT_HEAD)
+                    return false;
+                break;
+            case INVTYPE_SHOULDERS:
+                if (slot != BOT_SLOT_SHOULDERS)
+                    return false;
+                break;
+            case INVTYPE_BODY:
+                if (slot != BOT_SLOT_BODY)
+                    return false;
+                break;
+            case INVTYPE_CHEST:
+            case INVTYPE_ROBE:
+                if (slot != BOT_SLOT_CHEST)
+                    return false;
+                break;
+            case INVTYPE_WAIST:
+                if (slot != BOT_SLOT_WAIST)
+                    return false;
+                break;
+            case INVTYPE_LEGS:
+                if (slot != BOT_SLOT_LEGS)
+                    return false;
+                break;
+            case INVTYPE_FEET:
+                if (slot != BOT_SLOT_FEET)
+                    return false;
+                break;
+            case INVTYPE_WRISTS:
+                if (slot != BOT_SLOT_WRIST)
+                    return false;
+                break;
+            case INVTYPE_HANDS:
+                if (slot != BOT_SLOT_HANDS)
+                    return false;
+                break;
+            case INVTYPE_FINGER:
+                if (slot != BOT_SLOT_FINGER1 && slot != BOT_SLOT_FINGER2)
+                    return false;
+                break;
+            case INVTYPE_TRINKET:
+                if (slot != BOT_SLOT_TRINKET1 && slot != BOT_SLOT_TRINKET2)
+                    return false;
+                break;
+            case INVTYPE_NECK:
+                if (slot != BOT_SLOT_NECK)
+                    return false;
+                break;
+            case INVTYPE_CLOAK:
+                if (slot != BOT_SLOT_BACK)
+                    return false;
+                break;
+            case INVTYPE_HOLDABLE:
+            case INVTYPE_SHIELD:
+                if (slot != BOT_SLOT_OFFHAND)
+                    return false;
+                break;
+            case INVTYPE_RELIC:
+                if (slot != BOT_SLOT_RANGED)
+                    return false;
+                break;
+            default:
+                break;
+        }
+
+        //Shields
+        if (item->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (slot == BOT_SLOT_OFFHAND) //wtf? mainhand shield?
+            {
+                //Only classes which can use shield
+                return _canUseOffHand() &&
+                    (_botclass == BOT_CLASS_WARRIOR ||
+                    _botclass == BOT_CLASS_PALADIN ||
+                    _botclass == BOT_CLASS_SHAMAN);
+            }
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_PLATE)
+        {
+            //Plate wearers
+            return (me->getLevel() >= 40 &&
+                (_botclass == BOT_CLASS_WARRIOR ||
+                _botclass == BOT_CLASS_DEATH_KNIGHT ||
+                _botclass == BOT_CLASS_PALADIN ||
+                _botclass == BOT_CLASS_BM));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MAIL)
+        {
+            //has mail skill by default
+            if (_botclass == BOT_CLASS_WARRIOR ||
+                _botclass == BOT_CLASS_DEATH_KNIGHT ||
+                _botclass == BOT_CLASS_PALADIN ||
+                _botclass == BOT_CLASS_BM)
+                return true;
+            //Mail wearers
+            return (me->getLevel() >= 40 &&
+                (_botclass == BOT_CLASS_SHAMAN ||
+                _botclass == BOT_CLASS_HUNTER));
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LEATHER)
+        {
+            //exclude classes which can never use leather
+            return (_botclass != BOT_CLASS_WARLOCK &&
+                _botclass != BOT_CLASS_MAGE &&
+                _botclass != BOT_CLASS_PRIEST);
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_CLOTH)
+        {
+            //All classes can wear cloth lol
+            return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_MISC)
+        {
+            if (item->InventoryType == INVTYPE_FEET && slot == BOT_SLOT_FEET)
+                return true;
+            if (item->InventoryType == INVTYPE_BODY && slot == BOT_SLOT_BODY)
+                return true;
+            if (item->InventoryType == INVTYPE_FINGER &&
+                (slot == BOT_SLOT_FINGER1 || slot == BOT_SLOT_FINGER2))
+                return true;
+            if (item->InventoryType == INVTYPE_TRINKET &&
+                (slot == BOT_SLOT_TRINKET1 || slot == BOT_SLOT_TRINKET2))
+                return true;
+            if (item->InventoryType == INVTYPE_NECK && slot == BOT_SLOT_NECK)
+                return true;
+            if (item->InventoryType == INVTYPE_HOLDABLE && slot == BOT_SLOT_OFFHAND && _canUseOffHand())
+                return true;
+        }
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_LIBRAM)
+            return _botclass == BOT_CLASS_PALADIN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_IDOL)
+            return _botclass == BOT_CLASS_DRUID && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_TOTEM)
+            return _botclass == BOT_CLASS_SHAMAN && slot == BOT_SLOT_RANGED;
+        else if (item->SubClass == ITEM_SUBCLASS_ARMOR_SIGIL)
+            return _botclass == BOT_CLASS_DEATH_KNIGHT && slot == BOT_SLOT_RANGED;
+        //misc inv items TODO:
+    }
+
+    return false;
+}
+
+bool bot_minion_ai::_unequip(uint8 slot)
+{
+    ASSERT(!IAmFree());
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to unequip item for bot with no equip info!");
+
+    Item* item = _equips[slot];
+    if (!item)
+        return true; //already unequipped
+
+    uint32 itemId = item->GetEntry();
+
+    //hand old weapon to master
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+    {
+        ItemPosCountVec dest;
+        uint32 no_space = 0;
+        InventoryResult msg = master->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, itemId, 1, &no_space);
+        if (msg != EQUIP_ERR_OK)
+        {
+            std::ostringstream istr, iistr;
+            istr << "Cannot unequip ";
+            _AddItemLink(master, item, iistr);
+            istr << iistr.str() << " for some stupid reason! Sending through mail";
+            ChatHandler ch(master->GetSession());
+            ch.SendSysMessage(istr.str().c_str());
+
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            MailDraft(iistr.str(), "").AddItem(item).SendMailTo(trans, MailReceiver(master), MailSender(me));
+            CharacterDatabase.CommitTransaction(trans);
+
+            //master->SendEquipError(msg, NULL, NULL, itemId);
+            //return false;
+        }
+        else
+        {
+            Item* pItem = master->StoreItem(dest, item, true);
+            master->SendNewItem(pItem, 1, true, false, false);
+        }
+    }
+    else
+    {
+        //slot < BOT_SLOT_RANGED && einfo->ItemEntry[slot] == itemId
+        //we have our standard weapon which we should get rid of
+        //item->SetState(ITEM_REMOVED, master); //delete Item object
+        delete item; //!Invalidated!
+        //item = NULL; //already in "_updateEquips(slot, NULL);"
+    }
+
+    //only for non-standard items
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != itemId)
+        RemoveItemBonuses(slot);
+
+    if (slot < BOT_SLOT_RANGED && CanChangeEquip(slot + 1)) //weapons
+    {
+        me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, 0);
+        me->SetAttackTime(WeaponAttackType(slot), 2000); //without weapon
+    }
+
+    _updateEquips(slot, NULL);
+
+    //offhand check
+    if (slot + 1 == BOT_SLOT_OFFHAND)
+    {
+        if (me->CanDualWield())
+            me->SetCanDualWield(false);
+        if (!(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK))
+            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra |= CREATURE_FLAG_EXTRA_NO_BLOCK;
+    }
+
+    return true;
+}
+
+bool bot_minion_ai::_equip(uint8 slot, Item* newItem)
+{
+    ASSERT(!IAmFree());
+
+    if (!newItem)
+        return true; //nothing to equip
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to equip item for bot with no equip info!");
+
+    ItemTemplate const* proto = newItem->GetTemplate();
+
+    if (newItem->GetState() == ITEM_REMOVED)
+    {
+        TC_LOG_ERROR("entities.player",
+            "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) which has state ITEM_REMOVED!",
+            master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().GetCounter());
+        return false;
+    }
+
+    uint32 newItemId = newItem->GetEntry();
+
+    if (Item* oldItem = _equips[slot])
+    {
+        //same id
+        if (oldItem->GetEntry() == newItemId)
+            return false;
+    }
+
+    if (!_unequip(slot))
+    {
+        BotSay("You have no space for my current item", master);
+        return false;
+    }
+
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+    {
+        //cheating
+        if (newItem->GetOwnerGUID() != master->GetGUID() || !master->HasItemCount(newItemId, 1))
+        {
+            std::ostringstream msg;
+            msg << "Cannot find ";
+            _AddItemLink(master, newItem, msg);
+            msg << " (id: " << uint32(newItemId) << ")!";
+            BotWhisper(msg.str().c_str(), master);
+
+            TC_LOG_ERROR("entities.player",
+                "minion_ai::_equip(): player %s (guidLow: %u) is trying to make bot %s (id: %u) equip item: %s (id: %u, guidLow: %u) but either does not have this item or does not own it",
+                master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), proto->Name1.c_str(), proto->ItemId, newItem->GetGUID().GetCounter());
+            return false;
+        }
+
+        master->MoveItemFromInventory(newItem->GetBagSlot(), newItem->GetSlot(), true);
+        //Item is removed from inventory table in _updateEquips(slot, newItem);
+        newItem->SetGuidValue(ITEM_FIELD_OWNER, ObjectGuid::Empty);
+    }
+
+    if (slot < BOT_SLOT_RANGED)
+    {
+        if (CanChangeEquip(slot + 1))
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + slot, newItemId);
+        uint32 delay =
+            /*einfo->ItemEntry[slot] != newItemId || */!IgnoreEquipsAttackTime() || slot + 1 == BOT_SLOT_OFFHAND ? proto->Delay :
+            slot + 1 == BOT_SLOT_RANGED ? me->GetCreatureTemplate()->RangeAttackTime : me->GetCreatureTemplate()->BaseAttackTime;
+        me->SetAttackTime(WeaponAttackType(slot), delay); //set attack speed
+    }
+
+    _updateEquips(slot, newItem);
+
+    //only for non-standard items
+    if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != newItemId)
+        ApplyItemBonuses(slot);
+
+    if (slot + 1 == BOT_SLOT_OFFHAND)
+    {
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            if (!me->CanDualWield())
+                me->SetCanDualWield(true);
+        }
+        else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+        {
+            if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+        }
+    }
+    else if (slot + 1 == BOT_SLOT_MAINHAND && proto->InventoryType == INVTYPE_2HWEAPON && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        //if have incompatible offhand unequip it
+        if (_equips[BOT_SLOT_OFFHAND - 1] != NULL)
+            _unequip(BOT_SLOT_OFFHAND - 1);
+    }
+
+    return true;
+}
+
+void bot_minion_ai::_updateEquips(uint8 slot, Item* item)
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to update equips for bot with no equip info!");
+
+    _equips[slot] = item;
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    //Commit to DB
+    PreparedStatement* bstmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_EQUIP);
+    //"UPDATE character_npcbot SET equipMhEx = ?, equipOhEx = ?, equipRhEx = ?, equipHead = ?, equipShoulders = ?, equipChest = ?, equipWaist = ?, equipLegs = ?, equipFeet = ?, equipWrist = ?, equipHands = ?, equipBack = ?, equipBody = ?, equipFinger1 = ?, equipFinger2 = ?, equipTrinket1 = ?, equipTrinket2 = ?, equipNeck = ? WHERE entry = ?", CONNECTION_ASYNC
+    PreparedStatement* stmt;
+    uint8 k;
+    for (k = 0; k != BOT_INVENTORY_SIZE; ++k)
+    {
+        if (Item* botitem = _equips[k])
+        {
+            bool standard = false;
+            for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+            {
+                if (einfo->ItemEntry[i] == botitem->GetEntry())
+                {
+                    bstmt->setUInt32(k, 0);
+                    standard = true;
+                    break;
+                }
+            }
+            if (standard)
+                continue;
+
+            uint8 index = 0;
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_REP_ITEM_INSTANCE);
+            //REPLACE INTO item_instance (itemEntry, owner_guid, creatorGuid, giftCreatorGuid, count, duration, charges, flags, enchantments, randomPropertyId, durability, playedTime, text, guid)
+            //VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC : 0-13
+            stmt->setUInt32(  index, botitem->GetEntry());
+            stmt->setUInt32(++index, botitem->GetOwnerGUID().GetCounter());
+            stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_CREATOR).GetCounter());
+            stmt->setUInt32(++index, botitem->GetGuidValue(ITEM_FIELD_GIFTCREATOR).GetCounter());
+            stmt->setUInt32(++index, botitem->GetCount());
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_DURATION));
+
+            std::ostringstream ssSpells;
+            for (uint8 i = 0; i < MAX_ITEM_PROTO_SPELLS; ++i)
+                ssSpells << botitem->GetSpellCharges(i) << ' ';
+            stmt->setString(++index, ssSpells.str());
+
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_FLAGS));
+
+            std::ostringstream ssEnchants;
+            for (uint8 i = 0; i < MAX_ENCHANTMENT_SLOT; ++i)
+            {
+                ssEnchants << botitem->GetEnchantmentId(EnchantmentSlot(i)) << ' ';
+                ssEnchants << botitem->GetEnchantmentDuration(EnchantmentSlot(i)) << ' ';
+                ssEnchants << botitem->GetEnchantmentCharges(EnchantmentSlot(i)) << ' ';
+            }
+            stmt->setString(++index, ssEnchants.str());
+
+            stmt->setInt16 (++index, botitem->GetItemRandomPropertyId());
+            stmt->setUInt16(++index, botitem->GetUInt32Value(ITEM_FIELD_DURABILITY));
+            stmt->setUInt32(++index, botitem->GetUInt32Value(ITEM_FIELD_CREATE_PLAYED_TIME));
+            stmt->setString(++index, botitem->GetText());
+            stmt->setUInt32(++index, botitem->GetGUID().GetCounter());
+
+            trans->Append(stmt);
+
+            botitem->DeleteFromInventoryDB(trans); //prevent duplicates
+
+            bstmt->setUInt32(k, botitem->GetGUID().GetCounter());
+        }
+        else
+            bstmt->setUInt32(k, uint32(0));
+    }
+
+    bstmt->setUInt32(k, me->GetEntry());
+
+    trans->Append(bstmt);
+    CharacterDatabase.CommitTransaction(trans);
+}
+//Called from gossip menu only (applies only to weapons)
+bool bot_minion_ai::_resetEquipment(uint8 slot)
+{
+    ASSERT(!IAmFree());
+    ASSERT(slot < BOT_SLOT_RANGED);
+
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to reset equipment for bot with no equip info!");
+
+    uint32 itemId = einfo->ItemEntry[slot];
+    if (!itemId)
+        return _unequip(slot);
+    else if (Item* oldItem = _equips[slot])
+        if (oldItem->GetEntry() == itemId)
+            return true;
+
+    if (slot + 1 == BOT_SLOT_MAINHAND && !(_botclass == BOT_CLASS_WARRIOR && me->getLevel() >= 60))
+    {
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (proto->Class == ITEM_CLASS_WEAPON &&
+                (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2 ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_SWORD2 || proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM ||
+                proto->SubClass == ITEM_SUBCLASS_WEAPON_STAFF || proto->SubClass == ITEM_SUBCLASS_WEAPON_SPEAR))
+            {
+                if (!_unequip(BOT_SLOT_OFFHAND - 1))
+                    return false;
+            }
+        }
+    }
+
+    //we have our standard weapon itemId which we should use to create new item
+    Item* stItem = Item::CreateItem(itemId, 1, NULL);
+    ASSERT(stItem && "Failed to create standard Item for bot!");
+
+    if (!_equip(slot, stItem))
+    {
+        TC_LOG_ERROR("entities.player", "minion_ai::_resetEquipment(): player %s (guidLow: %u) failed to reset equipment for bot %s (id: %u) in slot %u",
+                master->GetName().c_str(), master->GetGUID().GetCounter(), me->GetName().c_str(), me->GetEntry(), slot);
+        return false;
+    }
+    return true;
+}
+
+void bot_minion_ai::ApplyItemBonuses(uint8 slot)
+{
+    //ensurance to set zeros
+    RemoveItemBonuses(slot);
+
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    ScalingStatDistributionEntry const* ssd = proto->ScalingStatDistribution ? sScalingStatDistributionStore.LookupEntry(proto->ScalingStatDistribution) : NULL;
+
+    uint32 ssd_level = me->getLevel();
+    if (ssd && ssd_level > ssd->MaxLevel)
+        ssd_level = ssd->MaxLevel;
+
+    ScalingStatValuesEntry const* ssv = proto->ScalingStatValue ? sScalingStatValuesStore.LookupEntry(ssd_level) : NULL;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_STATS; ++i)
+    {
+        uint32 statType = 0;
+        int32  val = 0;
+        if (ssd && ssv)
+        {
+            if (ssd->StatMod[i] < 0)
+                continue;
+            statType = ssd->StatMod[i];
+            val = (ssv->getssdMultiplier(proto->ScalingStatValue) * ssd->Modifier[i]) / 10000;
+        }
+        else
+        {
+            if (i >= proto->StatsCount)
+                continue;
+            statType = proto->ItemStat[i].ItemStatType;
+            val = proto->ItemStat[i].ItemStatValue;
+        }
+
+        if (val == 0)
+            continue;
+
+        _stats[slot][statType] += val;
+    }
+
+    _stats[slot][BOT_ITEM_MOD_RESIST_HOLY] += proto->HolyRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FIRE] += proto->FireRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_NATURE] += proto->NatureRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_FROST] += proto->FrostRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_SHADOW] += proto->ShadowRes;
+    _stats[slot][BOT_ITEM_MOD_RESIST_ARCANE] += proto->ArcaneRes;
+
+    _stats[slot][BOT_ITEM_MOD_DAMAGE] += (proto->Damage[0].DamageMin + proto->Damage[0].DamageMax) / 2;
+    _stats[slot][BOT_ITEM_MOD_ARMOR] += proto->Armor;
+    _stats[slot][BOT_ITEM_MOD_BLOCK_VALUE] += proto->Block;
+
+    if (GetPlayerClass() == BOT_CLASS_DRUID)
+    {
+        int32 dpsMod = 0;
+        int32 feral_bonus = 0;
+
+        if (ssv)
+        {
+            dpsMod = ssv->getDPSMod(proto->ScalingStatValue);
+            feral_bonus += ssv->getFeralBonus(proto->ScalingStatValue);
+        }
+
+        feral_bonus += proto->getFeralBonus(dpsMod);
+        if (feral_bonus)
+            _stats[slot][BOT_ITEM_MOD_FERAL_ATTACK_POWER] += feral_bonus;
+            //ApplyFeralAPBonus(feral_bonus, apply);
+    }
+
+    ApplyItemEnchantments(item, slot);
+    ApplyItemEquipSpell(item, true);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::RemoveItemBonuses(uint8 slot)
+{
+    Item* item = _equips[slot];
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = sObjectMgr->GetItemTemplate(item->GetEntry());
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_BOT_ITEM_MOD; ++i)
+        _stats[slot][i] = 0;
+
+    RemoveItemEnchantments(item, slot); //remove spells
+    ApplyItemEquipSpell(item, false);
+
+    shouldUpdateStats = true;
+}
+
+void bot_minion_ai::ApplyItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        ApplyItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_minion_ai::ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    if (pEnchant->requiredLevel > me->getLevel())
+        return;
+
+    uint32 enchant_display_type;
+    uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                _stats[slot][BOT_ITEM_MOD_DAMAGE] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                {
+                    int32 basepoints = 0;
+                    // Random Property Exist - try found basepoints for spell (basepoints depends from item suffix factor)
+                    if (item->GetItemRandomPropertyId())
+                    {
+                        ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                        if (item_rand)
+                        {
+                            // Search enchant_amount
+                            for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                            {
+                                if (item_rand->enchant_id[k] == enchant_id)
+                                {
+                                    basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                    // Cast custom spell vs all equal basepoints got from enchant_amount
+                    if (basepoints)
+                        me->CastCustomSpell(me, enchant_spell_id, &basepoints, &basepoints, &basepoints, true, item);
+                    else
+                        me->CastSpell(me, enchant_spell_id, true, item);
+                }
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand)
+                    {
+                        for (uint8 k = 0; k < MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+                _stats[slot][BOT_ITEM_MOD_RESISTANCE_START + enchant_spell_id] += enchant_amount;
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+            {
+                if (!enchant_amount)
+                {
+                    ItemRandomSuffixEntry const* item_rand_suffix = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+                    if (item_rand_suffix)
+                    {
+                        for (uint8 k = 0; k != MAX_ITEM_ENCHANTMENT_EFFECTS; ++k)
+                        {
+                            if (item_rand_suffix->enchant_id[k] == enchant_id)
+                            {
+                                enchant_amount = uint32((item_rand_suffix->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                                break;
+                            }
+                        }
+                    }
+                }
+
+                switch (enchant_spell_id)
+                {
+                    case ITEM_MOD_MANA:
+                    case ITEM_MOD_HEALTH:
+                    case ITEM_MOD_AGILITY:
+                    case ITEM_MOD_STRENGTH:
+                    case ITEM_MOD_INTELLECT:
+                    case ITEM_MOD_SPIRIT:
+                    case ITEM_MOD_STAMINA:
+                    case ITEM_MOD_DEFENSE_SKILL_RATING:
+                    case ITEM_MOD_DODGE_RATING:
+                    case ITEM_MOD_PARRY_RATING:
+                    case ITEM_MOD_BLOCK_RATING:
+                    case ITEM_MOD_HIT_MELEE_RATING:
+                    case ITEM_MOD_HIT_RANGED_RATING:
+                    case ITEM_MOD_HIT_SPELL_RATING:
+                    case ITEM_MOD_CRIT_MELEE_RATING:
+                    case ITEM_MOD_CRIT_RANGED_RATING:
+                    case ITEM_MOD_CRIT_SPELL_RATING:
+                    case ITEM_MOD_HASTE_MELEE_RATING:
+                    case ITEM_MOD_HASTE_RANGED_RATING:
+                    case ITEM_MOD_HASTE_SPELL_RATING:
+                    case ITEM_MOD_HIT_RATING:
+                    case ITEM_MOD_CRIT_RATING:
+                    case ITEM_MOD_HASTE_RATING:
+                    case ITEM_MOD_RESILIENCE_RATING:
+                    case ITEM_MOD_EXPERTISE_RATING:
+                    case ITEM_MOD_ATTACK_POWER:
+                    case ITEM_MOD_RANGED_ATTACK_POWER:
+                    case ITEM_MOD_MANA_REGENERATION:
+                    case ITEM_MOD_ARMOR_PENETRATION_RATING:
+                    case ITEM_MOD_SPELL_POWER:
+                    case ITEM_MOD_SPELL_PENETRATION:
+                    case ITEM_MOD_BLOCK_VALUE:
+                    case ITEM_MOD_SPELL_HEALING_DONE:   // deprecated
+                    case ITEM_MOD_SPELL_DAMAGE_DONE:    // deprecated
+                        _stats[slot][enchant_spell_id] += enchant_amount;
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            }
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::RemoveItemEnchantments(Item* item, uint8 slot)
+{
+    for (uint8 i = 0; i != MAX_ENCHANTMENT_SLOT; ++i)
+        RemoveItemEnchantment(item, EnchantmentSlot(i), slot);
+}
+
+void bot_minion_ai::RemoveItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 /*slot*/)
+{
+    uint32 enchant_id = item->GetEnchantmentId(eslot);
+    if (!enchant_id)
+        return;
+
+    SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+    if (!pEnchant)
+        return;
+
+    ////skip level reqs
+    //if (pEnchant->requiredLevel > me->getLevel())
+    //    return;
+
+    uint32 enchant_display_type;
+    //uint32 enchant_amount;
+    uint32 enchant_spell_id;
+
+    for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+    {
+        enchant_display_type = pEnchant->type[s];
+        //enchant_amount = pEnchant->amount[s];
+        enchant_spell_id = pEnchant->spellid[s];
+
+        switch (enchant_display_type)
+        {
+            case ITEM_ENCHANTMENT_TYPE_DAMAGE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_EQUIP_SPELL:
+                if (enchant_spell_id)
+                    me->RemoveAurasDueToItemSpell(enchant_spell_id, item->GetGUID());
+                break;
+            case ITEM_ENCHANTMENT_TYPE_RESISTANCE:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_STAT:
+                //Already removed in RemoveItemBonuses()
+                break;
+            case ITEM_ENCHANTMENT_TYPE_TOTEM:           // Shaman Rockbiter Weapon
+            case ITEM_ENCHANTMENT_TYPE_USE_SPELL:
+            case ITEM_ENCHANTMENT_TYPE_PRISMATIC_SOCKET:
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void bot_minion_ai::ApplyItemEquipSpell(Item* item, bool apply)
+{
+    if (!item)
+        return;
+
+    ItemTemplate const* proto = item->GetTemplate();
+    if (!proto)
+        return;
+
+    for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+    {
+        _Spell const& spellData = proto->Spells[i];
+
+        if (!spellData.SpellId)
+            continue;
+
+        // wrong triggering type
+        if (apply && spellData.SpellTrigger != ITEM_SPELLTRIGGER_ON_EQUIP)
+            continue;
+
+        // check if it is valid spell
+        SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+        if (!spellInfo)
+            continue;
+
+        //ApplyEquipSpell(spellproto, item, apply);
+
+        //if (apply)
+        //    me->AddAura(spellInfo->Id, me);
+        //else
+        //    me->RemoveAura(spellInfo->Id);
+
+        if (apply)
+            me->CastSpell(me, spellInfo, true, item);
+        else
+            me->RemoveAurasDueToItemSpell(spellInfo->Id, item->GetGUID());  // un-apply all spells, not only at-equipped
+    }
+}
+
+void bot_minion_ai::ApplyItemsSpells()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    //only for non-standard items
+    for (uint8 slot = 0; slot != BOT_INVENTORY_SIZE; ++slot)
+        if (Item* item = _equips[slot])
+            if (slot >= BOT_SLOT_RANGED || einfo->ItemEntry[slot] != item->GetEntry())
+                ApplyItemEquipSpell(item, true);
+}
+
+inline float bot_minion_ai::_getBotStat(uint8 slot, uint8 stat) const
+{
+    return float(static_cast<BotStat>(_stats[slot])[stat]);
+}
+
+inline float bot_minion_ai::_getTotalBotStat(uint8 stat) const
+{
+    int32 value = 0;
+    for (uint8 slot = 0; slot != BOT_INVENTORY_SIZE; ++slot)
+        value += static_cast<BotStat>(_stats[slot])[stat];
+
+    return float(value);
+}
+
+inline float bot_minion_ai::_getRatingMultiplier(CombatRating cr) const
+{
+    GtCombatRatingsEntry const* Rating =
+        sGtCombatRatingsStore.LookupEntry(cr*GT_MAX_LEVEL + (me->getLevel()-1));
+    GtOCTClassCombatRatingScalarEntry const* classRating =
+        sGtOCTClassCombatRatingScalarStore.LookupEntry((GetPlayerClass()-1)*GT_MAX_RATING + cr + 1);
+    if (!Rating || !classRating)
+        return 1.0f;
+
+    //bots gain 20% increased bonus from rating mods
+    return 1.2f * classRating->ratio / Rating->ratio;
+}
+
+char const* bot_minion_ai::_getNameForSlot(uint8 slot) const
+{
+    switch (slot)
+    {
+        case BOT_SLOT_MAINHAND:
+            return "Main Hand Weapon";
+        case BOT_SLOT_OFFHAND:
+            return "Offhand Weapon";
+        case BOT_SLOT_RANGED:
+            return "Ranged Weapon";
+        case BOT_SLOT_HEAD:
+            return "Head";
+        case BOT_SLOT_SHOULDERS:
+            return "Shoulders";
+        case BOT_SLOT_CHEST:
+            return "Chest";
+        case BOT_SLOT_WAIST:
+            return "Waist";
+        case BOT_SLOT_LEGS:
+            return "Legs";
+        case BOT_SLOT_FEET:
+            return "Feet";
+        case BOT_SLOT_WRIST:
+            return "Wrist";
+        case BOT_SLOT_HANDS:
+            return "Hands";
+        case BOT_SLOT_BACK:
+            return "Back";
+        case BOT_SLOT_BODY:
+            return "Body";
+        case BOT_SLOT_FINGER1:
+            return "Finger1";
+        case BOT_SLOT_FINGER2:
+            return "Finger2";
+        case BOT_SLOT_TRINKET1:
+            return "Trinket1";
+        case BOT_SLOT_TRINKET2:
+            return "Trinket2";
+        case BOT_SLOT_NECK:
+            return "Neck";
+        default:
+            return "Unknown";
+    }
+}
+
+uint8 bot_minion_ai::_onOffIcon(uint8 role) const
+{
+    return HasRole(role) ? BOT_ICON_ON : BOT_ICON_OFF;
+}
+
+bool bot_minion_ai::CanHeal() const
+{
+    return
+        (_botclass == BOT_CLASS_PRIEST || _botclass == BOT_CLASS_DRUID ||
+        _botclass == BOT_CLASS_SHAMAN || _botclass == BOT_CLASS_PALADIN);
+}
+
+char const* bot_ai::GetRoleString(uint8 role) const
+{
+    switch (role)
+    {
+        case BOT_ROLE_NONE:
+            return "???";
+        case BOT_ROLE_TANK:
+            return "Tanking";
+        case BOT_ROLE_DPS:
+            return "DPS";
+        case BOT_ROLE_HEAL:
+            return "Heal";
+        //case BOT_ROLE_MELEE:
+        //    return "Melee";
+        case BOT_ROLE_RANGED:
+            return "Ranged";
+        default:
+        {
+            std::ostringstream str;
+            str << "role " << uint32(role);
+            return str.str().c_str();
+        }
+    }
+}
+
+void bot_ai::DefaultInit()
+{
+    //only once
+    if (spawned) return;
+    spawned = true;
+
+    if (!firstspawn)
+    {
+        me->RemoveAllAuras();
+        if (IsMinionAI())
+            ToMinionAI()->ApplyItemsSpells();
+    }
+
+    //*etStats() has *pplyClassPassives() in it
+    //needed to be before InitEquips for some classes (warrior TG)
+    me->SetPvP(true);
+    InitRoles();
+    SetStats(true);
+    //InitPowers(); //already in *etStats();
+    ApplyPassives();
+
+    if (firstspawn)
+    {
+        firstspawn = false;
+        ASSERT(!me->GetBotAI());
+        me->SetBotAI(this);
+        InitFaction();
+        InitOwner();
+        InitEquips();
+
+        InitSpellMap(PVPTRINKET, true);
+    }
+}
+
+void bot_minion_ai::InitFaction()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_FACTION);
+    //"SELECT faction FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    ASSERT(result);
+
+    Field* field = result->Fetch();
+    uint32 faction = field[0].GetUInt32();
+    me->setFaction(faction);
+    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->faction = faction;
+}
+
+void bot_minion_ai::InitOwner()
+{
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+    //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    ASSERT(result);
+
+    Field* field = result->Fetch();
+    _ownerGuid = field[0].GetUInt32();
+}
+
+void bot_minion_ai::InitRoles()
+{
+    if (IAmFree())
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_ROLES);
+    //"SELECT roles FROM character_npcbot WHERE entry = ?", CONNECTION_SYNC
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        //default roles
+        _roleMask = BOT_ROLE_DPS;
+        if (!IsMeleeClass(_botclass))
+            _roleMask |= BOT_ROLE_RANGED;
+        if (CanHeal())
+            _roleMask |= BOT_ROLE_HEAL;
+
+        return;
+    }
+
+    Field* field = result->Fetch();
+    _roleMask = field[0].GetInt8();
+}
+
+void bot_pet_ai::InitRoles()
+{
+    _roleMask = BOT_ROLE_DPS;
+    if (!IsMeleeClass(GetPetClass(me)))
+        _roleMask |= BOT_ROLE_RANGED;
+    if (CanHeal())
+        _roleMask |= BOT_ROLE_HEAL;
+}
+
+void bot_minion_ai::InitEquips()
+{
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+    ASSERT(einfo && "Trying to spawn bot with no equip info!");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+    //"SELECT equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck
+    //FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult cnresult = CharacterDatabase.Query(stmt);
+    if (!cnresult)
+    {
+        TC_LOG_ERROR("entities.player", "bot_minion_ai::InitEquips(): Failed to initialize equips for bot %s (id: %u, guidLow: %u), not found in `characters_npcbots table`!!!",
+            me->GetName().c_str(), me->GetEntry(), me->GetGUID().GetCounter());
+        ASSERT(false);
+    }
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP_BY_ITEM_INSTANCE);
+    //                    0                   1         2            3           4         5                6                    7              8             9        10       11            12             13
+    //SELECT ii.creatorGuid, ii.giftCreatorGuid, ii.count, ii.duration, ii.charges, ii.flags, ii.enchantments, ii.randomPropertyId, ii.durability, ii.playedTime, ii.text, ii.guid, ii.itemEntry, ii.owner_guid "
+    //  "FROM item_instance ii JOIN characters_npcbot cn ON ii.guid IN "
+    //  "(cn.equipMhEx, cn.equipOhEx, cn.equipRhEx, cn.equipHead, cn.equipShoulders, cn.equipChest, cn.equipWaist, cn.equipLegs, cn.equipFeet, cn.equipWrist, cn.equipHands, cn.equipBack, cn.equipBody, cn.equipFinger1, cn.equipFinger2, cn.equipTrinket1, cn.equipTrinket2, cn.equipNeck) "
+    //  "WHERE cn.entry = ?", CONNECTION_SYNCH
+    stmt->setUInt32(0, me->GetEntry());
+    PreparedQueryResult iiresult = CharacterDatabase.Query(stmt);
+
+    Field* fields1 = cnresult->Fetch();
+    Field* fields2;
+    uint32 itemId;
+    uint32 itemGuidLow;
+    Item* item;
+
+    if (!iiresult) //blank bot - fill with standard items
+    {
+        for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+        {
+            itemId = einfo->ItemEntry[i];
+            if (!itemId)
+                continue;
+
+            item = Item::CreateItem(itemId, 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot!");
+            _equips[i] = item;
+        }
+    }
+    else
+    {
+        do
+        {
+            fields2 = iiresult->Fetch();
+            itemGuidLow = fields2[11].GetUInt32();
+            itemId = fields2[12].GetUInt32();
+            item = new Item;
+            ASSERT(item->LoadFromDB(itemGuidLow, ObjectGuid::Empty, fields2, itemId));
+            //gonna find where to store our new item
+            bool found = false;
+            uint8 i = 0;
+            for (; i != BOT_INVENTORY_SIZE; ++i)
+            {
+                if (fields1[i].GetUInt32() == itemGuidLow && !_equips[i])
+                {
+                    _equips[i] = item;
+                    found = true;
+                    break;
+                }
+            }
+            ASSERT(found);
+            //ItemTemplate const* proto = item->GetTemplate();
+            //TC_LOG_ERROR("entities.player", "minion_ai::InitEquips(): bot %s (id: %u): found item: for slot %u: %s (id: %u, guidLow: %u)",
+            //    me->GetName().c_str(), me->GetEntry(), i, proto->Name1.c_str(), itemId, itemGuidLow);
+
+        } while (iiresult->NextRow());
+    }
+
+    //visualize
+    for (uint8 i = 0; i != BOT_SLOT_RANGED; ++i)
+    {
+        if (CanChangeEquip(i + 1) && _equips[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, _equips[i]->GetEntry());
+        else if (einfo->ItemEntry[i])
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+    }
+
+    //apply weapons' parameters
+    if (Item* MH = _equips[0])
+    {
+        itemId = MH->GetEntry();
+        if (einfo->ItemEntry[0] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                me->SetAttackTime(BASE_ATTACK, proto->Delay);
+                ApplyItemBonuses(0);
+            }
+        }
+    }
+    if (Item* OH = _equips[1])
+    {
+        itemId = OH->GetEntry();
+        if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+        {
+            if (einfo->ItemEntry[1] != itemId)
+                ApplyItemBonuses(1);
+
+            if (proto->Class == ITEM_CLASS_WEAPON)
+            {
+                me->SetAttackTime(OFF_ATTACK, proto->Delay);
+                me->SetCanDualWield(true);
+            }
+            else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+            {
+                if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                    const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+            }
+        }
+    }
+    if (Item* RH = _equips[2])
+    {
+        itemId = RH->GetEntry();
+        if (einfo->ItemEntry[2] != itemId)
+        {
+            if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(itemId))
+            {
+                if (proto->Class == ITEM_CLASS_WEAPON)
+                    me->SetAttackTime(RANGED_ATTACK, proto->Delay);
+
+                ApplyItemBonuses(2);
+            }
+        }
+    }
+
+    for (uint8 i = 3; i != BOT_INVENTORY_SIZE; ++i)
+        ApplyItemBonuses(i);
+
+    for (uint8 i = 0; i != MAX_EQUIPMENT_ITEMS; ++i)
+    {
+        if (_equips[i] == NULL && einfo->ItemEntry[i] != 0)
+        {
+            if (i == 1 && !_canUseOffHand())
+                continue;
+
+            //if bot has no equips but equip template then write these to bot map
+            item = Item::CreateItem(einfo->ItemEntry[i], 1, NULL);
+            ASSERT(item && "Failed to init standard Item for bot point 2!");
+            _equips[i] = item;
+
+            me->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + i, einfo->ItemEntry[i]);
+            if (i == 1)
+            {
+                if (ItemTemplate const* proto = sObjectMgr->GetItemTemplate(einfo->ItemEntry[i]))
+                {
+                    if (proto->Class == ITEM_CLASS_WEAPON)
+                    {
+                        me->SetAttackTime(OFF_ATTACK, _botclass == BOT_CLASS_ROGUE ? 1400 : 1800);
+                        me->SetCanDualWield(true);
+                    }
+                    else if (proto->Class == ITEM_CLASS_ARMOR && proto->SubClass == ITEM_SUBCLASS_ARMOR_SHIELD)
+                    {
+                        if (me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK)
+                            const_cast<CreatureTemplate*>(me->GetCreatureTemplate())->flags_extra &= ~CREATURE_FLAG_EXTRA_NO_BLOCK;
+                    }
+                }
+            }
+        }
+    }
+}
+
+void bot_ai::ToggleRole(uint8 role, bool force)
+{
+    if (!force && roleTimer > 0)
+        return;
+
+    roleTimer = 350; //delay next attempt (prevent abuse)
+
+    HasRole(role) ? _roleMask &= ~role : _roleMask |= role;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_ROLES);
+    //"UPDATE character_npcbot SET roles = ? WHERE entry = ?", CONNECTION_ASYNC
+    stmt->setUInt8(0, _roleMask);
+    stmt->setUInt32(1, me->GetEntry());
+    CharacterDatabase.Execute(stmt);
+
+    //Update passives
+    ApplyPassives();
+    shouldUpdateStats = true;
+}
+
+bool bot_ai::IsTank(Unit* unit) const
+{
+    if (!unit)
+        unit = me;
+
+    if (unit == me)
+        return HasRole(BOT_ROLE_TANK);
+
+    if (Creature* bot = unit->ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            return bot->GetBotAI()->HasRole(BOT_ROLE_TANK);
+
+    if (Player* player = unit->ToPlayer())
+    {
+        if (Group* gr = player->GetGroup())
+        {
+            Group::MemberSlotList const& slots = gr->GetMemberSlots();
+            for (Group::member_citerator itr = slots.begin(); itr != slots.end(); ++itr)
+                if (itr->guid == player->GetGUID())
+                    return itr->flags & MEMBER_FLAG_MAINTANK;
+        }
+    }
+
+    return false;
+}
+
+void bot_ai::FindMaster(bool force)
+{
+    if (!force)
+    {
+        //totally free
+        if (!_ownerGuid)
+            return;
+        if (!_atHome || _evadeMode)
+            return;
+
+        //delay
+        if (checkMasterTimer > 0)
+            return;
+
+        checkMasterTimer = urand(5000, 15000);
+    }
+
+    //already have master
+    if (!IAmFree())
+        return;
+
+    if (Player* player = sObjectMgr->GetPlayerByLowGUID(_ownerGuid))
+    {
+        //prevent bot being screwed up because of wrong flags
+        if (player->IsGameMaster() || player->GetSession()->isLogingOut())
+            return;
+
+        SetBotOwner(player);
+
+        //fail
+        if (master != player)
+            return;
+
+        if (!IsTempBot())
+            BotWhisper("Hey...", master);
+        return;
+    }
+}
+
+bool bot_minion_ai::IAmFree() const
+{
+    if (!_ownerGuid)
+        return true;
+    if (_ownerGuid != master->GetGUID())
+        return true;
+    if (!me->HasUnitTypeMask(UNIT_MASK_MINION))
+        return true;
+
+    return false;
+    //return (!_ownerGuid || _ownerGuid != master->GetGUID() || !me->HasUnitTypeMask(UNIT_MASK_MINION));
+    //        //has owner   and   //owner is found          and        //bound to owner
+}
+
+void bot_minion_ai::SavePosition()
+{
+    if (_saveTimer > 0) return;
+    if (!me->IsPositionValid()) return;
+    if (me->IsInCombat() || !me->IsInWorld())
+    {
+        _saveTimer = 3000;
+        return;
+    }
+
+    _saveTimer = sWorld->getIntConfig(CONFIG_INTERVAL_SAVE);
+
+    uint16 mapid = me->GetMapId();
+    float x = me->GetPositionX();
+    float y = me->GetPositionY();
+    float z = me->GetPositionZ();
+    float o = me->GetOrientation();
+
+    if (CreatureData const* data = sObjectMgr->GetCreatureData(me->GetSpawnId()))
+    {
+        const_cast<CreatureData*>(data)->mapid = mapid;
+        const_cast<CreatureData*>(data)->posX = x;
+        const_cast<CreatureData*>(data)->posY = y;
+        const_cast<CreatureData*>(data)->posZ = z;
+        const_cast<CreatureData*>(data)->orientation = o;
+    }
+
+    PreparedStatement* stmt = WorldDatabase.GetPreparedStatement(WORLD_UPD_NPCBOT_POSITION);
+    //"UPDATE creature SET map = ?, position_x = ?, position_y = ?, position_z = ?, orientation = ? WHERE guid = ?", CONNECTION_ASYNC
+    stmt->setUInt16(0, mapid);
+    stmt->setFloat(1, x);
+    stmt->setFloat(2, y);
+    stmt->setFloat(3, z);
+    stmt->setFloat(4, o);
+    stmt->setUInt32(5, me->GetSpawnId());
+
+    WorldDatabase.Execute(stmt);
+}
+
+//UTILITIES
+void bot_ai::_AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const
+{
+    //color
+    str << "|c";
+    switch (item->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << uint32(item->ItemId) << ':';
+
+    //permanent enchantment, 3 gems, 4 unknowns, reporter_level (9)
+    str << "0:0:0:0:0:0:0:0:0";
+
+    //name
+    std::string name = item->Name1;
+    _LocalizeItem(forPlayer, name, item->ItemId);
+    str << "|h[" << name << "]|h|r";
+
+    //max in stack
+    if (item->BuyCount > 1)
+        str<< "|cff009900x" << item->BuyCount << ".|r";
+    else
+        str << "|cff009900.|r";
+}
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:0:reporter_level|h[name]|h|r
+// |cffa335ee|Hitem:812:0:0:0:0:0:0:0:70|h[Glowing Brightwood Staff]|h|r
+void bot_ai::_AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const
+{
+    ItemTemplate const* proto = item->GetTemplate();
+
+    //color
+    str << "|c";
+    switch (proto->Quality)
+    {
+        case ITEM_QUALITY_POOR:     str << "ff9d9d9d"; break;  //GREY
+        case ITEM_QUALITY_NORMAL:   str << "ffffffff"; break;  //WHITE
+        case ITEM_QUALITY_UNCOMMON: str << "ff1eff00"; break;  //GREEN
+        case ITEM_QUALITY_RARE:     str << "ff0070dd"; break;  //BLUE
+        case ITEM_QUALITY_EPIC:     str << "ffa335ee"; break;  //PURPLE
+        case ITEM_QUALITY_LEGENDARY:str << "ffff8000"; break;  //ORANGE
+        case ITEM_QUALITY_ARTIFACT: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        case ITEM_QUALITY_HEIRLOOM: str << "ffe6cc80"; break;  //LIGHT YELLOW
+        default:                    str << "ff000000"; break;  //UNK BLACK
+    }
+    str << "|Hitem:" << proto->ItemId << ':';
+
+    //gems (3)
+    uint32 g1 = 0, g2 = 0, g3 = 0;
+    for (uint32 slot = SOCK_ENCHANTMENT_SLOT; slot != SOCK_ENCHANTMENT_SLOT + MAX_ITEM_PROTO_SOCKETS; ++slot)
+    {
+        uint32 eId = item->GetEnchantmentId(EnchantmentSlot(slot));
+
+// |color|Hitem:item_id:perm_ench_id:gem1:gem2:gem3:0:random_property:0:reporter_level|h[name]|h|r
+        switch (slot - SOCK_ENCHANTMENT_SLOT)
+        {
+            case 0: g1 = eId;   break;
+            case 1: g2 = eId;   break;
+            case 2: g3 = eId;   break;
+        }
+    }
+    //permanent enchantment
+    str << item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ':';
+    //gems 3
+    str << g1 << ':' << g2 << ':' << g3 << ':';
+    //gems bonus - useless
+    //str << item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ':';
+    str << 0 << ':';
+    //random property
+    str << item-> GetItemRandomPropertyId() << ':';
+    //item suffix
+    //str << item->GetItemSuffixFactor() << ':';
+    //temp enchantment (i.e. windfury weapon)
+    //str << item->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT) << ':';
+    //str << 0 << ':';
+
+    ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(abs(item->GetItemRandomPropertyId()));
+    uint32 bpoints = 0;
+    if (item_rand)
+    {
+        // Search enchant_amount
+        for (uint8 k = 0; k != 3; ++k)
+        {
+            if (item_rand->enchant_id[k])
+            {
+                uint32 basepoints = int32((item_rand->prefix[k] * item->GetItemSuffixFactor()) / 10000);
+                if (basepoints > bpoints)
+                    bpoints = basepoints;
+            }
+        }
+    }
+
+    str << bpoints << ':';
+
+    //reporter level
+    str << proto->RequiredLevel;
+
+    //name
+    std::string name = proto->Name1;
+    std::string suffix;
+    _LocalizeItem(forPlayer, name, suffix, item);
+
+    str << "|h[" << name << suffix << "]|h|r";
+
+    //quantity
+    if (item->GetCount() > 1)
+        str << "x" << item->GetCount() << ' ';
+}
+
+void bot_ai::_AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const
+{
+    std::string questTitle = quest->GetTitle();
+    _LocalizeQuest(forPlayer, questTitle, quest->GetQuestId());
+    str << "|cFFEFFD00|Hquest:" << quest->GetQuestId() << ':' << quest->GetQuestLevel() << "|h[" << questTitle << "]|h|r";
+}
+
+void bot_ai::_AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|cff00ffff|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << " : " << master->GetSkillValue(skillid) << " /" << master->GetMaxSkillValue(skillid) << "]|h|r";
+}
+//|cff71d5ff|Hspell:21563|h[Command]|h|r
+void bot_ai::_AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color/* = true*/, const std::string& colorstr/* = "ffffffff"*/) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    str << "|c";
+
+    if (color)
+    {
+        switch (GetFirstSchoolInMask(spellInfo->GetSchoolMask()))
+        {
+            case SPELL_SCHOOL_NORMAL:       str << "ffffff00"; break; //YELLOW
+            case SPELL_SCHOOL_HOLY:         str << "ffffe680"; break; //LIGHT YELLOW
+            case SPELL_SCHOOL_FIRE:         str << "ffff8000"; break; //ORANGE
+            case SPELL_SCHOOL_NATURE:       str << "ff4dff4d"; break; //GREEN
+            case SPELL_SCHOOL_FROST:        str << "ff80ffff"; break; //LIGHT BLUE
+            case SPELL_SCHOOL_SHADOW:       str << "ff8080ff"; break; //DARK BLUE
+            case SPELL_SCHOOL_ARCANE:       str << "ffff80ff"; break; //LIGHT PURPLE
+            default:                        str << "ffffffff"; break; //UNK WHITE
+        }
+    }
+    else
+        str << colorstr; //explicit color default white
+
+
+    str << "|Hspell:" << spellInfo->Id << "|h[" << spellInfo->SpellName[loc] << "]|h|r";
+}
+
+void bot_ai::_AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const
+{
+    ASSERT(master->HasSkill(skillId));
+    // |cffffd000|Htrade:4037:1:150:1:6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA|h[Engineering]|h|r
+    uint32 loc = forPlayer->GetSession()->GetSessionDbcLocale();
+    SkillLineEntry const* skillInfo = sSkillLineStore.LookupEntry(skillId);
+    if (skillInfo)
+    {
+        uint32 curValue = master->GetPureSkillValue(skillId);
+        uint32 maxValue  = master->GetPureMaxSkillValue(skillId);
+        str << "|cffffd000|Htrade:" << spellInfo->Id << ':' << curValue << ':' << maxValue << ':' << master->GetGUID().GetCounter() << ":6AAAAAAAAAAAAAAAAAAAAAAOAADAAAAAAAAAAAAAAAAIAAAAAAAAA" << "|h[" << skillInfo->name[loc] << "]|h|r";
+    }
+}
+//Localization
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(entry);
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+}
+
+void bot_ai::_LocalizeItem(Player* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    ItemLocale const* itemInfo = sObjectMgr->GetItemLocale(item->GetEntry());
+    if (!itemInfo)
+        return;
+
+    if (itemInfo->Name.size() > loc && !itemInfo->Name[loc].empty())
+    {
+        const std::string name = itemInfo->Name[loc];
+        if (Utf8FitTo(name, wnamepart))
+            itemName = name;
+    }
+
+    int32 randomPropId = item->GetItemRandomPropertyId();
+    if (!randomPropId)
+        return;
+
+    if (randomPropId > 0)
+    {
+        if (ItemRandomPropertiesEntry const* item_rand = sItemRandomPropertiesStore.LookupEntry(randomPropId))
+            suffix = item_rand->nameSuffix[loc];
+    }
+    else
+    {
+        if (ItemRandomSuffixEntry const* item_rand = sItemRandomSuffixStore.LookupEntry(-randomPropId))
+             suffix = item_rand->nameSuffix[loc];
+    }
+}
+
+void bot_ai::_LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    QuestLocale const* questInfo = sObjectMgr->GetQuestLocale(entry);
+    if (!questInfo)
+        return;
+
+    if (questInfo->Title.size() > loc && !questInfo->Title[loc].empty())
+    {
+        const std::string title = questInfo->Title[loc];
+        if (Utf8FitTo(title, wnamepart))
+            questTitle = title;
+    }
+}
+
+void bot_ai::_LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    CreatureLocale const* creatureInfo = sObjectMgr->GetCreatureLocale(entry);
+    if (!creatureInfo)
+        return;
+
+    if (creatureInfo->Name.size() > loc && !creatureInfo->Name[loc].empty())
+    {
+        const std::string title = creatureInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            creatureName = title;
+    }
+}
+
+void bot_ai::_LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const
+{
+    uint32 loc = forPlayer->GetSession()->GetSessionDbLocaleIndex();
+    std::wstring wnamepart;
+
+    GameObjectLocale const* gameObjectInfo = sObjectMgr->GetGameObjectLocale(entry);
+    if (!gameObjectInfo)
+        return;
+
+    if (gameObjectInfo->Name.size() > loc && !gameObjectInfo->Name[loc].empty())
+    {
+        const std::string title = gameObjectInfo->Name[loc];
+        if (Utf8FitTo(title, wnamepart))
+            gameobjectName = title;
+    }
+}
+
+void bot_ai::BotSpeak(std::string const& text, uint8 msgtype, uint32 language, ObjectGuid speaker, ObjectGuid receiver)
+{
+    if (msgtype == CHAT_MSG_WHISPER)
+        language = LANG_UNIVERSAL;
+
+    std::string _text(text);
+    //sScriptMgr->OnPlayerChat(this, CHAT_MSG_SAY, language, _text);
+
+    WorldPacket data(SMSG_MESSAGECHAT, 200);
+    //BuildPlayerChat(&data, msgType, _text, language);
+    data << uint8(msgtype);
+    data << uint32(language);
+    data << uint64(speaker);
+    data << uint32(0);                 // constant unknown time
+    data << uint64(speaker);
+    data << uint32(text.length() + 1);
+    data << text;
+    data << uint8(0);
+
+    if (msgtype == CHAT_MSG_WHISPER)
+    {
+        ASSERT(receiver && "BotSpeak(): no receiver for whisper!");
+        ASSERT(receiver.IsPlayer() && "BotSpeak(): whisper receiver is not a player!");
+
+        if (Player* res = ObjectAccessor::FindPlayer(receiver))
+            res->GetSession()->SendPacket(&data);
+    }
+    else
+    {
+        if (Unit* snd = ObjectAccessor::FindConnectedPlayer(speaker))
+        {
+            float dist = std::max<float>(sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL) * 0.5f);
+            Trinity::MessageDistDeliverer notifier(snd, &data, dist, false);
+            snd->VisitNearbyWorldObject(dist, notifier);
+        }
+    }
+    //SendMessageToSetInRange(&data, sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY), true);
+}
+
+void bot_minion_ai::BotJump(Position* pos)
+{
+    ++_jumpCount;
+
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(*pos, me->GetExactDist2d(pos->m_positionX, pos->m_positionY), 10.0f);
+
+    //float dx = pos->m_positionX - me->m_positionX;
+    //float dy = pos->m_positionY - me->m_positionY;
+    //float fdx = fabs(dx); float fdy = fabs(dy);
+    //float divider = fdx > 400 || fdy > 400 ? 5.0f : fdx > 200 || fdy > 200 ? 3.0f : fdx > 100 || fdy > 100 ? 2.0f : 1.5f;
+    //dx = dx / divider + me->m_positionX;
+    //dy = dy / divider + me->m_positionY;
+    //float z = me->GetMap()->GetHeight(dx, dy, std::max<float>(me->m_positionZ, pos->m_positionZ));
+
+    //if (z > INVALID_HEIGHT)
+    //    me->GetMotionMaster()->MoveJump(dx, dy, z, me->GetExactDist2d(dx, dy), 10.0f);
+}
+
+bool bot_minion_ai::UpdateImpossibleChase(Unit* target)
+{
+    if (_chaseTimer || me->isMoving() || !IAmFree())
+        return false;
+
+    if (me->IsFalling() || JumpingFlyingOrFalling())
+        return false;
+
+    if (!me->IsWithinDist(target, IsMelee() ? 50 : 75) || (me->GetDistance(target) < (IsMelee() ? 5 : 25)))
+    {
+        ResetChaseTimer(target);
+        me->GetMotionMaster()->MovePoint(me->GetMapId(), *target, false);
+        return true;
+    }
+
+    if (_jumpCount >= 3)
+    {
+        me->AttackStop();
+        Evade(true);
+        return true;
+    }
+
+    ResetChaseTimer(target);
+    BotJump(target);
+    return true;
+}
+
+void bot_minion_ai::ResetChaseTimer(Position* /*pos*/)
+{
+    _chaseTimer = 10000;//std::max<uint32>(5000, me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 400);
+    //me->GetDistance2d(pos->m_positionX, pos->m_positionY) * 1000 / me->GetSpeed(MOVE_WALK);
+}
+
+void bot_minion_ai::ResetChase(Position* pos)
+{
+    if (!IAmFree())
+        return;
+
+    ResetChaseTimer(pos);
+    _jumpCount = 0;
+}
+
+void bot_minion_ai::OnStartAttack(Unit* u)
+{
+    if (u->GetGUID() != _lastTargetGuid)
+    {
+        ResetChase(u);
+        _lastTargetGuid = u->GetGUID();
+    }
+}
+
+void bot_minion_ai::EnterCombat(Unit* u)
+{
+    _atHome = false;
+
+    //clear gossip during combat. See CheckAuras() for restore
+    if (me->HasFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP))
+        me->RemoveFlag(UNIT_NPC_FLAGS, UNIT_NPC_FLAG_GOSSIP);
+    //disable evade mode just in case
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (Creature* pet = me->GetBotsPet())
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    if (!IAmFree())
+        return;
+
+    _evadeMode = false;
+    AbortTeleport();
+
+    ResetChase(u);
+}
+
+void bot_minion_ai::JustDied(Unit*)
+{
+    events.KillAllEvents(false);
+    _reviveTimer = IAmFree() ? 180000 : 30000; //3min/30sec
+    _atHome = false;
+    _evadeMode = false;
+    spawned = false;
+
+    if (IsTempBot())
+    {
+        //TC_LOG_ERROR("entities.player", "Unsummoning temp bot %s (guidLow: %u), owner: %s (guidLow: %u)...",
+        //    me->GetName().c_str(), me->GetGUID().GetCounter(), master->GetName().c_str(), master->GetGUID().GetCounter());
+
+        if (!IAmFree())
+            master->GetBotMgr()->RemoveBot(me->GetGUID(), BOT_REMOVE_UNSUMMON);
+
+        me->AddObjectToRemoveList();
+    }
+    else if (!IAmFree())
+    {
+        if (Group* gr = master->GetGroup())
+            if (gr->IsMember(me->GetGUID()))
+                gr->SendUpdate();
+    }
+}
+
+void bot_minion_ai::MoveInLineOfSight(Unit* /*u*/)
+{
+}
+
+void bot_ai::DamageDealt(Unit* victim, uint32& damage, DamageEffectType /*damageType*/)
+{
+    if (victim == me)
+        return;
+
+    if (damage)
+        if (Creature* cre = victim->ToCreature())
+            if (!cre->hasLootRecipient())
+                cre->SetLootRecipient(master);
+
+    if (victim->GetTypeId() == TYPEID_PLAYER)
+        ResetChase(victim);
+}
+//This function is called after Spell::SendSpellCooldown() call for players
+void bot_ai::OnBotSpellGo(Spell const* spell)
+{
+    SpellInfo const* curInfo = spell->GetSpellInfo();
+    uint32 rec = curInfo->GetRecoveryTime();
+    uint32 catrec = curInfo->CategoryRecoveryTime;
+
+    if (rec > 0)
+        ApplyBotSpellCooldownMods(curInfo, rec);
+    if (catrec > 0 && !(curInfo->AttributesEx6 & SPELL_ATTR6_IGNORE_CATEGORY_COOLDOWN_MODS))
+        ApplyBotSpellCategoryCooldownMods(curInfo, catrec);
+
+    //Set cooldown
+    SetSpellCooldown(curInfo->GetFirstRankSpell()->Id, rec);
+    SetSpellCategoryCooldown(curInfo->GetFirstRankSpell(), catrec);
+
+    OnClassSpellGo(curInfo);
+}
+
+void bot_ai::OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs)
+{
+    SpellInfo const* info;
+
+    for (BotSpellMap::iterator itr = spells.begin(); itr != spells.end(); ++itr)
+    {
+        info = sSpellMgr->GetSpellInfo(itr->second.first);
+        if (!info || !(info->GetSchoolMask() & schoolMask)) continue;
+        if (info->IsCooldownStartedOnEvent()) continue;
+        if (info->PreventionType != SPELL_PREVENTION_TYPE_SILENCE) continue;
+
+        itr->second.second += unTimeMs;
+        //TC_LOG_ERROR("entities.player", "OnBotSpellInterrupted(): Adding cooldown (%u, new: %u) to spell %s (id: %u, schoolmask: %u), reqSchoolMask = %u",
+        //    unTimeMs, itr->second.second, info->SpellName[0], info->Id, info->SchoolMask, schoolMask);
+    }
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell/* = NULL*/)
+{
+    if (!target || !target->IsAlive() || target == me)
+        return;
+
+    if (!me->CanUseAttackType(attType))
+        return;
+
+    Item* item;
+    ItemTemplate const* proto;
+    uint8 slot;
+    int8 id = 1;
+    EquipmentInfo const* einfo = sObjectMgr->GetEquipmentInfo(me->GetEntry(), id);
+
+    for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+    {
+        item = _equips[i];
+        if (!item)
+            continue;
+
+        //skip standard items
+        if (i < BOT_SLOT_RANGED && einfo->ItemEntry[i] == item->GetEntry())
+            continue;
+
+        proto = item->GetTemplate();
+        if (!proto)
+            continue;
+
+        // Additional check for weapons
+        if (proto->Class == ITEM_CLASS_WEAPON)
+        {
+            // offhand item cannot proc from main hand hit etc
+            switch (attType)
+            {
+                case BASE_ATTACK:   slot = BOT_SLOT_MAINHAND;   break;
+                case OFF_ATTACK:    slot = BOT_SLOT_OFFHAND;    break;
+                case RANGED_ATTACK: slot = BOT_SLOT_RANGED;     break;
+                default:            slot = BOT_MAX_SLOTS;       break;
+            }
+            if (slot - 1 != i)
+                continue;
+        }
+
+        CastBotItemCombatSpell(target, attType, procVictim, procEx, item, proto, spell);
+    }
+}
+
+void bot_minion_ai::CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto, Spell const* /*spell*//* = NULL*/)
+{
+    //TODO: custom spell triggers maybe?
+
+    // Can do effect if any damage done to target
+    if (procVictim & PROC_FLAG_TAKEN_DAMAGE)
+    {
+        for (uint8 i = 0; i != MAX_ITEM_PROTO_SPELLS; ++i)
+        {
+            _Spell const& spellData = proto->Spells[i];
+
+            // no spell
+            if (!spellData.SpellId)
+                continue;
+
+            // wrong triggering type
+            if (spellData.SpellTrigger != ITEM_SPELLTRIGGER_CHANCE_ON_HIT)
+                continue;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellData.SpellId);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "WORLD: unknown Item spellid %i", spellData.SpellId);
+                continue;
+            }
+
+            // not allow proc extra attack spell at extra attack
+            if (me->m_extraAttacks && spellInfo->HasEffect(SPELL_EFFECT_ADD_EXTRA_ATTACKS))
+                return;
+
+            float chance = float(spellInfo->ProcChance);
+
+            if (spellData.SpellPPMRate)
+            {
+                uint32 WeaponSpeed = me->GetAttackTime(attType);
+                chance = me->GetPPMProcChance(WeaponSpeed, spellData.SpellPPMRate, spellInfo);
+            }
+            else if (chance > 100.0f)
+                chance = me->GetWeaponProcChance();
+
+            if (roll_chance_f(chance))
+                me->CastSpell(target, spellInfo->Id, true, item);
+        }
+    }
+
+    // item combat enchantments
+    for (uint8 e_slot = 0; e_slot != MAX_ENCHANTMENT_SLOT; ++e_slot)
+    {
+        uint32 enchant_id = item->GetEnchantmentId(EnchantmentSlot(e_slot));
+        SpellItemEnchantmentEntry const* pEnchant = sSpellItemEnchantmentStore.LookupEntry(enchant_id);
+        if (!pEnchant)
+            continue;
+
+        for (uint8 s = 0; s != MAX_ITEM_ENCHANTMENT_EFFECTS; ++s)
+        {
+            if (pEnchant->type[s] != ITEM_ENCHANTMENT_TYPE_COMBAT_SPELL)
+                continue;
+
+            SpellEnchantProcEntry const* entry = sSpellMgr->GetSpellEnchantProcEvent(enchant_id);
+
+            if (entry && entry->procEx)
+            {
+                // Check hit/crit/dodge/parry requirement
+                if ((entry->procEx & procEx) == 0)
+                    continue;
+            }
+            else
+            {
+                // Can do effect if any damage done to target
+                if (!(procVictim & PROC_FLAG_TAKEN_DAMAGE))
+                    continue;
+            }
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(pEnchant->spellid[s]);
+            if (!spellInfo)
+            {
+                //TC_LOG_ERROR("entities.player.items", "Player::CastItemCombatSpell(GUID: %u, name: %s, enchant: %i): unknown spell %i is casted, ignoring...",
+                //    GetGUID().GetCounter(), GetName().c_str(), pEnchant->ID, pEnchant->spellid[s]);
+                continue;
+            }
+
+            float chance = pEnchant->amount[s] != 0 ? float(pEnchant->amount[s]) : me->GetWeaponProcChance();
+
+            if (entry)
+            {
+                if (entry->PPMChance)
+                    chance = me->GetPPMProcChance(proto->Delay, entry->PPMChance, spellInfo);
+                else if (entry->customChance)
+                    chance = float(entry->customChance);
+            }
+
+            //// Apply spell mods
+            //ApplySpellMod(pEnchant->spellid[s], SPELLMOD_CHANCE_OF_SUCCESS, chance);
+
+            // Shiv has 100% chance to apply the poison
+            if (me->FindCurrentSpellBySpellId(5938) && e_slot == TEMP_ENCHANTMENT_SLOT)
+                chance = 100.0f;
+
+            if (roll_chance_f(chance))
+            {
+                if (spellInfo->IsPositive())
+                    me->CastSpell(me, spellInfo, true, item);
+                else
+                    me->CastSpell(target, spellInfo, true, item);
+            }
+        }
+    }
+}
+
+bool bot_minion_ai::GlobalUpdate(uint32 diff)
+{
+    lastdiff = diff;
+
+    if (_updateTimerMedium <= diff)
+    {
+        _updateTimerMedium = 500;
+
+        //Medium-timed updates
+
+        //send stats update for group frames
+        if (me->IsInWorld() && !IAmFree())
+        {
+            if (Group* gr = master->GetGroup())
+            {
+                if (gr->IsMember(me->GetGUID()))
+                {
+                    WorldPacket data;
+                    BuildGrouUpdatePacket(&data);
+
+                    Player* member;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        member = itr->GetSource();
+                        if (member/* && !member->IsWithinDist(me, member->GetSightRange(), false)*/)
+                            member->GetSession()->SendPacket(&data);
+                    }
+                }
+            }
+
+            //update pvp state
+            if (me->GetByteValue(UNIT_FIELD_BYTES_2, 1) != master->GetByteValue(UNIT_FIELD_BYTES_2, 1))
+                me->SetByteValue(UNIT_FIELD_BYTES_2, 1, master->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+        }
+    }
+
+    if (!me->IsAlive())
+        return false;
+
+    return true;
+}
+
+void bot_minion_ai::CommonTimers(uint32 diff)
+{
+    events.Update(diff);
+    SpellTimers(diff);
+
+    if (Potion_cd > diff && (Potion_cd < POTION_CD || !me->IsInCombat()))
+        Potion_cd -= diff;
+
+    if (pvpTrinket_cd > diff)       pvpTrinket_cd -= diff;
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (temptimer > diff)           temptimer -= diff;
+    if (checkAurasTimer != 0)       --checkAurasTimer;
+    if (wait != 0)                  --wait;
+
+    if (roleTimer > diff)           roleTimer -= diff;
+    else if (roleTimer > 0)         roleTimer = 0;
+
+    if (_saveTimer > diff)          _saveTimer -= diff;
+    else if (_saveTimer > 0)        _saveTimer = 0;
+
+    if (_powersTimer > diff)        _powersTimer -= diff;
+    else if (_powersTimer > 0)      _powersTimer = 0;
+
+    if (_chaseTimer > diff)         _chaseTimer -= diff;
+    else if (_chaseTimer > 0)       _chaseTimer = 0;
+
+    if (checkMasterTimer > diff)    checkMasterTimer -= diff;
+    else if (checkMasterTimer > 0)  checkMasterTimer = 0;
+
+    if (IAmFree())
+        UpdateReviveTimer(diff);
+
+    if (_bootTimer > int32(diff))   _bootTimer -= diff;
+    else if (_bootTimer > 0)        _bootTimer = 0;
+
+    if (_updateTimerMedium > diff)  _updateTimerMedium -= diff;
+}
+
+void bot_pet_ai::CommonTimers(uint32 diff)
+{
+    events.Update(diff);
+    SpellTimers(diff);
+
+    if (GC_Timer > diff)            GC_Timer -= diff;
+    if (temptimer > diff)           temptimer -= diff;
+    if (roleTimer > diff)           roleTimer -= diff;
+    if (checkAurasTimer != 0)       --checkAurasTimer;
+    if (wait != 0)                  --wait;
+
+    if (regenTimer_mp > diff)       regenTimer_mp -= diff;
+    else if (regenTimer_mp > 0)     regenTimer_mp = 0;
+    if (regenTimer_hp > diff)       regenTimer_hp -= diff;
+    else if (regenTimer_hp > 0)     regenTimer_hp = 0;
+}
+
+void bot_minion_ai::UpdateReviveTimer(uint32 diff)
+{
+    if (me->IsAlive())
+        return;
+
+    if (_reviveTimer > diff)        _reviveTimer -= diff;
+    else
+    {
+        if (IAmFree())
+            BotMgr::ReviveBot(me);
+        else
+            if (_reviveTimer > 0)   _reviveTimer = 0;
+    }
+}
+
+void bot_minion_ai::EnterEvadeMode(bool /*force*/)
+{
+    //if (me->IsInCombat())
+    //    return;
+    if (me->GetVictim())
+        return;
+    if (IsCasting())
+        return;
+    if (CCed(me, true))
+        return;
+
+    if (_atHome && !_evadeMode)
+        return;
+
+    _atHome = true;
+
+    if (!IAmFree())
+    {
+        _evadeMode = false;
+        return;
+    }
+
+    Creature* pet = me->GetBotsPet();
+
+    //me->CombatStop();
+    //if (pet)
+    //    pet->CombatStop();
+
+    //if (!_evadeMode)
+    //{
+    //    ASSERT(!evadeEvent);
+    //    evadeEvent = new EvadeEvent(me->GetGUID(), true);
+    //    events.AddEvent(evadeEvent, events.CalculateTime(0));
+    //    events.Update(0);
+    //}
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    if (mapid != me->GetMapId() || me->GetDistance(pos) > 30.f || _evadeCount >= 3)
+    {
+        //TeleportHome();
+
+        if (!teleHomeEvent || teleHomeEvent->to_Abort)
+        {
+            teleHomeEvent = new TeleportHomeEvent(this);
+            events.AddEvent(teleHomeEvent, events.CalculateTime(1000));
+            me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, true);
+        }
+        _evadeMode = false;
+        return;
+    }
+
+    float dist = me->GetDistance(pos);
+    if (dist > 1.5f)
+    {
+        if (!_evadeMode)
+            ++_evadeCount;
+        else if (me->isMoving() && Rand() > 30)
+            return;
+
+        _evadeMode = true;
+
+        //me->AddUnitState(UNIT_STATE_EVADE);
+        //if (pet)
+        //    pet->AddUnitState(UNIT_STATE_EVADE);
+
+        me->BotStopMovement();
+        if (pet)
+            pet->BotStopMovement();
+
+        bool farpoint = true;
+        if (dist > 50)
+        {
+            float dx = pos.m_positionX - me->m_positionX;
+            float dy = pos.m_positionY - me->m_positionY;
+            float fdx = fabs(dx); float fdy = fabs(dy);
+            float divider =
+                fdx > 1800 || fdy > 1800 ? 120.0f :
+                fdx > 900  || fdy > 900  ?  60.0f :
+                fdx > 600  || fdy > 600  ?  30.0f :
+                fdx > 400  || fdy > 400  ?  20.0f :
+                fdx > 200  || fdy > 200  ?  10.0f :
+                fdx > 100  || fdy > 100  ?   7.0f : 3.0f;
+            dx = dx / divider + me->m_positionX;
+            dy = dy / divider + me->m_positionY;
+            float z = me->GetMap()->GetHeight(dx, dy, me->m_positionZ);
+
+            if (z > INVALID_HEIGHT && fabs(me->m_positionZ - z) > 0.05f)
+            {
+                me->GetMotionMaster()->MovePoint(mapid, dx, dy, z + 0.1f, true);
+                farpoint = false;
+            }
+        }
+
+        if (farpoint)
+        {
+            me->GetMotionMaster()->MovePoint(mapid, pos);
+            if (pet)
+                pet->SetBotCommandState(COMMAND_FOLLOW, true);
+        }
+
+        return;
+    }
+
+    if (me->isMoving())
+        return;
+
+    _evadeMode = false;
+    _evadeCount = 0;
+
+    me->SetFacingTo(pos.GetOrientation());
+    me->SetStandState(UNIT_STAND_STATE_SIT);
+
+    //if (evadeEvent)
+    //{
+    //    evadeEvent->to_Abort = true;
+    //    evadeEvent->Execute(evadeEvent->m_addTime, evadeEvent->m_execTime);
+    //}
+
+    //me->ClearUnitState(UNIT_STATE_EVADE);
+    //if (pet)
+    //    pet->ClearUnitState(UNIT_STATE_EVADE);
+
+    me->setFaction(me->GetCreatureTemplate()->faction);
+    if (pet)
+        pet->setFaction(pet->GetCreatureTemplate()->faction);
+
+    //RestorePositionMods();
+}
+//TeleportHome() ONLY CALLED THROUGH EVENTPROCESSOR
+void bot_minion_ai::TeleportHome()
+{
+    ASSERT(teleHomeEvent);
+    //ASSERT(IAmFree());
+
+    AbortTeleport();
+
+    uint16 mapid;
+    Position pos;
+    GetHomePosition(mapid, &pos);
+
+    Map* map = sMapMgr->CreateBaseMap(mapid);
+    ASSERT(map && !map->Instanceable());
+    BotMgr::TeleportBot(me, map, &pos);
+
+    spawned = false;
+    _evadeCount = 0;
+
+    //Reset();
+}
+//FinishTeleport(uint32, float, float, float, float) ONLY CALLED THROUGH EVENTPROCESSOR
+bool bot_minion_ai::FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/)
+{
+    ASSERT(teleFinishEvent);
+    //ASSERT(!IAmFree());
+    ASSERT(!me->IsInWorld());
+
+    AbortTeleport();
+
+    //1) Cannot teleport: master disappeared - return home
+    if (IAmFree()/* || master->GetSession()->isLogingOut()*/)
+    {
+        uint16 mapid;
+        Position pos;
+        GetHomePosition(mapid, &pos);
+
+        teleHomeEvent = new TeleportHomeEvent(this);
+        events.AddEvent(teleHomeEvent, events.CalculateTime(0)); //make sure event will be deleted
+        teleHomeEvent->to_Abort = true; //make sure event will not be executed twice
+        teleHomeEvent->Execute(0,0);
+        _evadeMode = false;
+
+        return false;
+    }
+
+    Map* map = master->FindMap();
+    //2) Cannot teleport: map not found or forbidden - delay teleport
+    if (!map || master->GetBotMgr()->RestrictBots(me, true))
+    {
+        //ChatHandler ch(master->GetSession());
+        //ch.PSendSysMessage("Your bot %s cannot teleport to you. Restricted bot access on this map...", me->GetName().c_str());
+        teleFinishEvent = new TeleportFinishEvent(this/*, master->GetMapId(), x, y, z, o*/);
+        events.AddEvent(teleFinishEvent, events.CalculateTime(5000));
+        return false;
+    }
+
+    me->SetMap(map);
+    me->Relocate(master);
+    map->AddToMap(me);
+    me->BotStopMovement();
+    //bot->SetAI(oldAI);
+    me->IsAIEnabled = true;
+
+    master->m_Controlled.insert(me);
+    me->CastSpell(me, COSMETIC_TELEPORT_EFFECT, true);
+
+    //update group member online state
+    if (Group* gr = master->GetGroup())
+        if (gr->IsMember(me->GetGUID()))
+            gr->SendUpdate();
+
+    return true;
+}
+
+void bot_minion_ai::AbortTeleport()
+{
+    if (teleHomeEvent)
+    {
+        teleHomeEvent->to_Abort = true;
+        teleHomeEvent = NULL;
+    }
+
+    if (teleFinishEvent)
+    {
+        teleFinishEvent->to_Abort = true;
+        teleFinishEvent = NULL;
+    }
+
+    CancelBoot();
+}
+
+void bot_ai::GetHomePosition(uint16& mapid, Position* pos)
+{
+    CreatureData const* data = me->GetCreatureData();
+    mapid = data->mapid;
+    pos->Relocate(data->posX, data->posY, data->posZ, data->orientation);
+}
+
+void bot_ai::KillEvents(bool force)
+{
+    events.KillAllEvents(force);
+}
+
+bool bot_ai::IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    if (spellInfo->_IsPositiveSpell())
+        return false;
+
+    if (_botclass >= BOT_CLASS_EX_START)
+    {
+        //bots of W3 classes will not be easily CCed
+        if (spellInfo->GetDuration() > 0 && spellInfo->GetDuration() <= 3000 &&
+            (spellInfo->HasAura(SPELL_AURA_MOD_STUN) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CONFUSE) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_CHARM) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_FEAR) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_PACIFY) ||
+            spellInfo->HasAura(SPELL_AURA_MOD_ROOT) ||
+            spellInfo->HasAura(SPELL_AURA_AOE_CHARM)))
+            return true;
+    }
+    return false;
+}
+
+MeleeHitOutcome bot_ai::BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    if (GetNextAttackMeleeOutCome() != MELEE_HIT_CRUSHING)
+        return GetNextAttackMeleeOutCome();
+    return me->RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void bot_ai::BotJumpInPlaceInFrontOf(Position* pos, float speedXY, float maxHeight)
+{
+    float sign = (me->GetPositionX() < pos->GetPositionX()) ? 1.f : -1.f;
+    float x = me->GetPositionX() + 0.14f * sign;
+    sign = (me->GetPositionY() < pos->GetPositionY()) ? 1.f : -1.f;
+    float y = me->GetPositionY() + 0.14f * sign;
+    float z = me->GetPositionZ() - 0.01f;
+    //float floorz = Map::GetHeight(x, y, z, true, 5.f);
+
+    //me->AttackStop();
+    me->BotStopMovement();
+    me->GetMotionMaster()->MoveJump(x, y, z, speedXY, maxHeight);
+}
+
+void bot_ai::BuildGrouUpdatePacket(WorldPacket* data)
+{
+    uint32 mask = GROUP_UPDATE_FULL;
+
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)                // if update power type, update current/max power also
+        mask |= (GROUP_UPDATE_FLAG_CUR_POWER | GROUP_UPDATE_FLAG_MAX_POWER);
+
+    if (mask & GROUP_UPDATE_FLAG_PET_POWER_TYPE)            // same for pets
+        mask |= (GROUP_UPDATE_FLAG_PET_CUR_POWER | GROUP_UPDATE_FLAG_PET_MAX_POWER);
+
+    uint32 byteCount = 0;
+    for (uint8 i = 1; i < GROUP_UPDATE_FLAGS_COUNT; ++i)
+        if (mask & (1 << i))
+            byteCount += GroupUpdateLength[i];
+
+    data->Initialize(SMSG_PARTY_MEMBER_STATS, 8 + 4 + byteCount);
+    *data << me->GetPackGUID();
+    *data << uint32(mask);
+
+    if (mask & GROUP_UPDATE_FLAG_STATUS)
+    {
+        uint16 playerStatus = MEMBER_STATUS_ONLINE;
+        if (me->IsPvP())
+            playerStatus |= MEMBER_STATUS_PVP;
+
+        if (!me->IsAlive())
+            playerStatus |= MEMBER_STATUS_DEAD;
+
+        if (me->HasByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP))
+            playerStatus |= MEMBER_STATUS_PVP_FFA;
+
+        *data << uint16(playerStatus);
+    }
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_HP)
+        *data << uint32(me->GetHealth());
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_HP)
+        *data << uint32(me->GetMaxHealth());
+
+    Powers powerType = me->getPowerType();
+    if (mask & GROUP_UPDATE_FLAG_POWER_TYPE)
+        *data << uint8(powerType);
+
+    if (mask & GROUP_UPDATE_FLAG_CUR_POWER)
+        *data << uint16(me->GetPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_MAX_POWER)
+        *data << uint16(me->GetMaxPower(powerType));
+
+    if (mask & GROUP_UPDATE_FLAG_LEVEL)
+        *data << uint16(me->getLevel());
+
+    if (mask & GROUP_UPDATE_FLAG_ZONE)
+        *data << uint16(me->GetZoneId());
+
+    if (mask & GROUP_UPDATE_FLAG_POSITION)
+    {
+        *data << uint16(me->GetPositionX());
+        *data << uint16(me->GetPositionY());
+    }
+
+    //TODO: ...?
+    //if (mask & GROUP_UPDATE_FLAG_AURAS)
+    //{
+    //    uint64 auramask = player->GetAuraUpdateMaskForRaid();
+    //    *data << uint64(auramask);
+    //    for (uint32 i = 0; i < MAX_AURAS; ++i)
+    //    {
+    //        if (auramask & (uint64(1) << i))
+    //        {
+    //            AuraApplication const* aurApp = player->GetVisibleAura(i);
+    //            *data << uint32(aurApp ? aurApp->GetBase()->GetId() : 0);
+    //            *data << uint8(1);
+    //        }
+    //    }
+    //}
+
+    //if (mask & GROUP_UPDATE_FLAG_VEHICLE_SEAT)
+    //{
+    //    if (Vehicle* veh = me->GetVehicle())
+    //        *data << uint32(veh->GetVehicleInfo()->m_seatID[me->m_movementInfo.transport.seat]);
+    //    else
+    //        *data << uint32(0);
+    //}
+}
+
+bool bot_ai::IsBotCustomSpell(uint32 spellId)
+{
+    return BotCustomSpells.find(spellId) != BotCustomSpells.end();
+}
+
+void bot_ai::InitBotCustomSpells()
+{
+    if (SPELLS_DEFINED)
+    {
+        //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... fail...");
+        return;
+    }
+    //TC_LOG_ERROR("entities.player", "Bot custom spells initialization... success...");
+    SPELLS_DEFINED = true;
+
+    //see bot_ai.h::CommonValues::CUSTOM_SPELLS
+    //all ids must be here
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PERSISTENT_AURA);
+    //BotCustomSpells.insert(BLIZZARD_VISUAL_PROC);
+
+    //BotCustomSpells.insert(SPELL_COMBAT_SPECIAL_2H_ATTACK); //exclusive
+    BotCustomSpells.insert(SPELL_TRANSPARENCY_50);//3.1
+    BotCustomSpells.insert(SPELL_NETHERWALK);//3
+    BotCustomSpells.insert(SPELL_MIRROR_IMAGE_BM);//4
+
+    uint32 trig;
+    SpellInfo* trigInfo;
+    uint32 spellId;
+    SpellInfo* sinfo;
+
+    //1) BLIZZARD
+    //1.1) BLIZZARD PROC
+    //trig = BLIZZARD_VISUAL_PROC; //rain
+    //trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+    //trigInfo->Dispel = DISPEL_NONE;
+    //trigInfo->Mechanic = MECHANIC_NONE;
+    //trigInfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //trigInfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+    //trigInfo->ManaCost = 0;
+    //trigInfo->ManaCostPercentage = 0;
+    //trigInfo->ManaCostPerlevel = 0;
+
+    //trigInfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    //trigInfo->Effects[0].BasePoints = 1;
+    //trigInfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_CHANNEL_TARGET);
+    //trigInfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+    //trigInfo->Effects[0].ApplyAuraName = SPELL_AURA_NONE;
+    //trigInfo->Effects[0].Amplitude = 0;
+    //trigInfo->Effects[0].TriggerSpell = 0;
+    //trigInfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    ////1.1) END BLIZZARD PROC
+
+    //spellId = BLIZZARD_VISUAL_PERSISTENT_AURA; //34167, 34183
+    //sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    //sinfo->Dispel = DISPEL_NONE;
+    //sinfo->Mechanic = MECHANIC_NONE;
+    //sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+    //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(3); //3 - 0.5 sec
+    //sinfo->DurationEntry = sSpellDurationStore.LookupEntry(1); //1 - 10 sec //32 - 6 seconds
+    //sinfo->ManaCost = 0;
+    //sinfo->ManaCostPercentage = 74;
+    //sinfo->ManaCostPerlevel = 0;
+    //sinfo->AttributesEx2 |= SPELL_ATTR2_UNK22;
+    //sinfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+    //sinfo->ExplicitTargetMask = TARGET_FLAG_DEST_LOCATION;
+    //sinfo->InterruptFlags = 0x0000000F; //15
+    //sinfo->ChannelInterruptFlags = 0x00007C3C; //31788
+
+    //sinfo->Effects[0].Effect = SPELL_EFFECT_PERSISTENT_AREA_AURA;
+    //sinfo->Effects[0].BasePoints = 1;
+    //sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_DYNOBJ_ENEMY);
+    //sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_DUMMY;
+    //sinfo->Effects[0].Amplitude = 0;
+    //sinfo->Effects[0].TriggerSpell = 0;
+    //sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+
+    //sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    //sinfo->Effects[1].BasePoints = 1;
+    //sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    //sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    //sinfo->Effects[1].ApplyAuraName = SPELL_AURA_PERIODIC_TRIGGER_SPELL;
+    //sinfo->Effects[1].Amplitude = 2000;
+    //sinfo->Effects[1].TriggerSpell = trig;
+    //sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+    //1) END BLIZZARD
+    {}
+    //2) SPELL_COMBAT_SPECIAL_2H_ATTACK
+    spellId = SPELL_COMBAT_SPECIAL_2H_ATTACK; //1132
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+    sinfo->Attributes &= ~(SPELL_ATTR0_CANT_USED_IN_COMBAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_CAN_TARGET_DEAD;
+    //2) END SPELL_COMBAT_SPECIAL_2H_ATTACK
+
+    //3) WINDWALK
+    //3.1) TRANSPARENCY
+    trig = SPELL_TRANSPARENCY_50; //44816
+    trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+    trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+    trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+    trigInfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    trigInfo->CasterAuraStateNot = 0;
+    //3.1) END TRANSPARENCY
+
+
+    spellId = SPELL_NETHERWALK; //31599
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->SpellLevel = 0;
+    sinfo->MaxLevel = 80;
+    sinfo->RecoveryTime = 5000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 75;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY);
+    sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+    sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+    sinfo->AttributesEx2 |= SPELL_ATTR2_UNK1;
+    sinfo->AuraInterruptFlags =
+        AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+    sinfo->CasterAuraStateNot = 0;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[0].BasePoints = 100;
+    sinfo->Effects[0].RealPointsPerLevel = 2.5f;
+    sinfo->Effects[0].ValueMultiplier = 1.0f;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+    sinfo->Effects[0].Amplitude = 0;
+    sinfo->Effects[0].TriggerSpell = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+    sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+    sinfo->Effects[1].BasePoints = 10;
+    sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+    sinfo->Effects[1].ValueMultiplier = 1.0f;
+    sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+    sinfo->Effects[1].Amplitude = 0;
+    sinfo->Effects[1].TriggerSpell = 0;
+    sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+    sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+    sinfo->Effects[2].BasePoints = 0;
+    sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+    sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+    sinfo->Effects[2].Amplitude = 0;
+    sinfo->Effects[2].TriggerSpell = trig;
+    sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+    //3) END WINDWALK
+
+    //4) MIRROR IMAGE (BLADEMASTER)
+    spellId = SPELL_MIRROR_IMAGE_BM; //69936
+    sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+    sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+    sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+    sinfo->RecoveryTime = 8000;
+    sinfo->PowerType = POWER_MANA;
+    sinfo->ManaCost = 125;
+    sinfo->ManaCostPercentage = 0;
+    sinfo->ManaCostPerlevel = 0;
+    sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+    sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+    sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+
+    sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+    sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+    sinfo->Effects[0].MiscValue = 0;
+    sinfo->Effects[0].MiscValueB = 0;
+    sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+    //4) END MIRROR IMAGE (BLADEMASTER)
+}
diff --git a/src/server/game/AI/NpcBots/bot_ai.h b/src/server/game/AI/NpcBots/bot_ai.h
new file mode 100644
index 0000000..d594cdf
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_ai.h
@@ -0,0 +1,908 @@
+#ifndef _BOT_AI_H
+#define _BOT_AI_H
+
+#include "ScriptedCreature.h"
+/*
+NpcBot System by Graff (onlysuffering@gmail.com)
+Original patch from: LordPsyan https://bitbucket.org/lordpsyan/trinitycore-patches/src/3b8b9072280e/Individual/11185-BOTS-NPCBots.patch
+*/
+
+struct PlayerClassLevelInfo;
+
+//class VisibilityUpdateEvent;
+class TeleportHomeEvent;
+//class EvadeEvent;
+class TeleportFinishEvent;
+
+enum CommonValues
+{
+//MISC
+    BOT_ENTRY_BEGIN                     = 70001,
+    BOT_ENTRY_END                       = 71000,
+    BOT_ICON_ON                         = 9,    //GOSSIP_ICON_BATTLE,
+    BOT_ICON_OFF                        = 7,    //GOSSIP_ICON_TALK,
+    BOT_MAX_CHASE_RANGE                 = 120,  //yds
+    BOT_EVADE_TIME                      = 3000, //ms
+//COMMON SPELLS
+    MANAPOTION                          = 32453,//"Uses a Holy elixir to heal the caster for 32000"
+    HEALINGPOTION                       = 15504,//"Drinks Holy Elixir to heal the caster"
+    DRINK                               = 66041,//"Restores 4% mana per sec for 30 sec"
+    EAT                                 = 66478,//"Restores Health"
+    PVPTRINKET                          = 42292,//PvP Trinket no CD
+    BERSERK                             = 46587,//68378,//900%/150%
+//COMMON CDs
+    POTION_CD                           = 60000,//default 60sec potion cd
+    RATIONS_CD                          = 1000, //update rations every X milliseconds
+//COMMON PASSIVES
+  //1) DEPRECATED"Increase(d) @whatever"
+    //SPELL_BONUS_10                      = 33021,//10spp
+    //SPELL_BONUS_50                      = 45011,//50spp
+    //SPELL_BONUS_150                     = 28141,//150spp
+    //SPELL_BONUS_250                     = 69709,//250spp
+    //FIREDAM_86                          = 33816,//86 fire spp
+    //MANAREGEN45                         = 35867,//45 mp5
+    //MANAREGEN100                        = 45216,//100 mp5
+    //SPELL_PEN_5                         = 31921,//5 sppen
+    //SPELL_PEN_20                        = 26283,//20 sppen
+  //2) DEPRECATEDTalents
+    //HASTE    /*Gift of the EarthMother*/= 51183,//rank 5 10% spell haste
+    //HASTE2   /*Blood Frenzy - warrior*/ = 29859,//rank 2 10% melee haste, bonus for rend (warriors only)
+    //HASTE3   /*       "Haste"       */  = 29418,//rank 0 10% increased ranged attack speed
+    //CRITS    /*Thundering Strikes-sham*/= 16305,//rank 5 5% crit melee/spell
+    //HOLYCRIT /*Holy Spec - priest*/     = 15011,//rank 5 5% holy crit
+    //DODGE    /*Anticipation - paladin*/ = 20100,//rank 5 5% dodge
+    //PARRY    /*Deflection - warrior*/   = 16466,//rank 5 5% parry
+    //BLOCK/*zzOLD Shield Specialization*/= 16253,//rank 1 5% block 10% amount, 3.3.5 & 4.3.4 deprecated
+    //PRECISION /*Precision - rogue*/     = 13843,//rank 3 3% melee/spell hit
+    //PRECISION /*Precision - warrior*/   = 29592,//rank 3 3% melee hit
+    //PRECISION2/*Precision - mage*/      = 29440,//rank 3 3% spell hit, -3% mana cost
+    //DMG_TAKEN/*Deadened Nerves - rogue*/= 31383,//rank 3 6% reduced damage taken all
+    //EXPERTISE /*Weapon Expertise-rogue*/= 30919,//rank 1 5 expertise
+    //EXPERTISE2/*Weapon Expertise-rogue*/= 30920,//rank 2 10 expertise
+  //3) Pet/Special
+    THREAT   /****  (unused)  ****/     = 57339,//+43% threat generated
+    //BOR      /*Blood of Rhino - pet*/   = 53482,//rank 2 +40% healing taken
+    //BOAR     /*Boar's Speed - pet*/     = 19596,//rank 1 +30% movement speed
+    RCP      /*Rogue Class Passive*/    = 21184,//-27% threat caused
+    DEFENSIVE_STANCE_PASSIVE /*Warrior*/= 7376, //+45% threat -10% damage taken -5% damage done
+//COMMON GOSSIPS
+    GOSSIP_SERVE_MASTER                 = 70001, //"I live only to serve the master."
+    GOSSIP_NEED_SMTH                    = 70002, //"You need something?"
+    GOSSIP_MURDER                       = 70003,//"Mortals... usually I kill wretches like you at sight"
+    GOSSIP_CLASS_BM                     = 70004,
+    GOSSIP_SENDER_BEGIN                 = 6000,
+    GOSSIP_SENDER_CLASS,
+    GOSSIP_SENDER_EQUIPMENT,
+    GOSSIP_SENDER_EQUIPMENT_LIST,
+    GOSSIP_SENDER_EQUIPMENT_SHOW,
+    GOSSIP_SENDER_EQUIPMENT_INFO,
+    GOSSIP_SENDER_UNEQUIP,
+    GOSSIP_SENDER_UNEQUIP_ALL,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_EQUIP,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_MHAND           = GOSSIP_SENDER_EQUIP_AUTOEQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_AUTOEQUIP_NECK,
+    GOSSIP_SENDER_EQUIP_RESET,
+    GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_BEGIN           = GOSSIP_SENDER_EQUIP,
+    GOSSIP_SENDER_EQUIP_MHAND           = GOSSIP_SENDER_EQUIP_BEGIN,
+    GOSSIP_SENDER_EQUIP_OHAND,
+    GOSSIP_SENDER_EQUIP_RANGED,
+    GOSSIP_SENDER_EQUIP_HEAD,
+    GOSSIP_SENDER_EQUIP_SHOULDERS,
+    GOSSIP_SENDER_EQUIP_CHEST,
+    GOSSIP_SENDER_EQUIP_WAIST,
+    GOSSIP_SENDER_EQUIP_LEGS,
+    GOSSIP_SENDER_EQUIP_FEET,
+    GOSSIP_SENDER_EQUIP_WRIST,
+    GOSSIP_SENDER_EQUIP_HANDS,
+    GOSSIP_SENDER_EQUIP_BACK,
+    GOSSIP_SENDER_EQUIP_BODY,
+    GOSSIP_SENDER_EQUIP_FINGER1,
+    GOSSIP_SENDER_EQUIP_FINGER2,
+    GOSSIP_SENDER_EQUIP_TRINKET1,
+    GOSSIP_SENDER_EQUIP_TRINKET2,
+    GOSSIP_SENDER_EQUIP_NECK,
+    GOSSIP_SENDER_ROLES,
+    GOSSIP_SENDER_ROLES_TOGGLE,
+    GOSSIP_SENDER_ABILITIES,
+    GOSSIP_SENDER_ABILITIES_USE,
+    GOSSIP_SENDER_HIRE,
+    GOSSIP_SENDER_DISMISS,
+    GOSSIP_SENDER_JOIN_GROUP,
+    GOSSIP_SENDER_LEAVE_GROUP,
+    GOSSIP_SENDER_FORMATION,
+    GOSSIP_SENDER_FORMATION_DISTANCE,
+    GOSSIP_SENDER_SCAN,
+    GOSSIP_SENDER_SCAN_OWNER,
+    GOSSIP_SENDER_SCAN_OWNER_ABILITY,
+    GOSSIP_SENDER_DEBUG,
+    GOSSIP_SENDER_DEBUG_ACTION,
+//COMMON NPCS
+    NPC_WORLD_TRIGGER                   = 22515,
+//COMMON GAMEEVENTS
+    GAME_EVENT_WINTER_VEIL              = 2,
+//COMMON MOUNTS SPELLS
+    REINDEER                            = 25859,
+    REINDEER_FLY                        = 44827,
+//ADVANCED
+    COSMETIC_TELEPORT_EFFECT            = 52096,//visual instant cast omni
+    //COSMETIC_SMOKING_CORPSE_AURA        = 51201,//black model + fire step (permanent)
+
+
+////CUSTOM SPELLS
+//ARCHMAGE
+  //modify
+/**/BLIZZARD_VISUAL_PERSISTENT_AURA     = 34167,
+    BLIZZARD_VISUAL_PROC                = 29969,
+
+//BLADEMASTER
+/**/ //- used explicitly within the script
+  //SPELLS
+  //unmodify
+    SPELL_DEATH_GRIP_JUMP               = 49575,
+/**/SPELL_CRITICAL_STRIKE               = 1132,
+    SPELL_BURNING_BLADE_BLADEMASTER     = 32281,//horde flag visual
+    SPELL_POSESS                        = 17250,//immunity,invis,stun
+    //SPELL_SELFSTUN                      = 24883,//green smoke, transparency, stun
+    SPELL_STUN_FREEZE_ANIM              = 59123,//stun forever, full stop
+  //modify
+    SPELL_TRANSPARENCY_50               = 44816,
+/**/SPELL_NETHERWALK                    = 31599,
+/**/SPELL_MIRROR_IMAGE_BM               = 69936,//blank spell
+  //SOUNDS
+    SOUND_FREEZE_IMPACT_WINDWALK        = 29,
+    SOUND_AXE_2H_IMPACT_FLESH_CRIT      = 158,
+    SOUND_ABSORB_GET_HIT                = 3334,
+    SOUND_MISS_WHOOSH_2H                = 7081,
+
+//OTHER
+  //unmodify
+    SPELL_VERTEX_COLOR_BLACK            = 39662,//black color model full
+    //SPELL_NIGHTMARE_VULNERABILITY       = 54199,//100% dmg taken, 100% crit chance taken (x4 dmg taken)
+  //modify
+    SPELL_COMBAT_SPECIAL_2H_ATTACK      = 44079
+};
+
+enum BotClasses
+{
+    BOT_CLASS_NONE                      = CLASS_NONE,
+    BOT_CLASS_WARRIOR                   = CLASS_WARRIOR,
+    BOT_CLASS_PALADIN                   = CLASS_PALADIN,
+    BOT_CLASS_HUNTER                    = CLASS_HUNTER,
+    BOT_CLASS_ROGUE                     = CLASS_ROGUE,
+    BOT_CLASS_PRIEST                    = CLASS_PRIEST,
+    BOT_CLASS_DEATH_KNIGHT              = CLASS_DEATH_KNIGHT,
+    BOT_CLASS_SHAMAN                    = CLASS_SHAMAN,
+    BOT_CLASS_MAGE                      = CLASS_MAGE,
+    BOT_CLASS_WARLOCK                   = CLASS_WARLOCK,
+    BOT_CLASS_DRUID                     = CLASS_DRUID,
+
+    BOT_CLASS_BM,
+
+    BOT_CLASS_END,
+
+    BOT_CLASS_NORMAL_START              = BOT_CLASS_WARRIOR,
+    BOT_CLASS_NORMAL_END                = BOT_CLASS_BM,
+    BOT_CLASS_EX_START                  = BOT_CLASS_BM,
+    BOT_CLASS_EX_END
+};
+
+enum BotStances
+{
+    BOT_STANCE_NONE                     = 0,
+    WARRIOR_BATTLE_STANCE               = BOT_CLASS_EX_END,
+    WARRIOR_DEFENSIVE_STANCE,
+    WARRIOR_BERSERKER_STANCE,
+    DEATH_KNIGHT_BLOOD_PRESENCE,
+    DEATH_KNIGHT_FROST_PRESENCE,
+    DEATH_KNIGHT_UNHOLY_PRESENCE,
+    DRUID_BEAR_FORM,
+    DRUID_CAT_FORM,
+    //DRUID_TRAVEL_FORM,                //NYI
+    //DRUID_FLY_FORM,                   //NYI
+    DRUID_MOONKIN_FORM                  //NYI
+};
+
+enum BotRoles
+{
+    BOT_ROLE_NONE                       = 0x00,
+    BOT_ROLE_TANK                       = 0x01,
+    BOT_ROLE_DPS                        = 0x02,
+    BOT_ROLE_HEAL                       = 0x04,
+    BOT_ROLE_RANGED                     = 0x08,
+
+    BOT_ROLE_PARTY                      = 0x10, //hidden
+
+    //BOT_ROLE_TANK_MELEE                 = (BOT_ROLE_TANK | BOT_ROLE_DPS),
+    //BOT_ROLE_TANK_RANGED                = (BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_RANGED),
+
+    BOT_MAX_ROLE                        = 0x20
+};
+
+enum BotPetTypes
+{
+    PET_TYPE_NONE,
+//Warlock
+    PET_TYPE_IMP,
+    PET_TYPE_VOIDWALKER,
+    PET_TYPE_SUCCUBUS,
+    PET_TYPE_FELHUNTER,
+    PET_TYPE_FELGUARD,
+//Mage
+    PET_TYPE_WATER_ELEMENTAL,
+//Shaman
+    //PET_TYPE_GHOSTLY_WOLF,
+    PET_TYPE_FIRE_ELEMENTAL,
+    PET_TYPE_EARTH_ELEMENTAL,
+//Hunter
+    PET_TYPE_VULTURE,
+
+    MAX_PET_TYPES
+};
+
+enum WarlockBotPets
+{
+    //PET_IMP                     = ,
+    PET_VOIDWALKER              = 70247
+    //PET_SUCCUBUS                =
+};
+
+enum HunterBotPets
+{
+    PET_VULTURE                 = 70248
+};
+
+enum BotPetsOriginalEntries
+{
+    ORIGINAL_ENTRY_VOIDWALKER   = 1860
+};
+
+enum BotEquipSlot
+{
+    BOT_SLOT_NONE               = 0,
+    BOT_SLOT_MAINHAND           = 1,
+    BOT_SLOT_OFFHAND            = 2,
+    BOT_SLOT_RANGED             = 3,
+    BOT_SLOT_HEAD               = 4,
+    BOT_SLOT_SHOULDERS          = 5,
+    BOT_SLOT_CHEST              = 6,
+    BOT_SLOT_WAIST              = 7,
+    BOT_SLOT_LEGS               = 8,
+    BOT_SLOT_FEET               = 9,
+    BOT_SLOT_WRIST              = 10,
+    BOT_SLOT_HANDS              = 11,
+    BOT_SLOT_BACK               = 12,
+    BOT_SLOT_BODY               = 13,
+    BOT_SLOT_FINGER1            = 14,
+    BOT_SLOT_FINGER2            = 15,
+    BOT_SLOT_TRINKET1           = 16,
+    BOT_SLOT_TRINKET2           = 17,
+    BOT_SLOT_NECK               = 18,
+    BOT_MAX_SLOTS,
+    BOT_INVENTORY_SIZE = BOT_MAX_SLOTS - 1
+};
+
+enum BotItemStat
+{
+    //ItemProtoType.h
+    BOT_ITEM_MOD_MANA                       = 0,
+    BOT_ITEM_MOD_HEALTH                     = 1,
+    BOT_ITEM_MOD_AGILITY                    = 3,
+    BOT_ITEM_MOD_STRENGTH                   = 4,
+    BOT_ITEM_MOD_INTELLECT                  = 5,
+    BOT_ITEM_MOD_SPIRIT                     = 6,
+    BOT_ITEM_MOD_STAMINA                    = 7,
+    BOT_ITEM_MOD_DEFENSE_SKILL_RATING       = 12,
+    BOT_ITEM_MOD_DODGE_RATING               = 13,
+    BOT_ITEM_MOD_PARRY_RATING               = 14,
+    BOT_ITEM_MOD_BLOCK_RATING               = 15,
+    BOT_ITEM_MOD_HIT_MELEE_RATING           = 16,
+    BOT_ITEM_MOD_HIT_RANGED_RATING          = 17,
+    BOT_ITEM_MOD_HIT_SPELL_RATING           = 18,
+    BOT_ITEM_MOD_CRIT_MELEE_RATING          = 19,
+    BOT_ITEM_MOD_CRIT_RANGED_RATING         = 20,
+    BOT_ITEM_MOD_CRIT_SPELL_RATING          = 21,
+    BOT_ITEM_MOD_HIT_TAKEN_MELEE_RATING     = 22,
+    BOT_ITEM_MOD_HIT_TAKEN_RANGED_RATING    = 23,
+    BOT_ITEM_MOD_HIT_TAKEN_SPELL_RATING     = 24,
+    BOT_ITEM_MOD_CRIT_TAKEN_MELEE_RATING    = 25,
+    BOT_ITEM_MOD_CRIT_TAKEN_RANGED_RATING   = 26,
+    BOT_ITEM_MOD_CRIT_TAKEN_SPELL_RATING    = 27,
+    BOT_ITEM_MOD_HASTE_MELEE_RATING         = 28,
+    BOT_ITEM_MOD_HASTE_RANGED_RATING        = 29,
+    BOT_ITEM_MOD_HASTE_SPELL_RATING         = 30,
+    BOT_ITEM_MOD_HIT_RATING                 = 31,
+    BOT_ITEM_MOD_CRIT_RATING                = 32,
+    BOT_ITEM_MOD_HIT_TAKEN_RATING           = 33,
+    BOT_ITEM_MOD_CRIT_TAKEN_RATING          = 34,
+    BOT_ITEM_MOD_RESILIENCE_RATING          = 35,
+    BOT_ITEM_MOD_HASTE_RATING               = 36,
+    BOT_ITEM_MOD_EXPERTISE_RATING           = 37,
+    BOT_ITEM_MOD_ATTACK_POWER               = 38,
+    BOT_ITEM_MOD_RANGED_ATTACK_POWER        = 39,
+    BOT_ITEM_MOD_FERAL_ATTACK_POWER         = 40,
+    BOT_ITEM_MOD_SPELL_HEALING_DONE         = 41,                 // deprecated
+    BOT_ITEM_MOD_SPELL_DAMAGE_DONE          = 42,                 // deprecated
+    BOT_ITEM_MOD_MANA_REGENERATION          = 43,
+    BOT_ITEM_MOD_ARMOR_PENETRATION_RATING   = 44,
+    BOT_ITEM_MOD_SPELL_POWER                = 45,
+    BOT_ITEM_MOD_HEALTH_REGEN               = 46,
+    BOT_ITEM_MOD_SPELL_PENETRATION          = 47,
+    BOT_ITEM_MOD_BLOCK_VALUE                = 48,
+    //END ItemProtoType.h
+
+    BOT_ITEM_MOD_DAMAGE                     = MAX_ITEM_MOD,
+    BOT_ITEM_MOD_ARMOR,
+    BOT_ITEM_MOD_RESIST_HOLY,
+    BOT_ITEM_MOD_RESIST_FIRE,
+    BOT_ITEM_MOD_RESIST_NATURE,
+    BOT_ITEM_MOD_RESIST_FROST,
+    BOT_ITEM_MOD_RESIST_SHADOW,
+    BOT_ITEM_MOD_RESIST_ARCANE,
+    BOT_ITEM_MOD_EX,
+    MAX_BOT_ITEM_MOD,
+
+    BOT_ITEM_MOD_RESISTANCE_START = BOT_ITEM_MOD_ARMOR
+};
+
+enum BotAIResetType
+{
+    BOTAI_RESET_INIT                    = 0x01,
+    BOTAI_RESET_DISMISS                 = 0x02,
+    BOTAI_RESET_LOST                    = 0x04,
+    BOTAI_RESET_LOGOUT                  = 0x08, //NYI
+
+    BOTAI_RESET_ABANDON_MASTER          = (BOTAI_RESET_INIT | BOTAI_RESET_DISMISS)
+};
+
+class bot_ai : public ScriptedAI
+{
+    friend class BotMgr;
+    friend class script_bot_commands;
+    private:
+        void SetBotOwnerGUID(uint32 guidlow) { _ownerGuid = guidlow; }
+    public:
+        virtual ~bot_ai();
+        bot_ai(Creature* creature);
+        //void OnCharmed(bool /*apply*/) { }
+        EventProcessor* GetEvents() { return &events; }
+        uint32 GetBotOwnerGuid() const { return _ownerGuid; }
+        Player* GetBotOwner() const { return master; }
+        bool SetBotOwner(Player* newowner);
+        uint8 GetBotClass() const { return _botclass; }
+        uint32 GetLastDiff() const { return lastdiff; }
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() {}
+        virtual void JustDied(Unit*) {}
+        virtual void EnterCombat(Unit*) {}
+        virtual void MoveInLineOfSight(Unit*) {}
+        virtual void ReturnHome() {}
+        virtual void CommonTimers(uint32 /*diff*/) = 0;
+        void ResetBotAI(uint8 resetType = BOTAI_RESET_INIT);
+        void KillEvents(bool force);
+        void FindMaster(bool force = false);
+        virtual bool IsMinionAI() const = 0;
+        virtual bool IsPetAI() const = 0;
+        virtual bool CanRespawn() = 0;
+        virtual void SetBotCommandState(CommandStates /*st*/, bool /*force*/ = false, Position* /*newpos*/ = NULL) = 0;
+        virtual const bot_minion_ai* GetMinionAI() const { return NULL; }
+        virtual const bot_pet_ai* GetPetAI() const { return NULL; }
+        bot_minion_ai const* ToMinionAI() const { return IsMinionAI() ? GetMinionAI() : NULL; }
+        bot_minion_ai* ToMinionAI() { return IsMinionAI() ? const_cast<bot_minion_ai*>(GetMinionAI()) : NULL; }
+        bot_pet_ai const* ToPetAI() const { return IsPetAI() ? GetPetAI() : NULL; }
+        bot_pet_ai* ToPetAI() { return IsPetAI() ? const_cast<bot_pet_ai*>(GetPetAI()) : NULL; }
+        bool IsInBotParty(Unit const* unit) const;
+        bool CanBotAttack(Unit const* target, int8 byspell = 0) const;
+        bool InDuel(Unit const* target) const;
+        CommandStates GetBotCommandState() const { return m_botCommandState; }
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyBotSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyBotSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void ApplyBotSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const;
+        void ApplyBotSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const;
+        //inline void SendPartyEvadeAbort() const;
+        inline void SetNeedParty(bool need) { needparty = need; }
+        inline void SetShouldUpdateStats() { shouldUpdateStats = true; }
+        inline void UpdateHealth() { doHealth = true; }
+        inline void UpdateMana() { doMana = true; }
+        inline uint32 GetManaRegen() const { return regen_mp; }
+        inline float GetHitRating() const { return hit; }
+        inline int32 GetHaste() const { return haste; }
+        inline float GetShieldBlockValue() const { return blockvalue; }
+        virtual uint8 GetBotStance() const { return BOT_STANCE_NONE; }
+        inline uint8 GetBotRoles() const { return _roleMask; }
+        inline bool HasRole(uint8 role) const { return _roleMask & role; }
+        void ToggleRole(uint8 role, bool force);
+        char const* GetRoleString(uint8 role) const;
+
+        virtual void OnBotSummon(Creature* /*summon*/) {}
+        virtual void OnBotDespawn(Creature* /*summon*/) {}
+        virtual void UnsummonAll() {}
+
+        void ReceiveEmote(Player* player, uint32 emote);
+        void ApplyPassives() const;
+
+        virtual void RemoveItemBonuses(uint8 /*slot*/) {}
+        virtual void ApplyItemBonuses(uint8 /*slot*/) {}
+
+        static inline bool CCed(Unit* target, bool root = false)
+        {
+            return target ? target->HasUnitState(UNIT_STATE_CONFUSED | UNIT_STATE_STUNNED | UNIT_STATE_FLEEING | UNIT_STATE_DISTRACTED | UNIT_STATE_CONFUSED_MOVE | UNIT_STATE_FLEEING_MOVE) || (root && (target->HasUnitState(UNIT_STATE_ROOT) || target->isFrozen() || target->isInRoots())) : true;
+        }
+
+        //virtual bool CanUseOffHand() const { return false; }
+        //virtual bool CanUseRanged() const { return false; }
+        //virtual bool CanEquip(ItemTemplate const* /*item*/, uint8 /*slot*/) const { return false; }
+        //virtual bool Unequip(uint8 /*slot*/) { return false; }
+        //virtual bool Equip(uint8 /*slot*/, Item* /*item*/) { return false; }
+        //virtual bool ResetEquipment(uint8 /*slot*/) { return false; }
+
+        static void BotSpeak(std::string const& text, uint8 msgtype, uint32 language, ObjectGuid sender, ObjectGuid receiver);
+
+        virtual void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType);
+        virtual bool IAmFree() const { return false; }
+
+        virtual void SetStats(bool, bool = false) = 0;
+        void DefaultInit();
+
+        void GetHomePosition(uint16& mapid, Position* pos);
+
+        virtual bool UpdateImpossibleChase(Unit* /*target*/) { return false; }
+        virtual bool IsDuringTeleport() const { return false; }
+        virtual void AbortTeleport() {}
+        virtual void ResetChase(Position* /*pos*/) {}
+
+        virtual uint8 GetPlayerClass() const { ASSERT(_botclass < BOT_CLASS_EX_START); return _botclass; }
+
+        virtual float GetBotParryChance() const { return CanParry() ? parry : 0.0f; }
+        virtual bool CanParry() const = 0;
+        virtual float GetBotDodgeChance() const { return CanDodge() ? dodge : 0.0f; }
+        virtual bool CanDodge() const = 0;
+        virtual float GetBotBlockChance() const { return CanBlock() ? block : 0.0f; }
+        virtual bool CanBlock() const = 0;
+        virtual float GetBotCritChance() const { return CanCrit() ? crit : 0.0f; }
+        virtual bool CanCrit() const = 0;
+        virtual float GetBotMissChance() const { return -hit; }
+        virtual bool CanMiss() const = 0;
+        virtual float GetBotEvasion() const { return 0.0f; }
+        virtual float GetBotArmorPenetrationCoef() const { return 0.0f; }
+        virtual float GetSpellMiscValue(uint32 /*basespell*/, uint8 /*offset*/ = 0) const { return 0.0f; }
+        virtual float GetBotDamageTakenMod() const { return dmg_taken; }
+        virtual uint32 GetBotExpertise() const { return expertise; }
+        virtual uint32 GetBotSpellPenetration() const { return spellpen; }
+        virtual uint32 GetBotSpellPower() const { return spellpower; }
+
+        virtual bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const;
+
+        MeleeHitOutcome BotRollCustomMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        virtual void CastBotItemCombatSpell(Unit* /*target*/, WeaponAttackType /*attType*/, uint32 /*procVictim*/, uint32 /*procEx*/, Spell const* /*spell = NULL*/) {}
+        virtual void OnBotSpellInterrupted(SpellSchoolMask schoolMask, uint32 unTimeMs);
+        virtual void OnBotSpellGo(Spell const* spell);
+        virtual void OnClassSpellGo(SpellInfo const* /*spellInfo*/) {}
+
+        static void InitBotCustomSpells();
+        static bool IsBotCustomSpell(uint32 spellId);
+
+        bool IsTempBot() const { return _temp; }
+        void SetBotIsTemp() { _temp = true; }
+
+        void StartBoot() { _bootTimer = 60000; }
+        void CancelBoot() { _bootTimer = -1; }
+
+        bool IsSpellReady(uint32 basespell, uint32 diff, bool checkGCD = true, uint32 forcedTime = 0) const;
+        void SetSpellCooldown(uint32 basespell, uint32 msCooldown);
+        void SetSpellCategoryCooldown(SpellInfo const* spellInfo, uint32 msCooldown);
+        virtual void InitFaction() {}
+    protected:
+        static uint32 InitSpell(Unit const* caster, uint32 spell);
+        void InitSpellMap(uint32 basespell, bool forceadd = false, bool forwardRank = true);
+        uint32 GetSpell(uint32 basespell) const;
+        uint32 GetSpellCooldown(uint32 basespell) const;
+        void ResetSpellCooldown(uint32 basespell) { SetSpellCooldown(basespell, 0); }
+        void RemoveSpell(uint32 basespell);
+        void SpellTimers(uint32 diff);
+
+        virtual void InitRoles() = 0;
+        bool IsTank(Unit* unit = NULL) const;
+
+        bool HasAuraName(Unit* unit, uint32 spellId, ObjectGuid casterGuid = ObjectGuid::Empty, bool exclude = false) const;
+        bool RefreshAura(uint32 spellId, int8 count = 1) const;
+        bool CheckAttackTarget(uint8 botOrPetType);
+        bool MoveBehind(Unit &target) const;
+        bool CheckImmunities(uint32 spell, Unit* target = NULL) const { return (spell && target && !target->ToCorpse() && target->IsHostileTo(me) ? !target->IsImmunedToDamage(sSpellMgr->GetSpellInfo(spell)) : true); }
+
+        //everything cast-related
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false, ObjectGuid originalCaster = ObjectGuid::Empty);
+        SpellCastResult CheckBotCast(Unit* victim, uint32 spellId, uint8 botclass) const;
+        virtual void removeFeralForm(bool /*force*/ = false, bool /*init*/ = true, uint32 /*diff*/ = 0) {}
+
+        //inline bool JumpingFlyingOrFalling() const { return me->IsFalling() || me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP|MOVEMENTFLAG_PITCH_DOWN|MOVEMENTFLAG_SPLINE_ELEVATION|MOVEMENTFLAG_FALLING_SLOW); }
+        inline bool JumpingFlyingOrFalling() const { return me->HasUnitMovementFlag(MOVEMENTFLAG_PITCH_UP | MOVEMENTFLAG_PITCH_DOWN | MOVEMENTFLAG_SPLINE_ELEVATION | MOVEMENTFLAG_FALLING_SLOW | MOVEMENTFLAG_FALLING | MOVEMENTFLAG_FALLING_FAR | MOVEMENTFLAG_DISABLE_GRAVITY); }
+        inline bool Feasting() const { return (me->HasAura(EAT) || me->HasAura(DRINK)); }
+        inline bool IsMeleeClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT || m_class == BOT_CLASS_BM); }
+        inline bool IsTankingClass(uint8 m_class) const { return (m_class == CLASS_WARRIOR || m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT); }
+        inline bool IsChanneling(Unit* u = NULL) const { if (!u) u = me; return u->GetCurrentSpell(CURRENT_CHANNELED_SPELL); }
+        inline bool IsCasting(Unit* u = NULL) const { if (!u) u = me; return (u->HasUnitState(UNIT_STATE_CASTING) || IsChanneling(u) || u->IsNonMeleeSpellCast(false, false, true)); }
+
+        void GetInPosition(bool force = false, Unit* newtarget = NULL, Position* pos = NULL);
+        void OnSpellHit(Unit* caster, SpellInfo const* spell);
+        void CalculateAttackPos(Unit* target, Position &pos) const;
+        virtual void CheckAttackState();
+        virtual void Evade(bool = false) {}
+        virtual void OnStartAttack(Unit* /*u*/) {}
+
+        virtual void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+        virtual void ApplyClassDamageMultiplierMelee(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierSpell(int32& /*damage*/, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& /*crit*/) const {}
+        virtual void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& /*heal*/, SpellInfo const* /*spellInfo*/, DamageEffectType /*damagetype*/, uint32 /*stack*/) const {}
+        virtual void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& /*crit_chance*/, SpellInfo const* /*spellInfo*/, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const {}
+        virtual void ApplyClassSpellCostMods(SpellInfo const* /*spellInfo*/, int32& /*cost*/) const {}
+        virtual void ApplyClassSpellCastTimeMods(SpellInfo const* /*spellInfo*/, int32& /*casttime*/) const {}
+        virtual void ApplyClassSpellCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellCategoryCooldownMods(SpellInfo const* /*spellInfo*/, uint32& /*cooldown*/) const {}
+        virtual void ApplyClassSpellGlobalCooldownMods(SpellInfo const* /*spellInfo*/, float& /*cooldown*/) const {}
+        virtual void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        virtual void CheckAuras(bool /*force*/ = false) {}
+        virtual void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        virtual void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        virtual void InitSpells() {}
+        virtual void InitPowers() {}
+        virtual void InitEquips() {}
+        virtual void InitOwner() {}
+        virtual void SavePosition() {}
+        virtual void ApplyClassPassives() = 0;
+        virtual void _OnHealthUpdate() const = 0;
+        virtual void _OnManaUpdate(bool /*shapeshift*/ = false) = 0;
+        //virtual void _OnMeleeDamageUpdate(uint8 /*myclass*/) const = 0;
+        virtual void Regenerate() = 0;
+
+        //virtual void ReceiveEmote(Player* /*player*/, uint32 /*emote*/) {}
+        //virtual void CommonTimers(uint32 diff) = 0;
+
+        virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        virtual bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        virtual bool IsMelee() const { return HasRole(BOT_ROLE_DPS) && !HasRole(BOT_ROLE_RANGED); }
+        virtual bool CanHeal() const { return false; }
+        virtual bool CanSheath() const { return true; }
+        virtual bool CanSit() const { return true; }
+        virtual bool CanDrink() const { return true; }
+        virtual bool CanEat() const { return true; }
+        virtual bool CanMount() const { return true; }
+        virtual bool CanChangeEquip(uint8 /*slot*/) const { return true; }
+        virtual bool IgnoreEquipsAttackTime() const { return false; }
+        virtual bool CanSeeEveryone() const { return false; }
+
+        uint8 GetWait();
+        inline float InitAttackRange(float origRange, bool ranged) const;
+        uint16 Rand() const;
+        static inline uint32 GetLostHP(Unit const* unit) { return unit->GetMaxHealth() - unit->GetHealth(); }
+        static inline uint8 GetHealthPCT(Unit const* hTarget) { if (!hTarget || hTarget->isDead()) return 100; return (hTarget->GetHealth()*100/hTarget->GetMaxHealth()); }
+        static inline uint8 GetManaPCT(Unit const* hTarget) { if (!hTarget || hTarget->isDead() || hTarget->GetMaxPower(POWER_MANA) <= 1) return 100; return (hTarget->GetPower(POWER_MANA)*100/(hTarget->GetMaxPower(POWER_MANA))); }
+
+        typedef std::set<Unit*> AttackerSet;
+
+        virtual MeleeHitOutcome GetNextAttackMeleeOutCome() const { return MELEE_HIT_CRUSHING; }
+
+        //event helpers
+        void BotJumpInPlaceInFrontOf(Position* pos, float speedXY, float maxHeight);
+
+        //utilities
+        void _AddItemTemplateLink(Player* forPlayer, ItemTemplate const* item, std::ostringstream &str) const;
+        void _AddItemLink(Player* forPlayer, Item const* item, std::ostringstream &str) const;
+        void _AddQuestLink(Player* forPlayer, Quest const* quest, std::ostringstream &str) const;
+        void _AddWeaponSkillLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillid) const;
+        void _AddSpellLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, bool color = true, const std::string& colorstr = "ffffffff") const;
+        void _AddProfessionLink(Player* forPlayer, SpellInfo const* spellInfo, std::ostringstream &str, uint32 skillId) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, uint32 entry) const;
+        void _LocalizeItem(Player* forPlayer, std::string &itemName, std::string &suffix, Item const* item) const;
+        void _LocalizeQuest(Player* forPlayer, std::string &questTitle, uint32 entry) const;
+        void _LocalizeCreature(Player* forPlayer, std::string &creatureName, uint32 entry) const;
+        void _LocalizeGameObject(Player* forPlayer, std::string &gameobjectName, uint32 entry) const;
+
+        void BuildGrouUpdatePacket(WorldPacket* data);
+
+        void BotSay(char const* text, Player const* target = NULL) const;
+        void BotWhisper(char const* text, Player* target = NULL) const;
+        void BotYell(char const* text, Player const* target = NULL) const;
+
+        typedef std::pair<uint32 /*spellId*/, uint32 /*cooldown*/> BotSpell;
+        typedef std::unordered_map<uint32 /*spellId_1*/, BotSpell /*spell*/> BotSpellMap;
+
+        BotSpellMap const& GetSpellMap() const { return spells; }
+
+        Player* master;
+        Unit* opponent;
+        CommandStates m_botCommandState;
+        SpellInfo const* m_botSpellInfo;
+        Position pos, attackpos;
+        float atpower, maxdist, ap_mod, spp_mod, crit_mod;
+        ObjectGuid aftercastTargetGuid;
+        int32 cost, value, sppower;
+        uint32 GC_Timer, temptimer, checkAurasTimer, checkMasterTimer, roleTimer, wait, regenTimer_hp, regenTimer_mp,
+            currentSpell;
+        uint8 clear_cd;
+        bool doHealth, doMana, shouldUpdateStats;
+
+        //stats
+        float hit, parry, dodge, block, blockvalue, crit, dmg_taken;
+        uint32 expertise, spellpower, spellpen, regen_hp, regen_mp;
+        int32 haste;
+        uint32 lastdiff;
+
+        uint8 _botclass;
+        uint8 _roleMask;
+        uint32 _ownerGuid;
+        bool needparty;
+        bool spawned;
+        bool firstspawn;
+        bool _evadeMode;
+        bool _atHome;
+
+        bool _temp;
+
+        int32 _bootTimer;
+        uint32 _updateTimerMedium;
+
+        EventProcessor events;
+
+        //VisibilityUpdateEvent* visUpEvent;
+        TeleportHomeEvent* teleHomeEvent;
+        //EvadeEvent* evadeEvent;
+        TeleportFinishEvent* teleFinishEvent;
+
+    private:
+        Unit* _getTarget(bool byspell, bool ranged, bool &reset) const;
+        bool _hasAuraName(Unit* unit, const std::string spell, ObjectGuid casterGuid = ObjectGuid::Empty, bool exclude = false) const;
+        void _listAuras(Player* player, Unit* unit) const;
+        static inline float _getAttackDistance(float distance) { return distance > 0.0f ? distance*0.72f : 0.0f; }
+
+        BotSpellMap spells;
+};
+
+class bot_minion_ai : public bot_ai
+{
+    public:
+        virtual ~bot_minion_ai();
+        bot_minion_ai(Creature* creature);
+        virtual void Reset() {}
+        virtual void EnterEvadeMode() { EnterEvadeMode(false); }
+        void EnterEvadeMode(bool force);
+        virtual void JustDied(Unit*);
+        virtual void EnterCombat(Unit* u);
+        virtual void MoveInLineOfSight(Unit* u);
+        virtual void ReturnHome() { _atHome = false; }
+        void CommonTimers(uint32 diff);
+        const bot_minion_ai* GetMinionAI() const { return this; }
+        bool IsMinionAI() const { return true; }
+        bool IsPetAI() const { return false; }
+        bool CanRespawn() { return IAmFree(); }
+        void SummonBotsPet(uint32 entry);
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        void CureGroup(Player* pTarget, uint32 cureSpell, uint32 diff);
+        bool CureTarget(Unit* target, uint32 cureSpell, uint32 diff);
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool shapeshift = false);
+
+        static bool OnGossipHello(Player* player, Creature* creature, uint32 option);
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action);
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code);
+
+        void InitSpells() {}
+        void InitPowers() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        void _OnMeleeDamageUpdate(uint8 myclass) const;
+        void Regenerate();
+
+        void RemoveItemBonuses(uint8 slot);
+        void ApplyItemBonuses(uint8 slot);
+        void RemoveItemEnchantments(Item* item, uint8 slot);
+        void RemoveItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEnchantments(Item* item, uint8 slot);
+        void ApplyItemEnchantment(Item* item, EnchantmentSlot eslot, uint8 slot);
+        void ApplyItemEquipSpell(Item* item, bool apply);
+        void ApplyItemsSpells();
+
+        void OnOwnerDamagedBy(Unit* attacker);
+
+        //inline void SetEvadeTimer(uint8 time) { evade_cd = time; }
+
+        bool CanHeal() const;
+
+        uint32 GetReviveTimer() const { return _reviveTimer; }
+        void SetReviveTimer(uint32 newtime) { _reviveTimer = newtime; }
+        void UpdateReviveTimer(uint32 diff);
+
+        bool IAmFree() const;
+        void SavePosition();
+        void TeleportHome();
+        bool FinishTeleport(/*uint32 mapId, uint32 instanceId, float x, float y, float z, float o*/);
+
+        bool IsDuringTeleport() const { return teleFinishEvent || teleHomeEvent; }
+        void SetTeleportFinishEvent(TeleportFinishEvent* tfevent) { ASSERT(!teleFinishEvent); teleFinishEvent = tfevent; }
+        void AbortTeleport();
+
+        void ResetChase(Position* pos);
+        void ResetChaseTimer(Position* pos);
+        bool UpdateImpossibleChase(Unit* target);
+        void BotJump(Position* pos);
+
+        virtual bool CanParry() const { return me->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 0) != 0 && parry_mod > 0.0f && me->CanUseAttackType(BASE_ATTACK); }
+        virtual bool CanDodge() const { return dodge_mod > 0.0f; }
+        virtual bool CanBlock() const { return !(me->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_BLOCK) && me->CanUseAttackType(OFF_ATTACK); }
+        virtual bool CanCrit() const { return crit_mod > 0.0f; }
+        virtual bool CanMiss() const { return true; }
+
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell = NULL);
+        void CastBotItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Item* item, ItemTemplate const* proto, Spell const* spell = NULL);
+
+        float GetTotalBotStat(uint8 stat) const { return _getTotalBotStat(stat); }
+        void InitRoles();
+        void InitEquips();
+        void InitOwner();
+        void InitFaction();
+    protected:
+        bool GlobalUpdate(uint32 diff);
+
+        Item const* GetEquips(uint8 slot) const { return _equips[slot]; }
+
+        virtual bool CanUseManually(uint32 /*basespell*/) const { return false; }
+        void BuffAndHealGroup(Player* gPlayer, uint32 diff);
+        void RezGroup(uint32 REZZ, Player* gPlayer);
+
+        void Follow(bool force = false, Position* newpos = NULL)
+        {
+            if (force ||
+                (me->IsAlive() && (!me->IsInCombat() || !opponent) && m_botCommandState != COMMAND_STAY))
+                SetBotCommandState(COMMAND_FOLLOW, force, newpos);
+        }
+
+        //void CheckAttackState();
+        void Evade(bool force = false);
+        void OnStartAttack(Unit* u);
+
+        virtual void BreakCC(uint32 diff);
+
+
+
+        WorldObject* GetNearbyRezTarget(float dist = 30) const;
+        Unit* FindHostileDispelTarget(float dist = 30, bool stealable = false) const;
+        Unit* FindAffectedTarget(uint32 spellId, ObjectGuid caster = ObjectGuid::Empty, float dist = DEFAULT_VISIBILITY_DISTANCE, uint8 hostile = 0) const;
+        Unit* FindPolyTarget(float dist = 30, Unit* currTarget = NULL) const;
+        Unit* FindFearTarget(float dist = 30) const;
+        Unit* FindStunTarget(float dist = 20) const;
+        Unit* FindUndeadCCTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindRootTarget(float dist = 30, uint32 spellId = 0) const;
+        Unit* FindCastingTarget(float maxdist = 10, float mindist = 0, bool isFriend = false, uint32 spellId = 0) const;
+        Unit* FindAOETarget(float dist = 30, bool checkbots = false, bool targetfriend = true) const;
+        Unit* FindSplashTarget(float dist = 5, Unit* To = NULL, float splashdist = 4) const;
+        Unit* FindTranquilTarget(float mindist = 5, float maxdist = 35) const;
+        void GetNearbyTargetsList(std::list<Unit*> &targets, float maxdist = 10, float mindist = 0, bool forCC = false) const;
+        void GetNearbyFriendlyTargetsList(GuidList &targets, float maxdist = 30) const;
+
+        uint32 Potion_cd;
+
+    private:
+        bool _canCureTarget(Unit* target, uint32 cureSpell, uint32 diff) const;
+        void _getBotDispellableAuraList(Unit* target, Unit* caster, uint32 dispelMask, DispelChargesList& dispelList) const;
+        void _calculatePos(Position& pos);
+        void _updateMountedState();
+        void _updateStandState() const;
+        void _updateRations();
+        char const* _getNameForSlot(uint8 slot) const;
+        uint8 _onOffIcon(uint8 role) const;
+        void _updateEquips(uint8 slot, Item* item);
+
+        bool _canUseOffHand() const;
+        bool _canUseRanged() const;
+        bool _canEquip(ItemTemplate const* item, uint8 slot, bool ignoreItemLevel = false) const;
+        bool _unequip(uint8 slot);
+        bool _equip(uint8 slot, Item* newItem);
+        bool _resetEquipment(uint8 slot);
+
+        typedef std::unordered_map<uint32 /*stat*/, int32 /*statvalue*/> BotStat;
+        BotStat _stats[BOT_INVENTORY_SIZE];
+        float _getBotStat(uint8 slot, uint8 stat) const;
+        float _getTotalBotStat(uint8 stat) const;
+        float _getRatingMultiplier(CombatRating cr) const;
+
+        Item* _equips[BOT_INVENTORY_SIZE];
+        PlayerClassLevelInfo* _classinfo;
+        float myangle, armor_mod, haste_mod, dodge_mod, parry_mod;
+        uint32 mana_cd, health_cd, pvpTrinket_cd;
+        bool feast_health, feast_mana;
+        uint8 rezz_cd;
+        uint32 _reviveTimer, _saveTimer, _powersTimer, _chaseTimer;
+        uint8 _jumpCount;
+        uint8 _evadeCount;
+        ObjectGuid _lastTargetGuid; //unused
+};
+
+class bot_pet_ai : public bot_ai
+{
+    public:
+        virtual ~bot_pet_ai();
+        bot_pet_ai(Creature* creature);
+        virtual void Reset() {}
+        const bot_pet_ai* GetPetAI() const { return this; }
+        Creature* GetCreatureOwner() const { return m_creatureOwner; }
+        bool IsMinionAI() const { return false; }
+        bool IsPetAI() const { return true; }
+        bool CanRespawn() { return false; }
+        void CommonTimers(uint32 diff);
+        inline bool IAmDead() const { return (!master || !m_creatureOwner || me->isDead()); }
+        //void SetCreatureOwner(Creature* newowner) { m_creatureOwner = newowner; }
+        void SetBotCommandState(CommandStates st, bool force = false, Position* newpos = NULL);
+        //virtual bool HealTarget(Unit* /*target*/, uint8 /*pct*/, uint32 /*diff*/) { return false; }
+        //virtual bool BuffTarget(Unit* /*target*/, uint32 /*diff*/) { return false; }
+        //void BuffAndHealGroup(Player* /*gPlayer*/, uint32 /*diff*/) {}
+        //void RezGroup(uint32 /*REZZ*/, Player* /*gPlayer*/) {}
+        //virtual bool doCast(Unit*  /*victim*/, uint32 /*spellId*/, bool /*triggered*/ = false) { return false; }
+        //void CureGroup(Player* /*pTarget*/, uint32 /*cureSpell*/, uint32 /*diff*/) {}
+        //bool CureTarget(Unit* /*target*/, uint32 /*cureSpell*/, uint32 /*diff*/) { return false; }
+        void CheckAuras(bool force = false);
+        //virtual void DoNonCombatActions(uint32 /*diff*/) {}
+        //virtual void StartAttack(Unit* /*u*/, bool /*force*/ = false) {}
+        void SetStats(bool force, bool = false);
+
+        static uint8 GetPetType(Creature* pet);
+        static uint8 GetPetClass(Creature* pet);
+        static uint32 GetPetOriginalEntry(uint32 entry);
+
+        //debug
+        //virtual void ListSpells(ChatHandler* /*handler*/) const {}
+
+        void InitSpells() {}
+        void _OnHealthUpdate() const;
+        void _OnManaUpdate(bool shapeshift = false);
+        //void _OnMeleeDamageUpdate(uint8 /*myclass*/) const {}
+        void Regenerate();
+        void SetBaseArmor(uint32 armor) { basearmor = armor; }
+
+        virtual bool CanParry() const { return false; }
+        virtual bool CanDodge() const { return true; }
+        virtual bool CanBlock() const { return false; }
+        virtual bool CanCrit() const { return true; }
+        virtual bool CanMiss() const { return true; }
+
+    protected:
+        void InitRoles();
+
+        Creature* m_creatureOwner;
+    private:
+        uint32 basearmor;
+};
+
+#endif
diff --git a/src/server/game/AI/NpcBots/bot_bm_ai.cpp b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
new file mode 100644
index 0000000..f55639b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_bm_ai.cpp
@@ -0,0 +1,968 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Blademaster NpcBot (by Graff onlysuffering@gmail.com)
+Complete - Around 30%
+TODO: MIRROR IMAGE (ILLUSION), BLADESTORM
+*/
+
+#define MAX_ILLUSION_POSITIONS 4
+
+class blademaster_bot : public CreatureScript
+{
+public:
+    blademaster_bot() : CreatureScript("blademaster_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new blademaster_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct blademaster_botAI : public bot_minion_ai
+    {
+    private:
+        //DelayedMeleeDamageEvent - Blademaster
+        //deals critical damage, resets attack timer and sends fake log
+        class DelayedMeleeDamageEvent : public BasicEvent
+        {
+            public:
+                DelayedMeleeDamageEvent(ObjectGuid botGuid, ObjectGuid targetGuid, bool windwalk) :
+                  _botGuid(botGuid), _targetGuid(targetGuid), _windwalk(windwalk), _dinfo(NULL) { }
+                ~DelayedMeleeDamageEvent() { }
+
+                void SetDamageInfo(CalcDamageInfo* dinfo)
+                {
+                    _dinfo = dinfo;
+                }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    bool suc = false;
+                    /*if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->CriticalStrikeFinish(_targetGuid, _dinfo, _windwalk);
+                        suc = true;
+                    }*/
+
+                    delete _dinfo;
+                    return suc;
+                }
+
+            private:
+                ObjectGuid _botGuid;
+                ObjectGuid _targetGuid;
+                bool _windwalk;
+                CalcDamageInfo* _dinfo;
+                DelayedMeleeDamageEvent(DelayedMeleeDamageEvent const&);
+        };
+
+        class EventTerminateEvent : public BasicEvent
+        {
+            public:
+                EventTerminateEvent(ObjectGuid botGuid) : _botGuid(botGuid) { }
+                ~EventTerminateEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    /*if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->TerminateEvent();
+                        return true;
+                    }*/
+                    return false;
+                }
+
+            private:
+                ObjectGuid _botGuid;
+                EventTerminateEvent(EventTerminateEvent const&);
+        };
+
+        class DelayedIllusionSummonEvent : public BasicEvent
+        {
+            public:
+                DelayedIllusionSummonEvent(ObjectGuid botGuid) : _botGuid(botGuid) { }
+                ~DelayedIllusionSummonEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    /*if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageFinish();
+                        return true;
+                    }*/
+
+                    return false;
+                }
+
+            private:
+                ObjectGuid _botGuid;
+                DelayedIllusionSummonEvent(DelayedIllusionSummonEvent const&);
+        };
+
+        class DisappearEvent : public BasicEvent
+        {
+            public:
+                DisappearEvent(ObjectGuid botGuid) : _botGuid(botGuid) { }
+                ~DisappearEvent() { }
+
+            protected:
+                bool Execute(uint64 /*e_time*/, uint32 /*p_time*/)
+                {
+                    /*if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(_botGuid, (Creature*)NULL))
+                    {
+                        ASSERT(bot->GetBotClass() == BOT_CLASS_BM);
+                        (dynamic_cast<blademaster_bot::blademaster_botAI*>(bot->GetBotMinionAI()))->MirrorImageMid();
+                        return true;
+                    }*/
+
+                    return false;
+                }
+
+            private:
+                ObjectGuid _botGuid;
+                DisappearEvent(DisappearEvent const&);
+        };
+
+        void _calcIllusionPositions()
+        {
+            float x = me->m_positionX;
+            float y = me->m_positionY;
+            float o = me->m_orientation;
+
+            //X     X
+            //   C
+            //X     X
+            //
+            //C - caster (Blademaster)
+            //X - new positions (1-3 illusions + blademaster)
+
+            float dist = 2.f; //not too far - 2 for x and y seems to be way to go
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                _illusPos[i].m_positionX = x + ((i == 0 || i == 1) ? +dist : -dist); // +2+2-2-2
+                _illusPos[i].m_positionY = y + (!(i & 1) ? +dist : -dist);           // +2-2+2-2
+                _illusPos[i].m_orientation = o;
+            }
+        }
+
+    public:
+        blademaster_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_BM;
+            //Blademaster cannot be disarmed
+            me->ApplySpellImmune(0, IMMUNITY_MECHANIC, SPELL_AURA_MOD_DISARM, true);
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_BM) != SPELL_CAST_OK)
+                return false;
+
+            //custom
+            if (_dmdevent)
+                return false;
+            if (IsTempBot()) //Illusion etc.
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && me->GetPower(POWER_MANA) < 125)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckWindWalk(diff);
+            CheckMirrorImage(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_BM))
+                return;
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* /*u*/) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+        uint8 GetPlayerClass() const { return BOT_CLASS_WARRIOR; }
+
+        bool CanSheath() const { return false; }
+        bool CanSit() const { return false; }
+        bool CanDrink() const { return false; }
+        bool CanEat() const { return Windwalk_Timer == 0 && !illusion_Fade; }
+        bool CanMount() const { return false; }
+        bool CanChangeEquip(uint8 slot) const { return slot > BOT_SLOT_RANGED; }
+        bool IgnoreEquipsAttackTime() const { return true; }
+        bool CanSeeEveryone() const { return Windwalk_Timer > 0; }
+        bool CanParry() const { return false; }
+        bool CanCrit() const { return false; }
+        bool CanDodge() const { return false; }
+        bool CanMiss() const { return false; }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (IsSpellReady(WINDWALK_1, diff) && !IsTank(me) && Rand() < 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 /*diff*/)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            //float meleedist = me->GetDistance(opponent);
+            ////charge + warbringer
+            //if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+            //    (me->getLevel() >= 50 ||
+            //    (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            //{
+            //    temptimer = GC_Timer;
+            //    if (me->getLevel() >= 29)
+            //        me->RemoveMovementImpairingAuras();
+            //    if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+            //    {
+            //        SetSpellCooldown(CHARGE_1, 12000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            ////OVERPOWER
+            //if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50 && getrage() > 50 && meleedist <= 5 &&
+            //    (battleStance || stancetimer <= diff))
+            //{
+            //    if (me->HasAura(TASTE_FOR_BLOOD_BUFF))
+            //    {
+            //        if (battleStance || stanceChange(diff, 1))
+            //        {
+            //            if (doCast(opponent, GetSpell(OVERPOWER_1)))
+            //            {
+            //                me->RemoveAura(TASTE_FOR_BLOOD_BUFF);
+            //                return;
+            //            }
+            //        }
+            //    }
+            //}
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //////PLACEHOLDER - BLADESTORM
+            ////BLADESTORM
+            //if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+            //   getrage() >= 250 && (Rand() < 20 || me->HasAura(RECKLESSNESS_1)) &&
+            //   (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()))
+            //{
+            //    if (doCast(me, GetSpell(BLADESTORM_1)))
+            //    {
+            //        SetSpellCooldown(BLADESTORM_1, 60000);
+            //        return;
+            //    }
+            //}
+            //////PLACEHOLDER - SPELLCAST INTERRUPT POSSIBLE
+            ////PUMMEL
+            //if (IsSpellReady(PUMMEL_1, diff, false) && Rand() < 80 && getrage() > 100 && meleedist <= 5 &&
+            //    opponent->IsNonMeleeSpellCast(false) &&
+            //    (berserkerStance || stancetimer <= diff))
+            //{
+            //    temptimer = GC_Timer;
+            //    if ((berserkerStance || stanceChange(diff, 3)) &&
+            //        doCast(opponent, GetSpell(PUMMEL_1)))
+            //    {
+            //        SetSpellCooldown(PUMMEL_1, 10000);
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+        }
+
+        void DoBMMeleeAttackIfReady()
+        {
+            //Copied from UnitAI::DoMeleeAttackIfReady() with modifications
+            //cannot attack while casting or jumping
+            if (me->HasUnitState(UNIT_STATE_CASTING) || _dmdevent)
+                return;
+
+            Unit* victim = me->GetVictim();
+            //Make sure our attack is ready and we aren't currently casting before checking distance
+            if (me->isAttackReady() && me->IsWithinMeleeRange(victim))
+            {
+                if (!CCed(me, true) && !JumpingFlyingOrFalling())
+                {
+                    //Windwalk strike
+                    if (Windwalk_Timer)
+                    {
+                        CriticalStrike(victim, true);
+                        return;
+                    }
+
+                    //Critical Strike: 15% to deal x2,x3, etc... damage
+                    if (criticalStikeMult >= 2 && !CCed(me, true) && !JumpingFlyingOrFalling() &&
+                        roll_chance_f(15.f))
+                    {
+                        CriticalStrike(victim);
+                        return;
+                    }
+                }
+
+                me->AttackerStateUpdate(victim);
+                me->resetAttackTimer();
+                return;
+            }
+        }
+
+        void CheckAttackState()
+        {
+            if (me->GetVictim())
+            {
+                if (HasRole(BOT_ROLE_DPS))
+                    DoBMMeleeAttackIfReady();
+            }
+            else
+                Evade();
+        }
+
+        void CheckWindWalk(uint32 diff)
+        {
+            if (!IsSpellReady(WINDWALK_1, diff) || Windwalk_Timer || illusion_Fade || IsCasting() ||
+                Rand() > (10 + 20 * (me->IsInCombat() || master->IsInCombat())))
+                return;
+
+            if (!IAmFree() && master->isMoving())
+            {
+                if (me->GetDistance(master) > 30 &&
+                    doCast(me, GetSpell(WINDWALK_1)))
+                    return;
+
+                return;
+            }
+
+            if (!IsTank(me))
+            {
+                //unit to strike
+                Unit* u = IsMelee() ? me->GetVictim() : NULL;
+
+                if ((u && u->isMoving() && me->GetDistance(u) > 18 &&
+                    (u->GetVictim() != me || u->getAttackers().size() > uint8(u->IsControlledByPlayer() ? 0 : 1))) ||
+                    me->getAttackers().size() > 2)
+                {
+                    if (doCast(me, GetSpell(WINDWALK_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckMirrorImage(uint32 diff)
+        {
+            //only for controlled bot
+            if (IAmFree())
+                return;
+            if (!IsSpellReady(MIRROR_IMAGE_1, diff) || !me->IsInCombat() || !illusionsCount || illusion_Fade ||
+                IsCasting() || Rand() > 20)
+                return;
+
+            uint8 pct = GetHealthPCT(me);
+            uint8 size = uint8(me->getAttackers().size());
+            if (!size)
+                return;
+
+            if (pct > 25 && (size > 3 || pct < (80 + size * 5)))
+                if (doCast(me, GetSpell(MIRROR_IMAGE_1)))
+                    return;
+        }
+
+        void MirrorImageStart()
+        {
+            if (!illusionsCount)
+                return;
+
+            ASSERT(!illusion_Fade); //prevent double casts
+            illusion_Fade = true;
+
+            //OKAY
+
+            //there is a restiction for illusions count - cannot summon more than 3 of them
+            while (int8(_illusionGuids.size()) > (3 - illusionsCount))
+            {
+                GuidList::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = ObjectAccessor::GetCreatureOrPetOrVehicle(*me, *itr))
+                    if (!illusion->IsDuringRemoveFromWorld())
+                        illusion->ToCreature()->GetBotAI()->JustDied(NULL);
+
+                _illusionGuids.erase(itr);
+            }
+
+            //mirror image renders BM invulnerable for a short period of time,
+            //removing all auras. We exclude passive or invisible auras for they don't exist in W3
+            Unit::AuraMap const auras = me->GetOwnedAuras(); //copy
+            for (Unit::AuraMap::const_iterator iter = auras.begin(); iter != auras.end(); ++iter)
+            {
+                Aura* aura = iter->second;
+                if ((aura->GetSpellInfo()->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) ||
+                    (aura->GetSpellInfo()->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR))
+                    continue;
+                AuraApplication* aurApp = aura->GetApplicationOfTarget(me->GetGUID());
+                if (!aurApp)
+                    continue;
+                me->RemoveAura(aurApp, AURA_REMOVE_BY_DEFAULT);
+            }
+
+            me->BotStopMovement();
+            me->AttackStop();
+            me->HandleEmoteCommand(EMOTE_ONESHOT_NONE);
+            me->AddAura(BLACK_COLOR, me);//color
+            me->AddAura(STUN_FREEZE, me);//stop/immunity
+
+            //prepare to disappear
+            DisappearEvent* devent = new DisappearEvent(me->GetGUID());
+            events.AddEvent(devent, events.CalculateTime(300)); //immediatelly (almost)
+        }
+
+        void MirrorImageMid()
+        {
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+            {
+                me->RemoveAura(BLACK_COLOR);
+                me->RemoveAura(STUN_FREEZE);
+                illusion_Fade = false;
+                return;
+            }
+            //disappear
+            me->SetPhaseMask(0, true);
+
+            //INVISIBLE!
+            //EVENT
+            DelayedIllusionSummonEvent* disevent = new DelayedIllusionSummonEvent(me->GetGUID());
+            events.AddEvent(disevent, events.CalculateTime(1250)); //1000 ms disappear time + 250 ms buffer
+        }
+
+        void MirrorImageFinish()
+        {
+            illusion_Fade = false;
+            me->RemoveAura(BLACK_COLOR);
+            me->RemoveAura(STUN_FREEZE);
+            if (!me->IsInWorld() ||
+                !me->IsAlive()/* || CCed(me)*/) //this is just ensurance
+                return;
+
+            _calcIllusionPositions();
+
+            std::set<uint8> usedposs;
+
+            for (uint8 i = 0; i != illusionsCount; ++i)
+            {
+                Creature* illusion = master->SummonCreature(me->GetEntry(), *me, TEMPSUMMON_TIMED_DESPAWN, 1 * MINUTE * IN_MILLISECONDS);
+                if (!illusion)
+                    continue;
+
+                illusion->GetBotAI()->SetBotIsTemp();
+                illusion->GetBotAI()->FindMaster(true);
+                illusion->SetMaxHealth(me->GetMaxHealth());
+                illusion->SetHealth(me->GetHealth());
+                illusion->SetMaxPower(POWER_MANA, me->GetMaxPower(POWER_MANA));
+                illusion->SetPower(POWER_MANA, me->GetPower(POWER_MANA));
+                illusion->SetFloatValue(UNIT_FIELD_MINDAMAGE, me->GetFloatValue(UNIT_FIELD_MINDAMAGE));
+                illusion->SetFloatValue(UNIT_FIELD_MAXDAMAGE, me->GetFloatValue(UNIT_FIELD_MAXDAMAGE));
+
+                illusion->BotStopMovement();
+                while (true)
+                {
+                    uint8 j = urand(0, MAX_ILLUSION_POSITIONS - 1);
+                    if (usedposs.find(j) == usedposs.end())
+                    {
+                        illusion->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[j]);
+                        //illusion->Relocate(_illusPos[j]);
+                        usedposs.insert(j);
+                        break;
+                    }
+                }
+
+                illusion->SetBotCommandState(COMMAND_ABANDON);
+
+                _illusionGuids.push_back(illusion->GetGUID());
+            }
+
+            me->SetBotCommandState(COMMAND_ABANDON);
+
+            for (uint8 i = 0; i != MAX_ILLUSION_POSITIONS; ++i)
+            {
+                if (usedposs.find(i) == usedposs.end())
+                {
+                    me->BotStopMovement();
+                    me->GetMotionMaster()->MovePoint(me->GetMapId(), _illusPos[i]);
+                    //me->Relocate(_illusPos[i]);
+                    //usedposs.insert(i);
+                    break;
+                }
+            }
+
+            uint8 counter = 0;
+            uint8 r = urand(0, uint8(_illusionGuids.size() - 1));
+
+            for (GuidList::const_iterator itr = _illusionGuids.begin(); itr != _illusionGuids.end(); ++itr)
+            {
+                if (Creature* illusion = ObjectAccessor::GetCreatureOrPetOrVehicle(*me, *itr))
+                    illusion->SetPhaseMask(master->GetPhaseMask(), true);
+
+                if (counter == r)
+                    me->SetPhaseMask(master->GetPhaseMask(), true);
+                else
+                    ++counter;
+            }
+
+            me->getHostileRefManager().deleteReferences();
+
+            if (me->GetPhaseMask() != master->GetPhaseMask())
+                me->SetPhaseMask(master->GetPhaseMask(), true);
+
+            //me->setAttackTimer(BASE_ATTACK, 3000);
+            wait = 18;
+            SetSpellCooldown(MIRROR_IMAGE_1, 8000);
+            Potion_cd = std::max<uint32>(Potion_cd, 10000);
+        }
+
+        void CriticalStrike(Unit* target, bool windwalk = false)
+        {
+            //Okay critical strike must have jump and strike animation, doing delayed damage
+            DelayedMeleeDamageEvent* dmdevent = new DelayedMeleeDamageEvent(me->GetGUID(), target->GetGUID(), windwalk);
+            SetDelayedMeleeDamageEvent(dmdevent);
+
+            //hack temp attack damage calc
+            float mindam = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            float maxdam = me->GetFloatValue(UNIT_FIELD_MAXDAMAGE);
+
+            if (windwalk)
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * 1.5f);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * 1.5f);
+                me->RemoveAura(GetSpell(WINDWALK_1));
+                me->RemoveAura(TRANSPARENCY);
+            }
+            else
+            {
+                me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam * criticalStikeMult);
+                me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam * criticalStikeMult);
+            }
+
+            CalcDamageInfo* dinfo = new CalcDamageInfo();
+            me->CalculateMeleeDamage(target, 0, dinfo, BASE_ATTACK);
+
+            me->SetFloatValue(UNIT_FIELD_MINDAMAGE, mindam);
+            me->SetFloatValue(UNIT_FIELD_MAXDAMAGE, maxdam);
+
+            dmdevent->SetDamageInfo(dinfo);
+            events.AddEvent(dmdevent, events.CalculateTime(450));
+
+            BotJumpInPlaceInFrontOf(target, 0.32f, 4.1f); //jump - DO NOT CHANGE
+            me->CastSpell(target, SPELL_COMBAT_SPECIAL_2H_ATTACK, true); //strike anim
+            me->resetAttackTimer(BASE_ATTACK);
+        }
+
+        void CriticalStrikeFinish(ObjectGuid targetGuid, CalcDamageInfo* dinfo, bool /*windwalk*/)
+        {
+            EventTerminateEvent* etevent = new EventTerminateEvent(me->GetGUID());
+            events.AddEvent(etevent, events.CalculateTime(750));
+
+            if (!me->IsInWorld() || !me->IsAlive() || CCed(me))
+            {
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            Unit* target = ObjectAccessor::GetUnit(*me, targetGuid);
+            if (!target || !target->IsAlive())
+            {
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            if (target->IsImmunedToDamage(SPELL_SCHOOL_MASK_NORMAL))
+            {
+                //target became immune
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_IMMUNE);
+                target->PlayDistanceSound(SOUND_ABSORB_GET_HIT);
+                Windwalk_Timer = 0;
+                return;
+            }
+            else if (!CanSeeEveryone() && !me->CanSeeOrDetect(target, false, false))
+            {
+                //target disappeared
+                me->SendSpellMiss(target, CRITICAL_STRIKE_1, SPELL_MISS_MISS/*SPELL_MISS_EVADE*/);
+                me->PlayDistanceSound(SOUND_MISS_WHOOSH_2H);
+                Windwalk_Timer = 0;
+                return;
+            }
+
+            target->PlayDistanceSound(SOUND_AXE_2H_IMPACT_FLESH_CRIT);
+
+            me->SendSpellNonMeleeDamageLog(target, CRITICAL_STRIKE_1,
+                dinfo->damage + dinfo->absorb + dinfo->resist + dinfo->blocked_amount,
+                SPELL_SCHOOL_MASK_NORMAL, dinfo->absorb, dinfo->resist, true, dinfo->blocked_amount, true);
+            CleanDamage cl(0, 0, BASE_ATTACK, MELEE_HIT_CRIT);
+            me->DealDamage(target, dinfo->damage, &cl);
+            me->ProcDamageAndSpell(dinfo->target, dinfo->procAttacker, dinfo->procVictim, dinfo->procEx, dinfo->damage, dinfo->attackType);
+            me->CombatStart(target);
+
+            Windwalk_Timer = 0;
+        }
+
+        void SetDelayedMeleeDamageEvent(DelayedMeleeDamageEvent* dmdevent)
+        { _dmdevent = dmdevent; }
+
+        void TerminateEvent()
+        { _dmdevent = NULL; }
+
+        MeleeHitOutcome GetNextAttackMeleeOutCome() const
+        {
+            return _dmdevent ? MELEE_HIT_NORMAL : bot_ai::GetNextAttackMeleeOutCome();
+        }
+
+        bool IsBotImmuneToSpell(SpellInfo const* spellInfo) const
+        {
+            //PLACEHOLDER BLADESTORM
+            //return !spellInfo->HasEffect(SPELL_EFFECT_HEAL);
+            return bot_ai::IsBotImmuneToSpell(spellInfo);
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            //return _dmdevent ? 0.5f : bot_ai::GetBotArmorPenetrationCoef();
+            return 0.5f;
+        }
+
+        float GetSpellMiscValue(uint32 basespell, uint8 offset) const
+        {
+            switch (basespell)
+            {
+                case CRITICAL_STRIKE_1:
+                    return offset == 0 ? criticalStikeMult : 0;
+                case MIRROR_IMAGE_1:
+                    return offset == 0 ? illusionsCount : 0;
+                default:
+                    return 0;
+            }
+        }
+
+        //void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        //{
+        //    uint32 spellId = spellInfo->Id;
+        //    uint8 lvl = me->getLevel();
+        //    float fdamage = float(damage);
+        //    //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+        //    if (!crit)
+        //    {
+        //        float aftercrit = 0.f;
+        //        ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+        //        //if (lvl >= 15 && spellId == GetSpell(CLEAVE_1) /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+        //        //    aftercrit += 15.f;
+
+        //        //second roll (may be illogical)
+        //        if (aftercrit > 0.f)
+        //            crit = roll_chance_f(aftercrit);
+        //    }
+
+        //    //2) apply bonus damage mods
+        //    float pctbonus = 0.0f;
+        //    if (crit)
+        //    {
+        //        //!!!Melee spell damage is not yet critical, all reduced by half
+        //        //Impale: 20% crit damage bonus for all abilities
+        //        if (lvl >= 20)
+        //            pctbonus += 0.10f;
+        //    }
+
+        //    ////Improved Rend: 20% bonus damage for Rend
+        //    //if (spellId == GetSpell(REND_1))
+        //    //    pctbonus += 0.2f;
+
+        //    damage = int32(fdamage * (1.0f + pctbonus));
+        //}
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(WINDWALK_1))
+            {
+                Windwalk_Timer = 30000; //TODO:
+                me->RemoveMovementImpairingAuras();
+                me->PlayDistanceSound(SOUND_FREEZE_IMPACT_WINDWALK, !IAmFree() ? master : NULL);
+
+                uint32 dur = 30000;
+                if (Aura* aura = me->GetAura(spellId))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+                if (Aura* aura = me->GetAura(TRANSPARENCY))
+                {
+                    aura->SetDuration(dur);
+                    aura->SetMaxDuration(dur);
+                }
+
+                if (GetHealthPCT(me) < 25 || !HasRole(BOT_ROLE_DPS))
+                    me->AttackStop();
+
+                //SpellEffectSanctuary
+                me->getHostileRefManager().UpdateVisibility();
+                AttackerSet attackers = me->getAttackers();
+                for (AttackerSet::const_iterator itr = attackers.begin(); itr != attackers.end();)
+                {
+                    if (!(*itr)->CanSeeOrDetect(me))
+                        (*(itr++))->AttackStop();
+                    else
+                        ++itr;
+                }
+
+                me->m_lastSanctuaryTime = getMSTime();
+            }
+
+            if (spellId == GetSpell(MIRROR_IMAGE_1))
+            {
+                MirrorImageStart();
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* /*target*/, SpellInfo const* /*spell*/) { }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            //Illusions deal no damage
+            if (IsTempBot())
+            {
+                //manually add threat as if damage was done
+                if (victim->GetTypeId() != TYPEID_PLAYER)
+                    victim->AddThreat(me, float(damage * 2));
+
+                damage = 0;
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& damage)
+        {
+            //illusions take twice damage
+            if (IsTempBot())
+            {
+                damage *= 2;
+                //return;
+            }
+            if (illusion_Fade)
+            {
+                damage = 0;
+                return;
+            }
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void OnBotDespawn(Creature* /*summon*/)
+        {}
+
+        void UnsummonAll()
+        {
+            while (!_illusionGuids.empty())
+            {
+                GuidList::iterator itr = _illusionGuids.begin();
+                if (Creature* illusion = ObjectAccessor::GetCreatureOrPetOrVehicle(*me, *itr))
+                    if (illusion->GetBotAI())
+                        illusion->GetBotAI()->JustDied(NULL);
+
+                _illusionGuids.erase(itr);
+            }
+        }
+
+        void Reset()
+        {
+            _dmdevent = NULL;
+            Windwalk_Timer = 0;
+            criticalStikeMult = 1;
+            illusionsCount = 0;
+            illusion_Fade = false;
+
+            me->setPowerType(POWER_MANA);
+            me->SetMaxPower(POWER_MANA, 75);
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Windwalk_Timer > diff)          Windwalk_Timer -= diff;
+            else if (Windwalk_Timer > 0)        Windwalk_Timer = 0;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+ /*Special*/lvl >= 10 ? InitSpellMap(WINDWALK_1) : RemoveSpell(WINDWALK_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(MIRROR_IMAGE_1) : RemoveSpell(MIRROR_IMAGE_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = me->getLevel();
+
+            RefreshAura(SPELL_BURNING_BLADE_BLADEMASTER);
+
+            criticalStikeMult =
+                level < 10 ? 1 :
+                level < 30 ? 2 :
+                level < 50 ? 3 :
+                level < 82 ? 4 : 5;
+
+            illusionsCount =
+                level < 20 ? 0 :
+                level < 40 ? 1 :
+                level < 70 ? 2 : 3;
+                //level < 83 ? 3 : 4;
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case WINDWALK_1:
+                case MIRROR_IMAGE_1:
+                    return true;
+                default:
+                    break;
+            }
+
+            return false;
+        }
+
+    private:
+        DelayedMeleeDamageEvent* _dmdevent;
+        GuidList _illusionGuids;
+        Position _illusPos[MAX_ILLUSION_POSITIONS];
+
+        uint32 Windwalk_Timer;
+        uint8 criticalStikeMult;
+        uint8 illusionsCount;
+        bool illusion_Fade;
+
+        enum BlademasterBaseSpells
+        {
+            WINDWALK_1                              = SPELL_NETHERWALK,
+            MIRROR_IMAGE_1                          = SPELL_MIRROR_IMAGE_BM,
+            CRITICAL_STRIKE_1                       = SPELL_CRITICAL_STRIKE
+        };
+        enum BlademasterPassives
+        {
+        //Talents
+        //other
+        };
+        enum BlademasterSpecial
+        {
+            TRANSPARENCY                            = SPELL_TRANSPARENCY_50,
+            BLACK_COLOR                             = SPELL_VERTEX_COLOR_BLACK,
+            STUN_FREEZE                             = SPELL_STUN_FREEZE_ANIM
+        };
+    };
+};
+
+void AddSC_blademaster_bot()
+{
+    new blademaster_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
new file mode 100644
index 0000000..126e41d
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_death_knight_ai.cpp
@@ -0,0 +1,1622 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Death Knight NpcBot by Graff onlysuffering@gmail.com
+Complete - around 55%
+Note: Rune system adapted from TC
+TODO: REMEMBER ALREADY DK HAS MINIMUM LEVEL 55!
+*/
+const RuneType runeSlotTypes[MAX_RUNES] =
+{
+    RUNE_BLOOD,
+    RUNE_BLOOD,
+    RUNE_UNHOLY,
+    RUNE_UNHOLY,
+    RUNE_FROST,
+    RUNE_FROST
+};
+struct BotRuneInfo
+{
+    uint8 BaseRune;
+    uint8 CurrentRune;
+    uint32 Cooldown;
+    //AuraEffect const* ConvertAura;
+};
+
+struct BotRunes
+{
+    BotRuneInfo runes[MAX_RUNES];
+    //uint8 runeState;          //UNUSED
+    //uint8 lastUsedRune;       //UNUSED
+
+    //void SetRuneState(uint8 index, bool set = true)
+    //{
+    //    if (set)
+    //        runeState |= (1 << index);    // usable
+    //    else
+    //        runeState &= ~(1 << index);   // on cooldown
+    //}
+};
+class death_knight_bot : public CreatureScript
+{
+public:
+    death_knight_bot() : CreatureScript("death_knight_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new death_knight_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct death_knight_botAI : public bot_minion_ai
+    {
+        death_knight_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DEATH_KNIGHT;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DEATH_KNIGHT) != SPELL_CAST_OK)
+                return false;
+
+            SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId);
+            int32 runecost[NUM_RUNE_TYPES];
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                runecost[i] = 0;
+
+            if (!triggered)
+            {
+                if (!HaveRunes(spellInfo, runecost))
+                    return false;
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result)
+            {
+                //std::ostringstream str;
+                //str << "Casting " << spellInfo->SpellName[0] << " on " << victim->GetName();
+                //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                //Set cooldown for runes
+                if (!triggered)
+                {
+                    SpendRunes(runecost);
+                    ////debug
+                    //for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+                    //    if (runecost[i])
+                    //        TC_LOG_FATAL("entities.player", "doCast():: DK bot %s has casted spell %u (%s) without %u rune(s) (type %u)!",
+                    //            me->GetName().c_str(), spellId, spellInfo->SpellName[0], runecost[i], i);
+                }
+                //runic power gain: all dk spells are instant but some have no unit target so
+                //we gain runic power here instead of SpellHitTarget()
+                if (SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID))
+                    if (int32 rp = int32(src->runePowerGain * runicpowerIncomeMult))
+                        me->ModifyPower(POWER_RUNIC_POWER, int32(rp));
+            }
+
+            return result;
+        }
+
+        bool HaveRunes(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            if (spellInfo->PowerType != POWER_RUNE || !spellInfo->RuneCostID)
+                return true;
+
+            CalcRuneCost(spellInfo, runecost);
+
+            if (runecost[RUNE_DEATH] != 0 && runecost[RUNE_DEATH] > GetDeathRunesCount())
+                return false;
+
+            return true;
+        }
+
+        void CalcRuneCost(SpellInfo const* spellInfo, int32 *runecost) const
+        {
+            SpellRuneCostEntry const* src = sSpellRuneCostStore.LookupEntry(spellInfo->RuneCostID);
+            if (!src)
+                return;
+
+            if (src->NoRuneCost())
+                return;
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                runecost[i] = src->RuneCost[i];
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                uint8 rune = _runes.runes[i].BaseRune;
+                if (_runes.runes[i].CurrentRune == rune && _runes.runes[i].Cooldown == 0 && runecost[rune] > 0)
+                    runecost[rune]--;
+            }
+
+            for (uint8 i = 0; i != RUNE_DEATH; ++i)
+                if (runecost[i] > 0)
+                    runecost[RUNE_DEATH] += runecost[i];
+
+            ////restore cost to allow cooldown set
+            //for (uint8 i = 0; i != RUNE_DEATH; ++i)
+            //    runecost[i] = src->RuneCost[i];
+        }
+
+        int32 GetDeathRunesCount() const
+        {
+            int32 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].CurrentRune == RUNE_DEATH && _runes.runes[i].Cooldown == 0)
+                    ++count;
+
+            return count;
+        }
+
+        uint8 GetCooledRunesCount(uint8 runetype) const
+        {
+            uint8 count = 0;
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+                if (_runes.runes[i].BaseRune == runetype && _runes.runes[i].Cooldown > 0)
+                    ++count;
+
+            return count;
+        }
+
+        void SpendRunes(int32* runecost)
+        {
+            for (uint8 i = 0; i != NUM_RUNE_TYPES; ++i)
+            {
+                if (runecost[i] <= 0)
+                    continue;
+
+                for (uint8 j = 0; j != MAX_RUNES && runecost[i] > 0; ++j)
+                {
+                    if (SpendRune(i))
+                        runecost[i]--;
+                }
+            }
+
+            if (GetCooledRunesCount(RUNE_BLOOD) > 1)
+            {
+                me->CastSpell(me, BLADE_BARRIER_AURA, true);
+            }
+        }
+
+        bool SpendRune(uint8 runetype)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].CurrentRune == runetype && _runes.runes[i].Cooldown == 0)
+                {
+                    _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                    //_runes.lastUsedRune = _runes.runes[i].CurrentRune;        //UNUSED
+                    //_runes.SetRuneState(i, false);                            //UNUSED
+                    //DK receives rune regen bonus from mana regen
+                    uint32 cooldown = RUNE_BASE_COOLDOWN - std::min<uint32>(uint32(GetManaRegen() * 10), RUNE_BASE_COOLDOWN);
+                    _runes.runes[i].Cooldown = cooldown;
+                    //std::ostringstream str;
+                    //str << "Spent rune " << uint32(i) << " (type: " << uint32(runetype) << ')';
+                    //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        bool HaveRune(uint8 runetype) const
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if ((_runes.runes[i].CurrentRune == runetype || _runes.runes[i].CurrentRune == RUNE_DEATH) &&
+                    _runes.runes[i].Cooldown == 0)
+                {
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void ConvertRune(uint8 runetype, uint8 count)
+        {
+            if (runetype == RUNE_DEATH)
+                return;
+
+            uint8 failcount = 0;
+            for (uint8 i = 0; i != MAX_RUNES && count > 0; ++i)
+            {
+                if (_runes.runes[i].BaseRune == runetype)
+                {
+                    if (_runes.runes[i].CurrentRune == RUNE_DEATH)
+                    {
+                        ++failcount;
+                        continue;
+                    }
+
+                    if (_runes.runes[i].Cooldown > 3000)
+                        _runes.runes[i].Cooldown -= 3000;
+
+                    _runes.runes[i].CurrentRune = RUNE_DEATH;
+                    --count;
+                }
+            }
+
+            if (!count && !failcount)
+                return;
+
+            //std::ostringstream str;
+            //str << "Failed to convert rune of type: " << uint32(runetype) << ")!";
+            //me->Whisper(str.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+        }
+
+        void ActivateAllRunes()
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].Cooldown = 0;
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void InitRunes()
+        {
+            //_runes.runeState = 0;                   //UNUSED
+            //_runes.lastUsedRune = RUNE_BLOOD;       //UNUSED
+
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                _runes.runes[i].BaseRune = runeSlotTypes[i];
+                _runes.runes[i].CurrentRune = _runes.runes[i].BaseRune;
+                _runes.runes[i].Cooldown = 0;
+                //_runes.runes[i].ConvertAura = NULL; //UNUSED
+                //_runes.SetRuneState(i, true);       //UNUSED
+            }
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void RuneTimers(uint32 diff)
+        {
+            for (uint8 i = 0; i != MAX_RUNES; ++i)
+            {
+                if (_runes.runes[i].Cooldown <= diff)
+                {
+                    _runes.runes[i].Cooldown = 0;
+                    //_runes.SetRuneState(i, true);     //UNUSED
+                }
+                else
+                    _runes.runes[i].Cooldown -= diff;
+            }
+        }
+
+        void modpower(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && runicpower < uint32(abs(mod)))
+            {
+                //debug set runic power to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                runicpower = mod ? mod * 10 : 0;
+            else
+                runicpower += mod * 10;
+
+            me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        uint32 getpower()
+        {
+            runicpower = me->GetPower(POWER_RUNIC_POWER);
+            return runicpower;
+        }
+
+        uint8 GetBotStance() const { return Presence; }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void KilledUnit(Unit*) { }
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || IsCasting() || Feasting() || Rand() > 20)
+                return;
+
+            //PATH OF FROST
+            if (GetSpell(PATH_OF_FROST_1) && HaveRune(RUNE_FROST)/* && !me->IsMounted()*/) //works while mounted
+            {
+                if ((me->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !me->HasAuraType(SPELL_AURA_WATER_WALK)) ||
+                    (master->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING) && !master->HasAuraType(SPELL_AURA_WATER_WALK) && me->GetDistance(master) < 50))
+                {
+                    if (doCast(me, GetSpell(PATH_OF_FROST_1)))
+                        return;
+                }
+            }
+        }
+
+        void CheckHysteria(uint32 diff)
+        {
+            if (!IsSpellReady(HYSTERIA_1, diff) || IsCasting() || Rand() > 15)
+                return;
+
+            Unit* target = NULL;
+
+            if (master->IsAlive() && IsMeleeClass(master->getClass()) && master->IsInCombat() &&
+                GetHealthPCT(master) > 80 && me->GetDistance(master) < 30 &&
+                master->getAttackers().empty() && !CCed(master, true))
+            {
+                if (Unit* u = master->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = master;
+            }
+
+            if (!target && IsMeleeClass(_botclass) && GetHealthPCT(me) > 80 &&
+                me->getAttackers().empty() && !CCed(me, true))
+            {
+                if (Unit* u = me->GetVictim())
+                    if (u->GetHealth() > me->GetMaxHealth() / 2)
+                        target = me;
+            }
+
+            if (!target && !IAmFree())
+            {
+                Group* gr = master->GetGroup();
+                if (gr)
+                {
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == master) continue;
+                        if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (!tPlayer->IsAlive() || me->GetMap() != tPlayer->FindMap()) continue;
+                        if (!IsMeleeClass(tPlayer->getClass()) || !tPlayer->IsInCombat()) continue;
+                        if (GetHealthPCT(tPlayer) < 80 || me->GetDistance(tPlayer) > 30) continue;
+                        if (!tPlayer->getAttackers().empty() || CCed(tPlayer, true)) continue;
+                        if (Unit* u = tPlayer->GetVictim())
+                        {
+                            if (u->GetHealth() > (me->GetMaxHealth() * 2) / 3)
+                            {
+                                target = tPlayer;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            if (target && doCast(target, GetSpell(HYSTERIA_1)))
+            {
+                if (target->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Hysteria on You!", target->ToPlayer());
+
+                GC_Timer = 800;
+                return;
+            }
+
+            SetSpellCooldown(HYSTERIA_1, 2000); //fail
+        }
+
+        void CheckAntiMagicShell(uint32 diff)
+        {
+            if (!IsSpellReady(ANTI_MAGIC_SHELL_1, diff, false) || GetHealthPCT(me) > 55 ||
+                getpower() < 200 || IsCasting() || Rand() > 50)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+                return;
+
+            bool cast = false;
+            uint8 count = 0;
+
+            for (AttackerSet::const_iterator itr = b_attackers.begin(); itr != b_attackers.end(); ++itr)
+            {
+                if (!(*itr) || !(*itr)->IsAlive()) continue;
+                if (Spell* spell = (*itr)->GetCurrentSpell(CURRENT_GENERIC_SPELL))
+                {
+                    if (spell->m_targets.GetUnitTargetGUID() == me->GetGUID())
+                    {
+                        if ((*itr)->ToCreature() && (*itr)->ToCreature()->isWorldBoss())
+                        {
+                            cast = true;
+                            break;
+                        }
+
+                        if (++count >= 3)
+                        {
+                            cast = true;
+                            break;
+                        }
+                    }
+                }
+            }
+
+            if (cast)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(ANTI_MAGIC_SHELL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(ANTI_MAGIC_SHELL_1, 1500); //fail
+        }
+
+        void CheckPresence(uint32 diff)
+        {
+            if (presencetimer > diff || IsCasting() || Rand() > 30) //no GCD
+                return;
+
+            uint8 newpresence = IsTank() ? DEATH_KNIGHT_FROST_PRESENCE : DEATH_KNIGHT_BLOOD_PRESENCE;
+            if (Presence == newpresence)
+            {
+                presencetimer = 500;
+                return;
+            }
+
+            Presence = newpresence;
+
+            if (Presence == DEATH_KNIGHT_FROST_PRESENCE && HaveRune(RUNE_FROST))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, FROST_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+            else if (Presence == DEATH_KNIGHT_BLOOD_PRESENCE && HaveRune(RUNE_BLOOD))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, BLOOD_PRESENCE_1))
+                {
+                    GC_Timer = temptimer;
+                    presencetimer = 1000;
+                    return;
+                }
+            }
+
+            presencetimer = 500; //fail
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (IsSpellReady(LICHBORNE_1, diff, false) &&/* Rand() < 75 &&*/
+                me->HasAuraWithMechanic((1<<MECHANIC_CHARM)|(1<<MECHANIC_FEAR)|(1<<MECHANIC_SLEEP)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LICHBORNE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+
+            if (me->getPowerType() != POWER_RUNIC_POWER)
+                InitPowers();
+
+            if (runicpowertimer <= diff)
+            {
+                if (!me->IsInCombat())
+                {
+                    if (getpower() > uint32(30 * runicpowerLossMult))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower - uint32(30 * runicpowerLossMult)); //-3 runic power every 2 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, 0);
+                }
+                runicpowertimer = 2000;
+            }
+            if (runicpowertimer2 <= diff)
+            {
+                if (me->IsInCombat())
+                {
+                    if (getpower() < me->GetMaxPower(POWER_RUNIC_POWER))
+                        me->SetPower(POWER_RUNIC_POWER, runicpower + uint32(20 * runicpowerIncomeMult)); //+2 runic power every 5 sec
+                    else
+                        me->SetPower(POWER_RUNIC_POWER, me->GetMaxPower(POWER_RUNIC_POWER));
+                }
+                runicpowertimer2 = 5000;
+            }
+
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            CheckPresence(diff);
+
+            //HORN OF WINTER
+            if (IsSpellReady(HORN_OF_WINTER_1, diff, false, (me->IsInCombat() ? 45000 : 0)) && Rand() < 30 &&
+                (me->IsInCombat() || (me->GetDistance(master) < 28 && master->IsWithinLOSInMap(me))))
+            {
+                Aura* horn = master->GetAura(GetSpell(HORN_OF_WINTER_1));
+                if (!horn || horn->GetDuration() < 5000)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(HORN_OF_WINTER_1)))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+            //BONE SHIELD
+            if (IsSpellReady(BONE_SHIELD_1, diff) && HaveRune(RUNE_UNHOLY) && Rand() < 25)
+            {
+                Aura* bone = me->GetAura(GetSpell(BONE_SHIELD_1));
+                if (!bone || bone->GetCharges() < 2 || (!me->IsInCombat() && bone->GetDuration() < 60000))
+                {
+                    if (doCast(me, GetSpell(BONE_SHIELD_1)))
+                    {
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(BONE_SHIELD_1, 1000); //fail
+            }
+
+            if (me->IsInCombat())
+            {
+                //ICEBOUND FORTITUDE
+                if (IsSpellReady(ICEBOUND_FORTITUDE_1, diff, false) && getpower() >= 200 &&
+                    GetHealthPCT(me) < std::min<uint32>(85, 45 + uint8(me->getAttackers().size()) * 7) &&
+                    Rand() < 40 + IsTank() * 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(ICEBOUND_FORTITUDE_1)))
+                        GC_Timer = temptimer;
+                }
+
+                CheckAntiMagicShell(diff);
+                CheckHysteria(diff);
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_DEATH_KNIGHT))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            //SELFHEAL
+
+            //RUNE TAP
+            if (IsSpellReady(RUNE_TAP_1, diff) && GetHealthPCT(me) < 40 && Rand() < 50)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RUNE_TAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //VAMPIRIC BLOOD
+            if (IsSpellReady(VAMPIRIC_BLOOD_1, diff, false) && GetHealthPCT(me) < 26/* && Rand() < 75*/)
+            {
+                if (!HaveRune(RUNE_BLOOD) && IsSpellReady(EMPOWER_RUNE_WEAPON_1, diff, false, 40000))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(EMPOWER_RUNE_WEAPON_1)))
+                    {
+                        ActivateAllRunes();
+                        GC_Timer = temptimer;
+                    }
+                }
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(VAMPIRIC_BLOOD_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //END SELFHEAL
+
+            //MARK OF BLOOD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(MARK_OF_BLOOD_1, diff) && HaveRune(RUNE_BLOOD) &&
+                u && GetHealthPCT(u) < 85 && opponent->GetHealth() > u->GetMaxHealth() / 3 &&
+                (IsTank(u) || u->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 35 && !opponent->HasAura(MARK_OF_BLOOD_1) && IsInBotParty(u))
+            {
+                if (doCast(opponent, GetSpell(MARK_OF_BLOOD_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //NON-DISEASE SECTION
+
+            //PLACEHOLDER: ARMY OF THE DEAD
+
+            //RANGED SECTION
+
+            //STRANGULATE
+            if (IsSpellReady(STRANGULATE_1, diff) && meleedist <= 30 && HaveRune(RUNE_BLOOD) &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 40)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                if (doCast(opponent, GetSpell(STRANGULATE_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(STRANGULATE_1, 500); //fail
+            }
+
+            //DARK COMMAND
+            if (IsSpellReady(DARK_COMMAND_1, diff, false) && dist < 30 && IsTank() &&
+                opponent->GetVictim() != me && Rand() < 70)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DARK_COMMAND_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            ////DEATH GRIP - DISABLED
+            //if (DEATH_GRIP && DeathGrip_cd <= diff && dist < 30 &&
+            //    (tank == me && opponent->GetVictim() != me) ||
+            //    (opponent->GetVictim() == me && opponent->ToPlayer() && opponent->IsNonMeleeSpellCast(false)) &&
+            //    Rand() < 75)
+            //{
+            //    temptimer = GC_Timer;
+            //    if (doCast(opponent, DEATH_GRIP))
+            //    {
+            //        DeathGrip_cd = 25000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+
+            //    DeathGrip_cd = 1000; //fail
+            //}
+            //CHAINS OF ICE
+            if (uint32 CHAINS_OF_ICE = GetSpell(CHAINS_OF_ICE_1))
+            {
+                if (GC_Timer <= diff && dist < 20 && HaveRune(RUNE_FROST) && opponent->isMoving() &&
+                    !CCed(opponent) && !IsTank(opponent->GetVictim()) && IsInBotParty(opponent->GetVictim()) && Rand() < 25)
+                {
+                    Aura* chains = opponent->GetAura(CHAINS_OF_ICE);
+                    if (!chains || chains->GetDuration() < chains->GetMaxDuration() / 4)
+                    {
+                        if (doCast(opponent, CHAINS_OF_ICE))
+                        {
+                            //Improved Chains of Ice: convert frost rune into death rune
+                            ConvertRune(RUNE_FROST, 1);
+                            return;
+                        }
+                    }
+                }
+            }
+
+            //AOE SECTION
+
+            //HOWLING BLAST
+            if (IsSpellReady(HOWLING_BLAST_1, diff) && IsTank() && meleedist < 8 && HasRole(BOT_ROLE_DPS) &&
+                me->getAttackers().size() > 2 && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(HOWLING_BLAST_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+
+                SetSpellCooldown(HOWLING_BLAST_1, 500); //fail
+            }
+            //BLOOD BOIL
+            if (IsSpellReady(BLOOD_BOIL_1, diff) && HasRole(BOT_ROLE_DPS) && HaveRune(RUNE_BLOOD) && Rand() < (10 + 40 * IsTank()))
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.5f);
+                if (targets.size() >= 5)
+                    if (doCast(me, GetSpell(BLOOD_BOIL_1)))
+                        return;
+            }
+            //DEATH AND DECAY
+            if (IsSpellReady(DEATH_AND_DECAY_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < (30 + 30 * IsTank()) &&
+                HaveRune(RUNE_BLOOD) && HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST))
+            {
+                if (Unit* target = FindAOETarget(30, true))
+                {
+                    if (doCast(target, GetSpell(DEATH_AND_DECAY_1)))
+                        return;
+                }
+
+                SetSpellCooldown(DEATH_AND_DECAY_1, 500); //fail
+            }
+
+            //END AOE SECTION
+
+            //ICY TOUCH
+            if (IsSpellReady(ICY_TOUCH_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && HaveRune(RUNE_FROST) && Rand() < 25 &&
+                !opponent->HasAura(FROST_FEVER_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(ICY_TOUCH_1)))
+                    return;
+            }
+            //DEATH COIL //custom cd condition
+            if (GetSpell(DEATH_COIL_1) && GC_Timer <= 600 && dist < 20 && HasRole(BOT_ROLE_DPS) &&
+                int32(getpower()) >= (400 + 200 * (GetSpell(RUNE_STRIKE_1) != 0 || GetSpell(MIND_FREEZE_1) != 0 || GetSpell(ANTI_MAGIC_SHELL_1) != 0) + 400 * (GetSpell(HUNGERING_COLD_1) != 0)) &&
+                Rand() < 60)
+            {
+                if (doCast(opponent, GetSpell(DEATH_COIL_1)))
+                    return;
+            }
+
+            //MELEE SECTION
+
+            //MIND FREEZE
+            if (IsSpellReady(MIND_FREEZE_1, diff, false) && meleedist <= 5 && getpower() >= 200 &&
+                opponent->IsNonMeleeSpellCast(false) && Rand() < 60)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(MIND_FREEZE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HUNGERING COLD
+            if (IsSpellReady(HUNGERING_COLD_1, diff) && HasRole(BOT_ROLE_DPS) && getpower() >= 400 && Rand() < 20)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f, 0, true);
+                if (targets.size() >= 3)
+                {
+                    if (doCast(me, GetSpell(HUNGERING_COLD_1)))
+                        return;
+                }
+
+                SetSpellCooldown(HUNGERING_COLD_1, 500); //fail
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //RUNE STRIKE
+            if (IsSpellReady(RUNE_STRIKE_1, diff, false) && runestriketimer > me->getAttackTimer(BASE_ATTACK) &&
+                HasRole(BOT_ROLE_DPS) && meleedist <= 5 && getpower() >= 200/* && Rand() < 75*/)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(RUNE_STRIKE_1)))
+                {
+                    runestriketimer = 0; //do not remove aura, just disable ability
+                    GC_Timer = temptimer;
+                }
+            }
+            //PLAGUE STRIKE
+            if (IsSpellReady(PLAGUE_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && HaveRune(RUNE_UNHOLY) && Rand() < 35 &&
+                !opponent->HasAura(BLOOD_PLAGUE_AURA, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(PLAGUE_STRIKE_1)))
+                    return;
+            }
+
+            //DISEASE SECTION
+            uint32 diseases = opponent->GetDiseasesByCaster(me->GetGUID());
+
+            //PESTILENCE //custom cd condition
+            if (GetSpell(PESTILENCE_1) && pestilencetimer == 0 && HasRole(BOT_ROLE_DPS) && GC_Timer <= 600 &&
+                diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 15)
+            {
+                std::list<Unit*> targets;
+                GetNearbyTargetsList(targets, 9.f);
+                if (targets.size() > 2)
+                {
+                    if (doCast(opponent, GetSpell(PESTILENCE_1)))
+                    {
+                        pestilencetimer = 10000;
+                        return;
+                    }
+                }
+
+                pestilencetimer = 1000; //fail
+            }
+            //DEATH STRIKE
+            if (IsSpellReady(DEATH_STRIKE_1, diff) && diseases > 0 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) &&
+                GetHealthPCT(me) < (91 - 10 * diseases) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEATH_STRIKE_1)))
+                    return;
+            }
+            //OBLITERATE
+            if (IsSpellReady(OBLITERATE_1, diff) && diseases > 2 && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                HaveRune(RUNE_UNHOLY) && HaveRune(RUNE_FROST) && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(OBLITERATE_1)))
+                    return;
+            }
+            //BLOOD STRIKE //custom
+            if (BLOOD_STRIKE && GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && diseases > 1 && meleedist <= 5 &&
+                HaveRune(RUNE_BLOOD) && Rand() < 25)
+            {
+                if (doCast(opponent, BLOOD_STRIKE))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Increased Plague Strike Crit (id 60130): 10% additional critical chance for Plague Strike
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Glyph of Rune Strike: 10% additional critical chance for Rune Strike
+                if (spellId == GetSpell(RUNE_STRIKE_1))
+                    aftercrit += 0.1f;
+                //Subversion: 9% additional critical chance for Blood Strike, Scourge Strike, Heart Strike and Obliterate
+                if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    /*spellId == GetSpell(SCOURGE_STRIKE_1) || */spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 0.09f;
+                //Improved Death Strike (part 2): 6% additional critical chance for Death Strike
+                if (spellId == GetSpell(DEATH_STRIKE_1))
+                    aftercrit += 0.06f;
+                //Rime (part 1 melee): 15% additional critical chance for Obliterate
+                if (lvl >= 68 && spellId == GetSpell(OBLITERATE_1))
+                    aftercrit += 15.f;
+                //Vicious Strikes (part 1): 6% additional critical chance for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    aftercrit += 6.f;
+
+                //Annihilation: 3% additional critical chance for melee special abilities
+                if (lvl >= 57)
+                    aftercrit += 0.03f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+
+                //Might of Mograine: 45% crit damage bonus for Blood Boil, Blood Strike, Death Strike and Heart Strike
+                if (lvl >= 68 &&
+                    (spellId == GetSpell(BLOOD_BOIL_1) || spellId == BLOOD_STRIKE ||
+                    spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(HEART_STRIKE_1)))
+                    pctbonus += 0.45f / 2.f;
+                //Guile of Gorefiend (part 1 melee): 45% crit damage bonus for Blood Strike, Frost Strike and Obliterate
+                if (lvl >= 69 &&
+                    (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) ||
+                    spellId == GetSpell(OBLITERATE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                    pctbonus += 0.45f / 2.f;
+                //Vicious Strikes (part 2): 30% crit damage bonus for Plague Strike and Scourge Strike
+                if (lvl >= 57 && (spellId == GetSpell(PLAGUE_STRIKE_1)/* || spellId == GetSpell(SCOURGE_STRIKE_1)*/))
+                    pctbonus += 0.3f / 2.f;
+            }
+
+            //Glypg of Plague Strike: 20% bonus damage for Plague Strike
+            if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                pctbonus += 0.2f;
+            //Glyph of Blood Strike: 20% bonus damage for Blood Strike on snared targets (Heart Strike too for bots)
+            //warning unsafe
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                if (damageinfo.target->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_SLOW_ATTACK)))
+                    pctbonus += 0.2f;
+            //Increased Blood Strike Damage: 90 bonus damage for Blood Strike and Heart Strike
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+                fdamage += 90.f;
+            //Glyph of Death Strike: 1% bonus damage for every runic power point (max 25) for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1) && me->GetPower(POWER_RUNIC_POWER) >= 10)
+            {
+                //10 to 250 * 0.001 = 10 to 250 / 1000 = 0.01 to 0.25
+                pctbonus += float(std::min<uint32>(me->GetPower(POWER_RUNIC_POWER), 250)) * 0.001f;
+            }
+            //Glyph of Obliterate: 25% bonus damage for Obliterate
+            if (spellId == GetSpell(OBLITERATE_1))
+                pctbonus += 0.25f;
+            //Bloody Strikes: 15% bonus damage for Blood Strike, 45% for Heart Strike and 30% for Blood Boil
+            if (lvl >= 60)
+            {
+                if (spellId == BLOOD_STRIKE)
+                    pctbonus += 0.15f;
+                else if (spellId == GetSpell(HEART_STRIKE_1))
+                    pctbonus += 0.45f;
+                else if (spellId == GetSpell(BLOOD_BOIL_1))
+                    pctbonus += 0.3f;
+            }
+            //Improved Death Strike (part 1): 30% bonus damage for Death Strike
+            if (spellId == GetSpell(DEATH_STRIKE_1))
+                pctbonus += 0.3f;
+            //Merciless Combat (melee): 12% bonus damage for Obliterate on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 && spellId == GetSpell(OBLITERATE_1) && damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Blood of the North (part 1): 10% bonus damage for Blood Strike and Frost Strike (make Heart strike too)
+            if (lvl >= 69 && (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/))
+                pctbonus += 0.1f;
+            //Tundra Stalker (melee): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Outbreak: 30% bonus damage for Plague Strike and 20% for Scourge Strike
+            if (lvl >= 59)
+            {
+                if (spellId == GetSpell(PLAGUE_STRIKE_1))
+                    pctbonus += 0.3f;
+                //else if (spellId == GetSpell(SCOURGE_STRIKE_1))
+                //    pctbonus += 0.2f;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rime (part 1 spell): 15% additional critical chance for Icy Touch
+                if (lvl >= 68 && spellId == GetSpell(ICY_TOUCH_1))
+                    aftercrit += 15.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+
+                //Guile of Gorefiend (part 1 spell): 45% crit damage bonus for Howling Blast
+                if (lvl >= 69 && spellId == GetSpell(HOWLING_BLAST_1))
+                    pctbonus += 0.45f / 1.5f;
+
+                //Runic Focus: 50% crit damage bonus for all spells
+                pctbonus += 0.5f / 1.5f;
+            }
+
+            //Improved Icy Touch: 15% bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                pctbonus += 0.15f;
+            //Increased Icy Touch Damage (id 54800): 111 bonus damage for Icy Touch
+            if (spellId == GetSpell(ICY_TOUCH_1))
+                fdamage += 111.f;
+            //Increased Death Coil Damage (id 54807): 80 bonus damage for Death Coil
+            if (spellId == GetSpell(DEATH_COIL_1))
+                fdamage += 80.f;
+            //Black Ice: 10% bonus damage for all Shadow and Frost spells
+            if (lvl >= 58 &&
+                ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                pctbonus += 0.1f;
+            //Glacier Rot: 20% bonus damage for Icy Touch, Howling Blast and Frost Strike
+            //warning unsafe
+            if (lvl >= 63 && (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetDiseasesByCaster(me->GetGUID()) > 0)
+                pctbonus += 0.2f;
+            //Merciless Combat (spell): 12% bonus damage for Icy Touch, Howling Blast and Frost Strike on targets with less than 35% hp
+            //warning unsafe
+            if (lvl >= 67 &&
+                (spellId == GetSpell(ICY_TOUCH_1) || spellId == GetSpell(HOWLING_BLAST_1)/* || spellId == GetSpell(FROST_STRIKE_1)*/) &&
+                damageinfo.target->GetHealthPct() < 35)
+                pctbonus += 0.12f;
+            //Tundra Stalker (spell): 40% damage bonus on targets affected with Frost Fever (20% for bot, regardless of caster)
+            //warning unsafe
+            if (lvl >= 70 && damageinfo.target->HasAura(FROST_FEVER_AURA))
+                pctbonus += 0.2f;
+            //Morbidity: 15% damage bonus for Death Coil
+            if (lvl >= 58 && spellId == GetSpell(DEATH_COIL_1))
+                pctbonus += 0.15f;
+
+            //temp
+            if (spellId == GetSpell(RUNE_TAP_1))
+                pctbonus += 1.f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* spellInfo, uint8 effect_index, float& value) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pct_mod = 1.f;
+
+            //Periodic damage bonuses
+            if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            {
+                //float ticksnum = float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+
+                //Increased Plague Strike DoT Damage (id 54802): increased DoT damage by 100
+                if (spellId == BLOOD_PLAGUE_AURA)
+                    value += 100.f;
+                //Glyph of Icy Touch: 20% bonus damage for Frost Fever
+                if (spellId == FROST_FEVER_AURA)
+                    pct_mod += 0.2f;
+                //Black Ice: 10% bonus damage for all Shadow and Frost spells
+                if (lvl >= 58 &&
+                    ((SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()) ||
+                    (SPELL_SCHOOL_MASK_SHADOW & spellInfo->GetSchoolMask())))
+                    pct_mod += 0.1f;
+                //Glyph of Unholy Blight: 40% damage bonus for Unholy Blight (100% for bot)
+                if (spellId == UNHOLY_BLIGHT_AURA)
+                    pct_mod += 1.f;
+            }
+            //Heal bonuses
+            if (spellInfo->Effects[effect_index].Effect == SPELL_EFFECT_HEAL)
+            {
+                //Improved Rune Tap: 100% bonus healing from Rune Tap
+                if (spellId == GetSpell(RUNE_TAP_1))
+                    pct_mod += 1.f;
+            }
+
+            value *= pct_mod;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Glyph of Horn of Winter: 1 minute bonus duration (3 for bot)
+            if (spellId == GetSpell(HORN_OF_WINTER_1))
+            {
+                if (Aura* horn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = horn->GetDuration() + 180000;
+                    horn->SetDuration(dur);
+                    horn->SetMaxDuration(dur);
+                }
+
+                //Winter Veil addition
+                if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+                    me->AddAura(44755, target); //snowflakes
+            }
+
+            if (target == me)
+                return;
+
+            //Epidemic: 10 sec bonus duration for all diseases
+            if (spellId == FROST_FEVER_AURA || spellId == BLOOD_PLAGUE_AURA ||
+                spellId == CRYPT_FEVER_AURA || spellId == EBON_PLAGUE_AURA)
+            {
+                if (Aura* fever = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = fever->GetDuration() + 10000;
+                    fever->SetDuration(dur);
+                    fever->SetMaxDuration(dur);
+                }
+            }
+            //Sudden Doom: 15% ctc Death Coil on Blood Strike or Heart Strike (up to 30% for bot)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1))
+            {
+                if (GetSpell(DEATH_COIL_1) && me->getLevel() >= 65 && irand(1,100) <= (me->getLevel() - 50))
+                {
+                    //debug: dk bot cannot cast without runic power even triggered spells
+                    modpower(40);
+                    me->CastSpell(target, GetSpell(DEATH_COIL_1), true);
+                }
+            }
+            //Rime (part 2): Obliterate has 15% chance to reset Howling Blast cooldown (25% for bot, screw runes part)
+            if (spellId == GetSpell(OBLITERATE_1))
+            {
+                if (me->getLevel() >= 67 && urand(1,100) <= 25)
+                    ResetSpellCooldown(HOWLING_BLAST_1);
+            }
+            //Chillblains Improved: increase duration by 10 sec (disable on players)
+            if (spellId == ICY_CLUTCH)
+            {
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* chill = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = chill->GetDuration() + 10000;
+                        chill->SetDuration(dur);
+                        chill->SetMaxDuration(dur);
+                    }
+                }
+            }
+            //Blood of the North (part 2): Blood Strike and Pestilence convert Blood Rune to Dark Rune (make Heart Strike too)
+            if (spellId == BLOOD_STRIKE || spellId == GetSpell(HEART_STRIKE_1) || GetSpell(spellId == PESTILENCE_1))
+            {
+                if (me->getLevel() >= 69)
+                    ConvertRune(RUNE_BLOOD, 1);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == RUNE_STRIKE_ACIVATION_AURA)
+            {
+                //Rune Strike activation and timer set
+                runestriketimer = 10000;
+            }
+            if (spellId == GetSpell(ANTI_MAGIC_SHELL_1))
+            {
+                //Glyph of Anti-Magic Shell: 2 sec increased duration (5 for bot)
+                if (Aura* shell = me->GetAura(spellId))
+                {
+                    uint32 dur = shell->GetDuration() + 5000;
+                    shell->SetDuration(dur);
+                    shell->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(VAMPIRIC_BLOOD_1))
+            {
+                //Glyph of Vampiric Blood: 5 sec increased duration
+                if (Aura* blood = me->GetAura(spellId))
+                {
+                    uint32 dur = blood->GetDuration() + 5000;
+                    blood->SetDuration(dur);
+                    blood->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(BONE_SHIELD_1))
+            {
+                //Glyph of Bone Shield: 1 bonus charge (2 for bot, 7 for tank)
+                if (Aura* bone = me->GetAura(spellId))
+                {
+                    bone->SetCharges(bone->GetCharges() + (IsTank() ? 3 : 1));
+                }
+            }
+            if (spellId == ICY_TALONS_AURA1 || spellId == ICY_TALONS_AURA2 ||
+                spellId == ICY_TALONS_AURA3 || spellId == ICY_TALONS_AURA4 || spellId == ICY_TALONS_AURA5)
+            {
+                //Icy Talons: Synchronize with Epidemic, add 10 sec duration
+                if (Aura* talons = me->GetAura(spellId))
+                {
+                    uint32 dur = talons->GetDuration() + 10000;
+                    talons->SetDuration(dur);
+                    talons->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(DEATH_STRIKE_1) || spellId == GetSpell(OBLITERATE_1))
+            {
+                //Death Rune Mastery: convert Unholy and Frost Runes into Death Runes
+                ConvertRune(RUNE_UNHOLY, 1);
+                ConvertRune(RUNE_FROST, 1);
+            }
+            if (spellId == GetSpell(ICEBOUND_FORTITUDE_1))
+            {
+                //Guile of Gorefiend (part 2): Icebound Fortitude 6 sec increased duration (18 for bot)
+                if (Aura* fort = me->GetAura(spellId))
+                {
+                    uint32 dur = fort->GetDuration() + 18000;
+                    fort->SetDuration(dur);
+                    fort->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                //Blood Presence Heal
+                if (me->HasAura(IMPROVED_BLOOD_PRESENCE_AURA))
+                {
+                    int32 bp0 = int32(damage / 25); //4%
+                    me->CastCustomSpell(me, BLOOD_PRESENCE_HEAL_EFFECT, &bp0, NULL, NULL, true);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            presencetimer = 0;
+            runicpowertimer = 2000;
+            runicpowertimer2 = 5000;
+            runestriketimer = 0;
+            pestilencetimer = 0;
+
+            Presence = BOT_STANCE_NONE;
+
+            runicpowerIncomeMult = sWorld->getRate(RATE_POWER_RUNICPOWER_INCOME);
+            runicpowerLossMult = sWorld->getRate(RATE_POWER_RUNICPOWER_LOSS);
+            me->setPowerType(POWER_RUNIC_POWER);
+            me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+
+            DefaultInit();
+            InitRunes();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            RuneTimers(diff);
+
+            if (presencetimer > diff)               presencetimer -= diff;
+            if (runicpowertimer > diff)             runicpowertimer -= diff;
+            if (runicpowertimer2 > diff)            runicpowertimer2 -= diff;
+
+            if (runestriketimer > diff)             runestriketimer -= diff;
+            else                                    runestriketimer = 0;
+            if (pestilencetimer > diff)             pestilencetimer -= diff;
+            else                                    pestilencetimer = 0;
+        }
+
+        void InitPowers()
+        {
+            if (master->getLevel() >= 70)
+                RefreshAura(RUNIC_POWER_MASTERY,5);
+            else if (master->getLevel() >= 58)
+                RefreshAura(RUNIC_POWER_MASTERY,4);
+            else
+            {
+                RefreshAura(RUNIC_POWER_MASTERY,0);
+                me->SetMaxPower(POWER_RUNIC_POWER, me->GetCreatePowers(POWER_RUNIC_POWER));
+            }
+
+            if (runicpower)
+                me->SetPower(POWER_RUNIC_POWER, runicpower);
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            //InitSpellMap(BLOOD_STRIKE_1);
+            InitSpellMap(ICY_TOUCH_1);
+            InitSpellMap(PLAGUE_STRIKE_1);
+            InitSpellMap(DEATH_STRIKE_1);
+            InitSpellMap(OBLITERATE_1);
+            InitSpellMap(RUNE_STRIKE_1);
+  /*Talent*/InitSpellMap(HEART_STRIKE_1);
+
+            InitSpellMap(BLOOD_BOIL_1);
+            InitSpellMap(DEATH_AND_DECAY_1);
+  /*Talent*/lvl >= 63 ? InitSpellMap(HOWLING_BLAST_1) : RemoveSpell(HOWLING_BLAST_1);
+
+            InitSpellMap(DEATH_COIL_1);
+            InitSpellMap(DEATH_GRIP_1, true);
+            InitSpellMap(PESTILENCE_1);
+            InitSpellMap(MIND_FREEZE_1);
+            InitSpellMap(STRANGULATE_1);
+            InitSpellMap(CHAINS_OF_ICE_1);
+            InitSpellMap(ICEBOUND_FORTITUDE_1);
+            InitSpellMap(DARK_COMMAND_1);
+            InitSpellMap(ANTI_MAGIC_SHELL_1);
+            InitSpellMap(ARMY_OF_THE_DEAD_1);
+  /*Talent*/InitSpellMap(LICHBORNE_1, true);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HUNGERING_COLD_1) : RemoveSpell(HUNGERING_COLD_1);
+
+            InitSpellMap(PATH_OF_FROST_1);
+            InitSpellMap(HORN_OF_WINTER_1);
+  /*Talent*/InitSpellMap(RUNE_TAP_1, true);
+  /*Talent*/lvl >= 58 ? InitSpellMap(BONE_SHIELD_1) : RemoveSpell(BONE_SHIELD_1);
+            InitSpellMap(EMPOWER_RUNE_WEAPON_1);
+  /*Talent*/InitSpellMap(MARK_OF_BLOOD_1, true);
+  /*Talent*/InitSpellMap(VAMPIRIC_BLOOD_1, true);
+  /*Talent*/lvl >= 59 ? InitSpellMap(HYSTERIA_1) : RemoveSpell(HYSTERIA_1);
+
+            InitSpellMap(BLOOD_PRESENCE_1, true);
+            InitSpellMap(FROST_PRESENCE_1, true);
+            //InitSpellMap(UNHOLY_PRESENCE_1, true);
+
+  /*Custom*/BLOOD_STRIKE = lvl >= 65 ? GetSpell(HEART_STRIKE_1) : InitSpell(me, BLOOD_STRIKE_1);
+            InitSpellMap(BLOOD_STRIKE);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(GLYPH_OF_CHAINS_OF_ICE, level >= 58 ? 1 : 0);
+            RefreshAura(CHAINS_OF_ICE_FROST_RUNE_REFRESH, level >= 80 ? 4 : level >= 77 ? 3 : level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HEART_STRIKE, level >= 65 ? 1 : 0);
+            RefreshAura(GLYPH_OF_RUNE_TAP, level >= 68 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_OF_HOWLING_BLAST, level >= 63 ? 1 : 0);
+            RefreshAura(BUTCHERY, level >= 57 ? 1 : 0);
+            RefreshAura(SCENT_OF_BLOOD, level >= 58 ? 1 : 0);
+            RefreshAura(VENDETTA, level >= 59 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE2, level >= 60 && level < 65 ? 1 : 0);
+            RefreshAura(BLOODY_VENGEANCE1, level >= 57 && level < 60 ? 1 : 0);
+            RefreshAura(ABOMINATIONS_MIGHT, level >= 60 ? 1 : 0);
+            RefreshAura(IMPROVED_BLOOD_PRESENCE, level >= 67 ? 1 : 0);
+            RefreshAura(BLOODWORMS, level >= 65 ? 2 : 0);
+            //RefreshAura(IMPROVED_DEATH_STRIKE, level >= 66 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 57 ? 1 : 0);
+            RefreshAura(ANNIHILATION, level >= 57 ? 1 : 0);
+            RefreshAura(ICY_TALONS, level >= 60 ? 1 : 0);
+            RefreshAura(CHILL_OF_THE_GRAVE, level >= 68 ? 2 : level >= 58 ? 1 : 0);
+            RefreshAura(IMPROVED_ICY_TALONS, level >= 64 ? 1 : 0);
+            RefreshAura(CHILBLAINS, level >= 68 ? 1 : 0);
+            RefreshAura(ACCLIMATION, level >= 69 ? 1 : 0);
+            RefreshAura(NECROSIS5, level >= 63 ? 1 : 0);
+            RefreshAura(NECROSIS4, level >= 62 && level < 63 ? 1 : 0);
+            RefreshAura(NECROSIS3, level >= 61 && level < 62 ? 1 : 0);
+            RefreshAura(NECROSIS2, level >= 60 && level < 61 ? 1 : 0);
+            RefreshAura(NECROSIS1, level >= 59 && level < 60 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE3, level >= 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE2, level >= 62 && level < 65 ? 1 : 0);
+            RefreshAura(BLOOD_CAKED_BLADE1, level >= 60 && level < 62 ? 1 : 0);
+            RefreshAura(DIRGE, level >= 67 ? 2 : level >= 61 ? 1 : 0);
+            RefreshAura(UNHOLY_BLIGHT, level >= 61 ? 1 : 0);
+            RefreshAura(DESECRATION, level >= 62 ? 1 : 0);
+            RefreshAura(CRYPT_FEVER, level >= 64 ? 1 : 0);
+            RefreshAura(EBON_PLAGUEBRINGER, level >= 68 ? 1 : 0);
+            RefreshAura(WANDERING_PLAGUE, level >= 67 ? 1 : 0);
+
+            RefreshAura(FROST_FEVER);
+            RefreshAura(BLOOD_PLAGUE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case LICHBORNE_1:
+                case PATH_OF_FROST_1:
+                case HORN_OF_WINTER_1:
+                case BONE_SHIELD_1:
+                case RUNE_TAP_1:
+                case EMPOWER_RUNE_WEAPON_1:
+                case VAMPIRIC_BLOOD_1:
+                case HYSTERIA_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 BLOOD_STRIKE;
+/*tmrs*/uint32 presencetimer, runicpowertimer, runicpowertimer2, runestriketimer, pestilencetimer;
+/*misc*/uint32 runicpower;
+/*misc*/float runicpowerIncomeMult, runicpowerLossMult;
+/*Chck*/uint8 Presence;
+
+        BotRunes _runes;
+
+        enum DeathKnightBaseSpells
+        {
+            BLOOD_STRIKE_1                      = 45902,
+            ICY_TOUCH_1                         = 45477,
+            PLAGUE_STRIKE_1                     = 45462,
+            DEATH_STRIKE_1                      = 49998,
+            OBLITERATE_1                        = 49020,
+            RUNE_STRIKE_1                       = 56815,
+            HEART_STRIKE_1                      = 55050,
+
+            BLOOD_BOIL_1                        = 48721,
+            DEATH_AND_DECAY_1                   = 43265,
+            HOWLING_BLAST_1                     = 49184,
+
+            DEATH_COIL_1                        = 47541,
+            DEATH_GRIP_1                        = 49576,
+            PESTILENCE_1                        = 50842,
+            MIND_FREEZE_1                       = 47528,
+            STRANGULATE_1                       = 47476,
+            CHAINS_OF_ICE_1                     = 45524,
+            ICEBOUND_FORTITUDE_1                = 48792,
+            DARK_COMMAND_1                      = 56222,
+            ANTI_MAGIC_SHELL_1                  = 48707,
+            ARMY_OF_THE_DEAD_1                  = 42650,
+            LICHBORNE_1                         = 49039,
+            HUNGERING_COLD_1                    = 49203,
+
+            PATH_OF_FROST_1                     = 3714,
+            HORN_OF_WINTER_1                    = 57330,
+            BONE_SHIELD_1                       = 49222,
+            RUNE_TAP_1                          = 48982,
+            EMPOWER_RUNE_WEAPON_1               = 47568,
+            MARK_OF_BLOOD_1                     = 49005,
+            VAMPIRIC_BLOOD_1                    = 55233,
+            HYSTERIA_1                          = 49016,
+
+            BLOOD_PRESENCE_1                    = 48266,
+            FROST_PRESENCE_1                    = 48263
+            //UNHOLY_PRESENCE_1                   = 48265
+        };
+        enum DeathKnightPassives
+        {
+        //Talents
+            BUTCHERY                            = 49483,//rank 2
+            SCENT_OF_BLOOD                      = 49509,//rank 3
+            VENDETTA                            = 55136,//rank 3
+            BLOODY_VENGEANCE1                   = 48988,
+            BLOODY_VENGEANCE2                   = 49503,
+            BLOODY_VENGEANCE3                   = 49504,
+            ABOMINATIONS_MIGHT                  = 53138,//rank 2
+            IMPROVED_BLOOD_PRESENCE             = 50371,//rank 2
+            BLOODWORMS                          = 49543,//rank 3
+            IMPROVED_DEATH_STRIKE               = 62908,//rank 2
+            TOUGHNESS                           = 49789,//rank 5
+            ANNIHILATION                        = 51473,//rank 3
+            ICY_TALONS                          = 50887,//rank 5
+            CHILL_OF_THE_GRAVE                  = 50115,//rank 2
+            IMPROVED_ICY_TALONS                 = 55610,
+            CHILBLAINS                          = 50043,//rank 3
+            ACCLIMATION                         = 50152,//rank 3
+            NECROSIS1                           = 51459,
+            NECROSIS2                           = 51462,
+            NECROSIS3                           = 51463,
+            NECROSIS4                           = 51464,
+            NECROSIS5                           = 51465,
+            BLOOD_CAKED_BLADE1                  = 49219,
+            BLOOD_CAKED_BLADE2                  = 49627,
+            BLOOD_CAKED_BLADE3                  = 49628,
+            DIRGE                               = 51206,//rank 2
+            UNHOLY_BLIGHT                       = 49194,
+            DESECRATION                         = 55667,//rank 2
+            CRYPT_FEVER                         = 49632,//rank 3
+            EBON_PLAGUEBRINGER                  = 51161,//rank 3
+            WANDERING_PLAGUE                    = 49655,//rank 3
+        //Special
+  /*Talent*/RUNIC_POWER_MASTERY                 = 50147,//rank 2
+            FROST_FEVER                         = 59921,
+            BLOOD_PLAGUE                        = 59879,
+        //Other
+            GLYPH_OF_CHAINS_OF_ICE              = 58620,//damage proc
+            CHAINS_OF_ICE_FROST_RUNE_REFRESH    = 62459,//5 runic power gain
+            GLYPH_OF_HEART_STRIKE               = 58616,//snare 50% for 10 sec
+            GLYPH_OF_RUNE_TAP                   = 59327,//10% heal for party
+            GLYPH_OF_HOWLING_BLAST              = 63335 //frost fever on targets
+        };
+        enum DeathKnightSpecial
+        {
+            FROST_FEVER_AURA                    = 55095,
+            BLOOD_PLAGUE_AURA                   = 55078,
+            CRYPT_FEVER_AURA                    = 50510,//rank 3
+            EBON_PLAGUE_AURA                    = 51735,//rank 3
+
+            RUNE_STRIKE_ACIVATION_AURA          = 56817,
+
+            IMPROVED_BLOOD_PRESENCE_AURA        = 63611,
+            BLOOD_PRESENCE_HEAL_EFFECT          = 50475,
+            BLADE_BARRIER_AURA                  = 64859,//rank 5
+            UNHOLY_BLIGHT_AURA                  = 50536,
+
+            ICY_TALONS_AURA1                    = 50882,//rank 1
+            ICY_TALONS_AURA2                    = 58575,//rank 2
+            ICY_TALONS_AURA3                    = 58576,//rank 3
+            ICY_TALONS_AURA4                    = 58577,//rank 4
+            ICY_TALONS_AURA5                    = 58578,//rank 5
+
+            DEATH_COIL_ENEMY                    = 47632,
+            ICY_CLUTCH                          = 50436 //rank 3 Chilblains proc
+        };
+        //enum RunePlacing
+        //{
+        //    RUNE_BLOOD_FIRST,
+        //    RUNE_BLOOD_SECOND,
+        //    RUNE_UNHOLY_FIRST,
+        //    RUNE_UNHOLY_SECOND,
+        //    RUNE_FROST_FIRST,
+        //    RUNE_FROST_SECOND,
+        //    NO_RUNE
+        //};
+    };
+};
+
+void AddSC_death_knight_bot()
+{
+    new death_knight_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_druid_ai.cpp b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
new file mode 100644
index 0000000..5802780
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_druid_ai.cpp
@@ -0,0 +1,1389 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Druid NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Maybe 30%
+TODO: Feral Spells (from scratch), More Forms, Balance Spells + treants...
+*/
+class druid_bot : public CreatureScript
+{
+public:
+    druid_bot() : CreatureScript("druid_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new bot_druid_ai(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct bot_druid_ai : public bot_minion_ai
+    {
+        bot_druid_ai(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_DRUID;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_DRUID) != SPELL_CAST_OK)
+                return false;
+
+            m_botSpellInfo = sSpellMgr->GetSpellInfo(spellId);
+            if (me->GetShapeshiftForm() == FORM_NONE && swiftness && m_botSpellInfo->CalcCastTime() > 0)
+            {
+                DoCast(victim, spellId, true);
+                me->RemoveAurasDueToSpell(NATURES_SWIFTNESS_1, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                me->RemoveAurasDueToSpell(CRIT_50, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                swiftness = false;
+                return true;
+            }
+            if (spellId == GetSpell(BEAR_FORM_1) || GetSpell(spellId == CAT_FORM_1))
+            {
+                //me->ModifyPower(POWER_MANA, - int32(m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask())));
+                if (me->GetVictim())
+                    GetInPosition(true);
+            }
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result &&
+                spellId != MANAPOTION && spellId != WARSTOMP_1 &&
+                me->HasAura(OMEN_OF_CLARITY_BUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                clearcast = true;
+                power = me->getPowerType();
+            }
+            return result;
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { removeFeralForm(true, false); bot_minion_ai::JustDied(u); }
+
+        uint8 GetBotStance() const
+        {
+            return Form;
+        }
+
+        void warstomp(uint32 diff)
+        {
+            if (me->getRace() != RACE_TAUREN) return;
+            if (!IsSpellReady(WARSTOMP_1, diff, false)) return;
+            if (me->GetShapeshiftForm() != FORM_NONE)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (b_attackers.empty())
+            {
+                Unit* u = me->SelectNearestTarget(5);
+                if (u && u->IsInCombat() && u->isTargetableForAttack())
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        return;
+                }
+            }
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter) || (*iter)->isDead()) continue;
+                if (!(*iter)->isTargetableForAttack()) continue;
+                if (me->GetDistance((*iter)) <= 5)
+                {
+                    if (doCast(me, WARSTOMP_1))
+                        return;
+                }
+            }
+        }
+
+        bool DamagePossible()
+        {
+            return true;
+            //return (GetManaPCT(me) < 30 || GetHealthPCT(master) < 50);
+            /*if (GetHealthPCT(master) < 75 || GetHealthPCT(me) < 75) return false;
+
+            if (Group* pGroup = master->GetGroup())
+            {
+                uint8 LHPcount = 0;
+                uint8 DIScount = 0;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || tPlayer->isDead()) continue;
+                    if (me->GetExactDist(tPlayer) > 30) continue;
+                    if (tPlayer->GetHealth()*100 / tPlayer->GetMaxHealth() < 75)
+                        ++LHPcount;
+                    Unit::AuraApplicationMap const& auras = tPlayer->GetAppliedAuras();
+                    for (Unit::AuraApplicationMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                        if (itr->second->GetBase()->GetSpellInfo()->Dispel == DISPEL_POISON)
+                            ++DIScount;
+                }
+                uint8 members = master->GetGroup()->GetMembersCount();
+
+                if (members > 10)
+                {
+                    if (LHPcount > 1 || DIScount > 2) return false;
+                }
+                if (members > 4)
+                {
+                    if (LHPcount > 0 || DIScount > 1) return false;
+                }
+                if (members < 5)
+                {
+                    if (LHPcount > 0 || DIScount > 0) return false;
+                }
+            }//endif unitlist
+
+            Unit* u = master->GetVictim();
+            if (master->getAttackers().size() > 4 ||
+              (!master->getAttackers().empty() &&
+                u != NULL && u->GetHealth() > me->GetMaxHealth()*17))
+                return false;
+
+            return true;*/
+        }
+
+        void removeFeralForm(bool force = false, bool /*init*/ = true, uint32 diff = 0)
+        {
+            if (!force && formtimer > diff)
+                return;
+
+            ShapeshiftForm form = me->GetShapeshiftForm();
+            if (form != FORM_NONE)
+            {
+                switch (form)
+                {
+                    case FORM_DIREBEAR:
+                    case FORM_BEAR:
+                        me->RemoveAurasDueToSpell(GetSpell(BEAR_FORM_1));
+                        break;
+                    case FORM_CAT:
+                        me->RemoveAurasDueToSpell(GetSpell(CAT_FORM_1));
+                        me->RemoveAurasDueToSpell(ENERGIZE);
+                        break;
+                    default:
+                        break;
+                }
+
+                setStats(BOT_CLASS_DRUID);
+            }
+            else if (Form != BOT_STANCE_NONE)
+                Form = BOT_STANCE_NONE;
+        }
+
+        bool IsMelee() const
+        {
+            if (GetBotStance() == DRUID_BEAR_FORM || GetBotStance() == DRUID_CAT_FORM)
+                return true;
+
+            return bot_ai::IsMelee();
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void doBearActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_RAGE) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_BEAR_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_BEAR_1)))
+                return;
+
+            if (IsSpellReady(SWIPE_1, diff) && HasRole(BOT_ROLE_DPS) && rage >= 150 && Rand() < 75 &&
+                doCast(opponent, GetSpell(SWIPE_1)))
+                return;
+
+        }//end doBearActions
+
+        void doCatActions(uint32 diff)
+        {
+            if (me->getPowerType() != POWER_ENERGY) return;
+
+            if (GetHealthPCT(me) < 75)
+                if (HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            opponent = me->GetVictim();
+            if (opponent)
+                StartAttack(opponent, true);
+            else
+                return;
+
+            uint32 energy = me->GetPower(POWER_ENERGY);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //range check (melee) to prevent fake casts
+            if (me->GetDistance(opponent) > 5) return;
+
+            if (IsSpellReady(MANGLE_CAT_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 35 &&
+                doCast(opponent, GetSpell(MANGLE_CAT_1)))
+                return;
+            if (IsSpellReady(RAKE_1, diff) && energy > 40 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RAKE_1)))
+                return;
+            if (IsSpellReady(SHRED_1, diff) && energy > 60 && HasRole(BOT_ROLE_DPS) && !opponent->HasInArc(M_PI, me) && Rand() < 50 &&
+                doCast(opponent, GetSpell(SHRED_1)))
+                return;
+            if (IsSpellReady(RIP_1, diff) && energy > 30 && HasRole(BOT_ROLE_DPS) && Rand() < 30 &&
+                doCast(opponent, GetSpell(RIP_1)))
+                return;
+            if (IsSpellReady(CLAW_1, diff) && energy > 45 && HasRole(BOT_ROLE_DPS) && Rand() < 80 &&
+                doCast(opponent, GetSpell(CLAW_1)))
+                return;
+        }//end doCatActions
+
+        void doBalanceActions(uint32 diff)
+        {
+            removeFeralForm(true, true);
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //range check to prevent fake casts
+            if (me->GetExactDist(opponent) > 30 || !DamagePossible()) return;
+
+            if (IsSpellReady(HURRICANE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 35)
+            {
+                Unit* target = FindAOETarget(30, true);
+                if (target && doCast(target, GetSpell(HURRICANE_1)))
+                    return;
+                SetSpellCooldown(HURRICANE_1, 2000); //fail
+            }
+            if (uint32 FAERIE_FIRE = GetSpell(FAERIE_FIRE_1))
+            {
+                if (GC_Timer <= diff &&
+                    opponent->getAttackers().size() > 1 &&//check if faerie fire is not useless 50/50
+                    Rand() < 20 && !HasAuraName(opponent, FAERIE_FIRE_1))
+                {
+                    if (doCast(opponent, FAERIE_FIRE))
+                        return;
+                }
+            }
+            if (IsSpellReady(MOONFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 20 &&
+                !HasAuraName(opponent, MOONFIRE_1, me->GetGUID()))
+            {
+                if (doCast(opponent, GetSpell(MOONFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(STARFIRE_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(STARFIRE_1)))
+                    return;
+            }
+            if (IsSpellReady(WRATH_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                if (doCast(opponent, GetSpell(WRATH_1)))
+                    return;
+            }
+        }
+
+        bool MassGroupHeal(Player* gPlayer, uint32 diff)
+        {
+            if (!gPlayer || GC_Timer > diff || IAmFree()) return false;
+            if (IsCasting()) return false; // if I'm already casting
+            bool tranq = IsSpellReady(TRANQUILITY_1, diff, false);
+            bool growt = IsSpellReady(WILD_GROWTH_1, diff, false);
+            if (!tranq && !growt) return false;
+            if (Rand() > 30) return false;
+            Group* pGroup = gPlayer->GetGroup();
+            if (!pGroup) return false;
+            uint8 LHPcount = 0;
+            uint8 pct = 100;
+            Unit* healTarget = NULL;
+            for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (tPlayer->isDead() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 39) continue;
+                if (GetHealthPCT(tPlayer) < 80)
+                {
+                    if (GetHealthPCT(tPlayer) < pct)
+                    {
+                        pct = GetHealthPCT(tPlayer);
+                        healTarget = tPlayer;
+                    }
+                    ++LHPcount;
+                    if (LHPcount > 2) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->GetExactDist(me) < 40 && GetHealthPCT(bot) < 80)
+                        {
+                            if (GetHealthPCT(bot) < pct)
+                            {
+                                pct = GetHealthPCT(bot);
+                                healTarget = bot;
+                            }
+                            ++LHPcount;
+                            if (LHPcount > 2) break;
+                        }
+                    }
+                }
+            }
+            if (LHPcount > 2 && tranq &&
+                doCast(me, GetSpell(TRANQUILITY_1)))
+                return true;
+            if (LHPcount > 0 && growt && healTarget &&
+                doCast(healTarget, GetSpell(WILD_GROWTH_1)))
+                return true;
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+
+            if (me->getPowerType() == POWER_RAGE)
+            {
+                rage = me->GetPower(POWER_RAGE);
+                if (ragetimer2 <= diff)
+                {
+                    if (me->IsInCombat() && me->getLevel() >= 30)
+                    {
+                        if (rage < 990)
+                            me->SetPower(POWER_RAGE, rage + uint32(10.f*rageIncomeMult));//1 rage per 2 sec
+                        else
+                            me->SetPower(POWER_RAGE, 1000);
+                    }
+                    ragetimer2 = 2000;
+                }
+                if (ragetimer <= diff)
+                {
+                    if (!me->IsInCombat())
+                    {
+                        if (rage > 10.f*rageLossMult)
+                            me->SetPower(POWER_RAGE, rage - uint32(10.f*rageLossMult)); //-1 rage per 1.5 sec
+                        else
+                            me->SetPower(POWER_RAGE, 0);
+                    }
+                    ragetimer = 1500;
+                    if (rage > 1000) me->SetPower(POWER_RAGE, 1000);
+                    if (rage < 10) me->SetPower(POWER_RAGE, 0);
+                }
+            }
+            if (clearcast && me->HasAura(OMEN_OF_CLARITY_BUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(power, cost);
+                me->RemoveAurasDueToSpell(OMEN_OF_CLARITY_BUFF, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+            warstomp(diff);
+
+            if (Potion_cd <= diff && me->getPowerType() == POWER_MANA && GetManaPCT(me) < 20)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Heal master
+            if (GetHealthPCT(master) < 85)
+                HealTarget(master, GetHealthPCT(master), diff);
+            //Innervate
+            doInnervate(diff);
+
+            MassGroupHeal(master, diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                CheckBattleRez(diff);
+            BuffAndHealGroup(master, diff);
+            //CureTarget(master, GetSpell(CURE_POISON_1), diff);
+            CureGroup(master, GetSpell(CURE_POISON_1), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_DRUID))
+                return;
+
+            //debug
+            opponent = me->GetVictim();
+
+            if (GetHealthPCT(me) < 75)
+            {
+                HealTarget(me, GetHealthPCT(me), diff);
+                return;
+            }
+
+            if (IsCasting())
+                return; //Casting heal or something
+
+            CheckRoots(diff);
+
+            if (DamagePossible() && opponent != NULL)
+            {
+                Unit* u = opponent->GetVictim();
+                //if the target is attacking us, we want to go bear
+                if (GetSpell(BEAR_FORM_1) && !CCed(opponent) &&
+                    ((u == me || (IsTank() && IsInBotParty(u))) ||
+                    (!me->getAttackers().empty() && (*me->getAttackers().begin()) == opponent && opponent->GetMaxHealth() > me->GetMaxHealth()*2)))
+                {
+                    //if we don't have bear yet
+                    if (me->GetShapeshiftForm() != FORM_DIREBEAR &&
+                        me->GetShapeshiftForm() != FORM_BEAR &&
+                        formtimer <= diff &&
+                        doCast(me, GetSpell(BEAR_FORM_1)))
+                    {
+                        formtimer = 1500;
+                    }
+                    if (me->GetShapeshiftForm() == FORM_DIREBEAR ||
+                        me->GetShapeshiftForm() == FORM_BEAR)
+                        doBearActions(diff);
+                }
+                else
+                if (GetSpell(CAT_FORM_1) && master->GetVictim() != opponent && u &&
+                    IsTank(u) && u != me &&
+                    opponent->GetMaxHealth() < u->GetMaxHealth()*3)
+                {
+                    //if we don't have cat yet
+                    if (me->GetShapeshiftForm() != FORM_CAT && formtimer <= diff)
+                    {
+                        if (doCast(me, GetSpell(CAT_FORM_1)))
+                        {
+                            formtimer = 1500;
+                        }
+                    }
+                    if (me->GetShapeshiftForm() == FORM_CAT)
+                        doCatActions(diff);
+                }
+                else if (!IsTank())
+                    doBalanceActions(diff);
+            }
+            else if (!IsTank())
+                doBalanceActions(diff);
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (hp > 95) return false;
+            if (!target || target->isDead()) return false;
+            if (IsTank() && hp > 35) return false;
+            if (hp > 50 && me->GetShapeshiftForm() != FORM_NONE) return false; //do not waste heal if in feral or so
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid() - 50*me->GetShapeshiftForm()) return false;
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (IsSpellReady(NATURES_SWIFTNESS_1, diff, false) &&
+                (hp < 15 || (hp < 35 && target->getAttackers().size() > 2)) &&
+                (target->IsInCombat() || !target->getAttackers().empty()))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(me, GetSpell(NATURES_SWIFTNESS_1)) && RefreshAura(CRIT_50, 2))
+                {
+                    swiftness = true;
+                    if (doCast(target, GetSpell(HEALING_TOUCH_1), true))
+                        Heal_Timer = 3000;
+                    return true;
+                }
+            }
+            if (IsSpellReady(SWIFTMEND_1, diff, false, 3000) &&
+                (hp < 25 || GetLostHP(target) > 5000) &&
+                (HasAuraName(target, REGROWTH_1) || HasAuraName(target, REJUVENATION_1)))
+            {
+                if (doCast(target, GetSpell(SWIFTMEND_1)))
+                {
+                    if (GetHealthPCT(target) > 75)
+                        return true;
+                    else if (!target->getAttackers().empty())
+                    {
+                        if (doCast(target, GetSpell(REGROWTH_1)))
+                        {
+                            GC_Timer = 300;
+                            return true;
+                        }
+                    }
+                }
+            }
+            if (hp > 35 && (hp < 75 || GetLostHP(target) > 3000) && Heal_Timer <= diff && GetSpell(NOURISH_1))
+            {
+                switch (urand(1,3))
+                {
+                    case 1:
+                    case 2:
+                        if (doCast(target, GetSpell(NOURISH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                    case 3:
+                        if (doCast(target, GetSpell(HEALING_TOUCH_1)))
+                        {
+                            Heal_Timer = 3000;
+                            return true;
+                        }
+                        break;
+                }
+            }
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            bool regrowth = IsSpellReady(REGROWTH_1, diff);
+            if ( ( (hp < 80 || GetLostHP(target) > 3500 || tanking) &&
+                regrowth && !HasAuraName(target, REGROWTH_1, me->GetGUID()) )
+                ||
+                (HasAuraName(target, REGROWTH_1, me->GetGUID()) && HasAuraName(target, REJUVENATION_1, me->GetGUID()) &&
+                (hp < 70 || GetLostHP(target) > 3000) && regrowth))
+            {
+                if (doCast(target, GetSpell(REGROWTH_1)))
+                    return true;
+            }
+            if (GetSpell(REJUVENATION_1) && GC_Timer <= diff && hp > 25 &&
+                (hp < 90 || GetLostHP(target) > 2000 || tanking) &&
+                !HasAuraName(target, REJUVENATION_1, me->GetGUID()))
+            {
+                if (doCast(target, GetSpell(REJUVENATION_1)))
+                {
+                    if (!target->getAttackers().empty() && (hp < 75 || GetLostHP(target) > 4000))
+                        if (IsSpellReady(SWIFTMEND_1, diff, false) && doCast(target, GetSpell(SWIFTMEND_1)))
+                        {}
+                    GC_Timer = 500;
+                    return true;
+                }
+            }
+            if (IsSpellReady(LIFEBLOOM_1, diff) &&
+                ((hp < 85 && hp > 40) || (hp > 70 && tanking) ||
+                (hp < 70 && hp > 25 && HasAuraName(target, REGROWTH_1) && HasAuraName(target, REJUVENATION_1)) ||
+                (GetLostHP(target) > 1500 && hp > 35)))
+            {
+                Aura* bloom = target->GetAura(GetSpell(LIFEBLOOM_1), me->GetGUID());
+                if ((!bloom || bloom->GetStackAmount() < 3) && doCast(target, GetSpell(LIFEBLOOM_1)))
+                    return true;
+            }
+            if (hp > 30 && (hp < 70 || GetLostHP(target) > 3000) && Heal_Timer <= diff &&
+                doCast(target, GetSpell(HEALING_TOUCH_1)))
+            {
+                Heal_Timer = 3000;
+                return true;
+            }
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (target && target->IsAlive() && me->GetExactDist(target) < 30)
+            {
+                if (uint32 MARK_OF_THE_WILD = GetSpell(MARK_OF_THE_WILD_1))
+                    if (!HasAuraName(target, MARK_OF_THE_WILD_1))
+                        if (doCast(target, MARK_OF_THE_WILD))
+                            return true;
+                if (uint32 THORNS = GetSpell(THORNS_1))
+                    if (!HasAuraName(target, THORNS_1))
+                        if (doCast(target, THORNS))
+                            return true;
+            }
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REVIVE_1), master);
+
+            //if (Feasting()) return;
+
+            //if (BuffTarget(master, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+            //if (BuffTarget(me, diff))
+            //{
+            //    /*GC_Timer = 800;*/
+            //    return;
+            //}
+        }
+
+        void doInnervate(uint32 diff, uint8 minmanaval = 30)
+        {
+            if (!IsSpellReady(INNERVATE_1, diff) || Rand() > 15)
+                return;
+            if (me->GetShapeshiftForm() != FORM_NONE && (IsTank() || me->getAttackers().size() > 3))
+                return;
+
+            uint32 INNERVATE = GetSpell(INNERVATE_1);
+            Unit* iTarget = NULL;
+
+            if (master->IsInCombat() && master->getPowerType() == POWER_MANA &&
+                GetManaPCT(master) < 20 && !master->HasAura(INNERVATE))
+                iTarget = master;
+            else if (me->IsInCombat() && me->getPowerType() == POWER_MANA &&
+                GetManaPCT(me) < 20 && !me->HasAura(INNERVATE))
+                iTarget = me;
+
+            if (!IAmFree())
+            {
+                Group* group = master->GetGroup();
+                if (!iTarget && !group) //first check master's bots
+                {
+                    BotMap const* map = master->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        Creature* bot = itr->second;
+                        if (!bot || !bot->IsInCombat() || bot->isDead()) continue;
+                        if (me->GetExactDist(bot) > 30) continue;
+                        if (bot->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                        {
+                            iTarget = bot;
+                            break;
+                        }
+                    }
+                }
+                if (!iTarget && group) //cycle through player members...
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->IsInWorld() || !tPlayer->IsInCombat() || tPlayer->isDead()) continue;
+                        if (me->GetExactDist(tPlayer) > 30) continue;
+                        if (tPlayer->getPowerType() != POWER_MANA) continue;
+                        if (GetManaPCT(tPlayer) < minmanaval && !tPlayer->HasAura(INNERVATE))
+                        {
+                            iTarget = tPlayer;
+                            break;
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+                if (!iTarget && group) //... and their bots.
+                {
+                    for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (tPlayer == NULL || !tPlayer->HaveBot()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || bot->isDead()) continue;
+                            if (me->GetExactDist(bot) > 30) continue;
+                            if (bot->getPowerType() != POWER_MANA) continue;
+                            if (GetManaPCT(bot) < minmanaval && !bot->HasAura(INNERVATE))
+                            {
+                                iTarget = bot;
+                                break;
+                            }
+                        }
+                        if (iTarget)
+                            break;
+                    }
+                }
+            }
+
+            if (iTarget && doCast(iTarget, INNERVATE))
+            {
+                if (iTarget->GetTypeId() == TYPEID_PLAYER)
+                    BotWhisper("Innervate on You!", iTarget->ToPlayer());
+                else if (!IAmFree())
+                {
+                    std::ostringstream msg;
+                    msg << "Innervate on " << (iTarget == me ? "myself" : iTarget->GetName()) << '!';
+                    BotWhisper(msg.str().c_str(), master);
+                }
+
+                return;
+            }
+
+            SetSpellCooldown(INNERVATE_1, 3000); //fail
+        }
+
+        void CheckRoots(uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 35) return;
+            if (me->GetShapeshiftForm() != FORM_NONE) return;
+            uint32 ENTANGLING_ROOTS = GetSpell(ENTANGLING_ROOTS_1);
+            if (!ENTANGLING_ROOTS) return;
+            if (FindAffectedTarget(ENTANGLING_ROOTS, me->GetGUID(), 60)) return;
+            if (Unit* target = FindRootTarget(30, ENTANGLING_ROOTS))
+                if (doCast(target, ENTANGLING_ROOTS))
+                    return;
+        }
+
+        void CheckBattleRez(uint32 diff)
+        {
+            if (!IsSpellReady(REBIRTH_1, diff, false) || IAmFree() || me->IsMounted() || IsCasting() || Rand() > 10) return;
+
+            Group* gr = master->GetGroup();
+            if (!gr)
+            {
+                Unit* target = master;
+                if (master->IsAlive()) return;
+                if (master->isResurrectRequested()) return; //ressurected
+                if (master->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)master->GetCorpse();
+                if (!target || !target->IsInWorld())
+                    return;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(master->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                    BotWhisper("Rezzing You", master);
+
+                return;
+            }
+            for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                Unit* target = tPlayer;
+                if (!tPlayer || tPlayer->IsAlive()) continue;
+                if (tPlayer->isResurrectRequested()) continue; //ressurected
+                if (tPlayer->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_GHOST))
+                    target = (Unit*)tPlayer->GetCorpse();
+                if (!target || !target->IsInWorld()) continue;
+                if (master->GetMap() != target->FindMap()) continue;
+                if (me->GetExactDist(target) > 30)
+                {
+                    me->GetMotionMaster()->MovePoint(target->GetMapId(), *target);
+                    SetSpellCooldown(REBIRTH_1, 1500);
+                    return;
+                }
+                else if (!target->IsWithinLOSInMap(me))
+                    me->Relocate(*target);
+
+                if (doCast(target, GetSpell(REBIRTH_1))) //rezzing
+                {
+                    BotWhisper("Rezzing You", tPlayer);
+                    return;
+                }
+            }
+        }
+
+        void setStats(uint8 form)
+        {
+            switch (form)
+            {
+                case DRUID_BEAR_FORM:
+                    Form = DRUID_BEAR_FORM;
+                    break;
+                case DRUID_CAT_FORM:
+                    Form = DRUID_CAT_FORM;
+                    RefreshAura(ENERGIZE, me->getLevel()/40);
+                    break;
+                case BOT_CLASS_DRUID:
+                    Form = BOT_STANCE_NONE;
+                    SetShouldUpdateStats();
+                    me->setPowerType(POWER_MANA);
+                    me->RemoveMovementImpairingAuras();
+                    break;
+                default:
+                    return;
+            }
+
+            SetStats(false);
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Primal Fury (white attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+                if (lvl >= 25 && GetBotStance() == DRUID_BEAR_FORM)
+                    me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+                //Predatory Instincts (part 1): 10% additional crit damage bonus for melee attacks in Cat form
+                if (lvl >= 45 && GetBotStance() == DRUID_CAT_FORM)
+                    pctbonus += 0.05f;
+            }
+
+            //Naturalist: 10% bonus damage for all melee attacks
+            if (lvl >= 15)
+                pctbonus += 0.1f;
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Rend and Tear (part 2): 25% additional critical chance on bleeding targets for Ferocious Bite
+                if (lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) && spellId == GetSpell(FEROCIOUS_BITE_1))
+                    aftercrit += 25.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                ////Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                //if (lvl >= 21)
+                //    pctbonus += 0.25f;
+            }
+
+            //Feral Instinct: 30% bonus damage for Swipe (Bear)
+            if (lvl >= 15 && spellId == GetSpell(SWIPE_1))
+                pctbonus += 0.3f;
+            //Savage Fury: 20% bonus damage for Claw, Rake, Mangle (Cat), Mangle (Bear) and Maul
+            if (lvl >= 15 &&
+                (spellId == GetSpell(CLAW_1) ||
+                spellId == GetSpell(RAKE_1) ||
+                spellId == GetSpell(MANGLE_CAT_1) ||
+                spellId == GetSpell(MANGLE_BEAR_1) ||
+                spellId == GetSpell(MAUL_1)))
+                pctbonus += 0.2f;
+            //Rend and Tear: 20% bonus damage on bleeding targets for Maul and Shred
+            if (lvl >= 55 && damageinfo.target && damageinfo.target->HasAuraState(AURA_STATE_BLEEDING) &&
+                (spellId == GetSpell(MAUL_1) || spellId == GetSpell(SHRED_1)))
+                pctbonus += 0.2f;
+            //Naturalist: 10% bonus damage for all melee attacks
+            if (lvl >= 15)
+                pctbonus += 0.1f;
+
+            //Primal Fury (yellow attacks): 100% to gain 5 rage at crit in (Dire) Bear Form
+            if (lvl >= 25 && crit && GetBotStance() == DRUID_BEAR_FORM)
+                me->CastSpell(me, PRIMAL_FURY_EFFECT_ENERGIZE, true);
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Improved Moonfire
+                if (lvl >= 15 && spellId == GetSpell(MOONFIRE_1))
+                    aftercrit += 10.f;
+                //Nature's Majesty: 4% additional critical chance for Wrath, Starfire and Starfall
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(WRATH_1) ||
+                    spellId == GetSpell(STARFIRE_1)/* ||
+                    spellId == GetSpell(STARFALL_1)*/))
+                    aftercrit += 4.f;
+                //Eclipse (Lunar): 40% additional critical chance for Starfire
+                if (lvl >= 50 && spellId == GetSpell(STARFIRE_1) && me->HasAura(ECLIPSE_LUNAR_BUFF))
+                    aftercrit += 40.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Vengeance: 100% additional crit damage bonus for Starfire, Starfall, Moonfire and Wrath
+                if (lvl >= 25 &&
+                    (spellId == GetSpell(STARFIRE_1) ||
+                    //spellId == GetSpell(STARFALL_1) ||
+                    spellId == GetSpell(MOONFIRE_1) ||
+                    spellId == GetSpell(WRATH_1)))
+                    pctbonus += 0.333f;
+            }
+            //Brambles: 75% bonus damage for Throns and Entangling Roots
+            if (lvl >= 20 &&
+                (spellId == GetSpell(THORNS_1) ||
+                spellId == GetSpell(ENTANGLING_ROOTS_1)))
+                pctbonus += 0.75f;
+            //Moonfury: 10% bonus damage for Starfire, Moonfire and Wrath
+            if (lvl >= 35 &&
+                (spellId == GetSpell(STARFIRE_1) ||
+                spellId == GetSpell(MOONFIRE_1) ||
+                spellId == GetSpell(WRATH_1)))
+                pctbonus += 0.1f;
+            //Wrath of Cenarius: 20%/10% Increased spellpower bonus for Starfire/Wrath
+            if (lvl >= 45)
+            {
+                if (spellId == GetSpell(STARFIRE_1))
+                    fdamage += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+                if (spellId == GetSpell(WRATH_1))
+                    fdamage += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, SPELL_DIRECT_DAMAGE) * 1.88f * me->CalculateLevelPenalty(spellInfo);
+            }
+            //Eclipse (Solar): 40% bonus damage for Wrath
+            if (lvl >= 50 && spellId == GetSpell(WRATH_1) && me->HasAura(ECLIPSE_SOLAR_BUFF))
+                pctbonus += 0.4f;
+            //Gale Winds: 30% bonus damage for Hurricane (no Typhon support yet)
+            if (lvl >= 50 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(HURRICANE_DAMAGE_1)))
+                pctbonus += 0.3f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Improved Rejuvenation: 15% bonus healing for Rejuvenation
+            if (lvl >= 25 && spellId == GetSpell(REJUVENATION_1))
+                pctbonus += 0.15f;
+            //Gift of Nature: 10% bonus healing for all spells
+            if (lvl >= 30)
+                pctbonus += 0.1f;
+            //Empowered Touch: 40% bonus (from spellpower) for Healing Touch and 20% bonus (from spellpower) for Nourish
+            if (lvl >= 35)
+            {
+                if (spellId == GetSpell(HEALING_TOUCH_1))
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(NOURISH_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Empowered Rejuvenation: 20% bonus healing for healing over time effects (20% increase in our case)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(TRANQUILITY_1) ||
+                spellId == GetSpell(REJUVENATION_1) ||
+                spellId == GetSpell(REGROWTH_1) ||
+                spellId == GetSpell(LIFEBLOOM_1) ||
+                spellId == GetSpell(WILD_GROWTH_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(TRANQUILITY_HEAL_1))))
+                pctbonus += 0.2f;
+            //Empowered Touch: 15% bonus (from spirit) for healing spells (taking in consideration increased spirit (Living Spirit: 15%))
+            if (lvl >= 50)
+                flat_mod += me->GetTotalStatValue(STAT_SPIRIT) * 0.15f * 1.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask /*schoolMask*/, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Nature's bounty: 25% additional critical chance for Regrowth
+            if (lvl >= 35 && spellId == GetSpell(REGROWTH_1))
+                aftercrit += 25.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Nature's Splendor: Increased duraion for
+            //Moonfire (3 sec), Rejuvenation (3 sec, let 6), Regrowth (6 sec, let 9),
+            //Insect Swarm (2 sec) and Lifebloom (2 sec, let 4)
+            if (spellId == GetSpell(MOONFIRE_1) || spellId == GetSpell(REJUVENATION_1) ||
+                spellId == GetSpell(REGROWTH_1)/* || spellId == GetSpell(INSECT_SWARM_1)*/ ||
+                spellId == GetSpell(LIFEBLOOM_1))
+            {
+                if (me->getLevel() >= 20)
+                {
+                    if (Aura* aur = target->GetAura(spellId))
+                    {
+                        uint32 dur = aur->GetDuration();
+
+                        switch (sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id)
+                        {
+                            case MOONFIRE_1:
+                                dur += 3000;
+                                break;
+                            case REJUVENATION_1:
+                                dur += 6000;
+                                break;
+                            case REGROWTH_1:
+                                dur += 9000;
+                                break;
+                            //case INSECT_SWARM_1:
+                            //    dur += 3000;
+                            //    break;
+                            case LIFEBLOOM_1:
+                                dur += 4000;
+                                break;
+                            default:
+                                break;
+                        }
+
+                        aur->SetDuration(dur);
+                        aur->SetMaxDuration(dur);
+                    }
+                }
+            }
+
+            if (spellId == GetSpell(THORNS_1))
+            {
+                //30 min duration for Thorns
+                if (Aura* thorn = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 30 * MINUTE * IN_MILLISECONDS;
+                    thorn->SetDuration(dur);
+                    thorn->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(MARK_OF_THE_WILD_1))
+            {
+                //1 hour duration for Mark of the Wild
+                if (Aura* mark = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = 1 * HOUR * IN_MILLISECONDS;
+                    mark->SetDuration(dur);
+                    mark->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Eclipse (helper): cooldown
+            if (spellId == ECLIPSE_SOLAR_BUFF || spellId == ECLIPSE_LUNAR_BUFF)
+                SetSpellCooldown(spellId, 30000);
+            //Forms helper
+            if (spellId == GetSpell(CAT_FORM_1) || spellId == GetSpell(BEAR_FORM_1))
+            {
+                if (spellId == GetSpell(BEAR_FORM_1))
+                    setStats(DRUID_BEAR_FORM);
+                if (spellId == GetSpell(CAT_FORM_1))
+                    setStats(DRUID_CAT_FORM);
+
+                me->CastSpell(me, LEADER_OF_THE_PACK_BUFF, true);
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            formtimer = 0;
+            Form = BOT_STANCE_NONE;
+
+            clearcast = false;
+            swiftness = false;
+
+            power = POWER_MANA;
+
+            rage = 0;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+
+            ragetimer = 0;
+            ragetimer2 = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (formtimer > diff)                   formtimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+
+            InitSpellMap(WARSTOMP_1, true);
+
+            InitSpellMap(MARK_OF_THE_WILD_1);
+            InitSpellMap(THORNS_1);
+            InitSpellMap(HEALING_TOUCH_1);
+            InitSpellMap(REGROWTH_1);
+            InitSpellMap(REJUVENATION_1);
+            InitSpellMap(LIFEBLOOM_1);
+            InitSpellMap(NOURISH_1);
+     /*tal*/lvl >= 60 ? InitSpellMap(WILD_GROWTH_1) : RemoveSpell(WILD_GROWTH_1);
+     /*tal*/lvl >= 40 ? InitSpellMap(SWIFTMEND_1) : RemoveSpell(SWIFTMEND_1);
+            InitSpellMap(TRANQUILITY_1);
+            InitSpellMap(REVIVE_1);
+            InitSpellMap(REBIRTH_1);
+            InitSpellMap(BEAR_FORM_1);
+            InitSpellMap(SWIPE_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_BEAR_1) : RemoveSpell(MANGLE_BEAR_1);
+            InitSpellMap(BASH_1);
+            InitSpellMap(CAT_FORM_1);
+            InitSpellMap(CLAW_1);
+            InitSpellMap(RAKE_1);
+            InitSpellMap(SHRED_1);
+            InitSpellMap(RIP_1);
+     /*tal*/lvl >= 50 ? InitSpellMap(MANGLE_CAT_1) : RemoveSpell(MANGLE_CAT_1);
+            InitSpellMap(MOONFIRE_1);
+            InitSpellMap(STARFIRE_1);
+            InitSpellMap(WRATH_1);
+            InitSpellMap(HURRICANE_1);
+            InitSpellMap(FAERIE_FIRE_1);
+            InitSpellMap(CURE_POISON_1);
+            InitSpellMap(INNERVATE_1);
+            InitSpellMap(ENTANGLING_ROOTS_1);
+     /*tal*/lvl >= 30 ? InitSpellMap(NATURES_SWIFTNESS_1) : RemoveSpell(NATURES_SWIFTNESS_1);
+
+ /*SPECIAL*/InitSpellMap(ECLIPSE_SOLAR_BUFF, true);
+ /*SPECIAL*/InitSpellMap(ECLIPSE_LUNAR_BUFF, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //RefreshAura(SPELLDMG2, level >= 78 ? 3 : level >= 65 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION3, level >= 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION2, level >= 43 && level < 45 ? 1 : 0);
+            RefreshAura(NATURAL_PERFECTION1, level >= 41 && level < 43 ? 1 : 0);
+            RefreshAura(LIVING_SEED3, level >= 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(LIVING_SEED1, level >= 46 && level < 48 ? 1 : 0);
+            RefreshAura(REVITALIZE3, level >= 55 ? 3 : 0);
+            RefreshAura(REVITALIZE2, level >= 53 && level < 55 ? 2 : 0);
+            RefreshAura(REVITALIZE1, level >= 51 && level < 53 ? 2 : 0);
+            RefreshAura(GIFT_OF_THE_EARTHMOTHER, level >= 55 ? 1 : 0);
+            RefreshAura(OMEN_OF_CLARITY, level >= 70 ? 3 : level >= 40 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(GLYPH_SWIFTMEND, level >= 45 ? 1 : 0);
+            RefreshAura(GLYPH_INNERVATE, level >= 40 ? 1 : 0);
+            RefreshAura(NATURESGRACE, level >= 20 ? 1 : 0);
+            RefreshAura(ECLIPSE, level >= 50 ? 1 : 0);
+            RefreshAura(EARTH_AND_MOON, level >= 55 ? 1 : 0);
+            RefreshAura(SURVIVAL_OF_THE_FITTEST, level >= 55 ? 1 : 0);
+            RefreshAura(HEART_OF_THE_WILD, level >= 35 ? 1 : 0);
+            RefreshAura(NATURAL_REACTION, level >= 35 ? 1 : 0);
+            RefreshAura(INFECTED_WOUNDS, level >= 45 ? 1 : 0);
+            RefreshAura(FUROR, level >= 10 ? 1 : 0);
+            RefreshAura(T9_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T8_RESTO_P4_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T9_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P2_BONUS, level >= 78 ? 1 : 0);
+            RefreshAura(T10_BALANCE_P4_BONUS, level >= 78 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case MARK_OF_THE_WILD_1:
+                case THORNS_1:
+                case HEALING_TOUCH_1:
+                case REJUVENATION_1:
+                case LIFEBLOOM_1:
+                case REGROWTH_1:
+                case NOURISH_1:
+                case WILD_GROWTH_1:
+                case SWIFTMEND_1:
+                case TRANQUILITY_1:
+                case CURE_POISON_1:
+                case INNERVATE_1:
+                case BEAR_FORM_1:
+                case CAT_FORM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Timers/other
+/*Heal*/uint32 Heal_Timer;
+/*Misc*/uint32 formtimer, ragetimer, ragetimer2;
+/*Form*/uint8 Form;
+/*Chck*/bool clearcast, swiftness;
+/*Misc*/Powers power; uint32 rage;
+/*Misc*/float rageIncomeMult, rageLossMult;
+
+        enum DruidBaseSpells
+        {
+            MARK_OF_THE_WILD_1                  = 1126,
+            THORNS_1                            = 467,
+            HEALING_TOUCH_1                     = 5185,
+            REGROWTH_1                          = 8936,
+            REJUVENATION_1                      = 774,
+            LIFEBLOOM_1                         = 33763,
+            NOURISH_1                           = 50464,
+     /*tal*/WILD_GROWTH_1                       = 48438,
+     /*tal*/SWIFTMEND_1                         = 18562,
+            TRANQUILITY_1                       = 740,
+            REVIVE_1                            = 50769,
+            REBIRTH_1                           = 20484,
+            BEAR_FORM_1                         = 5487,
+            SWIPE_1                             = 779,
+     /*tal*/MANGLE_BEAR_1                       = 33878,
+            BASH_1                              = 5211, //NYI
+            MAUL_1                              = 6807, //NYI
+            CAT_FORM_1                          = 768,
+            CLAW_1                              = 1082,
+            RAKE_1                              = 1822,
+            SHRED_1                             = 5221,
+            RIP_1                               = 1079,
+     /*tal*/MANGLE_CAT_1                        = 33876,
+            FEROCIOUS_BITE_1                    = 22568, //NYI
+            MOONFIRE_1                          = 8921,
+            STARFIRE_1                          = 2912,
+            WRATH_1                             = 5176,
+            HURRICANE_1                         = 16914,
+            FAERIE_FIRE_1                       = 770,
+            CURE_POISON_1                       = 8946,
+            INNERVATE_1                         = 29166,
+            ENTANGLING_ROOTS_1                  = 339,
+     /*tal*/NATURES_SWIFTNESS_1                 = 17116,
+            WARSTOMP_1                          = 20549
+        };
+        enum DruidPassives
+        {
+        //Talents
+            OMEN_OF_CLARITY                     = 16864,//clearcast
+            NATURESGRACE                        = 61346,//haste 20% for 3 sec
+            NATURAL_PERFECTION1                 = 33881,
+            NATURAL_PERFECTION2                 = 33882,
+            NATURAL_PERFECTION3                 = 33883,
+            LIVING_SEED1                        = 48496,//rank 1
+            LIVING_SEED2                        = 48499,//rank 2
+            LIVING_SEED3                        = 48500,//rank 3
+            REVITALIZE1                         = 48539,//rank 1
+            REVITALIZE2                         = 48544,//rank 2
+            REVITALIZE3                         = 48545,//rank 3
+            GIFT_OF_THE_EARTHMOTHER             = 51183,//rank 5
+            ECLIPSE                             = 48525,//rank 3
+            EARTH_AND_MOON                      = 48511,//rank 3
+            SURVIVAL_OF_THE_FITTEST             = 33856,//rank 3
+            HEART_OF_THE_WILD                   = 24894,//rank 5
+            FUROR                               = 17061,//rank 5
+            NATURAL_REACTION                    = 57881,//rank 3
+            INFECTED_WOUNDS                     = 48485,//rank 3
+        //Glyphs
+            GLYPH_SWIFTMEND                     = 54824,//no consumption
+            GLYPH_INNERVATE                     = 54832,//self regen
+        //other
+            T9_RESTO_P4_BONUS                   = 67128,//rejuve crits
+            T8_RESTO_P4_BONUS                   = 64760,//rejuve init heal
+            T9_BALANCE_P2_BONUS                 = 67125,//moonfire crits
+            T10_BALANCE_P2_BONUS                = 70718,//omen of doom (15%)
+            T10_BALANCE_P4_BONUS                = 70723,//Languish(DOT)
+            //SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            //SPELLDMG2/*Earth and Moon - druid*/ = 48511,//rank3 6% dam
+            ENERGIZE                            = 27787,//Rogue Armor Energize (chance: +35 energy on hit)
+            CRIT_50                             = 23434 //50% spell crit
+        };
+        enum DruidSpecial
+        {
+            HURRICANE_DAMAGE_1                  = 42231,
+            TRANQUILITY_HEAL_1                  = 44203,
+  /*Talent*/LEADER_OF_THE_PACK_BUFF             = 24932,
+            //NATURESGRACEBUFF                    = 16886,
+            ECLIPSE_SOLAR_BUFF                  = 48517,// from Starfire to Wrath
+            ECLIPSE_LUNAR_BUFF                  = 48518,// from Wrath to Starfire
+            OMEN_OF_CLARITY_BUFF                = 16870,//434 deprecated
+
+            PRIMAL_FURY_EFFECT_ENERGIZE         = 16959 //5 rage
+        };
+    };
+};
+
+void AddSC_druid_bot()
+{
+    new druid_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_hunter_ai.cpp b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
new file mode 100644
index 0000000..8fa05af
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_hunter_ai.cpp
@@ -0,0 +1,1086 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+/*
+Hunter NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 35%
+TODO:
+*/
+class hunter_bot : public CreatureScript
+{
+public:
+    hunter_bot() : CreatureScript("hunter_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new hunter_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct hunter_botAI : public bot_minion_ai
+    {
+        hunter_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_HUNTER;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_HUNTER) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = NULL;
+
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                target = FindCastingTarget(15, 0, false, GetSpell(SCATTER_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(WYVERN_STING_1, diff, true, 10000) && HasRole(BOT_ROLE_DPS) && Rand() < 70)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(WYVERN_STING_1));
+                if (target && doCast(target, GetSpell(WYVERN_STING_1)))
+                    return;
+            }
+            //if (!target && FREEZING_ARROW && Trap_cd <= 10000 && Rand() < 40)
+            //{
+            //    target = FindCastingTarget(40, 0, false, FREEZING_ARROW);
+            //    temptimer = GC_Timer;
+            //    if (target && doCast(target, FREEZING_ARROW))
+            //    {
+            //        Trap_cd = 20000;
+            //        GC_Timer = temptimer;
+            //        return;
+            //    }
+            //}
+            if (!target && IsSpellReady(SCARE_BEAST_1, diff, true, 7500) && Rand() < 35)
+            {
+                target = FindCastingTarget(30, 0, false, GetSpell(SCARE_BEAST_1));
+                if (target && doCast(target, GetSpell(SCARE_BEAST_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!target && IsSpellReady(SILENCING_SHOT_1, diff, false, 7500) && Rand() < 30)
+            {
+                target = FindCastingTarget(35, 5, false, GetSpell(SILENCING_SHOT_1));
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckScatter(uint32 diff)
+        {
+            if (!IsSpellReady(SCATTER_SHOT_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(15))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCATTER_SHOT_1, 1000); //fail
+        }
+
+        void CheckWyvernSting(uint32 diff)
+        {
+            if (!IsSpellReady(WYVERN_STING_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 50)
+                return;
+
+            if (Unit* target = FindStunTarget(35))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(WYVERN_STING_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(WYVERN_STING_1, 1000); //fail
+        }
+
+        void CheckFreezingArrow(uint32 diff)
+        {
+            //Freezing Trap shares cooldown with traps
+            if (!GetSpell(FREEZING_ARROW_1) || Trap_cd > diff || IsCasting() || Rand() > 75)
+                return;
+
+            if (Unit* target = FindStunTarget(40))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FREEZING_ARROW_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 1000; //fail
+        }
+
+        void CheckTraps(uint32 diff)
+        {
+            if (!GetSpell(FROST_TRAP_1) || Trap_cd > diff || IsCasting() || Rand() > 90)
+                return;
+
+            Unit* target = me->GetVictim();
+            if (!(target && me->GetDistance(target) < 6 && me->HasInArc(M_PI, target) &&
+                IsInBotParty(target->GetVictim())))
+                target = NULL;
+            if (!target)
+                target = FindAOETarget(3.f, true);
+
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(FROST_TRAP_1)))
+                {
+                    GC_Timer = temptimer;
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+
+            Trap_cd = 500; //fail
+        }
+
+        void CheckScare(uint32 diff)
+        {
+            if (!IsSpellReady(SCARE_BEAST_1, diff) || IsCasting() || Rand() > 35)
+                return;
+
+            if (Unit* scareTarget = FindFearTarget())
+            {
+                if (doCast(scareTarget, GetSpell(SCARE_BEAST_1), true))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SCARE_BEAST_1, 1500); //fail
+        }
+
+        void CheckAspects(uint32 diff)
+        {
+            if (Aspect_Timer > diff || GC_Timer > diff || IsCasting() || Feasting() || Rand() > 35)
+                return;
+
+            uint32 ASPECT_OF_THE_VIPER = GetSpell(ASPECT_OF_THE_VIPER_1);
+            uint32 ASPECT_OF_THE_PACK = GetSpell(ASPECT_OF_THE_PACK_1);
+            if (!ASPECT_OF_THE_VIPER && !ASPECT_OF_THE_PACK)
+                return;
+
+            uint32 needaspect = 0;
+            uint8 pct = GetManaPCT(me);
+
+            if (ASPECT_OF_THE_VIPER && pct < 25)
+                needaspect = ASPECT_OF_THE_VIPER;
+            else if (ASPECT_OF_THE_PACK && (pct > 70 || !Aspect))
+                needaspect = ASPECT_OF_THE_PACK;
+
+            if (!needaspect || (needaspect == Aspect && HasAuraName(me, needaspect)))
+            {
+                Aspect_Timer = 2000;
+                return;
+            }
+
+            if (Aspect)
+                me->RemoveAurasDueToSpell(Aspect);
+
+            if (doCast(me, needaspect))
+            {
+                Aspect = needaspect;
+                GC_Timer = 800;
+                return;
+            }
+        }
+
+        void doDefend(uint32 diff)
+        {
+            //No GCD abilities
+            if (!IsSpellReady(FEIGN_DEATH_1, diff, false) && !IsSpellReady(DETERRENCE_1, diff, false))
+                return;
+            if (IsTank() || Rand() > 35)
+                return;
+
+            AttackerSet b_attackers = me->getAttackers();
+            bool cast = false;
+
+            if (b_attackers.size() == 1)
+            {
+                if (Creature* cre = (*b_attackers.begin())->ToCreature())
+                {
+                    if (cre->isWorldBoss() || cre->IsDungeonBoss() || cre->GetMaxHealth() > me->GetMaxHealth() * 10)
+                    {
+                        cast = true;
+                        //need feign death
+                        SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), diff + 500));
+                    }
+                }
+            }
+            else
+                cast = (uint8(b_attackers.size()) > (GetHealthPCT(me) > 20 ? 1 : 0));
+
+            if (!cast || b_attackers.empty())
+            {
+                //delay next try
+                SetSpellCooldown(FEIGN_DEATH_1, std::max<uint32>(GetSpellCooldown(FEIGN_DEATH_1), 1000));
+                SetSpellCooldown(DETERRENCE_1, std::max<uint32>(GetSpellCooldown(DETERRENCE_1), 1000));
+                return;
+            }
+
+            if (IsSpellReady(FEIGN_DEATH_1, diff, false) && (*b_attackers.begin())->getAttackers().size() > 1)
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(FEIGN_DEATH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(DETERRENCE_1, diff, false))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DETERRENCE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void CheckAutoShot()
+        {
+            //Auto Shot is always present
+            //if (!AUTO_SHOT)
+            //    return;
+
+            Unit* target = me->GetVictim();
+            if (!target)
+                return;
+
+            if (!HasRole(BOT_ROLE_DPS))
+                return;
+
+            if (IsCasting())
+                return;
+
+            if (Spell* shot = me->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL))
+            {
+                if (shot->GetSpellInfo()->Id != AUTO_SHOT_1)
+                {
+                    ////casting some other autorepeat spell, wtf?
+                    //TC_LOG_ERROR("entities.player", "CheckAutoShot(): Bot %s is casting autorepeatable spell %u (%s) during check!",
+                    //    me->GetName().c_str(), shot->GetSpellInfo()->Id, shot->GetSpellInfo()->SpellName[0]);
+                    return;
+                }
+                else if (shot->m_targets.GetUnitTarget() != target)
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+            }
+
+            float dist = me->GetExactDist(target);
+            if (dist < 5 || dist > 35)
+                return;
+
+            temptimer = GC_Timer;
+            if (doCast(target, AUTO_SHOT_1))
+            {
+                GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckTranquil(uint32 diff)
+        {
+            if (!IsSpellReady(TRANQ_SHOT_1, diff, false) || Rand() > 35) //No GCD
+                return;
+
+            //First check current target
+            Unit* target = me->GetVictim();
+            if (target)
+            {
+                Unit::AuraMap const &auras = target->GetOwnedAuras();
+                for (Unit::AuraMap::const_iterator itr = auras.begin(); itr != auras.end(); ++itr)
+                {
+                    SpellInfo const* spellInfo = itr->second->GetSpellInfo();
+                    if (spellInfo->Dispel != DISPEL_MAGIC && spellInfo->Dispel != DISPEL_ENRAGE) continue;
+                    if (spellInfo->Attributes & (SPELL_ATTR0_PASSIVE | SPELL_ATTR0_HIDDEN_CLIENTSIDE)) continue;
+                    //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                    AuraApplication const* aurApp = itr->second->GetApplicationOfTarget(target->GetGUID());
+                    if (aurApp && aurApp->IsPositive())
+                    {
+                        temptimer = GC_Timer;
+                        //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                        if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+
+            target = FindTranquilTarget();
+            if (target)
+            {
+                temptimer = GC_Timer;
+                //me->InterruptNonMeleeSpells(true, AUTO_SHOT);
+                if (doCast(target, GetSpell(TRANQ_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(TRANQ_SHOT_1, 2000); //fail
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (!IsSpellReady(SILENCING_SHOT_1, diff, false) || IsCasting() || Rand() > 50) //No GCD
+                return;
+
+            Unit* target = me->GetVictim();
+            if (target && target->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+
+                return; //succeed or failed, our hightest priority target casts spell and it must be interrupted above all else
+            }
+
+            target = FindCastingTarget(35, 5);
+            if (target)
+            {
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(SILENCING_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            SetSpellCooldown(SILENCING_SHOT_1, 1000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 40)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            //Deterrence check
+            if (me->HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
+            {
+                if (!me->isMoving())
+                    GetInPosition(true);
+                return;
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            else
+                doDefend(diff);
+
+            CheckAspects(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckTranquil(diff);
+                CheckSilence(diff);
+            }
+
+            if (!CheckAttackTarget(BOT_CLASS_HUNTER))
+            {
+                me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                return;
+            }
+
+            DoRangedAttack(diff);
+        }
+
+        void DoRangedAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            CheckAutoShot();
+            CheckScare(diff);
+            CheckScatter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //special
+            if (IsSpellReady(SCATTER_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist < 15 && Rand() < 60)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SCATTER_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    me->InterruptSpell(CURRENT_AUTOREPEAT_SPELL);
+                    me->AttackStop();
+                    return;
+                }
+            }
+
+            //MELEE SECTION
+            if (!(meleedist > 5))
+            {
+                //TRAPS
+                CheckTraps(diff);
+
+                //RAPTOR STRIKE
+                if (IsSpellReady(RAPTOR_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(RAPTOR_STRIKE_1), true))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                //WING CLIP
+                if (IsSpellReady(WING_CLIP_1, diff) && (!IsTank() || opponent->isMoving()) &&
+                    Rand() < 80 && !opponent->HasAuraWithMechanic(/*(1<<MECHANIC_SNARE)|*/(1<<MECHANIC_ROOT)))
+                {
+                    if (doCast(opponent, GetSpell(WING_CLIP_1)))
+                    {
+                        GC_Timer = 1000;
+                        return;
+                    }
+                }
+                //DISENGAGE
+                if (IsSpellReady(DISENGAGE_1, diff, false) && me->IsInCombat() && !IsTank() &&
+                    !me->getAttackers().empty() && me->HasInArc(M_PI, *me->getAttackers().begin()) && Rand() < 30)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(DISENGAGE_1)))
+                        GC_Timer = temptimer;
+                }
+
+                return; //don't try to do anything else in melee
+            }
+
+            //RANGED SECTION
+
+            //HUNTERS MARK
+            if (IsSpellReady(HUNTERS_MARK_1, diff, false) && Rand() < 25 &&
+                !HasAuraName(opponent, HUNTERS_MARK_1)) //100 yd range so don't check it
+            {
+                //Hunter's Mark has exclusive GCD
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HUNTERS_MARK_1)))
+                {
+                    markTarget = opponent;
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+
+            //FREEZING ARROW
+            CheckFreezingArrow(diff);
+            CheckWyvernSting(diff);
+
+            //attack range check 1
+            if (!(meleedist < 45))
+                return;
+
+            //KILL SHOT //No GCD
+            if (IsSpellReady(KILL_SHOT_1, diff, false) && HasRole(BOT_ROLE_DPS) && GetHealthPCT(opponent) < 20 && Rand() < 95)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KILL_SHOT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            //attack range check 2
+            if (!(meleedist < 35))
+                return;
+
+            //CONCUSSIVE SHOT
+            if (IsSpellReady(CONCUSSIVE_SHOT_1, diff) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CONCUSSIVE_SHOT_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            //DISTRACTING SHOT
+            if (Unit* u = opponent->GetVictim())
+            {
+                if (IsSpellReady(DISTRACTING_SHOT_1, diff, false) && IsTank() && u != me && !CCed(opponent) &&
+                    Rand() < 75 && IsInBotParty(u))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(opponent, GetSpell(DISTRACTING_SHOT_1)))
+                        GC_Timer = temptimer;
+                }
+            }
+            //BLACK ARROW //custom cd condition
+            //Black Arrow shares cooldown with traps, but we'll have it only partially
+            if (IsSpellReady(BLACK_ARROW_1, diff) && Trap_cd <= 10000 && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < 75)
+            {
+                if (doCast(opponent, GetSpell(BLACK_ARROW_1)))
+                {
+                    Trap_cd = 20000;
+                    return;
+                }
+            }
+            //RAPID FIRE
+            if (IsSpellReady(RAPID_FIRE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > me->GetMaxHealth() / 2 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(RAPID_FIRE_1)))
+                    GC_Timer = temptimer;
+            }
+            //EXPLOSIVE SHOT
+            if (IsSpellReady(EXPLOSIVE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS))
+            {
+                if (doCast(opponent, GetSpell(EXPLOSIVE_SHOT_1)))
+                    return;
+
+                SetSpellCooldown(EXPLOSIVE_SHOT_1, 500); //fail
+            }
+            //SCORPID STING //custom cd condition
+            if (uint32 SCORPID_STING = GetSpell(SCORPID_STING_1))
+            {
+                if (GC_Timer <= diff && (ScorpidSting_Timer <= diff || stingTargetGuid != opponent->GetGUID()))
+                {
+                    Aura* sSting = opponent->GetAura(SCORPID_STING);
+                    if (sSting && sSting->GetDuration() > 3000)
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        SetSpellCooldown(SCORPID_STING_1, 2000);
+                    }
+                    else if (Rand() < 40 && doCast(opponent, SCORPID_STING))
+                    {
+                        stingTargetGuid = opponent->GetGUID();
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+            }
+            //CHIMERA SHOT TODO:
+            if (IsSpellReady(CHIMERA_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && stingTargetGuid == opponent->GetGUID() &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(CHIMERA_SHOT_1)))
+                    return;
+            }
+            //MULTI-SHOT
+            if (IsSpellReady(MULTISHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 60)
+            {
+                if (Unit* target = FindSplashTarget(35, opponent))
+                {
+                    if (doCast(target, GetSpell(MULTISHOT_1)))
+                    {
+                        GC_Timer = 800;
+                        return;
+                    }
+                }
+
+                SetSpellCooldown(MULTISHOT_1, 1000); //fail
+            }
+            //VOLLEY
+            if (IsSpellReady(VOLLEY_1, diff) && HasRole(BOT_ROLE_DPS) && !me->isMoving() && Rand() < 25)
+            {
+                if (Unit* target = FindAOETarget(35, true, false))
+                {
+                    if (doCast(target, GetSpell(VOLLEY_1)))
+                        return;
+                }
+
+                SetSpellCooldown(VOLLEY_1, 1000); //fail
+            }
+            //AIMED SHOT
+            if (IsSpellReady(AIMED_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(AIMED_SHOT_1)))
+                    return;
+            }
+            //ARCANE SHOT
+            if (IsSpellReady(ARCANE_SHOT_1, diff) && HasRole(BOT_ROLE_DPS) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(ARCANE_SHOT_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+
+                //Glyph of TrueShot Aura (req lvl 40): 10% additional critical chance for Aimed Shot
+                if (lvl >= 40 && spellId == GetSpell(AIMED_SHOT_1))
+                    aftercrit += 10.f;
+                //Improved Barrage: 12% additional critical chance for Multi-Shot and Aimed Shot
+                if (lvl >= 40 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1)))
+                    aftercrit += 12.f;
+                //Survival Instincts: 4% additional critical chance for Arcane Shot, Steady Shot and Explosive Shot
+                if (lvl >= 15 && (spellId == GetSpell(ARCANE_SHOT_1)/* || spellId == GetSpell(STEADY_SHOT_1)*/ || spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+                    aftercrit += 4.f;
+                //Sniper Training (part 1): 15% additional critical chance for Kill Shot
+                if (lvl >= 50 && spellId == GetSpell(KILL_SHOT_1))
+                    aftercrit += 15.f;
+                //Point of No Escape: 6% additional critical chance on victims of any kind of frost trap (crew this condition)
+                if (lvl >= 50)
+                    aftercrit += 6.f;
+
+                //Savage Strikes: 20% additional critical chance for Raptor Strike, Mongoose Bite and Counterattack
+                if (lvl >= 10 && (spellId == GetSpell(RAPTOR_STRIKE_1)/* || spellId == GetSpell(MONGOOSE_BITE_1) || spellId == GetSpell(COUNTERATTACK_1)*/))
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Mortal Shots: 30% crit damage bonus for all ranged abilities
+                if (lvl >= 15 && attackType == RANGED_ATTACK)
+                    pctbonus += 0.15f;
+                //Marked for Death (part 2): 10% crit damage bonus for Aimed Shot, Arcane Shot, Steady Shot, Kill Shot and Chimera Shot
+                if (lvl >= 55 &&
+                    (spellId == GetSpell(AIMED_SHOT_1) ||
+                    spellId == GetSpell(ARCANE_SHOT_1) ||
+                    //spellId == GetSpell(STEADY_SHOT_1) ||
+                    spellId == GetSpell(KILL_SHOT_1) ||
+                    spellId == GetSpell(CHIMERA_SHOT_1)))
+                    pctbonus += 0.05f;
+            }
+
+            //Ranged Weapon Specialization: 5% bonus damage for ranged attacks
+            if (lvl >= 35 && attackType == RANGED_ATTACK)
+                pctbonus += 0.05f;
+            //Improved Arcane Shot: 15% bonus damage for Arcane Shot
+            if (lvl >= 20 && spellId == GetSpell(ARCANE_SHOT_1))
+                pctbonus += 0.15f;
+            //Rapid Killing (buff): 20% bonus damage for Aimed Shot, Arcane Shot or Chimera Shot (removed in SpellHitTarget())
+            if (lvl >= 20 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1)) &&
+                me->HasAura(RAPID_KILLING_BUFF))
+                pctbonus += 0.2f;
+            //Barrage: 12% bonus damage for Aimed Shot, Multi-Shot or Volley (removed in SpellHitTarget())
+            if (lvl >= 30 && (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(MULTISHOT_1) ||
+                spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(VOLLEY_DAMAGE_1))))
+                pctbonus += 0.12f;
+            //Marked for Death (part 1): 5% bonus damage for all ranged shots on marked target
+            if (lvl >= 55 && attackType == RANGED_ATTACK && damageinfo.target == markTarget)
+                pctbonus += 0.05f;
+            //T.N.T: 6% bonus damage for Explosive Shot (handled here) and Black Arrow (can be handler in ApplyClassDamageMultiplierEffect())
+            if (lvl >= 25 && spellId == GetSpell(EXPLOSIVE_SHOT_1))
+                pctbonus += 0.06f;
+            //Sniper Training (part 2): 6% bonus damage for Steady Shot, Aimed Shot, Black Arrow and Explosive Shot (screw aura stuff, just increase)
+            if (lvl >= 50 &&
+                (spellId == GetSpell(AIMED_SHOT_1) ||
+                //spellId == GetSpell(STEADY_SHOT_1) ||
+                //spellId == GetSpell(BLACK_ARROW_1) ||//cannot be handled here
+                spellId == GetSpell(EXPLOSIVE_SHOT_1)))
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value (50%) while ability crits
+            if (lvl >= 40)
+                (static_cast<ManaRestoreList>(TotH))[spellId] = crit && attackType == RANGED_ATTACK ? spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask()) / 2 : 0;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (target == me)
+                return;
+
+            uint32 spellId = spell->Id;
+
+            //Thrill of the Hunt additive (stage 1): store mana restore value while ability crits
+            if (me->getLevel() >= 40 && TotH[spellId] > 0 && uint32(TotH[spellId]) < me->GetMaxPower(POWER_MANA))
+            {
+                me->EnergizeBySpell(me, THRILL_OF_THE_HUNT_EFFECT, TotH[spellId], POWER_MANA);
+                TotH[spellId] = 0;
+            }
+
+            if (spellId == GetSpell(WING_CLIP_1))
+            {
+                //zzzOLD Improved Wing Clip (only on creatures): 30% to root target with Wing Clip
+                //normal creatures are rooted for 10 sec, elites+ for 6 sec
+                if (target->GetTypeId() == TYPEID_UNIT)
+                {
+                    if (urand(1,100) <= 30)
+                    {
+                        uint32 clip = target->ToCreature()->GetCreatureTemplate()->rank == CREATURE_ELITE_NORMAL ? IMPROVED_WING_CLIP_NORMAL : IMPROVED_WING_CLIP_EX;
+                        me->CastSpell(target, clip, true);
+                    }
+                }
+            }
+            if (spellId == GetSpell(CONCUSSIVE_SHOT_1))
+            {
+                //Improved Concussion Shot rank 2: 2 sec increased daze duration
+                if (Aura* concus = target->GetAura(spellId, me->GetGUID()))
+                {
+                    int32 dur = concus->GetDuration() + 2000;
+                    concus->SetDuration(dur);
+                    concus->SetMaxDuration(dur);
+                }
+
+                //zzzOLD Improved Concussion Shot: chance to stun target for 3 sec
+                if (urand(1,100) <= 15)
+                {
+                    me->CastSpell(target, IMPROVED_CONCUSSION, true);
+                }
+            }
+
+            //Rapid Killing: use up buff manually
+            if (spellId == GetSpell(AIMED_SHOT_1) || spellId == GetSpell(ARCANE_SHOT_1) || spellId == GetSpell(CHIMERA_SHOT_1))
+            {
+                if (me->HasAura(RAPID_KILLING_BUFF))
+                    me->RemoveAura(RAPID_KILLING_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(RAPID_FIRE_1))
+            {
+                //Rapid Fire (id 28755): 4 sec increased duration
+                if (Aura* rapid = me->GetAura(spellId))
+                {
+                    uint32 dur = rapid->GetDuration() + 4000;
+                    rapid->SetDuration(dur);
+                    rapid->SetMaxDuration(dur);
+                }
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Trap_cd = 0;
+
+            ScorpidSting_Timer = 0;
+            Aspect_Timer = 0;
+
+            Aspect = 0;
+
+            stingTargetGuid.Clear();
+
+            markTarget = NULL;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Trap_cd > diff)                     Trap_cd -= diff;
+
+            if (ScorpidSting_Timer > diff)          ScorpidSting_Timer -= diff;
+            if (Aspect_Timer > diff)                Aspect_Timer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(AUTO_SHOT_1, true);
+            InitSpellMap(TRANQ_SHOT_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(SILENCING_SHOT_1) : RemoveSpell(SILENCING_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHIMERA_SHOT_1) : RemoveSpell(CHIMERA_SHOT_1);
+            InitSpellMap(ARCANE_SHOT_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(AIMED_SHOT_1) : RemoveSpell(AIMED_SHOT_1);
+            InitSpellMap(KILL_SHOT_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(EXPLOSIVE_SHOT_1) : RemoveSpell(EXPLOSIVE_SHOT_1);
+            InitSpellMap(MULTISHOT_1);
+            InitSpellMap(VOLLEY_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(SCATTER_SHOT_1) : RemoveSpell(SCATTER_SHOT_1);
+            InitSpellMap(CONCUSSIVE_SHOT_1);
+            InitSpellMap(DISTRACTING_SHOT_1);
+            InitSpellMap(SCORPID_STING_1);
+            //InitSpellMap(VIPER_STING_1);
+            InitSpellMap(RAPID_FIRE_1);
+            InitSpellMap(WING_CLIP_1);
+            InitSpellMap(RAPTOR_STRIKE_1);
+            InitSpellMap(DISENGAGE_1);
+            InitSpellMap(FROST_TRAP_1);
+            InitSpellMap(FREEZING_ARROW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(WYVERN_STING_1) : RemoveSpell(WYVERN_STING_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(BLACK_ARROW_1) : RemoveSpell(BLACK_ARROW_1);
+            InitSpellMap(HUNTERS_MARK_1);
+            InitSpellMap(SCARE_BEAST_1);
+            InitSpellMap(FEIGN_DEATH_1);
+            InitSpellMap(DETERRENCE_1);
+            //InitSpellMap(ASPECT_OF_THE_VIPER_1);
+  /*Custom*///ASPECT_OF_THE_PACK                      = ASPECT_OF_THE_VIPER ? ASPECT_OF_THE_PACK_1 : 0;
+  /*Custom*/lvl >= 20 ? InitSpellMap(ASPECT_OF_THE_PACK_1, true) : RemoveSpell(ASPECT_OF_THE_PACK_1);
+            //InitSpellMap(ASPECT_OF_THE_DRAGONHAWK_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(RAPID_KILLING, level >= 20 ? 1 : 0);
+            RefreshAura(CONCUSSIVE_BARRAGE, level >= 30 ? 1 : 0);
+            RefreshAura(PIERCING_SHOTS, level >= 40 ? 1 : 0);
+            RefreshAura(TRUESHOT_AURA, level >= 40 ? 1 : 0);
+            RefreshAura(RAPID_RECUPERATION, level >= 45 ? 1 : 0);
+            RefreshAura(MASTER_MARKSMAN, level >= 45 ? 1 : 0);
+            RefreshAura(WILD_QUIVER, level >= 70 ? 3 : level >= 60 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(SUREFOOTED, level >= 15 ? 1 : 0);
+            RefreshAura(ENTRAPMENT, level >= 15 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN5, level >= 67 ? 3 : level >= 58 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN4, level >= 49 && level < 50 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN3, level >= 48 && level < 49 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN2, level >= 47 && level < 48 ? 1 : 0);
+            RefreshAura(MASTER_TACTICIAN1, level >= 46 && level < 47 ? 1 : 0);
+            RefreshAura(NOXIOUS_STINGS, level >= 45 ? 1 : 0);
+            RefreshAura(HUNTING_PARTY, level >= 55 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case RAPID_FIRE_1:
+                case FROST_TRAP_1:
+                case ASPECT_OF_THE_PACK_1:
+                case ASPECT_OF_THE_VIPER_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::unordered_map<uint32 /*spellId*/, int32 /*manaCost*/> ManaRestoreList;
+        ManaRestoreList TotH;
+        uint32 Trap_cd;
+        uint32 ScorpidSting_Timer, Aspect_Timer;
+        uint32 Aspect;
+        ObjectGuid stingTargetGuid;
+        Unit* markTarget;
+
+        enum HunterBaseSpells
+        {
+            AUTO_SHOT_1                         = 75,
+            TRANQ_SHOT_1                        = 19801,
+            SILENCING_SHOT_1                    = 34490,
+            CHIMERA_SHOT_1                      = 53209,
+            ARCANE_SHOT_1                       = 3044,
+            AIMED_SHOT_1                        = 19434,
+            KILL_SHOT_1                         = 53351,
+            EXPLOSIVE_SHOT_1                    = 53301,
+            MULTISHOT_1                         = 2643,
+            VOLLEY_1                            = 1510,
+            SCATTER_SHOT_1                      = 1991,
+            CONCUSSIVE_SHOT_1                   = 5116,
+            DISTRACTING_SHOT_1                  = 20736,
+            SCORPID_STING_1                     = 3043,
+            //VIPER_STING_1                       = 3034,
+            RAPID_FIRE_1                        = 3045,
+            WING_CLIP_1                         = 2974,
+            RAPTOR_STRIKE_1                     = 2973,
+            DISENGAGE_1                         = 781,
+            FROST_TRAP_1                        = 13809,
+            FREEZING_ARROW_1                    = 60192,
+            WYVERN_STING_1                      = 19386,
+            BLACK_ARROW_1                       = 3674,
+            HUNTERS_MARK_1                      = 1130,
+            SCARE_BEAST_1                       = 1513,
+            FEIGN_DEATH_1                       = 5384,
+            DETERRENCE_1                        = 19263,
+            ASPECT_OF_THE_PACK_1                = 36613,//Aspect of the Spirit Hunter
+            ASPECT_OF_THE_VIPER_1               = 34074
+            //ASPECT_OF_THE_DRAGONHAWK_1          = 61846
+        };
+
+        enum HunterPassives
+        {
+        //Talents
+            RAPID_KILLING                       = 34949,//rank 2
+            CONCUSSIVE_BARRAGE                  = 35102,//rank 2
+            PIERCING_SHOTS                      = 53238,//rank 3
+            TRUESHOT_AURA                       = 19506,
+            RAPID_RECUPERATION                  = 53232,//rank 2
+            MASTER_MARKSMAN                     = 34489,//rank 5
+            WILD_QUIVER                         = 53217,//rank 3
+            SUREFOOTED                          = 24283,//rank 3
+            ENTRAPMENT                          = 19388,//rank 3
+            MASTER_TACTICIAN1                   = 34506,
+            MASTER_TACTICIAN2                   = 34507,
+            MASTER_TACTICIAN3                   = 34508,
+            MASTER_TACTICIAN4                   = 34838,
+            MASTER_TACTICIAN5                   = 34839,
+            NOXIOUS_STINGS                      = 53297,//rank 3
+            HUNTING_PARTY                       = 53292 //rank 3
+        };
+
+        enum HunterSpecial
+        {
+            IMPROVED_CONCUSSION                 = 28445,
+            IMPROVED_WING_CLIP_NORMAL           = 47168,
+            IMPROVED_WING_CLIP_EX               = 35963,
+
+            RAPID_KILLING_BUFF                  = 35099,//rank 2
+            THRILL_OF_THE_HUNT_EFFECT           = 34720,
+            FROST_TRAP_AURA                     = 13810,
+            FREEZING_ARROW_EFFECT               = 60210,
+            //FREEZING_TRAP_EFFECT_1              = 3355,
+            //FREEZING_TRAP_EFFECT_2              = 14308,
+            //FREEZING_TRAP_EFFECT_3              = 14309,
+            VOLLEY_DAMAGE_1                     = 42243 //rank 1
+        };
+    };
+};
+
+void AddSC_hunter_bot()
+{
+    new hunter_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_mage_ai.cpp b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
new file mode 100644
index 0000000..d28177b
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_mage_ai.cpp
@@ -0,0 +1,910 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "GameEventMgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Mage NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45%
+TODO: Ice Lance, Deep Freeze, Mana Gems, Pet etc...
+*/
+class mage_bot : public CreatureScript
+{
+public:
+    mage_bot() : CreatureScript("mage_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new mage_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct mage_botAI : public bot_minion_ai
+    {
+        mage_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_MAGE) != SPELL_CAST_OK)
+                return false;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered);
+
+            if (result && spellId != MANAPOTION && me->HasAura(CLEARCASTBUFF))
+            {
+                cost = m_botSpellInfo->CalcPowerCost(me, m_botSpellInfo->GetSchoolMask());
+                if (cost)
+                    clearcast = true;
+            }
+
+            return result;
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void Counter()
+        {
+            Unit* u = me->GetVictim();
+            bool cSpell = IsSpellReady(COUNTERSPELL_1, 0, false, 5000);
+            bool blast = IsSpellReady(FIREBLAST_1, 0, false, 3000) && HasRole(BOT_ROLE_DPS) && !(u && u->ToCreature() && (u->ToCreature()->isWorldBoss() || u->ToCreature()->IsDungeonBoss())) && me->HasAura(IMPACT_BUFF);
+            if (!cSpell && !blast) return;
+            if (u && u->IsNonMeleeSpellCast(false) &&
+                ((cSpell && me->GetDistance(u) < 30) || (blast && me->GetDistance(u) < 30)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (cSpell && doCast(u, GetSpell(COUNTERSPELL_1)))
+                {}
+                else if (blast && doCast(u, GetSpell(FIREBLAST_1)))
+                {}
+                GC_Timer = temptimer;
+            }
+            else if (cSpell)
+            {
+                if (Unit* target = FindCastingTarget(30))
+                {
+                    temptimer = GC_Timer;
+                    if (me->IsNonMeleeSpellCast(false))
+                        me->InterruptNonMeleeSpells(false);
+                    if (doCast(target, GetSpell(COUNTERSPELL_1)))
+                        GC_Timer = temptimer;
+                }
+            }
+        }
+
+        void CheckSpellSteal(uint32 diff)
+        {
+            if (!IsSpellReady(SPELLSTEAL_1, diff) || IsCasting() || Rand() > 25) return;
+            Unit* target = FindHostileDispelTarget(30, true);
+            if (target && doCast(target, GetSpell(SPELLSTEAL_1)))
+                GC_Timer = 800;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || Feasting())
+                return;
+
+            if (uint32 DAMPENMAGIC = GetSpell(DAMPENMAGIC_1))
+            {
+                if (!HasAuraName(me, DAMPENMAGIC) &&
+                    doCast(me, DAMPENMAGIC))
+                    return;
+            }
+
+            if (ICEARMOR && !HasAuraName(me, ICEARMOR) &&
+                doCast(me, ICEARMOR))
+                return;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (GC_Timer > diff || Rand() > 20) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+
+            if (uint32 ARCANEINTELLECT = GetSpell(ARCANEINTELLECT_1))
+            {
+                if (target->getPowerType() == POWER_MANA && !HasAuraName(target, ARCANEINTELLECT) &&
+                    doCast(target, ARCANEINTELLECT))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            if (clearcast && me->HasAura(CLEARCASTBUFF) && !me->IsNonMeleeSpellCast(false))
+            {
+                me->ModifyPower(POWER_MANA, cost);
+                me->RemoveAurasDueToSpell(CLEARCASTBUFF,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF1))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF1,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                if (me->HasAura(ARCANE_POTENCY_BUFF2))
+                    me->RemoveAurasDueToSpell(ARCANE_POTENCY_BUFF2,me->GetGUID(),0,AURA_REMOVE_BY_EXPIRE);
+                clearcast = false;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me) && (!GetSpell(ICEBLOCK_1) || !me->HasAura(GetSpell(ICEBLOCK_1)))) return; //TODO
+
+            CheckBlink(diff);
+            CheckPoly(diff);
+            CheckPots(diff);
+            CureGroup(master, GetSpell(REMOVE_CURSE_1), diff);
+
+            FocusMagic(diff);
+            BuffAndHealGroup(master, diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_MAGE))
+                return;
+
+            CheckPoly2();//this should go AFTER getting opponent
+
+            Counter();
+            CheckSpellSteal(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            Unit* u = me->SelectNearestTarget(20);
+            //ICE_BARRIER
+            uint32 ICE_BARRIER = GetSpell(ICE_BARRIER_1);
+            if (IsSpellReady(ICE_BARRIER_1, diff, false) && u && u->GetVictim() == me && u->GetDistance(me) < 8 &&
+                !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, ICE_BARRIER))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+            if (!IsSpellReady(ICE_BARRIER_1, diff, false) &&
+                IsSpellReady(BLINK_1, diff, false, 3000) && u && u->GetVictim() == me &&
+                u->GetDistance(me) < 6 && !me->HasAura(ICE_BARRIER))
+            {
+                if (me->IsNonMeleeSpellCast(true))
+                    me->InterruptNonMeleeSpells(true);
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            //ICEBLOCK
+            if (uint32 ICEBLOCK = GetSpell(ICEBLOCK_1))
+            {
+                if (IsSpellReady(ICEBLOCK_1, diff, false, 57000))
+                {
+                    if (((GetManaPCT(me) > 45 && GetHealthPCT(me) > 80) || b_attackers.empty()) &&
+                        me->HasAura(ICEBLOCK))
+                        me->RemoveAurasDueToSpell(ICEBLOCK);
+                }
+
+                if (IsSpellReady(ICEBLOCK_1, diff, false) && !b_attackers.empty() && Rand() < 50 &&
+                    (GetManaPCT(me) < 15 || GetHealthPCT(me) < 45 || b_attackers.size() > 4) &&
+                    !me->HasAura(ICEBLOCK))
+                {
+                    if (me->IsNonMeleeSpellCast(true))
+                        me->InterruptNonMeleeSpells(true);
+                    if (doCast(me, ICEBLOCK))
+                    {
+                        Nova_cd = 0; //Glyph of Iceblock
+                        return;
+                    }
+                }
+            }
+
+            if (IsCasting()) return;
+
+            float dist = me->GetExactDist(opponent);
+
+            uint32 FROSTBOLT = GetSpell(FROSTBOLT_1);
+            uint32 FIREBALL = GetSpell(FIREBALL_1);
+            uint32 BLASTWAVE = GetSpell(BLASTWAVE_1);
+            uint32 FROSTNOVA = GetSpell(FROSTNOVA_1);
+            BOLT = (CCed(opponent, true) || !FROSTBOLT) ? FIREBALL : FROSTBOLT;
+            NOVA = BOLT == FROSTBOLT && BLASTWAVE && dist > 5 ? BLASTWAVE : FROSTNOVA ? FROSTNOVA : 0;
+
+            if (IsSpellReady(COMBUSTION_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                (opponent->GetMaxHealth() > master->GetMaxHealth()*6 ||
+                m_attackers.size() > 1 || b_attackers.size() > 2) &&
+                Rand() < 15 && !HasAuraName(me, COMBUSTION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(COMBUSTION_1)))
+                {
+                    GC_Timer = temptimer;
+                    //Reset timers for fun
+                    ResetSpellCooldown(FIREBLAST_1);
+                    ResetSpellCooldown(DRAGONBREATH_1);
+                    Nova_cd = 0;
+                }
+            }
+            //DAMAGE
+            //PYROBLAST
+            if (IsSpellReady(PYROBLAST_1, diff) && opponent->IsPolymorphed() && HasRole(BOT_ROLE_DPS) &&
+                (b_attackers.size() < 2 || (*b_attackers.begin()) == opponent) &&
+                dist < 35 && Rand() < 75 &&
+                doCast(opponent, GetSpell(PYROBLAST_1)))
+            {
+                SetSpellCooldown(PYROBLAST_1, 7500); //no initial cooldown
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), uint32(float(sSpellMgr->GetSpellInfo(GetSpell(PYROBLAST_1))->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 400)));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //nova //TODO: SEPARATE
+            u = me->SelectNearestTarget(6.3f);
+            if (NOVA && Nova_cd <= diff && HasRole(BOT_ROLE_DPS) && u && Rand() < 75 && !CCed(u, true) && IsInBotParty(u->GetVictim()))
+            {
+                if (doCast(me, NOVA))
+                {
+                    Nova_cd = 15000;
+                    GetInPosition(true);
+                    return;
+                }
+            }
+            //living bomb
+            if (IsSpellReady(LIVINGBOMB_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 35 && opponent->GetHealth() > me->GetHealth()/2 &&
+                Rand() < 45 && !HasAuraName(opponent, LIVINGBOMB_1, me->GetGUID()) &&
+                doCast(opponent, GetSpell(LIVINGBOMB_1)))
+            {
+                GC_Timer = 500;
+                return;
+            }
+            //cone of cold
+            if (IsSpellReady(CONEOFCOLD_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 7 && Rand() < 50 &&
+                me->HasInArc(M_PI*0.75f, opponent) &&
+                doCast(opponent, GetSpell(CONEOFCOLD_1)))
+            {
+                GC_Timer = 500;
+                GetInPosition(true);
+                return;
+            }
+            //dragon's breath
+            if (IsSpellReady(DRAGONBREATH_1, diff) && HasRole(BOT_ROLE_DPS) && !CCed(opponent, true) &&
+                ((me->HasInArc(M_PI*0.75f, opponent) && dist < 7) ||
+                (u && u != opponent && me->HasInArc(M_PI*0.75f, u) && IsInBotParty(u->GetVictim()))) &&
+                doCast(me, GetSpell(DRAGONBREATH_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+            /*//blast wave //TODO Separate again
+            u = me->SelectNearestTarget(8);
+            if (BLASTWAVE != 0 && u && isTimerReady(BlastWave_cd) &&
+                !HasAuraName(u, FROSTNOVA) && !HasAuraName(u, DRAGONBREATH) &&
+                doCast(me, BLASTWAVE))
+            {
+                BlastWave_cd = BLASTWAVE_CD;
+                GC_Timer = 800;
+            }*/
+            //fire blast
+            if (IsSpellReady(FIREBLAST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                Rand() < 20 + 80*(!opponent->isFrozen() && !opponent->HasAuraType(SPELL_AURA_MOD_STUN) && me->HasAura(IMPACT_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(FIREBLAST_1)))
+                {
+                    GC_Timer = 500;
+                    return;
+                }
+            }
+            //flamestrike - use Improved Flamestrike for instant cast
+            if (IsSpellReady(FLAMESTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->HasAura(FIRESTARTERBUFF) && Rand() < 25)
+            {
+                Unit* FStarget = FindAOETarget(30, true, false);
+                if (FStarget && doCast(FStarget, GetSpell(FLAMESTRIKE_1), true))
+                {
+                    me->RemoveAurasDueToSpell(FIRESTARTERBUFF);
+                    GC_Timer = 300;
+                    return;
+                }
+            }
+            //blizzard
+            if (IsSpellReady(BLIZZARD_1, diff, false) && HasRole(BOT_ROLE_DPS) && Rand() < 40)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(BLIZZARD_1)))
+                    return;
+                SetSpellCooldown(BLIZZARD_1, 1500); //fail
+            }
+            //Frost or Fire Bolt
+            if (BOLT && Bolt_cd <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 75 &&
+                doCast(opponent, BOLT))
+            {
+                Bolt_cd = uint32(float(sSpellMgr->GetSpellInfo(BOLT)->CalcCastTime()/100) * me->GetFloatValue(UNIT_MOD_CAST_SPEED) + 200);
+                //debug
+                SetSpellCooldown(DRAGONBREATH_1, std::max<uint32>(GetSpellCooldown(DRAGONBREATH_1), Bolt_cd + 200));
+                Nova_cd = std::max<uint32>(Nova_cd, 450);
+                return;
+            }
+            //Arcane Missiles
+            if (IsSpellReady(ARCANEMISSILES_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && Rand() < 15 &&
+                doCast(opponent, GetSpell(ARCANEMISSILES_1)))
+                return;
+        }
+
+        void CheckPoly(uint32 diff)
+        {
+            if (polyCheckTimer <= diff)
+            {
+                Polymorph = FindAffectedTarget(GetSpell(POLYMORPH_1), me->GetGUID());
+                polyCheckTimer = 2000;
+            }
+        }
+
+        void CheckPoly2()
+        {
+            if (Polymorph == false && GC_Timer < 500 && GetSpell(POLYMORPH_1))
+            {
+                if (Unit* target = FindPolyTarget(30, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(POLYMORPH_1)))
+                    {
+                        Polymorph = true;
+                        polyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckPots(uint32 diff)
+        {
+            if (me->IsMounted() || IsCasting())
+                return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 35 && Rand() < 35)
+            {
+                if (IsSpellReady(EVOCATION_1, diff, false) && me->getAttackers().empty() &&
+                    doCast(me, GetSpell(EVOCATION_1)))
+                    return;
+                if (Potion_cd <= diff)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, MANAPOTION))
+                    {
+                        Potion_cd = POTION_CD;
+                        GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void CheckBlink(uint32 diff)
+        {
+            if (GetBotCommandState() == COMMAND_STAY || me->IsMounted() || IAmFree()) return;
+            if (!IsSpellReady(BLINK_1, diff, false) || me->getLevel() < 20 || IsCasting()) return;
+
+            if (!me->IsInCombat() && me->GetExactDist2d(master) > std::max<uint8>(master->GetBotFollowDist(), 35) &&
+                me->HasInArc(M_PI*0.75f, master))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLINK_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            if (!me->getAttackers().empty() && me->GetExactDist2d(master) > 15)
+            {
+                if (Unit* op = me->SelectNearestTarget(7))
+                {
+                    if (op->GetVictim() == me)
+                    {
+                        me->SetFacingTo(me->GetAngle(master));
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLINK_1)))
+                            GC_Timer = temptimer;
+                    }
+                }
+            }
+        }
+
+        void FocusMagic(uint32 diff)
+        {
+            if (fmCheckTimer > diff || GC_Timer > diff || IAmFree() || me->getLevel() < 20 || IsCasting() || Rand() < 50)
+                return;
+
+            uint32 FOCUSMAGIC = GetSpell(FOCUSMAGIC_1);
+            if (!FOCUSMAGIC)
+                return;
+
+            if (Unit* target = FindAffectedTarget(FOCUSMAGIC, me->GetGUID(), 70, 3))
+            {
+                fmCheckTimer = 15000;
+                return;
+            }
+            else
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (master->getPowerType() == POWER_MANA && me->GetExactDist(master) < 30 &&
+                        !master->HasAura(FOCUSMAGIC))
+                        target = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (pPlayer->getPowerType() == POWER_MANA && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(FOCUSMAGIC))
+                        {
+                            target = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!target)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (cre->getPowerType() == POWER_MANA && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(FOCUSMAGIC))
+                                {
+                                    target = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (target && doCast(target, FOCUSMAGIC))
+                {
+                    GC_Timer = 500;
+                    fmCheckTimer = 30000;
+                    return;
+                }
+            }
+
+            fmCheckTimer = 5000;
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Combustion: 10% per stack
+                if (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask())
+                    if (Aura* combustion = me->GetAura(COMBUSTION_BUFF))
+                        aftercrit += float(combustion->GetStackAmount()*10);
+                //Incineration: 6% additional critical chance for Fire Blast, Scorch, Arcane Blast and Cone of Cold
+                if (lvl >= 10 &&
+                    (spellId == GetSpell(FIREBLAST_1) ||
+                    spellId == GetSpell(CONEOFCOLD_1)/* ||
+                    spellId == ARCANEBLAST ||
+                    spellId == SCORCH*/))
+                    aftercrit += 6.f;
+                //World In Flames: 6% additional critical chance for
+                //Flamestrike, Pyroblast, Blast Wave, Dragon's Breath, Living Bomb, Blizzard and Arcane Explosion
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(FLAMESTRIKE_1) ||
+                    spellId == GetSpell(PYROBLAST_1) ||
+                    spellId == GetSpell(BLASTWAVE_1) ||
+                    spellId == GetSpell(DRAGONBREATH_1)/* ||
+                    spellId == ARCANEXPLOSION ||
+                    spellId == LIVINGBOMB ||    //cannot be handled here
+                    spellId == BLIZZARD*/))    //cannot be handled here
+                    aftercrit += 6.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Spell Power: 50% additional crit damage bonus for All spells
+                if (lvl >= 55)
+                    pctbonus += 0.333f;
+                //Ice Shards: 50% additional crit damage bonus for Frost spells
+                else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                    pctbonus += 0.333f;
+            }
+            //Improved Cone of Cold: 35% bonus damage for Cone of Cold
+            if (lvl >= 30 && spellId == GetSpell(CONEOFCOLD_1))
+                pctbonus += 0.35f;
+            //Fire Power: 10% bonus damage for Fire spells
+            if (lvl >= 35 && (SPELL_SCHOOL_MASK_FIRE & spellInfo->GetSchoolMask()))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            if (!aftercastTargetGuid)
+            {
+                //only players for now
+                if (!aftercastTargetGuid.IsPlayer())
+                {
+                    aftercastTargetGuid.Clear();
+                    return;
+                }
+
+                Player* pTarget = ObjectAccessor::FindPlayer(aftercastTargetGuid);
+                aftercastTargetGuid.Clear();
+
+                if (!pTarget/* || me->GetDistance(pTarget) > 15*/)
+                    return;
+
+                //handle effects
+                for (uint8 i = 0; i != MAX_SPELL_EFFECTS; ++i)
+                {
+                    switch (spell->Effects[i].Effect)
+                    {
+                        case SPELL_EFFECT_CREATE_ITEM:
+                        case SPELL_EFFECT_CREATE_ITEM_2:
+                        {
+                            uint32 newitemid = spell->Effects[i].ItemType;
+                            if (newitemid)
+                            {
+                                ItemPosCountVec dest;
+                                ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(newitemid);
+                                if (!pProto)
+                                    return;
+                                uint32 count = pProto->GetMaxStackSize();
+                                uint32 no_space = 0;
+                                InventoryResult msg = pTarget->CanStoreNewItem(NULL_BAG, NULL_SLOT, dest, newitemid, count, &no_space);
+                                if (msg != EQUIP_ERR_OK)
+                                {
+                                    if (msg == EQUIP_ERR_INVENTORY_FULL || msg == EQUIP_ERR_CANT_CARRY_MORE_OF_THIS)
+                                        count -= no_space;
+                                    else
+                                    {
+                                        // if not created by another reason from full inventory or unique items amount limitation
+                                        pTarget->SendEquipError(msg, NULL, NULL, newitemid);
+                                        continue;
+                                    }
+                                }
+                                if (count)
+                                {
+                                    Item* pItem = pTarget->StoreNewItem(dest, newitemid, true, Item::GenerateItemRandomPropertyId(newitemid));
+                                    if (!pItem)
+                                    {
+                                        pTarget->SendEquipError(EQUIP_ERR_ITEM_NOT_FOUND, NULL, NULL);
+                                        continue;
+                                    }
+                                    //unsafe possible
+                                    pItem->SetUInt32Value(ITEM_FIELD_CREATOR, me->GetGUID().GetCounter());
+
+                                    pTarget->SendNewItem(pItem, count, true, false, true);
+                                }
+                            }
+                            break;
+                        }
+                        default:
+                            break;
+                    }
+                }
+
+                return;
+            }
+
+            //Winter Veil addition
+            uint32 spellId = spell->Id;
+            if (sGameEventMgr->IsActiveEvent(GAME_EVENT_WINTER_VEIL))
+            {
+                if (SPELL_SCHOOL_MASK_FROST & spell->GetSchoolMask())
+                    me->AddAura(44755, target); //snowflakes
+
+                if (spellId == GetSpell(FROSTBOLT_1) && urand(1,100) <= 10)
+                    me->CastSpell(target, 25686, true); //10% super snowball
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Bolt_cd = 0;
+            Nova_cd = 0;
+            polyCheckTimer = 0;
+            fmCheckTimer = 0;
+            Polymorph = false;
+            clearcast = false;
+            BOLT = 0;
+            NOVA = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Bolt_cd > diff)                     Bolt_cd -= diff;
+            if (Nova_cd > diff)                     Nova_cd -= diff;
+
+            if (polyCheckTimer > diff)              polyCheckTimer -= diff;
+            if (fmCheckTimer > diff)                fmCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DAMPENMAGIC_1);
+            InitSpellMap(ARCANEINTELLECT_1);
+            InitSpellMap(ARCANEMISSILES_1);
+            InitSpellMap(POLYMORPH_1);
+            InitSpellMap(COUNTERSPELL_1);
+            InitSpellMap(SPELLSTEAL_1);
+            InitSpellMap(EVOCATION_1);
+            InitSpellMap(BLINK_1);
+            InitSpellMap(REMOVE_CURSE_1);
+            //InitSpellMap(INVISIBILITY_1);
+            InitSpellMap(FIREBALL_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLASTWAVE_1) : RemoveSpell(BLASTWAVE_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(DRAGONBREATH_1) : RemoveSpell(DRAGONBREATH_1);
+            InitSpellMap(FIREBLAST_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PYROBLAST_1) : RemoveSpell(PYROBLAST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(LIVINGBOMB_1) : RemoveSpell(LIVINGBOMB_1);
+            InitSpellMap(DAMPENMAGIC_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(COMBUSTION_1) : RemoveSpell(COMBUSTION_1);
+            InitSpellMap(FROSTBOLT_1);
+            InitSpellMap(FROSTNOVA_1);
+            InitSpellMap(CONEOFCOLD_1);
+            InitSpellMap(BLIZZARD_1);
+ /*Special*/ICEARMOR = lvl >= 20 ? InitSpell(me, ICEARMOR_1) : InitSpell(me, FROSTARMOR_1);
+            InitSpellMap(ICEARMOR);
+  /*Talent*/lvl >= 40 ? InitSpellMap(ICE_BARRIER_1) : RemoveSpell(ICE_BARRIER_1);
+            InitSpellMap(ICEBLOCK_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(FOCUSMAGIC_1) : RemoveSpell(FOCUSMAGIC_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(ARCTIC_WINDS, level >= 35 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL3, level >= 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(WINTERS_CHILL1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(IMPROVED_BLIZZARD, level >= 45 ? 1 : 0);
+            RefreshAura(FROSTBITE3, level >= 80 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(FROSTBITE2, level >= 50 && level < 80 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(FROSTBITE1, level >= 10 && level < 50 ? level >= 60 ? 3 : level >= 30 ? 2 : level >= 10 ? 1 : 0 : 0);
+            RefreshAura(SHATTERED_BARRIER, level >= 45 ? 1 : 0);
+            RefreshAura(ARCANE_INSTABILITY, level >= 65 ? 4 : level >= 55 ? 3 : level >= 45 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION3, level >= 50 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(INCANTERS_ABSORPTION1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SHATTER3, level >= 35 ? 1 : 0);
+            RefreshAura(SHATTER2, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(SHATTER1, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(CLEARCAST, level >= 75 ? 3 : level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(FINGERS_OF_FROST, level >= 45 ? 1 : 0); //15%
+            RefreshAura(ARCANE_POTENCY2, level >= 40 ? 1 : 0);
+            RefreshAura(ARCANE_POTENCY1, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(IGNITE, level >= 15 ? 1 : 0);
+            RefreshAura(IMPACT, level >= 60 ? 2 : level >= 20 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL2, level >= 35 ? 1 : 0);
+            RefreshAura(IMPROVED_COUNTERSPELL1, level >= 25 && level < 35 ? 1 : 0);
+            RefreshAura(FIRESTARTER2, level >= 55 ? 1 : 0);
+            RefreshAura(FIRESTARTER1, level >= 45 && level < 55 ? 1 : 0);
+            RefreshAura(GLYPH_LIVING_BOMB, GetSpell(LIVINGBOMB_1) ? 1 : 0);
+            RefreshAura(GLYPH_POLYMORPH, GetSpell(POLYMORPH_1) ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DAMPENMAGIC_1:
+                case ARCANEINTELLECT_1:
+                case EVOCATION_1:
+                case REMOVE_CURSE_1:
+                case FOCUSMAGIC_1:
+                case FROSTARMOR_1:
+                case ICEARMOR_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        //Spells
+/*frst*/uint32 ICEARMOR;
+/*exc.*/uint32 BOLT, NOVA;
+        //Timers
+/*exc.*/uint32 Bolt_cd, Nova_cd;
+/*exc.*/uint32 polyCheckTimer, fmCheckTimer;
+        //Check
+/*exc.*/bool Polymorph, clearcast;
+
+        enum MageBaseSpells
+        {
+            DAMPENMAGIC_1                       = 604,
+            ARCANEINTELLECT_1                   = 1459,
+            ARCANEMISSILES_1                    = 5143,
+            POLYMORPH_1                         = 118,
+            COUNTERSPELL_1                      = 2139,
+            SPELLSTEAL_1                        = 30449,
+            EVOCATION_1                         = 12051,
+            BLINK_1                             = 1953,
+            REMOVE_CURSE_1                      = 475,
+            //INVISIBILITY_1                      = 0,
+            FIREBALL_1                          = 133,
+            BLASTWAVE_1                         = 11113,
+            DRAGONBREATH_1                      = 31661,
+            FIREBLAST_1                         = 2136,
+            PYROBLAST_1                         = 11366,
+            LIVINGBOMB_1                        = 44457,
+            FLAMESTRIKE_1                       = 2120,
+            COMBUSTION_1                        = 11129,
+            FROSTBOLT_1                         = 116,
+            FROSTNOVA_1                         = 122,
+            CONEOFCOLD_1                        = 120,
+            BLIZZARD_1                          = 10,
+            FROSTARMOR_1                        = 168,
+            ICEARMOR_1                          = 7302,
+            ICE_BARRIER_1                       = 11426,
+            ICEBLOCK_1                          = 45438,
+            FOCUSMAGIC_1                        = 54646
+        };
+
+        enum MagePassives
+        {
+        //Talents
+            SHATTERED_BARRIER                   = 54787,//rank 2
+            ARCTIC_WINDS                        = 31678,//rank 5
+            WINTERS_CHILL1                      = 11180,
+            WINTERS_CHILL2                      = 28592,
+            WINTERS_CHILL3                      = 28593,
+            FROSTBITE1                          = 11071,
+            FROSTBITE2                          = 12496,
+            FROSTBITE3                          = 12497,
+            IMPROVED_BLIZZARD                   = 12488,//rank 3
+            CLEARCAST /*Arcane Concentration*/  = 12577,//rank 5
+            ARCANE_POTENCY1                     = 31571,
+            ARCANE_POTENCY2                     = 31572,
+            SHATTER1                            = 11170,
+            SHATTER2                            = 12982,
+            SHATTER3                            = 12983,
+            INCANTERS_ABSORPTION1               = 44394,
+            INCANTERS_ABSORPTION2               = 44395,
+            INCANTERS_ABSORPTION3               = 44396,
+            FINGERS_OF_FROST                    = 44545,//rank 2
+            ARCANE_INSTABILITY                  = 15060,//rank 3
+            IMPROVED_COUNTERSPELL1              = 11255,
+            IMPROVED_COUNTERSPELL2              = 12598,
+            IGNITE                              = 12848,
+            FIRESTARTER1                        = 44442,
+            FIRESTARTER2                        = 44443,
+            IMPACT                              = 12358,
+            GLYPH_LIVING_BOMB                   = 63091,
+        //Special
+            GLYPH_POLYMORPH                     = 56375
+        };
+        enum MageSpecial
+        {
+            CLEARCASTBUFF                       = 12536,
+            IMPACT_BUFF                         = 64343,
+            FIRESTARTERBUFF                     = 54741,
+            ARCANE_POTENCY_BUFF1                = 57529,
+            ARCANE_POTENCY_BUFF2                = 57531,
+            COMBUSTION_BUFF                     = 28682
+        };
+    };
+};
+
+void AddSC_mage_bot()
+{
+    new mage_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_paladin_ai.cpp b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
new file mode 100644
index 0000000..ea9a8f3
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_paladin_ai.cpp
@@ -0,0 +1,1173 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Paladin NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 45-50%
+TODO: Tanking, Shield Abilities, Auras
+*/
+class paladin_bot : public CreatureScript
+{
+public:
+    paladin_bot() : CreatureScript("paladin_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new paladin_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct paladin_botAI : public bot_minion_ai
+    {
+        paladin_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PALADIN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PALADIN) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void HOFGroup(Player* pTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOF_1, diff) || IAmFree() || IsCasting() || Rand() > 60)
+                return;
+
+            if (Group* pGroup = pTarget->GetGroup())
+            {
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer) continue;
+                    if (HOFTarget(tPlayer, diff))
+                        return;
+                }
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* cre = it->second;
+                        if (!cre || !cre->IsInWorld()) continue;
+                        if (HOFTarget(cre, diff))
+                            return;
+                    }
+                }
+            }
+        }
+
+        bool HOFTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOF_1, diff)) return false;
+            if (target->ToCreature() && Rand() > 25) return false;
+            if (me->GetExactDist(target) > 30) return false;//too far away
+            if (HasAuraName(target, HOF_1)) return false;     //Alredy has HOF
+
+            Unit::AuraMap const &auras = target->GetOwnedAuras();
+            for (Unit::AuraMap::const_iterator i = auras.begin(); i != auras.end(); ++i)
+            {
+                Aura* aura = i->second;
+                if (aura->IsPassive()) continue;//most
+                if (aura->GetDuration() < 2000) continue;
+                if (AuraApplication* app = aura->GetApplicationOfTarget(target->GetGUID()))
+                    if (app->IsPositive()) continue;
+                SpellInfo const* spellInfo = aura->GetSpellInfo();
+                if (spellInfo->AttributesEx & SPELL_ATTR0_HIDDEN_CLIENTSIDE) continue;
+                //if (spellInfo->AttributesEx & SPELL_ATTR1_DONT_DISPLAY_IN_AURA_BAR) continue;
+                if (me->getLevel() >= 40 && (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_STUN)))
+                {
+                    if (doCast(target, GetSpell(HOF_1)))
+                        return true;
+                }
+       /*else */if (spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_SNARE) ||
+                    spellInfo->GetAllEffectsMechanicMask() & (1<<MECHANIC_ROOT))
+                {
+                    uint32 spell = GetSpell(CLEANSE_1) &&
+                        (spellInfo->Dispel == DISPEL_MAGIC ||
+                        spellInfo->Dispel == DISPEL_DISEASE ||
+                        spellInfo->Dispel == DISPEL_POISON) ? GetSpell(CLEANSE_1) : GetSpell(HOF_1);
+
+                    if (doCast(target, spell))
+                        return true;
+                }
+            }
+            return false;
+        }
+
+        void HOSGroup(Player* hTarget, uint32 diff)
+        {
+            if (!IsSpellReady(HOS_1, diff) || IAmFree() || IsCasting() || Rand() > 30)
+                return;
+
+            if (Group* pGroup = hTarget->GetGroup())
+            {
+                bool bots = false;
+                float threat;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* HOSPlayer = itr->GetSource();
+                    if (!HOSPlayer) continue;
+                    if (HOSPlayer->HaveBot())
+                        bots = true;
+                    if (HOSPlayer->isDead()) continue;
+                    if (IsTank(HOSPlayer)) continue; //tanks do not need it
+                    if (!HOSPlayer->IsInWorld() || master->GetMap() != HOSPlayer->FindMap() || me->GetExactDist(HOSPlayer) > 30) continue;
+                    if (HasAuraName(HOSPlayer, HOS_1)) continue;
+                    AttackerSet h_attackers = HOSPlayer->getAttackers();
+                    if (h_attackers.empty()) continue;
+                    for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        threat = (*iter)->getThreatManager().getThreat(HOSPlayer);
+                        if (threat < 25.f) continue;//too small threat
+                        if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                        if (HOSPlayer->GetDistance((*iter)) > 10) continue;
+                        if (HOSTarget(HOSPlayer, diff))
+                            return;
+                    }//end for
+                }//end for
+                if (!bots) return;
+                for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (!pl) continue;
+                    if (!pl->HaveBot()) continue;
+                    if (master->GetMap() != pl->FindMap()) continue;
+                    if (!pl->IsInWorld() || pl->IsBeingTeleported()) continue;
+                    BotMap const* map = pl->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* cre = it->second;
+                        if (!cre || cre->isDead()) continue;
+                        if (IsTank(cre)) continue;
+                        if (me->GetExactDist(cre) > 30) continue;
+                        if (HasAuraName(cre, HOS_1)) continue; //Alredy has HOS
+                        AttackerSet h_attackers = cre->getAttackers();
+                        if (h_attackers.empty()) continue;
+                        for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                        {
+                            if (!(*iter)) continue;
+                            if ((*iter)->isDead()) continue;
+                            if (!(*iter)->CanHaveThreatList()) continue;
+                            threat = (*iter)->getThreatManager().getThreat(cre);
+                            if (threat < 25.f) continue;//too small threat
+                            if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                            if (cre->GetDistance((*iter)) > 10) continue;
+                            if (HOSTarget(cre, diff))
+                                return;
+                        }//end for
+                    }//end for
+                }//end for
+            }//end if
+        }
+
+        bool HOSTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOS_1, diff) || Rand() > 50) return false;
+            if (IsTank(target)) return false; //tanks do not need it
+            if (IsCasting()) return false; //I'm busy casting
+            if (me->GetExactDist(target) > 30) return false; //too far away
+            if (HasAuraName(target, HOS_1)) return false; //Alredy has HOS
+
+            AttackerSet h_attackers = target->getAttackers();
+            if (h_attackers.empty()) return false; //no aggro
+            float threat;
+            uint8 Tattackers = 0;
+            for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if ((*iter)->isDead()) continue;
+                if (!(*iter)->CanHaveThreatList()) continue;
+                threat = (*iter)->getThreatManager().getThreat(target);
+                if (threat < 25.f) continue; //too small threat
+                if ((*iter)->getAttackers().size() < 2) continue;//would be useless
+                if (target->GetDistance((*iter)) <= 10)
+                    Tattackers++;
+            }
+            if (Tattackers > 0 && doCast(target, GetSpell(HOS_1)))
+            {
+                for (AttackerSet::iterator iter = h_attackers.begin(); iter != h_attackers.end(); ++iter)
+                    if ((*iter)->getThreatManager().getThreat(target) > 0.f)
+                        (*iter)->getThreatManager().modifyThreatPercent(target, -(30 + 50*(target->HasAura(586)))); //Fade
+                return true;
+            }
+            return false;
+        }
+        //Holy_Shock setup (Modify HERE)
+        bool HS(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead()) return false;
+            if (!IsSpellReady(HOLY_SHOCK_1, diff)) return false;
+            if (IsCasting()) return false;
+            if (target->GetTypeId() == TYPEID_PLAYER && (target->IsCharmed() || target->isPossessed()))
+                return false; //do not damage friends under control
+            if (me->GetExactDist(target) > 40) return false;
+
+            if (doCast(target, GetSpell(HOLY_SHOCK_1)))
+            {
+                if (urand(1,100) <= 20) //Daybreak: 20% to not trigger HS CD, only GCD
+                    ResetSpellCooldown(HOLY_SHOCK_1);
+                return true;
+            }
+            return false;
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL)) return false;
+            if (!target || target->isDead()) return false;
+            if (hp > 97) return false;
+            //sLog->outBasic("HealTarget() by %s on %s", me->GetName().c_str(), target->GetName().c_str());
+            if (Rand() > 40 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 35) return false;
+            if (IsCasting()) return false;
+            if (IsSpellReady(HAND_OF_PROTECTION_1, diff, false) && target->GetTypeId() == TYPEID_PLAYER &&
+                IsInBotParty(target) &&
+                ((hp < 30 && !target->getAttackers().empty()) || (hp < 50 && target->getAttackers().size() > 3)) &&
+                me->GetExactDist(target) < 30 &&
+                !HasAuraName(target, HAND_OF_PROTECTION_1) &&
+                !HasAuraName(target, FORBEARANCE_AURA))
+            {
+                if (doCast(target, GetSpell(HAND_OF_PROTECTION_1)))
+                {
+                    BotWhisper("BOP on you!", target->ToPlayer());
+
+                    //debug
+                    if (!HasAuraName(target, FORBEARANCE_AURA))
+                        me->AddAura(FORBEARANCE_AURA, target);
+                    if (HasAuraName(target, FORBEARANCE_AURA) && !HasAuraName(target, HAND_OF_PROTECTION_1))
+                        me->AddAura(GetSpell(HAND_OF_PROTECTION_1), target);
+                }
+                return true;
+            }
+            else if (hp < 20 && !HasAuraName(target, HAND_OF_PROTECTION_1))
+            {
+                // 20% to cast loh, else just do a Shock
+                switch (rand()%3)
+                {
+                    case 1:
+                        if (IsSpellReady(LAY_ON_HANDS_1, diff, false) && hp < 20 &&
+                            target->GetTypeId() == TYPEID_PLAYER &&
+                            (target->IsInCombat() || !target->getAttackers().empty()) &&
+                            !HasAuraName(target, FORBEARANCE_AURA))
+                        {
+                            if (doCast(target, GetSpell(LAY_ON_HANDS_1)))
+                            {
+                                BotWhisper("Lay of Hands on you!", target->ToPlayer());
+                                return true;
+                            }
+                        }
+                    case 2:
+                        if (GC_Timer > diff) return false;
+                        if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                            return true;
+                    case 3:
+                        if (GC_Timer > diff) return false;
+                        if (HS(target, diff))
+                            return true;
+                }
+            }
+
+            Unit* u = target->GetVictim();
+            if (IsSpellReady(SACRED_SHIELD_1, diff) && !IAmFree() && target->GetTypeId() == TYPEID_PLAYER &&
+                (hp < 65 || target->getAttackers().size() > 1 || (u && u->GetMaxHealth() > target->GetMaxHealth()*10 && target->IsInCombat())) &&
+                !HasAuraName(target, SACRED_SHIELD_1) && IsInBotParty(target))
+            {
+                Unit* aff = FindAffectedTarget(GetSpell(SACRED_SHIELD_1), me->GetGUID(), 50, 1);//use players since we cast only on them
+                if ((!aff || (aff->getAttackers().empty() && !IsTank(aff))) &&
+                    doCast(target, GetSpell(SACRED_SHIELD_1)))
+                    return true;
+            }
+            if ((hp < 85 || GetLostHP(target) > 6000))
+                if (HS(target, diff))
+                    return true;
+            if ((hp > 35 && (hp < 75 || GetLostHP(target) > 8000)) || (!GetSpell(FLASH_OF_LIGHT_1) && hp < 85))
+                if (doCast(target, GetSpell(HOLY_LIGHT_1)))
+                    return true;
+            if ((hp < 90 || GetLostHP(target) > 1500))
+                if (doCast(target, GetSpell(FLASH_OF_LIGHT_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return true;
+            return false;
+        }//end HealTarget
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            //HOFTarget(me, diff);//self stun cure goes FIRST
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (GetManaPCT(me) < 40 && IsSpellReady(DIVINE_PLEA_1, diff, false))
+                if (doCast(me, GetSpell(DIVINE_PLEA_1)))
+                    return;
+
+            CureTarget(me, GetSpell(CLEANSE_1), diff); //maybe unnecessary but this goes FIRST
+            HOFTarget(master, diff); //maybe unnecessary
+            CureTarget(master, GetSpell(CLEANSE_1), diff); //maybe unnecessary
+            BuffAndHealGroup(master, diff);
+            HOSTarget(master, diff);
+            CureGroup(master, GetSpell(CLEANSE_1), diff);
+            HOFGroup(master, diff);
+            HOSGroup(master, diff);
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff
+            if (IsSpellReady(SEAL_OF_COMMAND_1, diff, false) && Rand() < 20 && !HasAuraName(me, SEAL_OF_COMMAND_1) &&
+                doCast(me, GetSpell(SEAL_OF_COMMAND_1)))
+                GC_Timer = 500;
+
+            // Heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_PALADIN))
+                return;
+
+            Repentance(diff);
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(REDEMPTION_1), master);
+
+            if (Feasting())
+                return;
+
+            //aura
+            if (master->IsAlive() && me->GetExactDist(master) < 20)
+            {
+                uint8 myAura;
+                uint32 DEVOTION_AURA = GetSpell(DEVOTION_AURA_1);
+                uint32 CONCENTRATION_AURA = GetSpell(CONCENTRATION_AURA_1);
+
+                if (me->HasAura(DEVOTION_AURA, me->GetGUID()))
+                    myAura = DEVOTIONAURA;
+                else if (me->HasAura(CONCENTRATION_AURA, me->GetGUID()))
+                    myAura = CONCENTRATIONAURA;
+                else
+                    myAura = NOAURA;
+
+                if (myAura != NOAURA)
+                    return; //do not bother
+
+                Aura* concAura = master->GetAura(CONCENTRATION_AURA);
+                Aura* devAura = master->GetAura(DEVOTION_AURA);
+                if (devAura && concAura) return;
+                if (devAura && devAura->GetCasterGUID() == me->GetGUID()) return;
+                if (concAura && concAura->GetCasterGUID() == me->GetGUID()) return;
+
+                if ((master->getClass() == BOT_CLASS_MAGE ||
+                    master->getClass() == BOT_CLASS_PRIEST ||
+                    master->getClass() == BOT_CLASS_WARLOCK ||
+                    master->getClass() == BOT_CLASS_DRUID || devAura) &&
+                    !concAura &&
+                    doCast(me, CONCENTRATION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+                if (!devAura && doCast(me, DEVOTION_AURA))
+                {
+                    /*GC_Timer = 800;*/
+                    return;
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || target->isDead() || GC_Timer > diff || Rand() > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+            if (me->GetExactDist(target) > 30) return false;
+            //if (HasAuraName(target, BLESSING_OF_WISDOM_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_KINGS_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_SANCTUARY_1, me->GetGUID()) ||
+            //    HasAuraName(target, BLESSING_OF_MIGHT_1, me->GetGUID()))
+            //    return false;
+            //if (HasAuraName(target, "Greater Blessing of Wisdom", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Might", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Kings", me->GetGUID()) ||
+            //    HasAuraName(target, "Greater Blessing of Sanctuary", me->GetGUID()))
+            //    return false;
+
+            uint32 mask = GetBlessingsMask(target);
+
+            //already has my blessing
+            if (mask & SPECIFIC_BLESSING_MY_BLESSING)
+                return false;
+
+            uint32 BLESSING_OF_WISDOM = GetSpell(BLESSING_OF_WISDOM_1);
+            uint32 BLESSING_OF_KINGS = GetSpell(BLESSING_OF_KINGS_1);
+            uint32 BLESSING_OF_SANCTUARY = GetSpell(BLESSING_OF_SANCTUARY_1);
+            uint32 BLESSING_OF_MIGHT = GetSpell(BLESSING_OF_MIGHT_1);
+
+            bool wisdom = (mask & SPECIFIC_BLESSING_WISDOM);
+            bool kings = (mask & SPECIFIC_BLESSING_KINGS);
+            bool sanctuary = (mask & SPECIFIC_BLESSING_SANCTUARY);
+            bool might = (mask & SPECIFIC_BLESSING_MIGHT);
+
+            //bool wisdom = HasAuraName(target, BLESSING_OF_WISDOM_1) || HasAuraName(target, GREATER_BLESSING_OF_WISDOM_1);
+            //bool kings = HasAuraName(target, BLESSING_OF_KINGS_1) || HasAuraName(target, GREATER_BLESSING_OF_KINGS_1);
+            //bool sanctuary = HasAuraName(target, BLESSING_OF_SANCTUARY_1) || HasAuraName(target, GREATER_BLESSING_OF_SANCTUARY_1);
+            //bool might = (HasAuraName(target, BLESSING_OF_MIGHT_1) || HasAuraName(target, GREATER_BLESSING_OF_MIGHT_1) || HasAuraName(target, BATTLESHOUT_1));
+
+            uint8 Class = 0;
+            if (target->GetTypeId() == TYPEID_PLAYER)
+                Class = target->getClass();
+            else if (Creature* cre = target->ToCreature())
+                Class = cre->GetBotAI() ? cre->GetBotAI()->GetPlayerClass() : cre->getClass();
+
+            switch (Class)
+            {
+                case BOT_CLASS_PRIEST:
+                    if (BLESSING_OF_WISDOM && !wisdom && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    break;
+                case BOT_CLASS_DEATH_KNIGHT:
+                case BOT_CLASS_WARRIOR:
+                case BOT_CLASS_PALADIN:
+                case BOT_CLASS_ROGUE:
+                case BOT_CLASS_HUNTER:
+                case BOT_CLASS_SHAMAN:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    break;
+                default:
+                    if (BLESSING_OF_KINGS && !kings && doCast(target, BLESSING_OF_KINGS))
+                        return true;
+                    else if (BLESSING_OF_WISDOM && !wisdom && target->getPowerType() == POWER_MANA && doCast(target, BLESSING_OF_WISDOM))
+                        return true;
+                    else if (BLESSING_OF_SANCTUARY && !sanctuary && doCast(target, BLESSING_OF_SANCTUARY))
+                        return true;
+                    else if (BLESSING_OF_MIGHT && !might && doCast(target, BLESSING_OF_MIGHT))
+                        return true;
+                    break;
+            }
+            return false;
+        }
+
+        void Repentance(uint32 diff, Unit* target = NULL)
+        {
+            temptimer = GC_Timer;
+            if (target)
+            {
+                if (IsSpellReady(REPENTANCE_1, diff, false, 25000) && doCast(target, GetSpell(REPENTANCE_1)))
+                {}
+            }
+            else if (IsSpellReady(REPENTANCE_1, diff, false))
+            {
+                Unit* u = FindStunTarget();
+                if (u && u->GetVictim() != me && doCast(u, GetSpell(REPENTANCE_1)))
+                {}
+            }
+            GC_Timer = temptimer;
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (IsCasting())
+                return;
+            if (Rand() > 60)
+                return;
+
+            Unit* target = IsSpellReady(REPENTANCE_1, diff, false, 25000) ? FindCastingTarget(20, 0, false, REPENTANCE_1) : NULL;
+            if (target)
+                Repentance(diff, target); //first check repentance
+            else if (IsSpellReady(TURN_EVIL_1, diff, false, 1500))
+            {
+                target = FindCastingTarget(20, 0, false, TURN_EVIL_1);
+                temptimer = GC_Timer;
+                if (target && doCast(target, GetSpell(TURN_EVIL_1), true))
+                    GC_Timer = temptimer;
+            }
+            else if (IsSpellReady(HOLY_WRATH_1, diff, false, 8000) && HasRole(BOT_ROLE_DPS))
+            {
+                target = FindCastingTarget(8, 0, false, TURN_EVIL_1); //here we check target as with turn evil cuz of same requirements
+                temptimer = GC_Timer;
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                    GC_Timer = temptimer;
+            }
+            else if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff, /*true*/false, 7000))
+            {
+                target = FindCastingTarget(10);
+                if (target && doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                {}
+            }
+        }
+
+        void TurnEvil(uint32 diff)
+        {
+            if (!IsSpellReady(TURN_EVIL_1, diff) || IsCasting() || Rand() > 50 ||
+                FindAffectedTarget(GetSpell(TURN_EVIL_1), me->GetGUID(), 50))
+                return;
+            Unit* target = FindUndeadCCTarget(20, TURN_EVIL_1);
+            if (target &&
+                (target != me->GetVictim() || GetHealthPCT(me) < 70 || target->GetVictim() == master) &&
+                doCast(target, GetSpell(TURN_EVIL_1), true))
+                return;
+            else
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                !CCed(opponent) &&
+                opponent->GetVictim() && !IsTank(opponent->GetVictim()) && opponent->GetVictim() != me &&
+                GetHealthPCT(me) < 90 &&
+                doCast(opponent, GetSpell(TURN_EVIL_1), true))
+                return;
+        }
+
+        void Wrath(uint32 diff)
+        {
+            if (!IsSpellReady(HOLY_WRATH_1, diff) || !HasRole(BOT_ROLE_DPS) || Rand() > 50)
+                return;
+            if ((opponent->GetCreatureType() == CREATURE_TYPE_UNDEAD || opponent->GetCreatureType() == CREATURE_TYPE_DEMON) &&
+                me->GetExactDist(opponent) <= 8 && doCast(me, GetSpell(HOLY_WRATH_1)))
+            {}
+            else
+            {
+                Unit* target = FindUndeadCCTarget(8, GetSpell(HOLY_WRATH_1));
+                if (target && doCast(me, GetSpell(HOLY_WRATH_1)))
+                {}
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+            TurnEvil(diff);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //HAMMER OF WRATH //custom GCD check
+            if (IsSpellReady(HOW_1, diff, false) && GC_Timer <= 300 && HasRole(BOT_ROLE_DPS) && Rand() < 30 && GetHealthPCT(opponent) < 19 &&
+                me->GetExactDist(opponent) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(HOW_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HAND OF RECKONING //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(HANDOFRECKONING_1, diff, false) && me->GetExactDist(opponent) < 30 &&
+                HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) && Rand() < 50 &&
+                (IsInBotParty(u) || IsTank()))
+            {
+                Creature* cre = opponent->ToCreature();
+                temptimer = GC_Timer;
+                if (((cre && cre->isWorldBoss() && !IsMeleeClass(u->getClass())) ||
+                    GetHealthPCT(u) < GetHealthPCT(me) - 5 || IsTank()) &&
+                    doCast(opponent, GetSpell(HANDOFRECKONING_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(HAMMER_OF_JUSTICE_1, diff) && !CCed(opponent) &&
+                me->GetExactDist(opponent) < 10 && Rand() < 20)
+            {
+                if (doCast(opponent, GetSpell(HAMMER_OF_JUSTICE_1)))
+                    return;
+            }
+
+            if (IsSpellReady(JUDGEMENT_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 10 &&
+                Rand() < 50 && me->HasAura(GetSpell(SEAL_OF_COMMAND_1)))
+            {
+                if (doCast(opponent, GetSpell(JUDGEMENT_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONSECRATION_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 7 &&
+                !opponent->isMoving() && Rand() < 50)
+            {
+                if (doCast(me, GetSpell(CONSECRATION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(AVENGING_WRATH_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                opponent->GetHealth() > (master->GetMaxHealth()*2)/3 && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(AVENGING_WRATH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (IsSpellReady(CRUSADER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetDistance(opponent) < 5)
+            {
+                if (doCast(opponent, GetSpell(CRUSADER_STRIKE_1)))
+                    return;
+            }
+
+            if (IsSpellReady(EXORCISM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 30 &&
+                (!IsTank() || opponent->GetVictim() == me || opponent->IsVehicle() || opponent->ToPlayer()))
+            {
+                if (doCast(opponent, GetSpell(EXORCISM_1), me->HasAura(THE_ART_OF_WAR_BUFF)))
+                    return;
+            }
+
+            Wrath(diff);
+
+            if (IsSpellReady(DIVINE_STORM_1, diff) && HasRole(BOT_ROLE_DPS) && me->GetExactDist(opponent) < 7)
+            {
+                if (doCast(opponent, GetSpell(DIVINE_STORM_1)))
+                    return;
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Fanaticism: 18% additional critical chance for all Judgements (not shure which check is right)
+                if (lvl >= 45 && (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT || spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT))
+                    aftercrit += 18.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+            //Sanctity of Battle: 15% bonus damage for Exorcism and Crusader Strike
+            if (lvl >= 25 && spellId == GetSpell(EXORCISM_1))
+                pctbonus += 0.15f;
+            //The Art of War (damage part): 10% bonus damage for Judgements, Crusader Strike and Divine Storm
+            if (lvl >= 40 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellId == GetSpell(CRUSADER_STRIKE_1) ||
+                spellId == GetSpell(DIVINE_STORM_1)))
+                pctbonus += 0.1f;
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Sanctified Wrath: 50% additional critical chance for Hammer of Wrath
+                if (lvl >= 45 && spellId == GetSpell(HOW_1))
+                    aftercrit += 50.f;
+                //Holy Power: 5% additional critical chance for Holy spells
+                if (lvl >= 35 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_HOLY))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            //if (crit)
+            //{
+            //}
+
+            //Judgements of the Pure (damage part): 25% bonus damage for Judgements and Seals
+            if (lvl >= 50 &&
+                (spellInfo->GetCategory() == SPELLCATEGORY_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_JUDGEMENT ||
+                spellInfo->GetSpellSpecific() == SPELL_SPECIFIC_SEAL ||
+                spellId == JUDGEMENT_OF_COMMAND_DAMAGE))
+                pctbonus += 0.25f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType /*damagetype*/, uint32 /*stack*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Light: 12% bonus healing for Holy Light, Flash of Light and Holy Shock
+            if (lvl >= 15 &&
+                (spellId == GetSpell(HOLY_LIGHT_1) ||
+                spellId == GetSpell(FLASH_OF_LIGHT_1) ||
+                spellId == GetSpell(HOLY_SHOCK_1)))
+                pctbonus += 0.12f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Sanctified Light: 6% additional critical chance for Holy Light and Holy Shock
+            if (lvl >= 30 && (spellId == GetSpell(HOLY_LIGHT_1) || spellId == GetSpell(HOLY_SHOCK_1)))
+                aftercrit += 6.f;
+            //Holy Power: 5% additional critical chance for Holy spells
+            if (lvl >= 35 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                aftercrit += 5.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if ((spellId == GetSpell(EXORCISM_1) || spellId == GetSpell(FLASH_OF_LIGHT_1)) &&
+                me->HasAura(THE_ART_OF_WAR_BUFF))
+            {
+                //Art of War: consume buff
+                me->RemoveAura(THE_ART_OF_WAR_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            if (spellId == GetSpell(HOF_1))
+            {
+                //Guardian's Favor part 2 (handled separately)
+                if (Aura* hof = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = hof->GetDuration() + 4000;
+                    hof->SetDuration(dur);
+                    hof->SetMaxDuration(dur);
+                }
+            }
+
+            //if (!IAmFree())
+            {
+                if (spellId == GetSpell(BLESSING_OF_KINGS_1) || spellId == GetSpell(BLESSING_OF_MIGHT_1) ||
+                    spellId == GetSpell(BLESSING_OF_WISDOM_1) || spellId == GetSpell(BLESSING_OF_SANCTUARY_1))
+                {
+                    //Blessings duration 1h
+                    if (Aura* bless = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = HOUR * IN_MILLISECONDS;
+                        bless->SetDuration(dur);
+                        bless->SetMaxDuration(dur);
+                    }
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            //Custom OnHit() handlers
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //The Art of War: 20% on autoattack
+                if (me->getLevel() >= 33)
+                    if (urand(1,100) <= 20)
+                        me->CastSpell(me, THE_ART_OF_WAR_BUFF, true);
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void HealReceived(Unit* healer, uint32& heal)
+        {
+            //Spiritual Attunement
+            if (heal && me->getLevel() >= 40 && healer != me && HasRole(BOT_ROLE_TANK) && GetLostHP(me))
+            {
+                if (int32 basepoints = int32(CalculatePct(std::min<int32>(heal, GetLostHP(me)), 10)))
+                    me->CastCustomSpell(me, SPIRITUAL_ATTUNEMENT_ENERGIZE, &basepoints, NULL, NULL, true);
+            }
+
+            //bot_ai::HealReceived(healer, heal);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(FLASH_OF_LIGHT_1);
+            InitSpellMap(HOLY_LIGHT_1);
+            InitSpellMap(LAY_ON_HANDS_1);
+            InitSpellMap(SACRED_SHIELD_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(HOLY_SHOCK_1) : RemoveSpell(HOLY_SHOCK_1);
+            InitSpellMap(CLEANSE_1);
+            InitSpellMap(REDEMPTION_1);
+            InitSpellMap(HAMMER_OF_JUSTICE_1);
+  /*Talent*/lvl >= 45 ? InitSpellMap(REPENTANCE_1) : RemoveSpell(REPENTANCE_1);
+            InitSpellMap(TURN_EVIL_1);
+            InitSpellMap(HOLY_WRATH_1);
+            InitSpellMap(EXORCISM_1);
+  /*Talent*/lvl >= 25 ? InitSpellMap(SEAL_OF_COMMAND_1) : RemoveSpell(SEAL_OF_COMMAND_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(CRUSADER_STRIKE_1) : RemoveSpell(CRUSADER_STRIKE_1);
+            InitSpellMap(JUDGEMENT_1);
+            InitSpellMap(CONSECRATION_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DIVINE_STORM_1) : RemoveSpell(DIVINE_STORM_1);
+            InitSpellMap(HOW_1);
+            InitSpellMap(AVENGING_WRATH_1);
+            InitSpellMap(BLESSING_OF_MIGHT_1);
+            InitSpellMap(BLESSING_OF_WISDOM_1);
+            InitSpellMap(BLESSING_OF_KINGS_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(BLESSING_OF_SANCTUARY_1) : RemoveSpell(BLESSING_OF_SANCTUARY_1);
+            InitSpellMap(DEVOTION_AURA_1);
+            InitSpellMap(CONCENTRATION_AURA_1);
+            InitSpellMap(DIVINE_PLEA_1);
+            InitSpellMap(HAND_OF_PROTECTION_1);
+            InitSpellMap(HOF_1);
+            InitSpellMap(HOS_1);
+            InitSpellMap(HANDOFRECKONING_1);
+
+ /*SPECIAL*/InitSpellMap(ARDENT_DEFENDER_HEAL, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            //RefreshAura(SPELLDMG, /*level >= 78 ? 5 : level >= 75 ? 4 */level >= 55 ? 3 : level >= 35 ? 2 : level >= 15 ? 1 : 0);
+            //RefreshAura(SPELLDMG2, level >= 55 ? 3 : level >= 35 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(PURE1, level >= 55 ? 1 : 0);
+            RefreshAura(WISE, level >= 35 ? 1 : 0);
+            RefreshAura(RECKONING5, level >= 50 ? 1 : 0);
+            RefreshAura(RECKONING4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(RECKONING3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(RECKONING2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(RECKONING1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(VENGEANCE3, level >= 30 ? 1 : 0);
+            RefreshAura(VENGEANCE2, level >= 27 && level < 30 ? 1 : 0);
+            RefreshAura(VENGEANCE1, level >= 25 && level < 27 ? 1 : 0);
+            RefreshAura(SHOFL3, level >= 60 ? 1 : 0);
+            RefreshAura(SHOFL2, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(SHOFL1, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(SACRED_CLEANSING, level >= 45 ? 1 : 0);
+            RefreshAura(DIVINE_PURPOSE, level >= 35 ? 1 : 0);
+            RefreshAura(VINDICATION2, level >= 25 ? 1 : 0);
+            RefreshAura(VINDICATION1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(LAYHANDS, level >= 30 ? 1 : 0);
+            RefreshAura(FANATICISM, level >= 20 ? 2 : 0);
+            RefreshAura(ARDENT_DEFENDER, level >= 40 ? 1 : 0);
+            RefreshAura(ILLUMINATION, level >= 20 ? 1 : 0);
+            RefreshAura(INFUSION_OF_LIGHT, level >= 55 ? 1 : 0); //NYI
+            RefreshAura(REDOUBT3, level >= 68 ? 2 : level >= 55 ? 1 : 0);
+            RefreshAura(REDOUBT2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(REDOUBT1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(GLYPH_HOLY_LIGHT, level >= 15 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case FLASH_OF_LIGHT_1:
+                case HOLY_LIGHT_1:
+                case LAY_ON_HANDS_1:
+                case HOF_1:
+                case SACRED_SHIELD_1:
+                case HOLY_SHOCK_1:
+                case CLEANSE_1:
+                case HAND_OF_PROTECTION_1:
+                case HOS_1:
+                case SEAL_OF_COMMAND_1:
+                case DIVINE_PLEA_1:
+                case AVENGING_WRATH_1:
+                case BLESSING_OF_MIGHT_1:
+                case BLESSING_OF_WISDOM_1:
+                case BLESSING_OF_KINGS_1:
+                case BLESSING_OF_SANCTUARY_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+
+        //uint32 GetBlessingsMask(Unit const*) const
+        //Scans target for auras which are related to paladin's blessings
+        //(even if aura is just incompatible with one)
+        //returns applied blessings mask
+        //used for finding out which blessings target lacks
+        uint32 GetBlessingsMask(Unit const* target) const
+        {
+            uint32 mask = 0;
+
+            bool blessing;
+            Unit::AuraApplicationMap const& aurapps = target->GetAppliedAuras();
+            for (Unit::AuraApplicationMap::const_iterator itr = aurapps.begin(); itr != aurapps.end(); ++itr)
+            {
+                blessing = true;
+                switch (itr->second->GetBase()->GetSpellInfo()->GetFirstRankSpell()->Id)
+                {
+                    case BLESSING_OF_WISDOM_1:
+                    case GREATER_BLESSING_OF_WISDOM_1:
+                        mask |= SPECIFIC_BLESSING_WISDOM;
+                        break;
+                    case BLESSING_OF_KINGS_1:
+                    case GREATER_BLESSING_OF_KINGS_1:
+                        mask |= SPECIFIC_BLESSING_KINGS;
+                        break;
+                    case BLESSING_OF_SANCTUARY_1:
+                    case GREATER_BLESSING_OF_SANCTUARY_1:
+                        mask |= SPECIFIC_BLESSING_SANCTUARY;
+                        break;
+                    case BLESSING_OF_MIGHT_1:
+                    case GREATER_BLESSING_OF_MIGHT_1:
+                    case BATTLESHOUT_1:
+                        mask |= SPECIFIC_BLESSING_MIGHT;
+                        break;
+                    default:
+                        blessing = false; //next aura
+                        break;
+                }
+
+                if (blessing && itr->second->GetBase()->GetCasterGUID() == me->GetGUID())
+                    mask |= SPECIFIC_BLESSING_MY_BLESSING;
+            }
+
+            return mask;
+        }
+
+        enum PaladinBaseSpells// all orignals
+        {
+            FLASH_OF_LIGHT_1                    = 19750,
+            HOLY_LIGHT_1                        = 635,
+            LAY_ON_HANDS_1                      = 633,
+            REDEMPTION_1                        = 7328,
+            HOF_1  /*Hand of Freedom*/          = 1044,
+            SACRED_SHIELD_1                     = 53601,
+            HOLY_SHOCK_1                        = 20473,
+            CLEANSE_1                           = 4987,
+            HAND_OF_PROTECTION_1                = 1022,
+            HOS_1 /*Hand of salvation*/         = 1038,
+            SEAL_OF_COMMAND_1                   = 20375,
+            HANDOFRECKONING_1                   = 62124,
+            DIVINE_PLEA_1                       = 54428,
+            REPENTANCE_1                        = 20066,
+            TURN_EVIL_1                         = 10326,
+            CRUSADER_STRIKE_1                   = 35395,
+            JUDGEMENT_1                         = 20271,
+            CONSECRATION_1                      = 26573,
+            HAMMER_OF_JUSTICE_1                 = 853,
+            DIVINE_STORM_1                      = 53385,
+            HOW_1   /*Hammer of Wrath*/         = 24275,
+            EXORCISM_1                          = 879,
+            HOLY_WRATH_1                        = 2812,
+            AVENGING_WRATH_1                    = 31884,
+            BLESSING_OF_MIGHT_1                 = 19740,
+            BLESSING_OF_WISDOM_1                = 19742,
+            BLESSING_OF_KINGS_1                 = 20217,
+            BLESSING_OF_SANCTUARY_1             = 20911,
+            DEVOTION_AURA_1                     = 465,
+            CONCENTRATION_AURA_1                = 19746
+        };
+        enum PaladinPassives
+        {
+        //Talents
+            DIVINE_PURPOSE                      = 31872,
+            PURE1/*Judgements of the Pure*/      = 54155,
+            WISE/*Judgements of the Wise*/      = 31878,
+            SACRED_CLEANSING                    = 53553,//rank 3
+            RECKONING1                          = 20177,
+            RECKONING2                          = 20179,
+            RECKONING3                          = 20181,
+            RECKONING4                          = 20180,
+            RECKONING5                          = 20182,
+            VINDICATION1                        = 9452 ,//rank 1
+            VINDICATION2                        = 26016,//rank 2
+            LAYHANDS  /*Improved LOH rank 2*/   = 20235,
+            FANATICISM                          = 31881,//rank 3
+            //RIGHTEOUS_VENGEANCE1                = 53380,//rank 1
+            //RIGHTEOUS_VENGEANCE2                = 53381,//rank 2
+            //RIGHTEOUS_VENGEANCE3                = 53382,//rank 3
+            VENGEANCE1                          = 20049,//rank 1
+            VENGEANCE2                          = 20056,//rank 2
+            VENGEANCE3                          = 20057,//rank 3
+            SHOFL1      /*Sheath of Light*/     = 53501,//rank 1
+            SHOFL2                              = 53502,//rank 2
+            SHOFL3                              = 53503,//rank 3
+            ARDENT_DEFENDER                     = 31852,//rank 3
+            ILLUMINATION                        = 20215,//rank 5
+            INFUSION_OF_LIGHT                   = 53576,//rank 2
+            REDOUBT1                            = 20127,//rank 3
+            REDOUBT2                            = 20130,//rank 3
+            REDOUBT3                            = 20135,//rank 3
+        //Glyphs
+            GLYPH_HOLY_LIGHT                    = 54937
+        //other
+            //SPELLDMG/*Arcane Instability-mage*/ = 15060,//rank3 3% dam/crit
+            //SPELLDMG2/*Earth and Moon - druid*/ = 48511 //rank3 6% dam
+        };
+
+        enum PaladinSpecial
+        {
+            NOAURA                              = 0,
+            DEVOTIONAURA                        = 1,
+            CONCENTRATIONAURA                   = 2,
+
+            THE_ART_OF_WAR_BUFF                 = 59578,
+            FORBEARANCE_AURA                    = 25771,
+
+            GREATER_BLESSING_OF_MIGHT_1         = 25782,
+            GREATER_BLESSING_OF_WISDOM_1        = 25894,
+            GREATER_BLESSING_OF_KINGS_1         = 25898,
+            GREATER_BLESSING_OF_SANCTUARY_1     = 25899,
+            BATTLESHOUT_1                       = 6673,
+
+            ARDENT_DEFENDER_HEAL                = 66235,
+            JUDGEMENT_OF_COMMAND_DAMAGE         = 20467,
+            SPIRITUAL_ATTUNEMENT_ENERGIZE       = 31786,
+
+            SPECIFIC_BLESSING_WISDOM            = 0x01,
+            SPECIFIC_BLESSING_KINGS             = 0x02,
+            SPECIFIC_BLESSING_SANCTUARY         = 0x04,
+            SPECIFIC_BLESSING_MIGHT             = 0x08,
+            SPECIFIC_BLESSING_MY_BLESSING       = 0x10
+        };
+    };
+};
+
+void AddSC_paladin_bot()
+{
+    new paladin_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_priest_ai.cpp b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
new file mode 100644
index 0000000..47cadc7
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_priest_ai.cpp
@@ -0,0 +1,1066 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+//#include "WorldSession.h"
+/*
+Priest NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - Around 50%
+TODO: maybe remove Divine Spirit or so, too much buffs
+*/
+class priest_bot : public CreatureScript
+{
+public:
+    priest_bot() : CreatureScript("priest_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new priest_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct priest_botAI : public bot_minion_ai
+    {
+        priest_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_PRIEST;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_PRIEST) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        bool MassGroupHeal(Player* player, uint32 diff)
+        {
+            if (IAmFree() || !player->GetGroup()) return false;
+            if (IsCasting()) return false;
+            if (Rand() > 35) return false;
+
+            if (IsSpellReady(DIVINE_HYMN_1, diff, false))
+            {
+                Group* gr = player->GetGroup();
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->FindMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 35) continue;
+                        uint8 pct = 50 + tPlayer->getAttackers().size()*10;
+                        pct = pct < 80 ? pct : 80;
+                        if (GetHealthPCT(tPlayer) < pct && GetLostHP(tPlayer) > 4000)
+                            ++LHPcount;
+                    }
+                    if (LHPcount > 1)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && GetHealthPCT(bot) < 40 && me->GetExactDist(bot) < 30)
+                            ++LHPcount;
+                        if (LHPcount > 1)
+                            break;
+                    }
+                }
+                if (LHPcount > 1 && doCast(me, GetSpell(DIVINE_HYMN_1)))
+                    return true;
+            }
+            if (GetSpell(PRAYER_OF_HEALING_1))
+            {
+                Group* gr = player->GetGroup();
+                Unit* castTarget = NULL;
+                uint8 LHPcount = 0;
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    uint8 lowestPCT = 100;
+                    Player* tPlayer = itr->GetSource();
+                    if (!tPlayer || !tPlayer->IsInWorld() || me->GetMap() != tPlayer->GetMap() ||
+                        tPlayer->IsBeingTeleported() || tPlayer->isPossessed() || tPlayer->IsCharmed()) continue;
+                    if (tPlayer->IsAlive())
+                    {
+                        if (me->GetExactDist(tPlayer) > 25) continue;
+                        if (GetHealthPCT(tPlayer) < 85)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(tPlayer) < lowestPCT)
+                            lowestPCT = GetHealthPCT(tPlayer);
+                            castTarget = tPlayer;
+                        }
+                    }
+                    if (LHPcount > 2)
+                        break;
+                    if (!tPlayer->HaveBot()) continue;
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && GetHealthPCT(bot) < 70 && me->GetExactDist(bot) < 15)
+                        {
+                            ++LHPcount;
+                            if (GetHealthPCT(bot) < lowestPCT)
+                            lowestPCT = GetHealthPCT(bot);
+                            castTarget = bot;
+                        }
+                        if (LHPcount > 2)
+                            break;
+                    }
+                }
+
+                if (LHPcount > 2 && castTarget && doCast(castTarget, GetSpell(PRAYER_OF_HEALING_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        bool ShieldTarget(Unit* target, uint32 diff)
+        {
+            if (!IsSpellReady(PW_SHIELD_1, diff, false) || IsCasting() || Rand() > 50)
+                return false;
+            if (me->GetExactDist(target) > 40)
+                return false;
+            if (target->getAttackers().empty() && GetHealthPCT(target) > 33 &&
+                !target->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE))
+                return false;
+            if (target->HasAura(WEAKENED_SOUL_DEBUFF) || HasAuraName(target, PW_SHIELD_1))
+                return false;
+
+            if (doCast(target, GetSpell(PW_SHIELD_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+            return false;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            Disperse(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+            DoDevCheck(diff);
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 33)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            //check possible fear
+            doDefend(diff);
+            //buff and heal master's group
+            MassGroupHeal(master, diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, GetSpell(DISPEL_MAGIC_1), diff);
+            CureGroup(master, GetSpell(CURE_DISEASE_1), diff);
+            //ShieldGroup(master);
+            if (master->IsInCombat() || me->IsInCombat())
+            {
+                CheckDispel(diff);
+                CheckSilence(diff);
+            }
+
+            if (me->IsInCombat())
+                CheckShackles(diff);
+            else
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_PRIEST))
+                return;
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            if (GetHealthPCT(master) > 90 && GetManaPCT(me) > 35 && GetHealthPCT(me) > 90 &&
+                (m_attackers.size() < 4 || b_attackers.size() + m_attackers.size() < 3) &&
+                !IsCasting())
+                //general rule
+            {
+                opponent = me->GetVictim();
+                if (opponent)
+                {
+                    if (!IsCasting())
+                        StartAttack(opponent);
+                }
+                else
+                    return;
+                float dist = me->GetExactDist(opponent);
+                if (HasRole(BOT_ROLE_DPS) && dist < 30)
+                {
+                    if (IsSpellReady(SW_DEATH_1, diff, false) && Rand() < 50 &&
+                        (GetHealthPCT(opponent) < 15 || opponent->GetHealth() < me->GetMaxHealth()/6) &&
+                        doCast(opponent, GetSpell(SW_DEATH_1)))
+                        return;
+                    if (IsSpellReady(SW_PAIN_1, diff) && Rand() < 25 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(SW_PAIN_1)))
+                        return;
+                    if (IsSpellReady(VAMPIRIC_TOUCH_1, diff) && Rand() < 50 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/4 &&
+                        !HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(VAMPIRIC_TOUCH_1)))
+                        return;
+                    if (IsSpellReady(DEVOURING_PLAGUE_1, diff) && !Devcheck && Rand() < 30 &&
+                        opponent->GetHealth() > me->GetMaxHealth()/3 &&
+                        !HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()) &&
+                        doCast(opponent, GetSpell(DEVOURING_PLAGUE_1)))
+                        return;
+                    if (IsSpellReady(MIND_BLAST_1, diff) && Rand() < 35 &&
+                        (!GetSpell(VAMPIRIC_TOUCH_1) || HasAuraName(opponent, VAMPIRIC_TOUCH_1, me->GetGUID())) &&
+                        doCast(opponent, GetSpell(MIND_BLAST_1)))
+                        return;
+                    if (IsSpellReady(MIND_FLAY_1, diff, false) && Rand() < 20 &&
+                        (opponent->isMoving() || opponent->GetHealth() < me->GetMaxHealth()/5 ||
+                        (HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) && HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))) &&
+                        doCast(opponent, GetSpell(MIND_FLAY_1)))
+                        return;
+                    if (IsSpellReady(MIND_SEAR_1, diff, false) && !opponent->isMoving() && dist < 35 && Rand() < 50 &&
+                        HasAuraName(opponent, SW_PAIN_1, me->GetGUID()) &&
+                        HasAuraName(opponent, DEVOURING_PLAGUE_1, me->GetGUID()))
+                    {
+                        if (Unit* u = FindSplashTarget(30, opponent))
+                            if (doCast(u, GetSpell(MIND_SEAR_1)))
+                                return;
+                    }
+                }//endif opponent
+            }//endif damage
+            //check horror after dots/damage
+            if (IsSpellReady(PSYCHIC_HORROR_1, diff, false) &&
+                opponent->GetCreatureType() != CREATURE_TYPE_UNDEAD &&
+                opponent->GetHealth() > me->GetMaxHealth()/5 && !CCed(opponent) && Rand() < 30 &&
+                me->GetExactDist(opponent) < 30 && !HasAuraName(opponent, PSYCHIC_HORROR_1))
+            {
+                if (doCast(opponent, GetSpell(PSYCHIC_HORROR_1)))
+                    return;
+            }
+        }//end UpdateAI
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 98)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //GUARDIAN SPIRIT
+            if (IsSpellReady(GUARDIAN_SPIRIT_1, diff, false) && !IAmFree() && target->IsInCombat() &&
+                !target->getAttackers().empty() && hp < (5 + std::min(20, uint8(target->getAttackers().size())*5)) &&
+                IsInBotParty(target) &&
+                Rand() < 80 && !target->HasAura(GetSpell(GUARDIAN_SPIRIT_1)))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(GUARDIAN_SPIRIT_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Guardian Spirit on you!", target->ToPlayer());
+                    else if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardian Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str(), master);
+                    }
+
+                    return true;
+                }
+            }
+
+            if (IsCasting()) return false;
+
+            //PAIN SUPPRESSION
+            if (hp < 35 && IsSpellReady(PAIN_SUPPRESSION_1, diff, false) &&
+                (target->IsInCombat() || !target->getAttackers().empty()) && Rand() < 50 &&
+                !target->HasAura(GetSpell(PAIN_SUPPRESSION_1)))
+            {
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                temptimer = GC_Timer;
+                if (doCast(target, GetSpell(PAIN_SUPPRESSION_1)))
+                {
+                    GC_Timer = temptimer;
+                    if (target->GetTypeId() == TYPEID_PLAYER)
+                        BotWhisper("Pain Suppression on you!", target->ToPlayer());
+                    else if (!IAmFree())
+                    {
+                        std::ostringstream msg;
+                        msg << "Guardin Spirit on " << (target == me ? "myself" : target->GetName()) << '!';
+                        BotWhisper(msg.str().c_str(), master);
+                    }
+
+                    return true;
+                }
+            }
+
+            //Now Heals Requires GCD
+            if ((hp < 80 || !target->getAttackers().empty()) &&
+                ShieldTarget(target, diff))
+                return true;
+
+            //PENANCE/Greater Heal
+            if (hp < 75 || GetLostHP(target) > 4000)
+            {
+                if (IsSpellReady(PENANCE_1, diff, false) && !me->isMoving() && Rand() < 80 &&
+                    (target->GetTypeId() != TYPEID_PLAYER ||
+                    !(target->ToPlayer()->IsCharmed() || target->ToPlayer()->isPossessed())) &&
+                    doCast(target, GetSpell(PENANCE_1)))
+                    return true;
+                else if (HEAL && Heal_Timer <= diff && GC_Timer <= diff && hp > 50 && Rand() < 70 &&
+                    doCast(target, HEAL))
+                {
+                    Heal_Timer = 2500;
+                    return true;
+                }
+            }
+            //Flash Heal
+            if (IsSpellReady(FLASH_HEAL_1, diff) &&
+                ((hp > 75 && hp < 90) || hp < 50 || GetLostHP(target) > 1500) &&
+                doCast(target, GetSpell(FLASH_HEAL_1)))
+                return true;
+            //maintain HoTs
+            Unit* u = target->GetVictim();
+            Creature* boss = u && u->ToCreature() && u->ToCreature()->isWorldBoss() ? u->ToCreature() : NULL;
+            bool tanking = IsTank(target) && boss;
+            //Renew
+            if (IsSpellReady(RENEW_1, diff) &&
+                ((hp < 98 && hp > 70) || GetLostHP(target) > 500 || tanking) &&
+                !HasAuraName(target, RENEW_1, me->GetGUID()) &&
+                doCast(target, GetSpell(RENEW_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            return false;
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!target || !target->IsInWorld() || target->isDead() ||
+                GC_Timer > diff || me->GetExactDist(target) > 30 || Rand() > 20)
+                return false;
+
+            if (IsSpellReady(FEAR_WARD_1, diff, false) &&
+                !target->HasAuraTypeWithMiscvalue(SPELL_AURA_MECHANIC_IMMUNITY, MECHANIC_FEAR) &&
+                doCast(target, GetSpell(FEAR_WARD_1)))
+            {
+                GC_Timer = 800;
+                return true;
+            }
+
+            if (target == me)
+            {
+                uint32 INNER_FIRE = GetSpell(INNER_FIRE_1);
+                if (INNER_FIRE && !me->HasAura(INNER_FIRE) &&
+                    doCast(me, INNER_FIRE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+                uint32 VAMPIRIC_EMBRACE = GetSpell(VAMPIRIC_EMBRACE_1);
+                if (VAMPIRIC_EMBRACE && !me->HasAura(VAMPIRIC_EMBRACE) &&
+                    doCast(me, VAMPIRIC_EMBRACE))
+                {
+                    GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (uint32 PW_FORTITUDE = GetSpell(PW_FORTITUDE_1))
+            {
+                if (!HasAuraName(target, PW_FORTITUDE) &&
+                    doCast(target, PW_FORTITUDE))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 SHADOW_PROTECTION = GetSpell(SHADOW_PROTECTION_1))
+            {
+                if (!HasAuraName(target, SHADOW_PROTECTION) &&
+                    doCast(target, SHADOW_PROTECTION))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+            if (uint32 DIVINE_SPIRIT = GetSpell(DIVINE_SPIRIT_1))
+            {
+                if (!HasAuraName(target, DIVINE_SPIRIT) &&
+                    doCast(target, DIVINE_SPIRIT))
+                {
+                    /*GC_Timer = 800;*/
+                    return true;
+                }
+            }
+
+            return false;
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(RESURRECTION_1), master);
+
+            //if (Feasting())
+            //    return;
+
+            //if (BuffTarget(master, diff))
+            //    return;
+            //if (BuffTarget(me, diff))
+            //    return;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (CheckDispelTimer > diff || Rand() > 25 || IsCasting())
+                return;
+
+            uint32 DM = GetSpell(DISPEL_MAGIC_1);
+            uint32 MD = GetSpell(MASS_DISPEL_1);
+
+            if (!DM && !MD)
+                return;
+
+            if (Unit* target = FindHostileDispelTarget())
+            {
+                uint32 dm = DM && !target->IsImmunedToSpell(sSpellMgr->GetSpellInfo(DM)) ? DM : MD;
+                if (target && doCast(target, dm))
+                {
+                    CheckDispelTimer = 1000;
+                    GC_Timer = 800;
+                    return;
+                }
+            }
+
+            CheckDispelTimer = 2000; //fail
+        }
+
+        void CheckShackles(uint32 diff)
+        {
+            if (!IsSpellReady(SHACKLE_UNDEAD_1, diff) || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 SHACKLE_UNDEAD = GetSpell(SHACKLE_UNDEAD_1);
+            if (FindAffectedTarget(SHACKLE_UNDEAD, me->GetGUID()))
+            {
+                Shackle_Timer = 1500;
+                return;
+            }
+            Unit* target = FindUndeadCCTarget(30, SHACKLE_UNDEAD);
+            if (target && doCast(target, SHACKLE_UNDEAD))
+            {
+                Shackle_Timer = 3000;
+                GC_Timer = 800;
+            }
+        }
+
+        void CheckSilence(uint32 diff)
+        {
+            if (IsCasting()) return;
+            temptimer = GC_Timer;
+            if (IsSpellReady(SILENCE_1, diff, false))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(SILENCE_1)))
+                    {}
+            }
+            else if (IsSpellReady(PSYCHIC_HORROR_1, diff, false, 20000))
+            {
+                if (Unit* target = FindCastingTarget(30))
+                    if (doCast(target, GetSpell(PSYCHIC_HORROR_1)))
+                    {}
+            }
+            GC_Timer = temptimer;
+        }
+
+        void doDefend(uint32 diff)
+        {
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+
+            //fear master's attackers
+            if (IsSpellReady(PSYCHIC_SCREAM_1, diff, false))
+            {
+                if (!m_attackers.empty() && (!IsTank(master) || GetHealthPCT(master) < 75))
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 1 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+
+                // Defend myself (psychic horror)
+                if (!b_attackers.empty())
+                {
+                    uint8 tCount = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->ToCreature() && (*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) > 7) continue;
+                        if (CCed(*iter) && me->GetExactDist((*iter)) > 5) continue;
+                        if (me->IsValidAttackTarget(*iter))
+                            ++tCount;
+                    }
+                    if (tCount > 0 && doCast(me, GetSpell(PSYCHIC_SCREAM_1)))
+                        return;
+                }
+            }
+            // Heal myself
+            if (GetHealthPCT(me) < 98 && !b_attackers.empty())
+            {
+                if (ShieldTarget(me, diff)) return;
+
+                if (IsSpellReady(FADE_1, diff, false) && me->IsInCombat())
+                {
+                    if (b_attackers.empty()) return;
+                    uint8 Tattackers = 0;
+                    for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->isDead()) continue;
+                        if (!(*iter)->ToCreature()) continue;
+                        if (!(*iter)->CanHaveThreatList()) continue;
+                        if (me->GetExactDist((*iter)) < 15)
+                            Tattackers++;
+                    }
+                    if (Tattackers > 0)
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(FADE_1)))
+                        {
+                            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                                if ((*iter)->getThreatManager().getThreat(me) > 0.f)
+                                    (*iter)->getThreatManager().modifyThreatPercent(me, -50);
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                if (GetHealthPCT(me) < 90 && HealTarget(me, GetHealthPCT(me), diff))
+                    return;
+            }
+        }
+
+        void DoDevCheck(uint32 diff)
+        {
+            if (DevcheckTimer <= diff)
+            {
+                Devcheck = FindAffectedTarget(GetSpell(DEVOURING_PLAGUE_1), me->GetGUID());
+                DevcheckTimer = 5000;
+            }
+        }
+
+        void Disperse(uint32 diff)
+        {
+            if (!IsSpellReady(DISPERSION_1, diff) || IsCasting() || Rand() > 60)
+                return;
+            if ((me->getAttackers().size() > 3 && !IsSpellReady(FADE_1, diff, false) && GetHealthPCT(me) < 90) ||
+                (GetHealthPCT(me) < 20 && me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)) ||
+                (GetManaPCT(me) < 30) ||
+                (me->getAttackers().size() > 1 && me->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(DISPERSION_1)))
+                {}
+                GC_Timer = temptimer;
+                return;
+            }
+
+            SetSpellCooldown(DISPERSION_1, 2000); //fail
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //434 new
+                //Improved Fire Blast (part 1): 8% additional crit chance for Fire Blast
+                //if (lvl >= 11 && spellId == FLAMESTRIKE)
+                //    aftercrit += 8.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Ice Shards: 50% additional crit damage bonus for Frost spells
+                //else if (lvl >= 15 && (SPELL_SCHOOL_MASK_FROST & spellInfo->GetSchoolMask()))
+                //    pctbonus += 0.333f;
+            }
+            //Focused Power: 4% bonus damage for all spells
+            if (lvl >= 35)
+                pctbonus += 0.04f;
+            //Darkness: 10% bonus damage for shadow spells
+            if (lvl >= 10 && (spellInfo->GetSchoolMask() & SPELL_SCHOOL_MASK_SHADOW))
+                pctbonus += 0.1f;
+            //Twin Disciplines (damage part): 5% bonus damage for instant spells
+            if (lvl >= 13 && !spellInfo->CalcCastTime())
+                pctbonus += 0.05f;
+            //Twisted Faith (part 1): 10% bonus damage for Mind Blast and Mind Flay if target is affected BY SW: Pain
+            if (lvl >= 55 && (spellId == GetSpell(SW_PAIN_1) || spellId == GetSpell(MIND_FLAY_1)) &&
+                damageinfo.target && damageinfo.target->HasAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                pctbonus += 0.1f;
+            //Mind Melt (part 1): 30% bonus damage for Shadow Word: Death
+            if (lvl >= 41 && spellId == GetSpell(SW_DEATH_1))
+                pctbonus += 0.3f;
+
+            //Glyph of Mind Flay: 10% damage bonus for Mind Flay
+            if (lvl >= 25 && spellId == GetSpell(MIND_FLAY_1))
+                pctbonus += 0.1f;
+
+            //other
+            if (spellId == SW_DEATH_BACKLASH)
+            {
+                ////T13 Shadow 2P Bonus (Shadow Word: Death), part 2
+                //if (lvl >= 60) //buffed
+                //    pctbonus -= 0.95f;
+                //Pain and Suffering (part 2): 40% reduced backlash damage
+                if (lvl >= 50)
+                    pctbonus -= 0.4f;
+
+                pctbonus = std::min<float>(pctbonus, 1.0f);
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Improved Renew: 15% bonus healing for Renew
+            if (lvl >= 10 && spellId == GetSpell(RENEW_1))
+                pctbonus += 0.15f;
+            //Spiritual Healing: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.15f;
+            //Blessend Resilience: 3% bonus healing for all spells
+            if (lvl >= 40)
+                pctbonus += 0.03f;
+            //Empowered Healing: 40% bonus (from spellpower) for Greater Heal and 20% bonus (from spellpower) for Flash Heal
+            if (lvl >= 45)
+            {
+                if (spellId == HEAL)
+                    flat_mod += spellpower * 0.4f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(FLASH_HEAL_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+            //Impowered Renew (heal bonus part): 15% bonus healing for Renew
+            if (lvl >= 50 && spellId == GetSpell(RENEW_1))
+                flat_mod += spellpower *  0.15f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * int32(stack) * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Test of Faith: 12% bonus healing on targets at or below 50% health
+            if (lvl >= 50 && GetHealthPCT(victim) <= 50)
+                pctbonus += 0.12f;
+            //Test of Faith: 10 bonus healing for Circle of Healing, Binding Heal, Holy Nova, Prayer of Healing, Divine Hymn and Prayer of Mending
+            if (lvl >= 55 &&
+                (/*spellId == GetSpell(CIRCLE_OF_HEALING_1) || spellId == GetSpell(BINDING_HEAL_1) ||
+                spellId == GetSpell(HOLY_NOVA_1) || */spellId == GetSpell(PRAYER_OF_HEALING_1) ||
+                spellId == DIVINE_HYMN_HEAL/* || spellId == GetSpell(PRAYER_OF_MENDING_1)*/))
+                pctbonus += 0.12f;
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Improved Flash Heal (part 2): 10% additional critical chance on targets at or below 50% hp for Flash Heal
+            if (lvl >= 40 && spellId == GetSpell(FLASH_HEAL_1) && GetHealthPCT(victim) <= 50)
+                aftercrit += 10.f;
+            //Holy Specialization: 5% additional critical chance for Holy spells
+            if (lvl >= 10 && (schoolMask & SPELL_SCHOOL_MASK_HOLY))
+                aftercrit += 5.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            ////Strength of Soul: direct heals reduce Weakened Soul duration on target by 4 sec
+            //if (spellId == HEAL || spellId == GetSpell(FLASH_HEAL_1))
+            //{
+            //    if (me->getLevel() >= 51)
+            //    {
+            //        if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+            //        {
+            //            if (soul->GetDuration() > 4000)
+            //                soul->SetDuration(soul->GetDuration() - 4000);
+            //            else
+            //                target->RemoveAura(soul, AURA_REMOVE_BY_EXPIRE);
+            //        }
+            //    }
+            //}
+
+            //Weakened Soul Reduction (id: 33333 lol): -2 sec to Weakened Soul duration
+            if (spellId == WEAKENED_SOUL_DEBUFF)
+                if (me->getLevel() >= 51)
+                    if (Aura* soul = target->GetAura(WEAKENED_SOUL_DEBUFF))
+                        soul->SetDuration(soul->GetDuration() - 2000);
+
+            //Pain and Suffering (part 1, 335 version): 100% to refresh Shadow Word: Pain on target hit by Mind Flay
+            if (spellId == GetSpell(MIND_FLAY_1))
+                if (me->getLevel() >= 51)
+                    if (Aura* pain = target->GetAura(GetSpell(SW_PAIN_1), me->GetGUID()))
+                        pain->RefreshDuration();
+
+            if (spellId == GetSpell(FEAR_WARD_1))
+            {
+                //2 minutes bonus duration for Fear Ward
+                if (Aura* ward = target->GetAura(GetSpell(FEAR_WARD_1), me->GetGUID()))
+                {
+                    uint32 dur = ward->GetDuration() + 120000;
+                    ward->SetDuration(dur);
+                    ward->SetMaxDuration(dur);
+                }
+            }
+
+            if (spellId == GetSpell(INNER_FIRE_1) || spellId == GetSpell(VAMPIRIC_EMBRACE_1) || spellId == GetSpell(PW_FORTITUDE_1) ||
+                spellId == GetSpell(SHADOW_PROTECTION_1) || spellId == GetSpell(DIVINE_SPIRIT_1))
+            {
+                //1 hour duration for all buffs
+                if (Aura* buff = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = HOUR * IN_MILLISECONDS;
+                    buff->SetDuration(dur);
+                    buff->SetMaxDuration(dur);
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            Heal_Timer = 0;
+            Shackle_Timer = 0;
+
+            CheckDispelTimer = 0;
+            DevcheckTimer = 0;
+
+            Devcheck = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (Heal_Timer > diff)                  Heal_Timer -= diff;
+            if (Shackle_Timer > diff)               Shackle_Timer -= diff;
+
+            if (CheckDispelTimer > diff)            CheckDispelTimer -= diff;
+            if (DevcheckTimer > diff)               DevcheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(DISPEL_MAGIC_1);
+            InitSpellMap(MASS_DISPEL_1);
+            InitSpellMap(CURE_DISEASE_1);
+            InitSpellMap(FEAR_WARD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PAIN_SUPPRESSION_1) : RemoveSpell(PAIN_SUPPRESSION_1);
+            InitSpellMap(PSYCHIC_SCREAM_1);
+            InitSpellMap(FADE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(PSYCHIC_HORROR_1) : RemoveSpell(PSYCHIC_HORROR_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SILENCE_1) : RemoveSpell(SILENCE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(PENANCE_1) : RemoveSpell(PENANCE_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(VAMPIRIC_EMBRACE_1) : RemoveSpell(VAMPIRIC_EMBRACE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(DISPERSION_1) : RemoveSpell(DISPERSION_1);
+            InitSpellMap(MIND_SEAR_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(GUARDIAN_SPIRIT_1) : RemoveSpell(GUARDIAN_SPIRIT_1);
+            InitSpellMap(SHACKLE_UNDEAD_1);
+            InitSpellMap(GREATER_HEAL_1);
+            InitSpellMap(NORMAL_HEAL_1);
+            InitSpellMap(LESSER_HEAL_1);
+            InitSpellMap(RENEW_1);
+            InitSpellMap(FLASH_HEAL_1);
+            InitSpellMap(PRAYER_OF_HEALING_1);
+            InitSpellMap(DIVINE_HYMN_1);
+            InitSpellMap(RESURRECTION_1);
+            InitSpellMap(PW_SHIELD_1);
+            InitSpellMap(INNER_FIRE_1);
+            InitSpellMap(PW_FORTITUDE_1);
+            InitSpellMap(SHADOW_PROTECTION_1);
+            InitSpellMap(DIVINE_SPIRIT_1);
+            InitSpellMap(SW_PAIN_1);
+            InitSpellMap(MIND_BLAST_1);
+            InitSpellMap(SW_DEATH_1);
+            InitSpellMap(DEVOURING_PLAGUE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(MIND_FLAY_1) : RemoveSpell(MIND_FLAY_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(VAMPIRIC_TOUCH_1) : RemoveSpell(VAMPIRIC_TOUCH_1);
+
+            HEAL = GetSpell(GREATER_HEAL_1) ? GetSpell(GREATER_HEAL_1) :
+                GetSpell(NORMAL_HEAL_1) ? GetSpell(NORMAL_HEAL_1) :
+                GetSpell(LESSER_HEAL_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(BORROWED_TIME, level >= 65 ? 1 : 0);
+            RefreshAura(DIVINE_AEGIS, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW3, level >= 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW2, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(EMPOWERED_RENEW1, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(BODY_AND_SOUL1, level >= 45 ? 1 : 0);
+            RefreshAura(RENEWED_HOPE, level >= 45 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING3, level >= 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(PAINANDSUFFERING1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(MISERY3, level >= 50 ? 1 : 0);
+            RefreshAura(MISERY2, level >= 48 && level < 50 ? 1 : 0);
+            RefreshAura(MISERY1, level >= 45 && level < 48 ? 1 : 0);
+            RefreshAura(GRACE, level >= 25 ? 1 : 0);
+            RefreshAura(ENLIGHTENMENT, level >= 35 ? 1 : 0);
+            RefreshAura(RAPTURE, level >= 45 ? 1 : 0);
+            RefreshAura(IMPROVED_DEVOURING_PLAGUE, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION3, level >= 25 ? 1 : 0);
+            RefreshAura(INSPIRATION2, level >= 23 && level < 25 ? 1 : 0);
+            RefreshAura(INSPIRATION1, level >= 20 && level < 23 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING3, level >= 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(SHADOW_WEAVING1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(GLYPH_SW_PAIN, level >= 15? 1 : 0);
+            RefreshAura(GLYPH_PW_SHIELD, level >= 15 ? 1 : 0);
+            RefreshAura(SHADOWFORM, level >= 40 ? 1 : 0);
+            RefreshAura(PRIEST_T10_2P_BONUS, level >= 70 ? 1 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case DISPEL_MAGIC_1:
+                case MASS_DISPEL_1:
+                case CURE_DISEASE_1:
+                case FEAR_WARD_1:
+                case PAIN_SUPPRESSION_1:
+                case FADE_1:
+                case PENANCE_1:
+                case VAMPIRIC_EMBRACE_1:
+                case DISPERSION_1:
+                case GUARDIAN_SPIRIT_1:
+                case LESSER_HEAL_1:
+                case NORMAL_HEAL_1:
+                case GREATER_HEAL_1:
+                case RENEW_1:
+                case FLASH_HEAL_1:
+                case PRAYER_OF_HEALING_1:
+                case DIVINE_HYMN_1:
+                case PW_SHIELD_1:
+                case INNER_FIRE_1:
+                case PW_FORTITUDE_1:
+                case SHADOW_PROTECTION_1:
+                case DIVINE_SPIRIT_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        uint32 HEAL;
+        uint32 Heal_Timer, Shackle_Timer;
+/*Misc*/uint16 CheckDispelTimer, DevcheckTimer;
+/*Misc*/bool Devcheck;
+
+        enum PriestBaseSpells
+        {
+            DISPEL_MAGIC_1                      = 527,
+            MASS_DISPEL_1                       = 32375,
+            CURE_DISEASE_1                      = 528,
+            FEAR_WARD_1                         = 6346,
+  /*Talent*/PAIN_SUPPRESSION_1                  = 33206,
+            PSYCHIC_SCREAM_1                    = 8122,
+            FADE_1                              = 586,
+  /*Talent*/PSYCHIC_HORROR_1                    = 64044,
+  /*Talent*/SILENCE_1                           = 15487,
+  /*Talent*/PENANCE_1                           = 47540,
+  /*Talent*/VAMPIRIC_EMBRACE_1                  = 15286,
+  /*Talent*/DISPERSION_1                        = 47585,
+            MIND_SEAR_1                         = 48045,
+  /*Talent*/GUARDIAN_SPIRIT_1                   = 47788,
+            SHACKLE_UNDEAD_1                    = 9484,
+            LESSER_HEAL_1                       = 2050,
+            NORMAL_HEAL_1                       = 2054,
+            GREATER_HEAL_1                      = 2060,
+            RENEW_1                             = 139,
+            FLASH_HEAL_1                        = 2061,
+            PRAYER_OF_HEALING_1                 = 596,
+            DIVINE_HYMN_1                       = 64843,
+            RESURRECTION_1                      = 2006,
+            PW_SHIELD_1                         = 17,
+            INNER_FIRE_1                        = 588,
+            PW_FORTITUDE_1                      = 1243,
+            SHADOW_PROTECTION_1                 = 976,
+            DIVINE_SPIRIT_1                     = 14752,
+            SW_PAIN_1                           = 589,
+            MIND_BLAST_1                        = 8092,
+            SW_DEATH_1                          = 32379,
+            DEVOURING_PLAGUE_1                  = 2944,
+  /*Talent*/MIND_FLAY_1                         = 15407,
+  /*Talent*/VAMPIRIC_TOUCH_1                    = 34914
+        };
+        enum PriestPassives
+        {
+            SHADOWFORM  /*For DOT crits*/   = 49868,
+        //Talents
+            IMPROVED_DEVOURING_PLAGUE       = 63627,//rank 3
+            MISERY1                         = 33191,
+            MISERY2                         = 33192,
+            MISERY3                         = 33193,
+            PAINANDSUFFERING1               = 47580,
+            PAINANDSUFFERING2               = 47581,
+            PAINANDSUFFERING3               = 47582,
+            SHADOW_WEAVING1                 = 15257,
+            SHADOW_WEAVING2                 = 15331,
+            SHADOW_WEAVING3                 = 15332,
+            DIVINE_AEGIS                    = 47515,//rank 3
+            BORROWED_TIME                   = 52800,//rank 5
+            GRACE                           = 47517,//rank 2
+            EMPOWERED_RENEW1                = 63534,
+            EMPOWERED_RENEW2                = 63542,
+            EMPOWERED_RENEW3                = 63543,
+            INSPIRATION1                    = 14892,
+            INSPIRATION2                    = 15362,
+            INSPIRATION3                    = 15363,
+            BODY_AND_SOUL1                  = 64127,
+            RENEWED_HOPE                    = 57472,//rank 3
+            ENLIGHTENMENT                   = 34910,//rank 3
+            RAPTURE                         = 47537,//rank 3
+        //Glyphs
+            GLYPH_SW_PAIN                   = 55681,
+            GLYPH_PW_SHIELD                 = 55672,
+        //other
+            PRIEST_T10_2P_BONUS             = 70770 //33% renew
+        };
+        enum PriestSpecial
+        {
+            IMPROVED_DEVOURING_PLAGUE_DAMAGE= 63675,
+            MIND_SEAR_DAMAGE                = 49821,
+            SW_DEATH_BACKLASH               = 32409,
+            WEAKENED_SOUL_DEBUFF            = 6788,
+            DIVINE_HYMN_HEAL                = 64844
+        };
+    };
+};
+
+void AddSC_priest_bot()
+{
+    new priest_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_rogue_ai.cpp b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
new file mode 100644
index 0000000..43d2551
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_rogue_ai.cpp
@@ -0,0 +1,828 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Rogue NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 25% maybe...
+TODO:
+*/
+#define DMGMIN              1
+#define DMGMAX              2
+#define MAX_COMBO_POINTS    5
+#define EVISCERATE_MAX_RANK 12
+const uint32 EVSCRDamage[EVISCERATE_MAX_RANK+1][MAX_COMBO_POINTS+1][DMGMAX+1] =
+{
+    { { 0,0,0 }, { 0,0,0 },     { 0,0,0 },      { 0,0,0 },       { 0,0,0 },       { 0,0,0 }       },
+    { { 0,0,0 }, { 0,6,11 },    { 0,12,16 },    { 0,17,22 },     { 0,22,28 },     { 0,28,34 }     },
+    { { 0,0,0 }, { 0,14,23 },   { 0,26,34 },    { 0,37,46 },     { 0,48,58 },     { 0,60,70 }     },
+    { { 0,0,0 }, { 0,25,49 },   { 0,45,59 },    { 0,64,79 },     { 0,83,99 },     { 0,103,119 }   },
+    { { 0,0,0 }, { 0,41,62 },   { 0,73,93 },    { 0,104,125 },   { 0,135,157 },   { 0,167,189 }   },
+    { { 0,0,0 }, { 0,60,91 },   { 0,106,136 },  { 0,151,182 },   { 0,196,228 },   { 0,242,274 }   },
+    { { 0,0,0 }, { 0,93,138 },  { 0,165,209 },  { 0,236,281 },   { 0,307,353 },   { 0,379,425 }   },
+    { { 0,0,0 }, { 0,144,213 }, { 0,255,323 },  { 0,365,434 },   { 0,475,545 },   { 0,586,656 }   },
+    { { 0,0,0 }, { 0,199,296 }, { 0,351,447 },  { 0,502,599 },   { 0,653,751 },   { 0,805,903 }   },
+    { { 0,0,0 }, { 0,224,333 }, { 0,395,503 },  { 0,565,674 },   { 0,735,845 },   { 0,906,1016 }  },
+    { { 0,0,0 }, { 0,245,366 }, { 0,431,551 },  { 0,616,737 },   { 0,801,923 },   { 0,987,1109 }  },
+    { { 0,0,0 }, { 0,405,614 }, { 0,707,915 },  { 0,1008,1217 }, { 0,1309,1519 }, { 0,1611,1821 } },
+    { { 0,0,0 }, { 0,497,752 }, { 0,868,1122 }, { 0,1238,1493 }, { 0,1608,1864 }, { 0,1979,2235 } }
+};
+#define RUPTURE_MAX_RANK    9
+const uint32 RuptureDamage[RUPTURE_MAX_RANK+1][MAX_COMBO_POINTS+1] =
+{
+    { 0, 0,   0,   0,    0,    0    },
+    { 0, 41,  61,  86,   114,  147  },
+    { 0, 61,  91,  128,  170,  219  },
+    { 0, 89,  131, 182,  240,  307  },
+    { 0, 129, 186, 254,  331,  419  },
+    { 0, 177, 256, 350,  457,  579  },
+    { 0, 273, 381, 506,  646,  803  },
+    { 0, 325, 461, 620,  800,  1003 },
+    { 0, 489, 686, 914,  1171, 1459 },
+    { 0, 581, 816, 1088, 1395, 1739 }
+};
+
+class rogue_bot : public CreatureScript
+{
+public:
+    rogue_bot() : CreatureScript("rogue_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new rogue_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct rogue_botAI : public bot_minion_ai
+    {
+        rogue_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_ROGUE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_ROGUE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { comboPoints = 0; tempComboPoints = 0; bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/)
+        {}
+
+        //This method should be used to emulate energy usage reduction
+        void modenergy(int32 mod, bool set = false)
+        {
+            //can't set enery to -x (2 cases)
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && energy < uint32(abs(mod)))
+            {
+                mod = 0;
+                set = true;
+            }
+
+            if (set)
+                energy = mod;
+            else
+                energy += mod;
+
+            energy = std::min<uint32>(energy, 100);
+            me->SetPower(POWER_ENERGY, energy);
+        }
+
+        uint32 getenergy()
+        {
+            energy = me->GetPower(POWER_ENERGY);
+            return energy;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_ROGUE))
+                return;
+
+            Attack(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            comboPoints = std::min<uint8>(comboPoints, 5);
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //Blade Flurry (434 deprecated)
+            if (IsSpellReady(BLADE_FLURRY_1, diff, false) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 &&
+                Rand() < 30 && getenergy() >= 25 && FindSplashTarget(7, opponent))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLADE_FLURRY_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //KICK
+            if (IsSpellReady(KICK_1, diff, false) && meleedist <= 5 && Rand() < 80 && getenergy() >= 25 &&
+                opponent->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(KICK_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //SHADOWSTEP
+            if (IsSpellReady(SHADOWSTEP_1, diff, false) && HasRole(BOT_ROLE_DPS) && dist < 25 &&
+                (opponent->GetVictim() != me || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                Rand() < 30 && getenergy() >= 10)
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(SHADOWSTEP_1)))
+                {
+                    GC_Timer = temptimer;
+                    //return;
+                }
+            }
+            //BACKSTAB
+            if (IsSpellReady(BACKSTAB_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 4 &&
+                /*Rand() < 90 && */getenergy() >= 60 && !opponent->HasInArc(M_PI, me))
+            {
+                if (doCast(opponent, GetSpell(BACKSTAB_1)))
+                    return;
+            }
+            //SINISTER STRIKE
+            if (IsSpellReady(SINISTER_STRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints < 5 &&
+                Rand() < 25 && getenergy() >= 45)
+            {
+                if (doCast(opponent, GetSpell(SINISTER_STRIKE_1)))
+                    return;
+            }
+            //SLICE AND DICE
+            if (IsSpellReady(SLICE_DICE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 20 && comboPoints > 1 && getenergy() >= 25 &&
+                (b_attackers.size() <= 1 || !IsSpellReady(BLADE_FLURRY_1, diff)) && Rand() < 30)
+            {
+                if (doCast(opponent, GetSpell(SLICE_DICE_1)))
+                    return;
+            }
+            //KIDNEY SHOT
+            if (IsSpellReady(KIDNEY_SHOT_1, diff) && meleedist <= 5 && comboPoints > 0 &&
+                !CCed(opponent) && getenergy() >= 25 && ((Rand() < 15 + comboPoints*15 && opponent->GetVictim() == me && comboPoints > 2) || opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(KIDNEY_SHOT_1)))
+                    return;
+            }
+            //EVISCERATE
+            if (IsSpellReady(EVISCERATE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 2 &&
+                getenergy() >= 35 && Rand() < comboPoints*15)
+            {
+                uint32 EVISCERATE = GetSpell(EVISCERATE_1);
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(EVISCERATE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float combo = float(comboPoints);
+                int32 damage = int32(urand(EVSCRDamage[rank][comboPoints][DMGMIN], EVSCRDamage[rank][comboPoints][DMGMAX]));//base damage
+                damage += irand(int32(ap*combo*0.03f), int32(ap*combo*0.07f));//ap bonus
+
+                currentSpell = EVISCERATE;
+                me->CastCustomSpell(opponent, EVISCERATE, &damage, NULL, NULL, false);
+                return;
+            }
+            //MUTILATE
+            //if (isTimerReady(Mutilate_Timer) && energy>60)
+            //{
+            //    // TODO: calculate correct dmg for mutilate (dont forget poison bonus)
+            //    // for now use same formula as evicerate
+            //    uint32 base_attPower = me->GetUInt32Value(UNIT_FIELD_ATTACK_POWER);
+            //    //float minDmg = me->GetFloatValue(UNIT_FIELD_MINDAMAGE);
+            //    float minDmg = me->GetWeaponDamageRange(BASE_ATTACK, MINDAMAGE);
+            //    int damage = irand(int32(base_attPower*7*0.03f),int32(base_attPower*7*0.08f))+minDmg+me->getLevel();
+
+            //    // compensate for lack of attack power
+            //    damage = damage*(rand()%4+1);
+
+            //    me->CastCustomSpell(opponent, MUTILATE, &damage, NULL, NULL, false, NULL, NULL);
+
+            //    //doCast (me, MUTILATE);
+            //    Mutilate_Timer = 10;
+            //    comboPoints+=3;
+            //    energy -= 60;
+            //}
+
+            //RUPTURE
+            if (IsSpellReady(RUPTURE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && comboPoints > 3 && getenergy() >= 25 &&
+                opponent->GetHealth() > me->GetMaxHealth()/3 && Rand() < (50 + 70 * opponent->isMoving()))
+            {
+                uint32 RUPTURE = GetSpell(RUPTURE_1);
+                //no damage range for rupture
+                SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(RUPTURE);
+                uint8 rank = spellInfo->GetRank();
+                float ap = me->GetTotalAttackPowerValue(BASE_ATTACK);
+                float AP_per_combo[6] = {0.0f, 0.015f, 0.024f, 0.03f, 0.03428571f, 0.0375f};
+                float divider[6] = {0.0f, 4.f, 5.f, 6.f, 7.f, 8.f};//duration/2 = number of ticks
+                int32 damage = int32(RuptureDamage[rank][comboPoints]/divider[comboPoints]);//base damage
+                damage += int32(ap*AP_per_combo[comboPoints]);//ap bonus is strict - applied to every tick
+
+                currentSpell = RUPTURE;
+                me->CastCustomSpell(opponent, RUPTURE, &damage, NULL, NULL, false);
+                return;
+            }
+            //DISMANTLE
+            if (IsSpellReady(DISMANTLE_1, diff, false) && meleedist <= 5 && opponent->GetTypeId() == TYPEID_PLAYER &&
+                Rand() < 20 && getenergy() >= 25 && !CCed(opponent) && !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (opponent->ToPlayer()->GetWeaponForAttack(BASE_ATTACK) || opponent->ToPlayer()->GetWeaponForAttack(RANGED_ATTACK)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(DISMANTLE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Puncturing Wounds: 30% additional critical chance for Backstab
+                if (lvl >= 15 && spellId == GetSpell(BACKSTAB_1))
+                    aftercrit += 30.f;
+                //Puncturing Wounds: 15% additional critical chance for Mutilate
+                else if (spellId == GetSpell(MUTILATE_1))
+                    aftercrit += 15.f;
+                //Glyph of Eviscerate: 10% additional critical chance for Eviscerate
+                else if (spellId == GetSpell(EVISCERATE_1))
+                    aftercrit += 10.f;
+                //Improved Ambush: 60% additional critical chance for Ambush
+                //else if (spellId == AMBUSH)
+                //    crit_chance += 60.f;
+                if (lvl >= 50 && spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS) && me->HasAura(TURN_THE_TABLES_EFFECT))
+                    aftercrit += 6.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Lethality: 30% crit damage bonus for non-stealth combo-generating abilities (on 25 lvl)
+                if (lvl >= 25 && !(spellInfo->Attributes & SPELL_ATTR0_ONLY_STEALTHED) &&
+                    spellInfo->HasEffect(SPELL_EFFECT_ADD_COMBO_POINTS))
+                    pctbonus += 0.15f;
+            }
+            //Shadowstep: 20% bonus damage to all abilities once
+            //if (shadowstep == true)
+            //{
+            //    shadowstep = false;
+            //    me->RemoveAurasDueToSpell(SHADOWSTEP_EFFECT_DAMAGE);
+            //    pctbonus += 0.2f;
+            //}
+            //Find Weakness: 6% bonus damage to all abilities
+            if (lvl >= 45)
+                pctbonus += 0.06f;
+            //DeathDealer set bonus: 15% damage bonus for Eviscerate
+            if (lvl >= 60 && spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.15f;
+            //Imoroved Eviscerate: 20% damage bonus for Eviscerate
+            if (spellId == GetSpell(EVISCERATE_1))
+                pctbonus += 0.2f;
+            //Opportunity: 20% damage bonus for Backstab, Mutilate, Garrote and Ambush
+            if (spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == GARROTE || spellId == AMBUSH*/)
+                pctbonus += 0.2f;
+            //Aggression: 15% damage bonus for Sinister Strike, Backstab and Eviscerate
+            if (lvl >= 30 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1) || spellId == GetSpell(EVISCERATE_1)))
+                pctbonus += 0.15f;
+            //Blood Spatter: 30% bonus damage for Rupture and Garrote
+            if (lvl >= 15 && (spellId == GetSpell(RUPTURE_1)/* || spellId == GARROTE*/))
+                pctbonus += 0.3f;
+            //Serrated Blades: 30% bonus damage for Rupture
+            if (lvl >= 20 && spellId == GetSpell(RUPTURE_1))
+                pctbonus += 0.3f;
+            //Surprise Attacks: 10% bonus damage for Sinister Strike, Backstab, Shiv, Hemmorhage and Gouge
+            if (lvl >= 50 && (spellId == GetSpell(SINISTER_STRIKE_1) || spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == SHIV || spellId == HEMMORHAGE || spellId == GOUGE*/))
+                pctbonus += 0.1f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            uint32 WOUND_POISON = GetSpell(WOUND_POISON_1);
+            uint32 MIND_NUMBING_POISON = GetSpell(MIND_NUMBING_POISON_1);
+            if (!WOUND_POISON && !MIND_NUMBING_POISON)
+                return;
+
+            if (damageType == DIRECT_DAMAGE || damageType == SPELL_DIRECT_DAMAGE)
+            {
+                if (victim && me->GetExactDist(victim) <= 40)
+                {
+                    switch (rand()%2)
+                    {
+                        case 0:
+                            break;
+                        case 1:
+                        {
+                            switch (rand()%2)
+                            {
+                                case 0:
+                                    if (WOUND_POISON)
+                                    {
+                                        currentSpell = WOUND_POISON;
+                                        DoCast(victim, WOUND_POISON, true);
+                                    }
+                                    break;
+                                case 1:
+                                    if (MIND_NUMBING_POISON)
+                                    {
+                                        currentSpell = MIND_NUMBING_POISON;
+                                        DoCast(victim, MIND_NUMBING_POISON, true);
+                                    }
+                                    break;
+                            }
+                        }
+                    }
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //combo points use up
+            if (spellId == GetSpell(SLICE_DICE_1))
+            {
+                SetSpellCooldown(SLICE_DICE_1, 15000 + (tempComboPoints-1)*4500); //no initial cooldown
+                GC_Timer = 800;
+
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    uint32 dur = dice->GetDuration();
+                    dur += tempComboPoints * 3000; //use cp
+                    dur += 6000; // Glyph of Slice and Dice
+                    dur = (dur * 3) / 2; //Improved Slice and Dice
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(RUPTURE_1))
+            {
+                SetSpellCooldown(RUPTURE_1, 8000 + (tempComboPoints-1)*2000 + 4000); //no initial cooldown
+                GC_Timer = 800;
+
+                if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                {
+                    uint32 dur = rupture->GetDuration() + tempComboPoints*2000; //use cp
+                    dur += 4000; //Glyph of Rupture
+                    rupture->SetDuration(dur);
+                    rupture->SetMaxDuration(dur);
+                }
+            }
+            else if (spellId == GetSpell(KIDNEY_SHOT_1))
+            {
+                if (Aura* kidney = target->GetAura(GetSpell(KIDNEY_SHOT_1), me->GetGUID()))
+                {
+                    uint32 dur = kidney->GetDuration() + tempComboPoints*1000;
+                    kidney->SetDuration(dur);
+                    kidney->SetMaxDuration(dur);
+                }
+            }
+
+            if (currentSpell == 0)
+                return;
+
+            //BONUS CP MANAGEMENT
+
+            //if (spellId == EVISCERATE || spellId == KIDNEY_SHOT || spellId == SLICE_DICE || spellId == RUPTURE/* || spellId == EXPOSE_ARMOR || spellId == ENVENOM*/)
+            //Relentless Strikes
+            if (spell->NeedsComboPoints())
+            {
+                //std::ostringstream msg;
+                //msg << "casting ";
+                //if (spellId == EVISCERATE)
+                //    msg << "Eviscerate, ";
+                //else if (spellId == RUPTURE)
+                //    msg << "Rupture, ";
+                //else if (spellId == SLICE_DICE)
+                //    msg << "Slice and Dice, ";
+                //else if (spellId == KIDNEY_SHOT)
+                //    msg << "Kidney Shot, ";
+                ////else if (spellId == EXPOSE_ARMOR)
+                ////    msg << "Expose Armor, ";
+                ////else if (spellId == ENVENOM)
+                ////    msg << "Envenom, ";
+                //msg << "combo points: " << uint32(std::min<uint32>(comboPoints,5));
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    currentSpell = RELENTLESS_STRIKES_EFFECT;
+                    DoCast(me, RELENTLESS_STRIKES_EFFECT, true);
+                }
+                tempComboPoints = comboPoints;
+                //CP adding effects are handled before actual finisher so use temp value
+                //std::ostringstream msg2;
+                //msg2 << "cp set to 0";
+                if (tempAddCP)
+                {
+                    //msg2 << " + " << uint32(tempAddCP) << " (temp)";
+                    comboPoints = tempAddCP;
+                    tempAddCP = 0;
+                }
+                else
+                    comboPoints = 0;
+                //me->Whisper(msg2.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+            }
+            else if (spellId == GetSpell(SINISTER_STRIKE_1) ||
+                spellId == GetSpell(BACKSTAB_1)/* ||
+                spellId == GOUGE ||
+                spellId == HEMORRHAGE*/)
+            {
+                ++comboPoints;
+                //std::ostringstream msg;
+                //msg << "1 cp generated ";
+                //if (spellId == SINISTER_STRIKE)
+                //    msg << "(Sinister Strike)";
+                //else if (spellId == BACKSTAB)
+                //    msg << "(Backstab)";
+                //msg << " set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == GetSpell(MUTILATE_1)/* ||
+                spellId == AMBUSH*/)
+            {
+                comboPoints += 2;
+                //std::ostringstream msg;
+                //msg << "2 cp generated (Mutilate), set to " << uint32(comboPoints);
+                //if (tempAddCP)
+                //    msg << " + " << uint32(tempAddCP) << " (triggered)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+                if (tempAddCP)
+                {
+                    comboPoints += tempAddCP;
+                    tempAddCP = 0;
+                }
+            }
+            else if (spellId == SEAL_FATE_EFFECT || spellId == RUTHLESSNESS_EFFECT)
+            {
+                ++tempAddCP;
+                //std::ostringstream msg;
+                //msg << "1 temp cp generated ";
+                //if (spellId == SEAL_FATE_EFFECT)
+                //    msg << "(Seal Fate)";
+                //else if (spellId == RUTHLESSNESS_EFFECT)
+                //    msg << "(Ruthleness)";
+                //me->Whisper(msg.str().c_str(), LANG_UNIVERSAL, master->GetGUID());
+            }
+
+            //Glyph of Sinister Strike (20% to add cp on hit)
+            //Seal Fate means crit so this glyph is enabled from lvl 35)
+            //as addition always add cp on ss crit
+            if (currentSpell == GetSpell(SINISTER_STRIKE_1) && (spellId == SEAL_FATE_EFFECT || urand(0,100) >= 20))
+            {
+                ++tempAddCP;
+                //me->Whisper("1 temp cp generated (glyph of SS)", LANG_UNIVERSAL, master->GetGUID());
+            }
+
+            //ENERGY COST REDUCTION
+
+            if (spellId == GetSpell(SINISTER_STRIKE_1))
+            {
+                //Improved Sinister Strike
+                //instead of restoring energy we should override current value
+                if (me->getLevel() >= 10)
+                    modenergy(-40, true);//45 - 5
+            }
+            //Slaughter from the Shadows energy restore
+            //instead of restoring energy we should override current value
+            if (me->getLevel() >= 55)
+            {
+                if (spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/)
+                    modenergy(-40, true);
+                //else if (spellId == HEMORRHAGE)
+                //    modenergy(-30, true);
+            }
+
+            //OTHER
+
+            if (spellId == GetSpell(EVISCERATE_1))
+            {
+                //Eviscerate speedup
+                GC_Timer = 800;
+
+                //Serrated Blades: Eviscerate has 20% chance per cp to refresh Rupture
+                //getting cheaty - remove roll
+                //getting cheaty - increase duration
+                //if (irand(0, 99) < 20 * (comboPoints > 5 ? 5 : comboPoints))
+                {
+                    if (Aura* rupture = target->GetAura(GetSpell(RUPTURE_1), me->GetGUID()))
+                    {
+                        int32 dur = rupture->GetMaxDuration() + 2000;
+                        dur = std::min<int32>(dur, 30000);
+                        rupture->SetDuration(dur);
+                        rupture->SetMaxDuration(dur);
+                        SetSpellCooldown(RUPTURE_1, dur - 2000); //no initial cooldown
+                    }
+                }
+            }
+
+            //Cut to the Chase: Eviscerate and Envenom will refresh Slice and Dice duration
+            //getting cheaty - increase duration
+            if (spellId == GetSpell(EVISCERATE_1)/* || spellId == ENVENOM*/)
+            {
+                if (Aura* dice = me->GetAura(GetSpell(SLICE_DICE_1)))
+                {
+                    int32 dur = dice->GetMaxDuration() + 2000;
+                    dur = std::min<int32>(dur, 59000);
+                    dice->SetDuration(dur);
+                    dice->SetMaxDuration(dur);
+                    SetSpellCooldown(SLICE_DICE_1, dur - 2000); //no initial cooldown
+                }
+            }
+
+            //Murderous Intent: When Backstabbing enemy that is below 35% hp, instantly restoring 30 energy
+            if (spellId == GetSpell(BACKSTAB_1))
+            {
+                if (target->HealthBelowPct(35))
+                {
+                    //since talent doesn't work just restore energy manually
+                    //DoCast(me, MURDEROUS_INTENT_EFFECT, true);
+                    modenergy(30);
+                }
+            }
+
+            //Waylay
+            if ((spellId == GetSpell(BACKSTAB_1)/* || spellId == AMBUSH*/) &&
+                me->getLevel() >= 20)
+            {
+                DoCast(target, WAYLAY_EFFECT, true);
+            }
+
+            //if (spellId == SHADOWSTEP)
+            //{
+            //    Shadowstep_eff_Timer = 10000;
+            //    shadowstep = true;
+            //}
+
+            //move behind on Kidney Shot and Gouge (optionally)
+            if (spellId == GetSpell(KIDNEY_SHOT_1)/* || spellId == GOUGE*/)
+                if (MoveBehind(*target))
+                    wait = 3;
+
+            if (spellId == currentSpell)
+                currentSpell = 0;
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            comboPoints = 0;
+            tempComboPoints = 0;
+            tempAddCP = 0;
+
+            tempDICE = false;
+            //shadowstep = false;
+
+            me->setPowerType(POWER_ENERGY);
+            //10 energy gained per stack
+            DefaultInit();
+
+            RefreshAura(GLADIATOR_VIGOR, 10);
+
+            me->SetPower(POWER_ENERGY, me->GetMaxPower(POWER_ENERGY));
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+            //if (Shadowstep_eff_Timer > diff)        Shadowstep_eff_Timer -= diff;
+            //else if (shadowstep)                    shadowstep = false;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(BACKSTAB_1);
+            InitSpellMap(SINISTER_STRIKE_1);
+            InitSpellMap(SLICE_DICE_1);
+            InitSpellMap(EVISCERATE_1);
+            InitSpellMap(KICK_1);
+            InitSpellMap(RUPTURE_1);
+            InitSpellMap(KIDNEY_SHOT_1);
+            lvl >= 50 ? InitSpellMap(MUTILATE_1) : RemoveSpell(MUTILATE_1);
+            lvl >= 50 ? InitSpellMap(SHADOWSTEP_1) : RemoveSpell(SHADOWSTEP_1);
+            InitSpellMap(DISMANTLE_1);
+            lvl >= 30 ? InitSpellMap(BLADE_FLURRY_1) : RemoveSpell(BLADE_FLURRY_1);
+
+            InitSpellMap(WOUND_POISON_1);
+            InitSpellMap(MIND_NUMBING_POISON_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(COMBAT_POTENCY5, level >= 70 ? 2 : level >= 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY4, level >= 52 && level < 55 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY3, level >= 49 && level < 52 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY2, level >= 47 && level < 49 ? 1 : 0);
+            RefreshAura(COMBAT_POTENCY1, level >= 45 && level < 47 ? 1 : 0);
+            RefreshAura(SEAL_FATE5, level >= 35 ? 1 : 0);
+            RefreshAura(SEAL_FATE4, level >= 32 && level < 35 ? 1 : 0);
+            RefreshAura(SEAL_FATE3, level >= 29 && level < 32 ? 1 : 0);
+            RefreshAura(SEAL_FATE2, level >= 27 && level < 29 ? 1 : 0);
+            RefreshAura(SEAL_FATE1, level >= 25 && level < 27 ? 1 : 0);
+            RefreshAura(VITALITY, level >= 70 ? 3 : level >= 55 ? 2 : level >= 40 ? 1 : 0);
+            RefreshAura(TURN_THE_TABLES, level >= 55 ? 1 : 0);
+            RefreshAura(DEADLY_BREW, level >= 40 ? 1 : 0);
+            RefreshAura(BLADE_TWISTING1, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY2, level >= 35 ? 1 : 0);
+            RefreshAura(QUICK_RECOVERY1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(IMPROVED_KIDNEY_SHOT, level >= 30 ? 1 : 0);
+            RefreshAura(GLYPH_BACKSTAB, level >= 10 ? 1 : 0);
+            RefreshAura(SURPRISE_ATTACKS, level >= 10 ? 1 : 0);
+            RefreshAura(ROGUE_VIGOR, level >= 25 ? 2 : level >= 20 ? 1 : 0);
+        }
+
+    private:
+        uint32 energy;
+        uint8 comboPoints, tempComboPoints, tempAddCP;
+        bool tempDICE/*, shadowstep*/;
+
+        enum RogueBaseSpells
+        {
+            BACKSTAB_1                          = 53,
+            SINISTER_STRIKE_1                   = 1757,
+            SLICE_DICE_1                        = 5171,
+            EVISCERATE_1                        = 2098,
+            KICK_1                              = 1766,
+            RUPTURE_1                           = 1943,
+            KIDNEY_SHOT_1                       = 408,
+  /*Talent*/MUTILATE_1                          = 1329,
+  /*Talent*/SHADOWSTEP_1                        = 36554,
+            DISMANTLE_1                         = 51722,
+            BLADE_FLURRY_1                      = 13877,
+        //Special
+            WOUND_POISON_1                      = 13218,
+            MIND_NUMBING_POISON_1               = 5760
+        };
+
+        enum RoguePassives
+        {
+            //Talents
+            SEAL_FATE1                          = 14189,
+            SEAL_FATE2                          = 14190,
+            SEAL_FATE3                          = 14193,
+            SEAL_FATE4                          = 14194,
+            SEAL_FATE5                          = 14195,
+            COMBAT_POTENCY1                     = 35541,
+            COMBAT_POTENCY2                     = 35550,
+            COMBAT_POTENCY3                     = 35551,
+            COMBAT_POTENCY4                     = 35552,
+            COMBAT_POTENCY5                     = 35553,
+            QUICK_RECOVERY1                     = 31244,
+            QUICK_RECOVERY2                     = 31245,
+            BLADE_TWISTING1                     = 31124,
+            //BLADE_TWISTING2                     = 31126,
+            VITALITY                            = 61329,//rank 3
+            DEADLY_BREW                         = 51626,//rank 2
+            IMPROVED_KIDNEY_SHOT                = 14176,//rank 3
+            TURN_THE_TABLES                     = 51629,//rank 3
+            SURPRISE_ATTACKS                    = 32601,
+            ROGUE_VIGOR                         = 14983,
+            //Other
+            //ROGUE_ARMOR_ENERGIZE/*Deathmantle*/ = 27787,
+            GLADIATOR_VIGOR                     = 21975,
+            GLYPH_BACKSTAB                      = 56800
+        };
+
+        enum RogueSpecial
+        {
+            RELENTLESS_STRIKES_EFFECT           = 14181,
+            RUTHLESSNESS_EFFECT                 = 14157,
+            SEAL_FATE_EFFECT                    = 14189,
+            //SHADOWSTEP_EFFECT_DAMAGE            = 36563,
+            TURN_THE_TABLES_EFFECT              = 52910,//'rank 3'
+            WAYLAY_EFFECT                       = 51693,
+            //434
+            MURDEROUS_INTENT_EFFECT             = 79132
+        };
+    };
+};
+
+void AddSC_rogue_bot()
+{
+    new rogue_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_shaman_ai.cpp b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
new file mode 100644
index 0000000..6671b3c
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_shaman_ai.cpp
@@ -0,0 +1,1340 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+#include "Totem.h"
+/*
+Shaman NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - around 30%
+TODO:
+*/
+enum TotemSlot
+{
+    T_FIRE  = 0,//m_SummonSlot[1]
+    T_EARTH = 1,//m_SummonSlot[2]
+    T_WATER = 2,//m_SummonSlot[3]
+    T_AIR   = 3,//m_SummonSlot[4]
+    MAX_TOTEMS
+};
+struct TotemParam
+{
+    TotemParam() : effradius(0.f) {}
+    Position pos;
+    float effradius;
+};
+class shaman_bot : public CreatureScript
+{
+public:
+    shaman_bot() : CreatureScript("shaman_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new shaman_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct shaman_botAI : public bot_minion_ai
+    {
+        shaman_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_SHAMAN;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_SHAMAN) != SPELL_CAST_OK)
+                return false;
+
+            bool maelstrom = false;
+            if (!triggered)
+                maelstrom = (MaelstromCount >= 5 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) || spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(HEALING_WAVE_1) || spellId == GetSpell(LESSER_HEALING_WAVE_1) ||
+                spellId == GetSpell(CHAIN_HEAL_1) || spellId == GetSpell(HEX_1)));
+
+            triggered |= maelstrom;
+
+            bool result = bot_ai::doCast(victim, spellId, triggered, me->GetGUID());
+
+            if (result && maelstrom)
+            {
+                MaelstromCount = 0;
+                me->RemoveAurasDueToSpell(MAELSTROM_WEAPON_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+
+            return result;
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+
+        bool Shielded(Unit* target) const
+        {
+            return
+                (HasAuraName(target, WATER_SHIELD_1) ||
+                HasAuraName(target, EARTH_SHIELD_1) ||
+                HasAuraName(target, LIGHTNING_SHIELD_1));
+        }
+
+        void CheckBloodlust(uint32 diff)
+        {
+            if (!IsSpellReady(BLOODLUST_1, diff, false) || me->GetDistance(master) > 18 || IsCasting() || Rand() > 15)
+                return;
+            if (!me->IsInCombat() || !master->IsInCombat())
+                return;
+
+            if (HasAuraName(master, BLOODLUST_1))
+            {
+                SetSpellCooldown(BLOODLUST_1, 3000); //fail
+                return;
+            }
+
+            if (Unit* u = me->GetVictim())
+            {
+                Creature* cre = u->ToCreature();
+                if (u->GetMaxHealth() > me->GetHealth() * 2 ||
+                    (cre && (cre->IsDungeonBoss() || cre->isWorldBoss())) ||
+                    me->getAttackers().size() + master->getAttackers().size() > 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(BLOODLUST_1)))
+                    {
+                        SetSpellCooldown(BLOODLUST_1, 300000); //5 minutes
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+
+            SetSpellCooldown(BLOODLUST_1, 2000); //fail
+        }
+
+        void CheckTotems(uint32 diff)
+        {
+            //update rate
+            if (Rand() > 25)
+                return;
+            //Unsummon
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first)
+                {
+                    if (master->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius &&
+                        me->GetDistance2d(_totems[i].second.pos.m_positionX, _totems[i].second.pos.m_positionY) > _totems[i].second.effradius)
+                    {
+                        Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[i].first);
+                        if (!to)
+                        {
+                            _totems[i].first.Clear();
+                            //TC_LOG_ERROR("entities.player", "%s has lost totem in slot %u! Despawned normally?", me->GetName().c_str(), i);
+                            continue;
+                        }
+
+                        to->ToTotem()->UnSummon();
+                    }
+                }
+            }
+            if (GC_Timer > diff || IsCasting() || me->GetDistance(master) > 15 || Feasting())
+                return;
+            //Summon
+            //TODO: role-based totems (attack/heal)
+            if (me->IsInCombat())
+            {
+                if (GetSpell(WINDFURY_TOTEM_1) && !_totems[T_AIR].first && !master->m_SummonSlot[T_AIR+1])
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, GetSpell(WINDFURY_TOTEM_1)))
+                    {
+                        if (me->getLevel() >= 57)
+                            GC_Timer = temptimer;
+                        return;
+                    }
+                }
+
+                if (!_totems[T_EARTH].first && !master->m_SummonSlot[T_EARTH+1])
+                {
+                    if (GetSpell(STRENGTH_OF_EARTH_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STRENGTH_OF_EARTH_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(STONESKIN_TOTEM_1))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(STONESKIN_TOTEM_1)))
+                        {
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+
+                if (!_totems[T_FIRE].first && !master->m_SummonSlot[T_FIRE+1])
+                {
+                    if (IsSpellReady(TOTEM_OF_WRATH_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(TOTEM_OF_WRATH_1)))
+                        {
+                            //bot's poor AI cannot use totems wisely so just reduce CD on this
+                            //SetSpellCooldown(TOTEM_OF_WRATH_1, 30000); //30 sec, old 5 min
+                            if (me->getLevel() >= 57)
+                                GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (IsSpellReady(SEARING_TOTEM_1, diff, false))
+                    {
+                        if (Unit* u = me->GetVictim())
+                        {
+                            if (HasRole(BOT_ROLE_DPS) && me->GetExactDist(u) < (u->isMoving() ? 10 : 25))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(me, GetSpell(SEARING_TOTEM_1)))
+                                {
+                                    if (me->getLevel() >= 57)
+                                        GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+            }
+            if (!me->isMoving() && !master->isMoving())
+            {
+                if (!_totems[T_WATER].first && !master->m_SummonSlot[T_WATER+1])
+                {
+                    uint8 manapct = GetManaPCT(master);
+                    uint8 hppct = GetHealthPCT(master);
+                    if (GetSpell(HEALINGSTREAM_TOTEM_1) && hppct < 98 && master->getPowerType() != POWER_MANA &&
+                        (hppct < 25 || manapct > hppct))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(HEALINGSTREAM_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                    else if (GetSpell(MANASPRING_TOTEM_1) && (manapct < 97 || GetManaPCT(me) < 90))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(MANASPRING_TOTEM_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+        }
+
+        void CheckThunderStorm(uint32 diff)
+        {
+            if (!IsSpellReady(THUNDERSTORM_1, diff, false) || !HasRole(BOT_ROLE_DPS) || IsCasting() || Rand() > 25)
+                return;
+
+            //case 1: low mana
+            if (GetManaPCT(me) < 15)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    GC_Timer = temptimer;
+                return;
+            }
+
+            //case 2: knock attackers
+            if (IsTank()) //pretty stupid idea I think
+                return;
+
+            //AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            if (b_attackers.empty())
+                return;
+
+            uint8 tCount = 0;
+            for (AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+            {
+                if (!(*iter)) continue;
+                if (me->GetExactDist((*iter)) > 9) continue;
+                if (CCed(*iter)) continue;
+                if (me->IsValidAttackTarget(*iter))
+                {
+                    ++tCount;
+                    break;
+                }
+            }
+
+            if (tCount > 0)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(THUNDERSTORM_1)))
+                    GC_Timer = temptimer;
+                return;
+            }
+        }
+
+        void CheckManaTide(uint32 diff)
+        {
+            if (!IsSpellReady(MANA_TIDE_TOTEM_1, diff, false) || IAmFree() || IsCasting() || Rand() > 20)
+                return;
+
+            Group* group = master->GetGroup();
+            if (!group)
+                return;
+
+            uint8 LMPcount = 0;
+            uint8 members = group->GetMembersCount();
+            for (GroupReference* itr = group->GetFirstMember(); itr != NULL; itr = itr->next())
+            {
+                Player* tPlayer = itr->GetSource();
+                if (!tPlayer || !tPlayer->IsInWorld() || tPlayer->GetMapId() != me->GetMapId() ||
+                    (!tPlayer->IsAlive() && !tPlayer->HaveBot())) continue;
+                if (me->GetExactDist(tPlayer) > 20) continue;
+                if (tPlayer->getPowerType() != POWER_MANA) continue;
+                if (GetManaPCT(tPlayer) < 35)
+                {
+                    ++LMPcount;
+                    if (LMPcount > 3 || LMPcount > members / 3) break;
+                }
+                if (tPlayer->HaveBot())
+                {
+                    BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                    {
+                        Creature* bot = it->second;
+                        if (bot && bot->IsInWorld() && bot->getPowerType() == POWER_MANA &&
+                            bot->GetExactDist(me) < 20 && GetManaPCT(bot) < 35)
+                        {
+                            ++LMPcount;
+                            if (LMPcount > 3 || LMPcount > members / 3) break;
+                        }
+                    }
+                }
+            }
+
+            if (LMPcount > 3 || LMPcount > members / 3)
+            {
+                if (_totems[T_WATER].first)
+                {
+                    Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[T_WATER].first);
+                    if (!to)
+                        _totems[T_WATER].first.Clear();
+                    else
+                        to->ToTotem()->UnSummon();
+                }
+                if (doCast(me, GetSpell(MANA_TIDE_TOTEM_1)))
+                    return;
+            }
+
+            SetSpellCooldown(MANA_TIDE_TOTEM_1, 3000); //fail
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            CheckThunderStorm(diff);
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            CheckHexy(diff);
+            CheckEarthy(diff);
+
+            if (Potion_cd <= diff && GetManaPCT(me) < 30)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+
+            CheckBloodlust(diff);
+            BuffAndHealGroup(master, diff);
+            CureGroup(master, CURE_TOXINS, diff);
+            CheckManaTide(diff);
+            CheckTotems(diff);
+
+            if (master->IsInCombat() || me->IsInCombat())
+                CheckDispel(diff);
+
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+            //buff myself
+            if (GetSpell(LIGHTNING_SHIELD_1) && !IsTank() && !Shielded(me))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LIGHTNING_SHIELD_1)))
+                    GC_Timer = temptimer;
+            }
+            //heal myself
+            if (GetHealthPCT(me) < 80)
+                HealTarget(me, GetHealthPCT(me), diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_SHAMAN))
+                return;
+
+            CheckHexy2(diff);
+
+            //Counter(diff);
+            DoNormalAttack(diff);
+        }
+
+        void Counter(uint32 diff)
+        {
+            if (!IsSpellReady(WIND_SHEAR_1, diff, false) || Rand() > 60)
+                return;
+
+            Unit* u = me->GetVictim();
+            if (u && u->IsNonMeleeSpellCast(false))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(u, GetSpell(WIND_SHEAR_1)))
+                {
+                    SetSpellCooldown(WIND_SHEAR_1, 5000); //improved
+                    GC_Timer = temptimer;
+                }
+            }
+            else if (Unit* target = FindCastingTarget(25))
+            {
+                temptimer = GC_Timer;
+                if (me->IsNonMeleeSpellCast(false))
+                    me->InterruptNonMeleeSpells(false);
+                if (doCast(target, GetSpell(WIND_SHEAR_1)))
+                    GC_Timer = temptimer;
+            }
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+
+            Counter(diff);
+
+            //AttackerSet m_attackers = master->getAttackers();
+            //AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            if (IsCasting()) return;
+
+            //STORMSTRIKE
+            if (IsSpellReady(STORMSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) && meleedist <= 5 && IsMelee() && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(STORMSTRIKE_1)))
+                    return;
+            }
+            //SHOCKS
+            if ((GetSpell(FLAME_SHOCK_1) || GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1)) &&
+                IsSpellReady(FLAME_SHOCK_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 25 && Rand() < 30)
+            {
+                temptimer = GC_Timer;
+
+                bool canFlameShock = (GetSpell(FLAME_SHOCK_1) != 0);
+                if (canFlameShock)
+                {
+                    if (Aura* fsh = opponent->GetAura(GetSpell(FLAME_SHOCK_1), me->GetGUID()))
+                        if (fsh->GetDuration() > 3000)
+                            canFlameShock = false;
+                }
+
+                if (canFlameShock)
+                {
+                    if (doCast(opponent, GetSpell(FLAME_SHOCK_1)))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+                else if (GetSpell(EARTH_SHOCK_1) || GetSpell(FROST_SHOCK_1))
+                {
+                    uint32 SHOCK = !GetSpell(FROST_SHOCK_1) ? GetSpell(EARTH_SHOCK_1) : RAND(GetSpell(EARTH_SHOCK_1), GetSpell(FROST_SHOCK_1));
+                    if (SHOCK && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)) &&
+                        !opponent->HasAura(SHOCK))
+                    {
+                        if (doCast(opponent, SHOCK))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+            }
+            //LAVA BURST
+            if (IsSpellReady(LAVA_BURST_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(LAVA_BURST_1)))
+                    return;
+            }
+
+            if (GetManaPCT(me) < 15 || (MaelstromCount < 5 && IsMelee()))
+                return;
+
+            //CHAIN LIGHTNING
+            if (IsSpellReady(CHAIN_LIGHTNING_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 80)
+            {
+                if (doCast(opponent, GetSpell(CHAIN_LIGHTNING_1)))
+                    return;
+            }
+            //LIGHTNING BOLT
+            if (IsSpellReady(LIGHTNING_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30)
+            {
+                uint32 LIGHTNING_BOLT = GetSpell(LIGHTNING_BOLT_1);
+                if (doCast(opponent, LIGHTNING_BOLT))
+                    return;
+            }
+        }
+
+        void CheckHexy(uint32 diff)
+        {
+            if (HexyCheckTimer <= diff)
+            {
+                Hexy = FindAffectedTarget(GetSpell(HEX_1), me->GetGUID());
+                HexyCheckTimer = 2000;
+            }
+        }
+
+        void CheckHexy2(uint32 diff)
+        {
+            if (Hexy == false && me->GetVictim() && IsSpellReady(HEX_1, diff, false))
+            {
+                if (Unit* target = FindPolyTarget(20, me->GetVictim()))
+                {
+                    if (doCast(target, GetSpell(HEX_1)))
+                    {
+                        Hexy = true;
+                        HexyCheckTimer += 2000;
+                    }
+                }
+            }
+        }
+
+        void CheckEarthy(uint32 diff)
+        {
+            if (EarthyCheckTimer <= diff)
+            {
+                Unit* u = FindAffectedTarget(GetSpell(EARTH_SHIELD_1), me->GetGUID(), 90.f, 3);
+                Earthy = (u && (IsTank(u) || u == master));
+                EarthyCheckTimer = 1000;
+            }
+        }
+
+        void DoNonCombatActions(uint32 diff)
+        {
+            if (GC_Timer > diff || me->IsMounted() || IsCasting())
+                return;
+
+            RezGroup(GetSpell(ANCESTRAL_SPIRIT_1), master);
+
+            if (Feasting()) return;
+
+            if (Shielded(me) && Rand() < 25)
+            {
+                Aura* shield = NULL;
+                uint32 SHIELD = HasRole(BOT_ROLE_DPS) ? GetSpell(LIGHTNING_SHIELD_1) : 0;
+                if (SHIELD)
+                    shield = me->GetAura(SHIELD);
+                if (!shield && IsTank() && GetSpell(EARTH_SHIELD_1))
+                {
+                    SHIELD = GetSpell(EARTH_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (!shield && GetSpell(WATER_SHIELD_1))
+                {
+                    SHIELD = GetSpell(WATER_SHIELD_1);
+                    shield = me->GetAura(SHIELD);
+                }
+                if (shield && shield->GetCharges() < 5)
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(me, SHIELD))
+                    {
+                        GC_Timer = temptimer;
+                        return;
+                    }
+                }
+            }
+        }
+
+        bool BuffTarget(Unit* target, uint32 diff)
+        {
+            if (!GetSpell(WATER_WALKING_1) && !GetSpell(WATER_BREATHING_1) && !GetSpell(EARTH_SHIELD_1))
+                return false;
+
+            if (GC_Timer > diff || !target || !target->IsAlive() || Rand() > 40)
+                return false;
+
+            if (GetSpell(EARTH_SHIELD_1) && Earthy == false && (target == master || IsTank(target)) &&
+                (target->IsInCombat() || !target->isMoving()) &&
+                me->GetExactDist(target) < 40 && Rand() < 75)
+            {
+                bool cast = !Shielded(target);
+                if (!cast)
+                    if (Aura* eShield = target->GetAura(GetSpell(EARTH_SHIELD_1)))
+                        if (eShield->GetCharges() < 5)
+                            cast = true;
+                if (cast && doCast(target, GetSpell(EARTH_SHIELD_1)))
+                {
+                    Earthy = true;
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+
+            if (me->GetExactDist(target) > 30) return false;
+            if (me->IsInCombat() && !master->GetMap()->IsRaid()) return false;
+
+            if (target->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+            {
+                //bots don't need water breathing
+                if (GetSpell(WATER_BREATHING_1) && target->GetTypeId() == TYPEID_PLAYER &&
+                    !target->HasAuraType(SPELL_AURA_WATER_BREATHING) &&
+                    doCast(target, GetSpell(WATER_BREATHING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+                //water walking breaks on any damage
+                if (GetSpell(WATER_WALKING_1) && target->getAttackers().empty() &&
+                    !target->HasAuraType(SPELL_AURA_WATER_WALK) &&
+                    doCast(target, GetSpell(WATER_WALKING_1)))
+                {
+                    //GC_Timer = 800;
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        void CheckDispel(uint32 diff)
+        {
+            if (!IsSpellReady(PURGE_1, diff, false) || IsCasting() || Rand() > 35)
+                return;
+
+            Unit* target = FindHostileDispelTarget();
+            if (target && doCast(target, GetSpell(PURGE_1)))
+            {}
+
+            SetSpellCooldown(PURGE_1, 2000); //fail
+        }
+
+        bool HealTarget(Unit* target, uint8 hp, uint32 diff)
+        {
+            if (!HasRole(BOT_ROLE_HEAL))
+                return false;
+            if (hp > 97)
+                return false;
+            if (!target || !target->IsAlive() || me->GetExactDist(target) > 40)
+                return false;
+            if (Rand() > 50 + 20*target->IsInCombat() + 50*master->GetMap()->IsRaid())
+                return false;
+
+            //PLACEHOLDER: Instant spell req. interrupt current spell
+
+            if (IsCasting()) return false;
+
+            if (IsSpellReady(LESSER_HEALING_WAVE_1, diff) &&
+                ((hp > 70 && hp < 85) || hp < 50 || GetLostHP(target) > 1800) && Rand() < 75)
+            {
+                if (doCast(target, GetSpell(LESSER_HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(HEALING_WAVE_1, diff) &&
+                hp > 40 && (hp < 75 || GetLostHP(target) > 4000) && Rand() < 65)
+            {
+                if (doCast(target, GetSpell(HEALING_WAVE_1)))
+                    return true;
+            }
+            if (IsSpellReady(CHAIN_HEAL_1, diff) &&
+                ((hp > 40 && hp < 90) || GetLostHP(target) > 1300) && Rand() < 120)
+            {
+                if (IsSpellReady(RIPTIDE_1, diff, false) && (hp < 85 || GetLostHP(target) > 2500) &&
+                    !target->HasAura(GetSpell(RIPTIDE_1)))
+                {
+                    temptimer = GC_Timer;
+                    if (doCast(target, GetSpell(RIPTIDE_1), true))
+                    {
+                        if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                }
+                else if (doCast(target, GetSpell(CHAIN_HEAL_1)))
+                    return true;
+            }
+
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& /*damage*/, CalcDamageInfo& /*damageinfo*/) const {}
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                //if (lvl >= 15 && spellId == CLEAVE /*|| spellId == HEROICSTRIKE || spellId == THUNDERCLAP*/)
+                //    aftercrit += 15.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.25f;
+            }
+
+            //SHAMAN_T8_ENCHANCEMENT_2P_BONUS: 20% bonus damage for Lava Lash and Stormstrike
+            if (lvl >= 60 &&
+                (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND/* || spellId == LAVA_LASH*/))
+                pctbonus += 0.2f;
+
+            //custom bonus to make stormstrike useful
+            if (spellId == STORMSTRIKE_DAMAGE || spellId == STORMSTRIKE_DAMAGE_OFFHAND)
+                pctbonus += 1.0f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Call of Thunder: 5% additional critical chance for Lightning Bolt, Chain Lightning and Thunderstorm
+                if (lvl >= 30 &&
+                    (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                    spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                    spellId == GetSpell(THUNDERSTORM_1)))
+                    aftercrit += 5.f;
+                //Tidal Mastery (part 2): 5% additional critical chance for lightning spells
+                if (lvl >= 25 && (SPELL_SCHOOL_MASK_NATURE & spellInfo->GetSchoolMask()))
+                    aftercrit += 5.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!spell damage is not yet critical and will be multiplied by 1.5
+                //so we should put here bonus damage mult /1.5
+                //Elemental Fury (part 2): 50% additional crit damage bonus for Nature, Fire and Frost (all) spells
+                if (lvl >= 21)
+                    pctbonus += 0.333f;
+                //Lava Flows (part 1): 24% additional crit damage bonus for Lava Burst
+                if (lvl >= 50 && spellId == GetSpell(LAVA_BURST_1))
+                    pctbonus += 0.16f;
+            }
+            //Concussion: 5% bonus damage for Lightning Bolt, Chain Lightning, Thunderstorm, Lava Burst and Shocks
+            if (lvl >= 10 &&
+                (spellId == GetSpell(LIGHTNING_BOLT_1) ||
+                spellId == GetSpell(CHAIN_LIGHTNING_1) ||
+                spellId == GetSpell(THUNDERSTORM_1) ||
+                spellId == GetSpell(LAVA_BURST_1) ||
+                spellId == GetSpell(EARTH_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1) ||
+                spellId == GetSpell(FLAME_SHOCK_1)))
+                pctbonus += 0.05f;
+            //Call of Flame (part 2): 6% bonus damage for Lava burst
+            if (lvl >= 15 && spellId == GetSpell(LAVA_BURST_1))
+                pctbonus += 0.06f;
+            //Storm, Earth and fire (part 3): 60% bonus damage for Flame Shock (periodic damage in fact but who cares?)
+            if (lvl >= 40 && spellId == GetSpell(FLAME_SHOCK_1))
+                pctbonus += 0.6f;
+            //Booming Echoes (part 2): 20% bonus damage for Flame Shock and Frost Shock (direct damage)
+            if (lvl >= 45 &&
+                (spellId == GetSpell(FLAME_SHOCK_1) ||
+                spellId == GetSpell(FROST_SHOCK_1)))
+                pctbonus += 0.2f;
+            //Improved Shields (part 1): 15% bonus damage for Lightning Shield orbs
+            if (lvl >= 15 && spellInfo->IsRankOf(sSpellMgr->GetSpellInfo(LIGHTNING_SHIELD_DAMAGE_1)))
+                pctbonus += 0.15f;
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierHeal(Unit const* /*victim*/, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+            float flat_mod = 0.0f;
+
+            //Healing Way: 25% bonus healing for Healing Wave
+            if (lvl >= 30 && spellId == GetSpell(HEALING_WAVE_1))
+                pctbonus += 0.25f;
+            //Purification: 10% bonus healing for all spells
+            if (lvl >= 35)
+                pctbonus += 0.1f;
+            //Nature's Blessing: 15% of Intellect to healing
+            if (lvl >= 45)
+                flat_mod += me->GetTotalStatValue(STAT_INTELLECT) * 1.0f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            //Improved Chain Heal: 20% bonus healing for Chain Heal
+            if (lvl >= 45 && spellId == GetSpell(CHAIN_HEAL_1))
+                pctbonus += 0.2f;
+            //Improved Earth Shield: 10% bonus healing for Earth Shield
+            //Glyph of Earth Shield: 20% bonus healing for Earth Shield
+            if (lvl >= 50 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.1f + 0.2f;
+            //Improved Shields (part 3): 15% bonus healing for Earth Shield
+            if (lvl >= 15 && spellId == EARTH_SHIELD_HEAL)
+                pctbonus += 0.15f;
+            //Tidal Waves (part 2): 20% bonus (from spellpower) for Healing Wave and 10% bonus (from spellpower) for Lesser Healing Wave
+            if (lvl >= 55)
+            {
+                if (spellId == GetSpell(HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.2f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+                else if (spellId == GetSpell(LESSER_HEALING_WAVE_1))
+                    flat_mod += spellpower * 0.1f * me->CalculateDefaultCoefficient(spellInfo, damagetype) * stack * 1.88f * me->CalculateLevelPenalty(spellInfo) * stack;
+            }
+
+            heal = heal * (1.0f + pctbonus) + flat_mod;
+        }
+
+        void ApplyClassCritMultiplierHeal(Unit const* /*victim*/, float& crit_chance, SpellInfo const* /*spellInfo*/, SpellSchoolMask schoolMask, WeaponAttackType /*attackType*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float aftercrit = 0.0f;
+
+            //Tidal Mastery (part 1): 5% additional critical chance for healing spells
+            if (lvl >= 25 && (schoolMask & SPELL_SCHOOL_MASK_NATURE))
+                aftercrit += 5.f;
+            //Blessing of the Eternals: 4% additional critical chance for all spells
+            if (lvl >= 45)
+                aftercrit += 4.f;
+
+            crit_chance += aftercrit;
+        }
+
+        void OnBotDespawn(Creature* summon)
+        {
+            if (!summon)
+            {
+                UnsummonAll();
+                return;
+            }
+
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned summon %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "SummonedCreatureDespawn(): Shaman bot %s has despawned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            _totems[slot].first.Clear();
+        }
+
+        void OnBotSummon(Creature* summon)
+        {
+            TempSummon* totem = summon->ToTempSummon();
+            if (!totem || !totem->ToTotem())
+            {
+                //TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned creature %s which is not a temp summon or not a totem...", me->GetName().c_str(), summon->GetName().c_str());
+                return;
+            }
+
+            totem->SetCreatorGUID(me->GetGUID());
+
+            int8 slot = -1;
+            switch (totem->m_Properties->Id)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:
+                    slot = T_FIRE;
+                    break;
+                case SUMMON_TYPE_TOTEM_EARTH:
+                    slot = T_EARTH;
+                    break;
+                case SUMMON_TYPE_TOTEM_WATER:
+                    slot = T_WATER;
+                    break;
+                case SUMMON_TYPE_TOTEM_AIR:
+                    slot = T_AIR;
+                    break;
+                default:
+                    TC_LOG_ERROR("entities.player", "OnBotSummon(): Shaman bot %s has summoned totem %s with unknown type %u", me->GetName().c_str(), summon->GetName().c_str(), totem->m_Properties->Id);
+                    return;
+            }
+
+            float radius = 0.f;
+            if (SpellInfo const* info = sSpellMgr->GetSpellInfo(summon->m_spells[0]))
+                if (SpellRadiusEntry const* entry = info->Effects[0].RadiusEntry)
+                    radius = entry->RadiusMax;
+
+            _totems[slot].first = summon->GetGUID();
+            _totems[slot].second.pos.Relocate(*summon);
+            _totems[slot].second.effradius = std::max<float>(radius, 20.f) + 5.f;
+
+            //TC_LOG_ERROR("entities.player", "shaman bot: summoned %s (type %u) at x='%f', y='%f', z='%f'",
+            //    summon->GetName().c_str(), slot, _totems[slot].second.GetPositionX(), _totems[slot].second.GetPositionY(), _totems[slot].second.GetPositionZ());
+
+            summon->SetDisplayId(me->GetModelForTotem(PlayerTotemType(totem->m_Properties->Id)));
+            master->m_SummonSlot[++slot].Clear();
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            //Maelstrom Weapon improved: 10% to gain full stack and 30% to add an extra stack
+            if (spellId == MAELSTROM_WEAPON_BUFF)
+            {
+                if (Aura* mwb = me->GetAura(MAELSTROM_WEAPON_BUFF))
+                {
+                    uint32 stacks = mwb->GetStackAmount();
+                    if (stacks < 5)
+                    {
+                        if (urand(1,100) <= 10)
+                            mwb->ModStackAmount(5);
+                        if (urand(1,100) <= 30)
+                            mwb->ModStackAmount(1);
+                    }
+
+                    MaelstromCount = mwb->GetStackAmount();
+                }
+
+                MaelstromTimer = 30000; //30 sec duration then reset
+            }
+
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+            //Shields improvement, replaces Static Shock (part 2) and Improved Earth Shield (part 1)
+            if (spellId == GetSpell(LIGHTNING_SHIELD_1) ||
+                spellId == GetSpell(EARTH_SHIELD_1)/* ||
+                spellId == GetSpell(WATER_SHIELD_1)*/)
+            {
+                if (Aura* shield = target->GetAura(spellId, me->GetGUID()))
+                {
+                    shield->SetCharges(shield->GetCharges() + 12);
+                }
+            }
+            //Lightning Overload: 20% cast SAME spell with no mana! make sure this does not proc on itself!
+            if (me->getLevel() >= 40 && (spellId == GetSpell(LIGHTNING_SHIELD_1) || spellId == GetSpell(CHAIN_LIGHTNING_1)))
+            {
+                bool cast = (urand(1,100) <= 20);
+                if (spellId == GetSpell(LIGHTNING_BOLT_1))
+                {
+                    if (LOvBolt == false)
+                    {
+                        if (cast)
+                        {
+                            LOvBolt = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvBolt = false;
+                }
+                if (spellId == GetSpell(CHAIN_LIGHTNING_1))
+                {
+                    if (LOvChain == false)
+                    {
+                        if (cast)
+                        {
+                            LOvChain = true;
+                            me->CastSpell(target, spellId, true);
+                        }
+                    }
+                    else
+                        LOvChain = false;
+                }
+            }
+            if (spellId == GetSpell(STORMSTRIKE_1))
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(target, WINDFURY_PROC, true);
+                }
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            if (victim == me)
+                return;
+
+            if (damageType == DIRECT_DAMAGE)
+            {
+                //Windfury: 10% chance
+                if (WindfuryTimer == 0 && me->getLevel() >= 30)
+                {
+                    if (urand(0,100) < 10)
+                        WindfuryTimer = 1000;
+
+                    if (WindfuryTimer > 0)
+                        me->CastSpell(victim, WINDFURY_PROC, true);
+                }
+            }
+
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void UnsummonAll()
+        {
+            for (uint8 i = 0; i != MAX_TOTEMS; ++i)
+            {
+                if (_totems[i].first)
+                {
+                    Unit* to = ObjectAccessor::FindConnectedPlayer(_totems[i].first);
+                    if (!to)
+                    {
+                        //TC_LOG_ERROR("entities.player", "%s has no totem in slot %u during remove!", me->GetName().c_str(), i);
+                        continue;
+                    }
+                    to->ToTotem()->UnSummon();
+                }
+            }
+        }
+
+        void Reset()
+        {
+            HexyCheckTimer = 3000;
+            EarthyCheckTimer = 2000;
+            MaelstromTimer = 0;
+            WindfuryTimer = 0;
+
+            MaelstromCount = 0;
+
+            Hexy = false;
+            Earthy = false;
+            LOvBolt = false;
+            LOvChain = false;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (HexyCheckTimer > diff)          HexyCheckTimer -= diff;
+            if (EarthyCheckTimer > diff)        EarthyCheckTimer -= diff;
+
+            if (MaelstromTimer > diff)          MaelstromTimer -= diff;
+            else if (MaelstromCount > 0)        MaelstromCount = 0;
+
+            if (WindfuryTimer > diff)           WindfuryTimer -= diff;
+            else                                WindfuryTimer = 0;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(HEALING_WAVE_1);
+            InitSpellMap(CHAIN_HEAL_1);
+            InitSpellMap(LESSER_HEALING_WAVE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(RIPTIDE_1) : RemoveSpell(RIPTIDE_1);
+            InitSpellMap(ANCESTRAL_SPIRIT_1);
+            CURE_TOXINS = lvl >= 39 ? InitSpell(me, CLEANSE_SPIRIT_1) : InitSpell(me, CURE_TOXINS_1);
+            InitSpellMap(CURE_TOXINS);
+            InitSpellMap(FLAME_SHOCK_1);
+            InitSpellMap(EARTH_SHOCK_1);
+            InitSpellMap(FROST_SHOCK_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(STORMSTRIKE_1) : RemoveSpell(STORMSTRIKE_1);
+            InitSpellMap(LIGHTNING_BOLT_1);
+            InitSpellMap(CHAIN_LIGHTNING_1);
+            InitSpellMap(LAVA_BURST_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(THUNDERSTORM_1) : RemoveSpell(THUNDERSTORM_1);
+            InitSpellMap(LIGHTNING_SHIELD_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(EARTH_SHIELD_1) : RemoveSpell(EARTH_SHIELD_1);
+     /*NYI*///InitSpellMap(WATER_SHIELD_1);
+            InitSpellMap(WATER_BREATHING_1);
+            InitSpellMap(WATER_WALKING_1);
+  /*CUSTOM*/lvl >= 60 ? InitSpellMap(BLOODLUST_1) : RemoveSpell(BLOODLUST_1);
+            InitSpellMap(PURGE_1);
+            InitSpellMap(WIND_SHEAR_1);
+            InitSpellMap(HEX_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(STONESKIN_TOTEM_1) : RemoveSpell(STONESKIN_TOTEM_1);
+            InitSpellMap(HEALINGSTREAM_TOTEM_1);
+            InitSpellMap(MANASPRING_TOTEM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SEARING_TOTEM_1) : RemoveSpell(SEARING_TOTEM_1);
+            InitSpellMap(WINDFURY_TOTEM_1);
+            InitSpellMap(STRENGTH_OF_EARTH_TOTEM_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(TOTEM_OF_WRATH_1) : RemoveSpell(TOTEM_OF_WRATH_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MANA_TIDE_TOTEM_1) : RemoveSpell(MANA_TIDE_TOTEM_1);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            RefreshAura(ELEMENTAL_WARDING, level >= 58 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION3, level >= 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION2, level >= 15 && level < 18 ? 1 : 0);
+            RefreshAura(ELEMENTAL_DEVASTATION1, level >= 12 && level < 15 ? 1 : 0);
+            RefreshAura(ANCESTRAL_KNOWLEDGE, level >= 30 ? 3 : level >= 20 ? 2 : level >= 10 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 25 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 29 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 28 && level < 29 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 27 && level < 28 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 26 && level < 27 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 25 && level < 26 ? 1 : 0);
+            RefreshAura(WEAPON_MASTERY, level >= 50 ? 3 : level >= 40 ? 2 : level >= 30 ? 1 : 0);
+            RefreshAura(STATIC_SHOCK, level >= 45 ? 2 : level >= 41 ? 1 : 0);
+            RefreshAura(ANCESTRAL_HEALING, level >= 20 ? 1 : 0);
+            RefreshAura(ANCESTRAL_AWAKENING, level >= 50 ? 1 : 0);
+            RefreshAura(SHAMAN_T10_RESTO_4P, level >= 70 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON5, level >= 70 ? 2 : level >= 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON4, level >= 55 && level < 60 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON3, level >= 50 && level < 55 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON2, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(MAELSTROM_WEAPON1, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(UNLEASHED_RAGE, level >= 40 ? 1 : 0);
+            RefreshAura(IMPROVED_STORMSTRIKE, level >= 40 ? 1 : 0);
+            RefreshAura(ELEMENTAL_OATH, level >= 40 ? 1 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_6, level >= 70 ? 3 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_5, level >= 50 && level < 70 ? 3 : 0);
+            RefreshAura(EARTHLIVING_WEAPON_PASSIVE_4, level >= 30 && level < 50 ? 3 : 0);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case HEALING_WAVE_1:
+                case CHAIN_HEAL_1:
+                case LESSER_HEALING_WAVE_1:
+                case RIPTIDE_1:
+                case CURE_TOXINS_1:
+                case CLEANSE_SPIRIT_1:
+                case BLOODLUST_1:
+                case WATER_SHIELD_1:
+                case MANA_TIDE_TOTEM_1:
+                    return true;
+                default:
+                    return false;
+            }
+        }
+
+    private:
+        typedef std::pair<ObjectGuid /*guid*/, TotemParam /*param*/> BotTotem;
+        BotTotem _totems[MAX_TOTEMS];
+        uint32 CURE_TOXINS;
+        //Timers
+        uint32 HexyCheckTimer, EarthyCheckTimer, MaelstromTimer, WindfuryTimer;
+        uint8 MaelstromCount;
+        bool Hexy, Earthy, LOvChain, LOvBolt;
+
+        enum ShamanBaseSpells
+        {
+            HEALING_WAVE_1                      = 331,
+            CHAIN_HEAL_1                        = 1064,
+            LESSER_HEALING_WAVE_1               = 8004,
+            RIPTIDE_1                           = 61295,
+            ANCESTRAL_SPIRIT_1                  = 2008,
+            CURE_TOXINS_1                       = 526,
+            CLEANSE_SPIRIT_1                    = 51886,
+            FLAME_SHOCK_1                       = 8050,
+            EARTH_SHOCK_1                       = 8042,
+            FROST_SHOCK_1                       = 8056,
+            STORMSTRIKE_1                       = 17364,
+            LIGHTNING_BOLT_1                    = 403,
+            CHAIN_LIGHTNING_1                   = 421,
+            LAVA_BURST_1                        = 51505,
+            THUNDERSTORM_1                      = 51490,
+            LIGHTNING_SHIELD_1                  = 324,
+            EARTH_SHIELD_1                      = 974,
+            WATER_SHIELD_1                      = 52127,
+            WATER_BREATHING_1                   = 131,
+            WATER_WALKING_1                     = 546,
+            //BLOODLUST_1                         = 54516,//custom, moved to specials
+            PURGE_1                             = 370,
+            WIND_SHEAR_1                        = 57994,
+            HEX_1                               = 51514,
+            STONESKIN_TOTEM_1                   = 8071,
+            HEALINGSTREAM_TOTEM_1               = 5394,
+            MANASPRING_TOTEM_1                  = 5675,
+            SEARING_TOTEM_1                     = 3599,
+            WINDFURY_TOTEM_1                    = 8512,
+            STRENGTH_OF_EARTH_TOTEM_1           = 8075,
+            TOTEM_OF_WRATH_1                    = 30706,
+            MANA_TIDE_TOTEM_1                   = 16190
+        };
+
+        enum ShamanPassives
+        {
+            //Elemental
+            ELEMENTAL_DEVASTATION1              = 30160,
+            ELEMENTAL_DEVASTATION2              = 29179,
+            ELEMENTAL_DEVASTATION3              = 29180,
+            ELEMENTAL_WARDING                   = 28998,//rank 3
+            ELEMENTAL_OATH                      = 51470,//rank 2
+            //Enchancement
+            ANCESTRAL_KNOWLEDGE                 = 17489,//rank 5
+            TOUGHNESS                           = 16309,//rank 5
+            FLURRY1                             = 16256,
+            FLURRY2                             = 16281,
+            FLURRY3                             = 16282,
+            FLURRY4                             = 16283,
+            FLURRY5                             = 16284,
+            WEAPON_MASTERY                      = 29086,//rank 3
+            UNLEASHED_RAGE                      = 30809,//rank 3
+            STATIC_SHOCK                        = 51527,//rank 3
+            IMPROVED_STORMSTRIKE                = 51522,//rank 2
+            MAELSTROM_WEAPON1                   = 51528,
+            MAELSTROM_WEAPON2                   = 51529,
+            MAELSTROM_WEAPON3                   = 51530,
+            MAELSTROM_WEAPON4                   = 51531,
+            MAELSTROM_WEAPON5                   = 51532,
+            //Restoration
+            ANCESTRAL_HEALING                   = 16240,//rank 3
+            ANCESTRAL_AWAKENING                 = 51558,//rank 3
+            //Special
+            SHAMAN_T10_RESTO_4P                 = 70808 //Chain Heal HoT
+        };
+
+        enum ShamanSpecial
+        {
+            //2 extra white attacks
+            //100 yd
+            //"Increases attack power for 1.50 sec"
+            //Warning! can proc even from itself!
+            WINDFURY_PROC                       = 32910,
+            //"Increases melee,ranged and spell casting speed by 35%
+            //for all party members. Lasts 20 sec."
+            //250 mana, 20 yd
+            //affects raid
+            //no penalty
+            BLOODLUST_1                         = 54516,
+            //20% chance to put HoT on healed target over 12 sec
+            EARTHLIVING_WEAPON_PASSIVE_4        = 52005,//348 base hp
+            EARTHLIVING_WEAPON_PASSIVE_5        = 52007,//456 base hp
+            EARTHLIVING_WEAPON_PASSIVE_6        = 52008,//652 base hp
+
+            MAELSTROM_WEAPON_BUFF               = 53817,
+            STORMSTRIKE_DAMAGE                  = 32175,
+            STORMSTRIKE_DAMAGE_OFFHAND          = 32176,
+
+            LIGHTNING_SHIELD_DAMAGE_1           = 26364,
+            EARTH_SHIELD_HEAL                   = 379
+        };
+    };
+};
+
+
+void AddSC_shaman_bot()
+{
+    new shaman_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warlock_ai.cpp b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
new file mode 100644
index 0000000..d5eac66
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warlock_ai.cpp
@@ -0,0 +1,519 @@
+#include "bot_ai.h"
+//#include "botmgr.h"
+//#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "SpellAuras.h"
+/*
+Warlock NpcBot (reworked by Graff onlysuffering@gmail.com)
+Voidwalker pet AI included
+Complete - 3%
+TODO:
+*/
+class warlock_bot : public CreatureScript
+{
+public:
+    warlock_bot() : CreatureScript("warlock_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warlock_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warlock_botAI : public bot_minion_ai
+    {
+        warlock_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARLOCK;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { me->SetBotsPetDied(); bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+            feartimer = std::max<uint32>(feartimer, 1000);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            ////if pet is dead or unreachable
+            //Creature* m_botsPet = me->GetBotsPet();
+            //if (!m_botsPet || m_botsPet->FindMap() != master->GetMap() || (me->GetDistance2d(m_botsPet) > sWorld->GetMaxVisibleDistanceOnContinents() - 20.f))
+            //    if (master->getLevel() >= 10 && !me->IsInCombat() && !IsCasting() && !me->IsMounted())
+            //        SummonBotsPet(PET_VOIDWALKER);
+
+            //TODO: implement healthstone
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (Potion_cd <= diff && GetManaPCT(me) < 50)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, MANAPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(BOT_CLASS_WARLOCK))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent);
+            }
+            else
+                return;
+
+            //TODO: add more damage spells
+
+            if (feartimer <= diff && GC_Timer <= diff)
+            { CheckFear(); feartimer = 2000; }
+
+            if (IsSpellReady(RAIN_OF_FIRE_1, diff) && !me->isMoving() && HasRole(BOT_ROLE_DPS) && Rand() < 25)
+            {
+                Unit* blizztarget = FindAOETarget(30, true);
+                if (blizztarget && doCast(blizztarget, GetSpell(RAIN_OF_FIRE_1)))
+                    return;
+                SetSpellCooldown(RAIN_OF_FIRE_1, 2000);//fail
+            }
+
+            float dist = me->GetExactDist(opponent);
+
+            if (IsSpellReady(CURSE_OF_THE_ELEMENTS_1, diff) && dist < 30 && Rand() < 15 &&
+                !HasAuraName(opponent, CURSE_OF_THE_ELEMENTS_1) &&
+                doCast(opponent, GetSpell(CURSE_OF_THE_ELEMENTS_1)))
+            {
+                GC_Timer = 800;
+                return;
+            }
+
+            if (IsSpellReady(CORRUPTION_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(CORRUPTION_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(CORRUPTION_1)))
+                return;
+
+            if (IsSpellReady(HAUNT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 25 &&
+                !opponent->HasAura(GetSpell(HAUNT_1), me->GetGUID()) &&
+                doCast(opponent, GetSpell(HAUNT_1)))
+                return;
+
+            if (GC_Timer <= diff && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 15 && !Afflicted(opponent))
+            {
+                if (GetSpellCooldown(CONFLAGRATE_1) <= 8000 && doCast(opponent, GetSpell(IMMOLATE_1)))
+                    return;
+                else if (doCast(opponent, GetSpell(UNSTABLE_AFFLICTION_1)))
+                    return;
+            }
+
+            if (IsSpellReady(CONFLAGRATE_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 35 &&
+                HasAuraName(opponent, IMMOLATE_1) &&
+                doCast(opponent, GetSpell(CONFLAGRATE_1)))
+                return;
+
+            if (IsSpellReady(CHAOS_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 && Rand() < 50 &&
+                doCast(opponent, GetSpell(CHAOS_BOLT_1)))
+                return;
+
+            if (IsSpellReady(SHADOW_BOLT_1, diff) && HasRole(BOT_ROLE_DPS) && dist < 30 &&
+                doCast(opponent, GetSpell(SHADOW_BOLT_1)))
+                return;
+        }
+
+        uint8 Afflicted(Unit* target)
+        {
+            if (!target || target->isDead()) return 0;
+            bool aff = HasAuraName(target, UNSTABLE_AFFLICTION_1, me->GetGUID());
+            bool imm = HasAuraName(target, IMMOLATE_1, me->GetGUID());
+            if (imm) return 1;
+            if (aff) return 2;
+            return 0;
+        }
+
+        void CheckFear()
+        {
+            uint32 FEAR = GetSpell(FEAR_1);
+            if (Unit* u = FindAffectedTarget(FEAR, me->GetGUID()))
+                if (Aura* aura = u->GetAura(FEAR, me->GetGUID()))
+                    if (aura->GetDuration() > 3000)
+                        return;
+            Unit* feartarget = FindFearTarget();
+            if (feartarget && doCast(feartarget, FEAR))
+                return;
+        }
+
+        //void SummonedCreatureDies(Creature* summon, Unit* /*killer*/)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPetDied();
+        //}
+
+        //void SummonedCreatureDespawn(Creature* summon)
+        //{
+        //    if (summon == me->GetBotsPet())
+        //        me->SetBotsPet(NULL);
+        //}
+
+        void ApplyClassDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* /*spellInfo*/, WeaponAttackType /*attackType*/, bool& crit) const
+        {
+            //uint32 spellId = spellInfo->Id;
+            //uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                ////Shatter: frozen targets crit
+                //if (lvl >= 11 && damageinfo.target && damageinfo.target->isFrozen())
+                //    aftercrit *= 4.f;
+
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                ////!!!spell damage is not yet critical and will be multiplied by 1.5
+                ////so we should put here bonus damage mult /1.5
+                ////Spell Power: 50% additional crit damage bonus for All spells
+                //if (lvl >= 55)
+                //    pctbonus += 0.333f;
+            }
+            //if (lvl >= 11 && spellId == FROSTBOLT && damageinfo.target && damageinfo.target->isFrozen())
+            //    pctbonus *= 0.2f;
+
+            ////Spellpower bonus damage (temp)
+            //if (m_spellpower > 0)
+            //{
+            //    if (spellId == SHADOW_BOLT)
+            //        fdamage += m_spellpower * 1.38f;
+            //    else if (spellId == IMMOLATE)
+            //        fdamage += m_spellpower * 0.75f; //guessed
+            //    else if (spellId == CONFLAGRATE)
+            //        fdamage += m_spellpower * 2.75f; //guessed
+            //    else if (spellId == CHAOS_BOLT)
+            //        fdamage += m_spellpower * 2.25f * 1.24f;
+            //    else if (spellId == RAIN_OF_FIRE || spellId == 42223)
+            //        fdamage += m_spellpower * 0.25f * 4.f;
+            //    else if (spellId == HAUNT)
+            //        fdamage += m_spellpower * 1.75f;
+            //}
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassDamageMultiplierEffect(SpellInfo const* /*spellInfo*/, uint8 /*effect_index*/, float& /*value*/) const
+        {
+            //uint32 spellId = spellInfo->Id;
+
+            //float pct_mod = 1.f;
+
+            //Spellpower bonus damage (temp)
+            //if (spellInfo->Effects[effect_index].ApplyAuraName == SPELL_AURA_PERIODIC_DAMAGE)
+            //{
+            //    if (spellId == CORRUPTION)
+            //        value += m_spellpower * 1.35f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == IMMOLATE)
+            //        value += m_spellpower * 1.59f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //    else if (spellId == UNSTABLE_AFFLICTION)
+            //        value += m_spellpower * 1.68f / float(spellInfo->GetMaxDuration() / spellInfo->Effects[effect_index].Amplitude);
+            //}
+
+            //value *= pct_mod;
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            feartimer = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (feartimer > diff)                   feartimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(CURSE_OF_THE_ELEMENTS_1);
+            InitSpellMap(SHADOW_BOLT_1);
+            InitSpellMap(IMMOLATE_1);
+            lvl >= 40 ? InitSpellMap(CONFLAGRATE_1) : RemoveSpell(CONFLAGRATE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(CHAOS_BOLT_1) : RemoveSpell(CHAOS_BOLT_1);
+            InitSpellMap(RAIN_OF_FIRE_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(HAUNT_1) : RemoveSpell(HAUNT_1);
+            InitSpellMap(CORRUPTION_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(UNSTABLE_AFFLICTION_1) : RemoveSpell(UNSTABLE_AFFLICTION_1);
+            InitSpellMap(FEAR_1);
+        }
+
+        //TODO
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+        uint32 feartimer;
+
+        enum WarlockBaseSpells
+        {
+            CURSE_OF_THE_ELEMENTS_1             = 1490,
+            SHADOW_BOLT_1                       = 686,
+            IMMOLATE_1                          = 348,
+            CONFLAGRATE_1                       = 17962,
+            CHAOS_BOLT_1                        = 50796,
+            RAIN_OF_FIRE_1                      = 5740,
+            HAUNT_1                             = 59164,
+            CORRUPTION_1                        = 172,
+            UNSTABLE_AFFLICTION_1               = 30404,
+            FEAR_1                              = 6215
+        };
+        enum WarlockPassives
+        {
+        };
+    };
+};
+
+class voidwalker_bot : public CreatureScript
+{
+public:
+    voidwalker_bot() : CreatureScript("voidwalker_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new voidwalker_botAI(creature);
+    }
+
+    struct voidwalker_botAI : public bot_pet_ai
+    {
+        voidwalker_botAI(Creature* creature) : bot_pet_ai(creature)
+        {
+            _botclass = BOT_CLASS_MAGE;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_NONE) != SPELL_CAST_OK)
+                return false;
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        void EnterCombat(Unit*) { }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit*) { }
+        void EnterEvadeMode() { }
+        void MoveInLineOfSight(Unit*) { }
+        void JustDied(Unit*) { m_creatureOwner->SetBotsPetDied(); }
+        void DoNonCombatActions() { }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (IAmDead()) return;
+            CheckAttackState();
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            if (CCed(me)) return;
+
+            //TODO: add checks to help owner
+
+            if (!me->IsInCombat())
+                DoNonCombatActions();
+
+            if (!CheckAttackTarget(PET_TYPE_VOIDWALKER))
+                return;
+
+            DoNormalAttack(diff);
+        }
+
+        void DoNormalAttack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            if (MoveBehind(*opponent))
+                wait = 5;
+
+            //float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+
+            //TORMENT
+            if (IsSpellReady(TORMENT_1, diff, false) && meleedist < 5 && !IsTank(opponent->GetVictim()))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TORMENT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            OnSpellHit(caster, spell);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (m_creatureOwner->IsAIEnabled)
+                if (bot_minion_ai* ai = m_creatureOwner->GetBotMinionAI())
+                    ai->OnOwnerDamagedBy(u);
+        }
+
+        //debug
+        //void ListSpells(ChatHandler* ch) const
+        //{
+        //    ch->PSendSysMessage("Spells list:");
+        //    ch->PSendSysMessage("Torment: %u", TORMENT);
+        //    ch->PSendSysMessage("End of spells list.");
+        //}
+
+        void Reset()
+        {
+            if (master && m_creatureOwner)
+            {
+                DefaultInit();
+                SetBaseArmor(162 * master->getLevel());
+            }
+        }
+
+        void ReduceCD(uint32 /*diff*/)
+        {
+        }
+
+        void InitSpells()
+        {
+            InitSpellMap(TORMENT_1);
+        }
+
+        void ApplyClassPassives() { }
+
+    private:
+        //Timers
+
+        enum VoidwalkerBaseSpells
+        {
+            TORMENT_1                           = 3716
+        };
+        enum VoidwalkerPassives
+        {
+        };
+    };
+};
+
+void AddSC_warlock_bot()
+{
+    new warlock_bot();
+    new voidwalker_bot();
+}
diff --git a/src/server/game/AI/NpcBots/bot_warrior_ai.cpp b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
new file mode 100644
index 0000000..3cc8060
--- /dev/null
+++ b/src/server/game/AI/NpcBots/bot_warrior_ai.cpp
@@ -0,0 +1,1915 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Group.h"
+#include "Player.h"
+#include "ScriptMgr.h"
+#include "Spell.h"
+#include "SpellAuras.h"
+#include "SpellAuraEffects.h"
+//#include "WorldSession.h"
+/*
+Warrior NpcBot (reworked by Graff onlysuffering@gmail.com)
+Complete - 92-97%
+*/
+class warrior_bot : public CreatureScript
+{
+public:
+    warrior_bot() : CreatureScript("warrior_bot") { }
+
+    CreatureAI* GetAI(Creature* creature) const
+    {
+        return new warrior_botAI(creature);
+    }
+
+    bool OnGossipHello(Player* player, Creature* creature)
+    {
+        return bot_minion_ai::OnGossipHello(player, creature, 0);
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelect(player, creature, sender, action);
+        return true;
+    }
+
+    bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, char const* code)
+    {
+        if (bot_minion_ai* ai = creature->GetBotMinionAI())
+            return ai->OnGossipSelectCode(player, creature, sender, action, code);
+        return true;
+    }
+
+    struct warrior_botAI : public bot_minion_ai
+    {
+        warrior_botAI(Creature* creature) : bot_minion_ai(creature)
+        {
+            _botclass = BOT_CLASS_WARRIOR;
+        }
+
+        bool doCast(Unit* victim, uint32 spellId, bool triggered = false)
+        {
+            if (CheckBotCast(victim, spellId, BOT_CLASS_WARRIOR) != SPELL_CAST_OK)
+                return false;
+
+            if (spellId == BATTLESTANCE_1 || spellId == DEFENSIVESTANCE_1 || spellId == BERSERKERSTANCE_1)
+                temptimer = GC_Timer;
+
+            return bot_ai::doCast(victim, spellId, triggered);
+        }
+
+        uint8 GetBotStance() const
+        {
+            if (battleStance)
+                return WARRIOR_BATTLE_STANCE;
+            else if (defensiveStance)
+                return WARRIOR_DEFENSIVE_STANCE;
+            else if (berserkerStance)
+                return WARRIOR_BERSERKER_STANCE;
+
+            return BOT_STANCE_NONE;
+        }
+
+        void UpdateAI(uint32 diff)
+        {
+            ReduceCD(diff);
+            if (!GlobalUpdate(diff))
+                return;
+            CheckAttackState();
+            getrage();
+            if (ragetimer2 <= diff)
+            {
+                if (me->IsInCombat() && me->getLevel() >= 20)
+                {
+                    if (me->GetPower(POWER_RAGE) < 990)
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) + uint32(10.f * rageIncomeMult)); //1 rage per 2 sec
+                    else
+                        me->SetPower(POWER_RAGE, 1000); //max
+                }
+                ragetimer2 = 2000;
+            }
+            if (ragetimer <= diff)
+            {
+                if (!me->IsInCombat() && !HasAuraName(me, BLOODRAGE_1))
+                {
+                    if (me->GetPower(POWER_RAGE) > uint32(10.f * rageLossMult))
+                        me->SetPower(POWER_RAGE, me->GetPower(POWER_RAGE) - uint32(10.f * rageLossMult)); //-1 rage per 1.5 sec
+                    else
+                        me->SetPower(POWER_RAGE, 0); //min
+                }
+                ragetimer = 1500;
+            }
+            CheckAuras();
+            if (wait == 0)
+                wait = GetWait();
+            else
+                return;
+            BreakCC(diff);
+            if (CCed(me)) return;
+
+            if (Potion_cd <= diff && GetHealthPCT(me) < 67)
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, HEALINGPOTION))
+                {
+                    Potion_cd = POTION_CD;
+                    GC_Timer = temptimer;
+                }
+            }
+            CheckShouts(diff);
+            CheckVigilance(diff);
+            CheckIntervene(diff);
+            CheckSpellReflect(diff);
+            if (!me->IsInCombat())
+                DoNonCombatActions(diff);
+
+            if (!CheckAttackTarget(BOT_CLASS_WARRIOR))
+            {
+                if (!IsTank() && !me->IsInCombat() && battleStance != true && master->getAttackers().empty() &&
+                    stancetimer <= diff && Rand() < 25)
+                    stanceChange(diff, 1);
+                return;
+            }
+
+            if (IsSpellReady(BLOODRAGE_1, diff, false) && me->IsInCombat() && rage < 600 &&
+                Rand() < 20 && !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(BLOODRAGE_1)))
+                {
+                    GC_Timer = temptimer;
+                    getrage();
+                }
+            }
+
+            Attack(diff);
+        }
+
+        void StartAttack(Unit* u, bool force = false)
+        {
+            if (GetBotCommandState() == COMMAND_ATTACK && !force) return;
+            Aggro(u);
+            SetBotCommandState(COMMAND_ATTACK);
+            OnStartAttack(u);
+            GetInPosition(force);
+        }
+
+        void EnterCombat(Unit* u) { bot_minion_ai::EnterCombat(u); }
+        void Aggro(Unit*) { }
+        void AttackStart(Unit*) { }
+        void KilledUnit(Unit* u)
+        {
+            //Victorious State spell
+            //only on targets which give xp or honor
+            if (me->getLevel() >= 5 && u->getLevel() + 9 >= me->getLevel())
+                me->CastSpell(me, VICTORIOUS_SPELL, true);
+        }
+        void EnterEvadeMode() { bot_minion_ai::EnterEvadeMode(); }
+        void MoveInLineOfSight(Unit* u) { bot_minion_ai::MoveInLineOfSight(u); }
+        void JustDied(Unit* u) { bot_minion_ai::JustDied(u); }
+        void DoNonCombatActions(uint32 /*diff*/) { }
+
+        void modrage(int32 mod, bool set = false)
+        {
+            if (set && mod < 0)
+                return;
+            if (mod < 0 && rage < abs(mod))
+            {
+                //debug set rage to 0
+                mod = 0;
+                set = true;
+                return;
+            }
+
+            if (set)
+                rage = mod ? mod*10 : 0;
+            else
+                rage += mod*10;
+
+            me->SetPower(POWER_RAGE, rage);
+        }
+
+        int32 getrage()
+        {
+            rage = me->GetPower(POWER_RAGE);
+            if (me->FindCurrentSpellBySpellId(GetSpell(CLEAVE_1)))
+                rage = std::max<int32>(rage - 200, 0);
+            else if (me->FindCurrentSpellBySpellId(GetSpell(HEROIC_STRIKE_1)))
+                rage = std::max<int32>(rage - 150, 0);
+
+            return rage;
+        }
+
+        int32 rcost(uint32 spellId) const
+        {
+            if (SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(spellId))
+                return spellInfo->CalcPowerCost(me, spellInfo->GetSchoolMask());
+            return 0;
+        }
+
+        void BreakCC(uint32 diff)
+        {
+            if (me->HasAuraWithMechanic((1<<MECHANIC_FEAR)|(1<<MECHANIC_SAPPED)|(1<<MECHANIC_DISORIENTED)))
+            {
+                if (IsSpellReady(BERSERKERRAGE_1, diff) && Rand() < 35 && !me->HasAura(ENRAGED_REGENERATION_1) &&
+                    doCast(me, GetSpell(BERSERKERRAGE_1)))
+                    return;
+            }
+            bot_minion_ai::BreakCC(diff);
+        }
+
+        void Attack(uint32 diff)
+        {
+            opponent = me->GetVictim();
+            if (opponent)
+            {
+                if (!IsCasting())
+                    StartAttack(opponent, true);
+            }
+            else
+                return;
+            //Keep defensive stance if tank
+            if (IsTank() && defensiveStance != true && stancetimer <= diff)
+                stanceChange(diff, 2);
+            //SelfHeal
+            if (IsSpellReady(ENRAGED_REGENERATION_1, diff) && rage > rcost(ENRAGED_REGENERATION_1) &&
+                GetHealthPCT(me) < 40 && Rand() < 40 && me->HasAuraWithMechanic(uint32(1<<MECHANIC_ENRAGED)))
+            {
+                if (doCast(me, GetSpell(ENRAGED_REGENERATION_1)))
+                    return;
+            }
+
+            AttackerSet m_attackers = master->getAttackers();
+            AttackerSet b_attackers = me->getAttackers();
+            float dist = me->GetExactDist(opponent);
+            float meleedist = me->GetDistance(opponent);
+            //charge + warbringer
+            if (IsSpellReady(CHARGE_1, diff, false) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                (me->getLevel() >= 50 ||
+                (!me->IsInCombat() && (battleStance || stanceChange(diff, 1)))))
+            {
+                temptimer = GC_Timer;
+                if (me->getLevel() >= 29)
+                    me->RemoveMovementImpairingAuras();
+                if (doCast(opponent, GetSpell(CHARGE_1), me->IsInCombat()))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //intercept
+            if (IsSpellReady(INTERCEPT_1, diff, false) && !IsTank() &&
+                rage > rcost(INTERCEPT_1) && dist > 11 && dist < 25 && me->HasInArc(M_PI, opponent) &&
+                !CCed(opponent) && (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(opponent, GetSpell(INTERCEPT_1)))
+                    return;
+            }
+            //SelfHeal 2 - LAST STAND
+            if (IsSpellReady(LAST_STAND_1, diff, false) && IsTank() && Rand() < 67 &&
+                GetHealthPCT(me) < (30 + 20 * (b_attackers.size() > 1) + 10 * me->HasAuraType(SPELL_AURA_PERIODIC_DAMAGE)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(LAST_STAND_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //FEAR
+            if (IsSpellReady(INTIMIDATING_SHOUT_1, diff) && Rand() < 70 && rage > rcost(INTIMIDATING_SHOUT_1))
+            {
+                if (opponent->IsNonMeleeSpellCast(false, false, true) && dist <= 8 &&
+                    !(opponent->ToCreature() && opponent->ToCreature()->GetCreatureType() == CREATURE_TYPE_UNDEAD))
+                {
+                    if (doCast(opponent, GetSpell(INTIMIDATING_SHOUT_1)))
+                        return;
+                }
+                Unit* fearTarget = NULL;
+                bool triggered = false;
+                uint8 tCount = 0;
+                //fear master's attackers
+                if (!m_attackers.empty() &&
+                    ((master->getClass() != BOT_CLASS_DEATH_KNIGHT &&
+                    master->getClass() != BOT_CLASS_WARRIOR &&
+                    master->getClass() != BOT_CLASS_PALADIN) ||
+                    GetHealthPCT(master) < 70))
+                {
+                    for(AttackerSet::iterator iter = m_attackers.begin(); iter != m_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+                //Defend myself
+                if (b_attackers.size() > 1)
+                {
+                    tCount = 0;
+                    fearTarget = NULL;
+                    triggered = false;
+                    for(AttackerSet::iterator iter = b_attackers.begin(); iter != b_attackers.end(); ++iter)
+                    {
+                        if (!(*iter)) continue;
+                        if ((*iter)->GetCreatureType() == CREATURE_TYPE_UNDEAD) continue;
+                        if (me->GetExactDist((*iter)) <= 8 && (*iter)->isTargetableForAttack())
+                        {
+                            ++tCount;
+                            fearTarget = (*iter);
+                            if (tCount > 1) break;
+                        }
+                    }
+                    if (tCount > 0 && !fearTarget)
+                    {
+                        fearTarget = opponent;
+                        triggered = true;
+                    }
+                    if (tCount > 1 && doCast(fearTarget, GetSpell(INTIMIDATING_SHOUT_1), triggered))
+                        return;
+                }
+            }//end FEAR
+            //TAUNT //No GCD
+            Unit* u = opponent->GetVictim();
+            if (IsSpellReady(TAUNT_1, diff, false) && u && u != me && !IsTank(u) && dist <= 30 &&
+                !CCed(opponent) && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u) &&
+                (defensiveStance || (stancetimer <= diff && stanceChange(diff, 2))))
+            {
+                temptimer = GC_Timer;
+                if (doCast(opponent, GetSpell(TAUNT_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //CHALLENGING SHOUT
+            if (IsSpellReady(CHALLENGING_SHOUT_1, diff))
+            {
+                u = opponent->GetVictim();
+                if (u && u != me && !IsTank(u) && !CCed(opponent) && dist <= 10 && rage > rcost(CHALLENGING_SHOUT_1) &&
+                    Rand() < 30 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u))
+                {
+                    if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                        return;
+                }
+                if (IsTank() && rage > rcost(CHALLENGING_SHOUT_1) && Rand() < 20)
+                {
+                    std::list<Unit*> targets;
+                    GetNearbyTargetsList(targets);
+                    if (int8(targets.size()) - int8(b_attackers.size()) >= 1)
+                        if (doCast(me, GetSpell(CHALLENGING_SHOUT_1)))
+                            return;
+                }
+            }
+            u = opponent->GetVictim();
+            //MOCKING BLOW
+            if (IsSpellReady(MOCKING_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && u && u != me && !IsTank(u) &&
+                meleedist <= 5 && rage > rcost(MOCKING_BLOW_1) &&
+                !CCed(opponent) && Rand() < 70 && (!IsTankingClass(u->getClass()) || IsTank()) && IsInBotParty(u) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(MOCKING_BLOW_1)))
+                    return;
+            }
+            //SHIELD SLAM
+            if (IsSpellReady(SHIELD_SLAM_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                meleedist <= 5 && rage > rcost(SHIELD_SLAM_1) && CanBlock() &&
+                Rand() < (55 + 200*me->HasAura(SWORD_AND_BOARD_BUFF)))
+            {
+                //check Shield Block
+                if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && (defensiveStance || stanceChange(diff, 2)))
+                {
+                    temptimer = GC_Timer;
+
+                    if (!doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                        return;
+
+                    GC_Timer = temptimer;
+                }
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(opponent, GetSpell(SHIELD_SLAM_1)))
+                        return;
+                }
+            }
+            //SHIELD BLOCK
+            if (IsSpellReady(SHIELD_BLOCK_1, diff, false) && CanBlock() && IsTank() &&
+                ((u == me && meleedist <= 8) || (!b_attackers.empty() && me->GetDistance2d(*(b_attackers.begin())) <= 8)) &&
+                GetHealthPCT(me) < (65 + 8 * uint8(b_attackers.size())) && Rand() < 50 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(me, GetSpell(SHIELD_BLOCK_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HEROIC THROW
+            if (IsSpellReady(HEROIC_THROW_1, diff) && HasRole(BOT_ROLE_DPS) && dist <= 30 &&
+                Rand() < (20 + 70 * opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(HEROIC_THROW_1)))
+                    return;
+            }
+            //SHOCKWAVE - frontal cone
+            if (IsSpellReady(SHOCKWAVE_1, diff) && HasRole(BOT_ROLE_DPS) && CanBlock() && dist <= 10 && !CCed(opponent) &&
+                rage > rcost(SHOCKWAVE_1) && Rand() < (30 + 50 * opponent->IsNonMeleeSpellCast(true)) &&
+                me->HasInArc(M_PI / 2.f, opponent) && opponent->IsWithinLOSInMap(me))
+            {
+                if (doCast(me, GetSpell(SHOCKWAVE_1)))
+                    return;
+            }
+            //OVERPOWER
+            if (IsSpellReady(OVERPOWER_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(OVERPOWER_1) &&
+                (battleStance || stancetimer <= diff) &&/* Rand() < 80 &&*/
+                (me->HasReactive(REACTIVE_OVERPOWER) ||
+                (IsSpellReady(TASTE_FOR_BLOOD_BUFF, diff, false) && me->HasAura(TASTE_FOR_BLOOD_BUFF))))
+            {
+                if (battleStance || stanceChange(diff, 1))
+                {
+                    //custom
+                    me->CastSpell(opponent, GetSpell(OVERPOWER_1));
+                    return;
+                }
+            }
+            //THUNDER CLAP
+            if (IsSpellReady(THUNDER_CLAP_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                dist <= 8 && rage > rcost(THUNDER_CLAP_1) && Rand() < 20 &&
+                (battleStance || defensiveStance || stancetimer <= diff) &&
+                (IsTank() || !HasAuraName(opponent, THUNDER_CLAP_1)))
+            {
+                if (battleStance || defensiveStance || stanceChange(diff, 4))
+                {
+                    if (doCast(me, GetSpell(THUNDER_CLAP_1)))
+                        return;
+                }
+            }
+            //DEVASTATE - only with shield
+            if (IsSpellReady(DEVASTATE_1, diff) && HasRole(BOT_ROLE_DPS)/* && IsTank()*/ && CanBlock() &&
+                meleedist <= 5 && rage > rcost(DEVASTATE_1) && Rand() < 70)
+            {
+                if (doCast(opponent, GetSpell(DEVASTATE_1)))
+                    return;
+            }
+            //REVENGE
+            if (IsSpellReady(REVENGE_1, diff) && me->HasAuraState(AURA_STATE_DEFENSE) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(REVENGE_1) && Rand() < 30 &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (defensiveStance || stanceChange(diff, 2))
+                {
+                    if (doCast(opponent, GetSpell(REVENGE_1)))
+                    {
+                        //Improved Revenge (part 2): find second target
+                        if (me->getLevel() >= 25)
+                            if (Unit* u = FindSplashTarget(5, opponent))
+                                me->CastSpell(u, GetSpell(REVENGE_1), true);
+                        return;
+                    }
+                }
+            }
+
+            if (MoveBehind(*opponent))
+                wait = 15;
+
+            //CONCUSSION_BLOW
+            if (IsSpellReady(CONCUSSION_BLOW_1, diff) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(CONCUSSION_BLOW_1) && !CCed(opponent) &&
+                Rand() < (30 + 60 * opponent->IsNonMeleeSpellCast(false)))
+            {
+                if (doCast(opponent, GetSpell(CONCUSSION_BLOW_1)))
+                    return;
+            }
+            //HAMSTRING
+            if (IsSpellReady(HAMSTRING_1, diff) && (!GetSpell(PIERCING_HOWL_1) || opponent->GetTypeId() == TYPEID_PLAYER) &&
+                opponent->isMoving() && meleedist <= 5 && rage > rcost(HAMSTRING_1) &&
+                Rand() < 50 && (battleStance || berserkerStance || stancetimer <= diff) &&
+                !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(HAMSTRING_1)))
+                        return;
+            }
+            //PIERCING HOWL
+            if (IsSpellReady(PIERCING_HOWL_1, diff) && opponent->isMoving() && meleedist <= 9 && rage > rcost(PIERCING_HOWL_1) &&
+                Rand() < 70 && !opponent->HasAuraWithMechanic((1<<MECHANIC_SNARE)|(1<<MECHANIC_ROOT)))
+            {
+                if (doCast(me, GetSpell(PIERCING_HOWL_1)))
+                    return;
+            }
+            //DISARM
+            if (IsSpellReady(DISARM_1, diff) && meleedist <= 5 && rage > rcost(DISARM_1) && Rand() < 50 &&
+                !opponent->HasAuraType(SPELL_AURA_MOD_DISARM) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                //check weapons
+                bool hasWeapon = true;
+                if (opponent->GetTypeId() == TYPEID_UNIT && !opponent->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID))
+                    hasWeapon = false;
+                else if (Player* pla = opponent->ToPlayer())
+                    if (!pla->GetWeaponForAttack(BASE_ATTACK) || !pla->IsUseEquipedWeapon(true))
+                        hasWeapon = false;
+
+                if (hasWeapon && (defensiveStance || stanceChange(diff, 2)) &&
+                    doCast(opponent, GetSpell(DISARM_1)))
+                    return;
+            }
+            //Victory Rush
+            if (IsSpellReady(VICTORY_RUSH_1, diff) && VICTORIOUS && HasRole(BOT_ROLE_DPS) && !IsTank() && meleedist <= 5/* &&
+                (b_attackers.size() <= 1 || (GetHealthPCT(me) < std::max<int32>(100 - b_attackers.size() * 10, 75)))*/ &&
+                (battleStance || berserkerStance || stancetimer <= diff))
+            {
+                if (battleStance || berserkerStance || stanceChange(diff, 5))
+                    if (doCast(opponent, GetSpell(VICTORY_RUSH_1)))
+                        return;
+            }
+            //UBERS
+            //Shield Wall
+            if (IsSpellReady(SHIELD_WALL_1, diff, false) && CanBlock() &&
+                GetHealthPCT(me) < (30 + 4 * b_attackers.size() + 10 * (opponent->GetTypeId() == TYPEID_UNIT && opponent->ToCreature()->isWorldBoss())) &&
+                Rand() < 70 &&
+                (defensiveStance || stanceChange(diff, 2)))
+            {
+                temptimer = GC_Timer;
+                if (doCast(me, GetSpell(SHIELD_WALL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //Retaliation
+            if (IsSpellReady(RETALIATION_1, diff) && HasRole(BOT_ROLE_DPS) && b_attackers.size() > 4 && Rand() < 30 &&
+                (battleStance || stanceChange(diff, 1)))
+            {
+                if (doCast(me, GetSpell(RETALIATION_1)))
+                    return;
+            }
+            //Recklessness
+            if (IsSpellReady(RECKLESSNESS_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                (m_attackers.size() > 3 || opponent->GetHealth() > me->GetHealth() * 10) && Rand() < 20 &&
+                (berserkerStance || stanceChange(diff, 3)))
+            {
+                if (doCast(me, GetSpell(RECKLESSNESS_1)))
+                    return;
+            }
+            //DEATHWISH
+            if (IsSpellReady(DEATHWISH_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && dist <= 20 && rage > rcost(DEATHWISH_1) &&
+                opponent->GetHealth() > me->GetHealth()/2 && Rand() < 20 &&
+                !me->HasAura(ENRAGED_REGENERATION_1))
+            {
+                if (doCast(me, GetSpell(DEATHWISH_1)))
+                    return;
+            }
+            //EXECUTE
+            if (IsSpellReady(EXECUTE_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(EXECUTE_1) &&
+                opponent->HasAuraState(AURA_STATE_HEALTHLESS_20_PERCENT) && Rand() < 70 &&
+                (battleStance || berserkerStance || (stancetimer <= diff && stanceChange(diff, 5))))
+            {
+                if (doCast(opponent, GetSpell(EXECUTE_1)))
+                {
+                    //sudden death
+                    if (me->getLevel() >= 50 && rage <= 400)
+                        modrage(10, true);
+                    else if (rage > 300)
+                        modrage(-30);
+                    else
+                        modrage(0, true);
+                    return;
+                }
+            }
+            //SUNDER ARMOR
+            if (IsSpellReady(SUNDER_1, diff) && !GetSpell(DEVASTATE_1) && IsTank() &&
+                meleedist <= 5 && rage > rcost(SUNDER_1) &&
+                opponent->GetHealth() > me->GetMaxHealth() && Rand() < 45)
+            {
+                Aura* sunder = opponent->GetAura(GetSpell(SUNDER_1), me->GetGUID());
+                if ((!sunder || sunder->GetStackAmount() < 5 || sunder->GetDuration() < 15000) &&
+                    doCast(opponent, GetSpell(SUNDER_1)))
+                    return;
+            }
+            //SS //no GCD //no rage (glyph)
+            if (IsSpellReady(SWEEPING_STRIKES_1, diff, false) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                dist <= 20 && rage > rcost(SWEEPING_STRIKES_1) &&
+                (battleStance || berserkerStance || stancetimer <= diff) && Rand() < 25 &&
+                (b_attackers.size() > 1 || FindSplashTarget(7, opponent)))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || berserkerStance || stanceChange(diff, 5)) &&
+                    doCast(me, GetSpell(SWEEPING_STRIKES_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //WHIRLWIND
+            if (IsSpellReady(WHIRLWIND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                (berserkerStance || stancetimer <= diff) &&
+                dist <= 10 && rage > rcost(WHIRLWIND_1) && Rand() < 50 &&
+               ((rage > 800 && dist <= 7) || FindSplashTarget(7, opponent)))
+            {
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(me, GetSpell(WHIRLWIND_1)))
+                    return;
+            }
+            //BLADESTORM
+            if (IsSpellReady(BLADESTORM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+               dist <= 10 && rage > rcost(BLADESTORM_1) &&
+               (b_attackers.size() > 1 || opponent->GetHealth() > me->GetMaxHealth()) &&
+               (Rand() < 20 || me->HasAura(RECKLESSNESS_1)))
+            {
+                if (doCast(me, GetSpell(BLADESTORM_1)))
+                    return;
+            }
+            //Mortal Strike
+            if (IsSpellReady(MORTALSTRIKE_1, diff) && HasRole(BOT_ROLE_DPS) &&
+                meleedist <= 5 && rage > rcost(MORTALSTRIKE_1) && Rand() < 50)
+            {
+                if (doCast(opponent, GetSpell(MORTALSTRIKE_1)))
+                    return;
+            }
+            //Slam
+            if (IsSpellReady(SLAM_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() && !opponent->isMoving() &&
+                meleedist <= 5 && rage > rcost(SLAM_1) && Rand() < (20 + 80 * me->HasAura(BLOODSURGE_BUFF)))
+            {
+                if (doCast(opponent, GetSpell(SLAM_1)))
+                    return;
+            }
+            //SHIELD BASH - shared cd with pummel
+            if (IsSpellReady(SHIELD_BASH_1, diff, false) && CanBlock() &&
+                meleedist <= 5 && rage > rcost(SHIELD_BASH_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCast(false) &&
+                (battleStance || defensiveStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((battleStance || defensiveStance || stanceChange(diff, 4)) &&
+                    doCast(opponent, GetSpell(SHIELD_BASH_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //PUMMEL - shared cd with shield bash
+            if (IsSpellReady(PUMMEL_1, diff, false) && !IsTank() &&
+                meleedist <= 5 && rage > rcost(PUMMEL_1) && Rand() < 80 &&
+                opponent->IsNonMeleeSpellCast(false) &&
+                (berserkerStance || stancetimer <= diff))
+            {
+                temptimer = GC_Timer;
+                if ((berserkerStance || stanceChange(diff, 3)) &&
+                    doCast(opponent, GetSpell(PUMMEL_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //REND
+            if (IsSpellReady(REND_1, diff) && HasRole(BOT_ROLE_DPS) && !IsTank() &&
+                opponent->GetHealth() > me->GetMaxHealth()/2 && meleedist <= 5 && rage > rcost(REND_1) &&
+                Rand() < 50 && !opponent->HasAura(GetSpell(REND_1), me->GetGUID()) &&
+                (battleStance || defensiveStance || (stancetimer <= diff && stanceChange(diff, 4))))
+            {
+                if (doCast(opponent, GetSpell(REND_1)))
+                    return;
+            }
+
+            //skip if already have cleave of heroic strike casted
+            if (me->GetCurrentSpell(CURRENT_MELEE_SPELL))
+                return;
+
+            //CLEAVE //no GCD
+            if (IsSpellReady(CLEAVE_1, diff, false) && HasRole(BOT_ROLE_DPS) &&
+                meleedist <= 5 && (!IsTank() || rage > 500) && rage > rcost(CLEAVE_1) && Rand() < 25)
+            {
+                temptimer = GC_Timer;
+                u = FindSplashTarget(5);
+                if (u && doCast(opponent, GetSpell(CLEAVE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+            //HEROIC STRIKE
+            if (IsSpellReady(HEROIC_STRIKE_1, diff, false) && HasRole(BOT_ROLE_DPS) && IsTank() &&
+                meleedist <= 5 && rage > rcost(HEROIC_STRIKE_1) && Rand() < (15 + rage / 10))
+            {
+                temptimer = GC_Timer;
+                if (u && doCast(opponent, GetSpell(HEROIC_STRIKE_1)))
+                {
+                    GC_Timer = temptimer;
+                    return;
+                }
+            }
+        }//end Attack
+
+        void CheckShouts(uint32 diff)
+        {
+            if (shoutCheckTimer > diff || GC_Timer > diff || me->IsMounted() || IsCasting() ||
+                /*rage < rcost(BATTLESHOUT_1) || */Rand() > 35)
+                return;
+
+            shoutCheckTimer = 3000;
+
+            if (IAmFree())
+            {
+                if (!HasAuraName(me, BATTLESHOUT_1, me->GetGUID()))
+                {
+                    if (rage < rcost(BATTLESHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLOODRAGE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            if (doCast(me, GetSpell(BATTLESHOUT_1)))
+                                return;
+                        }
+                    }
+                }
+
+                return;
+            }
+
+            bool hasBS = HasAuraName(me, BATTLESHOUT_1/*, me->GetGUID()*/);
+            bool hasCS = HasAuraName(me, COMMANDING_SHOUT_1/*, me->GetGUID()*/);
+            if (hasCS || hasBS)
+                return;
+
+            if (me->GetDistance2d(master) < 30/* && master->IsWithinLOSInMap(me)*/)
+            {
+                bool battleshout = !hasBS && (!IsTank(me) || !GetSpell(COMMANDING_SHOUT_1));
+                bool commandingshout = !hasCS && GetSpell(COMMANDING_SHOUT_1);
+
+                if (battleshout || commandingshout)
+                {
+                    if (rage < rcost(BATTLESHOUT_1) && IsSpellReady(BLOODRAGE_1, diff, false))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(me, GetSpell(BLOODRAGE_1)))
+                            GC_Timer = temptimer;
+                    }
+
+                    if ((battleshout && doCast(me, GetSpell(BATTLESHOUT_1))) ||
+                        (commandingshout && doCast(me, GetSpell(COMMANDING_SHOUT_1))))
+                    {
+                        shoutCheckTimer = 10000;
+                        return;
+                    }
+                }
+            }
+        }
+
+        void CheckVigilance(uint32 diff)
+        {
+            if (!IsSpellReady(VIGILANCE_1, diff) || me->IsInCombat() || me->IsMounted() || IsCasting() || Rand() > 50)
+                return;
+
+            uint32 VIGILANCE = GetSpell(VIGILANCE_1);
+
+            Unit* u = ObjectAccessor::FindConnectedPlayer(vigilanceTargetGuid);
+
+            if (u)
+            {
+                if (!IsTank())
+                {
+                    u->RemoveAura(VIGILANCE, me->GetGUID(), 0, AURA_REMOVE_BY_EXPIRE);
+                    vigilanceTargetGuid.Clear();
+                }
+                if (IAmFree())
+                    return;
+            }
+            else if (IsTank())
+            {
+                Group* pGroup = master->GetGroup();
+                if (!pGroup)
+                {
+                    if (me->GetExactDist(master) < 30 && !master->HasAura(VIGILANCE))
+                        u = master;
+                }
+                else
+                {
+                    for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* pPlayer = itr->GetSource();
+                        if (!pPlayer || !pPlayer->IsInWorld() || pPlayer->isDead()) continue;
+                        if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                        if (!IsTankingClass(pPlayer->getClass()) && me->GetExactDist(pPlayer) < 30 &&
+                            !pPlayer->HasAura(VIGILANCE))
+                        {
+                            u = pPlayer;
+                            break;
+                        }
+                    }
+                    if (!u)
+                    {
+                        for (GroupReference* itr = pGroup->GetFirstMember(); itr != NULL; itr = itr->next())
+                        {
+                            Player* pPlayer = itr->GetSource();
+                            if (!pPlayer || !pPlayer->IsInWorld() || !pPlayer->HaveBot()) continue;
+                            if (me->GetMapId() != pPlayer->GetMapId()) continue;
+                            BotMap const* map = pPlayer->GetBotMgr()->GetBotMap();
+                            for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                            {
+                                Creature* cre = it->second;
+                                if (!cre || !cre->IsInWorld() || cre == me || cre->isDead()) continue;
+                                if (!IsTankingClass(cre->GetBotClass()) && me->GetExactDist(cre) < 30 &&
+                                    !cre->HasAura(VIGILANCE))
+                                {
+                                    u = cre;
+                                    break;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                if (u && doCast(u, VIGILANCE))
+                {
+                    vigilanceTargetGuid = u->GetGUID();
+                    return;
+                }
+            }
+
+            SetSpellCooldown(VIGILANCE_1, 10000); //fail
+        }
+
+        void CheckIntervene(uint32 diff)
+        {
+            if (IsSpellReady(INTERVENE_1, diff, false) && GetBotCommandState() != COMMAND_STAY &&
+                !me->IsMounted() && rage > rcost(INTERVENE_1) &&
+                !IAmFree() && !IsCasting() && Rand() < (IsTank() ? 80 : 30) &&
+                (defensiveStance || stancetimer <= diff))
+            {
+                if (!master->IsInCombat() && master->getAttackers().empty() && master->isMoving())
+                {
+                    float mydist = me->GetExactDist(master);
+                    if (mydist < 24 && mydist > 19 && (defensiveStance || stanceChange(diff, 2)))
+                    {
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            Follow(true);
+                            return;
+                        }
+                    }
+                }
+                Group* gr = master->GetGroup();
+                if (!gr)
+                {
+                    if (GetHealthPCT(master) < 95 && !master->getAttackers().empty() &&
+                        me->getAttackers().size() <= master->getAttackers().size())
+                    {
+                        float dist = me->GetExactDist(master);
+                        if (dist > 25 || dist < 10) return;
+                        if (!(defensiveStance || stanceChange(diff, 2))) return;
+                        temptimer = GC_Timer;
+                        if (doCast(master, GetSpell(INTERVENE_1)))
+                        {
+                            GC_Timer = temptimer;
+                            return;
+                        }
+                    }
+                }
+                else
+                {
+                    bool Bots = false;
+                    float dist;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        if (tPlayer->HaveBot())
+                            Bots = true;
+                        if (tPlayer->isDead() || GetHealthPCT(tPlayer) > 90 || IsTank(tPlayer)) continue;
+                        if (tPlayer->getAttackers().size() < me->getAttackers().size()) continue;
+                        dist = me->GetExactDist(tPlayer);
+                        if (dist > 24 || dist < 10) continue;
+                        if (defensiveStance || stanceChange(diff, 2))
+                        {
+                            temptimer = GC_Timer;
+                            if (doCast(tPlayer, GetSpell(INTERVENE_1)))
+                            {
+                                GC_Timer = temptimer;
+                                return;
+                            }
+                        }
+                    }
+                    if (!Bots) return;
+                    for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                    {
+                        Player* tPlayer = itr->GetSource();
+                        if (!tPlayer || !tPlayer->HaveBot()) continue;
+                        if (!tPlayer->IsInWorld() || tPlayer->IsBeingTeleported()) continue;
+                        if (tPlayer->FindMap() != me->GetMap()) continue;
+                        BotMap const* map = tPlayer->GetBotMgr()->GetBotMap();
+                        for (BotMap::const_iterator it = map->begin(); it != map->end(); ++it)
+                        {
+                            Creature* bot = it->second;
+                            if (!bot || !bot->IsInWorld() || bot == me || bot->isDead()) continue;
+                            if (GetHealthPCT(bot) > 90 || IsTank(bot)) continue;
+                            dist = me->GetExactDist(bot);
+                            if (dist > 25 || dist < 10) continue;
+                            if (bot->getAttackers().size() <= me->getAttackers().size()) continue;
+                            if (defensiveStance || stanceChange(diff, 2))
+                            {
+                                temptimer = GC_Timer;
+                                if (doCast(bot, GetSpell(INTERVENE_1)))
+                                {
+                                    GC_Timer = temptimer;
+                                    return;
+                                }
+                            }
+                        }
+                    }
+                }
+
+                SetSpellCooldown(INTERVENE_1, 2000); //fail
+            }
+        }
+
+        void CheckSpellReflect(uint32 diff)
+        {
+            if (!IsSpellReady(SPELL_REFLECTION_1, diff, false) || me->IsMounted() || IsCasting() ||
+                !CanBlock() || !(battleStance || defensiveStance || stancetimer <= diff) ||
+                rage < rcost(SPELL_REFLECTION_1) || Rand() > 35)
+                return;
+
+            //use simpliest finder - first match (covers most cases)
+            if (Unit* target = FindCastingTarget(70))
+            {
+                temptimer = GC_Timer;
+                for (uint8 i = CURRENT_FIRST_NON_MELEE_SPELL; i != CURRENT_AUTOREPEAT_SPELL; ++i)
+                    if (Spell* spell = target->GetCurrentSpell(CurrentSpellTypes(i)))
+                        if (!spell->GetSpellInfo()->IsChanneled())
+                            if (spell->GetSpellInfo()->DmgClass == SPELL_DAMAGE_CLASS_MAGIC &&
+                                !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_ABILITY) &&
+                                !(spell->GetSpellInfo()->AttributesEx & SPELL_ATTR1_CANT_BE_REFLECTED) &&
+                                !(spell->GetSpellInfo()->Attributes & SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY) &&
+                                !spell->GetSpellInfo()->IsPassive() && !spell->GetSpellInfo()->IsPositive())
+                                if (Unit* u = spell->m_targets.GetUnitTarget())
+                                    if (u == me || (me->GetDistance(u) < 20 && !IAmFree() && IsInBotParty(u)))
+                                        if (doCast(me, GetSpell(SPELL_REFLECTION_1)))
+                                        {
+                                            GC_Timer = temptimer;
+                                            return;
+                                        }
+            }
+
+            SetSpellCooldown(SPELL_REFLECTION_1, 1000); //fail
+        }
+
+        bool stanceChange(uint32 diff, uint8 stance)
+        {
+            if (stancetimer > diff || !stance)
+                return false;
+
+            if (stance == 5)
+                stance = (me->getLevel() >= 30 && !IsTank() && urand(1,100) > 70) ? 3 : 1;
+            else if (stance == 4)
+                stance = (me->getLevel() >= 10 && (IsTank() || urand(1,100) > 50)) ? 2 : 1;
+
+            if (stance == 2 && me->getLevel() < 10)
+                return false;
+            if (stance == 3 && me->getLevel() < 30)
+                return false;
+
+            switch (stance)
+            {
+                case 1:
+                    if (doCast(me, GetSpell(BATTLESTANCE_1)))
+                    {
+                        if (me->HasAura(BATTLESTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 2:
+                    if (doCast(me, GetSpell(DEFENSIVESTANCE_1)))
+                    {
+                        if (me->HasAura(DEFENSIVESTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                case 3:
+                    if (doCast(me, GetSpell(BERSERKERSTANCE_1)))
+                    {
+                        if (me->HasAura(BERSERKERSTANCE_1))
+                        {
+                            GC_Timer = temptimer;
+                            return true;
+                        }
+                    }
+                    break;
+                default:
+                    break;
+            }
+
+            GC_Timer = temptimer;
+            return false;
+        }
+
+        void ApplyClassDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+        {
+            uint8 lvl = me->getLevel();
+            float pctbonus = 0.0f;
+
+            if (damageinfo.hitOutCome == MELEE_HIT_CRIT)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(damageinfo.attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            damage = damage * (1.0f + pctbonus);
+        }
+
+        void ApplyClassDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& /*damageinfo*/, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+        {
+            uint32 spellId = spellInfo->Id;
+            uint8 lvl = me->getLevel();
+            float fdamage = float(damage);
+            //1) apply additional crit chance. This additional chance roll will replace original (balance safe)
+            if (!crit)
+            {
+                float aftercrit = 0.f;
+                //Poleaxe Specialization: 5% additional critical chance for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                aftercrit += 5.f;
+                //Incite: 15% additional critical chance for Cleave, Heroic Strike and Thunder Clap
+                if (lvl >= 15 &&
+                    (spellId == GetSpell(CLEAVE_1) ||
+                    spellId == GetSpell(HEROIC_STRIKE_1) ||
+                    spellId == GetSpell(THUNDER_CLAP_1)))
+                    aftercrit += 15.f;
+                //Improved Overpower: 50% additional critical chance for Overpower
+                if (lvl >= 20 && spellId == GetSpell(OVERPOWER_1))
+                    aftercrit += 50.f;
+                //Critical Block: 15% additional critical chance for Shield Slam
+                if (lvl >= 50 && spellId == GetSpell(SHIELD_SLAM_1))
+                    aftercrit += 15.f;
+                //Sword and Board: 15% additional critical chance for Devastate
+                if (lvl >= 55 && spellId == GetSpell(DEVASTATE_1))
+                    aftercrit += 15.f;
+                //Warrior T8 Protection Bonus (id: 64933): 10% additional critical chance for Devastate (tanks only)
+                if (lvl >= 78 && IsTank() && spellId == GetSpell(DEVASTATE_1))
+                    aftercrit += 10.f;
+
+                //second roll (may be illogical)
+                if (aftercrit > 0.f)
+                    crit = roll_chance_f(aftercrit);
+            }
+
+            //2) apply bonus damage mods
+            float pctbonus = 0.0f;
+            if (crit)
+            {
+                //!!!Melee spell damage is not yet critical, all reduced by half
+                //Impale: 20% crit damage bonus for all abilities
+                if (lvl >= 20)
+                    pctbonus += 0.10f;
+                //Poleaxe Specialization: 5% additional critical damage for all attacks
+                if (lvl >= 30)
+                    if (Item const* weap = GetEquips(attackType))
+                        if (ItemTemplate const* proto = weap->GetTemplate())
+                            if (proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE || proto->SubClass == ITEM_SUBCLASS_WEAPON_AXE2 ||
+                                proto->SubClass == ITEM_SUBCLASS_WEAPON_POLEARM)
+                                pctbonus += 0.025f;
+            }
+
+            //Improved Rend: 20% bonus damage for Rend
+            if (spellId == GetSpell(REND_1))
+                pctbonus += 0.2f;
+            //Improved Whirlwind: 20% bonus damage for Whirlwind
+            if (lvl >= 40 && spellId == GetSpell(WHIRLWIND_1))
+                pctbonus += 0.2f;
+            //Glyph of Mortal Strike: 10% bonus damage for Mortal Strike
+            if (lvl >= 40 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Unrelenting Assault (part 2): 20% bonus damage for Overpower and Revenge
+            if (lvl >= 45 && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                pctbonus += 0.2f;
+            //Improved Mortal Strike (part 1): 10% bonus damage for Mortal Strike
+            if (lvl >= 45 && spellId == GetSpell(MORTALSTRIKE_1))
+                pctbonus += 0.1f;
+            //Undending Fury: 10% bonus damage for Whirlwind, Slam and Bloodthirst
+            if (lvl >= 55 && (spellId == GetSpell(WHIRLWIND_1) || spellId == GetSpell(SLAM_1) /*|| spellId == BLOODTHIRST*/))
+                pctbonus += 0.1f;
+            //Improved Thunder Clap (part 2): 30% bonus damage for Thunder Clap
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                pctbonus += 0.3f;
+            ////Improved Revenge (part 1): 60% bonus damage for Revenge
+            //if (lvl >= 20 && spellId == GetSpell(REVENGE_1))
+            //    pctbonus += 0.6f;
+            //Gag Order (part 2): 10% bonus damage for Shield Slam
+            if (lvl >= 30 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Improved Shield Slam (id: 38407): 10% bonus damage for Shield Slam
+            if (lvl >= 50 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Shield Slam Damage Up (id: 60173): 10% bonus damage for Shield Slam
+            if (lvl >= 70 && spellId == GetSpell(SHIELD_SLAM_1))
+                pctbonus += 0.1f;
+            //Warrior T10 Protection 2P Bonus (id: 70843): 20% bonus damage for Shield Slam and Shockwave (tanks only)
+            if (lvl >= 78 && IsTank() && (spellId == GetSpell(SHIELD_SLAM_1) || spellId == GetSpell(SHOCKWAVE_1)))
+                pctbonus += 0.2f;
+            //One-Handed Weapon Specialization: 10% bonus damage with 1H weapons (for bot - Devastate only)
+            if (lvl >= 35 && spellId == GetSpell(DEVASTATE_1))
+                pctbonus += 0.1f;
+            //Warrior T9 Protection 2P Bonus (id: 67269): 5% bonus damage for Devastate
+            if (lvl >= 77 && spellId == GetSpell(DEVASTATE_1))
+                pctbonus += 0.05f;
+            //Glyph of Mocking Blow: 25% bonus damage for Mocking Blow
+            if (lvl >= 15 && spellId == GetSpell(MOCKING_BLOW_1))
+                pctbonus += 0.25f;
+
+            //Improved Cleave: 120% increased '!bonus damage!' done by Cleave (flat mod)
+            if (lvl >= 25 && spellId == GetSpell(CLEAVE_1))
+            {
+                float bp = spellInfo->Effects[EFFECT_0].BasePoints; //SPELL_EFFECT_WEAPON_DAMAGE (values: 15 - 222)
+                fdamage += bp * 1.2;
+            }
+
+            damage = int32(fdamage * (1.0f + pctbonus));
+        }
+
+        void ApplyClassSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+        {
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float fcost = float(cost);
+            int32 flatbonus = 0;
+            float pctbonus = 0.0f;
+
+            //percent mods
+            //Glyph of Bloodrage: -100% health cost for Bloodrage
+            if (lvl >= 10 && spellId == GetSpell(BLOODRAGE_1))
+                pctbonus += 1.0f;
+            //Sword and Board: -100% rage cost for Shield Slam
+            if (lvl >= 55 && spellId == GetSpell(SHIELD_SLAM_1) && me->HasAura(SWORD_AND_BOARD_BUFF))
+                pctbonus += 1.0f;
+            //Glyph of Sweeping Strikes: -100% rage cost for Sweeping Strikes
+            if (lvl >= 30 && spellId == GetSpell(SWEEPING_STRIKES_1))
+                pctbonus += 1.0f;
+            //Glyph of Revenge: -100% rage cost for Heroic Strike
+            if (lvl >= 20 && spellId == GetSpell(HEROIC_STRIKE_1) && me->HasAura(GLYPH_OF_REVENGE_BUFF))
+                pctbonus += 1.0f;
+
+            //flat mods
+            //!1 rage = 10 pts!
+            //Improved Heroic Strike: -3 rage cost for Heroic Strike
+            if (lvl >= 10 && spellId == GetSpell(HEROIC_STRIKE_1))
+                flatbonus += 30;
+            //Bloodthirst and Mortal Strike Discount (id: 37535): -5 rage cost for Bloodthirst and Mortal Strike
+            if (lvl >= 40 && (/*spellId == GetSpell(BLOODTHIRST_1) || */spellId == GetSpell(MORTALSTRIKE_1)))
+                flatbonus += 50;
+            //Improved Execute: -5 rage cost for Execute
+            if (lvl >= 25 && spellId == GetSpell(EXECUTE_1))
+                flatbonus += 50;
+            //Improved Thunder Clap (part 1): -4 rage cost for Execute
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                flatbonus += 40;
+            //Puncture: -3 rage cost for Sunder Armor and Devastate
+            if (lvl >= 25 && (spellId == GetSpell(SUNDER_1) || spellId == GetSpell(DEVASTATE_1)))
+                flatbonus += 30;
+            //Glyph of Shockwave: -3 rage cost for Shockwave
+            if (lvl >= 65 && spellId == GetSpell(SHOCKWAVE_1))
+                flatbonus += 30;
+            //Improved Hamstring (id: 24428): -2 rage cost for Hamstring (for bot Piercing Howl also)
+            if (lvl >= 25 && (spellId == GetSpell(HAMSTRING_1) || spellId == GetSpell(PIERCING_HOWL_1)))
+                flatbonus += 20;
+            //Focused Rage: -3 rage cost for all abilities (using rage)
+            if (lvl >= 40 && spellInfo->PowerType == POWER_RAGE)
+                flatbonus += 30;
+            //Glyph of Resonating Power: -5 rage cost for Thunder Clap
+            if (lvl >= 15 && spellId == GetSpell(THUNDER_CLAP_1))
+                flatbonus += 50;
+
+            //cost can be < 0
+            cost = int32(fcost * (1.0f - pctbonus)) - flatbonus;
+        }
+
+        void ApplyClassSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+        {
+            //casttime is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            //float pctbonus = 0.0f;
+
+            //100% mods
+            //Improved Slam: -100% sec cast time for Slam
+            if (lvl >= 40 && spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+                timebonus += casttime;
+
+            //flat mods
+            //Improved Slam: -1.0 sec cast time for Slam
+            if (lvl >= 40 && spellId == GetSpell(SLAM_1))
+                timebonus += 1000;
+
+            casttime = std::max<int32>(casttime - timebonus, 0);
+        }
+
+        void ApplyClassSpellCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            uint32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //pct mods
+            //Intensify Rage: -33% cooldown for Bloodrage, Berserker Rage, Recklessness and Death Wish
+            if (lvl >= 40 &&
+                (spellId == GetSpell(BLOODRAGE_1) || spellId == GetSpell(BERSERKERRAGE_1) ||
+                spellId == GetSpell(RECKLESSNESS_1) || spellId == GetSpell(DEATHWISH_1)))
+                pctbonus += 0.33f;
+            //Glyph of Rapid Charge: -7% cooldown for Charge
+            if (lvl >= 40 && spellId == GetSpell(CHARGE_1))
+                pctbonus += 0.07f;
+
+            //flat mods
+            //Improved Disciplines: -60 sec cooldown for Shield Wall, Retaliation and Recklessness
+            if (lvl >= 35 &&
+                (spellId == GetSpell(SHIELD_WALL_1) ||
+                spellId == GetSpell(RETALIATION_1) ||
+                spellId == GetSpell(RECKLESSNESS_1)))
+                timebonus += 60000;
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 4000;
+            //Improved Intercept: -10 sec cooldown for Intercept
+            if (lvl >= 30 && spellId == GetSpell(INTERCEPT_1))
+                timebonus += 10000;
+            //Shield Mastery (part 2): -20 sec cooldown for Shield Block
+            if (lvl >= 20 && spellId == GetSpell(SHIELD_BLOCK_1))
+                timebonus += 20000;
+            //Improved Disarm (part 1): -20 sec cooldown for Disarm
+            if (lvl >= 25 && spellId == GetSpell(DISARM_1))
+                timebonus += 20000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 25 && spellId == GetSpell(MORTALSTRIKE_1))
+                timebonus += 1000;
+            //Glyph of Bladestorm: -15 sec cooldown for Bladestorm
+            if (lvl >= 60 && spellId == GetSpell(BLADESTORM_1))
+                timebonus += 15000;
+            //Glyph of Last Stand: -1 min cooldown for Last Stand
+            if (lvl >= 20 && spellId == GetSpell(LAST_STAND_1))
+                timebonus += 60000;
+            //Glyph of Spell Reflection: -1 sec cooldown for Spell Reflection
+            if (lvl >= 65 && spellId == GetSpell(SPELL_REFLECTION_1))
+                timebonus += 60000;
+            //Glyph of Whirlwind: -2 sec cooldown for Whirlwind
+            if (lvl >= 36 && spellId == GetSpell(WHIRLWIND_1))
+                timebonus += 2000;
+            //Warrior T9 2P Bonus (id: 67269): -2 sec cooldown for Taunt (tanks only)
+            if (lvl >= 68 && IsTank() && spellId == GetSpell(TAUNT_1))
+                timebonus += 2000;
+            //Improved Challenging Shout (id: 12327): -2 min cooldown for Challenging Shout (tanks only)
+            if (lvl >= 30 && IsTank() && spellId == GetSpell(CHALLENGING_SHOUT_1))
+                timebonus += 120000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellCategoryCooldownMods(SpellInfo const* spellInfo, uint32& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            int32 timebonus = 0;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1): -4 sec cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 4000;
+            //Improved Mortal Strike (part 2): -1 sec cooldown for Mortal Strike
+            if (lvl >= 25 && spellId == GetSpell(MORTALSTRIKE_1))
+                timebonus += 1000;
+
+            cooldown = std::max<int32>((float(cooldown) * (1.0f - pctbonus)) - timebonus, 0);
+        }
+
+        void ApplyClassSpellGlobalCooldownMods(SpellInfo const* spellInfo, float& cooldown) const
+        {
+            //cooldown is in milliseconds
+            uint32 spellId = spellInfo->Id;
+            //SpellSchool school = GetFirstSchoolInMask(spellInfo->GetSchoolMask());
+            uint8 lvl = me->getLevel();
+            float timebonus = 0.0f;
+            float pctbonus = 0.0f;
+
+            //Unrelenting Assault (part 1, special): -0.5 sec global cooldown for Overpower and Revenge (not for tanks)
+            if (lvl >= 50 && !IsTank() && (spellId == GetSpell(OVERPOWER_1) || spellId == GetSpell(REVENGE_1)))
+                timebonus += 500.f;
+
+            cooldown = (cooldown * (1.0f - pctbonus)) - timebonus;
+        }
+
+        void OnClassSpellGo(SpellInfo const* spellInfo)
+        {
+            uint32 spellId = spellInfo->Id;
+
+            if (spellId == GetSpell(LAST_STAND_1))
+            {
+                BotWhisper("Last Stand used!");
+            }
+            if (spellId == GetSpell(SHIELD_WALL_1))
+            {
+                BotWhisper("Shield Wall used!");
+                //uint32 cd = 300000;
+                //ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(SHIELD_WALL_1)), cd);
+                SetSpellCooldown(RETALIATION_1, 12000);
+                //SetSpellCooldown(SHIELD_WALL_1, cd);
+                SetSpellCooldown(RECKLESSNESS_1, 12000);
+            }
+            if (spellId == GetSpell(RETALIATION_1))
+            {
+                //custom ability - no cooldown
+                uint32 cd = 300000;
+                ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(RETALIATION_1)), cd);
+                SetSpellCooldown(RETALIATION_1, cd);
+                SetSpellCooldown(SHIELD_WALL_1, 12000);
+                SetSpellCooldown(RECKLESSNESS_1, 12000);
+                return;
+            }
+            if (spellId == GetSpell(RECKLESSNESS_1))
+            {
+                //custom ability - no cooldown
+                uint32 cd = 300000;
+                ApplyBotSpellCooldownMods(sSpellMgr->GetSpellInfo(GetSpell(RECKLESSNESS_1)), cd);
+                SetSpellCooldown(RETALIATION_1, 12000);
+                SetSpellCooldown(SHIELD_WALL_1, 12000);
+                SetSpellCooldown(RECKLESSNESS_1, cd);
+                return;
+            }
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                //suctom
+                float gcd = 1500.f;
+                ApplyBotSpellGlobalCooldownMods(spellInfo, gcd);
+                GC_Timer = uint32(gcd);
+            }
+            if (spellId == GetSpell(CLEAVE_1) || spellId == GetSpell(HEROIC_STRIKE_1) || spellId == GetSpell(SLAM_1))
+            {
+                //once per swing
+                SetSpellCooldown(spellId, me->getAttackTimer(BASE_ATTACK));
+            }
+            if (spellId == GetSpell(VIGILANCE_1))
+            {
+                SetSpellCooldown(VIGILANCE_1, 30000); //no initial cooldown
+            }
+            if (spellId == GetSpell(SLAM_1) && me->HasAura(BLOODSURGE_BUFF))
+            {
+                me->RemoveAura(BLOODSURGE_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(HEROIC_STRIKE_1) && me->HasAura(GLYPH_OF_REVENGE_BUFF))
+            {
+                me->RemoveAura(GLYPH_OF_REVENGE_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(SHIELD_SLAM_1) && me->HasAura(SWORD_AND_BOARD_BUFF))
+            {
+                me->RemoveAura(SWORD_AND_BOARD_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == GetSpell(OVERPOWER_1) && me->HasAura(TASTE_FOR_BLOOD_BUFF))
+            {
+                me->RemoveAura(TASTE_FOR_BLOOD_BUFF, ObjectGuid::Empty, 0, AURA_REMOVE_BY_EXPIRE);
+            }
+            if (spellId == TASTE_FOR_BLOOD_BUFF)
+            {
+                SetSpellCooldown(TASTE_FOR_BLOOD_BUFF, 6000);
+            }
+        }
+
+        void SpellHit(Unit* caster, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == BATTLESTANCE_1 || spellId == DEFENSIVESTANCE_1 || spellId == BERSERKERSTANCE_1)
+            {
+                //stance mastery impl
+                uint32 temprage = 0;
+                uint32 myrage = rage;
+                if (me->getLevel() >= 20)
+                    temprage = myrage > 250 ? 250 : myrage;
+                else if (me->getLevel() >= 15)
+                    temprage = myrage > 100 ? 100 : myrage;
+
+                battleStance = (spellId == BATTLESTANCE_1);
+                defensiveStance = (spellId == DEFENSIVESTANCE_1);
+                berserkerStance = (spellId == BERSERKERSTANCE_1);
+                me->SetPower(POWER_RAGE, temprage);
+                stancetimer = 2100 - me->getLevel() * 20; //500 on 80
+                GC_Timer = temptimer;
+            }
+            if (spellId == GetSpell(BERSERKERRAGE_1))
+            {
+                //Improved Berserker Rage: 20 rage bonus when used
+                if (me->getLevel() >= 35)
+                    me->CastSpell(me, BERSERKER_RAGE_EFFECT, true);
+            }
+            if (spellId == SWORD_AND_BOARD_BUFF)
+            {
+                //Sword And Board: remove Shield Slam cooldown
+                ResetSpellCooldown(SHIELD_SLAM_1);
+            }
+            if (spellId == VIGILANCE_PROC)
+            {
+                //Vigilance: remove Taunt cooldown
+                ResetSpellCooldown(TAUNT_1);
+            }
+            if (spellId == GetSpell(SHIELD_WALL_1))
+            {
+                //Shield Wall Duration (id: 60175): 3 sec increased Shield Wall duration
+                if (Aura* wall = me->GetAura(spellId))
+                {
+                    int32 dur = wall->GetDuration() + 3000;
+                    wall->SetDuration(dur);
+                    wall->SetMaxDuration(dur);
+                }
+            }
+
+            switch (spellId)
+            {
+                case VICTORIOUS_SPELL:
+                    VICTORIOUS = true;
+                    break;
+                default:
+                    break;
+            }
+            OnSpellHit(caster, spell);
+        }
+
+        void SpellHitTarget(Unit* target, SpellInfo const* spell)
+        {
+            uint32 spellId = spell->Id;
+
+            if (spellId == GetSpell(PIERCING_HOWL_1))
+            {
+                //Piercing Howl: 4 sec duraion increase (exclude players)
+                if (target->GetTypeId() != TYPEID_PLAYER)
+                {
+                    if (Aura* howl = target->GetAura(spellId, me->GetGUID()))
+                    {
+                        uint32 dur = howl->GetDuration() + 4000;
+                        howl->SetDuration(dur);
+                        howl->SetMaxDuration(dur);
+                    }
+                }
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1) || spellId == GetSpell(COMMANDING_SHOUT_1))
+            {
+                if (me->getLevel() >= 15)
+                {
+                    //Commanding Presence: +25% increased effect (melee AP / HP)
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_0, me->GetGUID());
+                    if (eff)
+                    {
+                        int32 amount = eff->GetAmount();
+                        amount = amount * 5 / 4;
+                        eff->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (spellId == GetSpell(REVENGE_1))
+            {
+                //zzzOLD Revenge Stun (25% chance)
+                if (me->getLevel() >= 25 && urand(1,100) <= 25)
+                    me->CastSpell(target, REVENGE_STUN_SPELL, true);
+            }
+            if (spellId == GetSpell(THUNDER_CLAP_1))
+            {
+                //We make it tanking bonus only, to prevent imbalance
+                if (me->getLevel() >= 15 && IsTank())
+                {
+                    AuraEffect* eff = target->GetAuraEffect(spellId, EFFECT_1, me->GetGUID());
+                    if (eff)
+                    {
+                        int32 amount = eff->GetAmount();
+                        //Improved Thunder Clap (part 3): 10% extra slow
+                        amount += (-10);
+                        //Conqueror Thunder Clap Bonus: 50% increased effect
+                        if (me->getLevel() >= 60)
+                            amount = amount * 3 / 2;
+
+                        eff->ChangeAmount(amount);
+                    }
+                }
+            }
+            if (spellId == GetSpell(OVERPOWER_1))
+            {
+                me->ClearReactive(REACTIVE_OVERPOWER);
+                //Unrelenting Assault (part 3): reduce spells efficiency
+                if (UNRELENTING_ASSAULT && target->HasUnitState(UNIT_STATE_CASTING))
+                    target->CastSpell(target, UNRELENTING_ASSAULT_SPELL, true);
+            }
+            if (spellId == GetSpell(BATTLESHOUT_1) || spellId == GetSpell(COMMANDING_SHOUT_1))
+            {
+                //Glyph of Battle/Command + 2 min duration (8 for bots)
+                if (Aura* shout = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = shout->GetDuration() + 480000;
+                    shout->SetDuration(dur);
+                    shout->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(REND_1))
+            {
+                //Glyph of Rending + 6 sec duration
+                if (Aura* rend = target->GetAura(spellId, me->GetGUID()))
+                {
+                    uint32 dur = rend->GetDuration() + 6000;
+                    rend->SetDuration(dur);
+                    rend->SetMaxDuration(dur);
+                }
+            }
+            if (spellId == GetSpell(INTERVENE_1))
+            {
+                //Glyph of Intervene + 2 bonus charges
+                if (Aura* vene = target->GetAura(spellId, me->GetGUID()))
+                {
+                    vene->SetCharges(vene->GetCharges() + 2);
+                }
+            }
+            if (spellId == GetSpell(VICTORY_RUSH_1))
+            {
+                me->RemoveAura(VICTORIOUS_SPELL);
+                VICTORIOUS = false;
+            }
+        }
+
+        void DamageDealt(Unit* victim, uint32& damage, DamageEffectType damageType)
+        {
+            bot_ai::DamageDealt(victim, damage, damageType);
+        }
+
+        void DamageTaken(Unit* u, uint32& /*damage*/)
+        {
+            if (!u->IsInCombat() && !me->IsInCombat())
+                return;
+            OnOwnerDamagedBy(u);
+        }
+
+        void OwnerAttackedBy(Unit* u)
+        {
+            OnOwnerDamagedBy(u);
+        }
+
+        void Reset()
+        {
+            stancetimer = 0;
+            ragetimer = 1500;
+            ragetimer2 = 3000;
+            shoutCheckTimer = 5000;
+
+            vigilanceTargetGuid.Clear();
+
+            battleStance = true;
+            defensiveStance = false;
+            berserkerStance = false;
+
+            rageIncomeMult = sWorld->getRate(RATE_POWER_RAGE_INCOME);
+            rageLossMult = sWorld->getRate(RATE_POWER_RAGE_LOSS);
+            me->setPowerType(POWER_RAGE);
+            rage = 0;
+
+            DefaultInit();
+        }
+
+        void ReduceCD(uint32 diff)
+        {
+            if (stancetimer > diff)                 stancetimer -= diff;
+            if (ragetimer > diff)                   ragetimer -= diff;
+            if (ragetimer2 > diff)                  ragetimer2 -= diff;
+            if (shoutCheckTimer > diff)             shoutCheckTimer -= diff;
+        }
+
+        void InitSpells()
+        {
+            uint8 lvl = me->getLevel();
+            InitSpellMap(INTIMIDATING_SHOUT_1);
+            InitSpellMap(ENRAGED_REGENERATION_1);
+            InitSpellMap(CHARGE_1);
+            InitSpellMap(OVERPOWER_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(TAUNT_1) : RemoveSpell(TAUNT_1);
+            InitSpellMap(BLOODRAGE_1);
+            InitSpellMap(BERSERKERRAGE_1);
+            InitSpellMap(INTERCEPT_1);
+            InitSpellMap(CLEAVE_1);
+            InitSpellMap(HAMSTRING_1);
+            InitSpellMap(INTERVENE_1);
+            InitSpellMap(WHIRLWIND_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(BLADESTORM_1) : RemoveSpell(BLADESTORM_1);
+            InitSpellMap(BATTLESHOUT_1);
+            InitSpellMap(REND_1);
+            InitSpellMap(EXECUTE_1);
+            InitSpellMap(PUMMEL_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(MORTALSTRIKE_1) : RemoveSpell(MORTALSTRIKE_1);
+            InitSpellMap(SLAM_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(SUNDER_1) : RemoveSpell(SUNDER_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(SWEEPING_STRIKES_1) : RemoveSpell(SWEEPING_STRIKES_1);
+            InitSpellMap(BATTLESTANCE_1);
+   /*Quest*/lvl >= 10 ? InitSpellMap(DEFENSIVESTANCE_1) : RemoveSpell(DEFENSIVESTANCE_1);
+   /*Quest*/lvl >= 30 ? InitSpellMap(BERSERKERSTANCE_1) : RemoveSpell(BERSERKERSTANCE_1);
+ /*Special*/lvl >= 50 ? InitSpellMap(RECKLESSNESS_1) : RemoveSpell(RECKLESSNESS_1);
+ /*Special*/lvl >= 20 ? InitSpellMap(RETALIATION_1) : RemoveSpell(RETALIATION_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(DEATHWISH_1) : RemoveSpell(DEATHWISH_1);
+            InitSpellMap(VICTORY_RUSH_1);
+            InitSpellMap(THUNDER_CLAP_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(LAST_STAND_1) : RemoveSpell(LAST_STAND_1);
+            InitSpellMap(REVENGE_1);
+            InitSpellMap(SHIELD_BLOCK_1);
+            InitSpellMap(SHIELD_SLAM_1);
+            InitSpellMap(SPELL_REFLECTION_1);
+            InitSpellMap(DISARM_1);
+            InitSpellMap(SHIELD_WALL_1);
+            InitSpellMap(SHIELD_BASH_1);
+            InitSpellMap(HEROIC_THROW_1);
+  /*Talent*/lvl >= 30 ? InitSpellMap(CONCUSSION_BLOW_1) : RemoveSpell(CONCUSSION_BLOW_1);
+  /*Talent*/lvl >= 40 ? InitSpellMap(VIGILANCE_1) : RemoveSpell(VIGILANCE_1);
+  /*Talent*/lvl >= 50 ? InitSpellMap(DEVASTATE_1) : RemoveSpell(DEVASTATE_1);
+            InitSpellMap(MOCKING_BLOW_1);
+  /*Talent*/lvl >= 60 ? InitSpellMap(SHOCKWAVE_1) : RemoveSpell(SHOCKWAVE_1);
+  /*Talent*/lvl >= 20 ? InitSpellMap(PIERCING_HOWL_1) : RemoveSpell(PIERCING_HOWL_1);
+            InitSpellMap(HEROIC_STRIKE_1);
+            InitSpellMap(CHALLENGING_SHOUT_1);
+            InitSpellMap(COMMANDING_SHOUT_1);
+
+ /*SPECIAL*/InitSpellMap(TASTE_FOR_BLOOD_BUFF, true);
+        }
+
+        void ApplyClassPassives()
+        {
+            uint8 level = master->getLevel();
+
+            UNRELENTING_ASSAULT = (level >= 35);
+            RefreshAura(WC5, level >= 70 ? 1 : 0);
+            RefreshAura(WC4, level >= 68 && level < 70 ? 1 : 0);
+            RefreshAura(WC3, level >= 66 && level < 68 ? 1 : 0);
+            RefreshAura(WC2, level >= 64 && level < 66 ? 1 : 0);
+            RefreshAura(WC1, level >= 62 && level < 64 ? 1 : 0);
+            RefreshAura(FLURRY5, level >= 39 ? 1 : 0);
+            RefreshAura(FLURRY4, level >= 38 && level < 39 ? 1 : 0);
+            RefreshAura(FLURRY3, level >= 37 && level < 38 ? 1 : 0);
+            RefreshAura(FLURRY2, level >= 36 && level < 37 ? 1 : 0);
+            RefreshAura(FLURRY1, level >= 35 && level < 36 ? 1 : 0);
+            RefreshAura(SWORD_SPEC5, level >= 60 ? 2 : level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC4, level >= 45 && level < 50 ? 1 : 0);
+            RefreshAura(SWORD_SPEC3, level >= 40 && level < 45 ? 1 : 0);
+            RefreshAura(SWORD_SPEC2, level >= 35 && level < 40 ? 1 : 0);
+            RefreshAura(SWORD_SPEC1, level >= 30 && level < 35 ? 1 : 0);
+            RefreshAura(RAMPAGE, level >= 60 ? 1 : 0);
+            RefreshAura(TRAUMA2, level >= 55 ? 1 : 0);
+            RefreshAura(TRAUMA1, level >= 35 && level < 55 ? 1 : 0);
+            RefreshAura(BLOOD_FRENZY, level >= 45 ? 1 : 0);
+            RefreshAura(SECOND_WIND, level >= 40 ? 1 : 0);
+            RefreshAura(TOUGHNESS, level >= 40 ? 2 : level >= 15 ? 1 : 0);
+            RefreshAura(IMP_HAMSTRING, level >= 40 ? 2 : level >= 35 ? 1 : 0);
+            RefreshAura(SHIELD_SPECIALIZATION, level >= 15 ? 1 : 0);
+            RefreshAura(GAG_ORDER, level >= 30 ? 1 : 0);
+            RefreshAura(IMPROVED_SPELL_REFLECTION, level >= 25 ? 1 : 0);
+            RefreshAura(IMPROVED_DISARM, level >= 25 ? 1 : 0);
+            RefreshAura(VITALITY, level >= 45 ? 1 : 0);
+            RefreshAura(CRITICAL_BLOCK, level >= 50 ? 1 : 0);
+            RefreshAura(SWORD_AND_BOARD, level >= 55 ? 1 : 0);
+            RefreshAura(ARMORED_TO_THE_TEETH, level >= 20 ? 1 : 0);
+            RefreshAura(ENDLESS_RAGE, level >= 55 ? 1 : 0);
+            RefreshAura(BLOODSURGE, level >= 50 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD3, level >= 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD2, level >= 28 && level < 30 ? 1 : 0);
+            RefreshAura(TASTE_FOR_BLOOD1, level >= 25 && level < 28 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE3, level >= 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE2, level >= 25 && level < 30 ? 1 : 0);
+            RefreshAura(BLOOD_CRAZE1, level >= 20 && level < 25 ? 1 : 0);
+            RefreshAura(WARRIOR_T10_4P, level >= 60 ? 1 : 0);
+            RefreshAura(GLYPH_BLOCKING);
+            RefreshAura(GLYPH_DEVASTATE);
+            RefreshAura(GLYPH_EXECUTION);
+            RefreshAura(GLYPH_HEROIC_STRIKE);
+            RefreshAura(GLYPH_REVENGE);
+        }
+
+        bool CanUseManually(uint32 basespell) const
+        {
+            switch (basespell)
+            {
+                case ENRAGED_REGENERATION_1:
+                case BLOODRAGE_1:
+                case BERSERKERRAGE_1:
+                case BATTLESHOUT_1:
+                case COMMANDING_SHOUT_1:
+                case DEATHWISH_1:
+                    return true;
+                case BATTLESTANCE_1:
+                    return !battleStance;
+                case DEFENSIVESTANCE_1:
+                    return !defensiveStance;
+                case BERSERKERSTANCE_1:
+                    return !berserkerStance;
+                case SWEEPING_STRIKES_1:
+                    return battleStance || berserkerStance;
+                //case RETALIATION_1:
+                //    return battleStance;
+                //case RECKLESSNESS_1:
+                //    return berserkerStance;
+                case SHIELD_WALL_1:
+                    return CanBlock() && defensiveStance;
+                case SHIELD_BLOCK_1:
+                    return CanBlock();
+                case LAST_STAND_1:
+                case VIGILANCE_1:
+                    return IsTank();
+                default:
+                    return false;
+            }
+        }
+
+        float GetBotArmorPenetrationCoef() const
+        {
+            float bonus = 0.0f;
+
+            if (battleStance)
+            {
+                bonus += 0.1f;
+                //Warrior T10 4P Bonus (part 1): 6% additional armor penetration in Battle Stance
+                if (me->getLevel() >= 75)
+                    bonus += 0.06f;
+            }
+
+            //Mace Specialization: 15% armor penetration
+            if (me->getLevel() >= 30)
+                if (Item const* weap = GetEquips(0))
+                    if (ItemTemplate const* proto = weap->GetTemplate())
+                        if (proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE || proto->SubClass == ITEM_SUBCLASS_WEAPON_MACE2)
+                            bonus += 0.15f;
+
+            return bonus;
+        }
+
+    private:
+/*tmrs*/uint32 stancetimer, ragetimer, ragetimer2, shoutCheckTimer;
+/*misc*/int32 rage;
+/*misc*/ObjectGuid vigilanceTargetGuid;
+/*misc*/float rageIncomeMult, rageLossMult;
+/*Chck*/bool battleStance, defensiveStance, berserkerStance, UNRELENTING_ASSAULT, VICTORIOUS;
+
+        enum WarriorBaseSpells
+        {
+            INTIMIDATING_SHOUT_1                    = 5246,
+            ENRAGED_REGENERATION_1                  = 55694,
+            CHARGE_1                                = 11578,
+            OVERPOWER_1                             = 7384,
+            TAUNT_1                                 = 355,
+            BLOODRAGE_1                             = 2687,
+            BERSERKERRAGE_1                         = 18499,
+            INTERCEPT_1                             = 20252,
+            CLEAVE_1                                = 845,
+            HAMSTRING_1                             = 1715,
+            INTERVENE_1                             = 3411,
+            WHIRLWIND_1                             = 1680,
+            BLADESTORM_1                            = 46924,
+            BATTLESHOUT_1                           = 6673,
+            REND_1                                  = 772,
+            EXECUTE_1                               = 5308,
+            PUMMEL_1                                = 6552,
+  /*Talent*/MORTALSTRIKE_1                          = 12294,
+            SLAM_1                                  = 1464,
+            SUNDER_1                                = 7386,
+  /*Talent*/SWEEPING_STRIKES_1                      = 12328,
+            BATTLESTANCE_1                          = 2457,
+            DEFENSIVESTANCE_1                       = 71,
+            BERSERKERSTANCE_1                       = 2458,
+            RECKLESSNESS_1                          = 13847,//1719, original warrior spell
+            RETALIATION_1                           = 22857,//20230, original warrior spell
+  /*Talent*/DEATHWISH_1                             = 12292,
+            VICTORY_RUSH_1                          = 34428,
+            THUNDER_CLAP_1                          = 6343,
+  /*Talent*/LAST_STAND_1                            = 12975,
+            REVENGE_1                               = 6572,
+            SHIELD_BLOCK_1                          = 2565,
+            SHIELD_SLAM_1                           = 23922,
+            SPELL_REFLECTION_1                      = 23920,
+            DISARM_1                                = 676,
+            SHIELD_WALL_1                           = 871,
+            SHIELD_BASH_1                           = 72,
+            HEROIC_THROW_1                          = 57755,
+  /*Talent*/CONCUSSION_BLOW_1                       = 12809,
+  /*Talent*/VIGILANCE_1                             = 50720,
+  /*Talent*/DEVASTATE_1                             = 20243,
+            MOCKING_BLOW_1                          = 694,
+            SHOCKWAVE_1                             = 46968,
+            PIERCING_HOWL_1                         = 12323,
+            HEROIC_STRIKE_1                         = 78,
+            CHALLENGING_SHOUT_1                     = 1161,
+            COMMANDING_SHOUT_1                      = 469
+        };
+        enum WarriorPassives
+        {
+        //Talents
+            WC1  /*WRECKING CREW1*/                 = 46867,
+            WC2  /*WRECKING CREW2*/                 = 56611,
+            WC3  /*WRECKING CREW3*/                 = 56612,
+            WC4  /*WRECKING CREW4*/                 = 56613,
+            WC5  /*WRECKING CREW5*/                 = 56614,
+            FLURRY1                                 = 16256,
+            FLURRY2                                 = 16281,
+            FLURRY3                                 = 16282,
+            FLURRY4                                 = 16283,
+            FLURRY5                                 = 16284,
+            SWORD_SPEC1                             = 12281,
+            SWORD_SPEC2                             = 12812,
+            SWORD_SPEC3                             = 12813,
+            SWORD_SPEC4                             = 12814,
+            SWORD_SPEC5                             = 12815,
+            BLOOD_CRAZE1                            = 16487,
+            BLOOD_CRAZE2                            = 16489,
+            BLOOD_CRAZE3                            = 16492,
+            TASTE_FOR_BLOOD1                        = 56636,
+            TASTE_FOR_BLOOD2                        = 56637,
+            TASTE_FOR_BLOOD3                        = 56638,
+            UNRELENTING_ASSAULT1                    = 46859,
+            UNRELENTING_ASSAULT2                    = 46860,
+            TRAUMA1                                 = 46854,
+            TRAUMA2                                 = 46855,
+            BLOOD_FRENZY                            = 29859,
+            RAMPAGE                                 = 29801,
+            SECOND_WIND                             = 29838,//rank 2
+            TOUGHNESS                               = 12764,//rank 5
+            IMP_HAMSTRING                           = 23695,//rank 3
+            SHIELD_SPECIALIZATION                   = 12727,//rank 5
+            GAG_ORDER                               = 12958,//rank 2
+            IMPROVED_SPELL_REFLECTION               = 59089,//rank 2
+            IMPROVED_DISARM                         = 12804,//rank 2
+            VITALITY                                = 29144,//rank 3
+            CRITICAL_BLOCK                          = 47296,//rank 3
+            SWORD_AND_BOARD                         = 46953,//rank 3
+            ARMORED_TO_THE_TEETH                    = 61222,//rank 3
+            ENDLESS_RAGE                            = 29623,
+            BLOODSURGE                              = 46915,//rank 3
+        //other
+            WARRIOR_T10_4P                          = 70844,
+            GLYPH_BLOCKING                          = 58375,
+            GLYPH_DEVASTATE                         = 58388,
+            GLYPH_EXECUTION                         = 58367,
+            GLYPH_HEROIC_STRIKE                     = 58357,
+            GLYPH_REVENGE                           = 58364
+        };
+        enum WarriorSpecial
+        {
+            TASTE_FOR_BLOOD_BUFF                    = 60503,
+            //LAMBS_TO_THE_SLAUGHTER_BUFF             = 84586,
+            SWORD_AND_BOARD_BUFF                    = 50227,
+            BLOODSURGE_BUFF                         = 46916,//"Slam!"
+            GLYPH_OF_REVENGE_BUFF                   = 58363,
+            UNRELENTING_ASSAULT_SPELL               = 65925,//64849
+            VICTORIOUS_SPELL                        = 32216,
+            REVENGE_STUN_SPELL                      = 12798,
+            //COLOSSUS_SMASH_EFFECT                   = 108126,
+            //SWORD_SPECIALIZATION_TRIGGERED          = 16459,
+            VIGILANCE_PROC                          = 50725,
+            BERSERKER_RAGE_EFFECT                   = 23691,//rank 2
+
+            BLESSING_OF_MIGHT_1                     = 19740,
+            GREATER_BLESSING_OF_MIGHT_1             = 25782
+        };
+    };
+};
+
+void AddSC_warrior_bot()
+{
+    new warrior_bot();
+}
diff --git a/src/server/game/AI/NpcBots/botcommands.cpp b/src/server/game/AI/NpcBots/botcommands.cpp
new file mode 100644
index 0000000..8710f60
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botcommands.cpp
@@ -0,0 +1,934 @@
+#include "bot_ai.h"
+#include "botmgr.h"
+#include "Chat.h"
+//#include "Config.h"
+//#include "DBCStructure.h"
+#include "Group.h"
+#include "Language.h"
+#include "Player.h"
+//#include "ScriptedGossip.h"
+#include "ScriptMgr.h"
+//#include "Spell.h"
+#include "SpellInfo.h"
+/*
+Name: script_bot_commands
+%Complete: ???
+Comment: Npcbot related commands
+Category: commandscripts/custom/
+*/
+//RBAC_PERM_GM_COMMANDS = 197
+#define GM_COMMANDS rbac::RBACPermissions(197)
+
+class script_bot_commands : public CommandScript
+{
+private:
+    typedef std::pair<uint32 /*id*/, std::string /*name*/> BotPair;
+    static bool sortbots(BotPair p1, BotPair p2)
+    {
+        return p1.first < p2.first;
+    }
+
+public:
+    script_bot_commands() : CommandScript("script_bot_commands") { }
+
+    std::vector<ChatCommand> GetCommands() const
+    {
+        static std::vector<ChatCommand> npcbotSetCommandTable =
+        {
+            { "faction",    GM_COMMANDS,                        false, &HandleNpcSetFactionCommand,             ""},
+            { "owner",      GM_COMMANDS,                        false, &HandleNpcSetOwnerCommand,               ""},
+        };
+
+        static std::vector<ChatCommand> npcbotCommandTable =
+        {
+            { "set",        GM_COMMANDS,                        false, NULL,                                    "", npcbotSetCommandTable},
+            { "add",        GM_COMMANDS,                        false, &HandleNpcBotAddCommand,                 ""},
+            { "remove",     GM_COMMANDS,                        false, &HandleNpcBotRemoveCommand,              ""},
+            { "spawn",      GM_COMMANDS,                        false, &HandleNpcBotSpawnCommand,               ""},
+            { "delete",     GM_COMMANDS,                        false, &HandleNpcBotDeleteCommand,              ""},
+            { "lookup",     GM_COMMANDS,                        false, &HandleNpcBotLookupCommand,              ""},
+            { "revive",     GM_COMMANDS,                        false, &HandleNpcBotReviveCommand,              ""},
+            { "cast",       GM_COMMANDS,                        false, &HandleNpcBotCastCustomSpell,            ""},
+        };
+
+        static std::vector<ChatCommand> commandTable =
+        {
+            { "npcbot",     GM_COMMANDS,                        false, NULL,                      "", npcbotCommandTable},
+        };
+        return commandTable;
+    }
+
+    static bool HandleNpcBotCastCustomSpell(ChatHandler* handler, const char* /*args*/)
+    {
+        handler->SetSentErrorMessage(true);
+        handler->SendSysMessage("This is a dev command. Do not use it.");
+
+        //uint32 trig = SPELL_TRANSPARENCY_50; //transpar
+        //SpellInfo* trigInfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(trig));
+
+        //trigInfo->Dispel = DISPEL_NONE;
+        //trigInfo->Mechanic = MECHANIC_NONE;
+        //trigInfo->RangeEntry = sSpellRangeStore.LookupEntry(6); //6 - 100 yds
+
+        //trigInfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+        //trigInfo->DurationEntry = sSpellDurationStore.LookupEntry(1); //1 - 10 sec //32 - 6 seconds
+        //trigInfo->ManaCost = 0;
+        //trigInfo->ManaCostPercentage = 0;
+        //trigInfo->ManaCostPerlevel = 0;
+        //trigInfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT | SPELL_ATTR0_CASTABLE_WHILE_SITTING);
+        //trigInfo->AttributesEx &= ~SPELL_ATTR1_CANT_TARGET_SELF;
+        //trigInfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH);
+        //trigInfo->AttributesEx2 |= SPELL_ATTR2_UNK22;
+        //trigInfo->AttributesEx5 |= SPELL_ATTR5_HASTE_AFFECT_DURATION;
+        //trigInfo->Targets = TARGET_FLAG_DEST_LOCATION;
+        //trigInfo->AuraInterruptFlags =
+        //    AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        //    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        //trigInfo->ChannelInterruptFlags = 0x00007C3C; //31788
+        //trigInfo->CasterAuraStateNot = 0;
+
+        //trigInfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //trigInfo->Effects[0].BasePoints = 1;
+        ////trigInfo->Effects[0].ValueMultiplier = 0.0f;
+        //trigInfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_DEST_CHANNEL_TARGET);
+        //trigInfo->Effects[0].TargetB = SpellImplicitTargetInfo(TARGET_UNIT_DEST_AREA_ENEMY);
+        //trigInfo->Effects[0].ApplyAuraName = SPELL_AURA_NONE;
+        //trigInfo->Effects[0].Amplitude = 0;
+        //trigInfo->Effects[0].TriggerSpell = 0;
+        //trigInfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_8_YARDS); //14
+
+
+        uint32 spellId = SPELL_MIRROR_IMAGE_BM; //69936
+        SpellInfo* sinfo = const_cast<SpellInfo*>(sSpellMgr->GetSpellInfo(spellId));
+
+        //sinfo->SpellLevel = 0;
+        //sinfo->MaxLevel = 80;
+        //sinfo->Dispel = DISPEL_NONE;
+        //sinfo->Mechanic = MECHANIC_NONE;
+        sinfo->RangeEntry = sSpellRangeStore.LookupEntry(1); //1 - self only //6 - 100 yds
+        //sinfo->Speed = 25.f;
+        //sinfo->CastTimeEntry = sSpellCastTimesStore.LookupEntry(1); //1 - instant //3 - 0.5 sec
+        sinfo->DurationEntry = sSpellDurationStore.LookupEntry(566); //566 - 0 sec //3 - 60 sec //1 - 10 sec //32 - 6 seconds
+        sinfo->RecoveryTime = 3000;
+        sinfo->PowerType = POWER_MANA;
+        sinfo->ManaCost = 125;
+        sinfo->ManaCostPercentage = 0;
+        sinfo->ManaCostPerlevel = 0;
+        //sinfo->DmgClass = SPELL_DAMAGE_CLASS_MELEE;
+        //sinfo->PreventionType = SPELL_PREVENTION_TYPE_PACIFY;
+        //sinfo->EquippedItemClass = ITEM_CLASS_WEAPON;
+        //sinfo->EquippedItemSubClassMask = 0x0002A5F3;
+
+        //sinfo->Attributes &= ~(SPELL_ATTR0_UNK11);
+        sinfo->Attributes |= (SPELL_ATTR0_NOT_SHAPESHIFT/* | SPELL_ATTR0_CASTABLE_WHILE_SITTING | SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY*/);
+        //sinfo->AttributesEx &= ~SPELL_ATTR1_UNK11;
+        //sinfo->AttributesEx |= (SPELL_ATTR1_NOT_BREAK_STEALTH | SPELL_ATTR1_NO_THREAT);
+        sinfo->AttributesEx2 &= ~(SPELL_ATTR2_CAN_TARGET_NOT_IN_LOS);
+        sinfo->AttributesEx3 |= SPELL_ATTR3_DONT_DISPLAY_RANGE;
+        //sinfo->AttributesEx5 |= SPELL_ATTR5_HIDE_DURATION;
+        //sinfo->AttributesEx7 &= ~SPELL_ATTR7_HAS_CHARGE_EFFECT;
+        //sinfo->Targets |= TARGET_FLAG_DEST_LOCATION;
+        //sinfo->ExplicitTargetMask = TARGET_FLAG_UNIT_ENEMY;
+        //sinfo->InterruptFlags = 0x0000000F; //15
+        //sinfo->AuraInterruptFlags =
+        //    AURA_INTERRUPT_FLAG_SPELL_ATTACK | AURA_INTERRUPT_FLAG_MELEE_ATTACK |
+        //    AURA_INTERRUPT_FLAG_NOT_ABOVEWATER | AURA_INTERRUPT_FLAG_MOUNT; //0x00003C07;vanish
+        //sinfo->ChannelInterruptFlags = 0x00007C3C; //31788
+        //sinfo->CasterAuraStateNot = 0;
+
+        sinfo->Effects[0].Effect = SPELL_EFFECT_DUMMY;
+        //sinfo->Effects[0].BasePoints = 9999;
+        //sinfo->Effects[0].ValueMultiplier = 0.0f;
+        sinfo->Effects[0].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[0].TargetB = SpellImplicitTargetInfo(0);
+        sinfo->Effects[0].MiscValue = 0;
+        sinfo->Effects[0].MiscValueB = 0;
+        //sinfo->Effects[0].ApplyAuraName = SPELL_AURA_MOD_INVISIBILITY;
+        //sinfo->Effects[0].Amplitude = 0;
+        //sinfo->Effects[0].TriggerSpell = 0;
+        sinfo->Effects[0].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS);
+
+        //sinfo->Effects[1].Effect = SPELL_EFFECT_APPLY_AURA;
+        //sinfo->Effects[1].BasePoints = 10;
+        //sinfo->Effects[1].RealPointsPerLevel = 0.5f;
+        //sinfo->Effects[1].ValueMultiplier = 1.0f;
+        //sinfo->Effects[1].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[1].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->Effects[1].ApplyAuraName = SPELL_AURA_MOD_INCREASE_SPEED;
+        //sinfo->Effects[1].Amplitude = 0;
+        //sinfo->Effects[1].TriggerSpell = 0;
+        //sinfo->Effects[1].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+        //sinfo->Effects[2].Effect = SPELL_EFFECT_TRIGGER_SPELL;
+        //sinfo->Effects[2].BasePoints = 0;
+        //sinfo->Effects[2].ValueMultiplier = 0.0f;
+        //sinfo->Effects[2].TargetA = SpellImplicitTargetInfo(TARGET_UNIT_CASTER);
+        //sinfo->Effects[2].TargetB = SpellImplicitTargetInfo(0);
+        //sinfo->Effects[2].ApplyAuraName = SPELL_AURA_NONE;
+        //sinfo->Effects[2].Amplitude = 0;
+        //sinfo->Effects[2].TriggerSpell = trig;
+        //sinfo->Effects[2].RadiusEntry = sSpellRadiusStore.LookupEntry(EFFECT_RADIUS_0_YARDS); //14
+
+
+        return true;
+    }
+
+    static bool HandleNpcSetFactionCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set faction #faction");
+            handler->SendSysMessage("Sets faction for selected npcbot (saved in DB). Use 'a', 'h' or 'm' as argument to set faction to alliance, horde or monsters (hostile to all)");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot() || !bot->IsFreeBot())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        uint32 factionId = 0;
+        const std::string facStr = args;
+        char const* factionChar = facStr.c_str();
+
+        if (factionChar[0] == 'a')
+            factionId = 1802; //Alliance
+        else if (factionChar[0] == 'h')
+            factionId = 1801; //Horde
+        else if (factionChar[0] == 'm')
+            factionId = 14; //Monsters
+
+        if (!factionId)
+        {
+            char* pfactionid = handler->extractKeyFromLink((char*)args, "Hfaction");
+            factionId = atoi(pfactionid);
+        }
+
+        if (!sFactionTemplateStore.LookupEntry(factionId))
+        {
+            handler->PSendSysMessage(LANG_WRONG_FACTION, factionId);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_FACTION);
+        //"UPDATE characters_npcbot SET faction = ? WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, factionId);
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.DirectExecute(stmt);
+
+        handler->PSendSysMessage("%s's faction set to %u", bot->GetName().c_str(), factionId);
+        bot->GetBotAI()->InitFaction();
+        return true;
+    }
+
+    static bool HandleNpcSetOwnerCommand(ChatHandler* handler, const char* args)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot || !*args)
+        {
+            handler->SendSysMessage(".npcbot set owner #guid | #name");
+            handler->SendSysMessage("Binds selected npcbot to new player owner using guid or name and updates owner in DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->GetIAmABot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("This npcbot already has owner");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* characterName_str = strtok((char*)args, " ");
+        if (!characterName_str)
+            return false;
+
+        std::string characterName = characterName_str;
+        uint32 guidlow = (uint32)atoi(characterName_str);
+
+        if (guidlow)
+            sObjectMgr->GetPlayerNameByGUID(ObjectGuid(HighGuid::Player, guidlow), characterName);
+        else
+            guidlow = sObjectMgr->GetPlayerGUIDByName(characterName);
+
+        if (!guidlow || !normalizePlayerName(characterName))
+        {
+            handler->PSendSysMessage("Player %s not found", characterName.c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        bot->GetBotAI()->SetBotOwnerGUID(guidlow);
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, guidlow);
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+
+        handler->PSendSysMessage("%s's new owner is %s (guidlow: %u)", bot->GetName().c_str(), characterName.c_str(), guidlow);
+        return true;
+    }
+
+    static bool HandleNpcBotLookupCommand(ChatHandler* handler, const char* args)
+    {
+        //this is just a modified '.lookup creature' command
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot lookup #class");
+            handler->SendSysMessage("Looks up npcbots by #class, and returns all matches with their creature ID's.");
+            handler->PSendSysMessage("BOT_CLASS_WARRIOR = %u", uint32(BOT_CLASS_WARRIOR));
+            handler->PSendSysMessage("BOT_CLASS_PALADIN = %u", uint32(BOT_CLASS_PALADIN));
+            handler->PSendSysMessage("BOT_CLASS_HUNTER = %u", uint32(BOT_CLASS_HUNTER));
+            handler->PSendSysMessage("BOT_CLASS_ROGUE = %u", uint32(BOT_CLASS_ROGUE));
+            handler->PSendSysMessage("BOT_CLASS_PRIEST = %u", uint32(BOT_CLASS_PRIEST));
+            handler->PSendSysMessage("BOT_CLASS_DEATH_KNIGHT = %u", uint32(BOT_CLASS_DEATH_KNIGHT));
+            handler->PSendSysMessage("BOT_CLASS_SHAMAN = %u", uint32(BOT_CLASS_SHAMAN));
+            handler->PSendSysMessage("BOT_CLASS_MAGE = %u", uint32(BOT_CLASS_MAGE));
+            handler->PSendSysMessage("BOT_CLASS_WARLOCK = %u", uint32(BOT_CLASS_WARLOCK));
+            handler->PSendSysMessage("BOT_CLASS_DRUID = %u", uint32(BOT_CLASS_DRUID));
+            handler->PSendSysMessage("BOT_CLASS_BM = %u", uint32(BOT_CLASS_BM));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* classstr = strtok((char*)args, " ");
+        uint8 botclass = BOT_CLASS_NONE;
+
+        if (classstr)
+            botclass = (uint8)atoi(classstr);
+
+        if (botclass == BOT_CLASS_NONE || botclass >= BOT_CLASS_END)
+        {
+            handler->PSendSysMessage("Unknown bot class %u", uint32(botclass));
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Looking for bots of class %u...", uint32(botclass));
+
+        uint8 localeIndex = handler->GetSessionDbLocaleIndex();
+        CreatureTemplateContainer const* ctc = sObjectMgr->GetCreatureTemplates();
+        typedef std::list<BotPair> BotList;
+        BotList botlist;
+        for (CreatureTemplateContainer::const_iterator itr = ctc->begin(); itr != ctc->end(); ++itr)
+        {
+            uint32 id = itr->second.Entry;
+            if (id < BOT_ENTRY_BEGIN || id > BOT_ENTRY_END) continue;
+            uint32 trainer_class = itr->second.trainer_class;
+            if (trainer_class != botclass) continue;
+
+            if (CreatureLocale const* creatureLocale = sObjectMgr->GetCreatureLocale(id))
+            {
+                if (creatureLocale->Name.size() > localeIndex && !creatureLocale->Name[localeIndex].empty())
+                {
+                    botlist.push_back(BotPair(id, creatureLocale->Name[localeIndex]));
+                    continue;
+                }
+            }
+
+            std::string name = itr->second.Name;
+            if (name.empty())
+                continue;
+
+            botlist.push_back(BotPair(id, name));
+        }
+
+        if (botlist.empty())
+        {
+            handler->SendSysMessage(LANG_COMMAND_NOCREATUREFOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        botlist.sort(&script_bot_commands::sortbots);
+
+        for (BotList::const_iterator itr = botlist.begin(); itr != botlist.end(); ++itr)
+        {
+            uint32 id = itr->first;
+            char const* name = itr->second.c_str();
+            handler->PSendSysMessage(LANG_CREATURE_ENTRY_LIST_CHAT, id, id, name);
+        }
+
+        return true;
+    }
+
+    static bool HandleNpcBotDeleteCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* chr = handler->GetSession()->GetPlayer();
+        Unit* ubot = chr->GetSelectedUnit();
+        if (!ubot)
+        {
+            handler->SendSysMessage(".npcbot delete");
+            handler->SendSysMessage("Deletes selected npcbot spawn from world and DB");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = ubot->ToCreature();
+        if (!bot || !bot->IsNPCBot())
+        {
+            handler->SendSysMessage("No npcbot selected");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* botowner = bot->GetBotOwner()->ToPlayer())
+            botowner->GetBotMgr()->RemoveBot(bot->GetGUID(), BOT_REMOVE_DISMISS);
+
+        uint32 id = bot->GetEntry();
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_EQUIP);
+        //"SELECT equipMhEx, equipOhEx, equipRhEx, equipHead, equipShoulders, equipChest, equipWaist, equipLegs, equipFeet, equipWrist, equipHands, equipBack, equipBody, equipFinger1, equipFinger2, equipTrinket1, equipTrinket2, equipNeck
+        //FROM characters_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res = CharacterDatabase.Query(stmt);
+        ASSERT(res);
+
+        Field* fields = res->Fetch();
+        for (uint8 i = 0; i != BOT_INVENTORY_SIZE; ++i)
+        {
+            if (fields[i].GetUInt32())
+            {
+                handler->PSendSysMessage("%s still has eqipment assigned. Please remove equips before deleting bot!", bot->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+        }
+
+        bot->CombatStop();
+        bot->DeleteFromDB();
+        bot->AddObjectToRemoveList();
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_NPCBOT);
+        //"DELETE FROM characters_npcbot WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, id);
+        CharacterDatabase.Execute(stmt);
+
+        handler->SendSysMessage("Npcbot successfully deleted.");
+        return true;
+    }
+
+    static bool HandleNpcBotSpawnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+        {
+            handler->SendSysMessage(".npcbot spawn");
+            handler->SendSysMessage("Adds new npcbot spawn of given entry in world. You can shift-link the npc");
+            handler->SendSysMessage("Syntax: .npcbot spawn #entry");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!creInfo)
+        {
+            handler->PSendSysMessage("creature %u does not exist!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+            handler->PSendSysMessage("creature %u is not a npcbot!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+        //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res1 = CharacterDatabase.Query(stmt);
+        if (res1)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to replace this bot to new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        float x = chr->GetPositionX();
+        float y = chr->GetPositionY();
+        float z = chr->GetPositionZ();
+        float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, chr->GetPhaseMaskForSpawn(), id, x, y, z, o))
+        {
+            delete creature;
+            return false;
+        }
+
+        uint8 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = creature->GetCreatureTemplate()->trainer_class;
+        if (!(m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE ||
+            m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT ||
+            m_class == CLASS_SHAMAN || m_class == BOT_CLASS_BM))
+            roleMask |= BOT_ROLE_RANGED;
+        if (m_class == CLASS_PRIEST || m_class == CLASS_DRUID ||
+            m_class == CLASS_SHAMAN || m_class == CLASS_PALADIN)
+            roleMask |= BOT_ROLE_HEAL;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        stmt->setUInt8(1, roleMask);
+        CharacterDatabase.DirectExecute(stmt);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetSpawnId();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned.");
+        return true;
+    }
+
+    static bool HandleNpcBotJumpCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* player = handler->GetSession()->GetPlayer();
+        ObjectGuid sel = player->GetTarget();
+        if (!sel)
+            return false;
+
+        Creature* bot = ObjectAccessor::GetCreatureOrPetOrVehicle(*player, sel);
+        if (!bot/* || (!bot->GetIAmABot() && !bot->GetIAmABotsPet())*/)
+            return false;
+
+        float speedZ = 10.0f;
+        float dist = bot->GetExactDist2d(player->GetPositionX(), player->GetPositionY());
+        float speedXY = dist;
+
+        bot->StopMoving();
+        bot->GetMotionMaster()->Clear();
+        bot->GetMotionMaster()->MoveJump(*player, speedXY, speedZ);
+
+        return true;
+    }
+
+    static bool HandleNpcBotSummonCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guidLowstr = strtok((char*)args, " ");
+        uint32 guidLow = 0;
+
+        if (guidLowstr)
+            guidLow = (uint32)atoi(guidLowstr);
+
+        if (!guidLow)
+            return false;
+
+        QueryResult result = WorldDatabase.PQuery("SELECT id FROM creature WHERE guid = %u", guidLow);
+        if (!result)
+            return false;
+
+        Field* field = result->Fetch();
+        uint32 id = field[0].GetUInt32();
+
+        Player* player = handler->GetSession()->GetPlayer();
+
+        /*if (Creature* cre = ObjectAccessor::GetObjectInOrOutOfWorld(ObjectGuid(HIGHGUID_UNIT, id, guidLow), (Creature*)NULL))
+        {
+            if (cre->GetIAmABot() && !cre->GetBotAI()->GetBotOwnerGuid())
+            {
+                BotMgr::TeleportBot(cre, player->GetMap(), player);
+                return true;
+            }
+        }*/
+
+        return false;
+    }
+
+    static bool HandleNpcBotInfoCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!owner->GetTarget())
+        {
+            handler->PSendSysMessage(".npcbot info");
+            handler->PSendSysMessage("Lists NpcBots count of each class owned by selected player. You can use this on self and your party members");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        Player* master = owner->GetSelectedPlayer();
+        if (!master || (owner->GetGroup() ? !owner->GetGroup()->IsMember(master->GetGUID()) : master->GetGUID() != owner->GetGUID()))
+        {
+            handler->PSendSysMessage("You should select self or one of your party members.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (!master->HaveBot())
+        {
+            handler->PSendSysMessage("%s has no NpcBots!", master->GetName().c_str());
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("Listing NpcBots for %s", master->GetName().c_str());
+        handler->PSendSysMessage("Owned NpcBots: %u", master->GetNpcBotsCount());
+        for (uint8 i = BOT_CLASS_WARRIOR; i != BOT_CLASS_END; ++i)
+        {
+            uint8 count = 0;
+            uint8 alivecount = 0;
+            BotMap const* map = master->GetBotMgr()->GetBotMap();
+            for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+            {
+                if (Creature* cre = itr->second)
+                {
+                    if (cre->GetBotClass() == i)
+                    {
+                        ++count;
+                        if (cre->IsAlive())
+                            ++alivecount;
+                    }
+                }
+            }
+            if (count == 0)
+                continue;
+
+            char const* bclass;
+            if (i >= BOT_CLASS_EX_START)
+            {
+                ASSERT(count == 1);
+
+                switch (i)
+                {
+                    //|cffe6cc80|hxxx|h|r
+                    case BOT_CLASS_BM:              bclass = "|cff9d9d9d|hHas Blademaster!|h|r";    break;
+                    default:                        bclass = "wtf";                                 break;
+                }
+                handler->PSendSysMessage("%s (alive: %s)", bclass, (alivecount ? "yes" : "no"));
+            }
+            else
+            {
+                switch (i)
+                {
+                    case BOT_CLASS_WARRIOR:         bclass = "Warriors";        break;
+                    case BOT_CLASS_PALADIN:         bclass = "Paladins";        break;
+                    case BOT_CLASS_MAGE:            bclass = "Mages";           break;
+                    case BOT_CLASS_PRIEST:          bclass = "Priests";         break;
+                    case BOT_CLASS_WARLOCK:         bclass = "Warlocks";        break;
+                    case BOT_CLASS_DRUID:           bclass = "Druids";          break;
+                    case BOT_CLASS_DEATH_KNIGHT:    bclass = "Death Knights";   break;
+                    case BOT_CLASS_ROGUE:           bclass = "Rogues";          break;
+                    case BOT_CLASS_SHAMAN:          bclass = "Shamans";         break;
+                    case BOT_CLASS_HUNTER:          bclass = "Hunters";         break;
+                    default:                        bclass = "Unknown Class";   break;
+                }
+                handler->PSendSysMessage("%s: %u (alive: %u)", bclass, count, alivecount);
+            }
+        }
+        return true;
+    }
+
+    static bool HandleNpcBotDistanceCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            if (owner->HaveBot())
+            {
+                handler->PSendSysMessage("bot follow distance is %u", owner->GetBotFollowDist());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage(".npcbot distance");
+            handler->PSendSysMessage("Sets 'distance to target' at which bots will follow you");
+            handler->PSendSysMessage("if set to 0, bots will not attack anything unless you point them");
+            handler->PSendSysMessage("min: 0, max: 75");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* distance = strtok((char*)args, " ");
+        int8 dist = -1;
+
+        if (distance)
+            dist = (int8)atoi(distance);
+
+        if (dist >= 0 && dist <= 75)
+        {
+            owner->SetBotFollowDist(dist);
+            if (!owner->IsInCombat() && owner->HaveBot())
+                owner->GetBotMgr()->SendBotCommandState(COMMAND_FOLLOW);
+
+            Group* gr = owner->GetGroup();
+            if (gr && owner->GetMap()->Instanceable() && /*gr->isRaidGroup() &&*/ gr->IsLeader(owner->GetGUID()))
+            {
+                for (GroupReference* itr = gr->GetFirstMember(); itr != NULL; itr = itr->next())
+                {
+                    Player* pl = itr->GetSource();
+                    if (pl && pl->IsInWorld() && pl->GetMap() == owner->GetMap())
+                    {
+                        pl->SetBotFollowDist(dist);
+                        if (!pl->IsInCombat() && pl->HaveBot())
+                            pl->GetBotMgr()->SendBotCommandState(COMMAND_FOLLOW);
+                    }
+                }
+            }
+            handler->PSendSysMessage("bot follow distance set to %u", dist);
+            return true;
+        }
+        handler->SendSysMessage("follow distance should be between 0 and 75");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotCommandCommand(ChatHandler* handler, const char* args)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        if (!*args)
+        {
+            handler->PSendSysMessage(".npcbot command <command>");
+            handler->PSendSysMessage("Forces npcbots to either follow you or hold position.");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        char* command = strtok((char*)args, " ");
+        int8 state = -1;
+        if (!strncmp(command, "s", 2) || !strncmp(command, "st", 3) || !strncmp(command, "stay", 5) || !strncmp(command, "stand", 6))
+            state = COMMAND_STAY;
+        else if (!strncmp(command, "f", 2) || !strncmp(command, "follow", 7) || !strncmp(command, "fol", 4) || !strncmp(command, "fo", 3))
+            state = COMMAND_FOLLOW;
+        if (state >= 0 && owner->HaveBot())
+        {
+            owner->GetBotMgr()->SendBotCommandState(CommandStates(state));
+            return true;
+        }
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotRemoveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->PSendSysMessage(".npcbot remove");
+            handler->PSendSysMessage("Frees selected npcbot from it's owner. Select player to remove all npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* master = u->ToPlayer();
+        if (master)
+        {
+            if (master->HaveBot())
+            {
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+
+                if (!master->HaveBot())
+                {
+                    handler->PSendSysMessage("Npcbots were successfully removed");
+                    handler->SetSentErrorMessage(true);
+                    return true;
+                }
+                handler->PSendSysMessage("Some npcbots were not removed!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            handler->PSendSysMessage("Npcbots are not found!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* cre = u->ToCreature();
+        if (cre && cre->GetIAmABot() && !cre->IsFreeBot())
+        {
+            master = cre->GetBotOwner();
+            master->GetBotMgr()->RemoveBot(cre->GetGUID(), BOT_REMOVE_DISMISS);
+            if (master->GetBotMgr()->GetBot(cre->GetGUID()) == NULL)
+            {
+                handler->PSendSysMessage("NpcBot successfully removed");
+                handler->SetSentErrorMessage(true);
+                return true;
+            }
+            handler->PSendSysMessage("NpcBot was NOT removed for some stupid reason!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        handler->PSendSysMessage("You must select player or controlled npcbot");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotResetCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Player* master = NULL;
+        bool all = false;
+        ObjectGuid guid = owner->GetTarget();
+        if (!guid)
+        {
+            handler->PSendSysMessage(".npcbot reset");
+            handler->PSendSysMessage("Reset selected npcbot, or all npcbots if used on self");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+        if (guid.IsPlayer())
+        {
+            master = owner;
+            all = true;
+        }
+        else if (guid.IsCreature())
+        {
+            if (Creature* cre = ObjectAccessor::GetCreature(*owner, guid))
+                master = cre->GetBotOwner();
+        }
+        if (master && master->GetGUID() == owner->GetGUID())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("Npcbots are not found!");
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+            if (all)
+                master->RemoveAllBots(BOT_REMOVE_DISMISS);
+            else
+                master->GetBotMgr()->RemoveBot(guid, BOT_REMOVE_DISMISS);
+            handler->SetSentErrorMessage(true);
+            return true;
+        }
+        handler->PSendSysMessage(".npcbot reset");
+        handler->PSendSysMessage("Reset selected npcbot. Cannot be used in combat");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+    static bool HandleNpcBotReviveCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* u = owner->GetSelectedUnit();
+        if (!u)
+        {
+            handler->SendSysMessage(".npcbot revive");
+            handler->SendSysMessage("Revives selected npcbot. If player is selected, revives all selected player's npcbots");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* master = u->ToPlayer())
+        {
+            if (!master->HaveBot())
+            {
+                handler->PSendSysMessage("%s has no npcbots!", master->GetName().c_str());
+                handler->SetSentErrorMessage(true);
+                return false;
+            }
+
+            master->GetBotMgr()->ReviveAllBots();
+            handler->SendSysMessage("Npcbots revived.");
+            return true;
+        }
+        else if (Creature* bot = u->ToCreature())
+        {
+            if (bot->GetBotAI())
+            {
+                BotMgr::ReviveBot(bot);
+                handler->PSendSysMessage("%s revived.", bot->GetName().c_str());
+                return true;
+            }
+        }
+
+        handler->SendSysMessage("You must select player or npcbot.");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+
+    static bool HandleNpcBotAddCommand(ChatHandler* handler, const char* /*args*/)
+    {
+        Player* owner = handler->GetSession()->GetPlayer();
+        Unit* cre = owner->GetSelectedUnit();
+
+        if (!cre || cre->GetTypeId() != TYPEID_UNIT)
+        {
+            handler->SendSysMessage(".npcbot add");
+            handler->SendSysMessage("Allows to hire selected uncontrolled bot, bypassing price condition");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* bot = cre->ToCreature();
+        if (!bot || !bot->GetIAmABot() || bot->GetBotAI()->GetBotOwnerGuid())
+        {
+            handler->SendSysMessage("You must select uncontrolled npcbot");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        BotMgr* mgr = owner->GetBotMgr();
+        if (!mgr)
+            mgr = new BotMgr(owner);
+
+        if (mgr->AddBot(bot) == BOT_ADD_SUCCESS)
+        {
+            handler->PSendSysMessage("%s is now your npcbot", bot->GetName().c_str());
+            return true;
+        }
+
+        handler->PSendSysMessage("NpcBot is NOT created for some reason!");
+        handler->SetSentErrorMessage(true);
+        return false;
+    }
+};
+
+void AddSC_script_bot_commands()
+{
+    new script_bot_commands();
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.cpp b/src/server/game/AI/NpcBots/botmgr.cpp
new file mode 100644
index 0000000..7cccca0
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.cpp
@@ -0,0 +1,841 @@
+#include "bot_ai.h"
+#include "bot_Events.h"
+#include "botmgr.h"
+#include "Chat.h"
+#include "Config.h"
+#include "GroupMgr.h"
+#include "GridNotifiers.h"
+#include "GridNotifiersImpl.h"
+#include "Group.h"
+#include "Language.h"
+#include "MapManager.h"
+#include "ObjectMgr.h"
+#include "Player.h"
+#include "SpellAuras.h"
+/*
+Npc Bot Manager by Graff (onlysuffering@gmail.com)
+Player NpcBots management
+%Complete: ???
+*/
+
+//config
+int8 _basefollowdist;
+uint8 _maxNpcBots;
+uint8 _maxClassNpcBots;
+uint8 _xpReductionNpcBots;
+uint8 _healTargetIconFlags;
+uint32 _npcBotsCost;
+bool _enableNpcBots;
+bool _allowgm;
+bool _enableNpcBotsDungeons;
+bool _enableNpcBotsRaids;
+bool _enableNpcBotsBGs;
+bool _enableNpcBotsArenas;
+bool _enableDungeonFinder;
+bool _limitNpcBotsDungeons;
+bool _limitNpcBotsRaids;
+bool _botPvP;
+float _mult_dmg_melee;
+float _mult_dmg_spell;
+float _mult_healing;
+
+bool __firstload = true;
+
+BotMgr::BotMgr(Player* const master) : _owner(master)
+{
+    //LoadConfig(); already loaded (MapManager.cpp)
+    _followdist = _basefollowdist;
+
+    master->SetBotMgr(this);
+}
+BotMgr::~BotMgr() { }
+
+void BotMgr::LoadConfig(bool force)
+{
+    if (__firstload)
+        __firstload = false;
+    else if (!force)
+        return;
+
+    _enableNpcBots          = sConfigMgr->GetBoolDefault("NpcBot.Enable", true);
+    _allowgm                = sConfigMgr->GetBoolDefault("NpcBot.AllowGM", true);
+    _maxNpcBots             = sConfigMgr->GetIntDefault("NpcBot.MaxBots", 1);
+    _maxClassNpcBots        = sConfigMgr->GetIntDefault("NpcBot.MaxBotsPerClass", 1);
+    _basefollowdist         = sConfigMgr->GetIntDefault("NpcBot.BaseFollowDistance", 30);
+    _xpReductionNpcBots     = sConfigMgr->GetIntDefault("NpcBot.XpReduction", 0);
+    _healTargetIconFlags    = sConfigMgr->GetIntDefault("NpcBot.HealTargetIconsMask", 0);
+    _mult_dmg_melee         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Melee", 1.0);
+    _mult_dmg_spell         = sConfigMgr->GetFloatDefault("NpcBot.Mult.Damage.Spell", 1.0);
+    _mult_healing           = sConfigMgr->GetFloatDefault("NpcBot.Mult.Healing", 1.0);
+    _enableNpcBotsDungeons  = sConfigMgr->GetBoolDefault("NpcBot.Enable.Dungeon", true);
+    _enableNpcBotsRaids     = sConfigMgr->GetBoolDefault("NpcBot.Enable.Raid", false);
+    _enableNpcBotsBGs       = sConfigMgr->GetBoolDefault("NpcBot.Enable.BG", false);
+    _enableNpcBotsArenas    = sConfigMgr->GetBoolDefault("NpcBot.Enable.Arena", false);
+    _enableDungeonFinder    = sConfigMgr->GetBoolDefault("NpcBot.Enable.DungeonFinder", true);
+    _limitNpcBotsDungeons   = sConfigMgr->GetBoolDefault("NpcBot.Limit.Dungeon", true);
+    _limitNpcBotsRaids      = sConfigMgr->GetBoolDefault("NpcBot.Limit.Raid", true);
+    _npcBotsCost            = sConfigMgr->GetIntDefault("NpcBot.Cost", 1000000);
+    _botPvP                 = sConfigMgr->GetBoolDefault("NpcBot.PvP", true);
+
+    //limits
+    _mult_dmg_melee         = std::max(_mult_dmg_melee, 0.1f);
+    _mult_dmg_spell         = std::max(_mult_dmg_spell, 0.1f);
+    _mult_healing           = std::max(_mult_healing,   0.1f);
+    _mult_dmg_melee         = std::min(_mult_dmg_melee, 10.f);
+    _mult_dmg_spell         = std::min(_mult_dmg_spell, 10.f);
+    _mult_healing           = std::min(_mult_healing,   10.f);
+}
+
+uint8 BotMgr::GetNpcBotsCount(bool inWorldOnly) const
+{
+    if (!inWorldOnly)
+        return _bots.size();
+
+    //CRITICAL SECTION
+    //inWorldOnly is only for one-shot cases (opcodes, etc.)
+    uint8 count = 0;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+        if (ObjectAccessor::GetCreatureOrPetOrVehicle(*_owner, itr->first))
+            ++count;
+    return count;
+}
+
+bool BotMgr::IsNpcBotModEnabled()
+{
+    return _enableNpcBots;
+}
+
+bool BotMgr::IsAllowGMModEnabled()
+{
+    return _allowgm;
+}
+
+bool BotMgr::IsNpcBotDungeonFinderEnabled()
+{
+    return _enableDungeonFinder;
+}
+
+uint8 BotMgr::GetNpcBotXpReduction()
+{
+    return _xpReductionNpcBots;
+}
+
+uint8 BotMgr::GetMaxNpcBots()
+{
+    return _maxNpcBots <= 4 ? _maxNpcBots : 4;
+}
+
+bool BotMgr::LimitBots(Map const* map)
+{
+    if (_limitNpcBotsDungeons && map->IsNonRaidDungeon())
+        return true;
+    if (_limitNpcBotsRaids && map->IsRaid())
+        return true;
+
+    return false;
+}
+
+void BotMgr::Update(uint32 diff)
+{
+    //remove temp bots from bot map before updating it
+    while (!_removeList.empty())
+    {
+        GuidList::iterator itr = _removeList.begin();
+
+        BotMap::iterator bitr = _bots.find(*itr);
+        ASSERT(bitr != _bots.end());
+        _bots.erase(bitr);
+
+        _removeList.erase(itr);
+        continue;
+    }
+
+    if (!HaveBot())
+        return;
+
+    //uint64 guid;
+    Creature* bot;
+    bot_minion_ai* ai;
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        //guid = itr->first;
+        bot = itr->second;
+        ai = bot->GetBotMinionAI();
+
+        if (ai->IAmFree())
+            continue;
+
+        if (!bot->IsInWorld())
+        {
+            ai->CommonTimers(diff);
+            continue;
+        }
+
+        if (!_isPartyInCombat())
+            ai->UpdateReviveTimer(diff);
+
+        bot->SetCanUpdate(true);
+        bot->IsAIEnabled = true;
+
+        if (ai->GetReviveTimer() <= diff)
+        {
+            if (bot->isDead() && _owner->IsAlive() && !_owner->IsInCombat() && !_owner->IsBeingTeleported() && !_owner->InArena() &&
+                !_owner->IsInFlight() && !_owner->HasFlag(UNIT_FIELD_FLAGS_2, UNIT_FLAG2_FEIGN_DEATH) &&
+                !_owner->HasInvisibilityAura() && !_owner->HasStealthAura())
+            {
+                _reviveBot(bot);
+                continue;
+            }
+
+            ai->SetReviveTimer(urand(1000, 5000));
+        }
+
+        if (_owner->IsAlive() && bot->IsAlive() && !ai->IsTempBot() && !ai->IsDuringTeleport() &&
+            (RestrictBots(bot, false) ||
+            bot->GetMap() != _owner->GetMap() ||
+            (bot->GetBotCommandState() != COMMAND_STAY && _owner->GetDistance(bot) > 100.f))) // _owner->GetDistance(bot) > SIZE_OF_GRIDS
+        {
+            _owner->m_Controlled.erase(bot);
+            TeleportBot(bot, _owner->GetMap(), _owner);
+            continue;
+        }
+
+        bot->Update(diff);
+        bot->SetCanUpdate(false);
+
+        if (Creature* pet = bot->GetBotsPet())
+        {
+            pet->SetCanUpdate(true);
+            pet->IsAIEnabled = true;
+            pet->Update(diff);
+            pet->SetCanUpdate(false);
+        }
+    }
+}
+
+bool BotMgr::RestrictBots(Creature const* bot, bool add) const
+{
+    if (!_owner->FindMap())
+        return true;
+
+    if (_owner->IsInFlight())
+        return true;
+
+    Map const* currMap = _owner->GetMap();
+
+    if ((!_enableNpcBotsBGs && currMap->IsBattleground()) ||
+        (!_enableNpcBotsArenas && currMap->IsBattleArena()) ||
+        (!_enableNpcBotsDungeons && currMap->IsNonRaidDungeon()) ||
+        (!_enableNpcBotsRaids && currMap->IsRaid()))
+        return true;
+
+    if (LimitBots(currMap))
+    {
+        //if bot is not in instance group - deny (only if trying to teleport to instance)
+        if (add)
+            if (!_owner->GetGroup() || !_owner->GetGroup()->IsMember(bot->GetGUID()))
+                return true;
+
+        InstanceMap const* map = currMap->ToInstanceMap();
+        uint32 count = map->GetPlayersCountExceptGMs();
+        if (count + uint8(add) > map->GetMaxPlayers())
+            return true;
+    }
+
+    return false;
+}
+
+void BotMgr::_reviveBot(Creature* bot)
+{
+    if (bot->IsAlive())
+        return;
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->Relocate(bot->GetBotOwner());
+
+    bot->SetUInt32Value(UNIT_NPC_FLAGS, bot->GetCreatureTemplate()->npcflag);
+    bot->ClearUnitState(uint32(UNIT_STATE_ALL_STATE));
+    bot->setDeathState(ALIVE);
+    //bot->GetBotAI()->Reset();
+    bot->SetBotShouldUpdateStats();
+
+    bot->SetHealth(bot->GetMaxHealth() / 6); //~15% of max health
+    if (bot->getPowerType() == POWER_MANA)
+        bot->SetPower(POWER_MANA, bot->GetMaxPower(POWER_MANA) / 5); //20% of max mana
+
+    if (!bot->GetBotAI()->IAmFree())
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+}
+
+Creature* BotMgr::GetBot(ObjectGuid guid) const
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    return itr != _bots.end() ? itr->second : NULL;
+}
+
+bool BotMgr::_isPartyInCombat() const
+{
+    if (_owner->IsInCombat())
+        return true;
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        if (itr->second->IsInCombat())
+            return true;
+        if (Creature* pet = itr->second->GetBotsPet())
+            if (pet->IsInCombat())
+                return true;
+    }
+
+    return false;
+}
+
+void BotMgr::OnTeleportFar(uint32 mapId, float x, float y, float z, float ori)
+{
+    Map* newMap = sMapMgr->CreateBaseMap(mapId);
+    Creature* bot;
+    Position pos;
+    pos.Relocate(x, y, z, ori);
+
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        bot = itr->second;
+        ASSERT(bot && "BotMgr::OnTeleportFar(): bot does not exist!!!");
+
+        if (bot->IsTempBot())
+            continue;
+
+        _owner->m_Controlled.erase(bot);
+        TeleportBot(bot, newMap, &pos);
+    }
+}
+
+void BotMgr::_teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori)
+{
+    ASSERT(bot->GetBotAI());
+    bot->GetBotAI()->AbortTeleport();
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+    bot->KillEvents(true);
+
+    if (bot->IsInWorld())
+    {
+        //bot->Whisper("teleport...", LANG_UNIVERSAL, bot->GetBotAI()->GetBotOwnerGuid());
+        bot->CastSpell(bot, COSMETIC_TELEPORT_EFFECT, true);
+    }
+
+    bot->IsAIEnabled = false;
+    //UnitAI* oldAI = bot->GetAI();
+    //bot->SetAI(NULL);
+
+    //if (bot->IsFreeBot() || bot->GetBotOwner()->GetSession()->isLogingOut())
+    //{
+    //    bot->FarTeleportTo(newMap, x, y, z, ori);
+
+    //    //bot->SetAI(oldAI);
+    //    bot->IsAIEnabled = true;
+    //    return;
+    //}
+
+    ////start Unit::CleanupBeforeRemoveFromMap()
+    if (bot->IsInWorld())
+        bot->RemoveFromWorld();
+
+    ASSERT(bot->GetGUID());
+
+    // A unit may be in removelist and not in world, but it is still in grid
+    // and may have some references during delete
+    //RemoveAllAuras();
+    bot->RemoveAllGameObjects();
+
+    //if (finalCleanup)
+    //    m_cleanupDone = true;
+
+    bot->m_Events.KillAllEvents(false);                      // non-delatable (currently casted spells) will not deleted now but it will deleted at call in Map::RemoveAllObjectsInRemoveList
+    bot->CombatStop();
+    bot->ClearComboPointHolders();
+    //bot->DeleteThreatList();
+    bot->getHostileRefManager().setOnlineOfflineState(false);
+    //bot->GetMotionMaster()->Clear(false);                    // remove different non-standard movement generators.
+    //end Unit::CleanupBeforeRemoveFromMap()
+
+    //bot->CleanupBeforeRemoveFromMap(false);
+
+    bot->BotStopMovement();
+
+    if (Map* mymap = bot->FindMap())
+        mymap->RemoveFromMap(bot, false);
+
+    if (bot->IsFreeBot()/* || bot->GetBotOwner()->GetSession()->isLogingOut()*/)
+    {
+        //bot->FarTeleportTo(newMap, x, y, z, ori);
+
+        //Creature::FarTeleportTo()
+        //{
+        //CleanupBeforeRemoveFromMap(false); //done above
+        //GetMap()->RemoveFromMap(this, false); //done above
+        //Relocate(X, Y, Z, O);
+        //SetMap(map);
+        //GetMap()->AddToMap(this);
+        //}
+        bot->Relocate(x, y, z, ori);
+        bot->SetMap(newMap);
+        bot->GetMap()->AddToMap(bot);
+        //end Creature::FarTeleportTo()
+
+        //bot->SetAI(oldAI);
+        bot->IsAIEnabled = true;
+        return;
+    }
+
+    //update group member online state
+    if (Group* gr = bot->GetBotOwner()->GetGroup())
+        if (gr->IsMember(bot->GetGUID()))
+            gr->SendUpdate();
+
+    //bot->Relocate(x, y, z);
+    TeleportFinishEvent* finishEvent = new TeleportFinishEvent(bot->GetBotMinionAI()/*, newMap->GetId(), newMap->GetInstanceId(), x, y, z, ori*/);
+    bot->GetBotAI()->GetEvents()->AddEvent(finishEvent, bot->GetBotAI()->GetEvents()->CalculateTime(urand(5000, 8000)));
+    bot->GetBotMinionAI()->SetTeleportFinishEvent(finishEvent);
+}
+
+void BotMgr::TeleportBot(Creature* bot, Map* newMap, Position* pos)
+{
+    _teleportBot(bot, newMap, pos->GetPositionX(), pos->GetPositionY(), pos->GetPositionZ(), pos->GetOrientation());
+}
+
+void BotMgr::CleanupsBeforeBotDelete(ObjectGuid guid)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(b)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(b)!!");
+
+    Creature* bot = itr->second;
+
+    //don't allow removing bots while they are teleporting
+    if (!bot->IsInWorld())
+    {
+        bot->GetBotAI()->AbortTeleport();
+        //if (!bot->IsInWorld())
+        //{
+        //    TC_LOG_ERROR("entities.player", "BotMgr::CleanupsBeforeBotDelete(): Failed to abort %s's teleport! Still out of world!", bot->GetName().c_str());
+        //    ASSERT(false);
+        //}
+    }
+
+    //if player is logging out group will be disbanded (and bots removed) normal way
+    //WorldSession.cpp:: if (_player->GetGroup() && !_player->GetGroup()->isRaidGroup() && m_Socket)
+    if (!_owner->GetSession()->PlayerLogout())
+        RemoveBotFromGroup(bot);
+
+    bot->SetBotsPetDied();
+    bot->OnBotDespawn(NULL);
+
+    //_owner->SetMinion((Minion*)bot->ToTempSummon(), false);
+    ASSERT(bot->GetOwnerGUID() == _owner->GetGUID());
+    bot->SetOwnerGUID(ObjectGuid::Empty);
+    _owner->m_Controlled.erase(bot);
+    bot->m_ControlledByPlayer = false;
+    bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, 0);
+    bot->SetGuidValue(UNIT_FIELD_CREATEDBY, ObjectGuid::Empty);
+
+    bot->SetIAmABot(false);
+}
+
+void BotMgr::_addBotToRemoveList(ObjectGuid guid)
+{
+    _removeList.push_back(guid);
+}
+
+void BotMgr::RemoveAllBots(uint8 removetype)
+{
+    while (!_bots.empty())
+        RemoveBot(_bots.begin()->first, removetype);
+}
+//Bot is being abandoned by player
+void BotMgr::RemoveBot(ObjectGuid guid, uint8 removetype)
+{
+    BotMap::const_iterator itr = _bots.find(guid);
+    ASSERT(itr != _bots.end() && "Trying to remove bot which does not belong to this botmgr(a)!!");
+    ASSERT(_owner->IsInWorld() && "Trying to remove bot while not in world(a)!!");
+
+    //trying to remove temp bot second time means removing all bots
+    //just erase from bots because already cleaned up
+    for (GuidList::iterator it = _removeList.begin(); it != _removeList.end(); ++it)
+    {
+        if (*it == guid)
+        {
+            _removeList.erase(it);
+            _bots.erase(itr);
+            return;
+        }
+    }
+
+    Creature* bot = itr->second;
+    CleanupsBeforeBotDelete(guid);
+
+    ////remove control bar
+    //if (GetNpcBotsCount() <= 1 && !_owner->GetPetGUID() && _owner->m_Controlled.empty())
+    //    _owner->SendRemoveControlBar();
+
+    if (bot->GetBotAI()->IsTempBot())
+    {
+        bot->GetBotAI()->OnBotDespawn(bot); //send to self
+        _addBotToRemoveList(guid);
+        return;
+    }
+
+    _bots.erase(itr);
+
+    bot->GetBotAI()->ResetBotAI(removetype == BOT_REMOVE_DISMISS ? BOTAI_RESET_DISMISS : BOTAI_RESET_LOGOUT);
+
+    bot->setFaction(bot->GetCreatureTemplate()->faction);
+    bot->SetLevel(bot->GetCreatureTemplate()->minlevel);
+
+    if (removetype == BOT_REMOVE_DISMISS)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, uint32(0));
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+    }
+
+    bot->AI()->Reset();
+}
+
+BotAddResult BotMgr::AddBot(Creature* bot, bool takeMoney)
+{
+    ASSERT(bot->IsNPCBot());
+    ASSERT(bot->GetBotAI() != NULL);
+
+    bool temporary = bot->GetBotAI()->IsTempBot();
+
+    if (!_enableNpcBots)
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.SendSysMessage("NpcBot system is currently disabled. Please contact administration.");
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_DISABLED;
+    }
+    // Is this the best place for this?
+    if (_owner->IsGameMaster())
+        {
+            if (!_allowgm)
+            {
+                ChatHandler ch(_owner->GetSession());
+                ch.SendSysMessage("NpcBot system is only available for players. GM's are not permitted to have bots.");
+                //ch.SetSentErrorMessage(true);
+                return BOT_ADD_DISABLED;
+            }
+        }
+    if (GetBot(bot->GetGUID()))
+        return BOT_ADD_ALREADY_HAVE; //Silent error, intended
+    if (!bot->GetBotAI()->IAmFree())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s will not join you, already has master: %s",
+            bot->GetName().c_str(), bot->GetBotOwner()->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_NOT_AVAILABLE;
+    }
+    if (bot->GetBotAI()->IsDuringTeleport())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("%s cannot join you while about to teleport", bot->GetName().c_str());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_BUSY;
+    }
+    if (!temporary && _owner->GetNpcBotsCount() >= GetMaxNpcBots())
+    {
+        ChatHandler ch(_owner->GetSession());
+        ch.PSendSysMessage("Youre exceed max npcbots (%u)", GetMaxNpcBots());
+        //ch.SetSentErrorMessage(true);
+        return BOT_ADD_MAX_EXCEED;
+    }
+    if (!temporary && HaveBot() && _maxClassNpcBots)
+    {
+        uint8 count = 0;
+        for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+            if (itr->second->GetBotClass() == bot->GetBotClass())
+                ++count;
+
+        if (count >= _maxClassNpcBots)
+        {
+            ChatHandler ch(_owner->GetSession());
+            ch.PSendSysMessage("You cannot have more bots of that class! %u of %u", count, _maxClassNpcBots);
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_MAX_CLASS_EXCEED;
+        }
+    }
+    //Map* curMap = _owner->GetMap();
+    //if (!temporary && LimitBots(curMap))
+    //{
+    //    InstanceMap* map = curMap->ToInstanceMap();
+    //    uint32 count = map->GetPlayersCountExceptGMs();
+    //    if (count >= map->GetMaxPlayers())
+    //    {
+    //        ChatHandler ch(_owner->GetSession());
+    //        ch.PSendSysMessage("Instance players limit exceed (%u of %u)", count, map->GetMaxPlayers());
+    //        //ch.SetSentErrorMessage(true);
+    //        return BOT_ADD_INSTANCE_LIMIT;
+    //    }
+    //}
+    if (!temporary && takeMoney)
+    {
+        uint32 cost = GetNpcBotCost(_owner->getLevel(), bot);
+        if (!_owner->HasEnoughMoney(cost))
+        {
+            ChatHandler ch(_owner->GetSession());
+            std::string str = "You don't have enough money (";
+            str += GetNpcBotCostStr(_owner->getLevel(), bot);
+            str += ")!";
+            ch.SendSysMessage(str.c_str());
+            //ch.SetSentErrorMessage(true);
+            return BOT_ADD_CANT_AFFORD;
+        }
+
+        _owner->ModifyMoney(-(int32(cost)));
+    }
+
+    bot->SetBotsPetDied();
+    bot->GetBotAI()->UnsummonAll();
+
+    _bots[bot->GetGUID()] = bot;
+
+    bot->SetIAmABot(true);
+    bot->SetBotOwner(_owner);
+    bot->SetGuidValue(UNIT_FIELD_CREATEDBY, _owner->GetGUID());
+
+    //_owner->SetMinion((Minion*)bot->ToTempSummon(), true);
+    ASSERT(!bot->GetOwnerGUID());
+    bot->SetOwnerGUID(_owner->GetGUID());
+    _owner->m_Controlled.insert(bot);
+    bot->m_ControlledByPlayer = true;
+    bot->SetFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PVP_ATTACKABLE);
+    bot->SetByteValue(UNIT_FIELD_BYTES_2, 1, _owner->GetByteValue(UNIT_FIELD_BYTES_2, 1));
+
+    //bot->RemoveFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_IMMUNE_TO_PC | UNIT_FLAG_IMMUNE_TO_NPC);
+    //bot->SetByteValue(UNIT_FIELD_BYTES_0, 0, botrace);
+    bot->setFaction(_owner->getFaction());
+    //bot->SetLevel(_owner->getLevel());
+    //bot->SetBotClass(botclass);
+    //bot->AIM_Initialize();
+    //bot->InitBotAI();
+    //AddBotToGroup(bot);
+    //InitBotEquips(m_bot);
+
+
+    //CharmInfo charmInfo(_owner); //owner to not set reaction and other stuff, just empty charm
+    //charmInfo.InitPetActionBar();
+
+    //uint8 addlist = 0;
+    //for (uint8 i = 0; i != MAX_SPELL_CHARM; ++i)
+    //    if (charmInfo.GetCharmSpell(i)->GetAction())
+    //        ++addlist;
+
+    //WorldPacket data(SMSG_PET_SPELLS, 8+2+4+4+4*MAX_UNIT_ACTION_BAR_INDEX+1+4*addlist+1);
+    //data << uint64(bot->GetGUID());
+    //data << uint16(0);
+    //data << uint32(0);
+
+    //data << uint8(bot->GetReactState()) << uint8(bot->GetBotCommandState()) << uint16(0);
+
+    //charmInfo.BuildActionBar(&data);
+
+    //data << uint8(addlist);
+
+    //if (addlist)
+    //{
+    //    for (uint8 i = 0; i != MAX_SPELL_CHARM; ++i)
+    //    {
+    //        CharmSpellInfo* cspell = charmInfo.GetCharmSpell(i);
+    //        if (cspell->GetAction())
+    //            data << uint32(cspell->packedData);
+    //    }
+    //}
+
+    //data << uint8(0); // cooldowns count
+
+    //_owner->GetSession()->SendPacket(&data);
+
+
+    bot->GetBotAI()->Reset();
+
+    if (!bot->GetBotAI()->IsTempBot())
+    {
+        bot->SetBotCommandState(COMMAND_FOLLOW, true);
+        if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            AddBotToGroup(bot);
+    }
+
+    if (!temporary)
+    {
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER);
+        //"UPDATE characters_npcbot SET owner = ? WHERE entry = ?", CONNECTION_ASYNC
+        stmt->setUInt32(0, _owner->GetGUID().GetCounter());
+        stmt->setUInt32(1, bot->GetEntry());
+        CharacterDatabase.Execute(stmt);
+    }
+
+    return BOT_ADD_SUCCESS;
+}
+
+bool BotMgr::AddBotToGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (gr)
+    {
+        if (gr->IsMember(bot->GetGUID()))
+            return true;
+
+        if (gr->IsFull())
+        {
+            if (!gr->isRaidGroup()) //non-raid group is full
+                gr->ConvertToRaid();
+            else
+                return false;
+        }
+    }
+    else
+    {
+        gr = new Group;
+        if (!gr->Create(_owner))
+        {
+            delete gr;
+            return false;
+        }
+        sGroupMgr->AddGroup(gr);
+    }
+
+    if (gr->AddMember((Player*)bot))
+    {
+        if (!bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+            bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+        bot->GetBotAI()->CancelBoot();
+        return true;
+    }
+
+    return false;
+}
+
+bool BotMgr::RemoveBotFromGroup(Creature* bot)
+{
+    ASSERT(GetBot(bot->GetGUID()));
+
+    Group* gr = _owner->GetGroup();
+    if (!gr || !gr->IsMember(bot->GetGUID()))
+        return false;
+
+    gr->RemoveMember(bot->GetGUID());
+
+    if (bot->GetBotAI()->HasRole(BOT_ROLE_PARTY))
+        bot->GetBotAI()->ToggleRole(BOT_ROLE_PARTY, true);
+
+    Map* map = _owner->FindMap();
+    gr = _owner->GetGroup(); //check if group has been deleted
+    if (map && map->IsDungeon() && (!gr || !gr->IsMember(bot->GetGUID()))) //make sure bot is removed from group
+    {
+        ChatHandler(_owner->GetSession()).PSendSysMessage("Your bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        if (gr && _owner->GetGUID() != gr->GetLeaderGUID())
+            if (Player* leader = ObjectAccessor::FindPlayer(gr->GetLeaderGUID()))
+                ChatHandler(leader->GetSession()).PSendSysMessage("Bot %s has been removed from your group and will be teleported out of the instance in 60 seconds if not invited back", bot->GetName().c_str());
+
+        bot->GetBotAI()->StartBoot();
+    }
+
+    return true;
+}
+
+bool BotMgr::RemoveAllBotsFromGroup(bool newGroup)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        RemoveBotFromGroup(itr->second);
+        itr->second->GetBotAI()->SetNeedParty(newGroup);
+    }
+
+    return true;
+}
+
+uint32 BotMgr::GetNpcBotCost(uint8 level, Creature* creature)
+{
+    if (!creature || !creature->GetBotAI())
+        return (_npcBotsCost * level) / DEFAULT_MAX_LEVEL;
+
+    uint32 base;
+    switch (creature->GetBotAI()->GetBotClass())
+    {
+        case BOT_CLASS_BM:
+            //base = GetNpcBotCost(level, NULL) * 9;
+            //base = 100000; //10 gold
+            //break;
+        case BOT_CLASS_WARRIOR:
+        case BOT_CLASS_PALADIN:
+        case BOT_CLASS_HUNTER:
+        case BOT_CLASS_ROGUE:
+        case BOT_CLASS_PRIEST:
+        case BOT_CLASS_DEATH_KNIGHT:
+        case BOT_CLASS_SHAMAN:
+        case BOT_CLASS_MAGE:
+        case BOT_CLASS_WARLOCK:
+        case BOT_CLASS_DRUID:
+        default:
+            base = 0;
+            break;
+    }
+
+    return base + GetNpcBotCost(level, NULL);
+}
+
+std::string BotMgr::GetNpcBotCostStr(uint8 level, Creature* creature)
+{
+    std::ostringstream money;
+
+    if (uint32 cost = GetNpcBotCost(level, creature))
+    {
+        uint32 gold = uint32(cost / 10000);
+        cost -= (gold * 10000);
+        uint32 silver = uint32(cost / 100);
+        cost -= (silver * 100);
+
+        if (gold != 0)
+            money << gold << " |TInterface\\Icons\\INV_Misc_Coin_01:8|t";
+        if (silver != 0)
+            money << silver << " |TInterface\\Icons\\INV_Misc_Coin_03:8|t";
+        if (cost)
+            money << cost << " |TInterface\\Icons\\INV_Misc_Coin_05:8|t";
+    }
+
+    return money.str();
+}
+
+void BotMgr::ReviveAllBots()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        _reviveBot(itr->second);
+    }
+}
+
+void BotMgr::SendBotCommandState(CommandStates state)
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetBotCommandState(state, true);
+    }
+}
+
+void BotMgr::SetBotsShouldUpdateStats()
+{
+    for (BotMap::const_iterator itr = _bots.begin(); itr != _bots.end(); ++itr)
+    {
+        itr->second->SetBotShouldUpdateStats();
+    }
+}
diff --git a/src/server/game/AI/NpcBots/botmgr.h b/src/server/game/AI/NpcBots/botmgr.h
new file mode 100644
index 0000000..b922fc9
--- /dev/null
+++ b/src/server/game/AI/NpcBots/botmgr.h
@@ -0,0 +1,110 @@
+#ifndef _BOTMGR_H
+#define _BOTMGR_H
+
+#include "Common.h"
+
+class Creature;
+class Map;
+class Player;
+
+struct Position;
+
+enum BotAddResult
+{
+    BOT_ADD_DISABLED                    = 0x001,
+    BOT_ADD_ALREADY_HAVE                = 0x002,
+    BOT_ADD_MAX_EXCEED                  = 0x004,
+    BOT_ADD_MAX_CLASS_EXCEED            = 0x008,
+    BOT_ADD_CANT_AFFORD                 = 0x010,
+    BOT_ADD_INSTANCE_LIMIT              = 0x020,
+    BOT_ADD_BUSY                        = 0x040,
+    BOT_ADD_NOT_AVAILABLE               = 0x080,
+
+    BOT_ADD_SUCCESS                     = 0x100,
+
+    BOT_ADD_ALL_MASK                    = 0xFFF,
+
+    BOT_ADD_FATAL                       = (BOT_ADD_DISABLED | BOT_ADD_CANT_AFFORD | BOT_ADD_MAX_EXCEED | BOT_ADD_MAX_CLASS_EXCEED)
+};
+
+enum BotRemoveType
+{
+    BOT_REMOVE_LOGOUT                   = 0,
+    BOT_REMOVE_DISMISS                  = 1,
+    BOT_REMOVE_HIDE                     = 2, //NYI
+    BOT_REMOVE_UNSUMMON                 = 3,
+    BOT_REMOVE_BY_DEFAULT               = BOT_REMOVE_LOGOUT
+};
+
+typedef std::unordered_map<ObjectGuid /*guid*/, Creature* /*bot*/> BotMap;
+
+class BotMgr
+{
+    public:
+        BotMgr(Player* const master);
+        ~BotMgr();
+
+        Player* GetOwner() const { return _owner; }
+
+        BotMap const* GetBotMap() const { return &_bots; }
+        BotMap* GetBotMap() { return &_bots; }
+
+        static bool IsNpcBotModEnabled();
+        static bool IsAllowGMModEnabled();
+        static bool IsNpcBotDungeonFinderEnabled();
+
+        static void ReloadConfig() { LoadConfig(true); }
+        static void LoadConfig(bool force = false);
+
+        void Update(uint32 diff);
+
+        Creature* GetBot(ObjectGuid guid) const;
+        bool HaveBot() const { return !_bots.empty(); }
+        uint8 GetNpcBotsCount(bool inWorldOnly = false) const;
+        static uint8 GetMaxNpcBots();
+        static uint8 GetNpcBotXpReduction();
+        static bool LimitBots(Map const* map);
+        bool RestrictBots(Creature const* bot, bool add) const;
+
+        static uint32 GetNpcBotCost(uint8 level, Creature* creature);
+        static std::string GetNpcBotCostStr(uint8 level, Creature* creature);
+
+        void OnTeleportFar(uint32 mapId, float x, float y, float z, float ori = 0.f);
+        void ReviveAllBots();
+        void SendBotCommandState(CommandStates state);
+
+        void CleanupsBeforeBotDelete(ObjectGuid guid);
+        void RemoveAllBots(uint8 removetype = BOT_REMOVE_LOGOUT);
+        void RemoveBot(ObjectGuid guid, uint8 removetype = BOT_REMOVE_LOGOUT);
+        BotAddResult AddBot(Creature* bot, bool takeMoney = false);
+        bool AddBotToGroup(Creature* bot);
+        bool RemoveBotFromGroup(Creature* bot);
+        bool RemoveAllBotsFromGroup(bool newGroup);
+
+        uint8 GetBotFollowDist() const { return _followdist; }
+        void SetBotFollowDist(int8 dist) { _followdist = dist; }
+
+        void SetBotsShouldUpdateStats();
+
+        static void ReviveBot(Creature* bot) { _reviveBot(bot); }
+
+        //TELEPORT BETWEEN MAPS
+        //CONFIRMEND UNSAFE (charmer,owner)
+        static void TeleportBot(Creature* bot, Map* newMap, Position* pos);
+
+    private:
+        static void _teleportBot(Creature* bot, Map* newMap, float x, float y, float z, float ori = 0.f);
+
+        bool _isPartyInCombat() const;
+        static void _reviveBot(Creature* bot);
+
+        void _addBotToRemoveList(ObjectGuid guid);
+
+        Player* const _owner;
+        BotMap _bots;
+        GuidList _removeList;
+
+        int8 _followdist;
+};
+
+#endif
diff --git a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
index 768def2..ad38ada 100644
--- a/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
+++ b/src/server/game/AuctionHouse/AuctionHouseMgr.cpp
@@ -31,6 +31,8 @@
 #include "Language.h"
 #include "Log.h"
 
+#include "../../plugins/ahbot/AhBot.h"
+
 enum eAuctionHouse
 {
     AH_MINIMUM_DEPOSIT = 100
@@ -200,6 +202,9 @@ void AuctionHouseMgr::SendAuctionSuccessfulMail(AuctionEntry* auction, SQLTransa
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_SUCCESSFUL), AuctionEntry::BuildAuctionMailBody(auction->bidder, auction->bid, auction->buyout, auction->deposit, auction->GetAuctionCut()))
             .AddMoney(profit)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, sWorld->getIntConfig(CONFIG_MAIL_DELIVERY_DELAY));
+
+        // ahbot mod
+        auctionbot.Won(auction);
     }
 }
 
@@ -223,6 +228,9 @@ void AuctionHouseMgr::SendAuctionExpiredMail(AuctionEntry* auction, SQLTransacti
         MailDraft(auction->BuildAuctionMailSubject(AUCTION_EXPIRED), AuctionEntry::BuildAuctionMailBody(0, 0, auction->buyout, auction->deposit, 0))
             .AddItem(pItem)
             .SendMailTo(trans, MailReceiver(owner, auction->owner), auction, MAIL_CHECK_MASK_COPIED, 0);
+
+        // ahbot mod
+        auctionbot.Expired(auction);
     }
     else
     {
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index 6455e3a..85a5acc 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -108,6 +108,7 @@ include_directories(
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/CoreAI
+  ${CMAKE_CURRENT_SOURCE_DIR}/AI/NpcBots
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/ScriptedAI
   ${CMAKE_CURRENT_SOURCE_DIR}/AI/SmartScripts
   ${CMAKE_CURRENT_SOURCE_DIR}/AuctionHouse
@@ -207,6 +208,7 @@ add_library(game STATIC
   ${game_STAT_PCH_SRC}
 )
 
+add_dependencies(plugins revision_data.h)
 # Generate precompiled header
 if (USE_COREPCH)
   add_cxx_pch(game ${game_STAT_PCH_HDR} ${game_STAT_PCH_SRC})
diff --git a/src/server/game/Chat/Chat.cpp b/src/server/game/Chat/Chat.cpp
index c99fe62..571ae31 100644
--- a/src/server/game/Chat/Chat.cpp
+++ b/src/server/game/Chat/Chat.cpp
@@ -360,7 +360,8 @@ bool ChatHandler::SetDataForCommandInTable(std::vector<ChatCommand>& table, char
         // expected subcommand by full name DB content
         else if (*text)
         {
-            TC_LOG_ERROR("sql.sql", "Table `command` have unexpected subcommand '%s' in command '%s', skip.", text, fullcommand.c_str());
+            // FEYZEE: hide error caused by command table
+            //TC_LOG_ERROR("sql.sql", "Table `command` have unexpected subcommand '%s' in command '%s', skip.", text, fullcommand.c_str());
             return false;
         }
 
diff --git a/src/server/game/DungeonFinding/LFGMgr.cpp b/src/server/game/DungeonFinding/LFGMgr.cpp
index 250f6e0..f0876b4 100644
--- a/src/server/game/DungeonFinding/LFGMgr.cpp
+++ b/src/server/game/DungeonFinding/LFGMgr.cpp
@@ -34,6 +34,12 @@
 #include "WorldSession.h"
 #include "InstanceSaveMgr.h"
 
+//npcbot
+//#include "bot_ai.h"
+#include "botmgr.h"
+#include "Chat.h"
+//end npcbot
+
 namespace lfg
 {
 
@@ -436,6 +442,50 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                         joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
                     ++memberCount;
                     players.insert(plrg->GetGUID());
+
+                    //npcbot
+                    if (!plrg->HaveBot())
+                        continue;
+                    //add npcbots
+                    BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                    for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                    {
+                        if (!grp->IsMember(itr->first))
+                            continue;
+
+                        //disabled in config
+                        if (!BotMgr::IsNpcBotDungeonFinderEnabled())
+                        {
+                            (ChatHandler(plrg->GetSession())).SendSysMessage("Using npcbots in Dungeon Finder is restricted. Contact your administration.");
+
+                            if (plrg->GetGUID() != grp->GetLeaderGUID())
+                                if (Player* leader = ObjectAccessor::FindPlayer(grp->GetLeaderGUID()))
+                                    (ChatHandler(leader->GetSession())).PSendSysMessage("There is a npcbot in your group (owner: %s). Using npcbots in Dungeon Finder is restricted. Contact your administration.",
+                                        plrg->GetName().c_str());
+
+                            joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                            break;
+                        }
+
+                        if (Creature* bot = ObjectAccessor::GetCreatureOrPetOrVehicle(*plrg, itr->first))
+                        {
+                            if (!bot->IsTempBot())
+                            {
+                                if (joinData.result == LFG_JOIN_OK &&
+                                    !(bot->GetBotRoles() & ( 1 | 2 | 4 ))) //(BOT_ROLE_TANK | BOT_ROLE_DPS | BOT_ROLE_HEAL)
+                                {
+                                    //no valid roles - reqs are not met
+                                    (ChatHandler(plrg->GetSession())).PSendSysMessage("Your bot %s does not have any viable roles assigned.", bot->GetName().c_str());
+                                    joinData.result = LFG_JOIN_PARTY_NOT_MEET_REQS;
+                                    continue;
+                                }
+
+                                ++memberCount;
+                                players.insert(itr->first);
+                            }
+                        }
+                    }
+                    //end npcbot
                 }
             }
 
@@ -533,6 +583,9 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
         SetState(gguid, LFG_STATE_ROLECHECK);
         // Send update to player
         LfgUpdateData updateData = LfgUpdateData(LFG_UPDATETYPE_JOIN_QUEUE, dungeons, comment);
+        //npcbot
+        std::map<ObjectGuid, uint8> brolemap;
+        //end npcbot
         for (GroupReference* itr = grp->GetFirstMember(); itr != NULL; itr = itr->next())
         {
             if (Player* plrg = itr->GetSource())
@@ -546,10 +599,51 @@ void LFGMgr::JoinLfg(Player* player, uint8 roles, LfgDungeonSet& dungeons, const
                 if (!debugNames.empty())
                     debugNames.append(", ");
                 debugNames.append(plrg->GetName());
+
+                //npcbot
+                if (!plrg->HaveBot())
+                    continue;
+                //add npcbots
+                BotMap const* map = plrg->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = map->begin(); itr != map->end(); ++itr)
+                {
+                    if (players.find(itr->first) == players.end() || !grp->IsMember(itr->first))
+                        continue;
+
+                    if (Creature* bot = ObjectAccessor::GetCreatureOrPetOrVehicle(*plrg, itr->first))
+                    {
+                        if (!bot->IsTempBot())
+                        {
+                            ObjectGuid bguid = itr->first;
+                            SetState(bguid, LFG_STATE_ROLECHECK);
+                            if (!isContinue)
+                                SetSelectedDungeons(bguid, dungeons);
+                            roleCheck.roles[bguid] = 0;
+                            if (!debugNames.empty())
+                                debugNames.append(", ");
+                            debugNames.append(bot->GetName());
+
+                            uint8 broles = 0;
+                            if (bot->GetBotRoles() & 1) //BOT_ROLE_TANK
+                                broles |= PLAYER_ROLE_TANK;
+                            if (bot->GetBotRoles() & 4) //BOT_ROLE_HEAL
+                                broles |= PLAYER_ROLE_HEALER;
+                            if (bot->GetBotRoles() & 2) //BOT_ROLE_DPS
+                                broles |= PLAYER_ROLE_DAMAGE;
+                            brolemap[bguid] = broles;
+                            //UpdateRoleCheck(gguid, bguid, broles);
+                        }
+                    }
+                }
+                //end npcbot
             }
         }
         // Update leader role
         UpdateRoleCheck(gguid, guid, roles);
+        //npcbot - update bots' roles
+        for (std::map<ObjectGuid, uint8>::const_iterator it = brolemap.begin(); it != brolemap.end(); ++it)
+            UpdateRoleCheck(gguid, it->first, it->second);
+        //end npcbot
     }
     else                                                   // Add player to queue
     {
@@ -899,6 +993,48 @@ void LFGMgr::MakeNewGroup(LfgProposal const& proposal)
         if (!player)
             continue;
 
+        //npcbot - handle player's bots
+        if (player->HaveBot())
+        {
+            Group* group = player->GetGroup();
+            if (group && group != grp)
+                Player::RemoveFromGroup(group, pguid);
+
+            if (!grp)
+            {
+                grp = new Group();
+                grp->ConvertToLFG();
+                grp->Create(player);
+                ObjectGuid gguid = grp->GetGUID();
+                SetState(gguid, LFG_STATE_PROPOSAL);
+                sGroupMgr->AddGroup(grp);
+            }
+            else if (group != grp)
+                grp->AddMember(player);
+
+            grp->SetLfgRoles(pguid, proposal.players.find(pguid)->second.role);
+
+            // Add the cooldown spell if queued for a random dungeon
+            if (dungeon->type == LFG_TYPE_RANDOM)
+                player->CastSpell(player, LFG_SPELL_DUNGEON_COOLDOWN, false);
+
+            for (GuidList::const_iterator itr2 = players.begin(); itr2 != players.end(); ++itr2)
+            {
+                ObjectGuid bguid = (*itr2);
+                if (bguid.IsPlayer())
+                    continue;
+                Creature* bot = player->GetBotMgr()->GetBot(bguid);
+                if (!bot)
+                    continue;
+
+                player->GetBotMgr()->AddBotToGroup(bot);
+                grp->SetLfgRoles(bguid, proposal.players.find(bguid)->second.role);
+            }
+
+            continue;
+        }
+        //end npcbot
+
         Group* group = player->GetGroup();
         if (group && group != grp)
             group->RemoveMember(player->GetGUID());
@@ -967,6 +1103,29 @@ void LFGMgr::UpdateProposal(uint32 proposalId, ObjectGuid guid, bool accept)
     if (itProposalPlayer == proposal.players.end())
         return;
 
+    //npcbot - player accepted proposal
+    //make its bots accept too
+    if (accept && guid.IsPlayer())
+    {
+        //if (Player* player = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Player*)NULL))
+        //{
+            //if (player->HaveBot())
+            //{
+                for (LfgProposalPlayerContainer::const_iterator itPlayers = proposal.players.begin(); itPlayers != proposal.players.end(); ++itPlayers)
+                {
+                    ObjectGuid bguid = itPlayers->first;
+                    if (bguid.IsPlayer())
+                        continue;
+                    //if (!player->GetBotMgr()->GetBot(bguid))
+                        //continue;
+
+                    UpdateProposal(proposalId, bguid, accept);
+                }
+            //}
+        //}
+    }
+    //end npcbot
+
     LfgProposalPlayer& player = itProposalPlayer->second;
     player.accept = LfgAnswer(accept);
 
diff --git a/src/server/game/DungeonFinding/LFGQueue.cpp b/src/server/game/DungeonFinding/LFGQueue.cpp
index 86b010a..72167c6 100644
--- a/src/server/game/DungeonFinding/LFGQueue.cpp
+++ b/src/server/game/DungeonFinding/LFGQueue.cpp
@@ -520,6 +520,25 @@ LfgCompatibility LFGQueue::CheckCompatibility(GuidList check)
         return LFG_COMPATIBLES_WITH_LESS_PLAYERS;
     }
 
+    //FEYZEE: disable this code because it effect LFG while grouped
+    //FEYZEE: normally this code seems fine
+    /*
+    // playerbot mod
+    bool nonBotFound = false;
+    for (GuidList::const_iterator it = check.begin(); it != check.end(); ++it)
+    {
+        Player *player = sObjectMgr->GetPlayerByLowGUID(*it);
+        if (player && !player->GetPlayerbotAI())
+        {
+            nonBotFound = true;
+            break;
+        }
+    }
+    if (!nonBotFound)
+        return LFG_INCOMPATIBLES_HAS_IGNORES;
+    // end of playerbot mod
+    */
+
     ObjectGuid gguid = *check.begin();
     proposal.queues = check;
     proposal.isNew = numLfgGroups != 1 || sLFGMgr->GetOldState(gguid) != LFG_STATE_DUNGEON;
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index 9173d44..24c841c 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -48,6 +48,10 @@
 #include "WorldPacket.h"
 #include "Transport.h"
 
+//npcbot
+#include "bot_ai.h"
+//end npcbot
+
 TrainerSpell const* TrainerSpellData::Find(uint32 spell_id) const
 {
     TrainerSpellMap::const_iterator itr = spellList.find(spell_id);
@@ -158,6 +162,13 @@ m_originalEntry(0), m_homePosition(), m_transportHomePosition(), m_creatureInfo(
     TriggerJustRespawned = false;
     m_isTempWorldObject = false;
     _focusSpell = NULL;
+
+    //bot
+    m_creature_owner = NULL;
+    m_bots_pet = NULL;
+    bot_AI = NULL;
+    m_canUpdate = true;
+    //end bot
 }
 
 Creature::~Creature()
@@ -447,6 +458,15 @@ bool Creature::UpdateEntry(uint32 entry, CreatureData const* data /*= nullptr*/)
 
 void Creature::Update(uint32 diff)
 {
+    //npcbot: update helper
+    if (bot_AI)
+    {
+        if (!m_canUpdate)
+            return;
+        bot_AI->CommonTimers(diff);
+    }
+    //end npcbot
+
     if (IsAIEnabled && TriggerJustRespawned)
     {
         TriggerJustRespawned = false;
@@ -499,6 +519,11 @@ void Creature::Update(uint32 diff)
             if (m_deathState != CORPSE)
                 break;
 
+            //npcbot
+            if (bot_AI)
+                break;
+            //end npcbot
+
             if (m_groupLootTimer && lootingGroupLowGUID)
             {
                 if (m_groupLootTimer <= diff)
@@ -524,6 +549,9 @@ void Creature::Update(uint32 diff)
 
             // creature can be dead after Unit::Update call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
+            //npcbot - skip dead state for bots (handled by AI)
+            if (!bot_AI)
+            //end npcbot
             if (!IsAlive())
                 break;
 
@@ -579,8 +607,15 @@ void Creature::Update(uint32 diff)
                 m_AI_locked = true;
 
                 i_AI->UpdateAI(diff);
+                //bot
+                if (!bot_AI)
+                //end bot
                 m_AI_locked = false;
             }
+            //npcbot - Update evade mode AI
+            else if (bot_AI)
+                bot_AI->UpdateAI(diff);
+            //end npcbot
 
             // creature can be dead after UpdateAI call
             // CORPSE/DEAD state will processed at next tick (in other case death timer will be updated unexpectedly)
@@ -633,6 +668,11 @@ void Creature::Update(uint32 diff)
 
 void Creature::RegenerateMana()
 {
+    //npcbot - manual regen enabled
+    if (GetBotAI())
+        return;
+    //end npcbot
+
     uint32 curValue = GetPower(POWER_MANA);
     uint32 maxValue = GetMaxPower(POWER_MANA);
 
@@ -668,6 +708,11 @@ void Creature::RegenerateMana()
 
 void Creature::RegenerateHealth()
 {
+    //npcbot - manual regen enabled
+    if (GetBotAI())
+        return;
+    //end npcbot
+
     if (!isRegeneratingHealth())
         return;
 
@@ -1298,6 +1343,23 @@ bool Creature::LoadCreatureFromDB(ObjectGuid::LowType spawnId, Map* map, bool ad
 
     m_creatureData = data;
 
+    //npcbot
+    if (IsNPCBot())
+    {
+        //prevent loading npcbot twice (grid unload/load case)
+        if (sWorld->GetMaxPlayerCount() > 0)
+            return false;
+
+        TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+        ASSERT(!IsInWorld());
+        SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+        //don't allow removing dead bot's corpse
+        m_corpseDelay = std::numeric_limits<uint32>::max();
+        setActive(true);
+    }
+    //end npcbot
+
     if (addToMap && !GetMap()->AddToMap(this))
         return false;
     return true;
@@ -1311,6 +1373,11 @@ void Creature::SetCanDualWield(bool value)
 
 void Creature::LoadEquipment(int8 id, bool force /*= true*/)
 {
+    //npcbot: prevent loading equipment for bots
+    if (IsNPCBot())
+        return;
+    //end npcbot
+
     if (id == 0)
     {
         if (force)
@@ -1606,6 +1673,9 @@ void Creature::Respawn(bool force)
         if (IsAIEnabled)
         {
             //reset the AI to be sure no dirty or uninitialized values will be used till next tick
+            //npcbot - not for bots
+            if (!bot_AI)
+            //end npcbot
             AI()->Reset();
             TriggerJustRespawned = true;//delay event to next tick so all creatures are created on the map before processing
         }
@@ -2188,6 +2258,16 @@ void Creature::SetInCombatWithZone()
 
 uint32 Creature::GetShieldBlockValue() const                  //dunno mob block value
 {
+    //npcbot - bot block value is fully calculated into botAI
+    if (bot_AI)
+    {
+        float blockValue = bot_AI->GetShieldBlockValue();
+        blockValue += GetTotalAuraModifier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE);
+        blockValue *= GetTotalAuraMultiplier(SPELL_AURA_MOD_SHIELD_BLOCKVALUE_PCT);
+        return uint32(blockValue);
+    }
+    //end npcbot
+
     return (getLevel()/2 + uint32(GetStat(STAT_STRENGTH)/20));
 }
 
@@ -2675,6 +2755,391 @@ void Creature::StartPickPocketRefillTimer()
     _pickpocketLootRestore = time(NULL) + sWorld->getIntConfig(CONFIG_CREATURE_PICKPOCKET_REFILL);
 }
 
+//NPCBOT
+bool Creature::LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap)
+{
+    CreatureData const* data = sObjectMgr->GetCreatureData(guid);
+
+    if (!data)
+    {
+        TC_LOG_ERROR("sql.sql", "Bot creature (GUID: %u) not found in table `creature`, can't load. ", guid);
+        return false;
+    }
+
+    m_spawnId = guid;
+    ASSERT(map->GetInstanceId() == 0);
+    if (map->GetCreature(ObjectGuid(HighGuid::Unit, data->id, guid)))
+        return false;
+
+    if (!Create(guid, map, data->phaseMask, data->id, data->posX, data->posY, data->posZ, data->orientation, data))
+        return false;
+
+    //We should set first home position, because then AI calls home movement
+    SetHomePosition(data->posX, data->posY, data->posZ, data->orientation);
+
+    m_respawnradius = data->spawndist;
+
+    m_respawnDelay = data->spawntimesecs;
+    m_deathState = ALIVE;
+
+    m_respawnTime  = GetMap()->GetCreatureRespawnTime(m_spawnId);
+    if (m_respawnTime)                          // respawn on Update
+    {
+        m_deathState = DEAD;
+        if (CanFly())
+        {
+            float tz = map->GetHeight(GetPhaseMask(), data->posX, data->posY, data->posZ, false);
+            if (data->posZ - tz > 0.1f)
+                Relocate(data->posX, data->posY, tz);
+        }
+    }
+
+    uint32 curhealth;
+
+    if (!m_regenHealth)
+    {
+        curhealth = data->curhealth;
+        if (curhealth)
+        {
+            curhealth = uint32(curhealth*_GetHealthMod(GetCreatureTemplate()->rank));
+            if (curhealth < 1)
+                curhealth = 1;
+        }
+        SetPower(POWER_MANA, data->curmana);
+    }
+    else
+    {
+        curhealth = GetMaxHealth();
+        SetPower(POWER_MANA, GetMaxPower(POWER_MANA));
+    }
+
+    SetHealth(m_deathState == ALIVE ? curhealth : 0);
+
+    // checked at creature_template loading
+    m_defaultMovementType = MovementGeneratorType(data->movementType);
+
+    m_creatureData = data;
+
+    TC_LOG_INFO("entities.unit", "Creature: loading npcbot %s (id: %u)", GetName().c_str(), GetEntry());
+    ASSERT(!IsInWorld());
+    SetByteValue(UNIT_FIELD_BYTES_0, 0, GetCreatureTemplate()->trainer_race); //set race
+
+    //don't allow removing dead bot's corpse
+    m_corpseDelay = std::numeric_limits<uint32>::max();
+    setActive(true);
+
+    if (addToMap && !GetMap()->AddToMap(this))
+        return false;
+    return true;
+}
+
+uint8 Creature::GetBotClass() const
+{
+    return bot_AI ? bot_AI->GetBotClass() : getClass();
+}
+
+Player* Creature::GetBotOwner() const
+{
+    return bot_AI ? bot_AI->GetBotOwner() : NULL;
+}
+
+void Creature::SetBotOwner(Player* newowner)
+{
+    if (bot_AI)
+        bot_AI->SetBotOwner(newowner);
+}
+
+bool Creature::IsNPCBot() const
+{
+    return GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT;
+}
+
+bool Creature::IsFreeBot() const
+{
+    return bot_AI && bot_AI->IAmFree();
+}
+
+void Creature::SetIAmABot(bool bot)
+{
+    CombatStop(!bot);
+    DeleteThreatList();
+
+    if (bot)
+    {
+        m_unitTypeMask |= (/*UNIT_MASK_SUMMON | */UNIT_MASK_MINION);
+    }
+    else
+    {
+        SetCharmerGUID(ObjectGuid::Empty);
+        bot_AI->UnsummonAll();
+        m_unitTypeMask &= ~(/*UNIT_MASK_SUMMON | */UNIT_MASK_MINION);
+        SetGuidValue(UNIT_FIELD_CREATEDBY, ObjectGuid::Empty);
+        //if (bot_AI->IsMinionAI())
+        //    SetOwnerGUID(0);
+    }
+}
+
+void Creature::SetBotsPetDied()
+{
+    if (!m_bots_pet)
+        return;
+
+    m_bots_pet->SetCharmerGUID(ObjectGuid::Empty);
+    m_bots_pet->SetCreatureOwner(NULL);
+    //m_bots_pet->GetBotPetAI()->SetCreatureOwner(NULL);
+    GetBotOwner()->SetMinion((Minion*)m_bots_pet, false);
+    m_bots_pet->SetIAmABot(false);
+    m_bots_pet->CleanupsBeforeDelete();
+    m_bots_pet->AddObjectToRemoveList();
+    m_bots_pet = NULL;
+}
+
+uint8 Creature::GetBotRoles() const
+{
+    return bot_AI ? bot_AI->GetBotRoles() : 0;
+}
+
+void Creature::SetBotCommandState(CommandStates st, bool force)
+{
+    if (bot_AI)
+        bot_AI->SetBotCommandState(st, force);
+}
+
+CommandStates Creature::GetBotCommandState() const
+{
+    return bot_AI ? bot_AI->GetBotCommandState() : COMMAND_ABANDON;
+}
+//Bot damage mods
+void Creature::ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo);
+}
+
+void Creature::ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierMelee(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierSpell(damage, damageinfo, spellInfo, attackType, crit);
+}
+
+void Creature::ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotDamageMultiplierHeal(victim, heal, spellInfo, damagetype, stack);
+}
+
+void Creature::ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotCritMultiplierAll(victim, crit_chance, spellInfo, schoolMask, attackType);
+}
+
+void Creature::ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCostMods(spellInfo, cost);
+}
+
+void Creature::ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const
+{
+    if (bot_AI)
+        bot_AI->ApplyBotSpellCastTimeMods(spellInfo, casttime);
+}
+
+bool Creature::GetIAmABot() const
+{
+    return bot_AI && bot_AI->IsMinionAI();
+}
+
+bool Creature::GetIAmABotsPet() const
+{
+    return bot_AI && bot_AI->IsPetAI();
+}
+
+bot_minion_ai* Creature::GetBotMinionAI() const
+{
+    return bot_AI ? bot_AI->ToMinionAI() : NULL;
+}
+
+bot_pet_ai* Creature::GetBotPetAI() const
+{
+    return bot_AI ? bot_AI->ToPetAI() : NULL;
+}
+
+void Creature::SetBotShouldUpdateStats()
+{
+    if (bot_AI)
+        bot_AI->SetShouldUpdateStats();
+}
+
+void Creature::OnBotSummon(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotSummon(summon);
+}
+
+void Creature::OnBotDespawn(Creature* summon)
+{
+    if (bot_AI)
+        bot_AI->OnBotDespawn(summon);
+}
+
+void Creature::KillEvents(bool force)
+{
+    if (bot_AI)
+        bot_AI->KillEvents(force);
+}
+
+void Creature::BotStopMovement()
+{
+    if (IsInWorld())
+    {
+        GetMotionMaster()->Clear();
+        GetMotionMaster()->MoveIdle();
+    }
+    StopMoving();
+    DisableSpline();
+}
+
+void Creature::ResetBotAI(uint8 resetType)
+{
+    if (bot_AI)
+        bot_AI->ResetBotAI(resetType);
+}
+
+bool Creature::CanParry() const
+{
+    return bot_AI ? bot_AI->CanParry() : true;
+}
+
+bool Creature::CanDodge() const
+{
+    return bot_AI ? bot_AI->CanDodge() : true;
+}
+
+bool Creature::CanBlock() const
+{
+    return bot_AI ? bot_AI->CanBlock() : true;
+}
+
+bool Creature::CanCrit() const
+{
+    return bot_AI ? bot_AI->CanCrit() : true;
+}
+
+bool Creature::CanMiss() const
+{
+    return bot_AI ? bot_AI->CanMiss() : true;
+}
+
+float Creature::GetCreatureParryChance() const
+{
+    return bot_AI ? bot_AI->GetBotParryChance() : 5.0f;
+}
+
+float Creature::GetCreatureDodgeChance() const
+{
+    return bot_AI ? bot_AI->GetBotDodgeChance() : 5.0f;
+}
+
+float Creature::GetCreatureBlockChance() const
+{
+    return bot_AI ? bot_AI->GetBotBlockChance() : 5.0f;
+}
+
+float Creature::GetCreatureCritChance() const
+{
+    return bot_AI ? bot_AI->GetBotCritChance() : 0.0f;
+}
+
+float Creature::GetCreatureMissChance() const
+{
+    return bot_AI ? bot_AI->GetBotMissChance() : 5.0f;
+}
+
+float Creature::GetCreatureEvasion() const
+{
+    return bot_AI ? bot_AI->GetBotEvasion() : 0.0f;
+}
+
+float Creature::GetCreatureArmorPenetrationCoef() const
+{
+    return bot_AI ? bot_AI->GetBotArmorPenetrationCoef() : 0.0f;
+}
+
+float Creature::GetCreatureDamageTakenMod() const
+{
+    return bot_AI ? bot_AI->GetBotDamageTakenMod() : 1.0f;
+}
+
+uint32 Creature::GetCreatureExpertise() const
+{
+    return bot_AI ? bot_AI->GetBotExpertise() : 0;
+}
+
+uint32 Creature::GetCreatureSpellPenetration() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPenetration() : 0;
+}
+
+uint32 Creature::GetCreatureSpellPower() const
+{
+    return bot_AI ? bot_AI->GetBotSpellPower() : 0;
+}
+
+bool Creature::IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const
+{
+    return bot_AI && bot_AI->IsBotImmuneToSpell(spellInfo);
+}
+
+bool Creature::IsTempBot() const
+{
+    return bot_AI && bot_AI->IsTempBot();
+}
+
+MeleeHitOutcome Creature::BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const
+{
+    return bot_AI ? bot_AI->BotRollCustomMeleeOutcomeAgainst(victim, attType) : RollMeleeOutcomeAgainst(victim, attType);
+}
+
+void Creature::CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->CastBotItemCombatSpell(target, attType, procVictim, procEx, spell);
+}
+
+void Creature::OnSpellGo(Spell const* spell)
+{
+    if (bot_AI)
+        bot_AI->OnBotSpellGo(spell);
+}
+
+void Creature::AddBotSpellCooldown(uint32 spellId, uint32 cooldown)
+{
+    if (bot_AI)
+        bot_AI->SetSpellCooldown(sSpellMgr->GetSpellInfo(spellId)->GetFirstRankSpell()->Id, cooldown);
+}
+
+//static
+bool Creature::IsBotCustomSpell(uint32 spellId)
+{
+    return bot_ai::IsBotCustomSpell(spellId);
+}
+
+//advanced
+bool Creature::IsQuestBot() const
+{
+    return
+        m_creatureInfo->Entry >= 71000 && m_creatureInfo->Entry < 72000 &&
+        (m_creatureInfo->unit_flags2 & UNIT_FLAG2_ALLOW_ENEMY_INTERACT);
+}
+//END NPCBOT
 void Creature::SetTextRepeatId(uint8 textGroup, uint8 id)
 {
     CreatureTextRepeatIds& repeats = m_textRepeat[textGroup];
diff --git a/src/server/game/Entities/Creature/Creature.h b/src/server/game/Entities/Creature/Creature.h
index 9a41c85..265d3d8 100644
--- a/src/server/game/Entities/Creature/Creature.h
+++ b/src/server/game/Entities/Creature/Creature.h
@@ -37,6 +37,11 @@ class Player;
 class SpellInfo;
 class WorldSession;
 
+// npcbot
+class bot_ai;
+class bot_minion_ai;
+class bot_pet_ai;
+
 enum CreatureFlagsExtra
 {
     CREATURE_FLAG_EXTRA_INSTANCE_BIND       = 0x00000001,       // creature kill bind instance with killer and killer's group
@@ -54,6 +59,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN        = 0x00040000,       // creature won't increase weapon skills
     CREATURE_FLAG_EXTRA_TAUNT_DIMINISH      = 0x00080000,       // Taunt is a subject to diminishing returns on this creautre
     CREATURE_FLAG_EXTRA_ALL_DIMINISH        = 0x00100000,       // Creature is subject to all diminishing returns as player are
+    CREATURE_FLAG_EXTRA_NPCBOT              = 0x04000000,       // custom flag for NPCBots (not confirmed safe)
     CREATURE_FLAG_EXTRA_DUNGEON_BOSS        = 0x10000000,       // creature is a dungeon boss (SET DYNAMICALLY, DO NOT ADD IN DB)
     CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING  = 0x20000000        // creature ignore pathfinding
 };
@@ -63,7 +69,7 @@ enum CreatureFlagsExtra
     CREATURE_FLAG_EXTRA_NO_CRUSH | CREATURE_FLAG_EXTRA_NO_XP_AT_KILL | CREATURE_FLAG_EXTRA_TRIGGER | \
     CREATURE_FLAG_EXTRA_NO_TAUNT | CREATURE_FLAG_EXTRA_WORLDEVENT | CREATURE_FLAG_EXTRA_NO_CRIT | \
     CREATURE_FLAG_EXTRA_NO_SKILLGAIN | CREATURE_FLAG_EXTRA_TAUNT_DIMINISH | CREATURE_FLAG_EXTRA_ALL_DIMINISH | \
-    CREATURE_FLAG_EXTRA_GUARD | CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING)
+    CREATURE_FLAG_EXTRA_NPCBOT | CREATURE_FLAG_EXTRA_GUARD | CREATURE_FLAG_EXTRA_IGNORE_PATHFINDING)
 
 #define CREATURE_REGEN_INTERVAL 2 * IN_MILLISECONDS
 
@@ -675,6 +681,76 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         void SetTextRepeatId(uint8 textGroup, uint8 id);
         void ClearTextRepeatGroup(uint8 textGroup);
 
+        //Bot commands
+        bool LoadBotCreatureFromDB(uint32 guid, Map* map, bool addToMap = true);
+        Player* GetBotOwner() const;
+        void SetBotOwner(Player* newowner);
+        Creature* GetCreatureOwner() const { return m_creature_owner; }
+        void SetCreatureOwner(Creature* newCreOwner) { m_creature_owner = newCreOwner; }
+        Creature* GetBotsPet() const { return m_bots_pet; }
+        void SetBotsPetDied();
+        void SetBotsPet(Creature* newpet) { /*ASSERT (!m_bots_pet);*/ m_bots_pet = newpet; }
+        bool IsNPCBot() const;
+        bool IsFreeBot() const;
+        void SetIAmABot(bool bot = true);
+        bool GetIAmABot() const;
+        bool GetIAmABotsPet() const;
+        uint8 GetBotClass() const;
+        uint8 GetBotRoles() const;
+        bot_ai* GetBotAI() const { return bot_AI; }
+        bot_minion_ai* GetBotMinionAI() const;
+        bot_pet_ai* GetBotPetAI() const;
+        void SetBotAI(bot_ai* ai) { bot_AI = ai; }
+        void SetBotCommandState(CommandStates st, bool force = false);
+        CommandStates GetBotCommandState() const;
+        void ApplyBotDamageMultiplierMelee(uint32& damage, CalcDamageInfo& damageinfo) const;
+        void ApplyBotDamageMultiplierMelee(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierSpell(int32& damage, SpellNonMeleeDamage& damageinfo, SpellInfo const* spellInfo, WeaponAttackType attackType, bool& crit) const;
+        void ApplyBotDamageMultiplierHeal(Unit const* victim, float& heal, SpellInfo const* spellInfo, DamageEffectType damagetype, uint32 stack) const;
+        void ApplyBotCritMultiplierAll(Unit const* victim, float& crit_chance, SpellInfo const* spellInfo, SpellSchoolMask schoolMask, WeaponAttackType attackType) const;
+        void ApplyCreatureSpellCostMods(SpellInfo const* spellInfo, int32& cost) const;
+        void ApplyCreatureSpellCastTimeMods(SpellInfo const* spellInfo, int32& casttime) const;
+        void SetBotShouldUpdateStats();
+        void OnBotSummon(Creature* summon);
+        void OnBotDespawn(Creature* summon);
+        void SetCanUpdate(bool can) { m_canUpdate = can; }
+        void KillEvents(bool force);
+        void BotStopMovement();
+        void ResetBotAI(uint8 resetType = 0);
+
+        bool CanParry() const;
+        bool CanDodge() const;
+        bool CanBlock() const;
+        bool CanCrit() const;
+        bool CanMiss() const;
+
+        float GetCreatureParryChance() const;
+        float GetCreatureDodgeChance() const;
+        float GetCreatureBlockChance() const;
+        float GetCreatureCritChance() const;
+        float GetCreatureMissChance() const;
+        float GetCreatureEvasion() const;
+        float GetCreatureArmorPenetrationCoef() const;
+        float GetCreatureDamageTakenMod() const;
+        uint32 GetCreatureExpertise() const;
+        uint32 GetCreatureSpellPenetration() const;
+        uint32 GetCreatureSpellPower() const;
+
+        bool IsCreatureImmuneToSpell(SpellInfo const* spellInfo) const;
+        bool IsTempBot() const;
+
+        MeleeHitOutcome BotRollMeleeOutcomeAgainst(Unit const* victim, WeaponAttackType attType) const;
+
+        void CastCreatureItemCombatSpell(Unit* target, WeaponAttackType attType, uint32 procVictim, uint32 procEx, Spell const* spell = NULL);
+
+        void OnSpellGo(Spell const* spell);
+        void AddBotSpellCooldown(uint32 spellId, uint32 cooldown);
+
+        static bool IsBotCustomSpell(uint32 spellId);
+        //advanced
+        bool IsQuestBot() const;
+        //End Bot commands
+
     protected:
         bool CreateFromProto(ObjectGuid::LowType guidlow, uint32 entry, CreatureData const* data = nullptr, uint32 vehId = 0);
         bool InitEntry(uint32 entry, CreatureData const* data = nullptr);
@@ -729,6 +805,13 @@ class Creature : public Unit, public GridObject<Creature>, public MapObject
         bool CanAlwaysSee(WorldObject const* obj) const override;
 
     private:
+        //bot system
+        Creature* m_creature_owner;
+        Creature* m_bots_pet;
+        bot_ai* bot_AI;
+        bool m_canUpdate;
+        //end bot system
+
         void ForcedDespawn(uint32 timeMSToDespawn = 0);
         bool CheckNoGrayAggroConfig(uint32 playerLevel, uint32 creatureLevel) const; // No aggro from gray creatures
 
diff --git a/src/server/game/Entities/Creature/TemporarySummon.cpp b/src/server/game/Entities/Creature/TemporarySummon.cpp
index 4642244..109b374 100644
--- a/src/server/game/Entities/Creature/TemporarySummon.cpp
+++ b/src/server/game/Entities/Creature/TemporarySummon.cpp
@@ -254,6 +254,16 @@ void TempSummon::UnSummon(uint32 msTime)
     if (owner && owner->GetTypeId() == TYPEID_UNIT && owner->ToCreature()->IsAIEnabled)
         owner->ToCreature()->AI()->SummonedCreatureDespawn(this);
 
+    //npcbot
+    if (GetIAmABot() || GetIAmABotsPet())
+    {
+        //TC_LOG_ERROR("entities.player", "TempSummon::UnSummon(): Trying to unsummon Bot %s (guidLow: %u owner: %s)", GetName().c_str(), GetGUID().GetCounter(), GetBotOwner()->GetName().c_str());
+        if (IsTempBot())
+            AI()->JustDied(NULL);
+        return;
+    }
+    //end npcbots
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Object/Object.cpp b/src/server/game/Entities/Object/Object.cpp
index afb987f..612fdcf 100644
--- a/src/server/game/Entities/Object/Object.cpp
+++ b/src/server/game/Entities/Object/Object.cpp
@@ -1032,6 +1032,11 @@ void WorldObject::setActive(bool on)
     if (GetTypeId() == TYPEID_PLAYER)
         return;
 
+    //bot
+    if (on == false && GetTypeId() == TYPEID_UNIT && ToCreature()->IsNPCBot())
+        return;
+    //end bot
+
     m_isActive = on;
 
     if (!IsInWorld())
@@ -1857,6 +1862,11 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
             summon = new Puppet(properties, summoner);
             break;
         case UNIT_MASK_TOTEM:
+            //npcbot: totem emul step 1
+            if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+                summon = new Totem(properties, summoner->ToCreature()->GetBotOwner());
+            else
+            //end npcbot
             summon = new Totem(properties, summoner);
             break;
         case UNIT_MASK_MINION:
@@ -1878,6 +1888,12 @@ TempSummon* Map::SummonCreature(uint32 entry, Position const& pos, SummonPropert
     AddToMap(summon->ToCreature());
     summon->InitSummon();
 
+    //npcbot: totem emul step 2
+    //if (mask == UNIT_MASK_TOTEM)
+        if (summoner && summoner->GetTypeId() == TYPEID_UNIT && summoner->ToCreature()->GetIAmABot())
+            summoner->ToCreature()->OnBotSummon(summon);
+    //end npcbot
+
     //ObjectAccessor::UpdateObjectVisibility(summon);
 
     return summon;
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 7fb2705..cb3bf6b 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -88,7 +88,9 @@
 // 64
 // 65
 // 66
-// 67
+//npcbot
+#include "botmgr.h"
+//end npcbot
 // 68
 // 69
 // 70
@@ -101,7 +103,10 @@
 // 77
 // 78
 // 79
-// 80
+// Playerbot mod:
+#include "../../../plugins/playerbot/playerbot.h"
+#include "../../../plugins/playerbot/GuildTaskMgr.h"
+
 // Visit http://www.realmsofwarcraft.com/bb for forums and information
 //
 // End of prepatch
@@ -562,6 +567,17 @@ inline void KillRewarder::_RewardXP(Player* player, float rate)
         for (Unit::AuraEffectList::const_iterator i = auras.begin(); i != auras.end(); ++i)
             AddPct(xp, (*i)->GetAmount());
 
+        //npcbot 4.2.2.1. Apply NpcBot XP reduction
+        if (player->GetNpcBotsCount() > 1)
+        {
+            if (uint8 xp_reduction = BotMgr::GetNpcBotXpReduction())
+            {
+                uint32 ratePct = std::max<int32>(100 - ((player->GetNpcBotsCount() - 1) * xp_reduction), 10);
+                xp = xp * ratePct / 100;
+            }
+        }
+        //end npcbot
+
         // 4.2.3. Give XP to player.
         player->GiveXP(xp, _victim, _groupRate);
         if (Pet* pet = player->GetPet())
@@ -912,6 +928,10 @@ Player::Player(WorldSession* session): Unit(true)
     m_timeSyncClient = 0;
     m_timeSyncServer = 0;
 
+    /////////////// Bot System //////////////////
+    _botMgr = NULL;
+    ///////////// End Bot System ////////////////
+
     for (uint8 i = 0; i < MAX_POWERS; ++i)
         m_powerFraction[i] = 0;
 
@@ -928,6 +948,10 @@ Player::Player(WorldSession* session): Unit(true)
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    // playerbot mod
+    m_playerbotAI = NULL;
+    m_playerbotMgr = NULL;
 }
 
 Player::~Player()
@@ -966,6 +990,14 @@ Player::~Player()
     delete m_achievementMgr;
     delete m_reputationMgr;
 
+    //npcbot
+    if (_botMgr)
+    {
+        delete _botMgr;
+        _botMgr = NULL;
+    }
+    //end npcbot
+
     sWorld->DecreasePlayerCount();
 }
 
@@ -1931,11 +1963,18 @@ void Player::Update(uint32 p_time)
     // 84
     // 85
     // 86
-    // 87
+    // Playerbot mod
+    if (m_playerbotAI)
+       m_playerbotAI->UpdateAI(p_time);
+    if (m_playerbotMgr)
+       m_playerbotMgr->UpdateAI(p_time);
     // 88
     // 89
     // 90
-    // 91
+    //NpcBot mod: Update
+    if (_botMgr)
+        _botMgr->Update(p_time);
+    //end Npcbot
     // 92
     // 93
     // 94
@@ -2378,6 +2417,11 @@ bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientati
             if (pet)
                 UnsummonPetTemporaryIfAny();
 
+            //bot: teleport npcbots
+            if (HaveBot())
+                _botMgr->OnTeleportFar(mapid, x, y, z, orientation);
+            //end bot
+
             // remove all dyn objects
             RemoveAllDynObjects();
 
@@ -2562,6 +2606,38 @@ void Player::RemoveFromWorld()
     }
 }
 
+//BOT
+bool Player::HaveBot() const
+{
+    return _botMgr && _botMgr->HaveBot();
+}
+
+uint8 Player::GetNpcBotsCount(bool inWorldOnly) const
+{
+    return HaveBot() ? _botMgr->GetNpcBotsCount(inWorldOnly) : 0;
+}
+
+uint8 Player::GetBotFollowDist() const
+{
+    return _botMgr ? _botMgr->GetBotFollowDist() : 30;
+}
+
+void Player::SetBotFollowDist(int8 dist)
+{
+    if (_botMgr) _botMgr->SetBotFollowDist(dist);
+}
+
+void Player::SetBotsShouldUpdateStats()
+{
+    if (HaveBot()) _botMgr->SetBotsShouldUpdateStats();
+}
+
+void Player::RemoveAllBots(uint8 removetype)
+{
+    if (HaveBot()) _botMgr->RemoveAllBots(removetype);
+}
+//END BOT
+
 void Player::RegenerateAll()
 {
     //if (m_regenTimer <= 500)
@@ -2837,6 +2913,11 @@ Creature* Player::GetNPCIfCanInteractWith(ObjectGuid guid, uint32 npcflagmask)
     if (creature->GetCharmerGUID())
         return NULL;
 
+    //npcbot
+    if ((creature->IsQuestBot() || creature->IsNPCBot()) && creature->IsWithinDistInMap(this, INTERACTION_DISTANCE))
+        return creature;
+    //end npcbot
+
     // not unfriendly/hostile
     if (creature->GetReactionTo(this) <= REP_UNFRIENDLY)
         return NULL;
@@ -3043,6 +3124,42 @@ void Player::RemoveFromGroup(Group* group, ObjectGuid guid, RemoveMethod method
     if (!group)
         return;
 
+    if (group)
+    {
+        //npcbot - player is being removed from group - remove bots from that group
+        if (Player* player = ObjectAccessor::FindPlayer(guid))
+        {
+            if (player->HaveBot())
+            {
+                uint8 players = 0;
+                Group::MemberSlotList const& members = group->GetMemberSlots();
+                for (Group::member_citerator itr = members.begin(); itr != members.end(); ++itr)
+                {
+                    if (ObjectAccessor::FindPlayer(itr->guid))
+                        ++players;
+                }
+
+                //remove npcbots and set up new group if needed
+                player->GetBotMgr()->RemoveAllBotsFromGroup(players > 1);
+                group = player->GetGroup();
+                if (!group)
+                    return; //group has been disbanded
+                }
+            }
+        //npcbot - bot is being removed from group - find master and remove bot through botmap
+        /*else if (Creature* bot = ObjectAccessor::GetObjectInOrOutOfWorld(guid, (Creature*)NULL))
+        {
+            Player* master = bot->GetBotOwner();
+            if (master && master->GetTypeId() == TYPEID_PLAYER) //check for free bot just in case
+            {
+                master->GetBotMgr()->RemoveBotFromGroup(bot);
+                group = NULL;
+                return;
+            }
+        }*/
+    }
+    //end npcbot
+
     group->RemoveMember(guid, method, kicker, reason);
 }
 
@@ -4907,6 +5024,14 @@ void Player::DeleteFromDB(ObjectGuid playerguid, uint32 accountId, bool updateRe
 
             Corpse::DeleteFromDB(playerguid, trans);
 
+            //npcbot - erase npcbots
+            stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_NPCBOT_OWNER_ALL);
+            //"UPDATE characters_npcbot SET owner = ? WHERE owner = ?", CONNECTION_ASYNC
+            stmt->setUInt32(0, uint32(0));
+            stmt->setUInt32(1, guid);
+            trans->Append(stmt);
+            //end npcbot
+
             CharacterDatabase.CommitTransaction(trans);
             break;
         }
@@ -7179,6 +7304,10 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         }
         else
         {
+            //npcbot - honor for bots
+            if (!(victim->ToCreature()->GetIAmABot() && victim->ToCreature()->IsFreeBot())) //exclude pets
+            //TODO: honor rate
+            //end npcbot
             if (!victim->ToCreature()->IsRacialLeader())
                 return false;
 
@@ -15447,7 +15576,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     if (quest->GetRewSpellCast() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpellCast());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpellCast(), true);
@@ -15458,7 +15587,7 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     else if (quest->GetRewSpell() > 0)
     {
         SpellInfo const* spellInfo = sSpellMgr->GetSpellInfo(quest->GetRewSpell());
-        if (questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
+        if (spellInfo && questGiver->isType(TYPEMASK_UNIT) && !spellInfo->HasEffect(SPELL_EFFECT_LEARN_SPELL) && !spellInfo->HasEffect(SPELL_EFFECT_CREATE_ITEM))
         {
             if (Creature* creature = GetMap()->GetCreature(questGiver->GetGUID()))
                 creature->CastSpell(this, quest->GetRewSpell(), true);
@@ -23803,6 +23932,9 @@ bool Player::GetsRecruitAFriendBonus(bool forXP)
 void Player::RewardPlayerAndGroupAtKill(Unit* victim, bool isBattleGround)
 {
     KillRewarder(this, victim, isBattleGround).Reward();
+    // playerbot mod
+    sGuildTaskMgr.CheckKillTask(this, victim);
+    // end of playerbot mod
 }
 
 void Player::RewardPlayerAndGroupAtEvent(uint32 creature_id, WorldObject* pRewardSource)
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index ad29637..ea1f922 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -56,6 +56,14 @@ class UpdateMask;
 
 struct CharacterCustomizeInfo;
 
+// Playerbot mod
+class PlayerbotAI;
+class PlayerbotMgr;
+
+// NpcBot mod
+class BotMgr;
+// end NpcBot mod
+
 typedef std::deque<Mail*> PlayerMails;
 
 #define PLAYER_MAX_SKILLS           127
@@ -2301,6 +2309,18 @@ class Player : public Unit, public GridObject<Player>
 
         bool CanFly() const override { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
+        // Playerbot mod:
+        // A Player can either have a playerbotMgr (to manage its bots), or have playerbotAI (if it is a bot), or
+        // neither. Code that enables bots must create the playerbotMgr and set it using SetPlayerbotMgr.
+        EquipmentSets& GetEquipmentSets() { return m_EquipmentSets; }
+        void SetPlayerbotAI(PlayerbotAI* ai) { m_playerbotAI=ai; }
+        PlayerbotAI* GetPlayerbotAI() { return m_playerbotAI; }
+        void SetPlayerbotMgr(PlayerbotMgr* mgr) { m_playerbotMgr=mgr; }
+        PlayerbotMgr* GetPlayerbotMgr() { return m_playerbotMgr; }
+        void SetBotDeathTimer() { m_deathTimer = 0; }
+        PlayerTalentMap& GetTalentMap(uint8 spec) { return *m_talents[spec]; }
+        bool MinimalLoadFromDB( QueryResult result, uint32 guid );
+
         //! Return collision height sent to client
         float GetCollisionHeight(bool mounted) const;
 
@@ -2317,7 +2337,20 @@ class Player : public Unit, public GridObject<Player>
     // 08
     // 09
     // 10
-    // 11
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        void SetBotMgr(BotMgr* mgr) { ASSERT(!_botMgr); _botMgr = mgr; }
+        BotMgr* GetBotMgr() const { return _botMgr; }
+        bool HaveBot() const;
+        uint8 GetNpcBotsCount(bool inWorldOnly = false) const;
+        uint8 GetBotFollowDist() const;
+        void SetBotFollowDist(int8 dist);
+        void SetBotsShouldUpdateStats();
+        void RemoveAllBots(uint8 removetype = 0);
+        /*********************************************************/
+        /***                 END BOT SYSTEM                    ***/
+        /*********************************************************/
     // 12
     // 13
     // 14
@@ -2585,6 +2618,14 @@ class Player : public Unit, public GridObject<Player>
         bool m_needsZoneUpdate;
 
     private:
+        /*********************************************************/
+        /***                     BOT SYSTEM                    ***/
+        /*********************************************************/
+        BotMgr* _botMgr;
+        /*********************************************************/
+        /***                END BOT SYSTEM                     ***/
+        /*********************************************************/
+
         // internal common parts for CanStore/StoreItem functions
         InventoryResult CanStoreItem_InSpecificSlot(uint8 bag, uint8 slot, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool swap, Item* pSrcItem) const;
         InventoryResult CanStoreItem_InBag(uint8 bag, ItemPosCountVec& dest, ItemTemplate const* pProto, uint32& count, bool merge, bool non_specialized, Item* pSrcItem, uint8 skip_bag, uint8 skip_slot) const;
@@ -2674,7 +2715,9 @@ class Player : public Unit, public GridObject<Player>
         // 37
         // 38
         // 39
-        // 40
+        // Playerbot mod:
+        PlayerbotAI* m_playerbotAI;
+        PlayerbotMgr* m_playerbotMgr;
         // Visit http://www.realmsofwarcraft.com/bb for forums and information
         //
         // End of prepatch
diff --git a/src/server/game/Entities/Totem/Totem.cpp b/src/server/game/Entities/Totem/Totem.cpp
index 85ee51a..f54793a 100644
--- a/src/server/game/Entities/Totem/Totem.cpp
+++ b/src/server/game/Entities/Totem/Totem.cpp
@@ -142,6 +142,13 @@ void Totem::UnSummon(uint32 msTime)
         }
     }
 
+    //npcbot: send SummonedCreatureDespawn()
+    if (GetCreatorGUID().IsCreature())
+        if (Unit* bot = ObjectAccessor::FindConnectedPlayer(GetCreatorGUID()))
+            if (bot->ToCreature()->GetIAmABot())
+                bot->ToCreature()->OnBotDespawn(this);
+    //end npcbot
+
     AddObjectToRemoveList();
 }
 
diff --git a/src/server/game/Entities/Unit/StatSystem.cpp b/src/server/game/Entities/Unit/StatSystem.cpp
index fb27fea..e601a12 100644
--- a/src/server/game/Entities/Unit/StatSystem.cpp
+++ b/src/server/game/Entities/Unit/StatSystem.cpp
@@ -216,6 +216,10 @@ bool Player::UpdateAllStats()
     RecalculateRating(CR_ARMOR_PENETRATION);
     UpdateAllResistances();
 
+    //npcbot - Player::UpdateAllStats() is called on level change - update bots
+    SetBotsShouldUpdateStats();
+    //end npcbot
+
     return true;
 }
 
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index 6b234df..a908cca 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -255,6 +255,13 @@ Unit::Unit(bool isWorldObject) :
 
     _oldFactionId = 0;
     _isWalkingBeforeCharm = false;
+
+    //npcbot
+    _damageInfo.target = NULL;
+    _delayedTargetGuid.Clear();
+    _swingDelayTimer = 0;
+    _swingLanded = true;
+    //end npcbot
 }
 
 ////////////////////////////////////////////////////////////
@@ -345,6 +352,29 @@ void Unit::Update(uint32 p_time)
         }
     }
 
+    //npcbot: update combat timer also for npcbots
+    if (IsInCombat() && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI()/* && (!GetVictim() || ToCreature()->IsFreeBot())*/)
+    {
+        if (m_HostileRefManager.isEmpty())
+        {
+            if (m_CombatTimer <= p_time)
+                ClearInCombat();
+            else
+                m_CombatTimer -= p_time;
+        }
+    }
+    //npcbot:
+    if (_delayedTargetGuid)
+    {
+        if (_swingLanded)
+            _delayedTargetGuid.Clear();
+        else if (_swingDelayTimer >= p_time)
+            _swingDelayTimer -= p_time;
+        else
+            ExecuteDelayedSwingHit();
+    }
+    //end npcbot
+
     // not implemented before 3.0.2
     if (uint32 base_att = getAttackTimer(BASE_ATTACK))
         setAttackTimer(BASE_ATTACK, (p_time >= base_att ? 0 : base_att - p_time));
@@ -581,6 +611,13 @@ uint32 Unit::DealDamage(Unit* victim, uint32 damage, CleanDamage const* cleanDam
         if (pet && pet->IsAlive())
             pet->AI()->OwnerAttackedBy(this);
 
+        // NpcBot mod: also signal owned npcbots
+        for (ControlList::const_iterator itr = victim->ToPlayer()->m_Controlled.begin(); itr != victim->ToPlayer()->m_Controlled.end(); ++itr)
+            if (Creature* cre = (*itr)->ToCreature())
+                if (cre->IsAIEnabled)
+                    cre->AI()->OwnerAttackedBy(this);
+        // End NpcBot
+
         if (victim->ToPlayer()->GetCommandStatus(CHEAT_GOD))
             return 0;
     }
@@ -845,6 +882,14 @@ void Unit::CastSpell(SpellCastTargets const& targets, SpellInfo const* spellInfo
         return;
     }
 
+    //npcbot
+    if (Creature::IsBotCustomSpell(spellInfo->Id) && !(ToCreature() && ToCreature()->GetBotAI()))
+    {
+        TC_LOG_ERROR("entities.unit", "CastSpell: NpcBot system custom spell %u by caster: %s %u), aborted. Please report", spellInfo->Id, (GetTypeId() == TYPEID_PLAYER ? "player (GUID:" : "creature (Entry:"), (GetTypeId() == TYPEID_PLAYER ? GetGUID().GetCounter() : GetEntry()));
+        return;
+    }
+    //end npcbot
+
     /// @todo this is a workaround - not needed anymore, but required for some scripts :(
     if (!originalCaster && triggeredByAura)
         originalCaster = triggeredByAura->GetCasterGUID();
@@ -999,6 +1044,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_RANGED:
             case SPELL_DAMAGE_CLASS_MELEE:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // Physical Damage
                 if (damageSchoolMask & SPELL_SCHOOL_MASK_NORMAL)
                 {
@@ -1056,6 +1107,12 @@ void Unit::CalculateSpellDamageTaken(SpellNonMeleeDamage* damageInfo, int32 dama
             case SPELL_DAMAGE_CLASS_NONE:
             case SPELL_DAMAGE_CLASS_MAGIC:
             {
+                //Npcbot mod: apply bot damage mods
+                if (Creature* bot = ToCreature())
+                    if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+                        bot->ApplyBotDamageMultiplierSpell(damage, *damageInfo, spellInfo, attackType, crit);
+                // End NpcBot
+
                 // If crit add critical bonus
                 if (crit)
                 {
@@ -1182,8 +1239,19 @@ void Unit::CalculateMeleeDamage(Unit* victim, uint32 damage, CalcDamageInfo* dam
     else
         damageInfo->damage = damage;
 
+    //NpcBot mod: check custom melee outcome
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        damageInfo->hitOutCome = ToCreature()->BotRollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
+    else
+    //End NpcBot
     damageInfo->hitOutCome = RollMeleeOutcomeAgainst(damageInfo->target, damageInfo->attackType);
 
+    //NpcBot mod: apply bot damage mods
+    if (Creature* bot = ToCreature())
+        if (bot->GetIAmABot() || bot->GetIAmABotsPet())
+            bot->ApplyBotDamageMultiplierMelee(damage, *damageInfo);
+    //End NpcBot
+
     switch (damageInfo->hitOutCome)
     {
         case MELEE_HIT_EVADE:
@@ -1332,6 +1400,9 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
         victim->HandleEmoteCommand(EMOTE_ONESHOT_PARRY_SHIELD);
 
     if (damageInfo->TargetState == VICTIMSTATE_PARRY)
+    //npcbot - implement CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN (TC sup)
+    if (!(GetTypeId() == TYPEID_UNIT && ToCreature()->GetCreatureTemplate()->flags_extra & CREATURE_FLAG_EXTRA_NO_PARRY_HASTEN))
+    //end npcbot
     {
         // Get attack timers
         float offtime  = float(victim->getAttackTimer(OFF_ATTACK));
@@ -1397,6 +1468,10 @@ void Unit::DealMeleeDamage(CalcDamageInfo* damageInfo, bool durabilityLoss)
 
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->CastItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //npcbot - CastItemCombatSpell for bots
+    else if (ToCreature()->GetBotAI())
+        ToCreature()->CastCreatureItemCombatSpell(victim, damageInfo->attackType, damageInfo->procVictim, damageInfo->procEx);
+    //end npcbot
 
     // Do effect if any damage done to target
     if (damageInfo->damage)
@@ -1543,6 +1618,11 @@ uint32 Unit::CalcArmorReducedDamage(Unit* victim, const uint32 damage, SpellInfo
     if (armor < 0.0f)
         armor = 0.0f;
 
+    //npcbot custom armor penetration modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        armor *= std::max<float>(1.0f - ToCreature()->GetCreatureArmorPenetrationCoef(), 0.0f);
+    //end npcbot
+
     float levelModifier = getLevel();
     if (levelModifier > 59)
         levelModifier = levelModifier + 4.5f * (levelModifier - 59);
@@ -1583,6 +1663,10 @@ uint32 Unit::CalcSpellResistance(Unit* victim, SpellSchoolMask schoolMask, Spell
 
     if (Player const* player = ToPlayer())
         baseVictimResistance -= player->GetSpellPenetrationItemMod();
+    //npcbot - spell penetration for bots
+    else if (ToCreature()->GetBotAI())
+        baseVictimResistance -= ToCreature()->GetCreatureSpellPenetration();
+    //end npcbot
 
     // Resistance can't be lower then 0
     int32 victimResistance = std::max<int32>(baseVictimResistance, 0);
@@ -1939,6 +2023,38 @@ void Unit::CalcHealAbsorb(Unit* victim, SpellInfo const* healSpell, uint32 &heal
     healAmount = RemainingHeal;
 }
 
+//NpcBot mod
+void Unit::ExecuteDelayedSwingHit(bool extra)
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    if (!extra)
+        _damageInfo.target = ObjectAccessor::FindConnectedPlayer(_delayedTargetGuid);
+
+    if (!_damageInfo.target)
+        return;
+
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::ExecuteDelayedSwingHit() call for %s, victim = %s", GetName().c_str(), _damageInfo.target->GetName().c_str());
+
+    //TriggerAurasProcOnEvent(*_damageInfo);
+    DealMeleeDamage(&_damageInfo, true);
+
+    // Recursion warning here
+    ProcDamageAndSpell(_damageInfo.target, _damageInfo.procAttacker, _damageInfo.procVictim, _damageInfo.procEx, _damageInfo.damage, _damageInfo.attackType);
+}
+//NpcBot mod
+void Unit::SuspendDelayedSwing()
+{
+    if (_swingLanded)
+        return;
+
+    _swingLanded = true;
+    //TC_LOG_DEBUG(LOG_FILTER_UNITS, "Unit::SuspendDelayedSwing() call for %s, victim = %s", GetName().c_str(), _damageInfo.target ? _damageInfo.target->GetName().c_str() : "_removed_");
+}
+//End NpcBot mod
+
 void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool extra)
 {
     if (HasUnitState(UNIT_STATE_CANNOT_AUTOATTACK) || HasFlag(UNIT_FIELD_FLAGS, UNIT_FLAG_PACIFIED))
@@ -1950,6 +2066,48 @@ void Unit::AttackerStateUpdate (Unit* victim, WeaponAttackType attType, bool ext
     if ((attType == BASE_ATTACK || attType == OFF_ATTACK) && !IsWithinLOSInMap(victim))
         return;
 
+    //npcbot
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+    {
+        // if attack is executed before previous swing finished, finish it forcefully
+        ExecuteDelayedSwingHit();
+
+        CombatStart(victim);
+        RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
+
+        if (attType != BASE_ATTACK && attType != OFF_ATTACK)
+            return;                                             // ignore ranged case
+
+        // melee attack spell casted at main hand attack only - no normal melee dmg dealt
+        if (attType == BASE_ATTACK && m_currentSpells[CURRENT_MELEE_SPELL] && !extra)
+            m_currentSpells[CURRENT_MELEE_SPELL]->cast();
+        else
+        {
+            // attack can be redirected to another target
+            victim = GetMeleeHitRedirectTarget(victim);
+            CalculateMeleeDamage(victim, 0, &_damageInfo, attType);
+            DealDamageMods(victim, _damageInfo.damage, &_damageInfo.absorb);
+
+            // Send log damage message to client
+            SendAttackStateUpdate(&_damageInfo);
+
+            // If this swing is extra attack, execute it right now
+            // Else delay melee hit by melee swing animation time
+            _swingLanded = false;
+            _delayedTargetGuid = victim->GetGUID();
+            if (m_extraAttacks)
+                ExecuteDelayedSwingHit(true);
+            else
+                _swingDelayTimer = 450;
+
+            //TC_LOG_DEBUG("entities.unit", "AttackerStateUpdateBot: (NPCBot)    %u attacked %u (TypeId: %u) for %u dmg, absorbed %u, blocked %u, resisted %u.",
+            //    GetGUID().GetCounter(), victim->GetGUID().GetCounter(), victim->GetTypeId(), _damageInfo.damage, _damageInfo.absorb, _damageInfo.blocked_amount, _damageInfo.resist);
+        }
+
+        return;
+    }
+    //end npcbot
+
     CombatStart(victim);
     RemoveAurasWithInterruptFlags(AURA_INTERRUPT_FLAG_MELEE_ATTACK);
 
@@ -2057,11 +2215,24 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
     {
         TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a player.");
     }
+    //npcbot - bots cannot dodge if attacker is behind
+    else if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI() && !victim->HasInArc(M_PI, this) && !victim->HasAuraType(SPELL_AURA_IGNORE_HIT_DIRECTION))
+    {
+        //TC_LOG_DEBUG("entities.unit", "RollMeleeOutcomeAgainst: attack came from behind and victim was a bot.");
+    }
+    //end npcbot
     else
     {
         // Reduce dodge chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             dodge_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            dodge_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             dodge_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2089,6 +2260,13 @@ MeleeHitOutcome Unit::RollMeleeOutcomeAgainst (const Unit* victim, WeaponAttackT
         // Reduce parry chance by attacker expertise rating
         if (GetTypeId() == TYPEID_PLAYER)
             parry_chance -= int32(ToPlayer()->GetExpertiseDodgeOrParryReduction(attType) * 100);
+        //npcbot - manual expertise instead of auras
+        else if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        {
+            parry_chance -= ToCreature()->GetCreatureExpertise() * 25;
+            parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
+        }
+        //end npcbot
         else
             parry_chance -= GetTotalAuraModifier(SPELL_AURA_MOD_EXPERTISE) * 25;
 
@@ -2710,6 +2888,14 @@ float Unit::GetUnitDodgeChance() const
         else
         {
             float dodge = 5.0f;
+            //npcbot - custom dodge chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanDodge())
+                    return 0.0f;
+                dodge = ToCreature()->GetCreatureDodgeChance();
+            }
+            //end npcbot
             dodge += GetTotalAuraModifier(SPELL_AURA_MOD_DODGE_PERCENT);
             return dodge > 0.0f ? dodge : 0.0f;
         }
@@ -2739,6 +2925,15 @@ float Unit::GetUnitParryChance() const
     {
         if (GetCreatureType() == CREATURE_TYPE_HUMANOID)
         {
+            //npcbot - custom parry chance instead of bunch of auras
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanParry())
+                    return 0.0f;
+                chance = ToCreature()->GetCreatureParryChance();
+            }
+            else
+            //end npcbot
             chance = 5.0f;
             chance += GetTotalAuraModifier(SPELL_AURA_MOD_PARRY_PERCENT);
         }
@@ -2785,6 +2980,14 @@ float Unit::GetUnitBlockChance() const
         else
         {
             float block = 5.0f;
+            //npcbot - custom block chance instead of bunch of auras and remove base chance
+            if (ToCreature()->GetBotAI())
+            {
+                if (!ToCreature()->CanBlock())
+                    return 0.0f;
+                block = ToCreature()->GetCreatureBlockChance();
+            }
+            //end npcbot
             block += GetTotalAuraModifier(SPELL_AURA_MOD_BLOCK_PERCENT);
             return block > 0.0f ? block : 0.0f;
         }
@@ -2816,6 +3019,15 @@ float Unit::GetUnitCriticalChance(WeaponAttackType attackType, const Unit* victi
     }
     else
     {
+        //npcbot - custom crit chance instead of bunch of auras and remove base chance
+        if (ToCreature()->GetBotAI())
+        {
+            if (!ToCreature()->CanCrit())
+                return 0.0f;
+            crit = 5.0f + ToCreature()->GetCreatureCritChance();
+        }
+        else
+        //end npcbot
         crit = 5.0f;
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_WEAPON_CRIT_PERCENT);
         crit += GetTotalAuraModifier(SPELL_AURA_MOD_CRIT_PCT);
@@ -6092,6 +6304,12 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                     // Check cooldown of heal spell cooldown
                     if (!GetSpellHistory()->HasCooldown(34299))
                         CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+
+                    //npcbot - proc for bot
+                    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && !ToCreature()->GetSpellHistory()->HasCooldown(34299))
+                        CastCustomSpell(this, 68285, &basepoints1, 0, 0, true, 0, triggeredByAura);
+                    //end npcbot
+
                     break;
                 }
                 // Healing Touch (Dreamwalker Raiment set)
@@ -6222,6 +6440,31 @@ bool Unit::HandleDummyAuraProc(Unit* victim, uint32 damage, AuraEffect* triggere
                 triggered_spell_id = isWrathSpell ? 48518 : 48517;
                 break;
             }
+
+            //npcbot - Eclipse for bot
+            if (dummySpell->SpellIconID == 2856 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+            {
+                if (!procSpell || effIndex != 0)
+                    return false;
+
+                bool isWrathSpell = (procSpell->SpellFamilyFlags[0] & 1);
+
+                if (!roll_chance_f(dummySpell->ProcChance * (isWrathSpell ? 0.6f : 1.0f)))
+                    return false;
+
+                target = this;
+                if (target->HasAura(isWrathSpell ? 48517 : 48518))
+                    return false;
+
+                triggered_spell_id = isWrathSpell ? 48518 : 48517;
+
+                if (ToCreature()->GetSpellHistory()->HasCooldown(triggered_spell_id))
+                    return false;
+
+                break;
+            }
+            //end npcbot
+
             break;
         }
         case SPELLFAMILY_ROGUE:
@@ -9001,6 +9244,9 @@ bool Unit::Attack(Unit* victim, bool meleeAttack)
     //    ToCreature()->SetCombatStartPosition(GetPositionX(), GetPositionY(), GetPositionZ());
 
     if (GetTypeId() == TYPEID_UNIT && !IsPet())
+    //npcbot - not for npcbots either
+    if (!ToCreature()->GetBotAI())
+    //end npcbot
     {
         // should not let player enter combat by right clicking target - doesn't helps
         SetInCombatWith(victim);
@@ -9072,6 +9318,9 @@ void Unit::CombatStop(bool includingCast)
         InterruptNonMeleeSpells(false);
 
     AttackStop();
+    //npcbot
+    SuspendDelayedSwing();
+    //end npcbot
     RemoveAllAttackers();
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->SendAttackSwingCancelAttack();     // melee and ranged forced attack cancel
@@ -9109,6 +9358,9 @@ void Unit::RemoveAllAttackers()
     while (!m_attackers.empty())
     {
         AttackerSet::iterator iter = m_attackers.begin();
+        //npcbot
+        (*iter)->SuspendDelayedSwing();
+        //end npcbot
         if (!(*iter)->AttackStop())
         {
             TC_LOG_ERROR("entities.unit", "WORLD: Unit has an attacker that isn't attacking it!");
@@ -9699,12 +9951,25 @@ void Unit::RemoveAllControlled()
     if (GetTypeId() == TYPEID_PLAYER)
         ToPlayer()->StopCastingCharm();
 
+    //npcbot - store bots for recontroll; bots are to be removed manually
+    std::list<Unit*> nBots;
+    for (Unit::ControlList::iterator itr = m_Controlled.begin(); itr != m_Controlled.end(); ++itr)
+        if ((*itr)->GetTypeId() == TYPEID_UNIT && (*itr)->ToCreature()->GetBotAI())
+            nBots.push_back(*itr);
+    //end npcbot
+
     while (!m_Controlled.empty())
     {
         Unit* target = *m_Controlled.begin();
         m_Controlled.erase(m_Controlled.begin());
         if (target->GetCharmerGUID() == GetGUID())
             target->RemoveCharmAuras();
+        //npcbot - debug info
+        else if (target->GetTypeId() == TYPEID_UNIT && target->ToCreature()->GetBotAI())
+        {
+            //TC_LOG_ERROR("entities.unit", "RemoveAllControlled(): Unit %u removing bot %s (%u)", GetGUID().GetCounter(), target->GetName().c_str(), target->GetEntry());
+        }
+        //end npcbot
         else if (target->GetOwnerGUID() == GetGUID() && target->IsSummon())
             target->ToTempSummon()->UnSummon();
         else
@@ -9716,6 +9981,14 @@ void Unit::RemoveAllControlled()
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its minion %s", GetEntry(), GetMinionGUID().ToString().c_str());
     if (GetCharmGUID())
         TC_LOG_FATAL("entities.unit", "Unit %u is not able to release its charm %s", GetEntry(), GetCharmGUID().ToString().c_str());
+
+    //npcbot - restore controlled bots
+    if (nBots.empty())
+        return;
+
+    for (std::list<Unit*>::const_iterator itr = nBots.begin(); itr != nBots.end(); ++itr)
+        m_Controlled.insert(*itr);
+    //end npcbot
 }
 
 bool Unit::isPossessedByPlayer() const
@@ -10338,6 +10611,11 @@ uint32 Unit::SpellDamageBonusTaken(Unit* caster, SpellInfo const* spellProto, ui
                 AddPct(TakenTotalMod, (*i)->GetAmount());
     }
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     //.. taken pct: dummy auras
     AuraEffectList const& mDummyAuras = GetAuraEffectsByType(SPELL_AURA_DUMMY);
     for (AuraEffectList::const_iterator i = mDummyAuras.begin(); i != mDummyAuras.end(); ++i)
@@ -10428,6 +10706,11 @@ int32 Unit::SpellBaseDamageBonusDone(SpellSchoolMask schoolMask) const
 {
     int32 DoneAdvertisedBenefit = 0;
 
+    //npcbot: apply bot spellpower
+    if (schoolMask && !(schoolMask & SPELL_SCHOOL_MASK_NORMAL) && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        DoneAdvertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     AuraEffectList const& mDamageDone = GetAuraEffectsByType(SPELL_AURA_MOD_DAMAGE_DONE);
     for (AuraEffectList::const_iterator i = mDamageDone.begin(); i != mDamageDone.end(); ++i)
         if (((*i)->GetMiscValue() & schoolMask) != 0 &&
@@ -10485,6 +10768,9 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     //! Mobs can't crit with spells. Player Totems can
     //! Fire Elemental (from totem) can too - but this part is a hack and needs more research
     if (GetGUID().IsCreatureOrVehicle() && !(IsTotem() && GetOwnerGUID().IsPlayer()) && GetEntry() != 15438)
+        //npcbot - allow bots to crit
+        if (!ToCreature()->GetBotAI())
+        //end npcbot
         return 0.0f;
 
     // not critting spell
@@ -10676,6 +10962,11 @@ float Unit::GetUnitSpellCriticalChance(Unit* victim, SpellInfo const* spellProto
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, SPELLMOD_CRITICAL_CHANCE, crit_chance);
 
+    //npcbot - apply bot spell crit mods
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotCritMultiplierAll(victim, crit_chance, spellProto, schoolMask, attackType);
+    //end npcbot
+
     return crit_chance > 0.0f ? crit_chance : 0.0f;
 }
 
@@ -10854,6 +11145,11 @@ uint32 Unit::SpellHealingBonusDone(Unit* victim, SpellInfo const* spellProto, ui
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellProto->Id, damagetype == DOT ? SPELLMOD_DOT : SPELLMOD_DAMAGE, heal);
 
+    //npcbot - healing bonus done for bots
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyBotDamageMultiplierHeal(victim, heal, spellProto, damagetype, stack);
+    //end npcbot
+
     return uint32(std::max(heal, 0.0f));
 }
 
@@ -11042,6 +11338,11 @@ int32 Unit::SpellBaseHealingBonusDone(SpellSchoolMask schoolMask) const
         if (!(*i)->GetMiscValue() || ((*i)->GetMiscValue() & schoolMask) != 0)
             advertisedBenefit += (*i)->GetAmount();
 
+    //npcbot: apply bot spellpower to healing
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        advertisedBenefit += ToCreature()->GetCreatureSpellPower();
+    //end npcbot
+
     // Healing bonus of spirit, intellect and strength
     if (GetTypeId() == TYPEID_PLAYER)
     {
@@ -11133,6 +11434,11 @@ bool Unit::IsImmunedToSpell(SpellInfo const* spellInfo) const
     if (spellInfo->HasAttribute(SPELL_ATTR0_UNAFFECTED_BY_INVULNERABILITY))
         return false;
 
+    //npcbot - check 'magic immunity' state and other
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && ToCreature()->IsCreatureImmuneToSpell(spellInfo))
+        return true;
+    //end npcbot
+
     if (spellInfo->Dispel)
     {
         SpellImmuneList const& dispelList = m_spellImmune[IMMUNITY_DISPEL];
@@ -11454,6 +11760,11 @@ uint32 Unit::MeleeDamageBonusTaken(Unit* attacker, uint32 pdamage, WeaponAttackT
     // ..taken
     TakenTotalMod *= GetTotalAuraMultiplierByMiscMask(SPELL_AURA_MOD_DAMAGE_PERCENT_TAKEN, attacker->GetMeleeDamageSchoolMask());
 
+    //npcbot - damage taken modifier
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        TakenTotalMod *= ToCreature()->GetCreatureDamageTakenMod();
+    //end npcbot
+
     // .. taken pct (special attacks)
     if (spellProto)
     {
@@ -11795,6 +12106,12 @@ void Unit::SetInCombatState(bool PvP, Unit* enemy)
     if (PvP)
         m_CombatTimer = 5000;
 
+    ////npcbot - if combat with npcbot or its pet set extended timer
+    //if (PvP &&((GetTypeId() == TYPEID_UNIT && ToCreature()->IsFreeBot()) ||
+    //    (enemy->GetTypeId() == TYPEID_UNIT && enemy->ToCreature()->IsFreeBot())))
+    //    m_CombatTimer += 5000;
+    ////end npcbot
+
     if (IsInCombat() || HasUnitState(UNIT_STATE_EVADE))
         return;
 
@@ -12224,6 +12541,12 @@ bool Unit::IsAlwaysVisibleFor(WorldObject const* seer) const
                 if (ownerPlayer->IsGroupVisibleFor(seerPlayer))
                     return true;
 
+    //npcbot - bots are always visible for owner
+    if (Creature const* bot = ToCreature())
+        if (bot->GetBotAI() && seer->GetGUID() == bot->GetBotOwner()->GetGUID())
+            return true;
+    //end npcbot
+
     return false;
 }
 
@@ -12597,6 +12920,11 @@ bool Unit::CanHaveThreatList(bool skipAliveCheck) const
     if (HasUnitTypeMask(UNIT_MASK_MINION | UNIT_MASK_GUARDIAN | UNIT_MASK_CONTROLABLE_GUARDIAN) && ((Pet*)this)->GetOwnerGUID().IsPlayer())
         return false;
 
+    //npcbot - npcbots and their pets cannot have threatlist
+    if (ToCreature()->GetBotAI())
+        return false;
+    //end npcbot
+
     return true;
 }
 
@@ -12993,6 +13321,10 @@ void Unit::ModSpellCastTime(SpellInfo const* spellInfo, int32 & castTime, Spell*
     // called from caster
     if (Player* modOwner = GetSpellModOwner())
         modOwner->ApplySpellMod(spellInfo->Id, SPELLMOD_CASTING_TIME, castTime, spell);
+    //npcbot - apply bot spell cast time mods
+    if (castTime > 0 && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        ToCreature()->ApplyCreatureSpellCastTimeMods(spellInfo, castTime);
+    //end npcbot
 
     if (!(spellInfo->HasAttribute(SPELL_ATTR0_ABILITY) || spellInfo->HasAttribute(SPELL_ATTR0_TRADESPELL) || spellInfo->HasAttribute(SPELL_ATTR3_NO_DONE_BONUS)) &&
         ((GetTypeId() == TYPEID_PLAYER && spellInfo->SpellFamilyName) || GetTypeId() == TYPEID_UNIT))
@@ -14146,6 +14478,13 @@ void Unit::ProcDamageAndSpellFor(bool isVictim, Unit* target, uint32 procFlag, u
                     ToPlayer()->AddComboPoints(target, 1);
                     StartReactiveTimer(REACTIVE_OVERPOWER);
                 }
+
+                //npcbot - update reactives for bots
+                if ((procExtra & (PROC_EX_DODGE | PROC_EX_PARRY)) && GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI() && ToCreature()->GetBotClass() == CLASS_WARRIOR)
+                {
+                    StartReactiveTimer(REACTIVE_OVERPOWER);
+                }
+                //end npcbot
             }
         }
     }
@@ -14703,6 +15042,29 @@ void Unit::ClearComboPointHolders()
     }
 }
 
+//npcbot
+void Unit::ClearReactive(ReactiveType reactive)
+{
+    m_reactiveTimer[reactive] = 0;
+
+    switch (reactive)
+    {
+        case REACTIVE_DEFENSE:
+            if (HasAuraState(AURA_STATE_DEFENSE))
+                ModifyAuraState(AURA_STATE_DEFENSE, false);
+            break;
+        case REACTIVE_HUNTER_PARRY:
+            if (getClass() == CLASS_HUNTER && HasAuraState(AURA_STATE_HUNTER_PARRY))
+                ModifyAuraState(AURA_STATE_HUNTER_PARRY, false);
+            break;
+        case REACTIVE_OVERPOWER:
+            if (getClass() == CLASS_WARRIOR && GetTypeId() == TYPEID_PLAYER)
+                ToPlayer()->ClearComboPoints();
+            break;
+    }
+}
+//end npcbot
+
 void Unit::ClearAllReactives()
 {
     for (uint8 i = 0; i < MAX_REACTIVE; ++i)
@@ -14811,6 +15173,9 @@ uint32 Unit::GetCastingTimeForBonus(SpellInfo const* spellProto, DamageEffectTyp
 {
     // Not apply this to creature cast spells with casttime == 0
     if (CastingTime == 0 && GetTypeId() == TYPEID_UNIT && !IsPet())
+        //npcbot - skip bots
+        if (!ToCreature()->GetBotAI())
+        //endnpcbot
         return 3500;
 
     if (CastingTime > 7000) CastingTime = 7000;
@@ -15454,6 +15819,9 @@ void Unit::Kill(Unit* victim, bool durabilityLoss)
 
         // only if not player and not controlled by player pet. And not at BG
         if ((durabilityLoss && !player && !victim->ToPlayer()->InBattleground()) || (player && sWorld->getBoolConfig(CONFIG_DURABILITY_LOSS_IN_PVP)))
+        //npcbot - bots should not cause durability loss unless rampaging around
+        if (player || !ToCreature()->GetBotAI() || ToCreature()->GetBotOwner()->GetGUID().GetCounter() == GetGUID().GetCounter())
+        //end npcbot
         {
             TC_LOG_DEBUG("entities.unit", "We are dead, losing %f percent durability", sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH));
             plrVictim->DurabilityLossAll(sWorld->getRate(RATE_DURABILITY_LOSS_ON_DEATH), false);
@@ -16393,6 +16761,21 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     //calculate miss chance
     float missChance = victim->GetUnitMissChance(attType);
 
+    //npcbot - custom miss chance instead of bunch of auras, extra miss chance against bots
+    //bot can have extra miss chance for attackers
+    //but if attacker is also a bot and cannot miss then return this extra miss chance
+    float evasion = 0.0f;
+
+    if (victim->GetTypeId() == TYPEID_UNIT && victim->ToCreature()->GetBotAI())
+        evasion = victim->ToCreature()->GetCreatureEvasion();
+    if (GetTypeId() == TYPEID_UNIT && !ToCreature()->CanMiss())
+        return evasion;
+    if (GetTypeId() == TYPEID_UNIT && ToCreature()->GetBotAI())
+        missChance += ToCreature()->GetCreatureMissChance();
+
+    missChance += evasion;
+    //end npcbot
+
     if (!spellId && haveOffhandWeapon())
         missChance += 19;
 
@@ -16421,6 +16804,11 @@ float Unit::MeleeSpellMissChance(const Unit* victim, WeaponAttackType attType, i
     else
         missChance -= m_modMeleeHitChance;
 
+    //npcbot - limit chance from 30% to 60% if evasion is here
+    if (evasion > 0.0f && missChance < evasion)
+        missChance = evasion;
+    //end npcbot
+
     // Limit miss chance from 0 to 60%
     if (missChance < 0.0f)
         return 0.0f;
@@ -16737,6 +17125,183 @@ uint32 Unit::GetModelForForm(ShapeshiftForm form) const
         }
     }
 
+    else if (ToCreature() && ToCreature()->GetBotOwner() && ToCreature()->GetBotOwner()->ToPlayer())
+    {
+        Player const* player = ToCreature()->GetBotOwner();
+        //let's make druids alike for each player
+        switch (form)
+        {
+        case FORM_CAT:
+            // Based on master's Hair color
+            if (player->getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                case 7: // Violet
+                case 8:
+                    return 29405;
+                case 3: // Light Blue
+                    return 29406;
+                case 0: // Green
+                case 1: // Light Green
+                case 2: // Dark Green
+                    return 29407;
+                case 4: // White
+                    return 29408;
+                default: // original - Dark Blue
+                    return 892;
+                }
+            }
+            // Based on master's Skin color
+            else if (player->getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                // Male master
+                if (player->getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                    case 12: // White
+                    case 13:
+                    case 14:
+                    case 18: // Completly White
+                        return 29409;
+                    case 9: // Light Brown
+                    case 10:
+                    case 11:
+                        return 29410;
+                    case 6: // Brown
+                    case 7:
+                    case 8:
+                        return 29411;
+                    case 0: // Dark
+                    case 1:
+                    case 2:
+                    case 3: // Dark Grey
+                    case 4:
+                    case 5:
+                        return 29412;
+                    default: // original - Grey
+                        return 8571;
+                    }
+                }
+                // Female master
+                else switch (skinColor)
+                {
+                case 10: // White
+                    return 29409;
+                case 6: // Light Brown
+                case 7:
+                    return 29410;
+                case 4: // Brown
+                case 5:
+                    return 29411;
+                case 0: // Dark
+                case 1:
+                case 2:
+                case 3:
+                    return 29412;
+                default: // original - Grey
+                    return 8571;
+                }
+            }
+            else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 892;
+            else
+                return 8571;
+        case FORM_DIREBEAR:
+        case FORM_BEAR:
+            // Based on Hair color
+            if (player->getRace() == RACE_NIGHTELF)
+            {
+                uint8 hairColor = player->GetByteValue(PLAYER_BYTES, 3);
+                switch (hairColor)
+                {
+                case 0: // Green
+                case 1: // Light Green
+                case 2: // Dark Green
+                    return 29413; // 29415?
+                case 6: // Dark Blue
+                    return 29414;
+                case 4: // White
+                    return 29416;
+                case 3: // Light Blue
+                    return 29417;
+                default: // original - Violet
+                    return 2281;
+                }
+            }
+            // Based on Skin color
+            else if (player->getRace() == RACE_TAUREN)
+            {
+                uint8 skinColor = player->GetByteValue(PLAYER_BYTES, 0);
+                // Male
+                if (player->getGender() == GENDER_MALE)
+                {
+                    switch (skinColor)
+                    {
+                    case 0: // Dark (Black)
+                    case 1:
+                    case 2:
+                        return 29418;
+                    case 3: // White
+                    case 4:
+                    case 5:
+                    case 12:
+                    case 13:
+                    case 14:
+                        return 29419;
+                    case 9: // Light Brown/Grey
+                    case 10:
+                    case 11:
+                    case 15:
+                    case 16:
+                    case 17:
+                        return 29420;
+                    case 18: // Completly White
+                        return 29421;
+                    default: // original - Brown
+                        return 2289;
+                    }
+                }
+                // Female
+                else switch (skinColor)
+                {
+                case 0: // Dark (Black)
+                case 1:
+                    return 29418;
+                case 2: // White
+                case 3:
+                    return 29419;
+                case 6: // Light Brown/Grey
+                case 7:
+                case 8:
+                case 9:
+                    return 29420;
+                case 10: // Completly White
+                    return 29421;
+                default: // original - Brown
+                    return 2289;
+                }
+            }
+            else if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 2281;
+            else
+                return 2289;
+        case FORM_FLIGHT:
+            if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 20857;
+            return 20872;
+        case FORM_FLIGHT_EPIC:
+            if (Player::TeamForRace(player->getRace()) == ALLIANCE)
+                return 21243;
+            return 21244;
+        default:
+            break;
+        }
+    }
+
     uint32 modelid = 0;
     SpellShapeshiftEntry const* formEntry = sSpellShapeshiftStore.LookupEntry(form);
     if (formEntry && formEntry->modelID_A)
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index 39b1c34..ac17613 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -2124,6 +2124,18 @@ class Unit : public WorldObject
         void TextEmote(uint32 textId, WorldObject const* target = nullptr, bool isBossEmote = false);
         void Whisper(uint32 textId, Player* target, bool isBossWhisper = false);
 
+        //npcbot
+        bool HasReactive(ReactiveType reactive) const { return m_reactiveTimer[reactive] > 0; }
+        void ClearReactive(ReactiveType reactive);
+
+        void SuspendDelayedSwing();
+        void ExecuteDelayedSwingHit(bool extra = false);
+        CalcDamageInfo _damageInfo;
+        ObjectGuid _delayedTargetGuid;
+        uint32 _swingDelayTimer;
+        bool _swingLanded;
+        //end npcbot
+
     protected:
         explicit Unit (bool isWorldObject);
 
diff --git a/src/server/game/Globals/ObjectMgr.cpp b/src/server/game/Globals/ObjectMgr.cpp
index 046ce42..4d23fd7 100644
--- a/src/server/game/Globals/ObjectMgr.cpp
+++ b/src/server/game/Globals/ObjectMgr.cpp
@@ -7881,6 +7881,82 @@ SkillRangeType GetSkillRangeType(SkillRaceClassInfoEntry const* rcEntry)
     return SKILL_RANGE_LEVEL;
 }
 
+void ObjectMgr::LoadCreatureOutfits()
+{
+    uint32 oldMSTime = getMSTime();
+
+    _creatureOutfitStore.clear();                           // for reload case (test only)
+
+    //                                                 0     1      2      3     4     5       6           7
+    QueryResult result = WorldDatabase.Query("SELECT entry, race, gender, skin, face, hair, haircolor, facialhair, "
+        //8       9        10    11     12     13    14     15     16     17     18
+        "head, shoulders, body, chest, waist, legs, feet, wrists, hands, back, tabard FROM creature_template_outfits");
+
+    if (!result)
+    {
+        TC_LOG_ERROR("server.loading", ">> Loaded 0 creature outfits. DB table `creature_template_outfits` is empty!");
+        return;
+    }
+
+    uint32 count = 0;
+
+    do
+    {
+        Field* fields = result->Fetch();
+
+        uint32 i = 0;
+        uint32 entry     = fields[i++].GetUInt32();
+
+        if (!GetCreatureTemplate(entry))
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits`, but not in `creature_template`!", entry);
+            continue;
+        }
+
+        CreatureOutfit co; // const, shouldnt be changed after saving
+        co.race          = fields[i++].GetUInt8();
+        ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(co.race);
+        if (!rEntry)
+        {
+            TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has incorrect race (%u).", entry, uint32(co.race));
+            continue;
+        }
+        co.gender        = fields[i++].GetUInt8();
+        // Set correct displayId
+        switch (co.gender)
+        {
+            case GENDER_FEMALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_f;
+                break;
+            case GENDER_MALE:
+                _creatureTemplateStore[entry].Modelid1 = rEntry->model_m;
+                break;
+            default:
+                TC_LOG_ERROR("server.loading", ">> Creature entry %u in `creature_template_outfits` has invalid gender %u", entry, uint32(co.gender));
+                continue;
+        }
+        _creatureTemplateStore[entry].Modelid2 = 0;
+        _creatureTemplateStore[entry].Modelid3 = 0;
+        _creatureTemplateStore[entry].Modelid4 = 0;
+        _creatureTemplateStore[entry].unit_flags2 |= UNIT_FLAG2_MIRROR_IMAGE; // Needed so client requests mirror packet
+
+        co.skin          = fields[i++].GetUInt8();
+        co.face          = fields[i++].GetUInt8();
+        co.hair          = fields[i++].GetUInt8();
+        co.haircolor     = fields[i++].GetUInt8();
+        co.facialhair    = fields[i++].GetUInt8();
+        for (uint32 j = 0; j != MAX_CREATURE_OUTFIT_DISPLAYS; ++j)
+            co.outfit[j] = fields[i+j].GetUInt32();
+
+        _creatureOutfitStore[entry] = co;
+
+        ++count;
+    }
+    while (result->NextRow());
+
+    TC_LOG_INFO("server.loading", ">> Loaded %u creature outfits in %u ms", count, GetMSTimeDiffToNow(oldMSTime));
+}
+
 void ObjectMgr::LoadGameTele()
 {
     uint32 oldMSTime = getMSTime();
diff --git a/src/server/game/Globals/ObjectMgr.h b/src/server/game/Globals/ObjectMgr.h
index 396be44..0cbf04f 100644
--- a/src/server/game/Globals/ObjectMgr.h
+++ b/src/server/game/Globals/ObjectMgr.h
@@ -136,6 +136,21 @@ struct GameTele
 
 typedef std::unordered_map<uint32, GameTele > GameTeleContainer;
 
+#define MAX_CREATURE_OUTFIT_DISPLAYS 11
+struct CreatureOutfit
+{
+    uint8 race;
+    uint8 gender;
+    uint8 face;
+    uint8 skin;
+    uint8 hair;
+    uint8 facialhair;
+    uint8 haircolor;
+    uint32 outfit[MAX_CREATURE_OUTFIT_DISPLAYS];
+};
+
+typedef std::unordered_map<uint32, CreatureOutfit > CreatureOutfitContainer;
+
 enum ScriptsType
 {
     SCRIPTS_FIRST = 1,
@@ -1034,6 +1049,7 @@ class ObjectMgr
 
         void LoadNPCSpellClickSpells();
 
+        void LoadCreatureOutfits();
         void LoadGameTele();
 
         void LoadGossipMenu();
@@ -1248,6 +1264,8 @@ class ObjectMgr
         bool AddGameTele(GameTele& data);
         bool DeleteGameTele(std::string const& name);
 
+        CreatureOutfitContainer const& GetCreatureOutfitMap() const { return _creatureOutfitStore; }
+
         TrainerSpellData const* GetNpcTrainerSpells(uint32 entry) const
         {
             CacheTrainerSpellContainer::const_iterator  iter = _cacheTrainerSpellStore.find(entry);
@@ -1399,6 +1417,8 @@ class ObjectMgr
         PageTextContainer _pageTextStore;
         InstanceTemplateContainer _instanceTemplateStore;
 
+        CreatureOutfitContainer _creatureOutfitStore;
+
     private:
         void LoadScripts(ScriptsType type);
         void LoadQuestRelationsHelper(QuestRelations& map, QuestRelationsReverse* reverseMap, std::string const& table, bool starter, bool go);
diff --git a/src/server/game/Groups/Group.cpp b/src/server/game/Groups/Group.cpp
index 5f50015..898ef94 100644
--- a/src/server/game/Groups/Group.cpp
+++ b/src/server/game/Groups/Group.cpp
@@ -104,6 +104,11 @@ bool Group::Create(Player* leader)
     if (m_groupType & GROUPTYPE_RAID)
         _initRaidSubGroupsCounter();
 
+    //npcbot - set loot mode on create
+    if (leader->HaveBot()) //player + npcbot so set to free-for-all on create
+        m_lootMethod = FREE_FOR_ALL;
+    else
+    //end npcbot
     if (!isLFGGroup())
         m_lootMethod = GROUP_LOOT;
 
@@ -363,6 +368,10 @@ bool Group::AddMember(Player* player)
 
     SubGroupCounterIncrease(subGroup);
 
+    //npcbot - check if trying to add bot
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     player->SetGroupInvite(NULL);
     if (player->GetGroup())
     {
@@ -378,6 +387,9 @@ bool Group::AddMember(Player* player)
     InstanceGroupBind* bind = GetBoundInstance(player);
     if (bind && bind->save->GetInstanceId() == player->GetInstanceId())
         player->m_InstanceValid = true;
+    //npcbot
+    }
+    //end npcbot
 
     if (!isRaidGroup())                                      // reset targetIcons for non-raid-groups
     {
@@ -402,6 +414,10 @@ bool Group::AddMember(Player* player)
     SendUpdate();
     sScriptMgr->OnGroupAddMember(this, player->GetGUID());
 
+    //npcbot - check 2
+    if (player->GetGUID().IsPlayer())
+    {
+    //end npcbot
     if (!IsLeader(player->GetGUID()) && !isBGGroup() && !isBFGroup())
     {
         // reset the new member's instances, unless he is currently in one of them
@@ -477,6 +493,9 @@ bool Group::AddMember(Player* player)
 
     if (m_maxEnchantingLevel < player->GetSkillValue(SKILL_ENCHANTING))
         m_maxEnchantingLevel = player->GetSkillValue(SKILL_ENCHANTING);
+    //npcbot
+    }
+    //end npcbot
 
     return true;
 }
@@ -600,6 +619,9 @@ bool Group::RemoveMember(ObjectGuid guid, const RemoveMethod& method /*= GROUP_R
         }
 
         if (m_memberMgr.getSize() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //npcbot
+        if (GetMembersCount() < ((isLFGGroup() || isBGGroup()) ? 1u : 2u))
+        //end npcbot
             Disband();
 
         return true;
diff --git a/src/server/game/Groups/Group.h b/src/server/game/Groups/Group.h
index b814ab0..7eea68f 100644
--- a/src/server/game/Groups/Group.h
+++ b/src/server/game/Groups/Group.h
@@ -323,6 +323,14 @@ class Group
         // FG: evil hacks
         void BroadcastGroupUpdate(void);
 
+        // ai playerbot mod
+        ObjectGuid GetTargetIcon(int index) { return m_targetIcons[index]; }
+        Rolls* GetRolls() { return &RollId; }
+        // end
+
+        //Bot
+        ObjectGuid const *GetTargetIcons() const { return m_targetIcons; }
+
     protected:
         bool _setMembersGroup(ObjectGuid guid, uint8 group);
         void _homebindIfInstance(Player* player);
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index c3fe967..417bc8a 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -46,6 +46,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+// Playerbot mod:
+#include "../../plugins/playerbot/playerbot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
 
 class LoginQueryHolder : public SQLQueryHolder
 {
@@ -60,6 +63,76 @@ class LoginQueryHolder : public SQLQueryHolder
         bool Initialize();
 };
 
+class PlayerbotLoginQueryHolder : public LoginQueryHolder
+{
+private:
+    uint32 masterAccountId;
+    PlayerbotHolder* playerbotHolder;
+
+public:
+    PlayerbotLoginQueryHolder(PlayerbotHolder* playerbotHolder, uint32 masterAccount, uint32 accountId, uint64 guid)
+        : LoginQueryHolder(accountId, ObjectGuid(guid)), masterAccountId(masterAccount), playerbotHolder(playerbotHolder) { }
+
+public:
+    uint32 GetMasterAccountId() const { return masterAccountId; }
+    PlayerbotHolder* GetPlayerbotHolder() { return playerbotHolder; }
+};
+
+void PlayerbotHolder::AddPlayerBot(uint64 playerGuid, uint32 masterAccount)
+{
+    // has bot already been added?
+	Player* bot = sObjectMgr->GetPlayerByLowGUID(playerGuid);
+
+	if (bot && bot->IsInWorld())
+        return;
+
+    uint32 accountId = sObjectMgr->GetPlayerAccountIdByGUID(ObjectGuid(playerGuid));
+    if (accountId == 0)
+        return;
+
+    PlayerbotLoginQueryHolder *holder = new PlayerbotLoginQueryHolder(this, masterAccount, accountId, playerGuid);
+    if(!holder->Initialize())
+    {
+        delete holder;                                      // delete all unprocessed queries
+        return;
+    }
+
+    QueryResultHolderFuture future = CharacterDatabase.DelayQueryHolder(holder);
+    future.get();
+
+    WorldSession* masterSession = masterAccount ? sWorld->FindSession(masterAccount) : NULL;
+    uint32 botAccountId = holder->GetAccountId();
+    WorldSession *botSession = new WorldSession(botAccountId, NULL, NULL, SEC_PLAYER, 2, 0, LOCALE_enUS, 0, false);
+
+    botSession->HandlePlayerLogin(holder); // will delete lqh
+
+	bot = botSession->GetPlayer();
+	if (!bot)
+		return;
+
+	PlayerbotMgr *mgr = bot->GetPlayerbotMgr();
+	bot->SetPlayerbotMgr(NULL);
+	delete mgr;
+	sRandomPlayerbotMgr.OnPlayerLogout(bot);
+
+    bool allowed = false;
+    if (botAccountId == masterAccount)
+        allowed = true;
+    else if (masterSession && sPlayerbotAIConfig.allowGuildBots && bot->GetGuildId() == masterSession->GetPlayer()->GetGuildId())
+        allowed = true;
+    else if (sPlayerbotAIConfig.IsInRandomAccountList(botAccountId))
+        allowed = true;
+
+    if (allowed)
+        OnBotLogin(bot);
+    else if (masterSession)
+    {
+        ChatHandler ch(masterSession);
+        ch.PSendSysMessage("You are not allowed to control bot %s...", bot->GetName().c_str());
+        LogoutPlayerBot(bot->GetGUID());
+    }
+}
+
 bool LoginQueryHolder::Initialize()
 {
     SetSize(MAX_PLAYER_LOGIN_QUERY);
@@ -993,6 +1066,14 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     // Handle Login-Achievements (should be handled after loading)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
+    // playerbot mod
+    if (!_player->GetPlayerbotAI())
+    {
+        _player->SetPlayerbotMgr(new PlayerbotMgr(_player));
+        sRandomPlayerbotMgr.OnPlayerLogin(_player);
+    }
+    // end of playerbot mod
+
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
     // Prepatch by LordPsyan
     // 01
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index e9c3cea..175cb65 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -49,7 +49,8 @@
 // 68
 // 69
 // 70
-// 71
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
 // 72
 // 73
 // 74
@@ -320,7 +321,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 (HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !sender->isAcceptWhispers() && !sender->IsInWhisperWhiteList(receiver->GetGUID())))
                 sender->AddWhisperWhiteList(receiver->GetGUID());
 
-            GetPlayer()->Whisper(msg, Language(lang), receiver);
+            // Playerbot mod: handle whispered command to bot
+            if (receiver->GetPlayerbotAI() && lang != LANG_ADDON)
+            {
+                receiver->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                receiver->m_speakTime = 0;
+                receiver->m_speakCount = 0;
+            }
+            else
+            {
+                GetPlayer()->Whisper(msg, Language(lang), receiver);
+            }
+            // END Playerbot mod
         } break;
         case CHAT_MSG_PARTY:
         case CHAT_MSG_PARTY_LEADER:
@@ -337,6 +349,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (type == CHAT_MSG_PARTY_LEADER && !group->IsLeader(sender->GetGUID()))
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -353,6 +378,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
 
                     guild->BroadcastToGuild(this, false, msg, lang == LANG_ADDON ? LANG_ADDON : LANG_UNIVERSAL);
                 }
+                // Playerbot mod: broadcast message to bot members
+                PlayerbotMgr *mgr = GetPlayer()->GetPlayerbotMgr();
+                if (mgr && lang != LANG_ADDON)
+                {
+                    for (PlayerBotMap::const_iterator it = mgr->GetPlayerBotsBegin(); it != mgr->GetPlayerBotsEnd(); ++it)
+                    {
+                        Player* const bot = it->second;
+                        if (bot->GetGuildId() == GetPlayer()->GetGuildId())
+                            bot->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    }
+                }
+                // END Playerbot mod
             }
         } break;
         case CHAT_MSG_OFFICER:
@@ -378,6 +415,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -395,6 +445,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                     return;
             }
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -407,6 +470,19 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             if (!group || !group->isRaidGroup() || !(group->IsLeader(GetPlayer()->GetGUID()) || group->IsAssistant(GetPlayer()->GetGUID())) || group->isBGGroup())
                 return;
 
+            // Playerbot mod: broadcast message to bot members
+            for(GroupReference* itr = group->GetFirstMember(); itr != NULL; itr=itr->next())
+            {
+                Player* player = itr->GetSource();
+                if (player && player->GetPlayerbotAI() && lang != LANG_ADDON)
+                {
+                    player->GetPlayerbotAI()->HandleCommand(type, msg, *GetPlayer());
+                    GetPlayer()->m_speakTime = 0;
+                    GetPlayer()->m_speakCount = 0;
+                }
+            }
+            // END Playerbot mod
+
             sScriptMgr->OnPlayerChat(GetPlayer(), type, lang, msg, group);
 
             WorldPacket data;
@@ -455,6 +531,13 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             {
                 if (Channel* chn = cMgr->GetChannel(channel, sender))
                 {
+                    // Playerbot mod: broadcast message to bot members
+                    if (_player->GetPlayerbotMgr() && lang != LANG_ADDON && chn->GetFlags() & 0x18)
+                    {
+                        _player->GetPlayerbotMgr()->HandleCommand(type, msg);
+                    }
+                    sRandomPlayerbotMgr.HandleCommand(type, msg, *_player);
+                    // END Playerbot mod
                     sScriptMgr->OnPlayerChat(sender, type, lang, msg, chn);
                     chn->Say(sender->GetGUID(), msg.c_str(), lang);
                 }
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 0f0640e..b8e1e5d 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -583,8 +583,38 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
     if (!unit)
         return;
 
+    //bot
+    if (unit->GetTypeId() == TYPEID_UNIT)
+    {
+        CreatureOutfitContainer const& outfits = sObjectMgr->GetCreatureOutfitMap();
+        CreatureOutfitContainer::const_iterator it = outfits.find(unit->GetEntry());
+        if (it != outfits.end())
+        {
+            WorldPacket data(SMSG_MIRRORIMAGE_DATA, 68);
+            data << uint64(guid);
+            data << uint32(unit->GetNativeDisplayId()); // displayId
+            data << uint8(it->second.race);             // race
+            data << uint8(it->second.gender);           // gender
+            data << uint8(unit->getClass());            // class
+            data << uint8(it->second.skin);             // skin
+            data << uint8(it->second.face);             // face
+            data << uint8(it->second.hair);             // hair
+            data << uint8(it->second.haircolor);        // haircolor
+            data << uint8(it->second.facialhair);       // facialhair
+            data << uint32(0);                          // guildId
+
+            // item displays
+            for (uint8 i = 0; i != MAX_CREATURE_OUTFIT_DISPLAYS; ++i)
+                data << uint32(it->second.outfit[i]);
+
+            SendPacket(&data);
+            return;
+        }
+    }
+
     if (!unit->HasAuraType(SPELL_AURA_CLONE_CASTER))
         return;
+    //end bot
 
     // Get creator of the unit (SPELL_AURA_CLONE_CASTER does not stack)
     Unit* creator = unit->GetAuraEffectsByType(SPELL_AURA_CLONE_CASTER).front()->GetCaster();
diff --git a/src/server/game/Maps/Map.cpp b/src/server/game/Maps/Map.cpp
index 6fbef75..c80e8e4 100644
--- a/src/server/game/Maps/Map.cpp
+++ b/src/server/game/Maps/Map.cpp
@@ -36,6 +36,10 @@
 #include "Vehicle.h"
 #include "VMapFactory.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 u_map_magic MapMagic        = { {'M','A','P','S'} };
 u_map_magic MapVersionMagic = { {'v','1','.','3'} };
 u_map_magic MapAreaMagic    = { {'A','R','E','A'} };
@@ -2793,8 +2797,24 @@ uint32 Map::GetPlayersCountExceptGMs() const
 {
     uint32 count = 0;
     for (MapRefManager::const_iterator itr = m_mapRefManager.begin(); itr != m_mapRefManager.end(); ++itr)
-        if (!itr->GetSource()->IsGameMaster())
+        if (!itr->GetSource()->IsGameMaster()) {
+            //npcbot - count npcbots as group members (event if not in group)
+            if (itr->GetSource()->HaveBot() && BotMgr::LimitBots(this))
+            {
+                ++count;
+                BotMap const* botmap = itr->GetSource()->GetBotMgr()->GetBotMap();
+                for (BotMap::const_iterator itr = botmap->begin(); itr != botmap->end(); ++itr)
+                {
+                    Creature* cre = itr->second;
+                    if (!cre || !cre->IsInWorld() || cre->FindMap() != this)
+                        continue;
+                    ++count;
+                }
+            }
+            else
+            //end npcbot
             ++count;
+        }
     return count;
 }
 
@@ -2860,6 +2880,10 @@ void Map::AddToActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->incUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoadedForActiveObject(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())), c);
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
@@ -2891,6 +2915,10 @@ void Map::RemoveFromActive(Creature* c)
         GridCoord p = Trinity::ComputeGridCoord(x, y);
         if (getNGrid(p.x_coord, p.y_coord))
             getNGrid(p.x_coord, p.y_coord)->decUnloadActiveLock();
+        //bot
+        else if (c->GetIAmABot())
+            EnsureGridLoaded(Cell(Trinity::ComputeCellCoord(c->GetPositionX(), c->GetPositionY())));
+        //end bot
         else
         {
             GridCoord p2 = Trinity::ComputeGridCoord(c->GetPositionX(), c->GetPositionY());
diff --git a/src/server/game/Maps/MapManager.cpp b/src/server/game/Maps/MapManager.cpp
index 0e7f9db..ae423db 100644
--- a/src/server/game/Maps/MapManager.cpp
+++ b/src/server/game/Maps/MapManager.cpp
@@ -37,6 +37,10 @@
 #include "Opcodes.h"
 #include "AchievementMgr.h"
 
+//npcbot
+#include "botmgr.h"
+//end npcbot
+
 MapManager::MapManager()
 {
     i_gridCleanUpDelay = sWorld->getIntConfig(CONFIG_INTERVAL_GRIDCLEAN);
@@ -54,6 +58,82 @@ void MapManager::Initialize()
     // Start mtmaps if needed.
     if (num_threads > 0)
         m_updater.activate(num_threads);
+
+    //npcbot - spawn bots
+    BotMgr::LoadConfig();
+
+    if (!BotMgr::IsNpcBotModEnabled())
+        return;
+
+    uint32 botoldMSTime = getMSTime();
+
+    TC_LOG_INFO("server.loading", "Starting NpcBot system...");
+    PreparedStatement* botstmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOTS);
+    //"SELECT entry FROM characters_npcbot", CONNECTION_SYNCH
+    PreparedQueryResult res = CharacterDatabase.Query(botstmt);
+    if (!res)
+    {
+        TC_LOG_INFO("server.loading", ">> Spawned 0 npcbots. Table `characters_npcbot` is empty!");
+        return;
+    }
+
+    PreparedQueryResult infores;
+    uint32 botcounter = 0;
+    Field* field;
+    std::list<uint32> botgrids;
+    do
+    {
+        field = res->Fetch();
+        uint32 entry = field[0].GetUInt32();
+        CreatureTemplate const* proto = sObjectMgr->GetCreatureTemplate(entry);
+        if (!proto)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot find creature_template entry for npcbot (id: %u)!", entry);
+            continue;
+        }
+
+        botstmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_NPCBOT_INFO);
+        //"SELECT guid, map, position_x, position_y, position_z, orientation FROM creature WHERE id = ?", CONNECTION_SYNCH
+        botstmt->setUInt32(0, entry);
+        infores = WorldDatabase.Query(botstmt);
+        if (!infores)
+        {
+            TC_LOG_ERROR("server.loading", "Cannot spawn npcbot %s (id: %u), not found in `creature` table!", proto->Name.c_str(), entry);
+            continue;
+        }
+
+        field = infores->Fetch();
+        uint32 tableGuid = field[0].GetUInt32();
+        uint32 mapId = uint32(field[1].GetUInt16());
+        float pos_x = field[2].GetFloat();
+        float pos_y = field[3].GetFloat();
+        //float pos_z = field[4].GetFloat();
+        //float ori = field[5].GetFloat();
+
+        CellCoord c = Trinity::ComputeCellCoord(pos_x, pos_y);
+        GridCoord g = Trinity::ComputeGridCoord(pos_x, pos_y);
+        ASSERT(c.IsCoordValid() && "Invalid Cell coord!");
+        ASSERT(g.IsCoordValid() && "Invalid Grid coord!");
+        Map* npcbotmap = sMapMgr->CreateBaseMap(mapId);
+        npcbotmap->LoadGrid(pos_x, pos_y);
+        /*Creature* bot = npcbotmap->GetCreature(ObjectGuid(HighGuid::Unit, entry, tableGuid));
+        ABORT();
+        //debug
+        if (!bot->IsAlive())
+        {
+            bot->Respawn();
+            bot->ResetBotAI(1);
+        }*/
+
+        TC_LOG_DEBUG("server.loading", ">> Spawned npcbot %s (id: %u, map: %u, grid: %u, cell: %u)", proto->Name.c_str(), entry, mapId, g.GetId(), c.GetId());
+        botgrids.push_back(g.GetId());
+        ++botcounter;
+
+    } while (res->NextRow());
+
+    botgrids.unique();
+    TC_LOG_INFO("server.loading", ">> Spawned %u npcbot(s) within %lu grid(s) in %u ms", botcounter, botgrids.size(), GetMSTimeDiffToNow(botoldMSTime));
+    //end npcbot
 }
 
 void MapManager::InitializeVisibilityDistanceInfo()
diff --git a/src/server/game/Movement/MotionMaster.cpp b/src/server/game/Movement/MotionMaster.cpp
index cb8cab18..c6fe464 100644
--- a/src/server/game/Movement/MotionMaster.cpp
+++ b/src/server/game/Movement/MotionMaster.cpp
@@ -363,6 +363,20 @@ void MotionMaster::MoveJumpTo(float angle, float speedXY, float speedZ)
 
     float x, y, z;
 
+    //npcbot
+    if (_owner->GetTypeId() == TYPEID_UNIT && _owner->ToCreature()->IsNPCBot())
+    {
+        Movement::MoveSplineInit init(_owner);
+        init.MoveTo(x, y, z);
+        init.SetParabolic(speedZ/*max_height*/, 0);
+        init.SetOrientationFixed(true);
+        init.SetVelocity(speedXY);
+        init.Launch();
+        Mutate(new EffectMovementGenerator(0), MOTION_SLOT_CONTROLLED);
+        return;
+    }
+    //end npcbot
+
     float moveTimeHalf = speedZ / Movement::gravity;
     float dist = 2 * moveTimeHalf * speedXY;
     _owner->GetClosePoint(x, y, z, _owner->GetObjectSize(), dist, angle);
diff --git a/src/server/game/OutdoorPvP/OutdoorPvP.cpp b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
index 9046d9e..d01520e 100644
--- a/src/server/game/OutdoorPvP/OutdoorPvP.cpp
+++ b/src/server/game/OutdoorPvP/OutdoorPvP.cpp
@@ -345,6 +345,23 @@ bool OPvPCapturePoint::Update(uint32 diff)
     if (!fact_diff)
         return false;
 
+    //npcbots - count bots as players but 2 times less affect and only if there is a players difference
+    uint32 botsCount[2];
+
+    for (uint8 team = 0; team != 2; ++team)
+    {
+        botsCount[team] = 0;
+
+        for (GuidSet::iterator itr = m_activePlayers[team].begin(); itr != m_activePlayers[team].end(); ++itr)
+        {
+            if (Player* player = ObjectAccessor::FindPlayer(*itr))
+                botsCount[team] += player->GetNpcBotsCount();
+        }
+    }
+
+    fact_diff += 0.5f * float(botsCount[0] - botsCount[1]) * diff / OUTDOORPVP_OBJECTIVE_UPDATE_INTERVAL;
+    //end npcbot
+
     uint32 Challenger = 0;
     float maxDiff = m_maxSpeed * diff;
 
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index 4ea8583..0537d01 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -1510,7 +1510,22 @@ void AddBattlegroundScripts()
 // start97
 // start98
 // start99
-// start100
+//Bots
+void AddSC_death_knight_bot();
+void AddSC_druid_bot();
+void AddSC_hunter_bot();
+void AddSC_mage_bot();
+void AddSC_paladin_bot();
+void AddSC_priest_bot();
+void AddSC_rogue_bot();
+void AddSC_shaman_bot();
+void AddSC_warlock_bot();
+void AddSC_warrior_bot();
+void AddSC_blademaster_bot();
+void AddSC_script_bot_commands();
+//advanced
+//void AddSC_BotQuests_chapter1();
+//end Bots
 // start101
 // start102
 // start103
@@ -1636,7 +1651,22 @@ void AddCustomScripts()
 // end97
 // end98
 // end99
-// end100
+    //Bots
+    AddSC_death_knight_bot();
+    AddSC_druid_bot();
+    AddSC_hunter_bot();
+    AddSC_mage_bot();
+    AddSC_paladin_bot();
+    AddSC_priest_bot();
+    AddSC_rogue_bot();
+    AddSC_shaman_bot();
+    AddSC_warlock_bot();
+    AddSC_warrior_bot();
+    AddSC_blademaster_bot();
+    AddSC_script_bot_commands();
+    //advanced
+    //AddSC_BotQuests_chapter1();
+    //end Bots
 // end101
 // end102
 // end103
diff --git a/src/server/game/Server/WorldSession.cpp b/src/server/game/Server/WorldSession.cpp
index b1a043c..85f7d65 100644
--- a/src/server/game/Server/WorldSession.cpp
+++ b/src/server/game/Server/WorldSession.cpp
@@ -46,6 +46,9 @@
 
 #include <zlib.h>
 
+// Playerbot mod
+#include "../../plugins/playerbot/playerbot.h"
+
 namespace {
 
 std::string const DefaultPlayerName = "<none>";
@@ -189,6 +192,14 @@ ObjectGuid::LowType WorldSession::GetGUIDLow() const
 /// Send a packet to the client
 void WorldSession::SendPacket(WorldPacket* packet)
 {
+    // Playerbot mod: send packet to bot AI
+    if (GetPlayer()) {
+        if (GetPlayer()->GetPlayerbotAI())
+            GetPlayer()->GetPlayerbotAI()->HandleBotOutgoingPacket(*packet);
+        else if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->HandleMasterOutgoingPacket(*packet);
+    }
+
     if (!m_Socket)
         return;
 
@@ -259,6 +270,8 @@ void WorldSession::LogUnprocessedTail(WorldPacket* packet)
 /// Update the WorldSession (triggered by World update)
 bool WorldSession::Update(uint32 diff, PacketFilter& updater)
 {
+    if (GetPlayer() && GetPlayer()->GetPlayerbotAI()) return true;
+
     /// Update Timeout timer.
     UpdateTimeOutTime(diff);
 
@@ -321,6 +334,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
                             sScriptMgr->OnPacketReceive(this, *packet);
                             (this->*opHandle.handler)(*packet);
                             LogUnprocessedTail(packet);
+
+                            // playerbot mod
+                            if (_player && _player->GetPlayerbotMgr())
+                                _player->GetPlayerbotMgr()->HandleMasterIncomingPacket(*packet);
+                            // playerbot mod end
                         }
                         // lag can cause STATUS_LOGGEDIN opcodes to arrive after the player started a transfer
                         break;
@@ -400,6 +418,11 @@ bool WorldSession::Update(uint32 diff, PacketFilter& updater)
             break;
     }
 
+    // playerbot mod
+    if (GetPlayer() && GetPlayer()->GetPlayerbotMgr())
+        GetPlayer()->GetPlayerbotMgr()->UpdateSessions(0);
+    // end of playerbot mod
+
     if (m_Socket && m_Socket->IsOpen() && _warden)
         _warden->Update();
 
@@ -444,11 +467,20 @@ void WorldSession::LogoutPlayer(bool save)
     m_playerLogout = true;
     m_playerSave = save;
 
+    //npcbot - free all bots and remove from botmap
+    _player->RemoveAllBots();
+    //end npcbots
+
     if (_player)
     {
         if (ObjectGuid lguid = _player->GetLootGUID())
             DoLootRelease(lguid);
 
+        // Playerbot mod: log out all player bots owned by this toon
+        if (GetPlayer()->GetPlayerbotMgr())
+            GetPlayer()->GetPlayerbotMgr()->LogoutAllBots();
+        sRandomPlayerbotMgr.OnPlayerLogout(_player);
+
         ///- If the player just died before logging out, make him appear as a ghost
         if (_player->GetDeathTimer())
         {
@@ -533,7 +565,8 @@ void WorldSession::LogoutPlayer(bool save)
         _player->CleanupChannels();
 
         ///- If the player is in a group (or invited), remove him. If the group if then only 1 person, disband the group.
-        _player->UninviteFromGroup();
+        // playerbot mod
+        //_player->UninviteFromGroup();
 
         // remove player from the group if he is:
         // a) in group; b) not in raid group; c) logging out normally (not being kicked or disconnected)
@@ -1616,3 +1649,14 @@ uint32 WorldSession::DosProtection::GetMaxPacketCounterAllowed(uint16 opcode) co
 
     return maxPacketCounterAllowed;
 }
+
+void WorldSession::HandleBotPackets()
+{
+    WorldPacket* packet;
+    while (_recvQueue.next(packet))
+    {
+        OpcodeHandler& opHandle = opcodeTable[packet->GetOpcode()];
+        (this->*opHandle.handler)(*packet);
+        delete packet;
+    }
+}
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index af2d2d2..4124661 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -190,7 +190,8 @@ class CharacterCreateInfo
     friend class WorldSession;
     friend class Player;
 
-    protected:
+    // playerbot mod
+    public:
         /// User specified variables
         std::string Name;
         uint8 Race       = 0;
@@ -819,6 +820,10 @@ class WorldSession
         void HandleBattlemasterJoinArena(WorldPacket& recvData);
         void HandleReportPvPAFK(WorldPacket& recvData);
 
+        // playerbot mod
+        void HandleBotPackets();
+        // end of playerbot mod
+
         // Battlefield
         void SendBfInvitePlayerToWar(uint32 battleId, uint32 zoneId, uint32 time);
         void SendBfInvitePlayerToQueue(uint32 battleId);
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index 76eefa0..d94a46b 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -2399,6 +2399,13 @@ void Spell::DoAllEffectOnTarget(TargetInfo* target)
             if (caster->GetTypeId() == TYPEID_PLAYER && m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET) == 0 &&
                (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
                 caster->ToPlayer()->CastItemCombatSpell(unitTarget, m_attackType, procVictim, procEx);
+
+            //npcbot - CastItemCombatSpell for bots
+            if (caster->GetTypeId() == TYPEID_UNIT &&
+                caster->ToCreature()->GetBotAI() && !(m_spellInfo->Attributes & SPELL_ATTR0_STOP_ATTACK_TARGET) &&
+               (m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_MELEE || m_spellInfo->DmgClass == SPELL_DAMAGE_CLASS_RANGED))
+               caster->ToCreature()->CastCreatureItemCombatSpell(unitTarget, m_attackType, procVictim, procEx, this);
+            //end npcbot
         }
 
         m_damage = damageInfo.damage;
@@ -3158,6 +3165,11 @@ void Spell::cast(bool skipCheck)
         return;
     }
 
+    //NpcBot: If we are applying crowd control aura execute caster's delayed attack immediately to prevent instant CC break
+    if (m_targets.GetUnitTarget() && (m_spellInfo->AuraInterruptFlags & AURA_INTERRUPT_FLAG_TAKE_DAMAGE))
+        m_caster->ExecuteDelayedSwingHit();
+    //end NpcBot
+
     PrepareTriggersExecutedOnHit();
 
     CallScriptOnCastHandlers();
@@ -3605,6 +3617,9 @@ void Spell::finish(bool ok)
 
     // Stop Attack for some spells
     if (m_spellInfo->HasAttribute(SPELL_ATTR0_STOP_ATTACK_TARGET))
+    //npcbot - disable for npcbots
+    if (!(m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI()))
+    //end npcbot
         m_caster->AttackStop();
 }
 
@@ -3814,6 +3829,11 @@ void Spell::SendSpellStart()
 
 void Spell::SendSpellGo()
 {
+    //npcbot - hook for spellcast finish
+    if (m_caster->GetTypeId() == TYPEID_UNIT && m_caster->ToCreature()->GetBotAI())
+        m_caster->ToCreature()->OnSpellGo(this);
+    //end npcbot
+
     // not send invisible spell casting
     if (!IsNeedSendToClient())
         return;
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 6486a7e..5e70233 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -2230,6 +2230,11 @@ int32 SpellInfo::CalcPowerCost(Unit const* caster, SpellSchoolMask schoolMask) c
         }
     }
 
+    //npcbot - apply bot spell cost mods
+    if (powerCost > 0 && caster->GetTypeId() == TYPEID_UNIT && caster->ToCreature()->GetBotAI())
+        caster->ToCreature()->ApplyCreatureSpellCostMods(this, powerCost);
+    //end npcbot
+
     // PCT mod from user auras by school
     powerCost = int32(powerCost * (1.0f + caster->GetFloatValue(UNIT_FIELD_POWER_COST_MULTIPLIER + school)));
     if (powerCost < 0)
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index a47ca53..58d80a5 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -82,7 +82,10 @@
 // 15
 // 16
 // 17
-// 18
+// playerbot mod
+#include "../../plugins/ahbot/AhBot.h"
+#include "../../plugins/playerbot/PlayerbotAIConfig.h"
+#include "../../plugins/playerbot/RandomPlayerbotMgr.h"
 // 19
 // 20
 // Visit http://www.realmsofwarcraft.com/bb for forums and information
@@ -1329,6 +1332,7 @@ void World::LoadConfigSettings(bool reload)
 
     // AHBot
     m_int_configs[CONFIG_AHBOT_UPDATE_INTERVAL] = sConfigMgr->GetIntDefault("AuctionHouseBot.Update.Interval", 20);
+    m_int_configs[CONFIG_AHBOT_USE_PLUGINS] = sConfigMgr->GetBoolDefault("AuctionHouseBot.Use.Plugins", false);
 
     m_bool_configs[CONFIG_CALCULATE_CREATURE_ZONE_AREA_DATA] = sConfigMgr->GetBoolDefault("Calculate.Creature.Zone.Area.Data", false);
     m_bool_configs[CONFIG_CALCULATE_GAMEOBJECT_ZONE_AREA_DATA] = sConfigMgr->GetBoolDefault("Calculate.Gameoject.Zone.Area.Data", false);
@@ -1553,6 +1557,9 @@ void World::SetInitialWorldSettings()
     TC_LOG_INFO("server.loading", "Loading Creature templates...");
     sObjectMgr->LoadCreatureTemplates();
 
+    TC_LOG_INFO("server.loading", "Loading Creature template outfits...");     // must be after LoadCreatureTemplates
+    sObjectMgr->LoadCreatureOutfits();
+
     TC_LOG_INFO("server.loading", "Loading Equipment templates...");           // must be after LoadCreatureTemplates
     sObjectMgr->LoadEquipmentTemplates();
 
@@ -1949,6 +1956,11 @@ void World::SetInitialWorldSettings()
 
     if (uint32 realmId = sConfigMgr->GetIntDefault("RealmID", 0)) // 0 reserved for auth
         sLog->SetRealmId(realmId);
+
+    TC_LOG_INFO("server.loading", "Initializing AuctionHouseBot...");
+    auctionbot.Init();
+
+    sPlayerbotAIConfig.Initialize();
 }
 
 void World::DetectDBCLang()
@@ -2118,14 +2130,24 @@ void World::Update(uint32 diff)
 
         ///- Handle expired auctions
         sAuctionMgr->Update();
-    }
 
-    /// <li> Handle AHBot operations
+        // ahbot mod
+        auctionbot.Update();
+    }
+        // playerbot mod
+    // <li> Handle AHBot operations
+    if (sWorld->getIntConfig(CONFIG_AHBOT_USE_PLUGINS) == 0)
+    {
     if (m_timers[WUPDATE_AHBOT].Passed())
     {
         sAuctionBot->Update();
         m_timers[WUPDATE_AHBOT].Reset();
     }
+    } else {
+    sRandomPlayerbotMgr.UpdateAI(diff);
+    sRandomPlayerbotMgr.UpdateSessions(diff);
+    }
+    // end of playerbot mod
 
     /// <li> Handle session updates when the timer has passed
     ResetTimeDiffRecord();
@@ -2690,6 +2712,10 @@ void World::ShutdownServ(uint32 time, uint32 options, uint8 exitcode, const std:
         ShutdownMsg(true, nullptr, reason);
     }
 
+    // playerbot mod
+    sRandomPlayerbotMgr.LogoutAllBots();
+    // end of playerbot mod
+
     sScriptMgr->OnShutdownInitiate(ShutdownExitCode(exitcode), ShutdownMask(options));
 }
 
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index 22c67ac..0cff4f2 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -412,6 +412,7 @@ enum WorldIntConfigs
     CONFIG_BIRTHDAY_TIME,
     CONFIG_CREATURE_PICKPOCKET_REFILL,
     CONFIG_AHBOT_UPDATE_INTERVAL,
+	CONFIG_AHBOT_USE_PLUGINS,
     CONFIG_CHARTER_COST_GUILD,
     CONFIG_CHARTER_COST_ARENA_2v2,
     CONFIG_CHARTER_COST_ARENA_3v3,
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index 3668a2b..f61c813 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -62,6 +62,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/game/Addons
   ${CMAKE_SOURCE_DIR}/src/server/game/AI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/CoreAI
+  ${CMAKE_SOURCE_DIR}/src/server/game/AI/NpcBots
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/ScriptedAI
   ${CMAKE_SOURCE_DIR}/src/server/game/AI/SmartScripts
   ${CMAKE_SOURCE_DIR}/src/server/game/AuctionHouse
diff --git a/src/server/scripts/Commands/cs_ahbot.cpp b/src/server/scripts/Commands/cs_ahbot.cpp
index 44889fc..16d8877 100644
--- a/src/server/scripts/Commands/cs_ahbot.cpp
+++ b/src/server/scripts/Commands/cs_ahbot.cpp
@@ -241,5 +241,9 @@ template bool ahbot_commandscript::HandleAHBotItemsRatioHouseCommand<AUCTION_HOU
 
 void AddSC_ahbot_commandscript()
 {
+    // playerbot mod
+    if (sWorld->getIntConfig(CONFIG_AHBOT_USE_PLUGINS) == 0)
+    {
     new ahbot_commandscript();
+    }
 }
diff --git a/src/server/scripts/Commands/cs_misc.cpp b/src/server/scripts/Commands/cs_misc.cpp
index b81d615..f40d332 100644
--- a/src/server/scripts/Commands/cs_misc.cpp
+++ b/src/server/scripts/Commands/cs_misc.cpp
@@ -37,6 +37,10 @@
 #include "DisableMgr.h"
 #include "SpellHistory.h"
 
+#include "../../../plugins/ahbot/AhBot.h"
+#include "../../../plugins/playerbot/playerbot.h"
+#include "../../../plugins/playerbot/GuildTaskMgr.h"
+
 class misc_commandscript : public CommandScript
 {
 public:
@@ -97,6 +101,11 @@ public:
             { "unstuck",          rbac::RBAC_PERM_COMMAND_UNSTUCK,           true, &HandleUnstuckCommand,          "" },
             { "wchange",          rbac::RBAC_PERM_COMMAND_WCHANGE,          false, &HandleChangeWeather,           "" },
             { "mailbox",          rbac::RBAC_PERM_COMMAND_MAILBOX,          false, &HandleMailBoxCommand,          "" },
+            // playerbot mod
+            { "ahbot",            rbac::RBAC_PERM_COMMAND_GM,               true,  &ahbot::AhBot::HandleAhBotCommand,                      ""},
+            { "rndbot",           rbac::RBAC_PERM_COMMAND_GM,               true,  &RandomPlayerbotMgr::HandlePlayerbotConsoleCommand,     ""},
+            { "bot",              195                       ,               false, &PlayerbotMgr::HandlePlayerbotMgrCommand,               ""},
+            { "gtask",            rbac::RBAC_PERM_COMMAND_GM,               true,  &GuildTaskMgr::HandleConsoleCommand,                    ""},
         };
         return commandTable;
     }
diff --git a/src/server/scripts/Commands/cs_npc.cpp b/src/server/scripts/Commands/cs_npc.cpp
index 99c10b0..8793bb7 100644
--- a/src/server/scripts/Commands/cs_npc.cpp
+++ b/src/server/scripts/Commands/cs_npc.cpp
@@ -32,6 +32,8 @@ EndScriptData */
 #include "CreatureAI.h"
 #include "Player.h"
 #include "Pet.h"
+#include "bot_ai.h"
+#include "botmgr.h"
 
 template<typename E, typename T = char const*>
 struct EnumName
@@ -239,6 +241,16 @@ public:
         if (!charID)
             return false;
 
+        uint32 id = atoi(charID);
+
+        CreatureTemplate const* creInfo = sObjectMgr->GetCreatureTemplate(id);
+
+        if (!(creInfo->flags_extra & CREATURE_FLAG_EXTRA_NPCBOT))
+        {
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
         uint32 id  = atoi(charID);
         if (!sObjectMgr->GetCreatureTemplate(id))
             return false;
@@ -293,6 +305,97 @@ public:
 
         sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
         return true;
+        } else {
+        char* charID = handler->extractKeyFromLink((char*)args, "Hcreature_entry");
+        if (!charID)
+            return false;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_NPCBOT_OWNER);
+        //"SELECT owner FROM character_npcbot WHERE entry = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res1 = CharacterDatabase.Query(stmt);
+        if (res1)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `characters_npcbot` table!", id);
+            handler->SendSysMessage("If you want to replace this bot to new location use '.npc move' command");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        stmt = WorldDatabase.GetPreparedStatement(WORLD_SEL_CREATURE_BY_ID);
+        //"SELECT guid FROM creature WHERE id = ?", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        PreparedQueryResult res2 = WorldDatabase.Query(stmt);
+        if (res2)
+        {
+            handler->PSendSysMessage("Npcbot %u already exists in `creature` table!", id);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Player* chr = handler->GetSession()->GetPlayer();
+
+        if (chr->GetTransport())
+        {
+            handler->SendSysMessage("Cannot spawn bots on transport!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        float x = chr->GetPositionX();
+        float y = chr->GetPositionY();
+        float z = chr->GetPositionZ();
+        float o = chr->GetOrientation();
+        Map* map = chr->GetMap();
+
+        if (map->Instanceable())
+        {
+            handler->SendSysMessage("Cannot spawn bots in instances!");
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        Creature* creature = new Creature();
+        if (!creature->Create(map->GenerateLowGuid<HighGuid::Unit>(), map, chr->GetPhaseMaskForSpawn(), id, x, y, z, o))
+        {
+            delete creature;
+            return false;
+        }
+
+        uint8 roleMask = BOT_ROLE_DPS;
+
+        uint8 m_class = creature->GetCreatureTemplate()->trainer_class;
+        if (!(m_class == CLASS_WARRIOR || m_class == CLASS_ROGUE ||
+            m_class == CLASS_PALADIN || m_class == CLASS_DEATH_KNIGHT ||
+            m_class == CLASS_SHAMAN || m_class == BOT_CLASS_BM))
+            roleMask |= BOT_ROLE_RANGED;
+        if (m_class == CLASS_PRIEST || m_class == CLASS_DRUID ||
+            m_class == CLASS_SHAMAN || m_class == CLASS_PALADIN)
+            roleMask |= BOT_ROLE_HEAL;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_INS_NPCBOT);
+        //"INSERT INTO characters_npcbot (entry, roles) VALUES (?, ?)", CONNECTION_SYNCH
+        stmt->setUInt32(0, id);
+        stmt->setUInt8(1, roleMask);
+        CharacterDatabase.DirectExecute(stmt);
+
+        creature->SaveToDB(map->GetId(), (1 << map->GetSpawnMode()), chr->GetPhaseMaskForSpawn());
+
+        uint32 db_guid = creature->GetSpawnId();
+        if (!creature->LoadBotCreatureFromDB(db_guid, map))
+        {
+            handler->SendSysMessage("Cannot load npcbot from DB!");
+            handler->SetSentErrorMessage(true);
+            //return false;
+            delete creature;
+            return false;
+        }
+
+        sObjectMgr->AddCreatureToGrid(db_guid, sObjectMgr->GetCreatureData(db_guid));
+
+        handler->SendSysMessage("Npcbot successfully spawned.");
+        return true;
+    }
     }
 
     //add item in vendorlist
diff --git a/src/server/scripts/Spells/spell_paladin.cpp b/src/server/scripts/Spells/spell_paladin.cpp
index 197d554..387051a 100644
--- a/src/server/scripts/Spells/spell_paladin.cpp
+++ b/src/server/scripts/Spells/spell_paladin.cpp
@@ -119,6 +119,12 @@ class spell_pal_ardent_defender : public SpellScriptLoader
             {
                 healPct = GetSpellInfo()->Effects[EFFECT_1].CalcValue();
                 absorbPct = GetSpellInfo()->Effects[EFFECT_0].CalcValue();
+
+                //npcbot - allow for npcbots
+                if (GetUnitOwner()->GetTypeId() == TYPEID_UNIT && GetUnitOwner()->ToCreature()->IsNPCBot())
+                    return true;
+                //end npcbot
+
                 return GetUnitOwner()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -133,6 +139,40 @@ class spell_pal_ardent_defender : public SpellScriptLoader
                 Unit* victim = GetTarget();
                 int32 remainingHealth = victim->GetHealth() - dmgInfo.GetDamage();
                 uint32 allowedHealth = victim->CountPctFromMaxHealth(35);
+
+                //npcbot - calc for bots
+                if (victim->GetTypeId() == TYPEID_UNIT/* && victim->ToCreature()->IsNPCBot()*/)
+                {
+                    if (remainingHealth <= 0 && !victim->ToCreature()->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
+                    {
+                        // Cast healing spell, completely avoid damage
+                        absorbAmount = dmgInfo.GetDamage();
+
+                        uint32 defenseSkillValue = victim->GetDefenseSkillValue();
+                        // Max heal when defense skill denies critical hits from raid bosses
+                        // Formula: max defense at level + 140 (raiting from gear)
+                        uint32 reqDefForMaxHeal  = victim->getLevel() * 5 + 140;
+                        float pctFromDefense = (defenseSkillValue >= reqDefForMaxHeal)
+                            ? 1.0f
+                            : float(defenseSkillValue) / float(reqDefForMaxHeal);
+
+                        int32 healAmount = int32(victim->CountPctFromMaxHealth(int32(healPct * pctFromDefense)));
+                        victim->CastCustomSpell(victim, PAL_SPELL_ARDENT_DEFENDER_HEAL, &healAmount, NULL, NULL, true, NULL, aurEff);
+                        victim->ToCreature()->AddBotSpellCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL, 120 * IN_MILLISECONDS);
+                    }
+                    else if (remainingHealth < int32(allowedHealth))
+                    {
+                        // Reduce damage that brings us under 35% (or full damage if we are already under 35%) by x%
+                        uint32 damageToReduce = (victim->GetHealth() < allowedHealth)
+                            ? dmgInfo.GetDamage()
+                            : allowedHealth - remainingHealth;
+                        absorbAmount = CalculatePct(damageToReduce, absorbPct);
+                    }
+
+                    return;
+                }
+                //end npcbot
+
                 // If damage kills us
                 if (remainingHealth <= 0 && !victim->GetSpellHistory()->HasCooldown(PAL_SPELL_ARDENT_DEFENDER_HEAL))
                 {
diff --git a/src/server/scripts/Spells/spell_priest.cpp b/src/server/scripts/Spells/spell_priest.cpp
index 0914089..9cb793d 100644
--- a/src/server/scripts/Spells/spell_priest.cpp
+++ b/src/server/scripts/Spells/spell_priest.cpp
@@ -574,6 +574,7 @@ class spell_pri_penance : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
@@ -616,6 +617,8 @@ class spell_pri_penance : public SpellScriptLoader
             SpellCastResult CheckCast()
             {
                 Player* caster = GetCaster()->ToPlayer();
+                if (!caster && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot())
+                    caster = (Player*)GetCaster();
                 if (Unit* target = GetExplTargetUnit())
                     if (!caster->IsFriendlyTo(target) && !caster->IsValidAttackTarget(target))
                         return SPELL_FAILED_BAD_TARGETS;
@@ -757,6 +760,7 @@ class spell_pri_renew : public SpellScriptLoader
 
             bool Load() override
             {
+                if (GetCaster() && GetCaster()->GetTypeId() == TYPEID_UNIT && GetCaster()->ToCreature()->IsNPCBot()) return true;
                 return GetCaster() && GetCaster()->GetTypeId() == TYPEID_PLAYER;
             }
 
diff --git a/src/server/worldserver/CMakeLists.txt b/src/server/worldserver/CMakeLists.txt
index 78f39e0..a2c7596 100644
--- a/src/server/worldserver/CMakeLists.txt
+++ b/src/server/worldserver/CMakeLists.txt
@@ -134,6 +134,7 @@ target_link_libraries(worldserver
   common
   shared
   database
+  plugins
   scripts
   g3dlib
   gsoap
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 4d2f9d6..c33aa37 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -2655,12 +2655,12 @@ PlayerStart.MapsExplored = 0
 HonorPointsAfterDuel = 0
 
 #
-#    ResetDuelCooldowns
-#        Description: Reset all cooldowns before duel starts and restore them when duel ends.
+#    ResetCoolDownAfterDuel
+#        Description: Reset all cooldowns after duel, but only if player has no cooldowns before the duel.
 #        Default:     0  - (Disabled)
 #                     1  - (Enabled)
 
-ResetDuelCooldowns = 0
+ResetCoolDownAfterDuel = 0
 
 #
 #    AlwaysMaxWeaponSkill
@@ -2857,6 +2857,16 @@ NoGrayAggro.Below = 0
 ###################################################################################################
 # AUCTION HOUSE BOT SETTINGS
 #
+#    AuctionHouseBot.Use.Plugins
+#       Description: If using AHBot from Plugins (ahbot.conf set for enabled)
+#                    You must set this to 1.
+#       Default:     0 (Use TC ahbot)
+#                    1 (Use plugins ahbot)
+#
+
+AuctionHouseBot.Use.Plugins = 0
+
+#
 #    AuctionHouseBot.Update.Interval
 #       Description: Interval in seconds for AHBot to get updated
 #       Default:     20
@@ -3441,6 +3451,128 @@ PacketSpoof.BanDuration = 86400
 #
 ###################################################################################################
 
+###################################################################################################
+# NPCBOT CONFIGURATION
+#
+#    NpcBot.Enable
+#        Description: Enable NpcBot system
+#        Default:   1 - enable
+#                   0 - disable
+
+NpcBot.Enable = 1
+
+#
+#    NpcBot.AllowGM
+#        Description: Allow GM's to have NpcBots
+#        Default:   1 - Allow
+#                   0 - disable
+
+NpcBot.AllowGM = 1
+
+#    NpcBot.MaxBots
+#        Description: Maximum number of bots allowed for players.
+#        Default:   1
+#        Recommend: 1-2
+#        Max:       4
+
+NpcBot.MaxBots = 1
+
+#    NpcBot.MaxBotsPerClass
+#        Description: Maximum bots of each class allowed for players.
+#        Default:   1
+#                   0 - no limit
+
+NpcBot.MaxBotsPerClass = 1
+
+#    NpcBot.BaseFollowDistance
+#        Description: Default bot follow distance.
+#        Note: This parameter determines bots' formation size, distance at which bots will chase and attack enemies.
+#        Note2: This parameter is set for each player at login.
+#        Default:   30
+
+NpcBot.BaseFollowDistance = 20
+
+#    NpcBot.XpReduction
+#        Description: XP percent penalty for each bot used starting with second.
+#        Example: 3 bots, xp reduction is 20: ((3-1)*20) = 40%, 60% exp gained only.
+#        Note: Maximum overall xp reduction is 90%.
+#        Default:   0
+
+NpcBot.XpReduction = 0
+
+#    NpcBot.HealTargetIconsMask
+#        Description: Icon number bitmask which bots use to search for additional targets to heal (out of party).
+#        Note: Many creatures cannot accept heal.
+#        Example: to check Star, Triangle and Square we need 1 + 8 + 32 = 41.
+#        Default:   0 (Disable)
+#                   1 - Star
+#                   2 - Circle
+#                   4 - Diamond
+#                   8 - Triangle
+#                   16 - Moon
+#                   32 - Square
+#                   64 - Cross
+#                   128 - Skull
+
+NpcBot.HealTargetIconsMask = 0
+
+#    NpcBot.Mult.Damage.Melee
+#    NpcBot.Mult.Damage.Spell
+#    NpcBot.Mult.Healing
+#        Description: Multipliers for bots' damage and healing. Allows to balance bots vs players.
+#        Minimum:   0.1
+#        Maximum:  10.0
+#        Default:   1.0
+
+NpcBot.Mult.Damage.Melee = 1.0
+NpcBot.Mult.Damage.Spell = 1.0
+NpcBot.Mult.Healing      = 1.0
+
+#    NpcBot.Enable.Dungeon
+#    NpcBot.Enable.Raid
+#    NpcBot.Enable.BG
+#    NpcBot.Enable.Arena
+#    NpcBot.Enable.DungeonFinder
+#        Description: Allow bots to enter PvE/PvP areas and Dungeon Finder query
+#        Default:   1 - (NpcBot.Enable.Dungeon)
+#                   0 - (NpcBot.Enable.Raid)
+#                   0 - (NpcBot.Enable.BG)
+#                   0 - (NpcBot.Enable.Arena)
+#                   1 - (NpcBot.Enable.DungeonFinder)
+
+NpcBot.Enable.Dungeon       = 1
+NpcBot.Enable.Raid          = 0
+NpcBot.Enable.BG            = 0
+NpcBot.Enable.Arena         = 0
+NpcBot.Enable.DungeonFinder = 1
+
+#    NpcBot.Limit.Dungeon
+#    NpcBot.Limit.Raid
+#        Description: Enable/Disable instance players limitation rules for bots.
+#        Default:   1 - (NpcBot.Limit.Dungeon)
+#                   1 - (NpcBot.Limit.Raid)
+
+NpcBot.Limit.Dungeon = 1
+NpcBot.Limit.Raid    = 1
+
+#    NpcBot.Cost
+#        Description: Bot recruitment cost (in copper).
+#        Note: This value is for level 80 characters.
+#              Cost is reduced for lower levels by simple formula: (cost * level / 80).
+#        Default:   1000000 (100 gold, 1g25s at level 1)
+
+NpcBot.Cost = 1000000
+
+#    NpcBot.PvP
+#        Description: Allow bots to attack player-controlled units (players, pets, bots, etc.)
+#        Note: This rule only applies to player-controlled bots
+#        Default:   1
+
+NpcBot.PvP = 1
+
+#
+###################################################################################################
+
 #
 # Prepatch by LordPsyan.
 # See http://www.realmsofwarcraft.com/bb for forums and information.
-- 
2.1.4

