From 867d38f9767e84e18174edb2bb33f27c48dc85a7 Mon Sep 17 00:00:00 2001
From: LordPsyan <realmsofwarcraft@gmail.com>
Date: Tue, 9 Sep 2014 02:27:13 -0400
Subject: [PATCH] ALL-No-Bots

---
 README.NPCTELEPORT                                 |   14 +
 Reforging_README.md                                |   40 +
 Transmog_CHANGELOG.md                              |  122 ++
 Transmog_README.md                                 |   50 +
 cmake/compiler/msvc/settings.cmake                 |    2 +-
 event_readme.txt                                   |  208 +++
 npc-entry-list.txt                                 |   24 +
 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql    |   11 +
 .../All-In-One/characters_AIO.sql                  |    1 +
 sql/TrinityCore-Patches/All-In-One/world_AIO.sql   |   31 +
 .../Anticheat/characters.anticheat.sql             |   30 +
 .../ArenaGambler/CharactersDB.sql                  |   59 +
 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql   |  371 +++++
 .../BountyHunter/characters.BountyHunter.sql       |   38 +
 .../CrossFactionBG/world.AVFix.sql                 |    3 +
 .../Fake_Players/characters.fake_players.sql       |   40 +
 .../Fake_Players/world.fake_players.sql            |    2 +
 .../GuildLevelSystem/auth_guild_level_system.sql   |    7 +
 .../characters_guild_level_system.sql              |   55 +
 .../GuildLevelSystem/world_guild_level_system.sql  |    7 +
 .../Guildhouses/world_guildhouses.sql              |   67 +
 .../auth_individuale_xp_Rate.sql                   |    5 +
 .../world_individuale_xp_Rate.sql                  |    9 +
 .../LevelNPC/world.levelnpc.sql                    |    5 +
 .../Player_Events/world.player_events.sql          |   75 +
 .../Reforging/characters.reforging.sql             |   10 +
 .../Reforging/world.reforging.sql                  |    6 +
 .../SummonNPC/world.summonnpc-item.sql             |    4 +
 .../TeleNPC2/world.npc_teleport.sql                |  120 ++
 .../Transmogrification/characters.sql              |   23 +
 .../Transmogrification/updates/_README.md          |    1 +
 .../updates/characters_update_2_1_to_2_2.sql       |   12 +
 .../updates/characters_update_2_2_to_3_0.sql       |    2 +
 .../updates/characters_update_4_x_to_5_0.sql       |   16 +
 .../updates/world_update_3_5_to_3_6.sql            |    1 +
 .../updates/world_update_4_x_to_5_0.sql            |   27 +
 .../updates/world_update_5_0_to_5_1.sql            |    6 +
 .../Transmogrification/world_NPC.sql               |    6 +
 .../Transmogrification/world_texts.sql             |   18 +
 .../beastmaster/world-beastmaster.sql              |   64 +
 sql/TrinityCore-Patches/enchant/world.enchant.sql  |    4 +
 .../npc_buff/world_npc_buff.sql                    |   62 +
 .../profession_npc/world_professionnpc.sql         |    4 +
 .../External_Mail/characters.external_mail.sql     |   10 +
 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp  |  380 +++++
 src/server/game/AI/ScriptedAI/sc_npc_teleport.h    |  151 ++
 src/server/game/Accounts/RBAC.h                    |   27 +
 src/server/game/Anticheat/AnticheatData.cpp        |  118 ++
 src/server/game/Anticheat/AnticheatData.h          |   63 +
 src/server/game/Anticheat/AnticheatMgr.cpp         |  434 ++++++
 src/server/game/Anticheat/AnticheatMgr.h           |  103 ++
 src/server/game/Anticheat/AnticheatScripts.cpp     |   14 +
 src/server/game/Anticheat/AnticheatScripts.h       |   15 +
 src/server/game/Battlegrounds/Arena.cpp            |    4 +-
 src/server/game/Battlegrounds/Battleground.cpp     |   47 +-
 src/server/game/Battlegrounds/Battleground.h       |    2 +-
 src/server/game/Battlegrounds/BattlegroundMgr.cpp  |    2 +-
 .../game/Battlegrounds/BattlegroundQueue.cpp       |   85 +-
 src/server/game/Battlegrounds/BattlegroundQueue.h  |   11 +-
 .../game/Battlegrounds/Zones/BattlegroundAB.cpp    |    2 +-
 .../game/Battlegrounds/Zones/BattlegroundAV.cpp    |   19 +-
 .../game/Battlegrounds/Zones/BattlegroundWS.cpp    |    3 +-
 src/server/game/CMakeLists.txt                     |    5 +
 src/server/game/Cfbg/Cfbg.cpp                      |  325 ++++
 src/server/game/Cfbg/Cfbg.h                        |   35 +
 src/server/game/Conditions/ConditionMgr.cpp        |   22 +
 src/server/game/Conditions/ConditionMgr.h          |    3 +-
 src/server/game/DataStores/DBCStores.cpp           |    4 +-
 src/server/game/DataStores/DBCStores.h             |    2 +-
 src/server/game/DataStores/DBCStructure.h          |    2 +-
 src/server/game/DataStores/DBCfmt.h                |    2 +-
 src/server/game/Entities/Creature/Creature.cpp     |    2 +-
 src/server/game/Entities/Player/Player.cpp         |  397 ++++-
 src/server/game/Entities/Player/Player.h           |  101 +-
 src/server/game/Entities/Unit/Unit.cpp             |   52 +-
 src/server/game/Entities/Unit/Unit.h               |    4 +-
 src/server/game/Entities/Vehicle/Vehicle.cpp       |    0
 src/server/game/Guilds/Guild.cpp                   |  169 ++
 src/server/game/Guilds/Guild.h                     |   37 +
 src/server/game/Handlers/BattleGroundHandler.cpp   |    4 +-
 src/server/game/Handlers/CharacterHandler.cpp      |   53 +-
 src/server/game/Handlers/ChatHandler.cpp           |   28 +-
 src/server/game/Handlers/GroupHandler.cpp          |   12 +-
 src/server/game/Handlers/LootHandler.cpp           |   11 +
 src/server/game/Handlers/MiscHandler.cpp           |   95 +-
 src/server/game/Handlers/MovementHandler.cpp       |    4 +
 src/server/game/Handlers/QueryHandler.cpp          |    2 +-
 src/server/game/Handlers/SpellHandler.cpp          |   11 +-
 src/server/game/Mails/Mail.cpp                     |   62 +
 src/server/game/Miscellaneous/Formulas.h           |   42 +-
 src/server/game/Miscellaneous/Language.h           |   48 +-
 src/server/game/Reputation/ReputationMgr.cpp       |   10 +
 src/server/game/Scripting/ScriptLoader.cpp         |  199 ++-
 src/server/game/Scripting/ScriptMgr.cpp            |    3 +
 src/server/game/Server/WorldSession.h              |    1 +
 src/server/game/Spells/Spell.cpp                   |   10 +-
 src/server/game/Spells/SpellEffects.cpp            |    4 +
 src/server/game/Spells/SpellInfo.cpp               |    6 +-
 src/server/game/World/World.cpp                    |  162 +-
 src/server/game/World/World.h                      |  104 ++
 src/server/scripts/CMakeLists.txt                  |    4 +
 src/server/scripts/Commands/cs_anticheat.cpp       |  262 ++++
 src/server/scripts/Commands/cs_guild.cpp           |  121 ++
 src/server/scripts/Commands/cs_modify.cpp          |   64 +
 src/server/scripts/Custom/ArenaGambler.cpp         |  308 ++++
 src/server/scripts/Custom/ArenaGamblingSystem.cpp  |  723 +++++++++
 src/server/scripts/Custom/ArenaGamblingSystem.h    |  458 ++++++
 src/server/scripts/Custom/CMakeLists.txt           |    4 +-
 src/server/scripts/Custom/Reforging.cpp            |  646 ++++++++
 src/server/scripts/Custom/Transmogrification.cpp   |  838 ++++++++++
 src/server/scripts/Custom/Transmogrification.h     |  140 ++
 src/server/scripts/Custom/Transmogrifier.cpp       |  399 +++++
 src/server/scripts/Custom/all-in-one.cpp           | 1330 ++++++++++++++++
 src/server/scripts/Custom/beastmaster.cpp          |  385 +++++
 src/server/scripts/Custom/bountyhunter.cpp         |  462 ++++++
 src/server/scripts/Custom/enchant.cpp              | 1621 ++++++++++++++++++++
 src/server/scripts/Custom/event.cpp                |  646 ++++++++
 src/server/scripts/Custom/guildmaster.cpp          |  313 ++++
 src/server/scripts/Custom/killstreak.cpp           |   63 +
 src/server/scripts/Custom/levelnpc.cpp             |  192 +++
 src/server/scripts/Custom/npc_teleport.cpp         |  222 +++
 src/server/scripts/Custom/npcbuff.cpp              |  426 +++++
 src/server/scripts/Custom/professionnpc.cpp        |  396 +++++
 src/server/scripts/Custom/summon.cpp               |   46 +
 src/server/scripts/Spells/spell_generic.cpp        |   22 +-
 .../Database/Implementation/CharacterDatabase.cpp  |   41 +-
 .../Database/Implementation/CharacterDatabase.h    |   37 +-
 src/server/worldserver/worldserver.conf.dist       |  563 +++++++
 128 files changed, 15767 insertions(+), 150 deletions(-)
 create mode 100644 README.NPCTELEPORT
 create mode 100644 Reforging_README.md
 create mode 100644 Transmog_CHANGELOG.md
 create mode 100644 Transmog_README.md
 create mode 100644 event_readme.txt
 create mode 100644 npc-entry-list.txt
 create mode 100644 sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/All-In-One/world_AIO.sql
 create mode 100644 sql/TrinityCore-Patches/Anticheat/characters.anticheat.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
 create mode 100644 sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
 create mode 100644 sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
 create mode 100644 sql/TrinityCore-Patches/CrossFactionBG/world.AVFix.sql
 create mode 100644 sql/TrinityCore-Patches/Fake_Players/characters.fake_players.sql
 create mode 100644 sql/TrinityCore-Patches/Fake_Players/world.fake_players.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
 create mode 100644 sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
 create mode 100644 sql/TrinityCore-Patches/Individuale_XP-Rate/auth_individuale_xp_Rate.sql
 create mode 100644 sql/TrinityCore-Patches/Individuale_XP-Rate/world_individuale_xp_Rate.sql
 create mode 100644 sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
 create mode 100644 sql/TrinityCore-Patches/Player_Events/world.player_events.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/characters.reforging.sql
 create mode 100644 sql/TrinityCore-Patches/Reforging/world.reforging.sql
 create mode 100644 sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
 create mode 100644 sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/characters.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/_README.md
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
 create mode 100644 sql/TrinityCore-Patches/Transmogrification/world_texts.sql
 create mode 100644 sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
 create mode 100644 sql/TrinityCore-Patches/enchant/world.enchant.sql
 create mode 100644 sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
 create mode 100644 sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
 create mode 100644 sql/TrinityCore-patches/External_Mail/characters.external_mail.sql
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
 create mode 100644 src/server/game/AI/ScriptedAI/sc_npc_teleport.h
 create mode 100644 src/server/game/Anticheat/AnticheatData.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatData.h
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatMgr.h
 create mode 100644 src/server/game/Anticheat/AnticheatScripts.cpp
 create mode 100644 src/server/game/Anticheat/AnticheatScripts.h
 create mode 100644 src/server/game/Cfbg/Cfbg.cpp
 create mode 100644 src/server/game/Cfbg/Cfbg.h
 mode change 100755 => 100644 src/server/game/Entities/Vehicle/Vehicle.cpp
 create mode 100644 src/server/scripts/Commands/cs_anticheat.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGambler.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.cpp
 create mode 100644 src/server/scripts/Custom/ArenaGamblingSystem.h
 create mode 100644 src/server/scripts/Custom/Reforging.cpp
 create mode 100644 src/server/scripts/Custom/Transmogrification.cpp
 create mode 100644 src/server/scripts/Custom/Transmogrification.h
 create mode 100644 src/server/scripts/Custom/Transmogrifier.cpp
 create mode 100644 src/server/scripts/Custom/all-in-one.cpp
 create mode 100644 src/server/scripts/Custom/beastmaster.cpp
 create mode 100644 src/server/scripts/Custom/bountyhunter.cpp
 create mode 100644 src/server/scripts/Custom/enchant.cpp
 create mode 100644 src/server/scripts/Custom/event.cpp
 create mode 100644 src/server/scripts/Custom/guildmaster.cpp
 create mode 100644 src/server/scripts/Custom/killstreak.cpp
 create mode 100644 src/server/scripts/Custom/levelnpc.cpp
 create mode 100644 src/server/scripts/Custom/npc_teleport.cpp
 create mode 100644 src/server/scripts/Custom/npcbuff.cpp
 create mode 100644 src/server/scripts/Custom/professionnpc.cpp
 create mode 100644 src/server/scripts/Custom/summon.cpp

diff --git a/README.NPCTELEPORT b/README.NPCTELEPORT
new file mode 100644
index 0000000..015c9c2
--- /dev/null
+++ b/README.NPCTELEPORT
@@ -0,0 +1,14 @@
+NPC Teleport for Trinity
+
+Original author : Wilibald09
+
+Allows you to add a custom NPC for teleporting, using .npc add 100000.
+The default NPC is entry 100000.
+
+All settings are located in the DB, so you can customize and add destinations,
+set level restrictions and also charge the player for teleporting.
+
+Installation:
+
+Run the query setup_npc_teleport.sql located in the trinity sql directory on
+your world DB. This will setup the DB and you can customize from there.
diff --git a/Reforging_README.md b/Reforging_README.md
new file mode 100644
index 0000000..e26d9bf
--- /dev/null
+++ b/Reforging_README.md
@@ -0,0 +1,40 @@
+#Reforging [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=reforging)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+Blizz*like* reforging
+Change 40% of your item stats to something else
+Sends item packets so you can see the changes on item tooltips
+Simple and easy to use interface
+Made for 3.3.5a.<br />
+Source: https://rochet2.github.io/?page=Reforging
+
+Video: https://youtu.be/84EtvKTfqQM
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/reforging
+- Diff: https://github.com/Rochet2/TrinityCore/compare/reforging.diff
+- Patch: https://github.com/Rochet2/TrinityCore/compare/reforging.patch
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 reforging`
+- use cmake and compile
+
+Using diff:
+- DO NOT COPY THE DIFF DIRECTLY! It causes apply to fail.
+- download the diff by __right clicking__ the link and select __Save link as__
+- place the downloaded `reforging.diff` to the source root folder
+- open git bash to source location
+- do `git apply reforging.diff`
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\Reforging\sql\`
+- Run `characters.reforging.sql` to your characters database
+ - optionally you can also insert a reforger NPC to your database by running `world.reforging.sql` to your world database.
+
+####Bugs and Contact
+Report issues and similar to https://rochet2.github.io/
diff --git a/Transmog_CHANGELOG.md b/Transmog_CHANGELOG.md
new file mode 100644
index 0000000..d5c97ec
--- /dev/null
+++ b/Transmog_CHANGELOG.md
@@ -0,0 +1,122 @@
+####6.0
+- Removed mutex locks - Different code style, works with ACE and boost, probably more efficient
+- Added regex checking for preset name
+- Fixed random properties not registering as item stats (Thanks Aokromes)
+- Made the code / patch compatible with herbs+veins patch (Thanks Aokromes)
+- Moved to bithub - Allows autogenerate patch and diff and management is easier:
+- https://github.com/Rochet2/TrinityCore/tree/transmog
+- Gist was at: https://gist.github.com/Rochet2/2c8765b53f8dda1e296a
+
+####5.6
+- Fixed few linux compile warnings
+- Moved to GIST
+- Old versions etc still available from:
+https://drive.google.com/folderview?id=0Bx5knS2IsjatTlVtWHRwbUN3VlE&usp=sharing
+
+####5.5
+- Updated to latest TC  rev
+- Fixed some tabs to spaces
+- Fixed a warning on gcc
+
+####5.4
+- Updated to latest TC rev
+
+####5.3
+- Rewrote transmogrification logic to be blizzlike.
+- Implemented multithread support.
+- Tweaked saving to work so that your data is saved whenever the player is saved.
+- This means that crashes can not be abused and DB wont have SQL executing and querying all the time.
+
+####5.2
+- Some logic fixes and other
+
+####5.1
+- Config options should now work properly. Please notify here if some still bug
+- Can transmog bows with guns and crossbows
+- Can transmog cloth to leather with config settings set
+- Can transmog robes with chest pieces
+- You should now be able to view the info menus with the new NPC
+- Allow shirt's to be transmogrified (were shown in menu but you weren't able to before)
+- Mirror image (mage spell) should now correctly copy the transmogrified outfit. Before it still got your old item displays.
+- Added new config options:
+
+####5.0
+- Ripped cata branch functions and thus altered how everything is coded pretty much.
+- Dropped translation support
+- Added colored item links as well as icons all over the place
+- Added new feature: Sets
+- Added many config options, for example to allow cloth and plate to be transmogrified with each other
+
+####4.0
+- I changed all the methods to normal functions and moved them to Transmogrification.cpp
+- I also updated the way transmogrifications are stored
+
+####3.9
+- Nothing was added
+- Now supporting latest TDB: 0d3554d4bf
+- Also tested and works on latest
+- Changed diff to patch for better compability
+
+####3.8
+- Nothing was added
+- Now supporting latest TDB: da9865b683
+
+####3.7
+- Quick update to the patch for latest trinitycore version
+
+####3.6
+- Updated the code to work with the new trinitycore changes
+- Added config (See the bottom of worldserver.conf)
+- Added token cost possibility -- in config
+- Added cost modification possibility -- in config
+- Added quality requirement modification possibility -- in config
+
+####3.5
+- Fixed a crash on item deletion from guild deleting and more
+
+####3.4
+- Added localization possibilities, even though I am not quite sure if it works and if it is good or good enough. Only tested that english works
+- Added possibility to disable gold cost before compiling
+- Cleaned all the code I could find to TrinityCore standards .. I think
+
+####3.3
+- Transformed the script into a full coremod instead of having some code in the gossip script. This allows the transmogrification methods to be used on any item anywhere.
+- Changed the way fake display entries are stored in the core. Instead of having a new variable for the item class, I am now having a contained, much like locales have.
+- Changed the files into one patch file like Aokromes suggested. You can find the DB table creation SQLs from sql/characters_transmogrification/
+- Removed prepared statements
+- Fake display entries are now loaded when the server starts up. All nonexistant item guids will be deleted before loading and when loading, all invalid item entries are deleted (deleted some custom items aye?
+
+####3.2
+- Fixed an issue with DB saving not taking action on login or server restart.
+
+####3.1
+- Corrected the quality check, which was left to return true in any case
+- Fixed invisible item entries from newly created items (.additem for example)
+
+####3.0
+- It will have mailing and auction etc restrictions properly coded (yay, no more Fake owner!)
+- Having its own prepared statement now
+- Moved loading transmogs to the item loading part.
+- The script should now be added to scriptloader by the patch. So you just need to add it to solution.
+- Included an NPC sql for everyone with NPC problems :3
+
+####2.2
+- Added a few sounds, altered to use switch instead of an IF block
+- Modified to have a separate table
+- And more?
+
+####2.1
+- Fixed a crash when getting item template of item entry 0
+
+####2.0
+- Possibly more ..
+- Implemented cost
+- Changed quality checks
+- Fixed few problems
+- Changed some messages for more blizzlike feeling
+- After trying to transmogrify or remove a transmogrification, you get to the item selection screen instead of main menu
+- Added Remove Transmogrification buttons and update main menu button (removed nevermind)
+- Added more checks for safety and blizzlike feeling
+
+####1.0
+- Added DB saving and remove transmogrifications option -> patch, sql and script needed
\ No newline at end of file
diff --git a/Transmog_README.md b/Transmog_README.md
new file mode 100644
index 0000000..663f2fc
--- /dev/null
+++ b/Transmog_README.md
@@ -0,0 +1,50 @@
+#Transmogrification [![Build Status](https://travis-ci.org/Rochet2/TrinityCore.svg?branch=transmog)](https://travis-ci.org/Rochet2/TrinityCore)
+
+####About
+Transmogrification allows you to change the display of an item to something else.
+You can use any item in your bags as source of display, as long as it fits the requirements.
+Requirements can be tweaked in the server configuration file.
+Basically any item should work with transmogrification. Custom items as well. No item is hardcoded to the system.
+Has a feature to store sets of displays. This can be removed before compiling or in the configuration file.
+Made for 3.3.5a.<br />
+Source: http://rochet2.github.io/?page=Transmogrification
+
+Video: http://youtu.be/xtH4ogz12iM
+
+####Installation
+
+Available as:
+- Direct merge: https://github.com/Rochet2/TrinityCore/tree/transmog
+- Diff: https://github.com/Rochet2/TrinityCore/compare/transmog.diff
+- Patch: https://github.com/Rochet2/TrinityCore/compare/transmog.patch
+
+Using direct merge:
+- open git bash to source location
+- do `git remote add rochet2 https://github.com/Rochet2/TrinityCore.git`
+- do `git pull rochet2 transmog`
+- use cmake and compile
+
+Using diff:
+- download the diff by __right clicking__ the link and select __save as__
+- place the downloaded `transmog.diff` to the source root folder
+- open git bash to source location
+- do `git apply transmog.diff`
+- use cmake and compile
+
+After compiling:
+- Navigate to `\src\server\scripts\Custom\Transmog\sql\`
+- Run `characters.sql` to your characters database
+- Run `world_texts.sql` to your world database
+ - optionally you can also insert a transmogrifier NPC to your database by running `world_NPC.sql` to your world database.
+- Change the settings to your liking in `worldserver.conf` (Note that you should copy over the new config created)
+
+####Usage
+Equip an item that is suitable for transmogrification.
+Have an item in your bags that is suitable to be used to transmogrify the equipped item
+Talk to Transmogrifier and select the item slot. Then select the item you want to transmogrify to.
+Click to proceed when prompted and your items are transmogrified.
+
+####Changelog: [Changelog](https://github.com/Rochet2/TrinityCore/blob/transmog/src/server/scripts/Custom/Transmog/CHANGELOG.md)
+
+####Bugs and Contact
+Report issues and similar to http://rochet2.github.io/
diff --git a/cmake/compiler/msvc/settings.cmake b/cmake/compiler/msvc/settings.cmake
index b68a0de..fe896d8 100644
--- a/cmake/compiler/msvc/settings.cmake
+++ b/cmake/compiler/msvc/settings.cmake
@@ -1,7 +1,7 @@
 # set up output paths for executable binaries (.exe-files, and .dll-files on DLL-capable platforms)
 set(CMAKE_RUNTIME_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR}/bin)
 
-set(MSVC_EXPECTED_VERSION 18.0)
+set(MSVC_EXPECTED_VERSION 16.0)
 
 if(CMAKE_CXX_COMPILER_VERSION VERSION_LESS MSVC_EXPECTED_VERSION)
   message(FATAL_ERROR "MSVC: TrinityCore requires version ${MSVC_EXPECTED_VERSION} (MSVC 2013) to build but found ${CMAKE_CXX_COMPILER_VERSION}")
diff --git a/event_readme.txt b/event_readme.txt
new file mode 100644
index 0000000..085effe
--- /dev/null
+++ b/event_readme.txt
@@ -0,0 +1,208 @@
+#### EventID:
+```
+Only used for debugging purposes
+.onevent test ID
+```
+
+#### ConditionType:
+```
+Table: conditions
+Column: SourceTypeOrReferenceId
+
+Read how condition system works, or keep on 0
+```
+
+#### ConditionEntry:
+```
+Table: conditions
+Column: SourceEntry
+```
+
+#### GameEventEntry:
+```
+Table: game_event
+Column: eventEntry
+If you enter a number here, the event & action will not be performed unless the event with specificed ID is running.
+```
+
+#### Eventtype:
+|Event               | ID | Explanation                         |
+|--------------------|----|-------------------------------------|
+|PEVENT_LEVELUP      | 1  | Run action if player levels up      |
+|PEVENT_KILLCREATURE | 2  | Run action if player kills creature |
+|PEVENT_CREATUREKILL | 3  | Run action if creature kills player |
+|PEVENT_DUELSTART    | 5  | Run action on duel start            |
+|PEVENT_DUELEND      | 6  | Run action on duel end              |
+|PEVENT_DUELWIN      | 7  | Run action on duel win              |
+|PEVENT_DUELLOSS     | 8  | Run action on duel loss             |
+|PEVENT_ONSPELLCAST  | 9  | Run action on spellcast             |
+|PEVENT_ONLOGIN      | 10 | Run action on login                 |
+|PEVENT_ONLOGOUT     | 11 | Run action on logout                |
+|PEVENT_NEWZONE      | 12 | Run action when entering new zone   |
+|PEVENT_FIRSTLOGIN   | 13 | Run action on first login           |
+
+#### Here's what eventvalue means for different eventtypes:
+
+PEVENT_LEVELUP:
+```
+What level you reached
+```
+PEVENT_KILLCREATURE:
+```
+Id of creature you killed
+```
+PEVENT_CREATUREKILL:
+```
+Id of creature who killed you
+```
+PEVENT_DUELSTART, PEVENT_DUELEND, PEVENT_DUELWIN, PEVENT_DUELLOSS:
+```
+DuelCompleteType:
+DUEL_INTERRUPTED = 0 (/forfeit etc..)
+DUEL_WON         = 1
+DUEL_FLED        = 2 (Ran away from duel)
+```
+PEVENT_ONSPELLCAST:
+```
+Id of spell being casted
+```
+PEVENT_ONLOGIN, PEVENT_ONLOGOUT:
+```
+Absolutely nothing
+```
+PEVENT_NEWZONE:
+```
+Id of new zone entered!
+```
+
+NOTE: Eventvalue 0 will accept any spellid, creatureid etc...
+
+#### Level: The level when the action will occur
+#### Class: The class ID of the class this should happen to (0 means all)
+
+
+|Class       | ID|
+|------------|---|
+|WARRIOR     | 1 |
+|PALADIN     | 2 |
+|HUNTER      | 3 |
+|ROGUE       | 4 |
+|PRIEST      | 5 |
+|DEATH_KNIGHT| 6 |
+|SHAMAN      | 7 |
+|MAGE        | 8 |
+|WARLOCK     | 9 |
+|DRUID       | 11|
+
+#### Race: The Race ID of the Race this should happen to (0 means all)
+
+|Race     | ID|
+|---------|---|
+|HUMAN    | 1 |
+|ORC      | 2 |
+|DWARF    | 3 |
+|NIGHTELF | 4 |
+|UNDEAD   | 5 |
+|TAUREN   | 6 |
+|GNOME    | 7 |
+|TROLL    | 8 |
+|BLOODELF | 10|
+|DRAENEI  | 11|
+
+#### Action: The action id
+
+|Action            | ID |
+|------------------|----|
+|ACTION_MODMONEY   | 1  |
+|ACTION_GIVEITEM   | 2  |
+|ACTION_CASTSPELL  | 3  |
+|ACTION_LEARNSPELL | 4  |
+|ACTION_TELEPORT   | 5  |
+|ACTION_TEMPSUMMON | 6  |
+|ACTION_SETHEALTH  | 7  |
+|ACTION_SETPOWER   | 8  |
+|ACTION_ADDTITLE   | 9  |
+|ACTION_GIVEXP     | 10 |
+|ACTION_ADDITEMSET | 11 |
+
+
+#### Here's what valueA - valueE means for different actions:
+
+###### ACTION_MODMONEY:
+```
+valueA = Amount of copper to give to player
+```
+
+###### ACTION_GIVEITEM:
+```
+valueA = ItemID
+valueB = How many to give
+```
+
+###### ACTION_CASTSPELL:
+```
+valueA = Spell to cast on player
+```
+
+###### ACTION_LEARNSPELL:
+```
+valueA = Spell to learn to player
+```
+
+###### ACTION_TELEPORT:
+```
+valueA = mapid
+valueB = x
+valueC = y
+valueD = z
+valueE = orientation
+```
+
+###### ACTION_TEMPSUMMON:
+```
+valueA = CreatureID
+valueB = TempSummonType* (I would say use 3, it's safe.)
+valueC = DespawnTime (milliseconds)
+```
+
+ACTION_SETHEALTH
+```
+valueA = % of health to set on player
+valueB = If more then 0 it affects pets as well.
+```
+ACTION_SETPOWER
+```
+valueA = % of power to set on player
+valueB = If more then 0 it affects pets as well.
+```
+ACTION_ADDTITLE
+```
+valueA = TitleID
+```
+ACTION_GIVEXP
+```
+valueA = Amount of XP
+```
+ACTION_ADDITEMSET
+```
+valueA = Itemset ID
+```
+*
+
+|TempSummonType                         | ID | Explanation                                                         |
+|---------------------------------------|----|---------------------------------------------------------------------|
+|TEMPSUMMON_TIMED_OR_DEAD_DESPAWN       | 1  | despawns after a specified time OR when the creature disappears     |
+|TEMPSUMMON_TIMED_OR_CORPSE_DESPAWN     | 2  | despawns after a specified time OR when the creature dies           |
+|TEMPSUMMON_TIMED_DESPAWN               | 3  | despawns after a specified time                                     |
+|TEMPSUMMON_TIMED_DESPAWN_OUT_OF_COMBAT | 4  | despawns after a specified time after the creature is out of combat |
+|TEMPSUMMON_CORPSE_DESPAWN              | 5  | despawns instantly after death                                      |
+|TEMPSUMMON_CORPSE_TIMED_DESPAWN        | 6  | despawns after a specified time after death                         |
+|TEMPSUMMON_DEAD_DESPAWN                | 7  | despawns when the creature disappears                               |
+|TEMPSUMMON_MANUAL_DESPAWN              | 8  | despawns when UnSummon() is called                                  |
+
+
+#### Message
+```
+A message that will be sent along with the reward.
+If message contains the text CODEMSG message will be overriden by a hardcoded message with reward text.
+```
\ No newline at end of file
diff --git a/npc-entry-list.txt b/npc-entry-list.txt
new file mode 100644
index 0000000..4090a23
--- /dev/null
+++ b/npc-entry-list.txt
@@ -0,0 +1,24 @@
+This is a list of all NPC's used in all of the patches.
+
+All-In-One NPC
+80000 - Young Woman
+Arena Gambler
+908001 - The Lich King
+BeastMaster
+99990 - LordPsyan
+Guild Houses
+13 - Beltez
+TeleNPC
+100000 - Abyssal Vortex
+NPC Buff
+60002 - LordPsyan
+Enchant:
+100067 - Young Woman
+Profession NPC
+60001 - Cyon
+Level NPC
+60003 - Lucy
+Reforging
+190011 - Thaumaturge Vashreen
+Transmogrification
+190010 - Warpweaver
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
new file mode 100644
index 0000000..ed0d7ea
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/auth_AIO.sql
@@ -0,0 +1,11 @@
+CREATE TABLE `hacked` (
+ `charname` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `lagreports` (
+ `account` CHAR( 50) NOT NULL
+);
+
+CREATE TABLE `vipek2` (
+ `account` CHAR( 50) NOT NULL
+);
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
new file mode 100644
index 0000000..f131461
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/characters_AIO.sql
@@ -0,0 +1 @@
+REPLACE INTO `mail` (`id`, `messageType`, `stationery`, `mailTemplateId`, `sender`, `receiver`, `subject`, `has_items`, `expire_time`, `deliver_time`, `money`, `cod`, `checked`) VALUES (60003, 0, 41, 0, 0, 0, 'Money For You!', 0, 0, 0, 4294967295, 0, 1);
diff --git a/sql/TrinityCore-Patches/All-In-One/world_AIO.sql b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
new file mode 100644
index 0000000..d3ed99b
--- /dev/null
+++ b/sql/TrinityCore-Patches/All-In-One/world_AIO.sql
@@ -0,0 +1,31 @@
+-- Updates
+-- WARNING! It's changes official blizz data!
+UPDATE `creature_template` SET `faction`=35 WHERE `entry` IN(28474, 914, 23128, 17204, 5115, 4584, 16655, 28958, 4090, 23534);
+
+-- Inserts
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80000, 'Sorry, you are not VIP member.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80001, 'Welcome Dear VIP.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80006, 'Your skills are set to max.', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80007, 'It\'s Time To choose!', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80010, 'Donation help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80011, 'Normal help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+REPLACE INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80012, 'Ingame help text', NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, NULL, NULL, 0, 0, 0, 0, 0, 0, 0, 0, 1);
+
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80013, 'You Don\'t have resurrection sickness!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80014, 'You Don\'t have a pet!', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `npc_text` (`ID`, `text0_0`, `text0_1`, `lang0`, `prob0`, `em0_0`, `em0_1`, `em0_2`, `em0_3`, `em0_4`, `em0_5`, `text1_0`, `text1_1`, `lang1`, `prob1`, `em1_0`, `em1_1`, `em1_2`, `em1_3`, `em1_4`, `em1_5`, `text2_0`, `text2_1`, `lang2`, `prob2`, `em2_0`, `em2_1`, `em2_2`, `em2_3`, `em2_4`, `em2_5`, `text3_0`, `text3_1`, `lang3`, `prob3`, `em3_0`, `em3_1`, `em3_2`, `em3_3`, `em3_4`, `em3_5`, `text4_0`, `text4_1`, `lang4`, `prob4`, `em4_0`, `em4_1`, `em4_2`, `em4_3`, `em4_4`, `em4_5`, `text5_0`, `text5_1`, `lang5`, `prob5`, `em5_0`, `em5_1`, `em5_2`, `em5_3`, `em5_4`, `em5_5`, `text6_0`, `text6_1`, `lang6`, `prob6`, `em6_0`, `em6_1`, `em6_2`, `em6_3`, `em6_4`, `em6_5`, `text7_0`, `text7_1`, `lang7`, `prob7`, `em7_0`, `em7_1`, `em7_2`, `em7_3`, `em7_4`, `em7_5`, `VerifiedBuild`) VALUES (80016, 'Welcome! My Name is AIO. What can I help for you? Please choose one menu. Do not forget this script is made by Blue from the wowemuf.org', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, '', '', 0, 0, 0, 0, 0, 0, 0, 0, 1);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (998, '|cffff0000<Announcer>: Join Warsong Guilch!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (999, '|cffff0000<Announcer>: Join Wintergrasp!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (997, '|cffff0000<Announcer>: Join Arathi Basin!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (996, '|cffff0000<Announcer>: Join Eye of the Storm!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (995, '|cffff0000<Announcer>: Join Random Battleground!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (994, '|cffff0000<Announcer>: Join Arena 2v2!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (993, '|cffff0000<Announcer>: Join Arena 3v3!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (992, '|cffff0000<Announcer>: Join Arena 5v5!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (991, '|cffff0000<Announcer>: Join Alterac Valley!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (990, '|cffff0000<Announcer>: Join Strand of the Ancients!', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
+
+-- Creature_template entry. Make sure entry number does not conflict.
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('80000','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_all','0');
+-- end
diff --git a/sql/TrinityCore-Patches/Anticheat/characters.anticheat.sql b/sql/TrinityCore-Patches/Anticheat/characters.anticheat.sql
new file mode 100644
index 0000000..3504594
--- /dev/null
+++ b/sql/TrinityCore-Patches/Anticheat/characters.anticheat.sql
@@ -0,0 +1,30 @@
+DROP TABLE IF EXISTS `players_reports_status`;
+
+CREATE TABLE `players_reports_status` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `creation_time` int(10) unsigned NOT NULL DEFAULT '0',
+  `average` float NOT NULL DEFAULT '0',
+  `total_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `speed_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `fly_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `jump_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `waterwalk_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `teleportplane_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `climb_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='';
+
+DROP TABLE IF EXISTS `daily_players_reports`;
+CREATE TABLE `daily_players_reports` (
+  `guid` int(10) unsigned NOT NULL DEFAULT '0',
+  `creation_time` int(10) unsigned NOT NULL DEFAULT '0',
+  `average` float NOT NULL DEFAULT '0',
+  `total_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `speed_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `fly_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `jump_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `waterwalk_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `teleportplane_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  `climb_reports` bigint(20) unsigned NOT NULL DEFAULT '0',
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='';
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
new file mode 100644
index 0000000..ac486b2
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/CharactersDB.sql
@@ -0,0 +1,59 @@
+/*
+ * Author: Xees
+ * Description: This file is used to apply the database tables needed for the ArenaGambler
+ * Version: 1.2
+*/
+create table `custom_duel_config` (
+    `optionIndex` int (10),
+    `optionName` varchar (60),
+    `optionValue` float
+);
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('0','MAP ID ','1');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('1','X CORDS','-7218.97');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('2','Y CORDS','982.622');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('3','Z CORDS','303.524');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('4','O CORDS','1.40677');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('5','MINIMUM LEVEL','60');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('6','LEVEL DIFF','3');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('7','REWARD ON FLED','1');
+
+create table `custom_duel_statistics` (
+    `playerGUID` int (11),
+    `duelsLost` int (10),
+    `duelsWon` int (10),
+    `duelsRefused` int (10),
+    `duelsTotal` int (10)
+);
+
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('12',
+        'ENABLE ONLY CURRENCY',
+        '0');
+INSERT INTO `custom_duel_config`
+            (`optionIndex`,
+             `optionName`,
+             `optionValue`)
+VALUES ('13',
+        'ENABLE EQUAL BETS',
+        '0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('11','ENABLE ITEM LIMITS','0');
+
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('8','MAXIMUM BET','1000');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('9','ENABLE GM DUEL','0');
+insert into `custom_duel_config` (`optionIndex`, `optionName`, `optionValue`) values('10','ENABLE SAMEIP DUEL','0');
+
+create table `custom_duel_storage` (
+    `matchId` int (10),
+    `challengerGUID` int (11),
+    `defenderGUID` int (11),
+    `challengerItemId` mediumint (8),
+    `challengerItemCount` int (11),
+    `defenderItemId` mediumint (8),
+    `defenderItemCount` int (11),
+    `matchDate` timestamp ,
+    `matchWinner` int (11)
+);
diff --git a/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
new file mode 100644
index 0000000..e2fd8e3
--- /dev/null
+++ b/sql/TrinityCore-Patches/ArenaGambler/WorldDB.sql
@@ -0,0 +1,371 @@
+REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('25266','0','0','0','0','0','24818','3422','24819','24821','Arena Gambler','','','0','255','255','0','35','0','1','1.14286','1','0','0','0','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','5','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','','1');
+REPLACE INTO `creature` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `modelid`, `equipment_id`, `position_x`, `position_y`, `position_z`, `orientation`, `spawntimesecs`, `spawndist`, `currentwaypoint`, `curhealth`, `curmana`, `MovementType`, `npcflag`, `unit_flags`, `dynamicflags`, `VerifiedBuild`) VALUES (1118308, 908001, 1, 1, 1, 0, 0, -7207.9, 1056.01, 327.532, 4.59111, 300, 0, 0, 108000, 0, 2, 0, 0, 0, 0);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8021000, 10, 8520, 'Arena Records', '', '', '', 0, 0, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', 'duel_records_system', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9045336, 8021000, 1, 1, 1, -7217.97, 1054.25, 331.856, 5.24803, 0, 0, 0.494776, -0.86902, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010000, 33, 9276, 'Arena 0', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239650, 8010000, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010001, 33, 9256, 'Arena 1', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239651, 8010001, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010002, 33, 9257, 'Arena 2', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239644, 8010002, 0, 1, 1, -8942.42, -4009.48, 331.64, 0.943155, 0, 0, 0.454292, 0.890853, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8010003, 33, 9258, 'Arena 3', '', '', '', 0, 0, 1.4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (239653, 8010003, 1, 1, 1, -7218.95, 982.451, 299.273, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8007862, 5, 7862, 'Arena Bonfire', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9044977, 8007862, 1, 1, 1, -7224.76, 1021.03, 303.523, 1.40272, 0, 0, 0.645258, 0.763965, 300, 0, 1),
+(9044978, 8007862, 1, 1, 1, -7201.21, 1017.04, 303.523, 1.40272, 0, 0, 0.645258, 0.763965, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8007658, 5, 7658, 'Arena Earth Rune', '', '', '', 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9044951, 8007658, 1, 1, 1, -7207.87, 1056.14, 327.535, 4.52314, 0, 0, 0.770754, -0.637133, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (800342, 5, 342, 'Arena Wall Rune', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9046955, 800342, 1, 1, 1, -7212.74, 1056.6, 335.527, 4.59111, 0, 0, 0.748659, -0.662955, 300, 0, 1),
+(9046953, 800342, 1, 1, 1, -7202.82, 1055.39, 335.527, 4.59111, 0, 0, 0.748659, -0.662955, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8008124, 5, 8124, 'Arena Eye of Acherus', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`, `id`, `map`, `spawnMask`, `phaseMask`, `position_x`, `position_y`, `position_z`, `orientation`, `rotation0`, `rotation1`, `rotation2`, `rotation3`, `spawntimesecs`, `animprogress`, `state`) VALUES (9044976, 8008124, 1, 1, 1, -7207.83, 1055.98, 342.182, 1.41429, 0, 0, 0.649667, 0.760219, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8008054, 5, 8054, 'Arena Skull of Acherus', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9055707, 8008054, 1, 1, 1, -7137.07, 970.488, 329.703, 1.51134, 0, 0, 0.685777, 0.727812, 300, 0, 1),
+(9044974, 8008054, 1, 1, 1, -7302.17, 994.336, 328.471, 4.55182, 0, 0, 0.761539, -0.648119, 300, 0, 1),
+(9044969, 8008054, 1, 1, 1, -7232.73, 900.85, 329.059, 6.09277, 0, 0, 0.0950627, -0.995471, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8004714, 5, 4714, 'Arena Light Powersource', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9044979, 8004714, 1, 1, 1, -7280.03, 1002.39, 303.523, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044980, 8004714, 1, 1, 1, -7283.71, 978.588, 303.523, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044981, 8004714, 1, 1, 1, -7155.47, 985.314, 303.524, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1),
+(9044982, 8004714, 1, 1, 1, -7158.91, 962.114, 303.524, 6.13, 0, 0, 0.0765184, -0.997068, 300, 0, 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240164, 70264, 1, 1, 1, -7211.89, 921.652, 307.653, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240166, 70264, 1, 1, 1, -7211.89, 921.652, 303.524, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240167, 70264, 1, 1, 1, -7211.64, 923.561, 304.714, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240168, 70264, 1, 1, 1, -7210.66, 920.395, 305.123, 3.10238, 0, 0, 0.999808, 0.0196051, 25, 0, 1),
+(240169, 70264, 1, 1, 1, -7210, 922.433, 304.547, 3.52728, 0, 0, 0.981463, -0.191651, 25, 0, 1),
+(240170, 70264, 1, 1, 1, -7211.74, 925.442, 305.599, 3.55012, 0, 0, 0.97921, -0.202848, 25, 0, 1),
+(240171, 70264, 1, 1, 1, -7211.08, 927.887, 303.524, 2.53696, 0, 0, 0.954649, 0.297734, 25, 0, 1),
+(240172, 70264, 1, 1, 1, -7210.16, 925.499, 303.523, 0.171338, 0, 0, 0.0855642, 0.996333, 25, 0, 1),
+(240174, 70264, 1, 1, 1, -7212.64, 918.485, 307.331, 2.88561, 0, 0, 0.99182, 0.127644, 25, 0, 1),
+(240175, 70264, 1, 1, 1, -7213.07, 916.643, 307.346, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240176, 70264, 1, 1, 1, -7213.5, 915.324, 306.69, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240177, 70264, 1, 1, 1, -7213.94, 913.631, 308.328, 2.57459, 0, 0, 0.960082, 0.27972, 25, 0, 1),
+(240178, 70264, 1, 1, 1, -7210.59, 918.498, 303.524, 2.23965, 0, 0, 0.900025, 0.435839, 25, 0, 1),
+(240179, 70264, 1, 1, 1, -7211, 916.593, 304.705, 2.5813, 0, 0, 0.961015, 0.276496, 25, 0, 1),
+(240180, 70264, 1, 1, 1, -7211.58, 914.537, 304.612, 5.18568, 0, 0, 0.521622, -0.853176, 25, 0, 1),
+(240181, 70264, 1, 1, 1, -7214.78, 911.262, 309.84, 2.45752, 0, 0, 0.942074, 0.335406, 25, 0, 1),
+(240182, 70264, 1, 1, 1, -7216.24, 912.227, 306.76, 5.43418, 0, 0, 0.411866, -0.911244, 25, 0, 1),
+(240183, 70264, 1, 1, 1, -7212.83, 912.539, 307.181, 2.37505, 0, 0, 0.927447, 0.373954, 25, 0, 1),
+(240184, 70264, 1, 1, 1, -7213.46, 909.984, 307.23, 0.549789, 0, 0, 0.271445, 0.962454, 25, 0, 1),
+(240194, 70264, 1, 1, 1, -7209.58, 914.14, 303.524, 3.51295, 0, 0, 0.982811, -0.184616, 25, 0, 1),
+(240195, 70264, 1, 1, 1, -7208.91, 916.507, 303.523, 3.29697, 0, 0, 0.996984, -0.0776098, 25, 0, 1),
+(240196, 70264, 1, 1, 1, -7208.91, 920.253, 303.524, 3.50117, 0, 0, 0.983881, -0.178823, 25, 0, 1),
+(240197, 70264, 1, 1, 1, -7211.93, 910.935, 303.523, 2.14636, 0, 0, 0.878724, 0.477331, 25, 0, 1),
+(240198, 70264, 1, 1, 1, -7211.66, 909.391, 304.125, 3.06528, 0, 0, 0.999272, 0.0381473, 25, 0, 1),
+(240199, 70264, 1, 1, 1, -7243.47, 918.183, 306.827, 2.88084, 0, 0, 0.991513, 0.130006, 25, 0, 1),
+(240200, 70264, 1, 1, 1, -7242.56, 920.043, 306.432, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240202, 70264, 1, 1, 1, -7242.34, 922.252, 307.37, 4.61579, 0, 0, 0.740422, -0.672143, 25, 0, 1),
+(240203, 70264, 1, 1, 1, -7241.58, 918.298, 307.496, 5.83709, 0, 0, 0.221202, -0.975228, 25, 0, 1),
+(240204, 70264, 1, 1, 1, -7242.13, 920.107, 308.89, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240205, 70264, 1, 1, 1, -7240.56, 920.002, 306.682, 3.3923, 0, 0, 0.992153, -0.125027, 25, 0, 1),
+(240206, 70264, 1, 1, 1, -7243.02, 924.059, 309.946, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240207, 70264, 1, 1, 1, -7243.01, 924.088, 305.274, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240208, 70264, 1, 1, 1, -7243.04, 924.253, 303.523, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240209, 70264, 1, 1, 1, -7241.35, 924.009, 307.062, 1.96681, 0, 0, 0.83239, 0.55419, 25, 0, 1),
+(240210, 70264, 1, 1, 1, -7241.94, 925.8, 305.81, 5.47362, 0, 0, 0.393821, -0.919187, 25, 0, 1),
+(240211, 70264, 1, 1, 1, -7241.6, 928.466, 303.523, 6.04382, 0, 0, 0.119399, -0.992846, 25, 0, 1),
+(240212, 70264, 1, 1, 1, -7241.24, 930.286, 305.206, 3.14491, 0, 0, 0.999999, -0.00165872, 25, 0, 1),
+(240213, 70264, 1, 1, 1, -7243.68, 926.66, 303.523, 5.75479, 0, 0, 0.261137, -0.965302, 25, 0, 1),
+(240214, 70264, 1, 1, 1, -7242.97, 929.298, 303.523, 5.94014, 0, 0, 0.170683, -0.985326, 25, 0, 1),
+(240215, 70264, 1, 1, 1, -7242.62, 931.894, 303.523, 0.27742, 0, 0, 0.138265, 0.990395, 25, 0, 1),
+(240216, 70264, 1, 1, 1, -7240.76, 933.186, 304.251, 4.5225, 0, 0, 0.770957, -0.636887, 25, 0, 1),
+(240217, 70264, 1, 1, 1, -7240.6, 934.86, 303.523, 1.03381, 0, 0, 0.494194, 0.869352, 25, 0, 1),
+(240218, 70264, 1, 1, 1, -7240.63, 927.437, 308.706, 3.04601, 0, 0, 0.998858, 0.0477748, 25, 0, 1),
+(240219, 70264, 1, 1, 1, -7239.85, 928.99, 306.613, 4.15651, 0, 0, 0.873982, -0.485958, 25, 0, 1),
+(240220, 70264, 1, 1, 1, -7239.49, 930.882, 305.622, 0.293923, 0, 0, 0.146433, 0.989221, 25, 0, 1),
+(240221, 70264, 1, 1, 1, -7243.6, 927.232, 307.087, 2.75142, 0, 0, 0.981031, 0.19385, 25, 0, 1),
+(240222, 70264, 1, 1, 1, -7243.98, 921.131, 303.523, 0.378774, 0, 0, 0.188257, 0.98212, 25, 0, 1),
+(240223, 70264, 1, 1, 1, -7245.03, 918.867, 303.523, 5.00398, 0, 0, 0.596875, -0.802334, 25, 0, 1),
+(240224, 70264, 1, 1, 1, -7243.15, 916.057, 303.523, 0.849226, 0, 0, 0.411968, 0.911198, 25, 0, 1),
+(240225, 70264, 1, 1, 1, -7240.85, 916.565, 303.523, 2.12943, 0, 0, 0.87465, 0.484755, 25, 0, 1),
+(240226, 70264, 1, 1, 1, -7245.19, 916.681, 303.523, 0.8453, 0, 0, 0.410179, 0.912005, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (8009248, 5, 9248, 'Arena Flat Steel', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240141, 8009248, 1, 1, 1, -7226.12, 929.725, 303.755, 0.169878, 0, 0, 0.0848367, 0.996395, 25, 0, 1),
+(9119088, 8009248, 1, 1, 1, -1823.82, -4584.27, -109.975, 5.70834, 0, 0, 0.283482, -0.958978, 300, 0, 1),
+(240149, 8009248, 1, 1, 1, -7227.33, 920.772, 306.682, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240147, 8009248, 1, 1, 1, -7226.91, 923.893, 305.622, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240144, 8009248, 1, 1, 1, -7226.49, 926.943, 304.55, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(9119083, 8009248, 1, 1, 1, -1823.47, -4583.57, -110.052, 4.20586, 0, 0, 0.861725, -0.507375, 300, 0, 1),
+(9347465, 8009248, 1, 1, 1, 6459.17, -4273.97, 667.048, 3.94114, 0, 0, 0.921148, -0.389212, 300, 0, 1),
+(9347468, 8009248, 1, 1, 1, 6474.25, -4258.45, 665.93, 3.94114, 0, 0, 0.921148, -0.389212, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (181640, 7, 6690, 'Arena Throne', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240150, 181640, 1, 1, 1, -7228.43, 912.741, 306.682, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240152, 181640, 1, 1, 1, -7235.39, 917.648, 306.682, 0.438242, 0, 0, 0.217372, 0.976089, 25, 0, 1),
+(240153, 181640, 1, 1, 1, -7220.81, 916.125, 306.681, 2.44007, 0, 0, 0.939112, 0.343611, 25, 0, 1),
+(240155, 181640, 1, 1, 1, -7218.34, 922.78, 306.683, 2.96331, 0, 0, 0.99603, 0.0890233, 25, 0, 1),
+(240160, 181640, 1, 1, 1, -7236.27, 924.809, 306.682, 6.1303, 0, 0, 0.0763687, -0.99708, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (186393, 5, 6725, 'Arena Bleachers', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(9365229, 186393, 1, 1, 1, -3067.83, 2199.85, 43.8142, 1.85265, 0, 0, 0.799417, 0.600776, 300, 0, 1),
+(9365139, 186393, 1, 1, 1, -2789.46, 2291.79, 53.9035, 2.34029, 0, 0, 0.920808, 0.390016, 300, 0, 1),
+(240010, 186393, 1, 1, 1, -7162.65, 959.809, 303.523, 4.58374, 0, 0, 0.751097, -0.660192, 25, 0, 1),
+(240008, 186393, 1, 1, 1, -7158.73, 989.066, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239922, 186393, 1, 1, 1, -7279.56, 975.823, 303.523, 4.57633, 0, 0, 0.753539, -0.657403, 25, 0, 1),
+(239997, 186393, 1, 1, 1, -7159.63, 980.321, 306.361, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(239913, 186393, 1, 1, 1, -7275.58, 1004.97, 303.523, 1.43885, 0, 0, 0.658953, 0.752184, 25, 0, 1),
+(239923, 186393, 1, 1, 1, -7277.64, 990.373, 306.361, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(239933, 186393, 1, 1, 1, -7278.38, 984.389, 306.36, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(239934, 186393, 1, 1, 1, -7276.92, 996.3, 306.36, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1),
+(240065, 186393, 1, 1, 1, -7248.77, 1032.2, 306.361, 3.77837, 0, 0, 0.949741, -0.313037, 25, 0, 1),
+(240080, 186393, 1, 1, 1, -7174.38, 1012.29, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240064, 186393, 1, 1, 1, -7259.13, 1024.25, 306.361, 0.640679, 0, 0, 0.314889, 0.949129, 25, 0, 1),
+(240100, 186393, 1, 1, 1, -7262.34, 949.284, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240128, 186393, 1, 1, 1, -7187.33, 939.703, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240024, 186393, 1, 1, 1, -7252.32, 1026.1, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(239992, 186393, 1, 1, 1, -7160.45, 974.339, 306.361, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(239994, 186393, 1, 1, 1, -7161.27, 968.374, 306.362, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1),
+(240227, 186393, 1, 1, 1, -7176.13, 1019.19, 306.361, 5.36606, 0, 0, 0.442661, -0.896689, 25, 0, 1),
+(240228, 186393, 1, 1, 1, -7168.2, 1008.91, 306.36, 2.24018, 0, 0, 0.900139, 0.435603, 25, 0, 1),
+(240229, 186393, 1, 1, 1, -7260.57, 942.307, 306.36, 2.22945, 0, 0, 0.89779, 0.440424, 25, 0, 1),
+(240230, 186393, 1, 1, 1, -7268.58, 952.669, 306.36, 5.36319, 0, 0, 0.443945, -0.896054, 25, 0, 1),
+(240231, 186393, 1, 1, 1, -7180.39, 941.411, 306.36, 3.79612, 0, 0, 0.946925, -0.321454, 25, 0, 1),
+(240232, 186393, 1, 1, 1, -7190.67, 933.47, 306.36, 0.654529, 0, 0, 0.321454, 0.946925, 25, 0, 1),
+(9365230, 186393, 1, 1, 1, -3077.56, 2197.23, 42.7844, 1.83087, 0, 0, 0.792826, 0.609448, 300, 0, 1),
+(9365232, 186393, 1, 1, 1, -3504.66, 2071.59, 42.6084, 1.13352, 0, 0, 0.536904, 0.843644, 300, 0, 1),
+(9365244, 186393, 1, 1, 1, -4759.7, 1584.99, 84.6154, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365245, 186393, 1, 1, 1, -4758.94, 1578.86, 85.7949, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365246, 186393, 1, 1, 1, -4758.17, 1572.71, 87.2961, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1),
+(9365247, 186393, 1, 1, 1, -4757.39, 1566.47, 87.6473, 0.124395, 0, 0, 0.0621572, 0.998066, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (188596, 5, 7812, 'Arena Pedestal', '', '', '', 0, 4, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(60046, 188596, 571, 1, 1, 3404.73, -5394.46, 267.362, 1.18682, 0, 0, 0, 1, 300, 100, 0),
+(239948, 188596, 1, 1, 1, -7164.57, 975.06, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239950, 188596, 1, 1, 1, -7163.66, 981.741, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240026, 188596, 1, 1, 1, -7257.12, 1032.41, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240090, 188596, 1, 1, 1, -7268.73, 944.317, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240015, 188596, 1, 1, 1, -7255.01, 1029.64, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240091, 188596, 1, 1, 1, -7270.72, 946.901, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(239658, 188596, 1, 1, 1, -7276.42, 1000.47, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239657, 188596, 1, 1, 1, -7276.87, 997.127, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239656, 188596, 1, 1, 1, -7277.33, 993.788, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239655, 188596, 1, 1, 1, -7277.78, 990.448, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239669, 188596, 1, 1, 1, -7273.63, 989.883, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239661, 188596, 1, 1, 1, -7279.1, 980.338, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239670, 188596, 1, 1, 1, -7273.17, 993.224, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239672, 188596, 1, 1, 1, -7272.26, 999.903, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239659, 188596, 1, 1, 1, -7278.22, 987.078, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239660, 188596, 1, 1, 1, -7278.66, 983.707, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239671, 188596, 1, 1, 1, -7272.72, 996.564, 303.523, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239673, 188596, 1, 1, 1, -7274.08, 986.518, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239674, 188596, 1, 1, 1, -7274.54, 983.151, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239675, 188596, 1, 1, 1, -7275, 979.786, 303.524, 1.43571, 0, 0, 0.65777, 0.753219, 25, 0, 1),
+(239949, 188596, 1, 1, 1, -7164.12, 978.4, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240077, 188596, 1, 1, 1, -7166.01, 1014.58, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239960, 188596, 1, 1, 1, -7160.4, 974.416, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239951, 188596, 1, 1, 1, -7163.21, 985.081, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240028, 188596, 1, 1, 1, -7259.67, 1030.47, 303.523, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(239958, 188596, 1, 1, 1, -7161.31, 967.734, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240068, 188596, 1, 1, 1, -7168.78, 1012.46, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240069, 188596, 1, 1, 1, -7174.66, 1020.19, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240072, 188596, 1, 1, 1, -7166.81, 1009.87, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240067, 188596, 1, 1, 1, -7170.75, 1015.05, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240066, 188596, 1, 1, 1, -7172.72, 1017.64, 303.524, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239961, 188596, 1, 1, 1, -7159.95, 977.758, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239955, 188596, 1, 1, 1, -7165.94, 964.962, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239957, 188596, 1, 1, 1, -7161.76, 964.393, 303.523, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240027, 188596, 1, 1, 1, -7254.53, 1034.39, 303.524, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240075, 188596, 1, 1, 1, -7169.95, 1019.76, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(239966, 188596, 1, 1, 1, -7159.03, 984.508, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239962, 188596, 1, 1, 1, -7159.49, 981.1, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239952, 188596, 1, 1, 1, -7165.03, 971.695, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239959, 188596, 1, 1, 1, -7160.85, 971.074, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(239954, 188596, 1, 1, 1, -7165.49, 968.329, 303.524, 1.43571, 0, 0, 0.657771, 0.753218, 25, 0, 1),
+(240124, 188596, 1, 1, 1, -7179.38, 939.825, 303.523, 1.78622, 0, 0, 0.779027, 0.626991, 25, 0, 1),
+(240125, 188596, 1, 1, 1, -7189.66, 932.069, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240092, 188596, 1, 1, 1, -7267.97, 949.005, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240098, 188596, 1, 1, 1, -7262.1, 941.384, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240099, 188596, 1, 1, 1, -7259.35, 943.486, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240096, 188596, 1, 1, 1, -7266.02, 946.459, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240097, 188596, 1, 1, 1, -7264.05, 943.929, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240095, 188596, 1, 1, 1, -7266.78, 941.771, 303.524, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240094, 188596, 1, 1, 1, -7267.21, 953.693, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240121, 188596, 1, 1, 1, -7187.05, 934.013, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240093, 188596, 1, 1, 1, -7269.95, 951.589, 303.523, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240127, 188596, 1, 1, 1, -7181.46, 942.585, 303.523, 2.57948, 0, 0, 0.960763, 0.27737, 25, 0, 1),
+(240120, 188596, 1, 1, 1, -7184.97, 931.254, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240119, 188596, 1, 1, 1, -7179.81, 935.147, 303.524, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240123, 188596, 1, 1, 1, -7181.94, 937.892, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240126, 188596, 1, 1, 1, -7191.74, 934.827, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240118, 188596, 1, 1, 1, -7182.37, 933.215, 303.524, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240122, 188596, 1, 1, 1, -7184.5, 935.96, 303.523, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(240076, 188596, 1, 1, 1, -7167.98, 1017.17, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240017, 188596, 1, 1, 1, -7260.11, 1025.76, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240021, 188596, 1, 1, 1, -7247.73, 1030.83, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240020, 188596, 1, 1, 1, -7249.82, 1033.58, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240019, 188596, 1, 1, 1, -7252.42, 1031.61, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240023, 188596, 1, 1, 1, -7258.02, 1023.01, 303.523, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240016, 188596, 1, 1, 1, -7257.56, 1027.7, 303.524, 5.3627, 0, 0, 0.444165, -0.895945, 25, 0, 1),
+(240073, 188596, 1, 1, 1, -7169.55, 1007.76, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240074, 188596, 1, 1, 1, -7177.41, 1018.09, 303.523, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (70264, 5, 6752, 'Arena Ice Block', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(240193, 70264, 1, 1, 1, -7210.52, 912.412, 304.893, 2.5155, 0, 0, 0.9514, 0.307959, 25, 0, 1),
+(240164, 70264, 1, 1, 1, -7211.89, 921.652, 307.653, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240166, 70264, 1, 1, 1, -7211.89, 921.652, 303.524, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240167, 70264, 1, 1, 1, -7211.64, 923.561, 304.714, 3.01201, 0, 0, 0.997902, 0.0647469, 25, 0, 1),
+(240168, 70264, 1, 1, 1, -7210.66, 920.395, 305.123, 3.10238, 0, 0, 0.999808, 0.0196051, 25, 0, 1),
+(240169, 70264, 1, 1, 1, -7210, 922.433, 304.547, 3.52728, 0, 0, 0.981463, -0.191651, 25, 0, 1),
+(240170, 70264, 1, 1, 1, -7211.74, 925.442, 305.599, 3.55012, 0, 0, 0.97921, -0.202848, 25, 0, 1),
+(240171, 70264, 1, 1, 1, -7211.08, 927.887, 303.524, 2.53696, 0, 0, 0.954649, 0.297734, 25, 0, 1),
+(240172, 70264, 1, 1, 1, -7210.16, 925.499, 303.523, 0.171338, 0, 0, 0.0855642, 0.996333, 25, 0, 1),
+(240174, 70264, 1, 1, 1, -7212.64, 918.485, 307.331, 2.88561, 0, 0, 0.99182, 0.127644, 25, 0, 1),
+(240175, 70264, 1, 1, 1, -7213.07, 916.643, 307.346, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240176, 70264, 1, 1, 1, -7213.5, 915.324, 306.69, 4.4564, 0, 0, 0.791581, -0.611065, 25, 0, 1),
+(240177, 70264, 1, 1, 1, -7213.94, 913.631, 308.328, 2.57459, 0, 0, 0.960082, 0.27972, 25, 0, 1),
+(240178, 70264, 1, 1, 1, -7210.59, 918.498, 303.524, 2.23965, 0, 0, 0.900025, 0.435839, 25, 0, 1),
+(240179, 70264, 1, 1, 1, -7211, 916.593, 304.705, 2.5813, 0, 0, 0.961015, 0.276496, 25, 0, 1),
+(240180, 70264, 1, 1, 1, -7211.58, 914.537, 304.612, 5.18568, 0, 0, 0.521622, -0.853176, 25, 0, 1),
+(240181, 70264, 1, 1, 1, -7214.78, 911.262, 309.84, 2.45752, 0, 0, 0.942074, 0.335406, 25, 0, 1),
+(240182, 70264, 1, 1, 1, -7216.24, 912.227, 306.76, 5.43418, 0, 0, 0.411866, -0.911244, 25, 0, 1),
+(240183, 70264, 1, 1, 1, -7212.83, 912.539, 307.181, 2.37505, 0, 0, 0.927447, 0.373954, 25, 0, 1),
+(240184, 70264, 1, 1, 1, -7213.46, 909.984, 307.23, 0.549789, 0, 0, 0.271445, 0.962454, 25, 0, 1),
+(240194, 70264, 1, 1, 1, -7209.58, 914.14, 303.524, 3.51295, 0, 0, 0.982811, -0.184616, 25, 0, 1),
+(240195, 70264, 1, 1, 1, -7208.91, 916.507, 303.523, 3.29697, 0, 0, 0.996984, -0.0776098, 25, 0, 1),
+(240196, 70264, 1, 1, 1, -7208.91, 920.253, 303.524, 3.50117, 0, 0, 0.983881, -0.178823, 25, 0, 1),
+(240197, 70264, 1, 1, 1, -7211.93, 910.935, 303.523, 2.14636, 0, 0, 0.878724, 0.477331, 25, 0, 1),
+(240198, 70264, 1, 1, 1, -7211.66, 909.391, 304.125, 3.06528, 0, 0, 0.999272, 0.0381473, 25, 0, 1),
+(240199, 70264, 1, 1, 1, -7243.47, 918.183, 306.827, 2.88084, 0, 0, 0.991513, 0.130006, 25, 0, 1),
+(240200, 70264, 1, 1, 1, -7242.56, 920.043, 306.432, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240202, 70264, 1, 1, 1, -7242.34, 922.252, 307.37, 4.61579, 0, 0, 0.740422, -0.672143, 25, 0, 1),
+(240203, 70264, 1, 1, 1, -7241.58, 918.298, 307.496, 5.83709, 0, 0, 0.221202, -0.975228, 25, 0, 1),
+(240204, 70264, 1, 1, 1, -7242.13, 920.107, 308.89, 6.18659, 0, 0, 0.0482802, -0.998834, 25, 0, 1),
+(240205, 70264, 1, 1, 1, -7240.56, 920.002, 306.682, 3.3923, 0, 0, 0.992153, -0.125027, 25, 0, 1),
+(240206, 70264, 1, 1, 1, -7243.02, 924.059, 309.946, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240207, 70264, 1, 1, 1, -7243.01, 924.088, 305.274, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240208, 70264, 1, 1, 1, -7243.04, 924.253, 303.523, 6.17654, 0, 0, 0.0532979, -0.998579, 25, 0, 1),
+(240209, 70264, 1, 1, 1, -7241.35, 924.009, 307.062, 1.96681, 0, 0, 0.83239, 0.55419, 25, 0, 1),
+(240210, 70264, 1, 1, 1, -7241.94, 925.8, 305.81, 5.47362, 0, 0, 0.393821, -0.919187, 25, 0, 1),
+(240211, 70264, 1, 1, 1, -7241.6, 928.466, 303.523, 6.04382, 0, 0, 0.119399, -0.992846, 25, 0, 1),
+(240212, 70264, 1, 1, 1, -7241.24, 930.286, 305.206, 3.14491, 0, 0, 0.999999, -0.00165872, 25, 0, 1),
+(240213, 70264, 1, 1, 1, -7243.68, 926.66, 303.523, 5.75479, 0, 0, 0.261137, -0.965302, 25, 0, 1),
+(240214, 70264, 1, 1, 1, -7242.97, 929.298, 303.523, 5.94014, 0, 0, 0.170683, -0.985326, 25, 0, 1),
+(240215, 70264, 1, 1, 1, -7242.62, 931.894, 303.523, 0.27742, 0, 0, 0.138265, 0.990395, 25, 0, 1),
+(240216, 70264, 1, 1, 1, -7240.76, 933.186, 304.251, 4.5225, 0, 0, 0.770957, -0.636887, 25, 0, 1),
+(240217, 70264, 1, 1, 1, -7240.6, 934.86, 303.523, 1.03381, 0, 0, 0.494194, 0.869352, 25, 0, 1),
+(240218, 70264, 1, 1, 1, -7240.63, 927.437, 308.706, 3.04601, 0, 0, 0.998858, 0.0477748, 25, 0, 1),
+(240219, 70264, 1, 1, 1, -7239.85, 928.99, 306.613, 4.15651, 0, 0, 0.873982, -0.485958, 25, 0, 1),
+(240220, 70264, 1, 1, 1, -7239.49, 930.882, 305.622, 0.293923, 0, 0, 0.146433, 0.989221, 25, 0, 1),
+(240221, 70264, 1, 1, 1, -7243.6, 927.232, 307.087, 2.75142, 0, 0, 0.981031, 0.19385, 25, 0, 1),
+(240222, 70264, 1, 1, 1, -7243.98, 921.131, 303.523, 0.378774, 0, 0, 0.188257, 0.98212, 25, 0, 1),
+(240223, 70264, 1, 1, 1, -7245.03, 918.867, 303.523, 5.00398, 0, 0, 0.596875, -0.802334, 25, 0, 1),
+(240224, 70264, 1, 1, 1, -7243.15, 916.057, 303.523, 0.849226, 0, 0, 0.411968, 0.911198, 25, 0, 1),
+(240225, 70264, 1, 1, 1, -7240.85, 916.565, 303.523, 2.12943, 0, 0, 0.87465, 0.484755, 25, 0, 1),
+(240226, 70264, 1, 1, 1, -7245.19, 916.681, 303.523, 0.8453, 0, 0, 0.410179, 0.912005, 25, 0, 1);
+REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('25266','0','0','0','0','0','24818','3422','24819','24821','Arena Gambler','','','0','255','255','0','35','0','1','1.14286','1','0','0','0','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','5','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','','1');
+REPLACE INTO `creature` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`modelid`,`equipment_id`,`position_x`,`position_y`,`position_z`,`orientation`,`spawntimesecs`,`spawndist`,`currentwaypoint`,`curhealth`,`curmana`,`MovementType`,`npcflag`,`unit_flags`,`dynamicflags`, `VerifiedBuild`) VALUES
+(1112166, 25266, 1, 1, 1, 0, 0, -7272.97, 986.543, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112165, 25266, 1, 1, 1, 0, 0, -7272, 994.955, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112163, 25266, 1, 1, 1, 0, 0, -7162.96, 966.158, 307.122, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112164, 25266, 1, 1, 1, 0, 0, -7273.19, 989.977, 306.361, 6.18204, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112162, 25266, 1, 1, 1, 0, 0, -7160.46, 971.542, 308.005, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112160, 25266, 1, 1, 1, 0, 0, -7166.61, 968.537, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112161, 25266, 1, 1, 1, 0, 0, -7165.4, 978.728, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112159, 25266, 1, 1, 1, 0, 0, -7166.34, 970.852, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112158, 25266, 1, 1, 1, 0, 0, -7165.9, 974.529, 306.36, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112157, 25266, 1, 1, 1, 0, 0, -7162.03, 975.112, 306.944, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112145, 25266, 1, 1, 1, 0, 0, -7277.48, 986.356, 307.508, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112146, 25266, 1, 1, 1, 0, 0, -7277.03, 989.028, 307.5, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112156, 25266, 1, 1, 1, 0, 0, -7161.6, 978.72, 306.836, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112155, 25266, 1, 1, 1, 0, 0, -7159.16, 978.43, 308.144, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112152, 25266, 1, 1, 1, 0, 0, -7160.59, 981.296, 307.276, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112153, 25266, 1, 1, 1, 0, 0, -7158.82, 981.086, 308.239, 3.02317, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112150, 25266, 1, 1, 1, 0, 0, -7276.97, 995.476, 307.962, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112151, 25266, 1, 1, 1, 0, 0, -7275.67, 995.258, 307.121, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112149, 25266, 1, 1, 1, 0, 0, -7277.57, 991.893, 307.982, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112148, 25266, 1, 1, 1, 0, 0, -7275.89, 991.613, 307.009, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0),
+(1112144, 25266, 1, 1, 1, 0, 0, -7277.83, 984.264, 307.587, 6.11808, 300, 0, 0, 42, 0, 2, 0, 0, 0, 0);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (178764, 5, 5453, 'Arena Rope Line', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(239891, 178764, 1, 1, 1, -7272.6, 985.626, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239897, 178764, 1, 1, 1, -7270.77, 999.019, 306.36, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239896, 178764, 1, 1, 1, -7271.12, 996.481, 306.36, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239893, 178764, 1, 1, 1, -7272.26, 988.172, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239895, 178764, 1, 1, 1, -7271.48, 993.817, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239894, 178764, 1, 1, 1, -7271.88, 990.953, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239888, 178764, 1, 1, 1, -7273.33, 980.292, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239889, 178764, 1, 1, 1, -7272.95, 983.06, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239886, 178764, 1, 1, 1, -7273.7, 977.636, 306.361, 6.1481, 0, 0, 0.0674923, -0.99772, 25, 0, 1),
+(239906, 178764, 1, 1, 1, -7276.49, 978.036, 306.361, 4.59361, 0, 0, 0.747829, -0.663891, 25, 0, 1),
+(239903, 178764, 1, 1, 1, -7270.44, 1001.47, 306.36, 1.43885, 0, 0, 0.658953, 0.752184, 25, 0, 1),
+(239946, 178764, 1, 1, 1, -7281.08, 978.658, 306.36, 6.14417, 0, 0, 0.0694537, -0.997585, 25, 0, 1),
+(239968, 178764, 1, 1, 1, -7164.82, 986.986, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239972, 178764, 1, 1, 1, -7165.9, 978.853, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239977, 178764, 1, 1, 1, -7167.68, 965.418, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239975, 178764, 1, 1, 1, -7166.97, 970.755, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(9051186, 178764, 1, 1, 1, -7168, 963.017, 306.36, 4.61838, 0, 0, 0.739552, -0.6731, 300, 0, 1),
+(239973, 178764, 1, 1, 1, -7166.25, 976.209, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239971, 178764, 1, 1, 1, -7165.54, 981.532, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239974, 178764, 1, 1, 1, -7166.62, 973.406, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239970, 178764, 1, 1, 1, -7165.18, 984.315, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1),
+(239985, 178764, 1, 1, 1, -7161.79, 986.521, 306.361, 1.42079, 0, 0, 0.652132, 0.758105, 25, 0, 1),
+(239976, 178764, 1, 1, 1, -7167.32, 968.097, 306.36, 3.01043, 0, 0, 0.99785, 0.0655325, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194593, 5, 8620, 'Ironforge Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67907, 194593, 571, 1, 1, 8460.36, 927.153, 544.916, 3.14159, 0, 0, 0, 1, 180, 255, 1),
+(239944, 194593, 1, 1, 1, -7278.25, 996.463, 308.409, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194595, 5, 8616, 'Darnassus Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67909, 194595, 571, 1, 1, 8459.95, 992.174, 544.922, -2.94959, 0, 0, 0, 1, 180, 255, 1),
+(239941, 194595, 1, 1, 1, -7279.28, 990.573, 308.462, 6.1613, 0, 0, 0.0609072, -0.998143, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194589, 5, 8617, 'Exodar Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67903, 194589, 571, 1, 1, 8439.42, 1010.37, 544.698, -1.50971, 0, 0, 0, 1, 180, 255, 1),
+(73361, 194589, 571, 1, 1, 8439.42, 1010.37, 544.698, -1.50971, 0, 0, 0, 0, 0, 0, 1),
+(9180728, 194589, 1, 1, 1, -7279.68, 984.602, 308.397, 6.1613, 0, 0, 0.0609048, -0.998144, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (170592, 7, 2810, 'Arena Throne', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(223623, 170592, 1, 1, 1, -1824.72, -4583.54, -115.128, 4.53332, 0, 0, 0.767499, -0.64105, 25, 0, 1),
+(240063, 170592, 1, 1, 1, -7256.76, 1032, 307.052, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240085, 170592, 1, 1, 1, -7168.76, 1016.56, 306.909, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240109, 170592, 1, 1, 1, -7268.44, 944.602, 307.092, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240133, 170592, 1, 1, 1, -7182.67, 933.532, 306.979, 2.21718, 0, 0, 0.895071, 0.445923, 25, 0, 1),
+(9092906, 170592, 1, 1, 1, -9781.68, -2860.63, 119.206, 0.279273, 0, 0, 0.139183, 0.990267, 300, 0, 1),
+(9092464, 170592, 1, 1, 1, -7310.55, 2233.88, 72.4531, 0.480897, 0, 0, 0.238138, 0.971231, 300, 0, 1),
+(9109862, 170592, 1, 1, 1, 5855.94, -1995.04, 689.745, 5.42784, 0, 0, 0.414754, -0.909934, 300, 0, 1),
+(9109906, 170592, 1, 1, 1, 5871.12, -2012.51, 689.701, 2.28655, 0, 0, 0.909997, 0.414615, 300, 0, 1),
+(9330403, 170592, 1, 1, 1, -5082.57, -1103.69, 87.1186, 0.534018, 0, 0, 0.263848, 0.964564, 300, 0, 1),
+(9330402, 170592, 1, 1, 1, -5060.65, -1089.75, 86.936, 3.74954, 0, 0, 0.954155, -0.299314, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194606, 5, 8615, 'Horde Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67920, 194606, 571, 1, 1, 8307.43, 705.927, 553.644, 0.253072, 0, 0, 0, 1, 180, 255, 1),
+(240136, 194606, 1, 1, 1, -7272.44, 946.637, 306.36, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1),
+(240137, 194606, 1, 1, 1, -7267.45, 940.127, 306.361, 0.654239, 0, 0, 0.321317, 0.946972, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194594, 5, 8623, 'Alliance Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67908, 194594, 571, 1, 1, 8460.08, 950.043, 545.051, -3.09792, 0, 0, 0, 1, 180, 255, 1),
+(9180720, 194594, 1, 1, 1, -7184.78, 929.577, 306.361, 2.21718, 0, 0, 0.895071, 0.445924, 300, 0, 1),
+(9180717, 194594, 1, 1, 1, -7178.15, 934.61, 306.362, 2.24088, 0, 0, 0.900292, 0.435286, 300, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194607, 5, 8621, 'Orgrimmar Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67921, 194607, 571, 1, 1, 8338.74, 687.096, 553.701, 1.59698, 0, 0, 0, 1, 180, 255, 1),
+(240004, 194607, 1, 1, 1, -7159.92, 968.19, 308.414, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194605, 5, 8622, 'Silvermoon City Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67919, 194605, 571, 1, 1, 8319.33, 744.352, 553.701, -0.98611, 0, 0, 0, 1, 180, 255, 1),
+(240003, 194605, 1, 1, 1, -7158.89, 974.126, 308.49, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194604, 5, 8624, 'Thunder Bluff Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(67918, 194604, 571, 1, 1, 8357.72, 744.694, 553.627, -2.30383, 0, 0, 0, 1, 180, 255, 1),
+(240005, 194604, 1, 1, 1, -7158.29, 979.98, 308.413, 3.00559, 0, 0, 0.997689, 0.0679491, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194592, 5, 8619, 'Gnomeregan Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(72058, 194592, 571, 1, 1, 8458.11, 905.744, 546.489, 2.82392, 0, 0, 0.987412, 0.158169, 30, 0, 1),
+(72043, 194592, 571, 1, 1, 8670.57, 692.054, 547.522, 1.89567, 0, 0, 0.812154, 0.583443, 30, 0, 1),
+(67906, 194592, 571, 1, 1, 8459.21, 905.564, 545.516, 2.75761, 0, 0, 0, 1, 180, 255, 1),
+(240088, 194592, 1, 1, 1, -7164.78, 1014.48, 306.361, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1),
+(240089, 194592, 1, 1, 1, -7169.75, 1021, 306.36, 3.79203, 0, 0, 0.94758, -0.319518, 25, 0, 1);
+REPLACE INTO `gameobject_template` (`entry`, `type`, `displayId`, `name`, `IconName`, `castBarCaption`, `unk1`, `faction`, `flags`, `size`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `data0`, `data1`, `data2`, `data3`, `data4`, `data5`, `data6`, `data7`, `data8`, `data9`, `data10`, `data11`, `data12`, `data13`, `data14`, `data15`, `data16`, `data17`, `data18`, `data19`, `data20`, `data21`, `data22`, `data23`, `AIName`, `ScriptName`, `VerifiedBuild`) VALUES (194608, 5, 8618, 'Undercity Banner', '', '', '', 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '', '', 1);
+REPLACE INTO `gameobject` (`guid`,`id`,`map`,`spawnMask`,`phaseMask`,`position_x`,`position_y`,`position_z`,`orientation`,`rotation0`,`rotation1`,`rotation2`,`rotation3`,`spawntimesecs`,`animprogress`,`state`) VALUES
+(72037, 194608, 571, 1, 1, 8368.94, 708.93, 553.772, 2.93164, 0, 0, 0.994495, 0.104784, 30, 0, 1),
+(240087, 194608, 1, 1, 1, -7254.69, 1036.01, 306.361, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1),
+(240086, 194608, 1, 1, 1, -7261.24, 1031, 306.36, 5.3627, 0, 0, 0.444166, -0.895945, 25, 0, 1);
diff --git a/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql b/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
new file mode 100644
index 0000000..edccae3
--- /dev/null
+++ b/sql/TrinityCore-Patches/BountyHunter/characters.BountyHunter.sql
@@ -0,0 +1,38 @@
+-- phpMyAdmin SQL Dump
+-- version 4.1.12
+-- http://www.phpmyadmin.net
+--
+-- Host: localhost:3306
+-- Erstellungszeit: 17. Jun 2014 um 20:34
+-- Server Version: 5.5.35-0+wheezy1
+-- PHP-Version: 5.4.16
+
+SET SQL_MODE = "NO_AUTO_VALUE_ON_ZERO";
+SET time_zone = "+00:00";
+
+
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
+/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
+/*!40101 SET NAMES utf8 */;
+
+--
+-- Datenbank: `characters`
+--
+
+-- --------------------------------------------------------
+
+--
+-- Table Structure for `bounties`
+--
+
+CREATE TABLE IF NOT EXISTS `bounties` (
+  `guid` int(200) unsigned NOT NULL,
+  `visual` varchar(200) NOT NULL,
+  `price` int(200) NOT NULL,
+  PRIMARY KEY (`guid`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
+/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
+/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
diff --git a/sql/TrinityCore-Patches/CrossFactionBG/world.AVFix.sql b/sql/TrinityCore-Patches/CrossFactionBG/world.AVFix.sql
new file mode 100644
index 0000000..a0c7eb9
--- /dev/null
+++ b/sql/TrinityCore-Patches/CrossFactionBG/world.AVFix.sql
@@ -0,0 +1,3 @@
+UPDATE creature_template SET faction = 1 WHERE entry IN (4255,4257,5134,5135,5139,11948,11949,11997,12050,12096,12127,13086,13096,13138,13216,13257,13296,13298,13299,13317,13318,13319,13320,13326,13327,13331,13422,13437,13438,13439,13442,13443,13447,13546,13576,13577,13598,13617,13797,14187,14188,14284,14762,14763,14765,14766,14768,14769,12047,13396,13358,13080,13078);
+
+UPDATE creature_template SET faction = 2 WHERE entry IN (2225,3343,3625,10364,10367,11946,11947,11998,12051,12052,12053,12097,12121,12122,13088,13089,13097,13137,13140,13143,13144,13145,13146,13147,13152,13153,13154,13176,13179,13180,13181,13218,13236,13284,13316,13359,13377,13397,13425,13428,13441,13448,13536,13539,13545,13597,13616,13618,13798,14185,14186,14282,14285,14772,14773,14774,14775,14776,14777,13332,13099,13079);
diff --git a/sql/TrinityCore-Patches/Fake_Players/characters.fake_players.sql b/sql/TrinityCore-Patches/Fake_Players/characters.fake_players.sql
new file mode 100644
index 0000000..0b4bf14
--- /dev/null
+++ b/sql/TrinityCore-Patches/Fake_Players/characters.fake_players.sql
@@ -0,0 +1,40 @@
+CREATE TABLE IF NOT EXISTS `characters_fake` (
+  `name` varchar(36) NOT NULL,
+  `race` mediumint(3) NOT NULL DEFAULT '0',
+  `class` mediumint(3) NOT NULL DEFAULT '0',
+  `level` mediumint(3) NOT NULL DEFAULT '0',
+  `zone` mediumint(9) NOT NULL DEFAULT '0',
+  `gender` mediumint(3) NOT NULL DEFAULT '0',
+  `online` datetime NOT NULL,
+  `lastup` datetime NOT NULL,
+  UNIQUE KEY `name` (`name`),
+  KEY `level` (`level`),
+  KEY `online` (`online`),
+  KEY `lastup` (`lastup`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+INSERT INTO `characters_fake` (`name`, `race`, `class`, `level`, `zone`, `gender`, `online`, `lastup`) VALUES
+('Drikish', 2, 8, 3, 22, 0, '2014-08-08 19:16:00', '2014-08-08 16:22:37'),
+('Sovelis', 3, 4, 5, 20, 0, '2014-08-08 21:27:44', '2014-08-08 16:22:37'),
+('Cuddles', 10, 2, 5, 31, 1, '2014-08-08 14:14:01', '2014-08-08 16:22:37'),
+('Epiasdv', 10, 2, 5, 45, 0, '2014-08-08 21:15:47', '2014-08-08 16:22:37'),
+('Mac', 1, 1, 4, 32, 1, '2014-08-08 11:51:35', '2014-08-08 18:19:40'),
+('Tiesto', 5, 1, 3, 23, 0, '2014-08-08 14:29:51', '2014-08-08 16:22:37'),
+('Ihavfacebook', 10, 2, 3, 18, 0, '2014-08-08 04:24:43', '2014-08-08 23:49:06'),
+('Mimik', 1, 2, 3, 22, 1, '2014-08-08 12:45:17', '2014-08-08 15:56:40'),
+('Deadmau', 1, 1, 6, 6, 1, '2014-08-08 05:43:07', '2014-08-08 16:22:37'),
+('Smoosh', 3, 2, 3, 15, 1, '2014-08-08 21:15:13', '2014-08-08 16:22:37'),
+('Shadowcrest', 4, 3, 5, 3, 1, '2014-08-08 13:09:17', '2014-08-08 15:07:46'),
+('Prox', 5, 1, 3, 22, 0, '2014-08-08 06:12:15', '2014-08-08 16:22:37'),
+('Rovip', 4, 11, 3, 1, 0, '2014-08-08 21:23:45', '2014-08-08 15:02:50'),
+('Ryan', 1, 2, 6, 40, 0, '2014-08-08 04:50:43', '2014-08-08 16:22:37'),
+('Holysmite', 4, 1, 4, 43, 0, '2014-08-08 17:54:05', '2014-08-08 19:59:12'),
+('Airagon', 6, 11, 1, 45, 0, '2014-08-08 11:46:37', '2014-08-08 20:18:07'),
+('Fracture', 5, 9, 5, 45, 0, '2014-08-08 22:02:27', '2014-08-08 14:35:01'),
+('Supershen', 3, 5, 2, 39, 0, '2014-08-08 10:15:35', '2014-08-08 17:53:00'),
+('Jana', 2, 1, 2, 11, 0, '2014-08-08 03:03:05', '2014-08-08 14:10:08'),
+('Gamm', 6, 11, 3, 38, 1, '2014-08-08 15:51:15', '2014-08-08 13:15:21'),
+('Emoarchie', 8, 4, 5, 5, 0, '2014-08-08 13:17:54', '2014-08-08 18:13:53'),
+('Melia', 5, 6, 57, 12, 0, '2014-08-08 09:21:15', '2014-08-08 16:22:37'),
+('Balu', 4, 4, 5, 42, 1, '2014-08-08 08:06:03', '2014-08-08 14:25:07'),
+('Jabari', 10, 2, 3, 25, 0, '2014-08-08 09:11:53', '2014-08-08 16:22:37');
diff --git a/sql/TrinityCore-Patches/Fake_Players/world.fake_players.sql b/sql/TrinityCore-Patches/Fake_Players/world.fake_players.sql
new file mode 100644
index 0000000..c1be608
--- /dev/null
+++ b/sql/TrinityCore-Patches/Fake_Players/world.fake_players.sql
@@ -0,0 +1,2 @@
+DELETE FROM `trinity_string` WHERE `entry` = 12001;
+INSERT INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (12001, 'Message: "Do not disturb".', NULL, NULL, NULL, NULL, NULL, NULL, NULL, ': " ".');
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
new file mode 100644
index 0000000..0846910
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/auth_guild_level_system.sql
@@ -0,0 +1,7 @@
+INSERT INTO `rbac_permissions` VALUES ('1000', 'Command: guild linfo');
+INSERT INTO `rbac_permissions` VALUES ('1001', 'Command: guild setlevel');
+INSERT INTO `rbac_permissions` VALUES ('1002', 'Command: guild givexp');
+
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1000');
+INSERT INTO `rbac_linked_permissions` VALUES ('192', '1001');
+INSERT INTO `rbac_linked_permissions` VALUES ('192', '1002');
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
new file mode 100644
index 0000000..ae05ff6
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/characters_guild_level_system.sql
@@ -0,0 +1,55 @@
+ALTER TABLE `guild` ADD `xp` INT(10) DEFAULT 0 NOT NULL AFTER `BankMoney`;
+ALTER TABLE `guild` ADD `level` TINYINT(3) DEFAULT 0 NOT NULL AFTER `xp`;
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for `guild_bonus_config`
+-- ----------------------------
+DROP TABLE IF EXISTS `guild_bonus_config`;
+CREATE TABLE `guild_bonus_config` (
+  `BonusId` smallint(5) NOT NULL DEFAULT '0',
+  `RequiredGuildLevel` tinyint(3) NOT NULL DEFAULT '0',
+  `comment` longtext CHARACTER SET utf8
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of guild_bonus_config
+-- ----------------------------
+INSERT INTO `guild_bonus_config` VALUES ('1', '1', 'Goldbonus | 5% Bonus gold for the guild bank');
+INSERT INTO `guild_bonus_config` VALUES ('2', '1', 'XP-Bonus | +5% XP at the end of quest or kill monsters');
+INSERT INTO `guild_bonus_config` VALUES ('3', '2', 'Faster Spirit | Double movement speed as spirit');
+INSERT INTO `guild_bonus_config` VALUES ('4', '2', 'Cheap repair | -25% Repair costs');
+INSERT INTO `guild_bonus_config` VALUES ('5', '3', 'Goldbonus-2 | 10% Bonus gold for the guild bank');
+INSERT INTO `guild_bonus_config` VALUES ('6', '4', 'Riding Pace | +5% Riding pace (Except Battlegrounds and Arenas)');
+INSERT INTO `guild_bonus_config` VALUES ('7', '4', 'Good Relationships | +5% Reputation gain');
+INSERT INTO `guild_bonus_config` VALUES ('8', '5', 'XP-Bonus-2 | +10% XP at the end of quest or kill monsters');
+INSERT INTO `guild_bonus_config` VALUES ('9', '6', 'Cheap Repair-2 | -50% Repair costs');
+INSERT INTO `guild_bonus_config` VALUES ('10', '6', 'Riding Pace-2 | +10% Riding pace (Except Battlegrounds and Arenas)');
+INSERT INTO `guild_bonus_config` VALUES ('11', '7', 'Good Relationships-2 | +10% Reputation gain');
+INSERT INTO `guild_bonus_config` VALUES ('12', '5', 'Bonus Honor | +5% Honor');
+INSERT INTO `guild_bonus_config` VALUES ('13', '8', 'Bonus Honor-2 | +10% Honor');
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for `guild_xp_for_next_level`
+-- ----------------------------
+DROP TABLE IF EXISTS `guild_xp_for_next_level`;
+CREATE TABLE `guild_xp_for_next_level` (
+  `level` tinyint(3) NOT NULL DEFAULT '0',
+  `xp_for_next_level` int(10) NOT NULL DEFAULT '0',
+  PRIMARY KEY (`level`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of guild_xp_for_next_level
+-- ----------------------------
+INSERT INTO `guild_xp_for_next_level` VALUES ('0', '8000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('1', '12000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('2', '18000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('3', '27000000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('4', '40500000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('5', '60750000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('6', '91125000');
+INSERT INTO `guild_xp_for_next_level` VALUES ('7', '136687500');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql b/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
new file mode 100644
index 0000000..fcf2396
--- /dev/null
+++ b/sql/TrinityCore-Patches/GuildLevelSystem/world_guild_level_system.sql
@@ -0,0 +1,7 @@
+DELETE FROM `trinity_string` WHERE `entry` IN (13000, 13001);
+INSERT INTO `trinity_string` VALUES ('13000', 'Guild Level: %u.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('13001', 'Guild Experience: %u/%u.', null, null, null, null, null, null, null, null);
+DELETE FROM `command` WHERE `permission` IN (1000, 1001, 1002);
+INSERT INTO `command` VALUES ('guild linfo', '1000', 'Syntax: .guild linfo');
+INSERT INTO `command` VALUES ('guild setlevel', '1001', 'Syntax: .guild setlevel $GuildName $Level');
+INSERT INTO `command` VALUES ('guild givexp', '1002', 'Syntax: .guild givexp $GuildName $Xp');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql b/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
new file mode 100644
index 0000000..61f7878
--- /dev/null
+++ b/sql/TrinityCore-Patches/Guildhouses/world_guildhouses.sql
@@ -0,0 +1,67 @@
+-- ----------------------------
+-- Table structure for guildhouses
+-- ----------------------------
+
+DROP TABLE IF EXISTS `guildhouses`;
+
+CREATE TABLE `guildhouses` (
+  `id` int(8) unsigned NOT NULL auto_increment,
+  `guildId` bigint(20) NOT NULL default '0',
+  `x` double NOT NULL,
+  `y` double NOT NULL,
+  `z` double NOT NULL,
+  `map` int(11) NOT NULL,
+  `comment` varchar(255) NOT NULL default '',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=42 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;
+
+-- ----------------------------
+-- Records
+-- ----------------------------
+INSERT INTO `guildhouses` VALUES
+('1', '0', '16222', '16266', '14.2', '1', 'GM Island'),
+('2', '0', '-10711', '2483', '8', '1', 'Tauren village at Veiled Sea (Silithus)'),
+('3', '0', '-8323', '-343', '146', '0', 'Fishing outside an Northshire Abbey (Elwynn Forest'),
+('4', '0', '7368', '-1560', '163', '1', 'Troll Village in mountains (Darkshore)'),
+('5', '0', '-4151', '-1400', '198', '0', 'Dwarven village outside Ironforge (Wetlands)'),
+('6', '0', '-1840', '-4233', '2.14', '0', 'Dwarven village (Arathi Highlands, Forbidding Sea)'),
+('8', '0', '-723', '-1076', '179', '1', 'Tauren camp (Mulgore, Red Rock)'),
+('9', '0', '-206', '1666', '80', '0', 'Shadowfang Keep an outside instance (Silverpine Forest)'),
+('10', '0', '-6374', '1262', '7', '0', 'Harbor house outside Stormwind (Elwynn Forest)'),
+('11', '0', '-8640', '580', '96', '0', 'Empty jail between canals (Stormwind) DELETE'),
+('12', '0', '-4844', '-1066', '502', '0', 'Old Ironforge'),
+('13', '0', '-4863', '-1658', '503.5', '0', 'Ironforge Airport'),
+('14', '0', '1146', '-165', '313', '37', 'Azshara Crater instance (Alliance entrance)'),
+('15', '0', '-123', '858', '298', '37', 'Azshara Crater instance (Horde entrance)'),
+('16', '0', '4303', '-2760', '16.8', '0', 'Quel\'Thalas Tower'),
+('17', '0', '-6161', '-790', '423', '0', 'Crashed gnome airplane (between Dun Morogh and Searing Gorge)'),
+('18', '0', '-11790', '-1640', '54.7', '0', 'Zul\'Gurub an outside instance (Stranglethorn Vale)'),
+('19', '0', '-11805', '-4754', '6', '1', 'Goblin village (Tanaris, South Seas)'),
+('20', '0', '-9296', '670', '132', '0', 'Villains camp outside an Stormwind (Elwynn Forest)'),
+('21', '0', '3414', '-3380', '142.2', '0', 'Stratholm an outside instance'),
+('22', '0', '4654', '-3772', '944', '1', 'Kalimdor Hyjal (Aka World Tree)'),
+('23', '0', '2176', '-4766', '55', '1', 'The Ring of Valor (Aka. Orgrimmar Arena)'),
+('24', '0', '1951.512085', '1530.475586', '247.288147', '1', 'Stonetalon Logging Camp'),
+('25', '0', '2813.660645', '2248.552979', '215.524643', '1', 'Stonetalon Ruins'),
+('28', '0', '9725.27', '-21.43', '20.03', '1', 'Teldrassil Furbold camp'),
+('29', '0', '-3855', '-3479', '579', '0', 'Wetlands mountain camp'),
+('30', '0', '-5362', '-2540', '485', '0', 'Ortell\'s Hideout'),
+('31', '0', '-12865', '-1396', '115', '0', 'Stranglethorn Secret Cave'),
+('32', '0', '-11073', '-1956', '39', '0', 'Karazhan Smiley'),
+('33', '0', '-11084', '-1801', '53', '0', 'Well of the Forgotten (Aka. Karazhan Crypt or Lower Karazhan)'),
+('34', '0', '1683.235474', '286.458801', '-45.451775', '0', 'Undercity Top Tier'),
+('35', '0', '-8521.3', '599.5', '101.399338', '0', 'Stormwind Cut-Throat Alley'),
+('36', '0', '-5933', '452', '509', '0', 'Forgotten gnome camp'),
+('37', '0', '-920.231323', '7096.489258', '170.35289', '530', 'Outland Nagrand : Newton\'s Remains'),
+('38', '0', '-2140.501953', '9142.6875', '137.041855', '530', 'Outland Nagrand : Tomb'),
+('39', '0', '-483.401794', '7461.944824', '186.120987', '530', 'Outland Nagrand: Challe\'s Home for Little Tykes'),
+('40', '0', '2387.753906', '3191.757324', '152.669388', '530', 'Outland Netherstorm: Nova\'s Shrine');
+
+-- *************************
+-- * NPC Guildhouse Keeper *
+-- *************************
+
+DELETE FROM creature_template WHERE `entry`=13;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('13','0','0','0','0','0','26789','0','0','0','Beltez','Guildhouse Keeper',NULL,'0','80','80','0','35','1','1','1.14286','0.75','0','0','1400','1900','1','1','1','0','0','8','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','guildmaster','12340');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Individuale_XP-Rate/auth_individuale_xp_Rate.sql b/sql/TrinityCore-Patches/Individuale_XP-Rate/auth_individuale_xp_Rate.sql
new file mode 100644
index 0000000..145342c
--- /dev/null
+++ b/sql/TrinityCore-Patches/Individuale_XP-Rate/auth_individuale_xp_Rate.sql
@@ -0,0 +1,5 @@
+INSERT INTO `rbac_permissions` VALUES ('1010', 'Command: modify xpkill');
+INSERT INTO `rbac_permissions` VALUES ('1011', 'Command: modify xpquest');
+
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1010');
+INSERT INTO `rbac_linked_permissions` VALUES ('195', '1011');
diff --git a/sql/TrinityCore-Patches/Individuale_XP-Rate/world_individuale_xp_Rate.sql b/sql/TrinityCore-Patches/Individuale_XP-Rate/world_individuale_xp_Rate.sql
new file mode 100644
index 0000000..5a757bf
--- /dev/null
+++ b/sql/TrinityCore-Patches/Individuale_XP-Rate/world_individuale_xp_Rate.sql
@@ -0,0 +1,9 @@
+DELETE FROM `trinity_string` WHERE `entry` IN (15000, 15001, 15002, 15003, 15004);
+INSERT INTO `trinity_string` VALUES ('15004', 'Current XpKill Rate: %f.$BCurrent XpQuest Rate: %f.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15003', 'The specified value is too low, it should be between 1 and 8.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15001', 'XpQuest Rate set to %f ', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15002', 'The specified value is too high, it should be between 1 and 8.', null, null, null, null, null, null, null, null);
+INSERT INTO `trinity_string` VALUES ('15000', 'XpKill Rate set to %f ', null, null, null, null, null, null, null, null);
+DELETE FROM `command` WHERE `permission` IN (1010, 1011);
+INSERT INTO `command` VALUES ('modify xpkill', '1010', 'Syntax: .modify xpkill #wert');
+INSERT INTO `command` VALUES ('modify xpquest', '1011', 'Syntax: .modify xpquest #wert');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql b/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
new file mode 100644
index 0000000..b0b67c6
--- /dev/null
+++ b/sql/TrinityCore-Patches/LevelNPC/world.levelnpc.sql
@@ -0,0 +1,5 @@
+-- Creature_template entry. Make sure entry number does not conflict.
+DELETE FROM `creature_template` WHERE `entry` = 60003;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60003','0','0','0','0','0','2591','0','0','0','Lucy','Level NPC','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','levelnpc','0');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/Player_Events/world.player_events.sql b/sql/TrinityCore-Patches/Player_Events/world.player_events.sql
new file mode 100644
index 0000000..1e76146
--- /dev/null
+++ b/sql/TrinityCore-Patches/Player_Events/world.player_events.sql
@@ -0,0 +1,75 @@
+/*
+Navicat MySQL Data Transfer
+
+Source Server         : Local
+Source Server Version : 50612
+Source Host           : localhost:3306
+Source Database       : tc_world
+
+Target Server Type    : MYSQL
+Target Server Version : 50612
+File Encoding         : 65001
+
+Date: 2014-07-11 05:24:41
+*/
+
+SET FOREIGN_KEY_CHECKS=0;
+
+-- ----------------------------
+-- Table structure for lil_actions
+-- ----------------------------
+DROP TABLE IF EXISTS `lil_actions`;
+CREATE TABLE `lil_actions` (
+  `id` int(10) unsigned NOT NULL,
+  `type` int(10) DEFAULT '0',
+  `avalue0` float DEFAULT '0',
+  `avalue1` float DEFAULT '0',
+  `avalue2` float DEFAULT '0',
+  `avalue3` float DEFAULT '0',
+  `avalue4` float DEFAULT '0',
+  `message` varchar(255) DEFAULT NULL,
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of lil_actions
+-- ----------------------------
+INSERT INTO `lil_actions` VALUES ('1', '1', '10000', '0', '0', '0', '0', 'CODEMSG');
+
+-- ----------------------------
+-- Table structure for lil_conditions
+-- ----------------------------
+DROP TABLE IF EXISTS `lil_conditions`;
+CREATE TABLE `lil_conditions` (
+  `id` int(10) unsigned NOT NULL,
+  `TCConditionType` int(10) DEFAULT '0',
+  `TCConditionEntry` int(10) DEFAULT '0',
+  `TCGameEventEntry` int(10) DEFAULT '0',
+  `PRace` int(1) DEFAULT '0',
+  `PClass` int(1) DEFAULT '0',
+  `CValue` int(10) DEFAULT '0',
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of lil_conditions
+-- ----------------------------
+INSERT INTO `lil_conditions` VALUES ('1', '0', '0', '0', '0', '0', '0');
+
+-- ----------------------------
+-- Table structure for lil_events
+-- ----------------------------
+DROP TABLE IF EXISTS `lil_events`;
+CREATE TABLE `lil_events` (
+  `id` int(10) unsigned NOT NULL,
+  `type` int(10) DEFAULT '0',
+  `condition` int(10) DEFAULT '0',
+  `action` int(10) DEFAULT '0',
+  PRIMARY KEY (`id`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+-- ----------------------------
+-- Records of lil_events
+-- ----------------------------
+INSERT INTO `lil_events` VALUES ('0', '0', '0', '0');
+INSERT INTO `lil_events` VALUES ('1', '1', '1', '1');
diff --git a/sql/TrinityCore-Patches/Reforging/characters.reforging.sql b/sql/TrinityCore-Patches/Reforging/characters.reforging.sql
new file mode 100644
index 0000000..9ac7bf6
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/characters.reforging.sql
@@ -0,0 +1,10 @@
+CREATE TABLE `custom_reforging` (
+	`GUID` INT(10) UNSIGNED NOT NULL COMMENT 'item guid low',
+	`increase` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`decrease` INT(10) UNSIGNED NOT NULL COMMENT 'stat_type',
+	`stat_value` INT(10) NOT NULL DEFAULT '0' COMMENT 'stat change',
+	`Owner` INT(10) UNSIGNED NULL DEFAULT NULL COMMENT 'player guid',
+	PRIMARY KEY (`GUID`)
+)
+COLLATE='utf8_general_ci'
+ENGINE=InnoDB;
diff --git a/sql/TrinityCore-Patches/Reforging/world.reforging.sql b/sql/TrinityCore-Patches/Reforging/world.reforging.sql
new file mode 100644
index 0000000..9a91aae
--- /dev/null
+++ b/sql/TrinityCore-Patches/Reforging/world.reforging.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190011,
+@Name = "Thaumaturge Vashreen";
+DELETE FROM `creature_template` WHERE `entry` = @Entry;
+INSERT INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `scale`, `rank`, `dmgschool`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`) VALUES
+(@Entry, 20988, 0, @Name, "Arcane Reforger", NULL, 0, 80, 80, 2, 35, 1, 1, 0, 0, 2000, 0, 1, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 0, 0, 1, 0, 0, 'REFORGER_NPC');
diff --git a/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
new file mode 100644
index 0000000..695b845
--- /dev/null
+++ b/sql/TrinityCore-Patches/SummonNPC/world.summonnpc-item.sql
@@ -0,0 +1,4 @@
+-- Example item:
+DELETE FROM `item_template` WHERE `entry` = 100000;
+insert into `item_template` (`entry`, `class`, `subclass`, `SoundOverrideSubclass`, `name`, `displayid`, `Quality`, `Flags`, `FlagsExtra`, `BuyCount`, `BuyPrice`, `SellPrice`, `InventoryType`, `AllowableClass`, `AllowableRace`, `ItemLevel`, `RequiredLevel`, `RequiredSkill`, `RequiredSkillRank`, `requiredspell`, `requiredhonorrank`, `RequiredCityRank`, `RequiredReputationFaction`, `RequiredReputationRank`, `maxcount`, `stackable`, `ContainerSlots`, `StatsCount`, `stat_type1`, `stat_value1`, `stat_type2`, `stat_value2`, `stat_type3`, `stat_value3`, `stat_type4`, `stat_value4`, `stat_type5`, `stat_value5`, `stat_type6`, `stat_value6`, `stat_type7`, `stat_value7`, `stat_type8`, `stat_value8`, `stat_type9`, `stat_value9`, `stat_type10`, `stat_value10`, `ScalingStatDistribution`, `ScalingStatValue`, `dmg_min1`, `dmg_max1`, `dmg_type1`, `dmg_min2`, `dmg_max2`, `dmg_type2`, `armor`, `holy_res`, `fire_res`, `nature_res`, `frost_res`, `shadow_res`, `arcane_res`, `delay`, `ammo_type`, `RangedModRange`, `spellid_1`, `spelltrigger_1`, `spellcharges_1`, `spellppmRate_1`, `spellcooldown_1`, `spellcategory_1`, `spellcategorycooldown_1`, `spellid_2`, `spelltrigger_2`, `spellcharges_2`, `spellppmRate_2`, `spellcooldown_2`, `spellcategory_2`, `spellcategorycooldown_2`, `spellid_3`, `spelltrigger_3`, `spellcharges_3`, `spellppmRate_3`, `spellcooldown_3`, `spellcategory_3`, `spellcategorycooldown_3`, `spellid_4`, `spelltrigger_4`, `spellcharges_4`, `spellppmRate_4`, `spellcooldown_4`, `spellcategory_4`, `spellcategorycooldown_4`, `spellid_5`, `spelltrigger_5`, `spellcharges_5`, `spellppmRate_5`, `spellcooldown_5`, `spellcategory_5`, `spellcategorycooldown_5`, `bonding`, `description`, `PageText`, `LanguageID`, `PageMaterial`, `startquest`, `lockid`, `Material`, `sheath`, `RandomProperty`, `RandomSuffix`, `block`, `itemset`, `MaxDurability`, `area`, `Map`, `BagFamily`, `TotemCategory`, `socketColor_1`, `socketContent_1`, `socketColor_2`, `socketContent_2`, `socketColor_3`, `socketContent_3`, `socketBonus`, `GemProperties`, `RequiredDisenchantSkill`, `ArmorDamageModifier`, `duration`, `ItemLimitCategory`, `HolidayId`, `ScriptName`, `DisenchantID`, `FoodType`, `minMoneyLoot`, `maxMoneyLoot`, `flagsCustom`, `VerifiedBuild`) values
+('100000','15','0','-1','Icerune','46787','4','72','0','1','0','0','0','-1','-1','1','1','0','0','0','0','0','0','6','1','1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','18282','0','0','0','8000','0','-1','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','1','|cff00FF00Use: Summons Lithathrad Teleporter.|r','0','0','0','0','0','3','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','-1','0','0','0','0','summon','0','0','0','0','0','-4');
diff --git a/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql b/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
new file mode 100644
index 0000000..ff6c46c
--- /dev/null
+++ b/sql/TrinityCore-Patches/TeleNPC2/world.npc_teleport.sql
@@ -0,0 +1,120 @@
+DROP TABLE IF EXISTS `custom_npc_tele_category`;
+CREATE TABLE `custom_npc_tele_category` (
+  `id` int(6) unsigned NOT NULL default '0',
+  `name` varchar(255) NOT NULL default '',
+  `flag` tinyint(3) unsigned NOT NULL default '0',
+  `data0` bigint(20) unsigned NOT NULL default '0',
+  `data1` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_destination`;
+CREATE TABLE `custom_npc_tele_destination` (
+  `id` int(6) unsigned NOT NULL auto_increment,
+  `name` char(100) NOT NULL default '',
+  `pos_X` float NOT NULL default '0',
+  `pos_Y` float NOT NULL default '0',
+  `pos_Z` float NOT NULL default '0',
+  `map` smallint(5) unsigned NOT NULL default '0',
+  `orientation` float NOT NULL default '0',
+  `level` tinyint(3) unsigned NOT NULL default '0',
+  `cost` int(10) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
+
+DROP TABLE IF EXISTS `custom_npc_tele_association`;
+CREATE TABLE `custom_npc_tele_association` (
+  `cat_id` int(6) unsigned NOT NULL default '0',
+  `dest_id` int(6) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`cat_id`, `dest_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=utf8;
+
+TRUNCATE `custom_npc_tele_category`;
+INSERT INTO `custom_npc_tele_category`
+   (`id`, `name`, `flag`, `data0`, `data1`)
+VALUES
+   (1, 'Cities', 0, 1, 0),
+   (2, 'Cities', 0, 2, 0),
+   (3, 'Battlegrounds', 0, 1, 0),
+   (4, 'Battlegrounds', 0, 2, 0),
+   (5, 'Arenas', 0, 0, 0),
+   (6, '[Instances Lvl 1-60]', 0, 0, 0),
+   (7, '[Instances Lvl 60+]', 5, 60, 0),
+   (8, '[Instances Lvl 70+]', 5, 70, 0),
+   (9, 'Destinations MJ', 3, 0, 0);
+
+TRUNCATE `custom_npc_tele_destination`;
+INSERT INTO `custom_npc_tele_destination`
+   (`id`, `name`, `pos_X`, `pos_Y`, `pos_Z`, `map`, `orientation`, `level`, `cost`)
+VALUES
+   (1, 'Alterac Valley', 883.187, -489.375, 96.7618, 30, 3.06932, 0, 0),
+   (2, 'Alterac Valley', -818.155, -623.043, 54.0884, 30, 2.1, 0, 0),
+   (3, 'Arathi Basin', 686.053, 683.165, -12.9149, 529, 0.18, 0, 0),
+   (4, 'Arathi Basin', 1308.68, 1306.03, -9.0107, 529, 3.91285, 0, 0),
+   (5, 'Black Temple', -3610.72, 324.988, 37.4, 530, 3.28298, 0, 0),
+   (6, 'Blackfathom Deeps', 4254.58, 664.74, -29.04, 1, 1.97, 0, 0),
+   (7, 'Blackrock Depths', -7301.03, -913.19, 165.37, 0, 0.08, 0, 0),
+   (8, 'Blackrock Spire', -7535.43, -1212.04, 285.45, 0, 5.29, 0, 0),
+   (9, 'Blackwing Lair', -7665.55, -1102.49, 400.679, 469, 0, 0, 0),
+   (10, 'Caverns of Time', -8173.66, -4746.36, 33.8423, 1, 4.93989, 0, 0),
+   (11, 'Circle of Blood', 2839.44, 5930.17, 11.1002, 530, 3.16284, 0, 0),
+   (12, 'Coilfang Reservoir', 517.288, 6976.28, 32.0072, 530, 0, 0, 0),
+   (13, 'Darnassus', 9947.52, 2482.73, 1316.21, 1, 0, 0, 0),
+   (14, 'Dire Maul', -3982.47, 1127.79, 161.02, 1, 0.05, 0, 0),
+   (15, 'Exodar', -4073.03, -12020.4, -1.47, 530, 0, 0, 0),
+   (16, 'Eye of the Storm', 2487.72, 1609.12, 1224.64, 566, 3.35671, 0, 0),
+   (17, 'Eye of the Storm', 1843.73, 1529.77, 1224.43, 566, 0.297579, 0, 0),
+   (18, 'Goldshire', -9464, 62, 56, 0, 0, 0, 0),
+   (19, 'Gruul\'s Lair', 3539.01, 5082.36, 1.69107, 530, 0, 0, 0),
+   (20, 'Gurubashi', -13261.3, 168.294, 35.0792, 0, 1.00688, 0, 0),
+   (21, 'Hellfire Citadel', -305.816, 3056.4, -2.47318, 530, 2.01, 0, 0),
+   (22, 'Ironforge', -4924.07, -951.95, 501.55, 0, 5.4, 0, 0),
+   (23, 'Isle Of Quel\'Danas', 12947.4, -6893.31, 5.68398, 530, 3.09154, 0, 0),
+   (24, 'Karazhan', -11118.8, -2010.84, 47.0807, 0, 0, 0, 0),
+   (25, 'Maraudon', -1433.33, 2955.34, 96.21, 1, 4.82, 0, 0),
+   (26, 'Molten Core', 1121.45, -454.317, -101.33, 230, 3.5, 0, 0),
+   (27, 'Naxxramas', 3125.18, -3748.02, 136.049, 0, 0, 0, 0),
+   (28, 'Onyxia\'s Lair', -4707.44, -3726.82, 54.6723, 1, 3.8, 0, 0),
+   (29, 'Orgrimmar', 1552.5, -4420.66, 8.94802, 1, 0, 0, 0),
+   (30, 'Razor Hill', 315.721, -4743.4, 10.4867, 1, 0, 0, 0),
+   (31, 'Razorfen Downs', -4645.08, -2470.85, 85.53, 1, 4.39, 0, 0),
+   (32, 'Razorfen Kraul', -4484.04, -1739.4, 86.47, 1, 1.23, 0, 0),
+   (33, 'Ring of Trials', -1999.94, 6581.71, 11.32, 530, 2.3, 0, 0),
+   (34, 'Ruins of Ahn\'Qiraj', -8409.03, 1498.83, 27.3615, 1, 2.49757, 0, 0),
+   (35, 'Scholomance', 1219.01, -2604.66, 85.61, 0, 0.5, 0, 0),
+   (36, 'Shadowfang Keep', -254.47, 1524.68, 76.89, 0, 1.56, 0, 0),
+   (37, 'Shattrath City', -1850.21, 5435.82, -10.9614, 530, 3.40391, 0, 0),
+   (38, 'Silvermoon', 9338.74, -7277.27, 13.7895, 530, 0, 0, 0),
+   (39, 'Stormwind', -8960.14, 516.266, 96.3568, 0, 0, 0, 0),
+   (40, 'Stratholme', 3263.54, -3379.46, 143.59, 0, 0, 0, 0),
+   (41, 'Tempest Keep', 3089.58, 1399.05, 187.653, 530, 4.79407, 0, 0),
+   (42, 'Temple of Ahn\'Qiraj', -8245.84, 1983.74, 129.072, 1, 0.936195, 0, 0),
+   (43, 'The Deadmines', -11212, 1658.58, 25.67, 0, 1.45, 0, 0),
+   (44, 'The Maul', -3761.49, 1133.43, 132.083, 1, 4.57259, 0, 0),
+   (45, 'The Scarlet Monastery', 2843.89, -693.74, 139.32, 0, 5.11, 0, 0),
+   (46, 'The Sunken Temple', -10346.9, -3851.9, -43.41, 0, 6.09, 0, 0),
+   (47, 'The Wailing Caverns', -722.53, -2226.3, 16.94, 1, 2.71, 0, 0),
+   (48, 'Thunder Bluff', -1290, 147.034, 129.682, 1, 4.919, 0, 0),
+   (49, 'Uldaman', -6119.7, -2957.3, 204.11, 0, 0.03, 0, 0),
+   (50, 'Undercity', 1819.71, 238.79, 60.5321, 0, 0, 0, 0),
+   (51, 'Warsong Gulch', 930.851, 1431.57, 345.537, 489, 0.015704, 0, 0),
+   (52, 'Warsong Gulch', 1525.95, 1481.66, 352.001, 489, 3.20756, 0, 0),
+   (53, 'Zul\'Aman', 6846.95, -7954.5, 170.028, 530, 4.61501, 0, 0),
+   (54, 'Zul\'Farrak', -6839.39, -2911.03, 8.87, 1, 0.41, 0, 0),
+   (55, 'Zul\'Gurub', -11916.7, -1212.82, 92.2868, 0, 4.6095, 0, 0),
+   (56, 'Ile des MJ', 16254, 16276.9, 14.5082, 1, 1.70269, 0, 0);
+
+TRUNCATE `custom_npc_tele_association`;
+INSERT INTO `custom_npc_tele_association`
+  (`cat_id`, `dest_id`)
+VALUES
+  (1, 13), (1, 15), (1, 18), (1, 22), (1, 23), (1, 37), (1, 39), (2, 23), (2, 29), (2, 30), (2, 37), (2, 38), (2, 48), (2, 50), (3, 1), (3, 4), (3, 16), (3, 52), (4, 2), (4, 3), (4, 17), (4, 51), (5, 11), (5, 20), (5, 33), (5, 44), (6, 6), (6, 7), (6, 8), (6, 14), (6, 25), (6, 31), (6, 32), (6, 35), (6, 36), (6, 40), (6, 43), (6, 45), (6, 46), (6, 47), (6, 49), (6, 54), (7, 9), (7, 26), (7, 27), (7, 28), (7, 34), (7, 42), (7, 55), (8, 5), (8, 10), (8, 12), (8, 19), (8, 21), (8, 24), (8, 41), (8, 53), (9, 56);
+
+-- `npc_text`
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100000, 'Choose your Category.'),
+   (100001, 'Choose your Destination.');
+
+-- `creature_template`
+REPLACE INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('100000','0','0','0','0','0','26502','0','0','0','Abisal Vortex','','','0','83','83','0','35','1','1','1.14286','2','1','0','0','0','1','1','1','0','2048','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','2','npc_teleport','1');
diff --git a/sql/TrinityCore-Patches/Transmogrification/characters.sql b/sql/TrinityCore-Patches/Transmogrification/characters.sql
new file mode 100644
index 0000000..815c4d3
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/characters.sql
@@ -0,0 +1,23 @@
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+CREATE TABLE `custom_transmogrification` (
+  `GUID` int(10) unsigned NOT NULL COMMENT 'Item guidLow',
+  `FakeEntry` int(10) unsigned NOT NULL COMMENT 'Item entry',
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidLow',
+  PRIMARY KEY (`GUID`)
+) ENGINE=InnoDB DEFAULT CHARSET=latin1;
+
+CREATE TABLE `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/_README.md b/sql/TrinityCore-Patches/Transmogrification/updates/_README.md
new file mode 100644
index 0000000..2632510
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/_README.md
@@ -0,0 +1 @@
+DO NOT RUN THE UPDATES WHEN MAKING A CLEAN INSTALL
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
new file mode 100644
index 0000000..ee57844
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_1_to_2_2.sql
@@ -0,0 +1,12 @@
+CREATE TABLE IF NOT EXISTS `custom_transmogrification` (
+	`GUID` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+	`FakeOwner` INT(10) UNSIGNED NOT NULL DEFAULT '0',
+	`FakeEntry` INT(10) UNSIGNED NOT NULL DEFAULT '0'
+)
+COLLATE='latin1_swedish_ci'
+ENGINE=InnoDB;
+
+REPLACE INTO custom_transmogrification (GUID, FakeOwner, FakeEntry) SELECT guid, FakeOwner, FakeEntry FROM item_instance WHERE FakeOwner != 0 AND FakeEntry != 0;
+ALTER TABLE `item_instance`
+	DROP COLUMN `FakeEntry`,
+	DROP COLUMN `FakeOwner`;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
new file mode 100644
index 0000000..63059ee
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_2_2_to_3_0.sql
@@ -0,0 +1,2 @@
+ALTER TABLE `custom_transmogrification`
+	DROP COLUMN `FakeOwner`;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
new file mode 100644
index 0000000..89c91ac
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/characters_update_4_x_to_5_0.sql
@@ -0,0 +1,16 @@
+/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
+/*!40101 SET NAMES utf8 */;
+/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
+/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
+
+CREATE TABLE `custom_transmogrification_sets` (
+  `Owner` int(10) unsigned NOT NULL COMMENT 'Player guidlow',
+  `PresetID` tinyint(3) unsigned NOT NULL COMMENT 'Preset identifier',
+  `SetName` text COMMENT 'SetName',
+  `SetData` text COMMENT 'Slot1 Entry1 Slot2 Entry2',
+  PRIMARY KEY (`Owner`,`PresetID`)
+) ENGINE=InnoDB DEFAULT CHARSET=utf8;
+
+/*!40101 SET SQL_MODE=IFNULL(@OLD_SQL_MODE, '') */;
+/*!40014 SET FOREIGN_KEY_CHECKS=IF(@OLD_FOREIGN_KEY_CHECKS IS NULL, 1, @OLD_FOREIGN_KEY_CHECKS) */;
+/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
new file mode 100644
index 0000000..03cc6d2
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_3_5_to_3_6.sql
@@ -0,0 +1 @@
+REPLACE INTO `trinity_string` (`entry`, `content_default`, `content_loc1`, `content_loc2`, `content_loc3`, `content_loc4`, `content_loc5`, `content_loc6`, `content_loc7`, `content_loc8`) VALUES (11129, 'You don\'t have enough %ss', NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL);
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
new file mode 100644
index 0000000..8723683
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_4_x_to_5_0.sql
@@ -0,0 +1,27 @@
+DELETE FROM `trinity_string` WHERE `entry` BETWEEN 11100 AND 11129;
+
+SET @TEXT_ID := 50000;
+INSERT INTO `npc_text` (`ID`, `text0_0`, `WDBVerified`) VALUES
+(@TEXT_ID, 'Transmogrification allows you to change how your items look like without changing the stats of the items.\r\nItems used in transmogrification are no longer refundable, tradeable and are bound to you.\r\nUpdating a menu updates the view and prices.\r\n\r\nNot everything can be transmogrified with eachother.\r\nRestrictions include but are not limited to:\r\nOnly armor and weapons can be transmogrified\r\nGuns, bows and crossbows can be transmogrified with eachother\r\nFishing poles can not be transmogrified\r\nYou must be able to equip both items used in the process.\r\n\r\nTransmogrifications stay on your items as long as you own them.\r\nIf you try to put the item in guild bank or mail it to someone else, the transmogrification is stripped.\r\n\r\nYou can also remove transmogrifications for free at the transmogrifier.', 1),
+(@TEXT_ID+1, 'You can save your own transmogrification sets.\r\n\r\nTo save, first you must transmogrify your equipped items.\r\nThen when you go to the set management menu and go to save set menu,\r\nall items you have transmogrified are displayed so you see what you are saving.\r\nIf you think the set is fine, you can click to save the set and name it as you wish.\r\n\r\nTo use a set you can click the saved set in the set management menu and then select use set.\r\nIf the set has a transmogrification for an item that is already transmogrified, the old transmogrification is lost.\r\nNote that same transmogrification restrictions apply when trying to use a set as in normal transmogrification.\r\n\r\nTo delete a set you can go to the set\'s menu and select delete set.', 1);
+
+SET @STRING_ENTRY := 11100;
+INSERT INTO `trinity_string` (`entry`, `content_default`) VALUES
+(@STRING_ENTRY+0, 'Item transmogrified'),
+(@STRING_ENTRY+1, 'Equipment slot is empty'),
+(@STRING_ENTRY+2, 'Invalid source item selected'),
+(@STRING_ENTRY+3, 'Source item does not exist'),
+(@STRING_ENTRY+4, 'Destination item does not exist'),
+(@STRING_ENTRY+5, 'Selected items are invalid'),
+(@STRING_ENTRY+6, 'Not enough money'),
+(@STRING_ENTRY+7, 'You don\'t have enough tokens'),
+(@STRING_ENTRY+8, 'Transmogrifications removed'),
+(@STRING_ENTRY+9, 'There are no transmogrifications'),
+(@STRING_ENTRY+10, 'Invalid name inserted');
+
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+REPLACE INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 35, 1, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 7, 0, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify', 0);
diff --git a/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
new file mode 100644
index 0000000..2a5e854
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/updates/world_update_5_0_to_5_1.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+
+REPLACE INTO `creature_template` (`entry`, `modelid1`, `modelid2`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction_A`, `faction_H`, `npcflag`, `scale`, `rank`, `mindmg`, `maxdmg`, `dmgschool`, `attackpower`, `dmg_multiplier`, `baseattacktime`, `rangeattacktime`, `unit_class`, `unit_flags`, `minrangedmg`, `maxrangedmg`, `rangedattackpower`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `Health_mod`, `Mana_mod`, `Armor_mod`, `RacialLeader`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `WDBVerified`) VALUES
+(@Entry, 19646, 0, @Name, "Transmogrifier", NULL, 0, 80, 80, 2, 35, 35, 1, 1, 0, 500, 500, 0, 350, 1, 2000, 0, 1, 0, 0, 0, 0, 7, 138936390, 0, 0, 0, '', 0, 3, 1, 1, 1, 1, 0, 0, 1, 0, 0, 'Creature_Transmogrify', 0);
diff --git a/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql b/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
new file mode 100644
index 0000000..62207a0
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/world_NPC.sql
@@ -0,0 +1,6 @@
+SET
+@Entry = 190010,
+@Name = "Warpweaver";
+DELETE FROM `creature_template` WHERE `entry` = @Entry;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+(@Entry,'0','0','0','0','0','19646','0','0','0',@Name,'Transmogrifier',NULL,'0','80','80','2','35','1','1','1.14286','1','0','0','2000','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','Creature_Transmogrify','0');
diff --git a/sql/TrinityCore-Patches/Transmogrification/world_texts.sql b/sql/TrinityCore-Patches/Transmogrification/world_texts.sql
new file mode 100644
index 0000000..082b631
--- /dev/null
+++ b/sql/TrinityCore-Patches/Transmogrification/world_texts.sql
@@ -0,0 +1,18 @@
+SET @TEXT_ID := 50000;
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+(@TEXT_ID, 'Transmogrification allows you to change how your items look like without changing the stats of the items.\r\nItems used in transmogrification are no longer refundable, tradeable and are bound to you.\r\nUpdating a menu updates the view and prices.\r\n\r\nNot everything can be transmogrified with eachother.\r\nRestrictions include but are not limited to:\r\nOnly armor and weapons can be transmogrified\r\nGuns, bows and crossbows can be transmogrified with eachother\r\nFishing poles can not be transmogrified\r\nYou must be able to equip both items used in the process.\r\n\r\nTransmogrifications stay on your items as long as you own them.\r\nIf you try to put the item in guild bank or mail it to someone else, the transmogrification is stripped.\r\n\r\nYou can also remove transmogrifications for free at the transmogrifier.'),
+(@TEXT_ID+1, 'You can save your own transmogrification sets.\r\n\r\nTo save, first you must transmogrify your equipped items.\r\nThen when you go to the set management menu and go to save set menu,\r\nall items you have transmogrified are displayed so you see what you are saving.\r\nIf you think the set is fine, you can click to save the set and name it as you wish.\r\n\r\nTo use a set you can click the saved set in the set management menu and then select use set.\r\nIf the set has a transmogrification for an item that is already transmogrified, the old transmogrification is lost.\r\nNote that same transmogrification restrictions apply when trying to use a set as in normal transmogrification.\r\n\r\nTo delete a set you can go to the set\'s menu and select delete set.');
+
+SET @STRING_ENTRY := 11100;
+REPLACE INTO `trinity_string` (`entry`, `content_default`) VALUES
+(@STRING_ENTRY+0, 'Item transmogrified'),
+(@STRING_ENTRY+1, 'Equipment slot is empty'),
+(@STRING_ENTRY+2, 'Invalid source item selected'),
+(@STRING_ENTRY+3, 'Source item does not exist'),
+(@STRING_ENTRY+4, 'Destination item does not exist'),
+(@STRING_ENTRY+5, 'Selected items are invalid'),
+(@STRING_ENTRY+6, 'Not enough money'),
+(@STRING_ENTRY+7, 'You don\'t have enough tokens'),
+(@STRING_ENTRY+8, 'Transmogrifications removed'),
+(@STRING_ENTRY+9, 'There are no transmogrifications'),
+(@STRING_ENTRY+10, 'Invalid name inserted');
diff --git a/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql b/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
new file mode 100644
index 0000000..dbad38a
--- /dev/null
+++ b/sql/TrinityCore-Patches/beastmaster/world-beastmaster.sql
@@ -0,0 +1,64 @@
+DROP TABLE IF EXISTS `beastmaster`;
+
+CREATE TABLE `beastmaster` (
+  `entry` INT(5) NOT NULL DEFAULT '0' COMMENT 'Pet entry number',
+  `cat_number` INT(5) NOT NULL DEFAULT '0' COMMENT '0-normal pet 1-exotic pet 2-pet spell',
+  `tokenOrGold` TINYINT(1) DEFAULT '0' COMMENT '0 = gold 1 = token',
+  `cost` INT(10) NOT NULL DEFAULT '0' COMMENT 'Amount in copper if tokenOrGold is 0 else number of tokens',
+  `token` INT(10) NOT NULL DEFAULT '0' COMMENT 'Token entry number (item_template.entry)',
+  `name` VARCHAR(255) DEFAULT NULL COMMENT 'Name of pet or name of pet spell',
+  `spell` INT(10) NOT NULL DEFAULT '0' COMMENT 'Spell entry number.',
+  PRIMARY KEY (`entry`)
+) ENGINE=INNODB DEFAULT CHARSET=utf8 COMMENT='Beastmaster System by LordPsyan';
+
+/*Data for the table `beastmaster` */
+
+INSERT INTO `beastmaster` (`entry`, `cat_number`, `tokenOrGold`, `cost`, `token`, `name`, `spell`) VALUES
+('1','0','1','1000','0','Spider','2349'),
+('2','0','0','1000','0','Bat','28233'),
+('3','0','0','1000','0','Bear','29319'),
+('4','0','0','1000','0','Boar','29996'),
+('5','0','0','1000','0','Cat','28097'),
+('6','0','0','1000','0','Carrion Bird','26838'),
+('7','0','0','1000','0','Crab','24478'),
+('8','0','0','1000','0','Crocolisk','1417'),
+('9','0','0','1000','0','Dragonhawk','27946'),
+('10','0','0','1000','0','Gorilla','28213'),
+('11','0','0','1000','0','Hyena','13036'),
+('12','0','0','1000','0','Moth','27421'),
+('13','0','0','1000','0','Owl','23136'),
+('14','0','0','1000','0','Raveger','17199'),
+('15','0','0','1000','0','Raptor','14821'),
+('16','0','0','1000','0','Serpent','28358'),
+('17','0','0','1000','0','Bug','28085'),
+('18','0','0','1000','0','Strider','22807'),
+('19','0','0','1000','0','Scorpid','9698'),
+('20','1','0','1000','0','Chimaera','21879'),
+('21','1','0','1000','0','Core Hound','21108'),
+('22','1','0','1000','0','Devilsaur','20931'),
+('23','1','0','1000','0','Rhino','30445'),
+('24','1','0','1000','0','Silithid','5460'),
+('25','1','0','1000','0','Worm','30148'),
+('26','1','0','1000','0','Loque\'nahak','32517'),
+('27','1','0','1000','0','Skoll','35189'),
+('28','1','0','1000','0','Gondria','33776'),
+('29','2','1','1000','0','Feed Pet','6991'),
+('30','2','0','1000','0','Call Pet','883'),
+('31','2','0','1000','0','Dismiss Pet','2641'),
+('32','2','0','1000','0','Mend Pet','136');
+
+-- Beastmaster NPC
+
+DELETE FROM `creature_template` WHERE `entry` = 99990;
+
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('99990','0','0','0','0','0','26789','0','0','0','LordPsyan','Beastmaster Service','','0','80','80','0','35','129','1','1.14286','0.75','1','0','1500','0','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','Npc_Beastmaster','0');
+
+-- Sample npc vendor data for beastmaster
+
+DELETE FROM `npc_vendor` WHERE `entry` = 99990;
+
+INSERT INTO `npc_vendor` (`entry`, `slot`, `item`, `maxcount`, `incrtime`, `ExtendedCost`) VALUES
+('99990','0','4540','0','0','0'),
+('99990','0','4541','0','0','0'),
+('99990','0','4542','0','0','0');
diff --git a/sql/TrinityCore-Patches/enchant/world.enchant.sql b/sql/TrinityCore-Patches/enchant/world.enchant.sql
new file mode 100644
index 0000000..647019c
--- /dev/null
+++ b/sql/TrinityCore-Patches/enchant/world.enchant.sql
@@ -0,0 +1,4 @@
+-- Creature template. Young woman enchantress
+DELETE FROM `creature_template` WHERE `entry` = 100067;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('100067','0','0','0','0','0','2591','0','0','0','Young Woman','You need it, I got it.','','0','80','80','0','35','1','1','1.14286','1','1','0','1500','0','1','1','1','0','2048','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','EventAI','0','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_enchantment','0');
diff --git a/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
new file mode 100644
index 0000000..3a970af
--- /dev/null
+++ b/sql/TrinityCore-Patches/npc_buff/world_npc_buff.sql
@@ -0,0 +1,62 @@
+DROP TABLE IF EXISTS `npc_buff_spells`;
+
+CREATE TABLE `npc_buff_spells` (
+  `spell_id` int(5) NOT NULL default '0' COMMENT 'Spell entry number',
+  `cat_number` int(5) NOT NULL default '0' COMMENT '0-small buff 1-great buff 2-gm buff 3-player tools',
+  `cost` int(10) NOT NULL default '0' COMMENT 'cost amount in copper',
+  `name` text COMMENT 'Name of spell',
+  PRIMARY KEY  (`spell_id`)
+) ENGINE=MyISAM DEFAULT CHARSET=latin1;
+
+/*Data for the table `npc_buff_spells` */
+
+INSERT INTO `npc_buff_spells` (`spell_id`, `cat_number`, `cost`, `name`) VALUES
+-- Small Buff
+(48469,1001,10000,"Mark of the Wild"),
+(53307,1002,10000,"Thorns"),
+(43017,1003,10000,"Amplify Magic"),
+(42995,1004,10000,"Arcane Intellect"),
+(61024,1005,10000,"Dalaran Intellect"),
+(43015,1006,10000,"Dampen Magic"),
+(20217,1007,10000,"Blessing of Kings"),
+(48932,1008,10000,"Blessing of Might"),
+(48936,1009,10000,"Blessing of Wisdom"),
+(48072,1010,10000,"Divine Spirit"),
+(48161,1011,10000,"Power Word: Fortitude"),
+(48169,1012,10000,"Shadow Protection"),
+-- Great Buff
+(48470,2001,100000,"Gift of the Wild"),
+(43002,2002,100000,"Arcane Brilliance"),
+(61316,2003,100000,"Dalaran Brilliance"),
+(25898,2004,100000,"Greater Blessing of Kings"),
+(48934,2005,100000,"Greater Blessing of Might"),
+(25899,2006,100000,"Greater Blessing of Sanctuary"),
+(48938,2007,100000,"Greater Blessing of Wisdom"),
+(48162,2008,100000,"Prayer of Fortitude"),
+(48170,2009,100000,"Prayer of Shadow Protection"),
+(48074,2010,100000,"Prayer of Spirit"),
+-- GM Buff
+(17013,3001,0,"Agamaggan's Agility"),
+(16612,3002,0,"Agamaggan's Strength"),
+(58453,3003,0,"Armor Magic"),
+(34106,3004,0,"Armor Penetration"),
+(25661,3005,0,"Increased Stamina"),
+(16610,3006,0,"Razorhide"),
+(10767,3007,0,"Rising Spirit"),
+(16618,3008,0,"Spirit of the Wind"),
+(7764,3009,0,"Wisdom of Agamaggan"),
+-- Player Tools
+(46642,4001,0,"Give me Gold"),
+(24827,4002,0,"Give me Soul Shards"),
+(38588,4003,0,"Heal me please"),
+(53251,4004,0,"Heal me and party members Please"),
+(42956,4005,0,"Conjure Refreshment"),
+(42985,4006,0,"Conjure Mana Gem");
+
+DELETE FROM `creature_template` WHERE `entry` = 60002;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60002','0','0','0','0','0','18','0','18','0','LordPsyan','Buffs master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','npc_buff','1');
+
+REPLACE INTO `npc_text` (`ID`, `text0_0`) VALUES
+   (100002, 'Choose your Buff Type.'),
+   (100003, 'Choose your Buff.');
\ No newline at end of file
diff --git a/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
new file mode 100644
index 0000000..d2141cf
--- /dev/null
+++ b/sql/TrinityCore-Patches/profession_npc/world_professionnpc.sql
@@ -0,0 +1,4 @@
+DELETE FROM `creature_template` WHERE `entry` = 60001;
+INSERT INTO `creature_template` (`entry`, `difficulty_entry_1`, `difficulty_entry_2`, `difficulty_entry_3`, `KillCredit1`, `KillCredit2`, `modelid1`, `modelid2`, `modelid3`, `modelid4`, `name`, `subname`, `IconName`, `gossip_menu_id`, `minlevel`, `maxlevel`, `exp`, `faction`, `npcflag`, `speed_walk`, `speed_run`, `scale`, `rank`, `dmgschool`, `BaseAttackTime`, `RangeAttackTime`, `BaseVariance`, `RangeVariance`, `unit_class`, `unit_flags`, `unit_flags2`, `dynamicflags`, `family`, `trainer_type`, `trainer_spell`, `trainer_class`, `trainer_race`, `type`, `type_flags`, `lootid`, `pickpocketloot`, `skinloot`, `resistance1`, `resistance2`, `resistance3`, `resistance4`, `resistance5`, `resistance6`, `spell1`, `spell2`, `spell3`, `spell4`, `spell5`, `spell6`, `spell7`, `spell8`, `PetSpellDataId`, `VehicleId`, `mingold`, `maxgold`, `AIName`, `MovementType`, `InhabitType`, `HoverHeight`, `HealthModifier`, `ManaModifier`, `ArmorModifier`, `DamageModifier`, `ExperienceModifier`, `RacialLeader`, `questItem1`, `questItem2`, `questItem3`, `questItem4`, `questItem5`, `questItem6`, `movementId`, `RegenHealth`, `mechanic_immune_mask`, `flags_extra`, `ScriptName`, `VerifiedBuild`) values
+('60001','0','0','0','0','0','18','0','18','0','Cyon','Profession master','','0','59','61','0','35','1','1.48','1.14286','0','0','0','1500','1900','1','1','1','0','0','0','0','0','0','0','0','7','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','0','','1','3','1','1','1','1','1','1','0','0','0','0','0','0','0','0','1','0','0','professionnpc','1');
+-- end
diff --git a/sql/TrinityCore-patches/External_Mail/characters.external_mail.sql b/sql/TrinityCore-patches/External_Mail/characters.external_mail.sql
new file mode 100644
index 0000000..8cd6a05
--- /dev/null
+++ b/sql/TrinityCore-patches/External_Mail/characters.external_mail.sql
@@ -0,0 +1,10 @@
+CREATE TABLE `mail_external` (
+  `id` bigint(20) unsigned NOT NULL auto_increment,
+  `receiver` bigint(20) unsigned NOT NULL,
+  `subject` varchar(200) default 'Support Message',
+  `message` varchar(500) default 'Support Message',
+  `money` bigint(20) unsigned NOT NULL default '0',
+  `item` bigint(20) unsigned NOT NULL default '0',
+  `item_count` bigint(20) unsigned NOT NULL default '0',
+  PRIMARY KEY  (`id`)
+) ENGINE=MyISAM AUTO_INCREMENT=7525 DEFAULT CHARSET=utf8;
\ No newline at end of file
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
new file mode 100644
index 0000000..3aed0f7
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.cpp
@@ -0,0 +1,380 @@
+/**
+ *
+ * @File : sc_npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 28/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+//#include "ProgressBar.h"
+
+#define TELE    nsNpcTel::CatDest
+#define PAGE    nsNpcTel::Page
+#define PAGEI   PAGE::Instance
+
+
+nsNpcTel::VCatDest nsNpcTel::TabCatDest;
+
+
+uint32 PAGE::operator [] (Player * const player) const
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i].GetPageId();
+    }
+    return 0;
+}
+
+PAGE::Instance & PAGE::operator () (Player * const player)
+{
+    for (VInst_t i(0); i < m_TabInstance.size(); ++i)
+    {
+        if (m_TabInstance[i].GetPlayer() == player)
+            return m_TabInstance[i];
+    }
+    m_TabInstance.push_back(Instance(player));
+    return m_TabInstance.back();
+}
+
+PAGE::Instance & PAGEI::operator = (const uint32 &id)
+{
+    m_PageId = id;
+    return *this;
+}
+
+PAGE::Instance & PAGEI::operator ++ (void)
+{
+    ++m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator ++ (int32)
+{
+    Instance tmp (*this);
+    ++m_PageId;
+    return tmp;
+}
+
+PAGE::Instance & PAGEI::operator -- (void)
+{
+    --m_PageId;
+    return *this;
+}
+
+PAGE::Instance PAGEI::operator -- (int32)
+{
+    Instance tmp (*this);
+    --m_PageId;
+    return tmp;
+}
+
+TELE::CatDest(const uint32 &id, const std::string &name,
+              const Flag &flag, const uint64 &data0, const uint32 &data1)
+    : m_id(id), m_name(name), m_flag(flag), m_data0(data0), m_data1(data1)
+{
+    m_TabDest.clear();
+}
+
+std::string TELE::GetName(const bool IsGM /* = false */) const
+{
+    if (!IsGM || m_flag != FLAG_TEAM)
+        return m_name;
+
+    switch (m_data0)
+    {
+      case TEAM_HORDE:      return std::string(m_name + " (H)");
+      case TEAM_ALLIANCE:   return std::string(m_name + " (A)");
+    }
+    return m_name;
+}
+
+bool TELE::IsAllowedToTeleport(Player * const player) const
+{
+    if (player->IsGameMaster())
+    {
+        if (m_flag == FLAG_GMLEVEL)
+            return player->GetSession()->GetSecurity() >= m_data0;
+        return true;
+    }
+
+    switch (m_flag)
+    {
+      case FLAG_TEAM:
+        switch (m_data0)
+        {
+          case TEAM_HORDE:      return player->GetTeam() == HORDE;
+          case TEAM_ALLIANCE:   return player->GetTeam() == ALLIANCE;
+          case TEAM_ALL:        return true;
+        }
+
+      case FLAG_GUILD:
+        return player->GetGuildId() == m_data0;
+
+      case FLAG_GMLEVEL:
+        return player->GetSession()->GetSecurity() >= m_data0;
+
+      case FLAG_ISGM:
+        return player->IsGameMaster();
+
+      case FLAG_ACCOUNT:
+        return player->GetSession()->GetAccountId() == m_data0;
+
+      case FLAG_LEVEL:
+        return player->getLevel() >= m_data0;
+
+      case FLAG_ITEM:
+        return player->HasItemCount(m_data0, m_data1, true);
+
+      case FLAG_QUEST:
+        if (m_data1 < MAX_QUEST_STATUS)
+            return player->GetQuestStatus(m_data0) == m_data1;
+        return player->GetQuestRewardStatus(m_data0);
+
+      case FLAG_GENDER:
+        return player->getGender() == m_data0;
+
+      case FLAG_RACE:
+        return player->getRace() == m_data0;
+
+      case FLAG_CLASS:
+        return player->getClass() == m_data0;
+
+      case FLAG_REPUTATION:
+        return player->GetReputationRank(m_data0) >= m_data1;
+
+      case FLAG_PLAYER:
+        return player->GetGUID() == m_data0;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u). Important problem...", GetCatID());
+    return false;
+}
+
+uint32 TELE::CountOfCategoryAllowedBy(Player * const player)
+{
+    uint32 count (0);
+    for (VCatDest_t i(0); i < TabCatDest.size(); ++i)
+    {
+        if (TabCatDest[i].IsAllowedToTeleport(player))
+            ++count;
+    }
+    return count;
+}
+
+bool nsNpcTel::IsValidData(const uint32 &cat,   const Flag &flag,
+                           const uint64 &data0, const uint32 &data1)
+{
+    switch(flag)
+    {
+      case FLAG_TEAM:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < MAX_FLAG_TEAM)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Team) (category: %u).", cat);
+        return false;
+
+      case FLAG_GUILD:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GuildID) (category: %u).", cat);
+        return false;
+
+      case FLAG_GMLEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (GmLevel) (category: %u).", cat);
+        return false;
+
+      case FLAG_ISGM:
+        if (data0)
+            TC_LOG_ERROR("misc", "Invalid data0 (category: %u).", cat);
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        return true;
+
+      case FLAG_ACCOUNT:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (AccountID) (category: %u).", cat);
+        return false;
+
+      case FLAG_LEVEL:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < 256)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Level) (category: %u).", cat);
+        return false;
+
+      case FLAG_ITEM:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (ItemID) (category: %u).", cat);
+            return false;
+        }
+        if (data1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Item Count) (category: %u).", cat);
+        return false;
+
+      case FLAG_QUEST:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (QuestID) (category: %u).", cat);
+            return false;
+        }
+        if (data1 < MAX_QUEST_STATUS + 1)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Quest Status) (category: %u).", cat);
+        return false;
+
+      case FLAG_GENDER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0 < GENDER_NONE)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Gender) (category: %u).", cat);
+        return false;
+
+      case FLAG_RACE:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_RACES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Race) (category: %u).", cat);
+        return false;
+
+      case FLAG_CLASS:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (0 < data0 && data0 < MAX_CLASSES)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (Class) (category: %u).", cat);
+        return false;
+
+      case FLAG_REPUTATION:
+        if (!data0)
+        {
+            TC_LOG_ERROR("misc", "Invalid data0 (Faction/Reputation) (category: %u).", cat);
+            return false;
+        }
+        if (data1 <= REP_EXALTED)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data1 (Faction/Reputation) (category: %u).", cat);
+        return false;
+
+      case FLAG_PLAYER:
+        if (data1)
+            TC_LOG_ERROR("misc", "Invalid data1 (category: %u).", cat);
+        if (data0)
+            return true;
+        TC_LOG_ERROR("misc", "Invalid data0 (PlayerGuid) (category: %u).", cat);
+        return false;
+
+      default: TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    }
+
+    TC_LOG_ERROR("misc", "Invalid flag (category: %u).", cat);
+    return false;
+}
+
+void LoadNpcTele(void)
+{
+    const char *Table[] =
+    {
+        "custom_npc_tele_category",
+        "custom_npc_tele_destination",
+        "custom_npc_tele_association",
+    };
+
+
+    QueryResult result = WorldDatabase.PQuery(
+        "SELECT `flag`, `data0`, `data1`, `cat_id`, C.`name` `namecat`, D.`name` `namedest`, "
+        //      0        1        2        3                  4                   5
+               "`pos_X`, `pos_Y`, `pos_Z`, `orientation`, `map`, `level`, `cost` "
+        //      6        7        8        9              10     11       12
+        "FROM `%s` C, `%s` D, `%s` A "
+        "WHERE C.`id` = `cat_id` AND D.`id` = `dest_id` "
+        "ORDER BY `namecat`, `cat_id`, `namedest`", Table[0], Table[1], Table[2]);
+
+    nsNpcTel::TabCatDest.clear();
+
+    if (result)
+    {
+        TC_LOG_INFO("server.loading", "Loading %s, %s and %s...", Table[0], Table[1], Table[2]);
+        // barGoLink bar(result->GetRowCount());
+
+        uint32 catid = 0;
+        uint32 nbDest = 0;
+        bool IsValidCat = true;
+        bool FirstTime = true;
+
+        do
+        {
+            // bar.step();
+            Field *fields = result->Fetch();
+
+            if (!IsValidCat && catid == fields[3].GetUInt32() && !FirstTime)
+                continue;
+
+            IsValidCat = true;
+            FirstTime = false;
+
+            if (!nsNpcTel::IsValidData(fields[3].GetUInt32(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                       fields[1].GetUInt64(), fields[2].GetUInt32()))
+            {
+                IsValidCat = false;
+                catid = fields[3].GetUInt32();
+                continue;
+            }
+
+            if (catid != fields[3].GetUInt32())
+            {
+                catid = fields[3].GetUInt32();
+                nsNpcTel::CatDest categorie (catid, fields[4].GetString(), (nsNpcTel::Flag)fields[0].GetUInt8(),
+                                             fields[1].GetUInt64(), fields[2].GetUInt32());
+                nsNpcTel::TabCatDest.push_back(categorie);
+            }
+
+            nsNpcTel::Dest item =
+            {
+                fields[5].GetString(),   // Name
+                fields[6].GetFloat(),       // X
+                fields[7].GetFloat(),       // Y
+                fields[8].GetFloat(),       // Z
+                fields[9].GetFloat(),       // Orientation
+                fields[10].GetUInt16(),     // Map
+                fields[11].GetUInt8(),      // Level
+                fields[12].GetUInt32(),     // Cost
+            };
+
+            nsNpcTel::TabCatDest.back().AddDest(item);
+            ++nbDest;
+        } while (result->NextRow());
+
+        TC_LOG_INFO("server.loading", " ");
+        TC_LOG_INFO("server.loading", "Loaded %u npc_teleport.", nbDest);
+    } else TC_LOG_ERROR("misc", "WARNING >> Loaded 0 npc_teleport.");
+}
+
+
+#undef TELE
+#undef PAGE
+#undef PAGEI
diff --git a/src/server/game/AI/ScriptedAI/sc_npc_teleport.h b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
new file mode 100644
index 0000000..4830245
--- /dev/null
+++ b/src/server/game/AI/ScriptedAI/sc_npc_teleport.h
@@ -0,0 +1,151 @@
+/**
+ *
+ * @File : sc_npc_teleport.h
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+#ifndef SC_NPC_TELEPORT_H
+#define SC_NPC_TELEPORT_H
+
+#include <vector>
+
+
+namespace nsNpcTel
+{
+    // Different types of permissions
+    enum Flag
+    {
+        FLAG_TEAM       = 0,
+        FLAG_GUILD      = 1,
+        FLAG_GMLEVEL    = 2,
+        FLAG_ISGM       = 3,
+        FLAG_ACCOUNT    = 4,
+        FLAG_LEVEL      = 5,
+        FLAG_ITEM       = 6,
+        FLAG_QUEST      = 7,
+        FLAG_GENDER     = 8,
+        FLAG_RACE       = 9,
+        FLAG_CLASS      = 10,
+        FLAG_REPUTATION = 11,
+        FLAG_PLAYER     = 12,
+        MAX_FLAG,
+    };
+
+    // Different parameters of FLAG_TEAM
+    enum
+    {
+        TEAM_ALL        = 0,
+        TEAM_ALLIANCE   = 1,
+        TEAM_HORDE      = 2,
+        MAX_FLAG_TEAM,
+    };
+
+    // Structure representing the destinations
+    struct Dest
+    {
+        std::string m_name;
+        float       m_X, m_Y, m_Z, m_orient;
+        uint16      m_map;
+        uint8       m_level;
+        uint32      m_cost;
+    };
+
+    // Class representing the categories of destinations
+    class CatDest
+    {
+      public:
+
+        typedef std::vector<Dest> VDest;
+        typedef VDest::size_type  VDest_t;
+
+        CatDest(const uint32 &id, const std::string &name,
+                const Flag &flag, const uint64 &data0, const uint32 &data1);
+
+        void   AddDest  (const Dest &item)       { m_TabDest.push_back(item); }
+        Dest   GetDest  (const uint32 &id) const { return m_TabDest[id]; }
+        uint32 GetCatID (void)             const { return m_id; }
+        uint32 size     (void)             const { return m_TabDest.size(); }
+
+        std::string GetName(const bool IsGM = false)    const;
+        bool IsAllowedToTeleport(Player * const player) const;
+
+        static uint32 CountOfCategoryAllowedBy(Player * const player);
+
+      private:
+
+        uint32      m_id;
+        std::string m_name;
+        Flag        m_flag;
+        uint64      m_data0;
+        uint32      m_data1;
+        VDest       m_TabDest;
+    };
+
+    // Class page for current player
+    class Page
+    {
+      protected:
+
+        // Class instance for current player
+        class Instance
+        {
+          public:
+
+            Instance(Player * const player, const uint32 &PageId = 0)
+                : m_player(player), m_PageId(PageId) {}
+
+            Instance & operator =  (const uint32 &id);
+            Instance & operator ++ (void);
+            Instance   operator ++ (int32);
+            Instance & operator -- (void);
+            Instance   operator -- (int32);
+
+            uint32   GetPageId(void) const { return m_PageId; }
+            Player * GetPlayer(void) const { return m_player; }
+
+          private:
+
+            Player *m_player;
+            uint32  m_PageId;
+        };
+
+
+      public:
+
+        typedef std::vector<Instance> VInst;
+        typedef VInst::size_type      VInst_t;
+
+        Page(void) { m_TabInstance.clear(); }
+
+        Instance &   operator () (Player * const player);
+        uint32 operator [] (Player * const player) const;
+
+
+      private:
+
+        VInst m_TabInstance;
+    };
+
+    typedef std::vector <CatDest> VCatDest;
+    typedef VCatDest::size_type   VCatDest_t;
+
+    // Verification of data integrity
+    bool IsValidData(const uint32 &cat,   const Flag &flag,
+                     const uint64 &data0, const uint32 &data1);
+
+    extern VCatDest TabCatDest;
+}
+
+// Loading contents of database
+void LoadNpcTele(void);
+
+extern WorldDatabaseWorkerPool WorldDatabase;
+
+#endif
diff --git a/src/server/game/Accounts/RBAC.h b/src/server/game/Accounts/RBAC.h
index 020ed1a..3055ac57 100644
--- a/src/server/game/Accounts/RBAC.h
+++ b/src/server/game/Accounts/RBAC.h
@@ -700,6 +700,33 @@ enum RBACPermissions
     RBAC_PERM_COMMAND_GUILD_INFO                             = 794,
 
     // custom permissions 1000+
+    // Prepatch by LordPsyan
+    RBAC_PERM_COMMAND_GUILD_LINFO                            = 1000,
+    RBAC_PERM_COMMAND_GUILD_SET_LEVEL                        = 1001,
+    RBAC_PERM_COMMAND_GUILD_GIVE_XP                          = 1002,
+    // 02
+    // 03
+    // 04
+    RBAC_PERM_COMMAND_MODIFY_XP_KILL                         = 1010,
+    RBAC_PERM_COMMAND_MODIFY_XP_QUEST                        = 1011,
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     RBAC_PERM_MAX
 };
 
diff --git a/src/server/game/Anticheat/AnticheatData.cpp b/src/server/game/Anticheat/AnticheatData.cpp
new file mode 100644
index 0000000..8c69972
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatData.cpp
@@ -0,0 +1,118 @@
+#include "AnticheatData.h"
+
+AnticheatData::AnticheatData()
+{
+    lastOpcode = 0;
+    totalReports = 0;
+    for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+    {
+        typeReports[i] = 0;
+        tempReports[i] = 0;
+        tempReportsTimer[i] = 0;
+    }
+    average = 0;
+    creationTime = 0;
+    hasDailyReport = false;
+}
+
+AnticheatData::~AnticheatData()
+{
+}
+
+void AnticheatData::SetDailyReportState(bool b)
+{
+    hasDailyReport = b;
+}
+
+bool AnticheatData::GetDailyReportState()
+{
+    return hasDailyReport;
+}
+
+void AnticheatData::SetLastOpcode(uint32 opcode)
+{
+    lastOpcode = opcode;
+}
+
+void AnticheatData::SetPosition(float x, float y, float z, float o)
+{
+    lastMovementInfo.pos.m_positionX = x;
+    lastMovementInfo.pos.m_positionY = y;
+    lastMovementInfo.pos.m_positionZ = z;
+    lastMovementInfo.pos.m_orientation = o;
+}
+
+uint32 AnticheatData::GetLastOpcode() const
+{
+    return lastOpcode;
+}
+
+const MovementInfo& AnticheatData::GetLastMovementInfo() const
+{
+    return lastMovementInfo;
+}
+
+void AnticheatData::SetLastMovementInfo(MovementInfo& moveInfo)
+{
+    lastMovementInfo = moveInfo;
+}
+
+uint32 AnticheatData::GetTotalReports() const
+{
+    return totalReports;
+}
+
+void AnticheatData::SetTotalReports(uint32 _totalReports)
+{
+    totalReports = _totalReports;
+}
+
+void AnticheatData::SetTypeReports(uint32 type, uint32 amount)
+{
+    typeReports[type] = amount;
+}
+
+uint32 AnticheatData::GetTypeReports(uint32 type) const
+{
+    return typeReports[type];
+}
+
+float AnticheatData::GetAverage() const
+{
+    return average;
+}
+
+void AnticheatData::SetAverage(float _average)
+{
+    average = _average;
+}
+
+uint32 AnticheatData::GetCreationTime() const
+{
+    return creationTime;
+}
+
+void AnticheatData::SetCreationTime(uint32 _creationTime)
+{
+    creationTime = _creationTime;
+}
+
+void AnticheatData::SetTempReports(uint32 amount, uint8 type)
+{
+    tempReports[type] = amount;
+}
+
+uint32 AnticheatData::GetTempReports(uint8 type)
+{
+    return tempReports[type];
+}
+
+void AnticheatData::SetTempReportsTimer(uint32 time, uint8 type)
+{
+    tempReportsTimer[type] = time;
+}
+
+uint32 AnticheatData::GetTempReportsTimer(uint8 type)
+{
+    return tempReportsTimer[type];
+}
diff --git a/src/server/game/Anticheat/AnticheatData.h b/src/server/game/Anticheat/AnticheatData.h
new file mode 100644
index 0000000..700ad2d
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatData.h
@@ -0,0 +1,63 @@
+#ifndef SC_ACDATA_H
+#define SC_ACDATA_H
+
+#include "AnticheatMgr.h"
+
+#define MAX_REPORT_TYPES 6
+
+class AnticheatData
+{
+public:
+    AnticheatData();
+    ~AnticheatData();
+
+    void SetLastOpcode(uint32 opcode);
+    uint32 GetLastOpcode() const;
+
+    const MovementInfo& GetLastMovementInfo() const;
+    void SetLastMovementInfo(MovementInfo& moveInfo);
+
+    void SetPosition(float x, float y, float z, float o);
+
+    /*
+    bool GetDisableACCheck() const;
+    void SetDisableACCheck(bool check);
+
+    uint32 GetDisableACTimer() const;
+    void SetDisableACTimer(uint32 timer);*/
+
+    uint32 GetTotalReports() const;
+    void SetTotalReports(uint32 _totalReports);
+
+    uint32 GetTypeReports(uint32 type) const;
+    void SetTypeReports(uint32 type, uint32 amount);
+
+    float GetAverage() const;
+    void SetAverage(float _average);
+
+    uint32 GetCreationTime() const;
+    void SetCreationTime(uint32 creationTime);
+
+    void SetTempReports(uint32 amount, uint8 type);
+    uint32 GetTempReports(uint8 type);
+
+    void SetTempReportsTimer(uint32 time, uint8 type);
+    uint32 GetTempReportsTimer(uint8 type);
+
+    void SetDailyReportState(bool b);
+    bool GetDailyReportState();
+private:
+    uint32 lastOpcode;
+    MovementInfo lastMovementInfo;
+    //bool disableACCheck;
+    //uint32 disableACCheckTimer;
+    uint32 totalReports;
+    uint32 typeReports[MAX_REPORT_TYPES];
+    float average;
+    uint32 creationTime;
+    uint32 tempReports[MAX_REPORT_TYPES];
+    uint32 tempReportsTimer[MAX_REPORT_TYPES];
+    bool hasDailyReport;
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/Anticheat/AnticheatMgr.cpp b/src/server/game/Anticheat/AnticheatMgr.cpp
new file mode 100644
index 0000000..f409e93
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.cpp
@@ -0,0 +1,434 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "AnticheatMgr.h"
+#include "AnticheatScripts.h"
+#include "MapManager.h"
+
+#define CLIMB_ANGLE 1.9f
+
+AnticheatMgr::AnticheatMgr()
+{
+}
+
+AnticheatMgr::~AnticheatMgr()
+{
+    m_Players.clear();
+}
+
+void AnticheatMgr::JumpHackDetection(Player* player, MovementInfo /* movementInfo */,uint32 opcode)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & JUMP_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (m_Players[key].GetLastOpcode() == MSG_MOVE_JUMP && opcode == MSG_MOVE_JUMP)
+    {
+        BuildReport(player,JUMP_HACK_REPORT);
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Jump-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    }
+}
+
+void AnticheatMgr::WalkOnWaterHackDetection(Player* player, MovementInfo /* movementInfo */)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & WALK_WATER_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+    if (!m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_WATERWALKING))
+        return;
+
+    // if we are a ghost we can walk on water
+    if (!player->IsAlive())
+        return;
+
+    if (player->HasAuraType(SPELL_AURA_FEATHER_FALL) ||
+        player->HasAuraType(SPELL_AURA_SAFE_FALL) ||
+        player->HasAuraType(SPELL_AURA_WATER_WALK))
+        return;
+
+    TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Walk on Water - Hack detected player GUID (low) %u",player->GetGUIDLow());
+    BuildReport(player,WALK_WATER_HACK_REPORT);
+
+}
+
+void AnticheatMgr::FlyHackDetection(Player* player, MovementInfo /* movementInfo */)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & FLY_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+    if (!m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_FLYING))
+        return;
+
+    if (player->HasAuraType(SPELL_AURA_FLY) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) ||
+        player->HasAuraType(SPELL_AURA_MOD_INCREASE_FLIGHT_SPEED))
+        return;
+
+    TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Fly-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    BuildReport(player,FLY_HACK_REPORT);
+}
+
+void AnticheatMgr::TeleportPlaneHackDetection(Player* player, MovementInfo movementInfo)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & TELEPORT_PLANE_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (m_Players[key].GetLastMovementInfo().pos.GetPositionZ() != 0 ||
+        movementInfo.pos.GetPositionZ() != 0)
+        return;
+
+    if (movementInfo.HasMovementFlag(MOVEMENTFLAG_FALLING))
+        return;
+
+    //DEAD_FALLING was deprecated
+    //if (player->getDeathState() == DEAD_FALLING)
+    //    return;
+    float x, y, z;
+    player->GetPosition(x, y, z);
+    float ground_Z = player->GetMap()->GetHeight(x, y, z);
+    float z_diff = fabs(ground_Z - z);
+
+    // we are not really walking there
+    if (z_diff > 1.0f)
+    {
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Teleport To Plane - Hack detected player GUID (low) %u",player->GetGUIDLow());
+        BuildReport(player,TELEPORT_PLANE_HACK_REPORT);
+    }
+}
+
+void AnticheatMgr::StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode)
+{
+    if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        return;
+
+    if (player->IsGameMaster())
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (player->IsInFlight() || player->GetTransport() || player->GetVehicle())
+    {
+        m_Players[key].SetLastMovementInfo(movementInfo);
+        m_Players[key].SetLastOpcode(opcode);
+        return;
+    }
+
+    SpeedHackDetection(player,movementInfo);
+    FlyHackDetection(player,movementInfo);
+    WalkOnWaterHackDetection(player,movementInfo);
+    JumpHackDetection(player,movementInfo,opcode);
+    TeleportPlaneHackDetection(player, movementInfo);
+    ClimbHackDetection(player,movementInfo,opcode);
+
+    m_Players[key].SetLastMovementInfo(movementInfo);
+    m_Players[key].SetLastOpcode(opcode);
+}
+
+// basic detection
+void AnticheatMgr::ClimbHackDetection(Player *player, MovementInfo movementInfo, uint32 opcode)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & CLIMB_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    if (opcode != MSG_MOVE_HEARTBEAT ||
+        m_Players[key].GetLastOpcode() != MSG_MOVE_HEARTBEAT)
+        return;
+
+    // in this case we don't care if they are "legal" flags, they are handled in another parts of the Anticheat Manager.
+    if (player->IsInWater() ||
+        player->IsFlying() ||
+        player->IsFalling())
+        return;
+
+    Position playerPos;
+    Position pos = player->GetPosition();
+
+    float deltaZ = fabs(playerPos.GetPositionZ() - movementInfo.pos.GetPositionZ());
+    float deltaXY = movementInfo.pos.GetExactDist2d(&playerPos);
+
+    float angle = Position::NormalizeOrientation(tan(deltaZ/deltaXY));
+
+    if (angle > CLIMB_ANGLE)
+    {
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Climb-Hack detected player GUID (low) %u", player->GetGUIDLow());
+        BuildReport(player,CLIMB_HACK_REPORT);
+    }
+}
+
+void AnticheatMgr::SpeedHackDetection(Player* player,MovementInfo movementInfo)
+{
+    if ((sWorld->getIntConfig(CONFIG_ANTICHEAT_DETECTIONS_ENABLED) & SPEED_HACK_DETECTION) == 0)
+        return;
+
+    uint32 key = player->GetGUIDLow();
+
+    // We also must check the map because the movementFlag can be modified by the client.
+    // If we just check the flag, they could always add that flag and always skip the speed hacking detection.
+    // 369 == DEEPRUN TRAM
+    if (m_Players[key].GetLastMovementInfo().HasMovementFlag(MOVEMENTFLAG_ONTRANSPORT) && player->GetMapId() == 369)
+        return;
+
+    uint32 distance2D = (uint32)movementInfo.pos.GetExactDist2d(&m_Players[key].GetLastMovementInfo().pos);
+    uint8 moveType = 0;
+
+    // we need to know HOW is the player moving
+    // TO-DO: Should we check the incoming movement flags?
+    if (player->HasUnitMovementFlag(MOVEMENTFLAG_SWIMMING))
+        moveType = MOVE_SWIM;
+    else if (player->IsFlying())
+        moveType = MOVE_FLIGHT;
+    else if (player->HasUnitMovementFlag(MOVEMENTFLAG_WALKING))
+        moveType = MOVE_WALK;
+    else
+        moveType = MOVE_RUN;
+
+    // how many yards the player can do in one sec.
+    uint32 speedRate = (uint32)(player->GetSpeed(UnitMoveType(moveType)) + movementInfo.jump.xyspeed);
+
+    // how long the player took to move to here.
+    uint32 timeDiff = getMSTimeDiff(m_Players[key].GetLastMovementInfo().time,movementInfo.time);
+
+    if (!timeDiff)
+        timeDiff = 1;
+
+    // this is the distance doable by the player in 1 sec, using the time done to move to this point.
+    uint32 clientSpeedRate = distance2D * 1000 / timeDiff;
+
+    // we did the (uint32) cast to accept a margin of tolerance
+    if (clientSpeedRate > speedRate)
+    {
+        BuildReport(player,SPEED_HACK_REPORT);
+        TC_LOG_DEBUG("entities.player.character", "AnticheatMgr:: Speed-Hack detected player GUID (low) %u",player->GetGUIDLow());
+    }
+}
+
+void AnticheatMgr::StartScripts()
+{
+    new AnticheatScripts();
+}
+
+void AnticheatMgr::HandlePlayerLogin(Player* player)
+{
+    // we must delete this to prevent errors in case of crash
+    CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u",player->GetGUIDLow());
+    // we initialize the pos of lastMovementPosition var.
+    m_Players[player->GetGUIDLow()].SetPosition(player->GetPositionX(),player->GetPositionY(),player->GetPositionZ(),player->GetOrientation());
+    QueryResult resultDB = CharacterDatabase.PQuery("SELECT * FROM daily_players_reports WHERE guid=%u;",player->GetGUIDLow());
+
+    if (resultDB)
+        m_Players[player->GetGUIDLow()].SetDailyReportState(true);
+}
+
+void AnticheatMgr::HandlePlayerLogout(Player* player)
+{
+    // TO-DO Make a table that stores the cheaters of the day, with more detailed information.
+
+    // We must also delete it at logout to prevent have data of offline players in the db when we query the database (IE: The GM Command)
+    CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u",player->GetGUIDLow());
+    // Delete not needed data from the memory.
+    m_Players.erase(player->GetGUIDLow());
+}
+
+void AnticheatMgr::SavePlayerData(Player* player)
+{
+    CharacterDatabase.PExecute("REPLACE INTO players_reports_status (guid,average,total_reports,speed_reports,fly_reports,jump_reports,waterwalk_reports,teleportplane_reports,climb_reports,creation_time) VALUES (%u,%f,%u,%u,%u,%u,%u,%u,%u,%u);",player->GetGUIDLow(),m_Players[player->GetGUIDLow()].GetAverage(),m_Players[player->GetGUIDLow()].GetTotalReports(), m_Players[player->GetGUIDLow()].GetTypeReports(SPEED_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(FLY_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(JUMP_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(WALK_WATER_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(TELEPORT_PLANE_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(CLIMB_HACK_REPORT),m_Players[player->GetGUIDLow()].GetCreationTime());
+}
+
+uint32 AnticheatMgr::GetTotalReports(uint32 lowGUID)
+{
+    return m_Players[lowGUID].GetTotalReports();
+}
+
+float AnticheatMgr::GetAverage(uint32 lowGUID)
+{
+    return m_Players[lowGUID].GetAverage();
+}
+
+uint32 AnticheatMgr::GetTypeReports(uint32 lowGUID, uint8 type)
+{
+    return m_Players[lowGUID].GetTypeReports(type);
+}
+
+bool AnticheatMgr::MustCheckTempReports(uint8 type)
+{
+    if (type == JUMP_HACK_REPORT)
+        return false;
+
+    return true;
+}
+
+void AnticheatMgr::BuildReport(Player* player,uint8 reportType)
+{
+    uint32 key = player->GetGUIDLow();
+
+    if (MustCheckTempReports(reportType))
+    {
+        uint32 actualTime = getMSTime();
+
+        if (!m_Players[key].GetTempReportsTimer(reportType))
+            m_Players[key].SetTempReportsTimer(actualTime,reportType);
+
+        if (getMSTimeDiff(m_Players[key].GetTempReportsTimer(reportType),actualTime) < 3000)
+        {
+            m_Players[key].SetTempReports(m_Players[key].GetTempReports(reportType)+1,reportType);
+
+            if (m_Players[key].GetTempReports(reportType) < 3)
+                return;
+        } else
+        {
+            m_Players[key].SetTempReportsTimer(actualTime,reportType);
+            m_Players[key].SetTempReports(1,reportType);
+            return;
+        }
+    }
+
+    // generating creationTime for average calculation
+    if (!m_Players[key].GetTotalReports())
+        m_Players[key].SetCreationTime(getMSTime());
+
+    // increasing total_reports
+    m_Players[key].SetTotalReports(m_Players[key].GetTotalReports()+1);
+    // increasing specific cheat report
+    m_Players[key].SetTypeReports(reportType,m_Players[key].GetTypeReports(reportType)+1);
+
+    // diff time for average calculation
+    uint32 diffTime = getMSTimeDiff(m_Players[key].GetCreationTime(),getMSTime()) / IN_MILLISECONDS;
+
+    if (diffTime > 0)
+    {
+        // Average == Reports per second
+        float average = float(m_Players[key].GetTotalReports()) / float(diffTime);
+        m_Players[key].SetAverage(average);
+    }
+
+    if (sWorld->getIntConfig(CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT) < m_Players[key].GetTotalReports())
+    {
+        if (!m_Players[key].GetDailyReportState())
+        {
+            CharacterDatabase.PExecute("REPLACE INTO daily_players_reports (guid,average,total_reports,speed_reports,fly_reports,jump_reports,waterwalk_reports,teleportplane_reports,climb_reports,creation_time) VALUES (%u,%f,%u,%u,%u,%u,%u,%u,%u,%u);",player->GetGUIDLow(),m_Players[player->GetGUIDLow()].GetAverage(),m_Players[player->GetGUIDLow()].GetTotalReports(), m_Players[player->GetGUIDLow()].GetTypeReports(SPEED_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(FLY_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(JUMP_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(WALK_WATER_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(TELEPORT_PLANE_HACK_REPORT),m_Players[player->GetGUIDLow()].GetTypeReports(CLIMB_HACK_REPORT),m_Players[player->GetGUIDLow()].GetCreationTime());
+            m_Players[key].SetDailyReportState(true);
+        }
+    }
+
+    if (m_Players[key].GetTotalReports() > sWorld->getIntConfig(CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION))
+    {
+        // display warning at the center of the screen, hacky way?
+        std::string str = "";
+        str = "|cFFFFFC00[AC]|cFF00FFFF[|cFF60FF00" + std::string(player->GetName().c_str()) + "|cFF00FFFF] Possible cheater!";
+        WorldPacket data(SMSG_NOTIFICATION, (str.size()+1));
+        data << str;
+        sWorld->SendGlobalGMMessage(&data);
+    }
+}
+
+void AnticheatMgr::AnticheatGlobalCommand(ChatHandler* handler)
+{
+    // MySQL will sort all for us, anyway this is not the best way we must only save the anticheat data not whole player's data!.
+    sObjectAccessor->SaveAllPlayers();
+
+    QueryResult resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY average ASC LIMIT 3;");
+    if (!resultDB)
+    {
+        handler->PSendSysMessage("No players found.");
+        return;
+    } else
+    {
+        handler->SendSysMessage("=============================");
+        handler->PSendSysMessage("Players with the lowest averages:");
+        do
+        {
+            Field *fieldsDB = resultDB->Fetch();
+
+            uint32 guid = fieldsDB[0].GetUInt32();
+            float average = fieldsDB[1].GetFloat();
+            uint32 total_reports = fieldsDB[2].GetUInt32();
+
+            if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                handler->PSendSysMessage("Player: %s Average: %f Total Reports: %u",player->GetName().c_str(),average,total_reports);
+
+        } while (resultDB->NextRow());
+    }
+
+    resultDB = CharacterDatabase.Query("SELECT guid,average,total_reports FROM players_reports_status WHERE total_reports != 0 ORDER BY total_reports DESC LIMIT 3;");
+
+    // this should never happen
+    if (!resultDB)
+    {
+        handler->PSendSysMessage("No players found.");
+        return;
+    } else
+    {
+        handler->SendSysMessage("=============================");
+        handler->PSendSysMessage("Players with the more reports:");
+        do
+        {
+            Field *fieldsDB = resultDB->Fetch();
+
+            uint32 guid = fieldsDB[0].GetUInt32();
+            float average = fieldsDB[1].GetFloat();
+            uint32 total_reports = fieldsDB[2].GetUInt32();
+
+            if (Player* player = sObjectMgr->GetPlayerByLowGUID(guid))
+                handler->PSendSysMessage("Player: %s Total Reports: %u Average: %f",player->GetName().c_str(),total_reports,average);
+
+        } while (resultDB->NextRow());
+    }
+}
+
+void AnticheatMgr::AnticheatDeleteCommand(uint32 guid)
+{
+    if (!guid)
+    {
+        for (AnticheatPlayersDataMap::iterator it = m_Players.begin(); it != m_Players.end(); ++it)
+        {
+            (*it).second.SetTotalReports(0);
+            (*it).second.SetAverage(0);
+            (*it).second.SetCreationTime(0);
+            for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+            {
+                (*it).second.SetTempReports(0,i);
+                (*it).second.SetTempReportsTimer(0,i);
+                (*it).second.SetTypeReports(i,0);
+            }
+        }
+        CharacterDatabase.PExecute("DELETE FROM players_reports_status;");
+    }
+    else
+    {
+        m_Players[guid].SetTotalReports(0);
+        m_Players[guid].SetAverage(0);
+        m_Players[guid].SetCreationTime(0);
+        for (uint8 i = 0; i < MAX_REPORT_TYPES; i++)
+        {
+            m_Players[guid].SetTempReports(0,i);
+            m_Players[guid].SetTempReportsTimer(0,i);
+            m_Players[guid].SetTypeReports(i,0);
+        }
+        CharacterDatabase.PExecute("DELETE FROM players_reports_status WHERE guid=%u;",guid);
+    }
+}
+
+void AnticheatMgr::ResetDailyReportStates()
+{
+     for (AnticheatPlayersDataMap::iterator it = m_Players.begin(); it != m_Players.end(); ++it)
+         m_Players[(*it).first].SetDailyReportState(false);
+}
diff --git a/src/server/game/Anticheat/AnticheatMgr.h b/src/server/game/Anticheat/AnticheatMgr.h
new file mode 100644
index 0000000..554bdfa
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatMgr.h
@@ -0,0 +1,103 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef SC_ACMGR_H
+#define SC_ACMGR_H
+
+//#include <ace/Singleton.h>
+#include "Common.h"
+#include "SharedDefines.h"
+#include "ScriptPCH.h"
+#include "AnticheatData.h"
+#include "Chat.h"
+
+class Player;
+class AnticheatData;
+
+enum ReportTypes
+{
+    SPEED_HACK_REPORT = 0,
+    FLY_HACK_REPORT,
+    WALK_WATER_HACK_REPORT,
+    JUMP_HACK_REPORT,
+    TELEPORT_PLANE_HACK_REPORT,
+    CLIMB_HACK_REPORT,
+
+   // MAX_REPORT_TYPES
+};
+
+enum DetectionTypes
+{
+    SPEED_HACK_DETECTION            = 1,
+    FLY_HACK_DETECTION              = 2,
+    WALK_WATER_HACK_DETECTION       = 4,
+    JUMP_HACK_DETECTION             = 8,
+    TELEPORT_PLANE_HACK_DETECTION   = 16,
+    CLIMB_HACK_DETECTION            = 32
+};
+
+// GUIDLow is the key.
+typedef std::map<uint32, AnticheatData> AnticheatPlayersDataMap;
+
+class AnticheatMgr
+{
+//    friend class ACE_Singleton<AnticheatMgr, ACE_Null_Mutex>;
+    AnticheatMgr();
+    ~AnticheatMgr();
+
+    public:
+    static AnticheatMgr* instance()
+        {
+           static AnticheatMgr* instance = new AnticheatMgr();
+           return instance;
+        }
+
+        void StartHackDetection(Player* player, MovementInfo movementInfo, uint32 opcode);
+        void DeletePlayerReport(Player* player, bool login);
+        void DeletePlayerData(Player* player);
+        void CreatePlayerData(Player* player);
+        void SavePlayerData(Player* player);
+
+        void StartScripts();
+
+        void HandlePlayerLogin(Player* player);
+        void HandlePlayerLogout(Player* player);
+
+        uint32 GetTotalReports(uint32 lowGUID);
+        float GetAverage(uint32 lowGUID);
+        uint32 GetTypeReports(uint32 lowGUID, uint8 type);
+
+        void AnticheatGlobalCommand(ChatHandler* handler);
+        void AnticheatDeleteCommand(uint32 guid);
+
+        void ResetDailyReportStates();
+    private:
+        void SpeedHackDetection(Player* player, MovementInfo movementInfo);
+        void FlyHackDetection(Player* player, MovementInfo movementInfo);
+        void WalkOnWaterHackDetection(Player* player, MovementInfo movementInfo);
+        void JumpHackDetection(Player* player, MovementInfo movementInfo,uint32 opcode);
+        void TeleportPlaneHackDetection(Player* player, MovementInfo);
+        void ClimbHackDetection(Player* player,MovementInfo movementInfo,uint32 opcode);
+
+        void BuildReport(Player* player,uint8 reportType);
+
+        bool MustCheckTempReports(uint8 type);
+
+        AnticheatPlayersDataMap m_Players;                        ///< Player data
+};
+
+#define sAnticheatMgr AnticheatMgr::instance()
+
+#endif
diff --git a/src/server/game/Anticheat/AnticheatScripts.cpp b/src/server/game/Anticheat/AnticheatScripts.cpp
new file mode 100644
index 0000000..340178d
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatScripts.cpp
@@ -0,0 +1,14 @@
+#include "AnticheatScripts.h"
+#include "AnticheatMgr.h"
+
+AnticheatScripts::AnticheatScripts(): PlayerScript("AnticheatScripts") {}
+
+void AnticheatScripts::OnLogout(Player* player)
+{
+    sAnticheatMgr->HandlePlayerLogout(player);
+}
+
+void AnticheatScripts::OnLogin(Player* player,bool)
+{
+    sAnticheatMgr->HandlePlayerLogin(player);
+}
diff --git a/src/server/game/Anticheat/AnticheatScripts.h b/src/server/game/Anticheat/AnticheatScripts.h
new file mode 100644
index 0000000..25d34d0
--- /dev/null
+++ b/src/server/game/Anticheat/AnticheatScripts.h
@@ -0,0 +1,15 @@
+#ifndef SC_ACSCRIPTS_H
+#define SC_ACSCRIPTS_H
+
+#include "ScriptPCH.h"
+
+class AnticheatScripts: public PlayerScript
+{
+    public:
+        AnticheatScripts();
+
+        void OnLogout(Player* player);
+        void OnLogin(Player* player,bool);
+};
+
+#endif
\ No newline at end of file
diff --git a/src/server/game/Battlegrounds/Arena.cpp b/src/server/game/Battlegrounds/Arena.cpp
index cdc6fc3..0830ba1 100644
--- a/src/server/game/Battlegrounds/Arena.cpp
+++ b/src/server/game/Battlegrounds/Arena.cpp
@@ -40,9 +40,9 @@ Arena::Arena()
 void Arena::AddPlayer(Player* player)
 {
     Battleground::AddPlayer(player);
-    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetBGTeam());
+    PlayerScores[player->GetGUIDLow()] = new ArenaScore(player->GetGUID(), player->GetTeam());
 
-    if (player->GetBGTeam() == ALLIANCE)        // gold
+    if (player->GetTeam() == ALLIANCE)        // gold
     {
         if (player->GetTeam() == HORDE)
             player->CastSpell(player, SPELL_HORDE_GOLD_FLAG, true);
diff --git a/src/server/game/Battlegrounds/Battleground.cpp b/src/server/game/Battlegrounds/Battleground.cpp
index 6f6d1b6..8e04104 100644
--- a/src/server/game/Battlegrounds/Battleground.cpp
+++ b/src/server/game/Battlegrounds/Battleground.cpp
@@ -288,7 +288,7 @@ inline void Battleground::_CheckSafePositions(uint32 diff)
             if (Player* player = ObjectAccessor::FindPlayer(itr->first))
             {
                 Position pos = player->GetPosition();
-                Position const* startPos = GetTeamStartPosition(Battleground::GetTeamIndexByTeamId(player->GetBGTeam()));
+                Position const* startPos = GetTeamStartPosition(Battleground::GetTeamIndexByTeamId(player->GetTeam()));
                 if (pos.GetExactDistSq(startPos) > maxDist)
                 {
                     TC_LOG_DEBUG("bg.battleground", "BATTLEGROUND: Sending %s back to start location (map: %u) (possible exploit)", player->GetName().c_str(), GetMapId());
@@ -494,7 +494,7 @@ inline void Battleground::_ProcessJoin(uint32 diff)
                     WorldPacket status;
                     BattlegroundQueueTypeId bgQueueTypeId = sBattlegroundMgr->BGQueueTypeId(m_TypeID, GetArenaType());
                     uint32 queueSlot = player->GetBattlegroundQueueIndex(bgQueueTypeId);
-                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetBGTeam());
+                    sBattlegroundMgr->BuildBattlegroundStatusPacket(&status, this, queueSlot, STATUS_IN_PROGRESS, 0, GetStartTime(), GetArenaType(), player->GetTeam());
                     player->SendDirectMessage(&status);
 
                     player->RemoveAurasDueToSpell(SPELL_ARENA_PREPARATION);
@@ -662,22 +662,34 @@ void Battleground::RewardHonorToTeam(uint32 Honor, uint32 TeamID)
             UpdatePlayerScore(player, SCORE_BONUS_HONOR, Honor);
 }
 
-void Battleground::RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID)
+void Battleground::RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 TeamID)
 {
-    FactionEntry const* factionEntry = sFactionStore.LookupEntry(faction_id);
-    if (!factionEntry)
+    FactionEntry const* a_factionEntry = sFactionStore.LookupEntry(a_faction_id);
+    FactionEntry const* h_factionEntry = sFactionStore.LookupEntry(h_faction_id);
+
+    if (!a_factionEntry || !h_factionEntry)
         return;
 
     for (BattlegroundPlayerMap::const_iterator itr = m_Players.begin(); itr != m_Players.end(); ++itr)
     {
-        Player* player = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam");
-        if (!player)
+       if (itr->second.OfflineRemoveTime)
             continue;
 
-        uint32 repGain = Reputation;
-        AddPct(repGain, player->GetTotalAuraModifier(SPELL_AURA_MOD_REPUTATION_GAIN));
-        AddPct(repGain, player->GetTotalAuraModifierByMiscValue(SPELL_AURA_MOD_FACTION_REPUTATION_GAIN, faction_id));
-        player->GetReputationMgr().ModifyReputation(factionEntry, repGain);
+        Player* plr = ObjectAccessor::FindPlayer(itr->first);
+
+        if (!plr)
+        {
+            TC_LOG_ERROR("bg.battleground", "BattleGround:RewardReputationToTeam: %u not found!", itr->first);
+            continue;
+        }
+
+        //uint32 team = plr->GetTeam();
+
+        //if (team == TeamId)
+        if (Player* plr = _GetPlayerForTeam(TeamID, itr, "RewardReputationToTeam"))
+            {
+            plr->GetReputationMgr().ModifyReputation(plr->GetOTeam() == ALLIANCE ? a_factionEntry : h_factionEntry, Reputation);
+            }
     }
 }
 
@@ -830,7 +842,7 @@ void Battleground::EndBattleground(uint32 winner)
         player->SendDirectMessage(&pvpLogData);
 
         WorldPacket data;
-        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetBGTeam());
+        sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, TIME_TO_AUTOREMOVE, GetStartTime(), GetArenaType(), player->GetTeam());
         player->SendDirectMessage(&data);
         player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_COMPLETE_BATTLEGROUND, 1);
     }
@@ -946,6 +958,7 @@ void Battleground::RemovePlayerAtLeave(uint64 guid, bool Transport, bool SendPac
 
     if (player)
     {
+        player->FitPlayerInTeam(false, this);
         // Do next only if found in battleground
         player->SetBattlegroundId(0, BATTLEGROUND_TYPE_NONE);  // We're not in BG.
         // reset destination bg team
@@ -1015,7 +1028,7 @@ void Battleground::AddPlayer(Player* player)
     // score struct must be created in inherited class
 
     uint64 guid = player->GetGUID();
-    uint32 team = player->GetBGTeam();
+    uint32 team = player->GetTeam();
 
     BattlegroundPlayer bp;
     bp.OfflineRemoveTime = 0;
@@ -1066,6 +1079,8 @@ void Battleground::AddPlayer(Player* player)
     // setup BG group membership
     PlayerAddedToBGCheckIfBGIsRunning(player);
     AddOrSetPlayerToCorrectBgGroup(player, team);
+
+    player->FitPlayerInTeam(true, this);
 }
 
 // this method adds player to his team's bg group, or sets his correct group if player is already in bg group
@@ -1135,8 +1150,8 @@ void Battleground::EventPlayerLoggedOut(Player* player)
 
         // 1 player is logging out, if it is the last, then end arena!
         if (isArena())
-            if (GetAlivePlayersCountByTeam(player->GetBGTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetBGTeam())))
-                EndBattleground(GetOtherTeam(player->GetBGTeam()));
+            if (GetAlivePlayersCountByTeam(player->GetTeam()) <= 1 && GetPlayersCountByTeam(GetOtherTeam(player->GetTeam())))
+                EndBattleground(GetOtherTeam(player->GetTeam()));
     }
 }
 
@@ -1744,7 +1759,7 @@ void Battleground::PlayerAddedToBGCheckIfBGIsRunning(Player* player)
     BuildPvPLogDataPacket(data);
     player->SendDirectMessage(&data);
 
-    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetBGTeam());
+    sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, this, player->GetBattlegroundQueueIndex(bgQueueTypeId), STATUS_IN_PROGRESS, GetEndTime(), GetStartTime(), GetArenaType(), player->GetTeam());
     player->SendDirectMessage(&data);
 }
 
diff --git a/src/server/game/Battlegrounds/Battleground.h b/src/server/game/Battlegrounds/Battleground.h
index b027019..e30a625 100644
--- a/src/server/game/Battlegrounds/Battleground.h
+++ b/src/server/game/Battlegrounds/Battleground.h
@@ -354,7 +354,7 @@ class Battleground
         void CastSpellOnTeam(uint32 SpellID, uint32 TeamID);
         void RemoveAuraOnTeam(uint32 SpellID, uint32 TeamID);
         void RewardHonorToTeam(uint32 Honor, uint32 TeamID);
-        void RewardReputationToTeam(uint32 faction_id, uint32 Reputation, uint32 TeamID);
+        void RewardReputationToTeam(uint32 a_faction_id, uint32 h_faction_id, uint32 Reputation, uint32 TeamId);
         void UpdateWorldState(uint32 Field, uint32 Value);
         void UpdateWorldStateForPlayer(uint32 Field, uint32 Value, Player* player);
         virtual void EndBattleground(uint32 winner);
diff --git a/src/server/game/Battlegrounds/BattlegroundMgr.cpp b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
index 82ea090..d5370b6 100644
--- a/src/server/game/Battlegrounds/BattlegroundMgr.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundMgr.cpp
@@ -695,7 +695,7 @@ void BattlegroundMgr::SendToBattleground(Player* player, uint32 instanceId, Batt
     if (Battleground* bg = GetBattleground(instanceId, bgTypeId))
     {
         uint32 mapid = bg->GetMapId();
-        uint32 team = player->GetBGTeam();
+        uint32 team = player->GetTeam();
         if (team == 0)
             team = player->GetTeam();
 
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.cpp b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
index e52f75a..d8d2fd3 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.cpp
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.cpp
@@ -154,6 +154,10 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         index += BG_TEAMS_COUNT;
     if (ginfo->Team == HORDE)
         index++;
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && ArenaType == 0)
+        index = BG_QUEUE_MIXED;                      // BG_QUEUE_*_* -> BG_QUEUE_MIXED
+
     TC_LOG_DEBUG("bg.battleground", "Adding Group to BattlegroundQueue bgTypeId : %u, bracket_id : %u, index : %u", BgTypeId, bracketId, index);
 
     uint32 lastOnlineTime = getMSTime();
@@ -198,33 +202,58 @@ GroupQueueInfo* BattlegroundQueue::AddGroup(Player* leader, Group* grp, Battlegr
         {
             if (Battleground* bg = sBattlegroundMgr->GetBattlegroundTemplate(ginfo->BgTypeId))
             {
-                uint32 MinPlayers = bg->GetMinPlayersPerTeam();
-                uint32 qHorde = 0;
-                uint32 qAlliance = 0;
-                uint32 q_min_level = bracketEntry->minLevel;
-                uint32 q_max_level = bracketEntry->maxLevel;
-                GroupsQueueType::const_iterator itr;
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qAlliance += (*itr)->Players.size();
-                for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
-                    if (!(*itr)->IsInvitedToBGInstanceGUID)
-                        qHorde += (*itr)->Players.size();
-
-                // Show queue status to player only (when joining queue)
-                if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED))
                 {
-                    ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bg->GetName().c_str(), q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    char const* bgName = bg->GetName().c_str();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam()*2;
+                    uint32 qPlayers = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracketId][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_MIXED].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qPlayers += (*itr)->Players.size();
+
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage("Queue status for %s (Lvl: %u to %u) Queued players: %u (Need at least %u more)", bgName, q_min_level, q_max_level, qPlayers, MinPlayers - qPlayers);
+                    }
+                    else
+                    {
+                        std::ostringstream ss;
+                        ss << "|cffff0000[BG Queue Announcer]:|r " << bgName << " -- [" << q_min_level << "-" << q_max_level << "] " << qPlayers << "/" << MinPlayers;
+                        sWorld->SendGlobalText(ss.str().c_str(), NULL);
+                    }
                 }
-                // System message
                 else
                 {
-                    sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bg->GetName().c_str(), q_min_level, q_max_level,
-                        qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    std::string bgName = bg->GetName().c_str();
+                    uint32 MinPlayers = bg->GetMinPlayersPerTeam();
+                    uint32 qHorde = 0;
+                    uint32 qAlliance = 0;
+                    uint32 q_min_level = bracketEntry->minLevel;
+                    uint32 q_max_level = bracketEntry->maxLevel;
+                    GroupsQueueType::const_iterator itr;
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_ALLIANCE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qAlliance += (*itr)->Players.size();
+                    for (itr = m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].begin(); itr != m_QueuedGroups[bracketId][BG_QUEUE_NORMAL_HORDE].end(); ++itr)
+                        if (!(*itr)->IsInvitedToBGInstanceGUID)
+                            qHorde += (*itr)->Players.size();
+
+                    // Show queue status to player only (when joining queue)
+                    if (sWorld->getBoolConfig(CONFIG_BATTLEGROUND_QUEUE_ANNOUNCER_PLAYERONLY))
+                    {
+                        ChatHandler(leader->GetSession()).PSendSysMessage(LANG_BG_QUEUE_ANNOUNCE_SELF, bg->GetName().c_str(), q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
+                    // System message
+                    else
+                    {
+                        sWorld->SendWorldText(LANG_BG_QUEUE_ANNOUNCE_WORLD, bg->GetName().c_str(), q_min_level, q_max_level,
+                            qAlliance, (MinPlayers > qAlliance) ? MinPlayers - qAlliance : (uint32)0, qHorde, (MinPlayers > qHorde) ? MinPlayers - qHorde : (uint32)0);
+                    }
                 }
-            }
-        }
+            }        }
         //release mutex
     }
 
@@ -308,7 +337,7 @@ void BattlegroundQueue::RemovePlayer(uint64 guid, bool decreaseInvitedCount)
     {
         //we must check premade and normal team's queue - because when players from premade are joining bg,
         //they leave groupinfo so we can't use its players size to find out index
-        for (uint32 j = index; j < BG_QUEUE_GROUP_TYPES_COUNT; j += BG_TEAMS_COUNT)
+        for (uint8 j = 0; j < BG_QUEUE_GROUP_TYPES_COUNT; ++j)
         {
             GroupsQueueType::iterator k = m_QueuedGroups[bracket_id_tmp][j].begin();
             for (; k != m_QueuedGroups[bracket_id_tmp][j].end(); ++k)
@@ -497,6 +526,10 @@ void BattlegroundQueue::FillPlayersToBG(Battleground* bg, BattlegroundBracketId
     int32 hordeFree = bg->GetFreeSlotsForTeam(HORDE);
     int32 aliFree   = bg->GetFreeSlotsForTeam(ALLIANCE);
 
+    if (!bg->isArena())
+        if (FillXPlayersToBG(bracket_id, bg, false))
+            return;
+
     //iterator for iterating through bg queue
     GroupsQueueType::const_iterator Ali_itr = m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].begin();
     //count of groups in queue - used to stop cycles
@@ -745,7 +778,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     if (m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_ALLIANCE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_PREMADE_HORDE].empty() &&
         m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_ALLIANCE].empty() &&
-        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty())
+        m_QueuedGroups[bracket_id][BG_QUEUE_NORMAL_HORDE].empty() &&
+        m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].empty())
         return;
 
     // battleground with free slot for player should be always in the beggining of the queue
@@ -836,7 +870,8 @@ void BattlegroundQueue::BattlegroundQueueUpdate(uint32 /*diff*/, BattlegroundTyp
     {
         // if there are enough players in pools, start new battleground or non rated arena
         if (CheckNormalMatch(bg_template, bracket_id, MinPlayersPerTeam, MaxPlayersPerTeam)
-            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam)))
+            || (bg_template->isArena() && CheckSkirmishForSameFaction(bracket_id, MinPlayersPerTeam))
+            || CheckCrossFactionMatch(bracket_id, bg_template))
         {
             // we successfully created a pool
             Battleground* bg2 = sBattlegroundMgr->CreateNewBattleground(bgTypeId, bracketEntry, arenaType, false);
diff --git a/src/server/game/Battlegrounds/BattlegroundQueue.h b/src/server/game/Battlegrounds/BattlegroundQueue.h
index f95e8ba..5d506eb 100644
--- a/src/server/game/Battlegrounds/BattlegroundQueue.h
+++ b/src/server/game/Battlegrounds/BattlegroundQueue.h
@@ -42,6 +42,7 @@ struct GroupQueueInfo                                       // stores informatio
 {
     std::map<uint64, PlayerQueueInfo*> Players;             // player queue info map
     uint32  Team;                                           // Player team (ALLIANCE/HORDE)
+    uint32  OTeam;                                          // Player team (ALLIANCE/HORDE)
     BattlegroundTypeId BgTypeId;                            // battleground type id
     bool    IsRated;                                        // rated
     uint8   ArenaType;                                      // 2v2, 3v3, 5v5 or 0 when BG
@@ -60,9 +61,10 @@ enum BattlegroundQueueGroupTypes
     BG_QUEUE_PREMADE_ALLIANCE   = 0,
     BG_QUEUE_PREMADE_HORDE      = 1,
     BG_QUEUE_NORMAL_ALLIANCE    = 2,
-    BG_QUEUE_NORMAL_HORDE       = 3
+    BG_QUEUE_NORMAL_HORDE       = 3,
+    BG_QUEUE_MIXED              = 4
 };
-#define BG_QUEUE_GROUP_TYPES_COUNT 4
+#define BG_QUEUE_GROUP_TYPES_COUNT 5
 
 class Battleground;
 class BattlegroundQueue
@@ -74,6 +76,11 @@ class BattlegroundQueue
         void BattlegroundQueueUpdate(uint32 diff, BattlegroundTypeId bgTypeId, BattlegroundBracketId bracket_id, uint8 arenaType = 0, bool isRated = false, uint32 minRating = 0);
         void UpdateEvents(uint32 diff);
 
+        bool FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start = false);
+        typedef std::multimap<int32, GroupQueueInfo*> QueuedGroupMap;
+        int32 PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam);
+        bool CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg);
+
         void FillPlayersToBG(Battleground* bg, BattlegroundBracketId bracket_id);
         bool CheckPremadeMatch(BattlegroundBracketId bracket_id, uint32 MinPlayersPerTeam, uint32 MaxPlayersPerTeam);
         bool CheckNormalMatch(Battleground* bg_template, BattlegroundBracketId bracket_id, uint32 minPlayers, uint32 maxPlayers);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
index 2622ab9..4438c56 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAB.cpp
@@ -141,7 +141,7 @@ void BattlegroundAB::PostUpdateImpl(uint32 diff)
 
                 if (m_ReputationScoreTics[team] >= m_ReputationTics)
                 {
-                    (team == TEAM_ALLIANCE) ? RewardReputationToTeam(509, 10, ALLIANCE) : RewardReputationToTeam(510, 10, HORDE);
+                    RewardReputationToTeam(509, 510, 10, team == ALLIANCE ? ALLIANCE : HORDE);
                     m_ReputationScoreTics[team] -= m_ReputationTics;
                 }
 
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
index fde358b..3f02942 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundAV.cpp
@@ -89,7 +89,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     if (entry == BG_AV_CreatureInfo[AV_NPC_A_BOSS])
     {
         CastSpellOnTeam(23658, HORDE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(729, BG_AV_REP_BOSS, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), HORDE);
         EndBattleground(HORDE);
         DelCreature(AV_CPLACE_TRIGGER17);
@@ -97,7 +97,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
     else if (entry == BG_AV_CreatureInfo[AV_NPC_H_BOSS])
     {
         CastSpellOnTeam(23658, ALLIANCE); //this is a spell which finishes a quest where a player has to kill the boss
-        RewardReputationToTeam(730, BG_AV_REP_BOSS, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_BOSS, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_BOSS), ALLIANCE);
         EndBattleground(ALLIANCE);
         DelCreature(AV_CPLACE_TRIGGER19);
@@ -110,7 +110,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[0]=false;
-        RewardReputationToTeam(729, BG_AV_REP_CAPTAIN, HORDE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), HORDE);
         UpdateScore(ALLIANCE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -129,7 +129,7 @@ void BattlegroundAV::HandleKillUnit(Creature* unit, Player* killer)
             return;
         }
         m_CaptainAlive[1]=false;
-        RewardReputationToTeam(730, BG_AV_REP_CAPTAIN, ALLIANCE);
+        RewardReputationToTeam(729, 730, BG_AV_REP_CAPTAIN, killer->GetTeam() == ALLIANCE ? ALLIANCE : HORDE);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_CAPTAIN), ALLIANCE);
         UpdateScore(HORDE, (-1)*BG_AV_RES_CAPTAIN);
         //spawn destroyed aura
@@ -151,6 +151,7 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
     if (GetStatus() != STATUS_IN_PROGRESS)
         return;//maybe we should log this, cause this must be a cheater or a big bug
     uint8 team = GetTeamIndexByTeamId(player->GetTeam());
+    uint8 oteam = GetTeamIndexByTeamId(GetOtherTeam(player->GetTeam()));
     /// @todo add reputation, events (including quest not available anymore, next quest available, go/npc de/spawning)and maybe honor
     TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed", questid);
     switch (questid)
@@ -175,21 +176,21 @@ void BattlegroundAV::HandleQuestComplete(uint32 questid, Player* player)
         case AV_QUEST_A_COMMANDER1:
         case AV_QUEST_H_COMMANDER1:
             m_Team_QuestStatus[team][1]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][1] == 30)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER2:
         case AV_QUEST_H_COMMANDER2:
             m_Team_QuestStatus[team][2]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][2] == 60)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
         case AV_QUEST_A_COMMANDER3:
         case AV_QUEST_H_COMMANDER3:
             m_Team_QuestStatus[team][3]++;
-            RewardReputationToTeam(team, 1, player->GetTeam());
+            RewardReputationToTeam(team, oteam, 1, player->GetTeam());
             if (m_Team_QuestStatus[team][3] == 120)
                 TC_LOG_DEBUG("bg.battleground", "BG_AV Quest %i completed (need to implement some events here", questid);
             break;
@@ -471,7 +472,7 @@ void BattlegroundAV::EndBattleground(uint32 winner)
             rep[i]   += BG_AV_REP_SURVIVING_CAPTAIN;
         }
         if (rep[i] != 0)
-            RewardReputationToTeam(i == 0 ? 730 : 729, rep[i], i == 0 ? ALLIANCE : HORDE);
+            RewardReputationToTeam(729, 730, 10, i == ALLIANCE ? ALLIANCE : HORDE);
         if (kills[i] != 0)
             RewardHonorToTeam(GetBonusHonorFromKill(kills[i]), i == 0 ? ALLIANCE : HORDE);
     }
@@ -576,7 +577,7 @@ void BattlegroundAV::EventPlayerDestroyedPoint(BG_AV_Nodes node)
             SpawnBGObject(BG_AV_OBJECT_BURN_DUNBALDAR_SOUTH + i + (tmp * 10), RESPAWN_IMMEDIATELY);
 
         UpdateScore((owner == ALLIANCE) ? HORDE : ALLIANCE, -1 * BG_AV_RES_TOWER);
-        RewardReputationToTeam(owner == ALLIANCE ? 730 : 729, BG_AV_REP_TOWER, owner);
+        RewardReputationToTeam(729, 730, BG_AV_REP_TOWER, owner);
         RewardHonorToTeam(GetBonusHonorFromKill(BG_AV_KILL_TOWER), owner);
 
         SpawnBGObject(BG_AV_OBJECT_TAURA_A_DUNBALDAR_SOUTH+GetTeamIndexByTeamId(owner)+(2*tmp), RESPAWN_ONE_DAY);
diff --git a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
index c50669b..57eb3c0 100644
--- a/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
+++ b/src/server/game/Battlegrounds/Zones/BattlegroundWS.cpp
@@ -309,7 +309,6 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_ALLIANCE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(ALLIANCE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_ALLIANCE);
-        RewardReputationToTeam(890, m_ReputationCapture, ALLIANCE);
     }
     else
     {
@@ -328,8 +327,8 @@ void BattlegroundWS::EventPlayerCapturedFlag(Player* player)
         if (GetTeamScore(TEAM_HORDE) < BG_WS_MAX_TEAM_SCORE)
             AddPoint(HORDE, 1);
         PlaySoundToAll(BG_WS_SOUND_FLAG_CAPTURED_HORDE);
-        RewardReputationToTeam(889, m_ReputationCapture, HORDE);
     }
+    RewardReputationToTeam(890, 889, m_ReputationCapture, player->GetTeam());
     //for flag capture is reward 2 honorable kills
     RewardHonorToTeam(GetBonusHonorFromKill(2), player->GetTeam());
 
diff --git a/src/server/game/CMakeLists.txt b/src/server/game/CMakeLists.txt
index d7d14e7..89a509e 100644
--- a/src/server/game/CMakeLists.txt
+++ b/src/server/game/CMakeLists.txt
@@ -9,6 +9,7 @@
 # implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
 file(GLOB_RECURSE sources_Accounts Accounts/*.cpp Accounts/*.h)
+file(GLOB_RECURSE sources_Anticheat Anticheat/*.cpp Anticheat/*.h)
 file(GLOB_RECURSE sources_Achievements Achievements/*.cpp Achievements/*.h)
 file(GLOB_RECURSE sources_Addons Addons/*.cpp Addons/*.h)
 file(GLOB_RECURSE sources_AI AI/*.cpp AI/*.h)
@@ -49,6 +50,7 @@ file(GLOB_RECURSE sources_Tickets Tickets/*.cpp Tickets/*.h)
 file(GLOB_RECURSE sources_Warden Warden/*.cpp Warden/*.h)
 file(GLOB_RECURSE sources_Weather Weather/*.cpp Weather/*.h)
 file(GLOB_RECURSE sources_World World/*.cpp World/*.h)
+file(GLOB_RECURSE sources_Cfbg Cfbg/*.cpp Cfbg/*.h)
 
 # Create game-libary
 
@@ -60,6 +62,7 @@ endif ()
 set(game_STAT_SRCS
   ${game_STAT_SRCS}
   ${sources_Accounts}
+  ${sources_Anticheat}
   ${sources_Achievements}
   ${sources_Addons}
   ${sources_AI}
@@ -100,6 +103,7 @@ set(game_STAT_SRCS
   ${sources_Warden}
   ${sources_Weather}
   ${sources_World}
+  ${sources_Cfbg}
 )
 
 include_directories(
@@ -131,6 +135,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared/Utilities
   ${CMAKE_CURRENT_SOURCE_DIR}
   ${CMAKE_CURRENT_SOURCE_DIR}/Accounts
+  ${CMAKE_CURRENT_SOURCE_DIR}/Anticheat
   ${CMAKE_CURRENT_SOURCE_DIR}/Achievements
   ${CMAKE_CURRENT_SOURCE_DIR}/Addons
   ${CMAKE_CURRENT_SOURCE_DIR}/AI
diff --git a/src/server/game/Cfbg/Cfbg.cpp b/src/server/game/Cfbg/Cfbg.cpp
new file mode 100644
index 0000000..2ea38c0
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.cpp
@@ -0,0 +1,325 @@
+#include "Cfbg.h"
+#include "Battleground.h"
+#include "BattlegroundMgr.h"
+#include "Player.h"
+#include "Chat.h"
+#include "BattlegroundQueue.h"
+
+/*####################################################################################
+###############################CROSSFACTION BATTLEGROUNDS#############################
+####################################################################################*/
+
+uint8 Unit::getRace(bool forceoriginal) const
+{
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* pPlayer = ((Player*)this);
+
+        if (forceoriginal)
+            return pPlayer->getORace();
+
+        if (pPlayer->InArena())
+            return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+
+        if (!pPlayer->IsPlayingNative())
+            return pPlayer->getFRace();
+    }
+
+    return GetByteValue(UNIT_FIELD_BYTES_0, 0);
+}
+
+bool Player::SendRealNameQuery()
+{
+    if (IsPlayingNative())
+        return false;
+
+    WorldPacket data(SMSG_NAME_QUERY_RESPONSE, (8 + 1 + 1 + 1 + 1 + 1 + 10));
+    data.appendPackGUID(GetGUID());                             // player guid
+    data << uint8(0);                                       // added in 3.1; if > 1, then end of packet
+    data << GetName();                                   // played name
+    data << uint8(0);                                       // realm name for cross realm BG usage
+    data << uint8(getORace());
+    data << uint8(getGender());
+    data << uint8(getClass());
+    data << uint8(0);                                   // is not declined
+    GetSession()->SendPacket(&data);
+
+    return true;
+}
+
+void Player::SetFakeRaceAndMorph()
+{
+m_FakeRace = GetOTeam() == ALLIANCE ? RACE_BLOODELF : RACE_HUMAN;
+}
+
+bool Player::SendBattleGroundChat(uint32 msgtype, std::string message)
+{
+    // Select distance to broadcast to.
+    float distance = msgtype == CHAT_MSG_SAY ? sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_SAY) : sWorld->getFloatConfig(CONFIG_LISTEN_RANGE_YELL);
+
+    if (Battleground* pBattleGround = GetBattleground())
+    {
+        if (pBattleGround->isArena()) // Only fake chat in BG's. CFBG should not interfere with arenas.
+            return false;
+
+        for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+        {
+            if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+            {
+                if (GetDistance2d(pPlayer->GetPositionX(), pPlayer->GetPositionY()) <= distance)
+                {
+                    WorldPacket data(SMSG_MESSAGECHAT, 200);
+
+                    if (GetTeam() == pPlayer->GetTeam())
+                        BuildPlayerChat(&data, msgtype, message, LANG_UNIVERSAL);
+                    else if (msgtype != CHAT_MSG_EMOTE)
+                       BuildPlayerChat(&data, msgtype, message, pPlayer->GetTeam() == ALLIANCE ? LANG_ORCISH : LANG_COMMON);
+
+                    pPlayer->GetSession()->SendPacket(&data);
+                }
+            }
+        }
+        return true;
+    }
+    else
+        return false;
+}
+
+void Player::MorphFit(bool value)
+{
+    if (!IsPlayingNative() && value)
+    {
+        if (GetOTeam() == HORDE)
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(19723);
+                SetNativeDisplayId(19723);
+            }
+            else
+            {
+                SetDisplayId(19724);
+                SetNativeDisplayId(19724);
+            }
+        }
+        else
+        {
+            if (getGender() == GENDER_MALE)
+            {
+                SetDisplayId(20578);
+                SetNativeDisplayId(20578);
+            }
+            else
+            {
+                SetDisplayId(20579);
+                SetNativeDisplayId(20579);
+            }
+        }
+    }
+    else
+        InitDisplayIds();
+}
+
+void Player::FitPlayerInTeam(bool action, Battleground* pBattleGround)
+{
+    if (!pBattleGround)
+        pBattleGround = GetBattleground();
+
+    if ((!pBattleGround || pBattleGround->isArena()) && action)
+        return;
+
+    if(!IsPlayingNative() && action)
+        setFactionForRace(getRace());
+    else
+        setFactionForRace(getORace());
+
+    if (action)
+        SetForgetBGPlayers(true);
+    else
+        SetForgetInListPlayers(true);
+
+    MorphFit(action);
+
+    if (pBattleGround && action)
+        SendChatMessage("%sYou are playing for the %s%s in this %s", MSG_COLOR_WHITE, GetTeam() == ALLIANCE ? MSG_COLOR_DARKBLUE"alliance" : MSG_COLOR_RED"horde", MSG_COLOR_WHITE, pBattleGround->GetName().c_str());
+}
+
+void Player::DoForgetPlayersInList()
+{
+    // m_FakePlayers is filled from a vector within the battleground
+    // they were in previously so all players that have been in that BG will be invalidated.
+    for (FakePlayers::const_iterator itr = m_FakePlayers.begin(); itr != m_FakePlayers.end(); ++itr)
+    {
+        WorldPacket data(SMSG_INVALIDATE_PLAYER, 8);
+        data << *itr;
+        GetSession()->SendPacket(&data);
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(*itr))
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID());
+    }
+    m_FakePlayers.clear();
+}
+
+void Player::DoForgetPlayersInBG(Battleground* pBattleGround)
+{
+    for (Battleground::BattlegroundPlayerMap::const_iterator itr = pBattleGround->GetPlayers().begin(); itr != pBattleGround->GetPlayers().end(); ++itr)
+    {
+        // Here we invalidate players in the bg to the added player
+        WorldPacket data1(SMSG_INVALIDATE_PLAYER, 8);
+        data1 << itr->first;
+        GetSession()->SendPacket(&data1);
+
+        if (Player* pPlayer = ObjectAccessor::FindPlayer(itr->first))
+        {
+            GetSession()->SendNameQueryOpcode(pPlayer->GetGUID()); // Send namequery answer instantly if player is available
+            // Here we invalidate the player added to players in the bg
+            WorldPacket data2(SMSG_INVALIDATE_PLAYER, 8);
+            data2 << GetGUID();
+            pPlayer->GetSession()->SendPacket(&data2);
+            pPlayer->GetSession()->SendNameQueryOpcode(GetGUID());
+        }
+    }
+}
+
+bool BattlegroundQueue::CheckCrossFactionMatch(BattlegroundBracketId bracket_id, Battleground* bg)
+{
+    if (!sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) || bg->isArena())
+        return false; // Only do this if crossbg's are enabled.
+
+    // Here we will add all players to selectionpool, later we check if there are enough and launch a bg.
+    FillXPlayersToBG(bracket_id, bg, true);
+
+    if (sBattlegroundMgr->isTesting() && (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() || m_SelectionPools[TEAM_HORDE].GetPlayerCount()))
+        return true;
+
+    uint8 MPT = bg->GetMinPlayersPerTeam();
+    if (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() < MPT || m_SelectionPools[TEAM_HORDE].GetPlayerCount() < MPT)
+        return false;
+
+    return true;
+}
+
+// This function will invite players in the least populated faction, which makes battleground queues much faster.
+// This function will return true if cross faction battlegrounds are enabled, otherwise return false,
+// which is useful in FillPlayersToBG. Because then we can interrupt the regular invitation if cross faction bg's are enabled.
+bool BattlegroundQueue::FillXPlayersToBG(BattlegroundBracketId bracket_id, Battleground* bg, bool start)
+{
+    uint8 queuedPeople = 0;
+    for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+        if (!(*itr)->IsInvitedToBGInstanceGUID)
+            queuedPeople += (*itr)->Players.size();
+
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && (sBattlegroundMgr->isTesting() || queuedPeople >= bg->GetMinPlayersPerTeam()*2 || !start))
+    {
+        int32 aliFree   = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(ALLIANCE);
+        int32 hordeFree = start ? bg->GetMaxPlayersPerTeam() : bg->GetFreeSlotsForTeam(HORDE);
+        // Empty selection pools. They will be refilled from queued groups.
+        m_SelectionPools[TEAM_ALLIANCE].Init();
+        m_SelectionPools[TEAM_HORDE].Init();
+        int32 valiFree = aliFree;
+        int32 vhordeFree = hordeFree;
+        int32 diff = 0;
+
+
+        // Add teams to their own factions as far as possible.
+        if (start)
+        {
+            QueuedGroupMap m_PreGroupMap_a, m_PreGroupMap_h;
+            int32 m_SmallestOfTeams = 0;
+            int32 queuedAlliance = 0;
+            int32 queuedHorde = 0;
+
+            for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            {
+                if ((*itr)->IsInvitedToBGInstanceGUID)
+                    continue;
+
+                bool alliance = (*itr)->OTeam == ALLIANCE;
+
+                if (alliance)
+                {
+                    m_PreGroupMap_a.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedAlliance += (*itr)->Players.size();
+                }
+                else
+                {
+                    m_PreGroupMap_h.insert(std::make_pair((*itr)->Players.size(), *itr));
+                    queuedHorde += (*itr)->Players.size();
+                }
+            }
+
+            m_SmallestOfTeams = std::min(std::min(aliFree, queuedAlliance), std::min(hordeFree, queuedHorde));
+
+            valiFree -= PreAddPlayers(m_PreGroupMap_a, m_SmallestOfTeams, aliFree);
+            vhordeFree -= PreAddPlayers(m_PreGroupMap_h, m_SmallestOfTeams, hordeFree);
+        }
+
+        QueuedGroupMap m_QueuedGroupMap;
+
+        for (GroupsQueueType::const_iterator itr = m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].begin(); itr != m_QueuedGroups[bracket_id][BG_QUEUE_MIXED].end(); ++itr)
+            m_QueuedGroupMap.insert(std::make_pair((*itr)->Players.size(), *itr));
+
+        for (QueuedGroupMap::reverse_iterator itr = m_QueuedGroupMap.rbegin(); itr != m_QueuedGroupMap.rend(); ++itr)
+        {
+            GroupsQueueType allypool = m_SelectionPools[TEAM_ALLIANCE].SelectedGroups;
+            GroupsQueueType hordepool = m_SelectionPools[TEAM_HORDE].SelectedGroups;
+
+            GroupQueueInfo* ginfo = itr->second;
+
+            // If player already was invited via pre adding (add to own team first) or he was already invited to a bg, skip.
+            if (ginfo->IsInvitedToBGInstanceGUID ||
+                std::find(allypool.begin(), allypool.end(), ginfo) != allypool.end() ||
+                std::find(hordepool.begin(), hordepool.end(), ginfo) != hordepool.end() ||
+                (m_SelectionPools[TEAM_ALLIANCE].GetPlayerCount() >= bg->GetMinPlayersPerTeam() &&
+                m_SelectionPools[TEAM_HORDE].GetPlayerCount() >= bg->GetMinPlayersPerTeam()))
+                continue;
+
+            diff = abs(valiFree - vhordeFree);
+            bool moreAli = valiFree < vhordeFree;
+
+            if (diff > 0)
+                ginfo->Team = moreAli ? HORDE : ALLIANCE;
+
+            bool alliance = ginfo->Team == ALLIANCE;
+
+            if (m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(ginfo, alliance ? aliFree : hordeFree))
+                alliance ? valiFree -= ginfo->Players.size() : vhordeFree -= ginfo->Players.size();
+        }
+
+        return true;
+    }
+    return false;
+}
+
+int32 BattlegroundQueue::PreAddPlayers(QueuedGroupMap m_PreGroupMap, int32 MaxAdd, uint32 MaxInTeam)
+{
+    int32 LeftToAdd = MaxAdd;
+    uint32 Added = 0;
+
+    for (QueuedGroupMap::reverse_iterator itr = m_PreGroupMap.rbegin(); itr != m_PreGroupMap.rend(); ++itr)
+    {
+        int32 PlayerSize = itr->first;
+        bool alliance = itr->second->OTeam == ALLIANCE;
+
+        if (PlayerSize <= LeftToAdd && m_SelectionPools[alliance ? TEAM_ALLIANCE : TEAM_HORDE].AddGroup(itr->second, MaxInTeam))
+            LeftToAdd -= PlayerSize, Added -= PlayerSize;
+    }
+
+    return LeftToAdd;
+}
+
+void Player::SendChatMessage(const char *format, ...)
+{
+    if (!IsInWorld())
+        return;
+
+    if (format)
+    {
+        va_list ap;
+        char str [2048];
+        va_start(ap, format);
+        vsnprintf(str, 2048, format, ap);
+        va_end(ap);
+
+        ChatHandler(GetSession()).SendSysMessage(str);
+    }
+}
diff --git a/src/server/game/Cfbg/Cfbg.h b/src/server/game/Cfbg/Cfbg.h
new file mode 100644
index 0000000..45567f8
--- /dev/null
+++ b/src/server/game/Cfbg/Cfbg.h
@@ -0,0 +1,35 @@
+#ifndef _CUSTOM_H
+#define _CUSTOM_H
+
+#define MSG_COLOR_LIGHTRED     "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE    "|cff00ccff"
+#define MSG_COLOR_ANN_GREEN    "|c1f40af20"
+#define MSG_COLOR_RED          "|cffff0000"
+#define MSG_COLOR_GOLD         "|cffffcc00"
+#define MSG_COLOR_SUBWHITE     "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA      "|cffff00ff"
+#define MSG_COLOR_YELLOW       "|cffffff00"
+#define MSG_COLOR_CYAN         "|cff00ffff"
+#define MSG_COLOR_DARKBLUE     "|cff0000ff"
+
+#define MSG_COLOR_GREY         "|cff9d9d9d"
+#define MSG_COLOR_WHITE        "|cffffffff"
+#define MSG_COLOR_GREEN        "|cff1eff00"
+#define MSG_COLOR_BLUE         "|cff0080ff"
+#define MSG_COLOR_PURPLE       "|cffb048f8"
+#define MSG_COLOR_ORANGE       "|cffff8000"
+
+#define MSG_COLOR_DRUID        "|cffff7d0a"
+#define MSG_COLOR_HUNTER       "|cffabd473"
+#define MSG_COLOR_MAGE         "|cff69ccf0"
+#define MSG_COLOR_PALADIN      "|cfff58cba"
+#define MSG_COLOR_PRIEST       "|cffffffff"
+#define MSG_COLOR_ROGUE        "|cfffff569"
+#define MSG_COLOR_SHAMAN       "|cff0070de"
+#define MSG_COLOR_WARLOCK      "|cff9482c9"
+#define MSG_COLOR_WARRIOR      "|cffc79c6e"
+#define MSG_COLOR_DEATH_KNIGHT "|cffc41f3b"
+#define MSG_COLOR_MONK         "|cff00ff96"
+
+#define LIMIT_UINT32 2147483647
+#endif
diff --git a/src/server/game/Conditions/ConditionMgr.cpp b/src/server/game/Conditions/ConditionMgr.cpp
index 0305145..605ec21 100644
--- a/src/server/game/Conditions/ConditionMgr.cpp
+++ b/src/server/game/Conditions/ConditionMgr.cpp
@@ -28,6 +28,7 @@
 #include "SpellAuras.h"
 #include "SpellMgr.h"
 #include "Spell.h"
+#include "Guild.h"
 
 // Checks if object meets the condition
 // Can have CONDITION_SOURCE_TYPE_NONE && !mReferenceId if called from a special event (ie: eventAI)
@@ -340,6 +341,13 @@ bool Condition::Meets(ConditionSourceInfo& sourceInfo)
                 condMeets = creature->GetCreatureTemplate()->type == ConditionValue1;
             break;
         }
+        case CONDITION_GUILD_LEVEL:
+        {
+            if (Player* player = object->ToPlayer())
+                if (Guild* guild = player->GetGuild())
+                    condMeets = CompareValues(static_cast<ComparisionType>(ConditionValue2), static_cast<uint32>(guild->GetLevel()), ConditionValue1);
+            break;
+        }
         default:
             condMeets = false;
             break;
@@ -504,6 +512,9 @@ uint32 Condition::GetSearcherTypeMaskForCondition()
         case CONDITION_CREATURE_TYPE:
             mask |= GRID_MAP_TYPE_MASK_CREATURE;
             break;
+        case CONDITION_GUILD_LEVEL:
+            mask |= GRID_MAP_TYPE_MASK_PLAYER;
+            break;
         default:
             ASSERT(false && "Condition::GetSearcherTypeMaskForCondition - missing condition handling!");
             break;
@@ -2058,6 +2069,17 @@ bool ConditionMgr::isConditionTypeValid(Condition* cond)
             }
             break;
         }
+        case CONDITION_GUILD_LEVEL:
+        {
+            if (cond->ConditionValue2 >= COMP_TYPE_MAX)
+            {
+                TC_LOG_ERROR("sql.sql", "Guildlevel condition has invalid option (%u), skipped", cond->ConditionValue2);
+                return false;
+            }
+            if (cond->ConditionValue3)
+                TC_LOG_ERROR("sql.sql", "Guildlevel condition has useless data in value3 (%u)!", cond->ConditionValue3);
+            break;
+        }
         default:
             break;
     }
diff --git a/src/server/game/Conditions/ConditionMgr.h b/src/server/game/Conditions/ConditionMgr.h
index ff50821..a1d5fd4 100644
--- a/src/server/game/Conditions/ConditionMgr.h
+++ b/src/server/game/Conditions/ConditionMgr.h
@@ -71,7 +71,8 @@ enum ConditionTypes
     CONDITION_ALIVE                 = 36,                   // 0                0              0                  true if unit is alive
     CONDITION_HP_VAL                = 37,                   // hpVal            ComparisonType 0                  true if unit's hp matches given value
     CONDITION_HP_PCT                = 38,                   // hpPct            ComparisonType 0                  true if unit's hp matches given pct
-    CONDITION_MAX                   = 39                    // MAX
+    CONDITION_GUILD_LEVEL           = 39,                   // Gildenlevel      Level          Vergleichstyp
+    CONDITION_MAX                   = 40                    // MAX
 };
 
 /*! Documentation on implementing a new ConditionSourceType:
diff --git a/src/server/game/DataStores/DBCStores.cpp b/src/server/game/DataStores/DBCStores.cpp
index e960422..84151cb 100644
--- a/src/server/game/DataStores/DBCStores.cpp
+++ b/src/server/game/DataStores/DBCStores.cpp
@@ -116,7 +116,7 @@ DBCStorage <HolidaysEntry>                sHolidaysStore(Holidaysfmt);
 DBCStorage <ItemEntry>                    sItemStore(Itemfmt);
 DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore(ItemBagFamilyfmt);
 //DBCStorage <ItemCondExtCostsEntry> sItemCondExtCostsStore(ItemCondExtCostsEntryfmt);
-//DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt); -- not used currently
+DBCStorage <ItemDisplayInfoEntry> sItemDisplayInfoStore(ItemDisplayTemplateEntryfmt);
 DBCStorage <ItemExtendedCostEntry> sItemExtendedCostStore(ItemExtendedCostEntryfmt);
 DBCStorage <ItemLimitCategoryEntry> sItemLimitCategoryStore(ItemLimitCategoryEntryfmt);
 DBCStorage <ItemRandomPropertiesEntry> sItemRandomPropertiesStore(ItemRandomPropertiesfmt);
@@ -369,7 +369,7 @@ void LoadDBCStores(const std::string& dataPath)
 
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemStore,                   dbcPath, "Item.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemBagFamilyStore,          dbcPath, "ItemBagFamily.dbc");
-    //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");     -- not used currently
+    LoadDBC(availableDbcLocales, bad_dbc_files, sItemDisplayInfoStore,        dbcPath, "ItemDisplayInfo.dbc");
     //LoadDBC(dbcCount, availableDbcLocales, bad_dbc_files, sItemCondExtCostsStore,       dbcPath, "ItemCondExtCosts.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemExtendedCostStore,       dbcPath, "ItemExtendedCost.dbc");
     LoadDBC(availableDbcLocales, bad_dbc_files, sItemLimitCategoryStore,      dbcPath, "ItemLimitCategory.dbc");
diff --git a/src/server/game/DataStores/DBCStores.h b/src/server/game/DataStores/DBCStores.h
index 8b89a86..ec9817e 100644
--- a/src/server/game/DataStores/DBCStores.h
+++ b/src/server/game/DataStores/DBCStores.h
@@ -130,7 +130,7 @@ extern DBCStorage <GtRegenMPPerSptEntry>         sGtRegenMPPerSptStore;
 extern DBCStorage <HolidaysEntry>                sHolidaysStore;
 extern DBCStorage <ItemEntry>                    sItemStore;
 extern DBCStorage <ItemBagFamilyEntry>           sItemBagFamilyStore;
-//extern DBCStorage <ItemDisplayInfoEntry>      sItemDisplayInfoStore; -- not used currently
+extern DBCStorage <ItemDisplayInfoEntry>         sItemDisplayInfoStore;
 extern DBCStorage <ItemExtendedCostEntry>        sItemExtendedCostStore;
 extern DBCStorage <ItemLimitCategoryEntry>       sItemLimitCategoryStore;
 extern DBCStorage <ItemRandomPropertiesEntry>    sItemRandomPropertiesStore;
diff --git a/src/server/game/DataStores/DBCStructure.h b/src/server/game/DataStores/DBCStructure.h
index 1e1cd6d..39ee140 100644
--- a/src/server/game/DataStores/DBCStructure.h
+++ b/src/server/game/DataStores/DBCStructure.h
@@ -1151,7 +1151,7 @@ struct ItemDisplayInfoEntry
     uint32      ID;                                         // 0        m_ID
                                                             // 1        m_modelName[2]
                                                             // 2        m_modelTexture[2]
-                                                            // 3        m_inventoryIcon
+    char*       inventoryIcon;                              // 3        m_inventoryIcon
                                                             // 4        m_geosetGroup[3]
                                                             // 5        m_flags
                                                             // 6        m_spellVisualID
diff --git a/src/server/game/DataStores/DBCfmt.h b/src/server/game/DataStores/DBCfmt.h
index a90cc48..ab97153 100644
--- a/src/server/game/DataStores/DBCfmt.h
+++ b/src/server/game/DataStores/DBCfmt.h
@@ -72,7 +72,7 @@ char const GtRegenMPPerSptfmt[] = "f";
 char const Holidaysfmt[] = "niiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiixxsiix";
 char const Itemfmt[] = "niiiiiii";
 char const ItemBagFamilyfmt[] = "nxxxxxxxxxxxxxxxxx";
-//char const ItemDisplayTemplateEntryfmt[] = "nxxxxxxxxxxixxxxxxxxxxx";
+char const ItemDisplayTemplateEntryfmt[] = "nxxxxsxxxxxxxxxxxxxxxxxxx";
 //char const ItemCondExtCostsEntryfmt[] = "xiii";
 char const ItemExtendedCostEntryfmt[] = "niiiiiiiiiiiiiix";
 char const ItemLimitCategoryEntryfmt[] = "nxxxxxxxxxxxxxxxxxii";
diff --git a/src/server/game/Entities/Creature/Creature.cpp b/src/server/game/Entities/Creature/Creature.cpp
index ba94a99..8f1312a 100644
--- a/src/server/game/Entities/Creature/Creature.cpp
+++ b/src/server/game/Entities/Creature/Creature.cpp
@@ -1452,7 +1452,7 @@ void Creature::setDeathState(DeathState s)
     if (s == JUST_DIED)
     {
         m_corpseRemoveTime = time(NULL) + m_corpseDelay;
-        m_respawnTime = time(NULL) + m_respawnDelay + m_corpseDelay;
+        m_respawnTime = time(NULL) + (m_respawnDelay / sWorld->getFloatConfig(CONFIG_RESPAWNSPEED)) + m_corpseDelay;
 
         // always save boss respawn time at death to prevent crash cheating
         if (sWorld->getBoolConfig(CONFIG_SAVE_RESPAWN_TIME_IMMEDIATELY) || isWorldBoss())
diff --git a/src/server/game/Entities/Player/Player.cpp b/src/server/game/Entities/Player/Player.cpp
index 0e1e53c..0533600 100644
--- a/src/server/game/Entities/Player/Player.cpp
+++ b/src/server/game/Entities/Player/Player.cpp
@@ -19,6 +19,7 @@
 #include "Player.h"
 #include "AccountMgr.h"
 #include "AchievementMgr.h"
+#include "AnticheatMgr.h"
 #include "ArenaTeam.h"
 #include "ArenaTeamMgr.h"
 #include "Battlefield.h"
@@ -79,6 +80,8 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 #include "GameObjectAI.h"
+#include "Config.h"
+#include "../../../scripts/Custom/Transmogrification.h"
 
 #define ZONE_UPDATE_INTERVAL (1*IN_MILLISECONDS)
 
@@ -656,6 +659,12 @@ void KillRewarder::Reward()
 
 Player::Player(WorldSession* session): Unit(true)
 {
+    m_FakeRace = 0;
+    m_RealRace = 0;
+    m_FakeMorph = 0;
+    m_ForgetBGPlayers = false;
+    m_ForgetInListPlayers = false;
+
     m_speakTime = 0;
     m_speakCount = 0;
 
@@ -902,6 +911,10 @@ Player::Player(WorldSession* session): Unit(true)
     _activeCheats = CHEAT_NONE;
     m_achievementMgr = new AchievementMgr(this);
     m_reputationMgr = new ReputationMgr(this);
+
+    //Individuale_XP-Rate
+    _individual_kill = 0.0f;
+    _individual_quest = 0.0f;
 }
 
 Player::~Player()
@@ -1006,6 +1019,12 @@ bool Player::Create(uint32 guidlow, CharacterCreateInfo* createInfo)
     uint32 RaceClassGender = (createInfo->Race) | (createInfo->Class << 8) | (createInfo->Gender << 16);
 
     SetUInt32Value(UNIT_FIELD_BYTES_0, (RaceClassGender | (powertype << 24)));
+
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());
+
     InitDisplayIds();
     if (sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_PVP || sWorld->getIntConfig(CONFIG_GAME_TYPE) == REALM_TYPE_RPPVP)
     {
@@ -1339,8 +1358,11 @@ int32 Player::getMaxTimer(MirrorTimerType timer)
 {
     switch (timer)
     {
+    if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+        {
         case FATIGUE_TIMER:
             return MINUTE * IN_MILLISECONDS;
+        }
         case BREATH_TIMER:
         {
             if (!IsAlive() || HasAuraType(SPELL_AURA_WATER_BREATHING) || GetSession()->GetSecurity() >= AccountTypes(sWorld->getIntConfig(CONFIG_DISABLE_BREATHING)))
@@ -1423,6 +1445,9 @@ void Player::HandleDrowning(uint32 time_diff)
     }
 
     // In dark water
+if(sConfigMgr->GetBoolDefault("fatigue.enabled", true)) // If "fatigue.enabled" is enabled
+{
+
     if (m_MirrorTimerFlags & UNDERWARER_INDARKWATER)
     {
         // Fatigue timer not activated - activate it
@@ -1459,7 +1484,7 @@ void Player::HandleDrowning(uint32 time_diff)
         else if (m_MirrorTimerFlagsLast & UNDERWARER_INDARKWATER)
             SendMirrorTimer(FATIGUE_TIMER, DarkWaterTime, m_MirrorTimer[FATIGUE_TIMER], 10);
     }
-
+}
     if (m_MirrorTimerFlags & (UNDERWATER_INLAVA /*| UNDERWATER_INSLIME*/) && !(_lastLiquid && _lastLiquid->SpellId))
     {
         // Breath timer not activated - activate it
@@ -1557,6 +1582,8 @@ void Player::Update(uint32 p_time)
     if (!IsInWorld())
         return;
 
+    //sAnticheatMgr->HandleHackDetectionTimer(this, p_time);
+
     // undelivered mail
     if (m_nextMailDelivereTime && m_nextMailDelivereTime <= time(NULL))
     {
@@ -1682,7 +1709,10 @@ void Player::Update(uint32 p_time)
 
                     // do attack
                     AttackerStateUpdate(victim, BASE_ATTACK);
-                    resetAttackTimer(BASE_ATTACK);
+                    if (sWorld->getBoolConfig(CONFIG_HURT_IN_REAL_TIME))
+                        AttackStop();
+                    else
+                        resetAttackTimer(BASE_ATTACK);
                 }
             }
 
@@ -1784,6 +1814,13 @@ void Player::Update(uint32 p_time)
             // m_nextSave reset in SaveToDB call
             SaveToDB();
             TC_LOG_DEBUG("entities.player", "Player '%s' (GUID: %u) saved", GetName().c_str(), GetGUIDLow());
+
+            // If Fake WHO List system on then change player position with every SavePlayer Interval (usually 15min)
+            if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+            {
+                CharacterDatabase.PExecute("UPDATE characters_fake SET zone = (FLOOR(50 * RAND()) + 1)");
+                CharacterDatabase.PExecute("UPDATE characters_fake SET level = level+1, lastup = NOW() WHERE level < 80 AND lastup < (NOW() - INTERVAL %u HOUR) AND HOUR(online) BETWEEN HOUR(NOW()) AND (HOUR(NOW()) + %u)", sWorld->getIntConfig(CONFIG_FAKE_WHO_LEVELUP_INTERVAL), sWorld->getIntConfig(CONFIG_FAKE_WHO_ONLINE_INTERVAL));
+            }
         }
         else
             m_nextSave -= p_time;
@@ -2109,6 +2146,8 @@ void Player::SendTeleportAckPacket()
 
 bool Player::TeleportTo(uint32 mapid, float x, float y, float z, float orientation, uint32 options)
 {
+    //sAnticheatMgr->DisableAnticheatDetection(this,true);
+
     if (!MapManager::IsValidMapCoord(mapid, x, y, z, orientation))
     {
         TC_LOG_ERROR("maps", "TeleportTo: invalid map (%d) or invalid coordinates (X: %f, Y: %f, Z: %f, O: %f) given when teleporting player (GUID: %u, name: %s, map: %d, X: %f, Y: %f, Z: %f, O: %f).",
@@ -3015,7 +3054,7 @@ void Player::GiveLevel(uint8 level)
         guild->UpdateMemberData(this, GUILD_MEMBER_DATA_LEVEL, level);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), level, &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), level, &info);
 
     PlayerClassLevelInfo classInfo;
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), level, &classInfo);
@@ -3153,7 +3192,7 @@ void Player::InitStatsForLevel(bool reapplyMods)
     sObjectMgr->GetPlayerClassLevelInfo(getClass(), getLevel(), &classInfo);
 
     PlayerLevelInfo info;
-    sObjectMgr->GetPlayerLevelInfo(getRace(), getClass(), getLevel(), &info);
+    sObjectMgr->GetPlayerLevelInfo(getORace(), getClass(), getLevel(), &info);
 
     SetUInt32Value(PLAYER_FIELD_MAX_LEVEL, sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL));
     SetUInt32Value(PLAYER_NEXT_LEVEL_XP, sObjectMgr->GetXPForLevel(getLevel()));
@@ -5059,6 +5098,12 @@ void Player::BuildPlayerRepop()
     // convert player body to ghost
     SetHealth(1);
 
+    //Guild-Level-System (Bonus: Faster spirit)
+    if (!GetMap()->IsBattlegroundOrArena())
+        if (Guild* guild = GetGuild())
+            if (guild->HasLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST))
+                SetSpeed(MOVE_RUN, 2.0f, true);
+
     SetMovement(MOVE_WATER_WALK);
     if (!GetSession()->isLogingOut())
         SetMovement(MOVE_UNROOT);
@@ -5106,6 +5151,9 @@ void Player::ResurrectPlayer(float restore_percent, bool applySickness)
     SetMovement(MOVE_LAND_WALK);
     SetMovement(MOVE_UNROOT);
 
+    //Guild-Level-System (Bonus: Faster spirit)
+    SetSpeed(MOVE_RUN, 1.0f, true);
+
     m_deathTimer = 0;
 
     // set health/powers (0- will be set in caller)
@@ -5206,7 +5254,7 @@ void Player::CreateCorpse()
         return;
     }
 
-    _uf = GetUInt32Value(UNIT_FIELD_BYTES_0);
+    _uf = getORace();
     _pb = GetUInt32Value(PLAYER_BYTES);
     _pb2 = GetUInt32Value(PLAYER_BYTES_2);
 
@@ -5431,6 +5479,15 @@ uint32 Player::DurabilityRepair(uint16 pos, bool cost, float discountMod, bool g
 
             costs = uint32(costs * discountMod * sWorld->getRate(RATE_REPAIRCOST));
 
+            //Guild-Level-System (Bonus: Guenstige Reperatur)
+            if (Guild* guild = GetGuild())
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_1))
+                    costs -= uint32(costs*0.25f);
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    costs -= uint32(costs*0.5f);
+            }
+
             if (costs == 0)                                   //fix for ITEM_QUALITY_ARTIFACT
                 costs = 1;
 
@@ -6890,10 +6947,10 @@ uint32 Player::TeamForRace(uint8 race)
 
 void Player::setFactionForRace(uint8 race)
 {
-    m_team = TeamForRace(race);
+    SetBGTeam(TeamForRace(race));
 
     ChrRacesEntry const* rEntry = sChrRacesStore.LookupEntry(race);
-    setFaction(rEntry ? rEntry->FactionID : 0);
+    setFaction(rEntry ? rEntry->FactionID : getFaction());
 }
 
 ReputationRank Player::GetReputationRank(uint32 faction) const
@@ -6995,6 +7052,27 @@ void Player::RewardReputation(Unit* victim, float rate)
     if (!Rep)
         return;
 
+    uint32 repfaction1 = Rep->RepFaction1;
+    uint32 repfaction2 = Rep->RepFaction2;
+
+    if (!IsPlayingNative())
+    {
+        if (GetOTeam() == ALLIANCE)
+        {
+            if (repfaction1 == 729)
+                repfaction1 = 730;
+            if (repfaction2 == 729)
+                repfaction2 = 730;
+        }
+        else
+        {
+            if (repfaction1 == 730)
+                repfaction1 = 729;
+            if (repfaction2 == 730)
+                repfaction2 = 729;
+        }
+    }
+
     uint32 ChampioningFaction = 0;
 
     if (GetChampioningFaction())
@@ -7009,23 +7087,23 @@ void Player::RewardReputation(Unit* victim, float rate)
 
     uint32 team = GetTeam();
 
-    if (Rep->RepFaction1 && (!Rep->TeamDependent || team == ALLIANCE))
+    if (repfaction1 && (!Rep->TeamDependent || team == ALLIANCE))
     {
-        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
+        int32 donerep1 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue1, ChampioningFaction ? ChampioningFaction : repfaction1);
         donerep1 = int32(donerep1 * rate);
 
-        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction1);
+        FactionEntry const* factionEntry1 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction1);
         uint32 current_reputation_rank1 = GetReputationMgr().GetRank(factionEntry1);
         if (factionEntry1 && current_reputation_rank1 <= Rep->ReputationMaxCap1)
             GetReputationMgr().ModifyReputation(factionEntry1, donerep1);
     }
 
-    if (Rep->RepFaction2 && (!Rep->TeamDependent || team == HORDE))
+    if (repfaction2 && (!Rep->TeamDependent || team == HORDE))
     {
-        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        int32 donerep2 = CalculateReputationGain(REPUTATION_SOURCE_KILL, victim->getLevel(), Rep->RepValue2, ChampioningFaction ? ChampioningFaction : repfaction2);
         donerep2 = int32(donerep2 * rate);
 
-        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : Rep->RepFaction2);
+        FactionEntry const* factionEntry2 = sFactionStore.LookupEntry(ChampioningFaction ? ChampioningFaction : repfaction2);
         uint32 current_reputation_rank2 = GetReputationMgr().GetRank(factionEntry2);
         if (factionEntry2 && current_reputation_rank2 <= Rep->ReputationMaxCap2)
             GetReputationMgr().ModifyReputation(factionEntry2, donerep2);
@@ -7120,7 +7198,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
         if (!victim || victim == this || victim->GetTypeId() != TYPEID_PLAYER)
             return false;
 
-        if (GetBGTeam() == victim->ToPlayer()->GetBGTeam())
+        if (GetTeam() == victim->ToPlayer()->GetTeam())
             return false;
 
         return true;
@@ -7132,6 +7210,7 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
 
     uint64 victim_guid = 0;
     uint32 victim_rank = 0;
+    uint32 rank_diff = 0;
 
     // need call before fields update to have chance move yesterday data to appropriate fields before today data change.
     UpdateHonorFields();
@@ -7174,19 +7253,104 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
             //  title[1..14]  -> rank[5..18]
             //  title[15..28] -> rank[5..18]
             //  title[other]  -> 0
-            if (victim_title == 0)
-                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
-            else if (victim_title < 15)
-                victim_rank = victim_title + 4;
-            else if (victim_title < 29)
-                victim_rank = victim_title - 14 + 4;
-            else
-                victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+                // PLAYER__FIELD_KNOWN_TITLES describe which titles player can use,
+                // so we must find biggest pvp title , even for killer to find extra honor value
+                uint32 vtitle = victim->GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                //uint32 victim_title = 0;
+                uint32 ktitle = GetUInt32Value(PLAYER__FIELD_KNOWN_TITLES);
+                uint32 killer_title = 0;
+                if (PLAYER_TITLE_MASK_ALL_PVP & ktitle)
+                {
+                    for (int i = ((GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if (ktitle & (1<<i))
+                            killer_title = i;
+                    }
+                }
+                if (PLAYER_TITLE_MASK_ALL_PVP & vtitle)
+                {
+                    for (int i = ((plrVictim->GetTeam() == ALLIANCE) ? 1:HKRANKMAX);i!=((plrVictim->GetTeam() == ALLIANCE) ? HKRANKMAX : (2*HKRANKMAX-1));i++)
+                    {
+                        if (vtitle & (1<<i))
+                            victim_title = i;
+                    }
+                }
+                // Get Killer titles, CharTitlesEntry::bit_index
+                // Ranks:
+                //  title[1..14]  -> rank[5..18]
+                //  title[15..28] -> rank[5..18]
+                //  title[other]  -> 0
+                if (victim_title == 0)
+                    victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+                else if (victim_title < HKRANKMAX)
+                    victim_rank = victim_title + 4;
+                else if (victim_title < (2*HKRANKMAX-1))
+                    victim_rank = victim_title - (HKRANKMAX-1) + 4;
+                else
+                    victim_guid = 0;                        // Don't show HK: <rank> message, only log.
+
+                // now find rank difference
+                if (killer_title == 0 && victim_rank>4)
+                    rank_diff = victim_rank - 4;
+                else if (killer_title < HKRANKMAX)
+                    rank_diff = (victim_rank>(killer_title + 4))? (victim_rank - (killer_title + 4)) : 0;
+                else if (killer_title < (2*HKRANKMAX-1))
+                    rank_diff = (victim_rank>(killer_title - (HKRANKMAX-1) +4))? (victim_rank - (killer_title - (HKRANKMAX-1) + 4)) : 0;
+
+
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+            honor *= 1 + sWorld->getRate(RATE_PVP_RANK_EXTRA_HONOR)*(((float)rank_diff) / 10.0f);
+
+            // count the number of playerkills in one day
+            ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+            // and those in a lifetime
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
+            UpdateKnownTitles();
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
+        }
+        else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_GUARD) && victim->ToCreature()->IsGuard())
+        {
+            uint8 k_level = getLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->getLevel();
+
+            if (v_level <= k_grey)
+                return false;
+
+            uint32 victim_title = 0;
+            victim_guid = 0;
+
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+
+            // count the number of playerkills in one day
+            ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+            // and those in a lifetime
+            ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_CLASS, victim->getClass());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HK_RACE, victim->getRace());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL_AT_AREA, GetAreaId());
+            UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_HONORABLE_KILL, 1, 0, victim);
+        }
+        else if (sWorld->getBoolConfig(CONFIG_GAIN_HONOR_ELITE) && victim->ToCreature()->isElite())
+        {
+            uint8 k_level = getLevel();
+            uint8 k_grey = Trinity::XP::GetGrayLevel(k_level);
+            uint8 v_level = victim->getLevel();
 
-            honor_f = std::ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
+            if (v_level <= k_grey)
+                return false;
 
+            uint32 victim_title = 0;
+            victim_guid = 0;
+            honor_f = ceil(Trinity::Honor::hk_honor_at_level_f(k_level) * (v_level - k_grey) / (k_level - k_grey));
             // count the number of playerkills in one day
             ApplyModUInt32Value(PLAYER_FIELD_KILLS, 1, true);
+
             // and those in a lifetime
             ApplyModUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS, 1, true);
             UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_EARN_HONORABLE_KILL);
@@ -7215,6 +7379,16 @@ bool Player::RewardHonor(Unit* victim, uint32 groupsize, int32 honor, bool pvpto
     }
 
     honor_f *= sWorld->getRate(RATE_HONOR);
+
+    //Guild-Level-System (Bonus: Ehre)
+    if (Guild* guild = GetGuild())
+    {
+        if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_1))
+            honor_f *= 0.05f;
+        if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_2))
+            honor_f *= 0.1f;
+    }
+
     // Back to int now
     honor = int32(honor_f);
     // honor - for show honor points in log
@@ -7285,6 +7459,30 @@ void Player::SetArenaPoints(uint32 value)
         AddKnownCurrency(ITEM_ARENA_POINTS_ID);
 }
 
+void Player::UpdateKnownTitles()
+{
+    uint32 new_title = 0;
+    uint32 honor_kills = GetUInt32Value(PLAYER_FIELD_LIFETIME_HONORABLE_KILLS);
+    uint32 old_title = GetUInt32Value(PLAYER_CHOSEN_TITLE);
+    RemoveFlag64(PLAYER__FIELD_KNOWN_TITLES,PLAYER_TITLE_MASK_ALL_PVP);
+    // if (honor_kills < 0)
+    //    return;
+    bool max_rank = ((honor_kills >= sWorld->pvp_ranks[HKRANKMAX-1]) ? true : false);
+    for (int i = HKRANK01; i != HKRANKMAX; ++i)
+    {
+        if (honor_kills < sWorld->pvp_ranks[i] || (max_rank))
+        {
+            new_title = ((max_rank) ? (HKRANKMAX-1) : (i-1));
+            if (new_title > 0)
+                new_title += ((GetTeam() == ALLIANCE) ? 0 : (HKRANKMAX-1));
+            break;
+        }
+    }
+    SetFlag64(PLAYER__FIELD_KNOWN_TITLES,uint64(1) << new_title);
+    if (old_title > 0 && old_title < (2*HKRANKMAX-1) && new_title > old_title)
+        SetUInt32Value(PLAYER_CHOSEN_TITLE,new_title);
+}
+
 void Player::ModifyHonorPoints(int32 value, SQLTransaction trans)
 {
     int32 newValue = int32(GetHonorPoints()) + value;
@@ -7444,7 +7642,7 @@ void Player::UpdateArea(uint32 newArea)
 
     // previously this was in UpdateZone (but after UpdateArea) so nothing will break
     pvpInfo.IsInNoPvPArea = false;
-    if (area && area->IsSanctuary())    // in sanctuary
+    if(area && area->IsSanctuary() || GetAreaId() == 4413)    // in sanctuary
     {
         SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_SANCTUARY);
         pvpInfo.IsInNoPvPArea = true;
@@ -7785,6 +7983,20 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
     if (only_level_scale && !ssv)
         return;
 
+    uint32 statcount = proto->StatsCount;
+    ReforgeData* reforgeData = NULL;
+    bool decreased = false;
+    if (statcount < MAX_ITEM_PROTO_STATS)
+    {
+        if (Item* invItem = GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+        {
+            if (reforgeMap.find(invItem->GetGUIDLow()) != reforgeMap.end())
+            {
+                reforgeData = &reforgeMap[invItem->GetGUIDLow()];
+                ++statcount;
+            }
+        }
+    }
     for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
     {
         uint32 statType = 0;
@@ -7799,10 +8011,24 @@ void Player::_ApplyItemBonuses(ItemTemplate const* proto, uint8 slot, bool apply
         }
         else
         {
-            if (i >= proto->StatsCount)
+            if (i >= statcount)
                 continue;
             statType = proto->ItemStat[i].ItemStatType;
             val = proto->ItemStat[i].ItemStatValue;
+
+            if (reforgeData)
+            {
+                if(i == statcount-1)
+                {
+                    statType = reforgeData->increase;
+                    val = reforgeData->stat_value;
+                }
+                else if (!decreased && reforgeData->decrease == statType)
+                {
+                    val -= reforgeData->stat_value;
+                    decreased = true;
+                }
+            }
         }
 
         if (val == 0)
@@ -11977,13 +12203,13 @@ InventoryResult Player::CanUseItem(ItemTemplate const* proto) const
     if (!proto)
         return EQUIP_ERR_ITEM_NOT_FOUND;
 
-    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetTeam() != HORDE)
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && GetOTeam() != HORDE)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetTeam() != ALLIANCE)
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && GetOTeam() != ALLIANCE)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
-    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getRaceMask()) == 0)
+    if ((proto->AllowableClass & getClassMask()) == 0 || (proto->AllowableRace & getORaceMask()) == 0)
         return EQUIP_ERR_YOU_CAN_NEVER_USE_THAT_ITEM;
 
     if (proto->RequiredSkill != 0)
@@ -12473,7 +12699,10 @@ void Player::SetVisibleItemSlot(uint8 slot, Item* pItem)
 {
     if (pItem)
     {
-        SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
+        if (uint32 entry = sTransmogrification->GetFakeEntry(pItem))
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), entry);
+        else
+            SetUInt32Value(PLAYER_VISIBLE_ITEM_1_ENTRYID + (slot * 2), pItem->GetEntry());
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 0, pItem->GetEnchantmentId(PERM_ENCHANTMENT_SLOT));
         SetUInt16Value(PLAYER_VISIBLE_ITEM_1_ENCHANTMENT + (slot * 2), 1, pItem->GetEnchantmentId(TEMP_ENCHANTMENT_SLOT));
     }
@@ -12593,12 +12822,36 @@ void Player::RemoveItem(uint8 bag, uint8 slot, bool update)
             pItem->SendUpdateToPlayer(this);
     }
 }
-
+extern void RemoveReforge(Player* player, uint32 itemguid, bool update);
 // Common operation need to remove item from inventory without delete in trade, auction, guild bank, mail....
 void Player::MoveItemFromInventory(uint8 bag, uint8 slot, bool update)
 {
     if (Item* it = GetItemByPos(bag, slot))
     {
+    // Prepatch by LordPsyan
+        RemoveReforge(this, it->GetGUIDLow(), true);
+    // 02
+    // 03
+    // 04
+    // 05
+    // 06
+        sTransmogrification->DeleteFakeEntry(this, it);
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
         ItemRemovedQuestCheck(it->GetEntry(), it->GetCount());
         RemoveItem(bag, slot, update);
         it->SetNotRefundable(this, false);
@@ -15309,13 +15562,26 @@ void Player::RewardQuest(Quest const* quest, uint32 reward, Object* questGiver,
     bool rewarded = (m_RewardedQuests.find(quest_id) != m_RewardedQuests.end());
 
     // Not give XP in case already completed once repeatable quest
-    uint32 XP = rewarded && !quest->IsDFQuest() ? 0 : uint32(quest->XPValue(this)*sWorld->getRate(RATE_XP_QUEST));
+    uint32 XP = rewarded && !quest->IsDFQuest() ? 0 : uint32(quest->XPValue(this)*(_individual_quest > 0 ? _individual_quest : sWorld->getRate(RATE_XP_QUEST)));
 
     // handle SPELL_AURA_MOD_XP_QUEST_PCT auras
     Unit::AuraEffectList const& ModXPPctAuras = GetAuraEffectsByType(SPELL_AURA_MOD_XP_QUEST_PCT);
     for (Unit::AuraEffectList::const_iterator i = ModXPPctAuras.begin(); i != ModXPPctAuras.end(); ++i)
         AddPct(XP, (*i)->GetAmount());
 
+    //Guild-Level-System (Bonus: QuestXP)
+    if (Guild* guild = GetGuild())
+    {
+        //QuestXP for the Guild
+        guild->GiveXp(50000);
+
+        //GuildXP-Bonus
+        if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+            XP += uint32(XP*0.05f);
+        if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+            XP += uint32(XP*0.1f);
+    }
+
     int32 moneyRew = 0;
     if (getLevel() < sWorld->getIntConfig(CONFIG_MAX_PLAYER_LEVEL))
         GiveXP(XP, NULL);
@@ -17217,6 +17483,11 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
         return false;
     }
 
+    SetORace();
+    m_team = TeamForRace(getORace());
+    SetFakeRaceAndMorph(); // m_team must be set before this can be used.
+    setFactionForRace(getORace());//Need to call it to initialize m_team (m_team can be calculated from race)
+
     SetUInt32Value(UNIT_FIELD_LEVEL, fields[6].GetUInt8());
     SetUInt32Value(PLAYER_XP, fields[7].GetUInt32());
 
@@ -17263,10 +17534,6 @@ bool Player::LoadFromDB(uint32 guid, SQLQueryHolder *holder)
     TC_LOG_DEBUG("entities.player.loading", "Load Basic value of player %s is: ", m_name.c_str());
     outDebugValues();
 
-    //Need to call it to initialize m_team (m_team can be calculated from race)
-    //Other way is to saves m_team into characters table.
-    setFactionForRace(getRace());
-
     // load home bind and check in same time class/race pair, it used later for restore broken positions
     if (!_LoadHomeBind(holder->GetPreparedResult(PLAYER_LOGIN_QUERY_LOAD_HOME_BIND)))
         return false;
@@ -19183,7 +19450,7 @@ void Player::SaveToDB(bool create /*=false*/)
         stmt->setUInt32(index++, GetGUIDLow());
         stmt->setUInt32(index++, GetSession()->GetAccountId());
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -19288,7 +19555,7 @@ void Player::SaveToDB(bool create /*=false*/)
         // Update query
         stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_CHARACTER);
         stmt->setString(index++, GetName());
-        stmt->setUInt8(index++, getRace());
+        stmt->setUInt8(index++, getORace());
         stmt->setUInt8(index++, getClass());
         stmt->setUInt8(index++, getGender());
         stmt->setUInt8(index++, getLevel());
@@ -19442,6 +19709,12 @@ void Player::SaveToDB(bool create /*=false*/)
 
     CharacterDatabase.CommitTransaction(trans);
 
+    // we save the data here to prevent spamming
+    sAnticheatMgr->SavePlayerData(this);
+
+    // in this way we prevent to spam the db by each report made!
+    // sAnticheatMgr->SavePlayerData(this);
+
     // save pet (hunter pet level and experience and all type pets health/mana).
     if (Pet* pet = GetPet())
         pet->SavePetToDB(PET_SAVE_AS_CURRENT);
@@ -20527,6 +20800,19 @@ void Player::StopCastingCharm()
     }
 }
 
+void Player::BuildPlayerChat(WorldPacket* data, uint8 msgtype, const std::string& text, uint32 language) const
+{
+    *data << uint8(msgtype);
+    *data << uint32(language);
+    *data << uint64(GetGUID());
+    *data << uint32(0);                                      // constant unknown time
+    *data << uint64(GetGUID());
+    *data << uint32(text.length() + 1);
+    *data << text;
+    *data << uint8(GetChatTag());
+}
+
+
 void Player::Say(const std::string& text, const uint32 language)
 {
     std::string _text(text);
@@ -22051,6 +22337,8 @@ void Player::AddSpellAndCategoryCooldowns(SpellInfo const* spellInfo, uint32 ite
 
 void Player::AddSpellCooldown(uint32 spellid, uint32 itemid, time_t end_time)
 {
+    if (sWorld->getBoolConfig(CONFIG_NO_COOLDOWN))
+        return;
     SpellCooldown sc;
     sc.end = end_time;
     sc.itemid = itemid;
@@ -22333,11 +22621,6 @@ void Player::SetBGTeam(uint32 team)
     SetByteValue(PLAYER_BYTES_3, 3, uint8(team == ALLIANCE ? 1 : 0));
 }
 
-uint32 Player::GetBGTeam() const
-{
-    return m_bgData.bgTeam ? m_bgData.bgTeam : GetTeam();
-}
-
 void Player::LeaveBattleground(bool teleportToEntryPoint)
 {
     if (Battleground* bg = GetBattleground())
@@ -22413,7 +22696,7 @@ void Player::ReportedAfkBy(Player* reporter)
 
 WorldLocation Player::GetStartPosition() const
 {
-    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getRace(), getClass());
+    PlayerInfo const* info = sObjectMgr->GetPlayerInfo(getORace(), getClass());
     uint32 mapId = info->mapId;
     if (getClass() == CLASS_DEATH_KNIGHT && HasSpell(50977))
         mapId = 0;
@@ -22872,10 +23155,13 @@ void Player::SendInitialPacketsBeforeAddToMap()
 
     SendEquipmentSetList();
 
+    float speedrate = sWorld->getFloatConfig(CONFIG_SPEED_GAME);
+    uint32 speedtime = ((sWorld->GetGameTime() - sWorld->GetUptime()) + (sWorld->GetUptime() * speedrate));
+
     data.Initialize(SMSG_LOGIN_SETTIMESPEED, 4 + 4 + 4);
-    data.AppendPackedTime(sWorld->GetGameTime());
-    data << float(0.01666667f);                             // game speed
-    data << uint32(0);                                      // added in 3.1.2
+    data.AppendPackedTime(speedtime);
+    data << float(0.01666667f) * speedrate; // game speed
+    data << uint32(0); // added in 3.1.2
     GetSession()->SendPacket(&data);
 
     GetReputationMgr().SendForceReactions();                // SMSG_SET_FORCED_REACTIONS
@@ -26852,6 +27138,25 @@ bool Player::IsLoading() const
     return GetSession()->PlayerLoading();
 }
 
+//Individuale_XP-Rate
+void Player::SetIndividualRate(IndividualXpRate rate, float value)
+{
+    if (value < 1 || value > 8)
+        return;
+
+    switch (rate)
+    {
+        case INDIVIDUAL_XP_KILL:
+            _individual_kill = value;
+            break;
+        case INDIVIDUAL_XP_QUEST:
+            _individual_quest = value;
+        break;
+        default:
+            break;
+    }
+}
+
 void Player::SendSupercededSpell(uint32 oldSpell, uint32 newSpell)
 {
     WorldPacket data(SMSG_SUPERCEDED_SPELL, 8);
diff --git a/src/server/game/Entities/Player/Player.h b/src/server/game/Entities/Player/Player.h
index 27ea835..e933f83 100644
--- a/src/server/game/Entities/Player/Player.h
+++ b/src/server/game/Entities/Player/Player.h
@@ -28,6 +28,7 @@
 #include "QuestDef.h"
 #include "SpellMgr.h"
 #include "Unit.h"
+#include "../../scripts/Custom/Transmogrification.h"
 
 #include <limits>
 #include <string>
@@ -122,10 +123,29 @@ struct SpellModifier
     Aura* const ownerAura;
 };
 
+typedef std::unordered_map<uint64, uint32> TransmogMapType;
+
+#ifdef PRESETS
+typedef std::map<uint8, uint32> PresetslotMapType;
+struct PresetData
+{
+    std::string name;
+    PresetslotMapType slotMap; // slotMap[slotId] = entry
+};
+typedef std::map<uint8, PresetData> PresetMapType;
+#endif
+
 typedef std::unordered_map<uint32, PlayerTalent*> PlayerTalentMap;
 typedef std::unordered_map<uint32, PlayerSpell*> PlayerSpellMap;
 typedef std::list<SpellModifier*> SpellModList;
 
+struct ReforgeData
+{
+    uint32 increase, decrease;
+    int32 stat_value;
+};
+typedef std::unordered_map<uint32, ReforgeData> ReforgeMapType;
+
 typedef std::list<uint64> WhisperListContainer;
 
 struct SpellCooldown
@@ -419,6 +439,27 @@ enum PlayerFlags
     PLAYER_FLAGS_UNK31             = 0x80000000
 };
 
+#define PLAYER_TITLE_MASK_ALLIANCE_PVP             \
+    (PLAYER_TITLE_PRIVATE | PLAYER_TITLE_CORPORAL |  \
+      PLAYER_TITLE_SERGEANT_A | PLAYER_TITLE_MASTER_SERGEANT | \
+      PLAYER_TITLE_SERGEANT_MAJOR | PLAYER_TITLE_KNIGHT | \
+      PLAYER_TITLE_KNIGHT_LIEUTENANT | PLAYER_TITLE_KNIGHT_CAPTAIN | \
+      PLAYER_TITLE_KNIGHT_CHAMPION | PLAYER_TITLE_LIEUTENANT_COMMANDER | \
+      PLAYER_TITLE_COMMANDER | PLAYER_TITLE_MARSHAL | \
+      PLAYER_TITLE_FIELD_MARSHAL | PLAYER_TITLE_GRAND_MARSHAL)
+
+#define PLAYER_TITLE_MASK_HORDE_PVP                           \
+    (PLAYER_TITLE_SCOUT | PLAYER_TITLE_GRUNT |  \
+      PLAYER_TITLE_SERGEANT_H | PLAYER_TITLE_SENIOR_SERGEANT | \
+      PLAYER_TITLE_FIRST_SERGEANT | PLAYER_TITLE_STONE_GUARD | \
+      PLAYER_TITLE_BLOOD_GUARD | PLAYER_TITLE_LEGIONNAIRE | \
+      PLAYER_TITLE_CENTURION | PLAYER_TITLE_CHAMPION | \
+      PLAYER_TITLE_LIEUTENANT_GENERAL | PLAYER_TITLE_GENERAL | \
+      PLAYER_TITLE_WARLORD | PLAYER_TITLE_HIGH_WARLORD)
+
+#define PLAYER_TITLE_MASK_ALL_PVP  \
+    (PLAYER_TITLE_MASK_ALLIANCE_PVP | PLAYER_TITLE_MASK_HORDE_PVP)
+
 // used for PLAYER__FIELD_KNOWN_TITLES field (uint64), (1<<bit_index) without (-1)
 // can't use enum for uint64 values
 #define PLAYER_TITLE_DISABLED              UI64LIT(0x0000000000000000)
@@ -917,6 +958,13 @@ enum PlayerCommandStates
     CHEAT_WATERWALK = 0x10
 };
 
+//Individuale_XP-Rate
+enum IndividualXpRate
+{
+    INDIVIDUAL_XP_KILL  = 1,
+    INDIVIDUAL_XP_QUEST = 2,
+};
+
 class PlayerTaxi
 {
     public:
@@ -1100,6 +1148,35 @@ class Player : public Unit, public GridObject<Player>
     public:
         explicit Player(WorldSession* session);
         ~Player();
+        private:
+        bool m_ForgetBGPlayers;
+        bool m_ForgetInListPlayers;
+        uint8 m_FakeRace;
+        uint8 m_RealRace;
+        uint32 m_FakeMorph;
+    public:
+        typedef std::vector<uint64> FakePlayers;
+        void SendChatMessage(const char *format, ...);
+        void FitPlayerInTeam(bool action, Battleground* pBattleGround = NULL);
+        void DoForgetPlayersInList();
+        void DoForgetPlayersInBG(Battleground* pBattleGround);
+        uint8 getORace() const { return m_RealRace; }
+        void SetORace() { m_RealRace = GetByteValue(UNIT_FIELD_BYTES_0, 0); }; // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRace(); // SHOULD ONLY BE CALLED ON LOGIN
+        void SetFakeRaceAndMorph(); // SHOULD ONLY BE CALLED ON LOGIN
+        uint32 GetFakeMorph() { return m_FakeMorph; };
+        uint8 getFRace() const { return m_FakeRace; }
+        void SetForgetBGPlayers(bool value) { m_ForgetBGPlayers = value; }
+        bool ShouldForgetBGPlayers() { return m_ForgetBGPlayers; }
+        void SetForgetInListPlayers(bool value) { m_ForgetInListPlayers = value; }
+        bool ShouldForgetInListPlayers() { return m_ForgetInListPlayers; }
+        bool SendBattleGroundChat(uint32 msgtype, std::string message);
+        void MorphFit(bool value);
+        bool IsPlayingNative() const { return GetTeam() == m_team; }
+        uint32 GetOTeam() const { return m_team; }
+        uint32 GetTeam() const { return m_bgData.bgTeam && GetBattleground() ? m_bgData.bgTeam : m_team; }
+        bool SendRealNameQuery();
+        FakePlayers m_FakePlayers;
 
         void CleanupsBeforeDelete(bool finalCleanup = true) override;
 
@@ -1154,7 +1231,7 @@ class Player : public Unit, public GridObject<Player>
         PlayerSocial *GetSocial() { return m_social; }
 
         PlayerTaxi m_taxi;
-        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getRace(), getClass(), getLevel()); }
+        void InitTaxiNodesForLevel() { m_taxi.InitTaxiNodesForLevel(getORace(), getClass(), getLevel()); }
         bool ActivateTaxiPathTo(std::vector<uint32> const& nodes, Creature* npc = NULL, uint32 spellid = 0);
         bool ActivateTaxiPathTo(uint32 taxi_path_id, uint32 spellid = 0);
         void CleanupAfterTaxiFlight();
@@ -1222,6 +1299,8 @@ class Player : public Unit, public GridObject<Player>
         void TextEmote(std::string const& text);
         /// Handles whispers from Addons and players based on sender, receiver's guid and language.
         void Whisper(std::string const& text, const uint32 language, uint64 receiver);
+        /// Constructs the player Chat data for the specific functions to use
+        void BuildPlayerChat(WorldPacket* data, uint8 msgtype, std::string const& text, uint32 language) const;
 
         /*********************************************************/
         /***                    STORAGE SYSTEM                 ***/
@@ -1927,8 +2006,7 @@ class Player : public Unit, public GridObject<Player>
         void CheckAreaExploreAndOutdoor(void);
 
         static uint32 TeamForRace(uint8 race);
-        uint32 GetTeam() const { return m_team; }
-        TeamId GetTeamId() const { return m_team == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
+        TeamId GetTeamId() const { return GetTeam() == ALLIANCE ? TEAM_ALLIANCE : TEAM_HORDE; }
         void setFactionForRace(uint8 race);
 
         void InitDisplayIds();
@@ -1965,6 +2043,7 @@ class Player : public Unit, public GridObject<Player>
         void ModifyHonorPoints(int32 value, SQLTransaction trans = SQLTransaction(nullptr));      //! If trans is specified, honor save query will be added to trans
         void ModifyArenaPoints(int32 value, SQLTransaction trans = SQLTransaction(nullptr));      //! If trans is specified, arena point save query will be added to trans
         uint32 GetMaxPersonalArenaRatingRequirement(uint32 minarenaslot) const;
+        void UpdateKnownTitles();
         void SetHonorPoints(uint32 value);
         void SetArenaPoints(uint32 value);
 
@@ -2073,7 +2152,6 @@ class Player : public Unit, public GridObject<Player>
         void SetBattlegroundEntryPoint();
 
         void SetBGTeam(uint32 team);
-        uint32 GetBGTeam() const;
 
         void LeaveBattleground(bool teleportToEntryPoint = true);
         bool CanJoinToBattleground(Battleground const* bg) const;
@@ -2312,6 +2390,7 @@ class Player : public Unit, public GridObject<Player>
         void SetTitle(CharTitlesEntry const* title, bool lost = false);
 
         //bool isActiveObject() const { return true; }
+        ReforgeMapType reforgeMap; // reforgeMap[iGUID] = ReforgeData
         bool CanSeeSpellClickOn(Creature const* creature) const;
 
         uint32 GetChampioningFaction() const { return m_ChampioningFaction; }
@@ -2332,6 +2411,11 @@ class Player : public Unit, public GridObject<Player>
         bool SetFeatherFall(bool apply, bool packetOnly = false) override;
         bool SetHover(bool enable, bool packetOnly = false) override;
 
+        TransmogMapType transmogMap; // transmogMap[iGUID] = entry
+#ifdef PRESETS
+        PresetMapType presetMap; // presetMap[presetId] = presetData
+#endif
+
         bool CanFly() const override { return m_movementInfo.HasMovementFlag(MOVEMENTFLAG_CAN_FLY); }
 
         //! Return collision height sent to client
@@ -2342,6 +2426,11 @@ class Player : public Unit, public GridObject<Player>
 
         bool IsLoading() const;
 
+        //Individuale_XP-Rate
+        void SetIndividualRate(IndividualXpRate rate, float value);
+        float GetIndividualXpKillRate() { return _individual_kill; };
+        float GetIndividualXpQuestRate() { return _individual_quest; };
+
     protected:
         // Gamemaster whisper whitelist
         WhisperListContainer WhisperList;
@@ -2670,6 +2759,10 @@ class Player : public Unit, public GridObject<Player>
         uint32 _pendingBindTimer;
 
         uint32 _activeCheats;
+
+        //Individuale_XP-Rate
+        float _individual_kill;
+        float _individual_quest;
 };
 
 void AddItemsSetItem(Player* player, Item* item);
diff --git a/src/server/game/Entities/Unit/Unit.cpp b/src/server/game/Entities/Unit/Unit.cpp
index bfa57ef..e26bc69 100644
--- a/src/server/game/Entities/Unit/Unit.cpp
+++ b/src/server/game/Entities/Unit/Unit.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Unit.h"
 #include "Common.h"
 #include "Battlefield.h"
@@ -61,6 +62,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 #include <cmath>
 
@@ -426,7 +428,14 @@ void Unit::DisableSpline()
 
 void Unit::resetAttackTimer(WeaponAttackType type)
 {
-    m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type]);
+    if (GetTypeId() == TYPEID_PLAYER || (ToCreature()->GetOwner() && ToCreature()->GetOwner()->GetTypeId() == TYPEID_PLAYER))
+    {
+        m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type] / sWorld->getFloatConfig(CONFIG_ATTACKSPEED_PLAYER));
+    }
+    else
+    {
+        m_attackTimer[type] = uint32(GetAttackTime(type) * m_modAttackSpeedPct[type] / sWorld->getFloatConfig(CONFIG_ATTACKSPEED_ALL));
+    }
 }
 
 float Unit::GetMeleeReach() const
@@ -12171,10 +12180,30 @@ void Unit::SetVisible(bool x)
 
 void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
 {
+    //if (this->ToPlayer())
+    //    sAnticheatMgr->DisableAnticheatDetection(this->ToPlayer());
+
     int32 main_speed_mod  = 0;
     float stack_bonus     = 1.0f;
     float non_stack_bonus = 1.0f;
 
+    //Guild-Level-System (Bonus: Reittempo)
+    uint8 bonusSpeed = 0;
+    if (GetTypeId() == TYPEID_PLAYER)
+    {
+        Player* player = ToPlayer();
+        if (Guild* guild = player->GetGuild())
+        {
+            if (!player->GetMap()->IsBattlegroundOrArena())
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_1))
+                    bonusSpeed = 5;
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_2))
+                    bonusSpeed = 10;
+            }
+        }
+    }
+
     switch (mtype)
     {
         // Only apply debuffs
@@ -12188,7 +12217,7 @@ void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
         {
             if (IsMounted()) // Use on mount auras
             {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED);
+                main_speed_mod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_SPEED) + bonusSpeed;
                 stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_SPEED_ALWAYS);
                 non_stack_bonus += GetMaxPositiveAuraModifier(SPELL_AURA_MOD_MOUNTED_SPEED_NOT_STACK) / 100.0f;
             }
@@ -12222,7 +12251,7 @@ void Unit::UpdateSpeed(UnitMoveType mtype, bool forced)
             }
             else if (IsMounted())
             {
-                main_speed_mod  = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED);
+                main_speed_mod = GetMaxPositiveAuraModifier(SPELL_AURA_MOD_INCREASE_MOUNTED_FLIGHT_SPEED) + bonusSpeed;
                 stack_bonus     = GetTotalAuraMultiplier(SPELL_AURA_MOD_MOUNTED_FLIGHT_SPEED_ALWAYS);
             }
             else             // Use not mount (shapeshift for example) auras (should stack)
@@ -15988,7 +16017,7 @@ void Unit::RemoveCharmedBy(Unit* charmer)
 void Unit::RestoreFaction()
 {
     if (GetTypeId() == TYPEID_PLAYER)
-        ToPlayer()->setFactionForRace(getRace());
+        ToPlayer()->setFactionForRace(ToPlayer()->getRace());
     else
     {
         if (HasUnitTypeMask(UNIT_MASK_MINION))
@@ -16739,6 +16768,21 @@ uint32 Unit::GetModelForTotem(PlayerTotemType totemType)
             }
             break;
         }
+        default: // One standard for other races.
+        {        // THANKS L30m4nc3r for this
+            switch (totemType)
+            {
+                case SUMMON_TYPE_TOTEM_FIRE:    // fire
+                    return 4589;
+                case SUMMON_TYPE_TOTEM_EARTH:   // earth
+                    return 4588;
+                case SUMMON_TYPE_TOTEM_WATER:   // water
+                    return 4587;
+                case SUMMON_TYPE_TOTEM_AIR:     // air
+                    return 4590;
+            }
+            break;
+        }
     }
     return 0;
 }
diff --git a/src/server/game/Entities/Unit/Unit.h b/src/server/game/Entities/Unit/Unit.h
index a18bc3b..ea0328b 100644
--- a/src/server/game/Entities/Unit/Unit.h
+++ b/src/server/game/Entities/Unit/Unit.h
@@ -1357,8 +1357,10 @@ class Unit : public WorldObject
         uint8 getLevel() const { return uint8(GetUInt32Value(UNIT_FIELD_LEVEL)); }
         uint8 getLevelForTarget(WorldObject const* /*target*/) const override { return getLevel(); }
         void SetLevel(uint8 lvl);
-        uint8 getRace() const { return GetByteValue(UNIT_FIELD_BYTES_0, 0); }
+        uint8 getRace(bool forceoriginal = false) const;
+        uint8 getORace() { return getRace(true); }
         uint32 getRaceMask() const { return 1 << (getRace()-1); }
+        uint32 getORaceMask() const { return 1 << (getRace(true) - 1); }
         uint8 getClass() const { return GetByteValue(UNIT_FIELD_BYTES_0, 1); }
         uint32 getClassMask() const { return 1 << (getClass()-1); }
         uint8 getGender() const { return GetByteValue(UNIT_FIELD_BYTES_0, 2); }
diff --git a/src/server/game/Entities/Vehicle/Vehicle.cpp b/src/server/game/Entities/Vehicle/Vehicle.cpp
old mode 100755
new mode 100644
diff --git a/src/server/game/Guilds/Guild.cpp b/src/server/game/Guilds/Guild.cpp
index bace2ec..64fc3f7 100644
--- a/src/server/game/Guilds/Guild.cpp
+++ b/src/server/game/Guilds/Guild.cpp
@@ -1207,6 +1207,9 @@ bool Guild::Create(Player* pLeader, std::string const& name)
     if (ret)
         sScriptMgr->OnGuildCreate(this, pLeader, name);
 
+    //Guild-Level-System
+    LoadLevelInfo();
+
     return ret;
 }
 
@@ -1516,6 +1519,31 @@ void Guild::HandleInviteMember(WorldSession* session, std::string const& name)
     Player* pInvitee = sObjectAccessor->FindPlayerByName(name);
     if (!pInvitee)
     {
+        if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+        {
+            PreparedStatement* fake = CharacterDatabase.GetPreparedStatement(FAKE_CHAR_SEL_RACE_BY_NAME_IS_ONLINE);
+            fake->setUInt32(0, sWorld->getIntConfig(CONFIG_FAKE_WHO_ONLINE_INTERVAL));
+            fake->setString(1, name);
+            PreparedQueryResult fakeresult = CharacterDatabase.Query(fake);
+
+            if (fakeresult)
+            {
+                Field* fields = fakeresult->Fetch();
+                uint32 team = Player::TeamForRace(fields[0].GetUInt8());
+
+                if (!sWorld->getBoolConfig(CONFIG_ALLOW_TWO_SIDE_INTERACTION_GUILD) && team != session->GetPlayer()->GetTeam())
+                {
+                    SendCommandResult(session, GUILD_COMMAND_INVITE, ERR_GUILD_NOT_ALLIED, name);
+                }
+                else
+                {
+                    ChatHandler(session->GetPlayer()->GetSession()).PSendSysMessage(LANG_FAKE_NOT_DISTURB);
+                }
+
+                return;
+            }
+        }
+
         SendCommandResult(session, GUILD_COMMAND_INVITE, ERR_GUILD_PLAYER_NOT_FOUND_S, name);
         return;
     }
@@ -1958,6 +1986,10 @@ bool Guild::LoadFromDB(Field* fields)
         m_bankTabs[i] = new BankTab(m_id, i);
 
     _CreateLogHolders();
+
+    //Guild-Level-System
+    LoadLevelInfo();
+
     return true;
 }
 
@@ -2925,3 +2957,140 @@ void Guild::ResetTimes()
 
     _BroadcastEvent(GE_BANK_TAB_AND_MONEY_UPDATED, 0);
 }
+
+//Guild-Level-System [Start]
+void Guild::LoadLevelInfo()
+{
+    PreparedStatement* stmt;
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_LEVEL_INFO);
+    stmt->setUInt32(0, m_id);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+    {
+        m_current_guildXp = (*result)[0].GetUInt32();
+        m_guild_level = (*result)[1].GetUInt8();
+    }
+    else
+    {
+        m_current_guildXp = 0;
+        m_guild_level = 0;
+    }
+
+    if (m_guild_level < GUILD_MAX_LEVEL)
+    {
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL);
+        stmt->setUInt32(0, m_guild_level);
+        PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+        if (result)
+            m_xp_for_next_level = (*result)[0].GetUInt32();
+        else
+            m_xp_for_next_level = 0;
+    }
+}
+
+bool Guild::HasLevelForBonus(uint8 guildBonus)
+{
+    switch (guildBonus)
+    {
+    case GUILD_BONUS_GOLD_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_GOLD_1);
+        break;
+    case GUILD_BONUS_XP_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_XP_1);
+        break;
+    case GUILD_BONUS_SCHNELLER_GEIST:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST);
+        break;
+    case GUILD_BONUS_REPERATUR_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_1);
+        break;
+    case GUILD_BONUS_GOLD_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_GOLD_2);
+        break;
+    case GUILD_BONUS_REITTEMPO_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_1);
+        break;
+    case GUILD_BONUS_RUF_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_RUF_1);
+        break;
+    case GUILD_BONUS_XP_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_XP_2);
+        break;
+    case GUILD_BONUS_REPERATUR_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_2);
+        break;
+    case GUILD_BONUS_REITTEMPO_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_2);
+        break;
+    case GUILD_BONUS_RUF_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_RUF_2);
+        break;
+    case GUILD_BONUS_EHRE_1:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_EHRE_1);
+        break;
+    case GUILD_BONUS_EHRE_2:
+        return m_guild_level >= sWorld->GetReqGuildLevelForBonus(GUILD_BONUS_EHRE_2);
+        break;
+    default:
+        return false;
+        break;
+    }
+}
+
+void Guild::GiveXp(uint32 value)
+{
+    if (m_guild_level > GUILD_MAX_LEVEL)
+        return;
+
+    if ((m_current_guildXp + value) >= m_xp_for_next_level)
+    {
+        m_current_guildXp = ((m_current_guildXp + value) - m_xp_for_next_level);
+        SetLevel(m_guild_level + 1, false);
+    }
+    else
+        m_current_guildXp += value;
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_XP);
+    stmt->setUInt32(0, value);
+    stmt->setUInt32(1, m_id);
+    CharacterDatabase.Execute(stmt);
+}
+
+void Guild::SetLevel(uint8 level, bool byCommand)
+{
+    if (level > GUILD_MAX_LEVEL)
+        return;
+
+    m_guild_level = level;
+
+    if (byCommand)
+    {
+        m_current_guildXp = 0;
+
+        PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_XP);
+        stmt->setUInt8(0, m_current_guildXp);
+        stmt->setUInt32(1, m_id);
+        CharacterDatabase.Execute(stmt);
+    }
+
+    char worldMsg[250];
+    sprintf(worldMsg, "The Guild %s has reached Guild Level %d.", m_name.c_str(), level);
+    sWorld->SendWorldText(SERVER_MSG_STRING, worldMsg);
+
+    //Save to DB
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_UPD_GUILD_LEVEL);
+    stmt->setUInt8(0, level);
+    stmt->setUInt32(1, m_id);
+    CharacterDatabase.Execute(stmt);
+
+    //reqXp fuers naechste Level laden
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL);
+    stmt->setUInt32(0, level);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+        m_xp_for_next_level = (*result)[0].GetUInt32();
+}
+//Guild-Level-System [End]
diff --git a/src/server/game/Guilds/Guild.h b/src/server/game/Guilds/Guild.h
index 375d39c..0316511 100644
--- a/src/server/game/Guilds/Guild.h
+++ b/src/server/game/Guilds/Guild.h
@@ -222,6 +222,29 @@ enum GuildMemberFlags
     GUILDMEMBER_STATUS_MOBILE           = 0x0008, // remote chat from mobile app
 };
 
+//Guild-Level-System [Start]
+enum GuildBonus
+{
+    GUILD_BONUS_GOLD_1 = 1,
+    GUILD_BONUS_XP_1 = 2,
+    GUILD_BONUS_SCHNELLER_GEIST = 3,
+    GUILD_BONUS_REPERATUR_1 = 4,
+    GUILD_BONUS_GOLD_2 = 5,
+    GUILD_BONUS_REITTEMPO_1 = 6,
+    GUILD_BONUS_RUF_1 = 7,
+    GUILD_BONUS_XP_2 = 8,
+    GUILD_BONUS_REPERATUR_2 = 9,
+    GUILD_BONUS_REITTEMPO_2 = 10,
+    GUILD_BONUS_RUF_2 = 11,
+    GUILD_BONUS_EHRE_1 = 12,
+    GUILD_BONUS_EHRE_2 = 13,
+
+    GUILD_BONUS_MAX = 14
+};
+
+#define GUILD_MAX_LEVEL 8
+//Guild-Level-System [End]
+
 // Emblem info
 class EmblemInfo
 {
@@ -743,6 +766,15 @@ public:
 
     void ResetTimes();
 
+    //Guild-Level-System
+    void LoadLevelInfo();
+    bool HasLevelForBonus(uint8 guildBonus);
+    void GiveXp(uint32 value);
+    void SetLevel(uint8 level, bool byCommand);
+    uint8 GetLevel() const { return m_guild_level; };
+    uint32 GetCurrentXP() const { return m_current_guildXp; };
+    uint32 GetXpForNextLevel() const { return m_xp_for_next_level; };
+
 protected:
     uint32 m_id;
     std::string m_name;
@@ -763,6 +795,11 @@ protected:
     LogHolder* m_eventLog;
     LogHolder* m_bankEventLog[GUILD_BANK_MAX_TABS + 1];
 
+    //Guild-Level-System
+    uint8 m_guild_level;
+    uint32 m_current_guildXp;
+    uint32 m_xp_for_next_level;
+
 private:
     inline uint8 _GetRanksSize() const { return uint8(m_ranks.size()); }
     inline const RankInfo* GetRankInfo(uint8 rankId) const { return rankId < _GetRanksSize() ? &m_ranks[rankId] : NULL; }
diff --git a/src/server/game/Handlers/BattleGroundHandler.cpp b/src/server/game/Handlers/BattleGroundHandler.cpp
index 95e4dd3..0d2cf52 100644
--- a/src/server/game/Handlers/BattleGroundHandler.cpp
+++ b/src/server/game/Handlers/BattleGroundHandler.cpp
@@ -35,6 +35,8 @@
 #include "DisableMgr.h"
 #include "Group.h"
 
+#include "Cfbg/Cfbg.h"
+
 void WorldSession::HandleBattlemasterHelloOpcode(WorldPacket& recvData)
 {
     uint64 guid;
@@ -543,7 +545,7 @@ void WorldSession::HandleBattlefieldStatusOpcode(WorldPacket & /*recvData*/)
             {
                 // this line is checked, i only don't know if GetStartTime is changing itself after bg end!
                 // send status in Battleground
-                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetBGTeam());
+                sBattlegroundMgr->BuildBattlegroundStatusPacket(&data, bg, i, STATUS_IN_PROGRESS, bg->GetEndTime(), bg->GetStartTime(), arenaType, _player->GetTeam());
                 SendPacket(&data);
                 continue;
             }
diff --git a/src/server/game/Handlers/CharacterHandler.cpp b/src/server/game/Handlers/CharacterHandler.cpp
index b250787..2eda9f2 100644
--- a/src/server/game/Handlers/CharacterHandler.cpp
+++ b/src/server/game/Handlers/CharacterHandler.cpp
@@ -1041,10 +1041,59 @@ void WorldSession::HandlePlayerLogin(LoginQueryHolder* holder)
     _player->UpdateAchievementCriteria(ACHIEVEMENT_CRITERIA_TYPE_ON_LOGIN, 1);
 
     sScriptMgr->OnPlayerLogin(pCurrChar, firstLogin);
-
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    // 03
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     delete holder;
-}
 
+    if (pCurrChar->GetTeam() != pCurrChar->GetOTeam())
+        pCurrChar->FitPlayerInTeam(pCurrChar->GetBattleground() && !pCurrChar->GetBattleground()->isArena() ? true : false, pCurrChar->GetBattleground());
+}
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    // 03
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
 void WorldSession::HandleSetFactionAtWar(WorldPacket& recvData)
 {
     TC_LOG_DEBUG("network", "WORLD: Received CMSG_SET_FACTION_ATWAR");
diff --git a/src/server/game/Handlers/ChatHandler.cpp b/src/server/game/Handlers/ChatHandler.cpp
index eccf7a6..a7a50b2 100644
--- a/src/server/game/Handlers/ChatHandler.cpp
+++ b/src/server/game/Handlers/ChatHandler.cpp
@@ -48,6 +48,18 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
     recvData >> type;
     recvData >> lang;
 
+    if (sWorld->getBoolConfig(BATTLEGROUND_CROSSFACTION_ENABLED) && lang != LANG_ADDON)
+    {
+        switch (type)
+        {
+        case CHAT_MSG_BATTLEGROUND:
+        case CHAT_MSG_BATTLEGROUND_LEADER:
+            lang = LANG_UNIVERSAL;
+        default:
+            break;
+        }
+    }
+
     if (type >= MAX_CHAT_MSG_TYPE)
     {
         TC_LOG_ERROR("network", "CHAT: Wrong message type received: %u", type);
@@ -55,7 +67,7 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
         return;
     }
 
-    if (lang == LANG_UNIVERSAL && type != CHAT_MSG_AFK && type != CHAT_MSG_DND)
+    if (lang == CHAT_MSG_AFK && type != CHAT_MSG_DND)
     {
         TC_LOG_ERROR("network", "CMSG_MESSAGECHAT: Possible hacking-attempt: %s tried to send a message in universal language", GetPlayerInfo().c_str());
         SendNotification(LANG_UNKNOWN_LANGUAGE);
@@ -253,6 +265,10 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
                 return;
             }
 
+            if (!GetPlayer()->IsGameMaster())
+                if (GetPlayer()->SendBattleGroundChat(type, msg))
+                    return;
+
             if (type == CHAT_MSG_SAY)
                 sender->Say(msg, lang);
             else if (type == CHAT_MSG_EMOTE)
@@ -271,7 +287,15 @@ void WorldSession::HandleMessagechatOpcode(WorldPacket& recvData)
             Player* receiver = sObjectAccessor->FindPlayerByName(to);
             if (!receiver || (lang != LANG_ADDON && !receiver->isAcceptWhispers() && receiver->GetSession()->HasPermission(rbac::RBAC_PERM_CAN_FILTER_WHISPERS) && !receiver->IsInWhisperWhiteList(sender->GetGUID())))
             {
-                SendPlayerNotFoundNotice(to);
+                // If Fake WHO List system on then show player DND
+                if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+                {
+                    ChatHandler(sender->GetSession()).PSendSysMessage(LANG_FAKE_NOT_DISTURB);
+                }
+                else
+                {
+                    SendPlayerNotFoundNotice(to);
+                }
                 return;
             }
             if (!sender->IsGameMaster() && sender->getLevel() < sWorld->getIntConfig(CONFIG_CHAT_WHISPER_LEVEL_REQ) && !receiver->IsInWhisperWhiteList(sender->GetGUID()))
diff --git a/src/server/game/Handlers/GroupHandler.cpp b/src/server/game/Handlers/GroupHandler.cpp
index 5b35da2..62ee828 100644
--- a/src/server/game/Handlers/GroupHandler.cpp
+++ b/src/server/game/Handlers/GroupHandler.cpp
@@ -33,6 +33,9 @@
 #include "WorldPacket.h"
 #include "WorldSession.h"
 
+#include "Chat.h"
+#include "Language.h"
+
 class Aura;
 
 /* differeces from off:
@@ -79,7 +82,14 @@ void WorldSession::HandleGroupInviteOpcode(WorldPacket& recvData)
     // no player
     if (!player)
     {
-        SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
+        if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+        {
+           ChatHandler(_player->GetSession()).PSendSysMessage(LANG_FAKE_NOT_DISTURB);
+        }
+        else
+        {
+            SendPartyResult(PARTY_OP_INVITE, membername, ERR_BAD_PLAYER_NAME_S);
+        }
         return;
     }
 
diff --git a/src/server/game/Handlers/LootHandler.cpp b/src/server/game/Handlers/LootHandler.cpp
index 8bc9c5d..4da3961 100644
--- a/src/server/game/Handlers/LootHandler.cpp
+++ b/src/server/game/Handlers/LootHandler.cpp
@@ -30,6 +30,7 @@
 #include "World.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 void WorldSession::HandleAutostoreLootItemOpcode(WorldPacket& recvData)
 {
@@ -204,6 +205,16 @@ void WorldSession::HandleLootMoneyOpcode(WorldPacket& /*recvData*/)
             SendPacket(&data);
         }
 
+        //Guild-Level-System (Bonus: Gold)
+        if (Guild* guild = player->GetGuild())
+        {
+            //Extra Gold fuer die Gildenbank
+            if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_1))
+                guild->HandleMemberDepositMoney(this, uint32(loot->gold*0.05f));
+            if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_2))
+                guild->HandleMemberDepositMoney(this, uint32(loot->gold*0.1f));
+        }
+
         loot->gold = 0;
 
         // Delete the money loot record from the DB
diff --git a/src/server/game/Handlers/MiscHandler.cpp b/src/server/game/Handlers/MiscHandler.cpp
index b6c508e..02550bb 100644
--- a/src/server/game/Handlers/MiscHandler.cpp
+++ b/src/server/game/Handlers/MiscHandler.cpp
@@ -192,6 +192,9 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
     uint32 zoneids[10];                                     // 10 is client limit
     std::string player_name, guild_name;
 
+    bool searchBool = false;
+    std::string searchName;
+
     recvData >> level_min;                                 // maximal player level, default 0
     recvData >> level_max;                                 // minimal player level, default 100 (MAX_LEVEL)
     recvData >> player_name;                               // player name, case sensitive...
@@ -231,6 +234,9 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
 
         wstrToLower(str[i]);
 
+        searchBool = true;
+        searchName = temp.c_str();
+
         TC_LOG_DEBUG("network", "String %u: %s", i, temp.c_str());
     }
 
@@ -365,7 +371,45 @@ void WorldSession::HandleWhoOpcode(WorldPacket& recvData)
         ++displaycount;
     }
 
-    data.put(0, displaycount);                            // insert right count, count displayed
+    if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST) && displaycount < 49)
+    {
+        const char fake_players_db = (searchBool ? FAKE_CHAR_ONLINE_SEARCH : FAKE_CHAR_ONLINE);
+        PreparedStatement* fake = CharacterDatabase.GetPreparedStatement(fake_players_db);
+
+        fake->setUInt32(0, sWorld->getIntConfig(CONFIG_FAKE_WHO_ONLINE_INTERVAL));
+        if (searchBool)
+            fake->setString(1, searchName);
+
+        PreparedQueryResult fakeresult = CharacterDatabase.Query(fake);
+        if (fakeresult)
+        {
+            do
+            {
+                Field *fields = fakeresult->Fetch();
+
+                std::string pname = fields[0].GetString();  // player name
+                std::string gname;                          // guild name
+                uint32 lvl = fields[3].GetUInt32();         // player level
+                uint32 class_ = fields[2].GetUInt32();      // player class
+                uint32 race = fields[1].GetUInt32();        // player race
+                uint32 pzoneid = fields[4].GetUInt32();     // player zone id
+                uint8 gender = fields[5].GetUInt8();        // player gender
+
+                data << pname;                              // player name
+                data << gname;                              // guild name
+                data << uint32(lvl);                        // player level
+                data << uint32(class_);                     // player class
+                data << uint32(race);                       // player race
+                data << uint8(gender);                      // player gender
+                data << uint32(pzoneid);                    // player zone id
+
+                if ((++matchcount) == 49)
+                    break;
+            } while (fakeresult->NextRow());
+        }
+    }
+
+    data.put(0, matchcount);
     data.put(4, matchcount);                              // insert right count, count of matches
 
     SendPacket(&data);
@@ -549,6 +593,26 @@ void WorldSession::HandleAddFriendOpcode(WorldPacket& recvData)
     TC_LOG_DEBUG("network", "WORLD: %s asked to add friend : '%s'",
         GetPlayer()->GetName().c_str(), friendName.c_str());
 
+    if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+    {
+        PreparedStatement* fake = CharacterDatabase.GetPreparedStatement(FAKE_CHAR_SEL_RACE_BY_NAME);
+        fake->setString(0, friendName);
+        PreparedQueryResult fakeresult = CharacterDatabase.Query(fake);
+
+        if (fakeresult)
+        {
+            Field* fields = fakeresult->Fetch();
+            uint32 team = Player::TeamForRace(fields[0].GetUInt8());
+
+            if (GetPlayer()->GetTeam() != team && !HasPermission(rbac::RBAC_PERM_TWO_SIDE_ADD_FRIEND))
+                sSocialMgr->SendFriendStatus(_player, FRIEND_ENEMY, false, false);
+            else
+                ChatHandler(_player->GetSession()).PSendSysMessage(LANG_FAKE_NOT_DISTURB);
+
+            return;
+        }
+    }
+
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_RACE_ACC_BY_NAME);
 
     stmt->setString(0, friendName);
@@ -640,6 +704,20 @@ void WorldSession::HandleAddIgnoreOpcode(WorldPacket& recvData)
     TC_LOG_DEBUG("network", "WORLD: %s asked to Ignore: '%s'",
         GetPlayer()->GetName().c_str(), ignoreName.c_str());
 
+    if (sWorld->getBoolConfig(CONFIG_FAKE_WHO_LIST))
+    {
+        PreparedStatement* fake = CharacterDatabase.GetPreparedStatement(FAKE_CHAR_SEL_RACE_BY_NAME_IS_ONLINE);
+        fake->setUInt32(0, sWorld->getIntConfig(CONFIG_FAKE_WHO_ONLINE_INTERVAL));
+        fake->setString(1, ignoreName.c_str());
+        PreparedQueryResult fakeresult = CharacterDatabase.Query(fake);
+
+        if (fakeresult)
+        {
+            ChatHandler(_player->GetSession()).PSendSysMessage(LANG_FAKE_NOT_DISTURB);
+            return;
+        }
+    }
+
     PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUID_BY_NAME);
 
     stmt->setString(0, ignoreName);
@@ -1432,6 +1510,21 @@ void WorldSession::HandleSetTitleOpcode(WorldPacket& recvData)
 
 void WorldSession::HandleTimeSyncResp(WorldPacket& recvData)
 {
+    Battleground* bg = _player->GetBattleground();
+    if (bg)
+    {
+        if (_player->ShouldForgetBGPlayers() && bg)
+        {
+            _player->DoForgetPlayersInBG(bg);
+            _player->SetForgetBGPlayers(false);
+        }
+    }
+    else if (_player->ShouldForgetInListPlayers())
+    {
+        _player->DoForgetPlayersInList();
+        _player->SetForgetInListPlayers(false);
+    }
+
     TC_LOG_DEBUG("network", "CMSG_TIME_SYNC_RESP");
 
     uint32 counter, clientTicks;
diff --git a/src/server/game/Handlers/MovementHandler.cpp b/src/server/game/Handlers/MovementHandler.cpp
index 64d0ae3..f735828 100644
--- a/src/server/game/Handlers/MovementHandler.cpp
+++ b/src/server/game/Handlers/MovementHandler.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "WorldPacket.h"
 #include "WorldSession.h"
@@ -343,6 +344,9 @@ void WorldSession::HandleMovementOpcodes(WorldPacket& recvData)
         plrMover->SetInWater(!plrMover->IsInWater() || plrMover->GetBaseMap()->IsUnderWater(movementInfo.pos.GetPositionX(), movementInfo.pos.GetPositionY(), movementInfo.pos.GetPositionZ()));
     }
 
+    if (plrMover)
+        sAnticheatMgr->StartHackDetection(plrMover, movementInfo, opcode);
+
     uint32 mstime = getMSTime();
     /*----------------------*/
     if (m_clientTimeDelay == 0)
diff --git a/src/server/game/Handlers/QueryHandler.cpp b/src/server/game/Handlers/QueryHandler.cpp
index dbcfb1c..f3ff127 100644
--- a/src/server/game/Handlers/QueryHandler.cpp
+++ b/src/server/game/Handlers/QueryHandler.cpp
@@ -48,7 +48,7 @@ void WorldSession::SendNameQueryOpcode(uint64 guid)
     data << uint8(0);                               // name known
     data << nameData->m_name;                       // played name
     data << uint8(0);                               // realm name - only set for cross realm interaction (such as Battlegrounds)
-    data << uint8(nameData->m_race);
+    data << uint8(player ? player->getRace() : nameData->m_race);
     data << uint8(nameData->m_gender);
     data << uint8(nameData->m_class);
 
diff --git a/src/server/game/Handlers/SpellHandler.cpp b/src/server/game/Handlers/SpellHandler.cpp
index 9cce494..a8bc5a7 100644
--- a/src/server/game/Handlers/SpellHandler.cpp
+++ b/src/server/game/Handlers/SpellHandler.cpp
@@ -29,6 +29,7 @@
 #include "TemporarySummon.h"
 #include "SpellAuras.h"
 #include "CreatureAI.h"
+#include "../../scripts/Custom/Transmogrification.h"
 #include "ScriptMgr.h"
 #include "GameObjectAI.h"
 #include "SpellAuraEffects.h"
@@ -360,6 +361,9 @@ void WorldSession::HandleCastSpellOpcode(WorldPacket& recvPacket)
         return;
     }
 
+    if (sWorld->getBoolConfig(CONFIG_NO_COOLDOWN))
+        _player->RemoveSpellCooldown(spellId, true);
+
     // Client is resending autoshot cast opcode when other spell is cast during shoot rotation
     // Skip it to prevent "interrupt" message
     if (spellInfo->IsAutoRepeatRangedSpell() && caster->GetCurrentSpell(CURRENT_AUTOREPEAT_SPELL)
@@ -637,7 +641,12 @@ void WorldSession::HandleMirrorImageDataRequest(WorldPacket& recvData)
             else if (*itr == EQUIPMENT_SLOT_BACK && player->HasFlag(PLAYER_FLAGS, PLAYER_FLAGS_HIDE_CLOAK))
                 data << uint32(0);
             else if (Item const* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, *itr))
-                data << uint32(item->GetTemplate()->DisplayInfoID);
+            {
+                if (uint32 entry = sTransmogrification->GetFakeEntry(item))
+                    data << uint32(sObjectMgr->GetItemTemplate(entry)->DisplayInfoID);
+                else
+                    data << uint32(item->GetTemplate()->DisplayInfoID);
+            }
             else
                 data << uint32(0);
         }
diff --git a/src/server/game/Mails/Mail.cpp b/src/server/game/Mails/Mail.cpp
index 2c65e36..b204180 100644
--- a/src/server/game/Mails/Mail.cpp
+++ b/src/server/game/Mails/Mail.cpp
@@ -20,6 +20,7 @@
 #include "Mail.h"
 #include "Log.h"
 #include "World.h"
+#include "WorldSession.h"
 #include "ObjectMgr.h"
 #include "Player.h"
 #include "Unit.h"
@@ -281,3 +282,64 @@ void MailDraft::SendMailTo(SQLTransaction& trans, MailReceiver const& receiver,
         deleteIncludedItems(temp);
     }
 }
+
+void WorldSession::SendExternalMails()
+{
+    TC_LOG_DEBUG("entities.player.character", "External Mail> Sending mails in queue...");
+
+    PreparedStatement* stmt = CharacterDatabase.GetPreparedStatement(CHAR_GET_EXTERNAL_MAIL);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+    if (!result)
+    {
+        TC_LOG_DEBUG("entities.player.character", "External Mail> No mails in queue...");
+        return;
+    }
+
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+
+    MailDraft* mail = NULL;
+
+    do
+    {
+        Field *fields = result->Fetch();
+        uint32 id = fields[0].GetUInt32();
+        uint32 receiver_guid = fields[1].GetUInt32();
+        std::string subject = fields[2].GetString();
+        std::string body = fields[3].GetString();
+        uint32 money = fields[4].GetUInt32();
+        uint32 itemId = fields[5].GetUInt32();
+        uint32 itemCount = fields[6].GetUInt32();
+
+        Player *receiver = ObjectAccessor::FindPlayer(receiver_guid);
+
+        mail = new MailDraft(subject, body);
+
+        if (money)
+        {
+            TC_LOG_DEBUG("entities.player.character", "External Mail> Adding money");
+            mail->AddMoney(money);
+        }
+
+        if (itemId)
+        {
+             TC_LOG_DEBUG("entities.player.character", "External Mail> Adding %u of item with id %u", itemCount, itemId);
+             if(Item* mailItem = Item::CreateItem(itemId, itemCount))
+             {
+                 mailItem->SaveToDB(trans);
+                 mail->AddItem(mailItem);
+             }
+        }
+
+        mail->SendMailTo(trans, receiver ? receiver : MailReceiver(receiver_guid), MailSender(MAIL_NORMAL, 0, MAIL_STATIONERY_GM), MAIL_CHECK_MASK_RETURNED);
+        delete mail;
+
+        stmt = CharacterDatabase.GetPreparedStatement(CHAR_DEL_EXTERNAL_MAIL);
+        stmt->setUInt32(0, id);
+        trans->Append(stmt);
+
+        TC_LOG_DEBUG("entities.player.character", "External Mail> Mail sent");
+   } while (result->NextRow());
+
+   CharacterDatabase.CommitTransaction(trans);
+   TC_LOG_DEBUG("entities.player.character", "External Mail> All Mails Sent...");
+}
\ No newline at end of file
diff --git a/src/server/game/Miscellaneous/Formulas.h b/src/server/game/Miscellaneous/Formulas.h
index e6ff1a0..2312931 100644
--- a/src/server/game/Miscellaneous/Formulas.h
+++ b/src/server/game/Miscellaneous/Formulas.h
@@ -19,10 +19,13 @@
 #ifndef TRINITY_FORMULAS_H
 #define TRINITY_FORMULAS_H
 
+#include "Guild.h"
 #include "World.h"
 #include "SharedDefines.h"
 #include "ScriptMgr.h"
 #include "Player.h"
+#include "Config.h"
+
 
 namespace Trinity
 {
@@ -183,9 +186,46 @@ namespace Trinity
 
                     xpMod *= creature->GetCreatureTemplate()->ModExperience;
                 }
-
+            if(sConfigMgr->GetBoolDefault("PrepatchGI.Added", false))
+                {
+                    // Prepatch by LordPsyan
+                //Guild-Level-System (Bonus: MonsterKillXp)
+                if (Guild* guild = player->GetGuild())
+                {
+                    //GildenXP-Bonus
+                    if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+                        gain += uint32(gain*0.05f);
+                    if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+                        gain += uint32(gain*0.1f);
+                }
+                    // 02
+                    // 03
+                    // 04
+                //Individuale_XP-Rate
+                float individualXpKill = player->GetIndividualXpKillRate();
+                gain = uint32(gain * (individualXpKill > 0 ? individualXpKill : sWorld->getRate(RATE_XP_KILL)));
+                    // 06
+                    // 07
+                    // 08
+                    // 09
+                    // 10
+                    // 11
+                    // 12
+                    // 13
+                    // 14
+                    // 15
+                    // 16
+                    // 17
+                    // 18
+                    // 19
+                    // 20
+                    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+                    //
+                    // End of prepatch
+                } else {
                 xpMod *= sWorld->getRate(RATE_XP_KILL);
                 gain = uint32(gain * xpMod);
+                }
             }
 
             sScriptMgr->OnGainCalculation(gain, player, u);
diff --git a/src/server/game/Miscellaneous/Language.h b/src/server/game/Miscellaneous/Language.h
index c1de3aa..dcc7217 100644
--- a/src/server/game/Miscellaneous/Language.h
+++ b/src/server/game/Miscellaneous/Language.h
@@ -796,7 +796,18 @@ enum TrinityStrings
     LANG_NPCINFO_SPELLCLICK             = 840,
     LANG_NPCINFO_MAILBOX                = 841,
     LANG_NPCINFO_PLAYER_VEHICLE         = 842,
-
+// Start AIO by LordPsyan
+    LANG_SOTA                           = 990,
+    LANG_AV                             = 991,
+    LANG_ARENA_3                        = 992,
+    LANG_ARENA_2                        = 993,
+    LANG_ARENA_1                        = 994,
+    LANG_RANDOM                         = 995,
+    LANG_EOTS                           = 996,
+    LANG_AB                             = 997,
+    LANG_WSG                            = 998,
+    LANG_WG                             = 999,
+// End AIO
     // Pinfo commands
     LANG_PINFO_PLAYER                   = 453,
     LANG_PINFO_GM_ACTIVE                = 548,
@@ -1178,6 +1189,8 @@ enum TrinityStrings
     LANG_AUTO_BROADCAST                 = 11000,
     LANG_INVALID_REALMID                = 11001,
 
+    LANG_FAKE_NOT_DISTURB    = 12001,
+
     // Show Kick in world
     LANG_COMMAND_KICKMESSAGE_WORLD = 11002,
 
@@ -1191,7 +1204,38 @@ enum TrinityStrings
     LANG_BAN_ACCOUNT_YOUPERMBANNEDMESSAGE_WORLD   = 11007,
 
     LANG_NPCINFO_INHABIT_TYPE                     = 11008,
-    LANG_NPCINFO_FLAGS_EXTRA                      = 11009
+    LANG_NPCINFO_FLAGS_EXTRA                      = 11009,
+    // Prepatch by LordPsyan
+    //Guild-Level-System
+    LANG_GUILDINFO_LEVEL                          = 13000,
+    LANG_GUILDINFO_XP_INFO                        = 13001,
+    // 02
+    // 03
+    // 04
+    //Individuale_XP-Rate
+    LANG_INDIVIDUAL_KILLRATE_SET                  = 15000,
+    LANG_INDIVIDUAL_QUESTRATE_SET                 = 15001,
+    LANG_INDIVIDUAL_RATE_TO_HIGH                  = 15002,
+    LANG_INDIVIDUAL_RATE_TO_LOW                   = 15003,
+    LANG_INDIVIDUAL_RATES_INFO                    = 15004,
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
 
     // NOT RESERVED IDS                   12000-1999999999
     // `db_script_string` table index     2000000000-2000009999 (MIN_DB_SCRIPT_STRING_ID-MAX_DB_SCRIPT_STRING_ID)
diff --git a/src/server/game/Reputation/ReputationMgr.cpp b/src/server/game/Reputation/ReputationMgr.cpp
index f19d6d7..5690f3e 100644
--- a/src/server/game/Reputation/ReputationMgr.cpp
+++ b/src/server/game/Reputation/ReputationMgr.cpp
@@ -25,6 +25,7 @@
 #include "ObjectMgr.h"
 #include "ScriptMgr.h"
 #include "WorldSession.h"
+#include "Guild.h"
 
 const int32 ReputationMgr::PointsInRank[MAX_REPUTATION_RANK] = {36000, 3000, 3000, 3000, 6000, 12000, 21000, 1000};
 
@@ -367,6 +368,15 @@ bool ReputationMgr::SetOneFactionReputation(FactionEntry const* factionEntry, in
             standing += itr->second.Standing + BaseRep;
         }
 
+        //Guild-Level-System (Bonus: Ruf)
+        if (Guild* guild = _player->GetGuild())
+        {
+            if (guild->HasLevelForBonus(GUILD_BONUS_RUF_1))
+                standing += uint32(standing*0.05f);
+            if (guild->HasLevelForBonus(GUILD_BONUS_RUF_2))
+                standing += uint32(standing*0.1f);
+        }
+
         if (standing > Reputation_Cap)
             standing = Reputation_Cap;
         else if (standing < Reputation_Bottom)
diff --git a/src/server/game/Scripting/ScriptLoader.cpp b/src/server/game/Scripting/ScriptLoader.cpp
index ed6c543..478774e 100644
--- a/src/server/game/Scripting/ScriptLoader.cpp
+++ b/src/server/game/Scripting/ScriptLoader.cpp
@@ -17,6 +17,7 @@
 
 #include "ScriptLoader.h"
 #include "World.h"
+#include "AnticheatMgr.h"
 
 //examples
 void AddSC_example_creature();
@@ -45,6 +46,7 @@ void AddSC_holiday_spell_scripts();
 void AddSC_SmartScripts();
 
 //Commands
+void AddSC_anticheat_commandscript();
 void AddSC_account_commandscript();
 void AddSC_achievement_commandscript();
 void AddSC_ahbot_commandscript();
@@ -695,7 +697,6 @@ void AddSC_outdoorpvp_zm();
 // player
 void AddSC_chat_log();
 void AddSC_action_ip_logger();
-
 #endif
 
 void AddScripts()
@@ -704,6 +705,7 @@ void AddScripts()
     AddSpellScripts();
     AddSC_SmartScripts();
     AddCommandScripts();
+    sAnticheatMgr->StartScripts();
 #ifdef SCRIPTS
     AddWorldScripts();
     AddEasternKingdomsScripts();
@@ -748,6 +750,7 @@ void AddSpellScripts()
 
 void AddCommandScripts()
 {
+    AddSC_anticheat_commandscript();
     AddSC_account_commandscript();
     AddSC_achievement_commandscript();
     AddSC_ahbot_commandscript();
@@ -1434,13 +1437,203 @@ void AddBattlegroundScripts()
 
 #ifdef SCRIPTS
 /* This is where custom scripts' loading functions should be declared. */
-
+// All In One NPC
+void AddSC_npc_all();
+// start02
+// start03
+// start04
+// Arena Gambler
+void AddSC_ArenaGambler();
+// start06
+// start07
+// start08
+// Beastmaster
+void AddSC_Npc_Beastmaster();
+// start10
+// start11
+// start12
+// Bounty Hunter
+void AddSC_BountyHunter();
+// start14
+// start15
+// start16
+    //GuildHouse NPC
+    void AddSC_guildmaster();
+// start18
+// start19
+// start20
+// Killstreak
+void AddSC_PvP_System();
+// start22
+// start23
+// start24
+// Level NPC
+void AddSC_levelnpc();
+// start26
+// start27
+// start28
+// start29
+// start30
+// start31
+// start32
+// Buff NPC
+void AddSC_Npc_Buff();
+// start34
+// start35
+// start36
+// Enchant NPC
+void AddSC_npc_enchantment();
+// start38
+// start39
+// start40
+// Events
+void AddSC_LevelEvents();
+// start42
+// start43
+// start44
+// Profession Npc
+void AddSC_professionnpc();
+// start46
+// start47
+// start48
+// IceRune
+void AddSC_summon();
+// start50
+// start51
+// start52
+// TeleNPC2
+void AddSC_npc_teleport();
+// start54
+// start55
+// start56
+// Transmogrification
+void AddSC_PWS_Transmogrification();
+void AddSC_CS_Transmogrification();
+// start58
+// start59
+// start60
+// start61
+// start62
+// start63
+// start64
+// start65
+// start66
+// start67
+// start68
+// start69
+// start70
+// start71
+// start72
+// start73
+// start74
+// start75
+// start76
+// start77
+// Reforging
+void AddSC_REFORGER_NPC();
+// start79
+// start80
 #endif
 
 void AddCustomScripts()
 {
 #ifdef SCRIPTS
     /* This is where custom scripts should be added. */
-
+    // All In One NPC
+    AddSC_npc_all();
+// end02
+// end03
+// end04
+    // Arena Gambler
+    AddSC_ArenaGambler();
+// end06
+// end07
+// end08
+    // Beastmaster
+    AddSC_Npc_Beastmaster();
+// end10
+// end11
+// end12
+    // Bounty Hunter
+    AddSC_BountyHunter();
+// end14
+// end15
+// end16
+    // GuildHouse NPC
+    AddSC_guildmaster();
+// end18
+// end19
+// end20
+    // Killstreak
+    AddSC_PvP_System();
+// end22
+// end23
+// end24
+    // Level NPC
+    AddSC_levelnpc();
+// end26
+// end27
+// end28
+// end29
+// end30
+// end31
+// end32
+    // Buff NPC
+    AddSC_Npc_Buff();
+// end34
+// end35
+// end36
+    // Enchant NPC
+    AddSC_npc_enchantment();
+// end38
+// end39
+// end40
+    // Events
+    AddSC_LevelEvents();
+// end42
+// end43
+// end44
+    // Profession Npc
+    AddSC_professionnpc();
+// end46
+// end47
+// end48
+    // IceRune
+    AddSC_summon();
+// end50
+// end51
+// end52
+    // TeleNPC2
+    AddSC_npc_teleport();
+// end54
+// end55
+// end56
+    // Transmogrification
+    AddSC_PWS_Transmogrification();
+    AddSC_CS_Transmogrification();
+// end58
+// end59
+// end60
+// end61
+// end62
+// end63
+// end64
+// end65
+// end66
+// end67
+// end68
+// end69
+// end70
+// end71
+// end72
+// end73
+// end74
+// end75
+// end76
+// end77
+    // Reforging
+    AddSC_REFORGER_NPC();
+// end79
+// end80
 #endif
 }
diff --git a/src/server/game/Scripting/ScriptMgr.cpp b/src/server/game/Scripting/ScriptMgr.cpp
index d13c81e..2ed9512 100644
--- a/src/server/game/Scripting/ScriptMgr.cpp
+++ b/src/server/game/Scripting/ScriptMgr.cpp
@@ -23,6 +23,7 @@
 #include "ObjectMgr.h"
 #include "OutdoorPvPMgr.h"
 #include "ScriptLoader.h"
+#include "sc_npc_teleport.h"
 #include "ScriptSystem.h"
 #include "Transport.h"
 #include "Vehicle.h"
@@ -188,6 +189,8 @@ void ScriptMgr::Initialize()
     uint32 oldMSTime = getMSTime();
 
     LoadDatabase();
+       // Load TeleNPC2 - maybe not the best place to load it ...
+       LoadNpcTele();
 
     TC_LOG_INFO("server.loading", "Loading C++ scripts");
 
diff --git a/src/server/game/Server/WorldSession.h b/src/server/game/Server/WorldSession.h
index 2e6a699..bd142a7 100644
--- a/src/server/game/Server/WorldSession.h
+++ b/src/server/game/Server/WorldSession.h
@@ -334,6 +334,7 @@ class WorldSession
             }
         }
         //used with item_page table
+        static void SendExternalMails();
         bool SendItemInfo(uint32 itemid, WorldPacket data);
         //auction
         void SendAuctionHello(uint64 guid, Creature* unit);
diff --git a/src/server/game/Spells/Spell.cpp b/src/server/game/Spells/Spell.cpp
index bb68010..eb35fd5 100644
--- a/src/server/game/Spells/Spell.cpp
+++ b/src/server/game/Spells/Spell.cpp
@@ -2967,6 +2967,9 @@ void Spell::prepare(SpellCastTargets const* targets, AuraEffect const* triggered
         if (!m_casttime && !m_spellInfo->StartRecoveryTime && !m_castItemGUID && GetCurrentContainer() == CURRENT_GENERIC_SPELL)
             cast(true);
     }
+        if (sWorld->getBoolConfig(CONFIG_NO_COOLDOWN))
+            if (m_caster->GetTypeId() == TYPEID_PLAYER)
+                ((Player*)m_caster)->RemoveSpellCooldown(m_spellInfo->Id, true);
 }
 
 void Spell::cancel()
@@ -4633,7 +4636,7 @@ SpellCastResult Spell::CheckCast(bool strict)
         {
             if (m_triggeredByAuraSpell)
                 return SPELL_FAILED_DONT_REPORT;
-            else
+            else if (!sWorld->getBoolConfig(CONFIG_NO_COOLDOWN))
                 return SPELL_FAILED_NOT_READY;
         }
 
@@ -4649,8 +4652,9 @@ SpellCastResult Spell::CheckCast(bool strict)
     }
 
     // Check global cooldown
-    if (strict && !(_triggeredCastFlags & TRIGGERED_IGNORE_GCD) && HasGlobalCooldown())
-        return SPELL_FAILED_NOT_READY;
+    if (!sWorld->getBoolConfig(CONFIG_NO_COOLDOWN))
+        if (strict && !(_triggeredCastFlags & TRIGGERED_IGNORE_GCD) && HasGlobalCooldown())
+            return SPELL_FAILED_NOT_READY;
 
     // only triggered spells can be processed an ended battleground
     if (!IsTriggered() && m_caster->GetTypeId() == TYPEID_PLAYER)
diff --git a/src/server/game/Spells/SpellEffects.cpp b/src/server/game/Spells/SpellEffects.cpp
index 00b7873..4dc96a7 100644
--- a/src/server/game/Spells/SpellEffects.cpp
+++ b/src/server/game/Spells/SpellEffects.cpp
@@ -16,6 +16,7 @@
  * with this program. If not, see <http://www.gnu.org/licenses/>.
  */
 
+#include "AnticheatMgr.h"
 #include "Common.h"
 #include "DatabaseEnv.h"
 #include "WorldPacket.h"
@@ -5164,6 +5165,9 @@ void Spell::EffectTransmitted(SpellEffIndex effIndex)
                 case 3: lastSec = 17; break;
             }
 
+            if (sWorld->getBoolConfig(CONFIG_FAST_FISHING))
+                lastSec = 17;
+
             duration = duration - lastSec*IN_MILLISECONDS + FISHING_BOBBER_READY_TIME*IN_MILLISECONDS;
             break;
         }
diff --git a/src/server/game/Spells/SpellInfo.cpp b/src/server/game/Spells/SpellInfo.cpp
index 5ef6acb..a35edfa 100644
--- a/src/server/game/Spells/SpellInfo.cpp
+++ b/src/server/game/Spells/SpellInfo.cpp
@@ -25,6 +25,7 @@
 #include "Battleground.h"
 #include "Vehicle.h"
 #include "Pet.h"
+#include "World.h"
 
 uint32 GetTargetFlagMask(SpellTargetObjectTypes objType)
 {
@@ -2104,7 +2105,10 @@ uint32 SpellInfo::CalcCastTime(Spell* spell /*= NULL*/) const
     if (Attributes & SPELL_ATTR0_REQ_AMMO && (!IsAutoRepeatRangedSpell()))
         castTime += 500;
 
-    return (castTime > 0) ? uint32(castTime) : 0;
+    if (!sWorld->getBoolConfig(CONFIG_NO_CAST_TIME))
+        return (castTime > 0) ? uint32(castTime) : 0;
+    else
+        return 0;
 }
 
 uint32 SpellInfo::GetMaxTicks() const
diff --git a/src/server/game/World/World.cpp b/src/server/game/World/World.cpp
index 58e3cff..227c3d4 100644
--- a/src/server/game/World/World.cpp
+++ b/src/server/game/World/World.cpp
@@ -27,6 +27,7 @@
 #include "AuctionHouseMgr.h"
 #include "BattlefieldMgr.h"
 #include "BattlegroundMgr.h"
+#include "AnticheatMgr.h"
 #include "CalendarMgr.h"
 #include "Channel.h"
 #include "CharacterDatabaseCleaner.h"
@@ -671,6 +672,10 @@ void World::LoadConfigSettings(bool reload)
     m_int_configs[CONFIG_STRICT_CHARTER_NAMES]                = sConfigMgr->GetIntDefault ("StrictCharterNames", 0);
     m_int_configs[CONFIG_STRICT_PET_NAMES]                    = sConfigMgr->GetIntDefault ("StrictPetNames",     0);
 
+    m_bool_configs[CONFIG_FAKE_WHO_LIST]                      = sConfigMgr->GetBoolDefault("Fake.WHO.List", false);
+    m_int_configs[CONFIG_FAKE_WHO_ONLINE_INTERVAL]            = sConfigMgr->GetIntDefault("Fake.WHO.Online.Interval", 5);
+    m_int_configs[CONFIG_FAKE_WHO_LEVELUP_INTERVAL]           = sConfigMgr->GetIntDefault("Fake.WHO.LevelUp.Interval", 2);
+
     m_int_configs[CONFIG_MIN_PLAYER_NAME]                     = sConfigMgr->GetIntDefault ("MinPlayerName",  2);
     if (m_int_configs[CONFIG_MIN_PLAYER_NAME] < 1 || m_int_configs[CONFIG_MIN_PLAYER_NAME] > MAX_PLAYER_NAME)
     {
@@ -851,6 +856,18 @@ void World::LoadConfigSettings(bool reload)
         TC_LOG_ERROR("server.loading", "MinPetitionSigns (%i) must be in range 0..9. Set to 9.", m_int_configs[CONFIG_MIN_PETITION_SIGNS]);
         m_int_configs[CONFIG_MIN_PETITION_SIGNS] = 9;
     }
+    rate_values[RATE_PVP_RANK_EXTRA_HONOR] = sConfigMgr->GetFloatDefault("PvPRank.Rate.ExtraHonor", 1);
+    std::string s_pvp_ranks = sConfigMgr->GetStringDefault("PvPRank.HKPerRank", "10,50,100,200,450,750,1300,2000,3500,6000,9500,15000,21000,30000");
+    char *c_pvp_ranks = const_cast<char*>(s_pvp_ranks.c_str());
+    for (int i = 0; i !=HKRANKMAX; i++)
+    {
+        if (i==0)
+            pvp_ranks[0] = 0;
+        else if (i==1)
+            pvp_ranks[1] = atoi(strtok (c_pvp_ranks, ","));
+        else
+            pvp_ranks[i] = atoi(strtok (NULL, ","));
+    }
 
     m_int_configs[CONFIG_GM_LOGIN_STATE]        = sConfigMgr->GetIntDefault("GM.LoginState", 2);
     m_int_configs[CONFIG_GM_VISIBLE_STATE]      = sConfigMgr->GetIntDefault("GM.Visible", 2);
@@ -1046,6 +1063,8 @@ void World::LoadConfigSettings(bool reload)
 
     m_int_configs[CONFIG_CREATURE_PICKPOCKET_REFILL] = sConfigMgr->GetIntDefault("Creature.PickPocketRefillDelay", 10 * MINUTE);
 
+    m_bool_configs[BATTLEGROUND_CROSSFACTION_ENABLED]                = sConfigMgr->GetBoolDefault("CrossfactionBG.enable", true);
+
     if (int32 clientCacheId = sConfigMgr->GetIntDefault("ClientCacheVersion", 0))
     {
         // overwrite DB/old value
@@ -1107,7 +1126,35 @@ void World::LoadConfigSettings(bool reload)
     m_visibility_notify_periodOnContinents = sConfigMgr->GetIntDefault("Visibility.Notify.Period.OnContinents", DEFAULT_VISIBILITY_NOTIFY_PERIOD);
     m_visibility_notify_periodInInstances = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InInstances",   DEFAULT_VISIBILITY_NOTIFY_PERIOD);
     m_visibility_notify_periodInBGArenas = sConfigMgr->GetIntDefault("Visibility.Notify.Period.InBGArenas",    DEFAULT_VISIBILITY_NOTIFY_PERIOD);
-
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    m_float_configs[CONFIG_SPEED_GAME] = sConfigMgr->GetFloatDefault("Custom.SpeedGame", 1.0f);
+    m_bool_configs[CONFIG_NO_CAST_TIME] = sConfigMgr->GetBoolDefault("Custom.NoCastTime", false);
+    m_bool_configs[CONFIG_NO_COOLDOWN] = sConfigMgr->GetBoolDefault("Custom.NoCooldown", false);
+    m_bool_configs[CONFIG_HURT_IN_REAL_TIME] = sConfigMgr->GetBoolDefault("Custom.HurtInRealTime", false);
+    // 04
+    // 05
+    // 06
+    m_bool_configs[CONFIG_FAST_FISHING] = sConfigMgr->GetBoolDefault("Custom.FastFishing", false);
+    // 08
+    // 09
+    // 10
+    m_bool_configs[CONFIG_GAIN_HONOR_GUARD] = sConfigMgr->GetBoolDefault("Custom.GainHonorOnGuardKill", false);
+    m_bool_configs[CONFIG_GAIN_HONOR_ELITE] = sConfigMgr->GetBoolDefault("Custom.GainHonorOnEliteKill", false);
+    // 12
+    // 13
+    // 14
+    m_float_configs[CONFIG_ATTACKSPEED_PLAYER] = sConfigMgr->GetFloatDefault("Custom.AttackSpeedForPlayer", 1.0f);
+    m_float_configs[CONFIG_ATTACKSPEED_ALL] = sConfigMgr->GetFloatDefault("Custom.AttackSpeedForMobs", 1.0f);
+    // 16
+    // 17
+    // 18
+    // 19
+    m_float_configs[CONFIG_RESPAWNSPEED] = sConfigMgr->GetFloatDefault("Custom.RespawnSpeed", 1.0f);
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     ///- Load the CharDelete related config options
     m_int_configs[CONFIG_CHARDELETE_METHOD] = sConfigMgr->GetIntDefault("CharDelete.Method", 0);
     m_int_configs[CONFIG_CHARDELETE_MIN_LEVEL] = sConfigMgr->GetIntDefault("CharDelete.MinLevel", 0);
@@ -1225,11 +1272,20 @@ void World::LoadConfigSettings(bool reload)
     // MySQL ping time interval
     m_int_configs[CONFIG_DB_PING_INTERVAL] = sConfigMgr->GetIntDefault("MaxPingTime", 30);
 
+     // External Mail
+    m_bool_configs[CONFIG_EXTERNAL_MAIL_ENABLE] = sConfigMgr->GetBoolDefault("External.Mail.Enable", false);
+    m_int_configs[CONFIG_EXTERNAL_MAIL_INTERVAL] = sConfigMgr->GetIntDefault("External.Mail.Interval", 1);
+
     // misc
     m_bool_configs[CONFIG_PDUMP_NO_PATHS] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowPaths", true);
     m_bool_configs[CONFIG_PDUMP_NO_OVERWRITE] = sConfigMgr->GetBoolDefault("PlayerDump.DisallowOverwrite", true);
     m_bool_configs[CONFIG_UI_QUESTLEVELS_IN_DIALOGS] = sConfigMgr->GetBoolDefault("UI.ShowQuestLevelsInDialogs", false);
 
+    m_bool_configs[CONFIG_ANTICHEAT_ENABLE] = sConfigMgr->GetBoolDefault("Anticheat.Enable", true);
+    m_int_configs[CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION] = sConfigMgr->GetIntDefault("Anticheat.ReportsForIngameWarnings", 70);
+    m_int_configs[CONFIG_ANTICHEAT_DETECTIONS_ENABLED] = sConfigMgr->GetIntDefault("Anticheat.DetectionsEnabled",31);
+    m_int_configs[CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT] = sConfigMgr->GetIntDefault("Anticheat.MaxReportsForDailyReport",70);
+
     // Wintergrasp battlefield
     m_bool_configs[CONFIG_WINTERGRASP_ENABLE] = sConfigMgr->GetBoolDefault("Wintergrasp.Enable", false);
     m_int_configs[CONFIG_WINTERGRASP_PLR_MAX] = sConfigMgr->GetIntDefault("Wintergrasp.PlayerMax", 100);
@@ -1261,6 +1317,9 @@ void World::LoadConfigSettings(bool reload)
     // AHBot
     m_int_configs[CONFIG_AHBOT_UPDATE_INTERVAL] = sConfigMgr->GetIntDefault("AuctionHouseBot.Update.Interval", 20);
 
+    //Guild-Level-System
+    LoadGuildBonusInfo();
+
     // call ScriptMgr if we're reloading the configuration
     if (reload)
         sScriptMgr->OnConfigLoad(reload);
@@ -1758,7 +1817,9 @@ void World::SetInitialWorldSettings()
     tm localTm;
     localtime_r(&m_gameTime, &localTm);
     mail_timer = ((((localTm.tm_hour + 20) % 24)* HOUR * IN_MILLISECONDS) / m_timers[WUPDATE_AUCTIONS].GetInterval());
-                                                            //1440
+
+    extmail_timer.SetInterval(m_int_configs[CONFIG_EXTERNAL_MAIL_INTERVAL] * MINUTE * IN_MILLISECONDS);
+
     mail_timer_expires = ((DAY * IN_MILLISECONDS) / (m_timers[WUPDATE_AUCTIONS].GetInterval()));
     TC_LOG_INFO("server.loading", "Mail timer set to: " UI64FMTD ", mail return is called every " UI64FMTD " minutes", uint64(mail_timer), uint64(mail_timer_expires));
 
@@ -1994,6 +2055,17 @@ void World::Update(uint32 diff)
     if (m_gameTime > m_NextGuildReset)
         ResetGuildCap();
 
+     // Handle external mail
+    if (sWorld->getBoolConfig(CONFIG_EXTERNAL_MAIL_ENABLE))
+    {
+        extmail_timer.Update(diff);
+        if (extmail_timer.Passed())
+        {
+            WorldSession::SendExternalMails();
+            extmail_timer.Reset();
+        }
+    }
+
     /// <ul><li> Handle auctions when the timer has passed
     if (m_timers[WUPDATE_AUCTIONS].Passed())
     {
@@ -2891,6 +2963,8 @@ void World::ResetDailyQuests()
 
     // change available dailies
     sPoolMgr->ChangeDailyQuests();
+
+    sAnticheatMgr->ResetDailyReportStates();
 }
 
 void World::LoadDBAllowedSecurityLevel()
@@ -3220,3 +3294,87 @@ void World::ReloadRBAC()
         if (WorldSession* session = itr->second)
             session->InvalidateRBACData();
 }
+
+//Guild-Level-System [Start]
+void World::LoadGuildBonusInfo()
+{
+    //Moechte keinen riesigen Abschnitt in die Worldconf hinzufuegen, deswegen
+    //soll das ganze ueber eine Tabelle in der CharDB geregelt werden.
+    //Hier werden die benoetigten Daten geladen.
+    m_req_guildLevel_gold_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_GOLD_1);
+    m_req_guildLevel_xp_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_XP_1);
+    m_req_guildLevel_schneller_geist = SelectReqGuildLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST);
+    m_req_guildLevel_reperatur_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_1);
+    m_req_guildLevel_gold_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_GOLD_2);
+    m_req_guildLevel_reittempo_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_1);
+    m_req_guildLevel_reputation_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_RUF_1);
+    m_req_guildLevel_xp_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_XP_2);
+    m_req_guildLevel_reperatur_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_REPERATUR_2);
+    m_req_guildLevel_reittempo_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_REITTEMPO_2);
+    m_req_guildLevel_reputation_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_RUF_2);
+    m_req_guildLevel_honor_1 = SelectReqGuildLevelForBonus(GUILD_BONUS_EHRE_1);
+    m_req_guildLevel_honor_2 = SelectReqGuildLevelForBonus(GUILD_BONUS_EHRE_2);
+}
+
+uint8 World::SelectReqGuildLevelForBonus(uint8 guildBonus)
+{
+    PreparedStatement* stmt;
+    stmt = CharacterDatabase.GetPreparedStatement(CHAR_SEL_GUILD_BONUS_INFO);
+    stmt->setUInt8(0, guildBonus);
+    PreparedQueryResult result = CharacterDatabase.Query(stmt);
+
+    if (result)
+        return (*result)[0].GetUInt8();
+    else
+        return 0;
+}
+
+uint8 World::GetReqGuildLevelForBonus(uint8 guildBonus)
+{
+    switch (guildBonus)
+    {
+    case GUILD_BONUS_GOLD_1:
+        return m_req_guildLevel_gold_1;
+        break;
+    case GUILD_BONUS_GOLD_2:
+        return m_req_guildLevel_gold_2;
+        break;
+    case GUILD_BONUS_EHRE_1:
+        return m_req_guildLevel_honor_1;
+        break;
+    case GUILD_BONUS_EHRE_2:
+        return m_req_guildLevel_honor_2;
+        break;
+    case GUILD_BONUS_REITTEMPO_1:
+        return m_req_guildLevel_reittempo_1;
+        break;
+    case GUILD_BONUS_REITTEMPO_2:
+        return m_req_guildLevel_reittempo_2;
+        break;
+    case GUILD_BONUS_REPERATUR_1:
+        return m_req_guildLevel_reperatur_1;
+        break;
+    case GUILD_BONUS_REPERATUR_2:
+        return m_req_guildLevel_reperatur_2;
+        break;
+    case GUILD_BONUS_RUF_1:
+        return m_req_guildLevel_reputation_1;
+        break;
+    case GUILD_BONUS_RUF_2:
+        return m_req_guildLevel_reputation_2;
+        break;
+    case GUILD_BONUS_SCHNELLER_GEIST:
+        return m_req_guildLevel_schneller_geist;
+        break;
+    case GUILD_BONUS_XP_1:
+        return m_req_guildLevel_xp_1;
+        break;
+    case GUILD_BONUS_XP_2:
+        return m_req_guildLevel_xp_2;
+        break;
+    default:
+        return 0;
+        break;
+    }
+}
+//Guild-Level-System [End]
diff --git a/src/server/game/World/World.h b/src/server/game/World/World.h
index cc2078b..c3ddf46 100644
--- a/src/server/game/World/World.h
+++ b/src/server/game/World/World.h
@@ -85,6 +85,7 @@ enum WorldTimers
 enum WorldBoolConfigs
 {
     CONFIG_DURABILITY_LOSS_IN_PVP = 0,
+    BATTLEGROUND_CROSSFACTION_ENABLED,
     CONFIG_ADDON_CHANNEL,
     CONFIG_ALLOW_PLAYER_COMMANDS,
     CONFIG_CLEAN_CHARACTER_DB,
@@ -144,6 +145,7 @@ enum WorldBoolConfigs
     CONFIG_ALLOW_TICKETS,
     CONFIG_DBC_ENFORCE_ITEM_ATTRIBUTES,
     CONFIG_PRESERVE_CUSTOM_CHANNELS,
+    CONFIG_ANTICHEAT_ENABLE,
     CONFIG_PDUMP_NO_PATHS,
     CONFIG_PDUMP_NO_OVERWRITE,
     CONFIG_QUEST_IGNORE_AUTO_ACCEPT,
@@ -156,6 +158,33 @@ enum WorldBoolConfigs
     CONFIG_STATS_LIMITS_ENABLE,
     CONFIG_INSTANCES_RESET_ANNOUNCE,
     CONFIG_IP_BASED_ACTION_LOGGING,
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    CONFIG_NO_CAST_TIME,
+    CONFIG_NO_COOLDOWN,
+    CONFIG_HURT_IN_REAL_TIME,
+    // 04
+    // 05
+    // 06
+    CONFIG_FAST_FISHING,
+    // 08
+    // 09
+    // 10
+    CONFIG_GAIN_HONOR_GUARD,
+    CONFIG_GAIN_HONOR_ELITE,
+    // 12
+    // 13
+    // 14
+    CONFIG_FAKE_WHO_LIST,
+    // 16
+    // 17
+    // 18
+    CONFIG_EXTERNAL_MAIL_ENABLE,
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     CONFIG_ALLOW_TRACK_BOTH_RESOURCES,
     BOOL_CONFIG_VALUE_COUNT
 };
@@ -177,6 +206,31 @@ enum WorldFloatConfigs
     CONFIG_STATS_LIMITS_PARRY,
     CONFIG_STATS_LIMITS_BLOCK,
     CONFIG_STATS_LIMITS_CRIT,
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    CONFIG_SPEED_GAME,
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    CONFIG_ATTACKSPEED_PLAYER,
+    CONFIG_ATTACKSPEED_ALL,
+    // 16
+    // 17
+    // 18
+    // 19
+    CONFIG_RESPAWNSPEED,
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     FLOAT_CONFIG_VALUE_COUNT
 };
 
@@ -306,12 +360,17 @@ enum WorldIntConfigs
     CONFIG_CHARDELETE_HEROIC_MIN_LEVEL,
     CONFIG_AUTOBROADCAST_CENTER,
     CONFIG_AUTOBROADCAST_INTERVAL,
+    CONFIG_FAKE_WHO_ONLINE_INTERVAL,
+    CONFIG_FAKE_WHO_LEVELUP_INTERVAL,
     CONFIG_MAX_RESULTS_LOOKUP_COMMANDS,
     CONFIG_DB_PING_INTERVAL,
     CONFIG_PRESERVE_CUSTOM_CHANNEL_DURATION,
     CONFIG_PERSISTENT_CHARACTER_CLEAN_FLAGS,
     CONFIG_LFG_OPTIONSMASK,
+    CONFIG_ANTICHEAT_REPORTS_INGAME_NOTIFICATION,
+    CONFIG_ANTICHEAT_MAX_REPORTS_FOR_DAILY_REPORT,
     CONFIG_MAX_INSTANCES_PER_HOUR,
+    CONFIG_ANTICHEAT_DETECTIONS_ENABLED,
     CONFIG_WARDEN_CLIENT_RESPONSE_DELAY,
     CONFIG_WARDEN_CLIENT_CHECK_HOLDOFF,
     CONFIG_WARDEN_CLIENT_FAIL_ACTION,
@@ -337,6 +396,7 @@ enum WorldIntConfigs
     CONFIG_BIRTHDAY_TIME,
     CONFIG_CREATURE_PICKPOCKET_REFILL,
     CONFIG_AHBOT_UPDATE_INTERVAL,
+    CONFIG_EXTERNAL_MAIL_INTERVAL,
     INT_CONFIG_VALUE_COUNT
 };
 
@@ -403,12 +463,33 @@ enum Rates
     RATE_DURABILITY_LOSS_PARRY,
     RATE_DURABILITY_LOSS_ABSORB,
     RATE_DURABILITY_LOSS_BLOCK,
+    RATE_PVP_RANK_EXTRA_HONOR,
     RATE_MOVESPEED,
     RATE_MONEY_QUEST,
     RATE_MONEY_MAX_LEVEL_QUEST,
     MAX_RATES
 };
 
+enum HonorKillPvPRank
+{
+    HKRANK00,
+    HKRANK01,
+    HKRANK02,
+    HKRANK03,
+    HKRANK04,
+    HKRANK05,
+    HKRANK06,
+    HKRANK07,
+    HKRANK08,
+    HKRANK09,
+    HKRANK10,
+    HKRANK11,
+    HKRANK12,
+    HKRANK13,
+    HKRANK14,
+    HKRANKMAX
+};
+
 /// Can be used in SMSG_AUTH_RESPONSE packet
 enum BillingPlanFlags
 {
@@ -636,6 +717,8 @@ class World
         bool SendZoneMessage(uint32 zone, WorldPacket* packet, WorldSession* self = nullptr, uint32 team = 0);
         void SendZoneText(uint32 zone, const char *text, WorldSession* self = nullptr, uint32 team = 0);
 
+        uint32 pvp_ranks[HKRANKMAX];
+
         /// Are we in the middle of a shutdown?
         bool IsShuttingDown() const { return m_ShutdownTimer > 0; }
         uint32 GetShutDownTimeLeft() const { return m_ShutdownTimer; }
@@ -750,6 +833,11 @@ class World
 
         void ReloadRBAC();
 
+        //Guild-Level-System
+        void LoadGuildBonusInfo();
+        uint8 GetReqGuildLevelForBonus(uint8 guildBonus);
+        uint8 SelectReqGuildLevelForBonus(uint8 guildBonus);
+
     protected:
         void _UpdateGameTime();
         // callback for UpdateRealmCharacters
@@ -781,6 +869,7 @@ class World
         time_t m_startTime;
         time_t m_gameTime;
         IntervalTimer m_timers[WUPDATE_COUNT];
+        IntervalTimer extmail_timer;
         time_t mail_timer;
         time_t mail_timer_expires;
         uint32 m_updateTime, m_updateTimeSum;
@@ -852,6 +941,21 @@ class World
 
         void ProcessQueryCallbacks();
         std::deque<std::future<PreparedQueryResult>> m_realmCharCallbacks;
+
+        //Guild-Level-System
+        uint8 m_req_guildLevel_gold_1;
+        uint8 m_req_guildLevel_xp_1;
+        uint8 m_req_guildLevel_schneller_geist;
+        uint8 m_req_guildLevel_reperatur_1;
+        uint8 m_req_guildLevel_gold_2;
+        uint8 m_req_guildLevel_reittempo_1;
+        uint8 m_req_guildLevel_reputation_1;
+        uint8 m_req_guildLevel_xp_2;
+        uint8 m_req_guildLevel_reperatur_2;
+        uint8 m_req_guildLevel_reittempo_2;
+        uint8 m_req_guildLevel_reputation_2;
+        uint8 m_req_guildLevel_honor_1;
+        uint8 m_req_guildLevel_honor_2;
 };
 
 extern uint32 realmID;
diff --git a/src/server/scripts/CMakeLists.txt b/src/server/scripts/CMakeLists.txt
index f193cf4..7d8322a 100644
--- a/src/server/scripts/CMakeLists.txt
+++ b/src/server/scripts/CMakeLists.txt
@@ -24,6 +24,9 @@ include(Examples/CMakeLists.txt)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
+  Custom/npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.cpp
+  ../game/AI/ScriptedAI/sc_npc_teleport.h
   ../game/AI/ScriptedAI/ScriptedEscortAI.cpp
   ../game/AI/ScriptedAI/ScriptedCreature.cpp
   ../game/AI/ScriptedAI/ScriptedFollowerAI.cpp
@@ -71,6 +74,7 @@ include_directories(
   ${CMAKE_SOURCE_DIR}/src/server/shared
   ${CMAKE_SOURCE_DIR}/src/server/shared/Database
   ${CMAKE_SOURCE_DIR}/src/server/game/Accounts
+  ${CMAKE_SOURCE_DIR}/src/server/game/Anticheat
   ${CMAKE_SOURCE_DIR}/src/server/game/Achievements
   ${CMAKE_SOURCE_DIR}/src/server/game/Addons
   ${CMAKE_SOURCE_DIR}/src/server/game/AI
diff --git a/src/server/scripts/Commands/cs_anticheat.cpp b/src/server/scripts/Commands/cs_anticheat.cpp
new file mode 100644
index 0000000..3cc6784
--- /dev/null
+++ b/src/server/scripts/Commands/cs_anticheat.cpp
@@ -0,0 +1,262 @@
+/*
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the
+ * Free Software Foundation; either version 2 of the License, or (at your
+ * option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program. If not, see <http://www.gnu.org/licenses/>.
+ */
+#include "Language.h"
+#include "ScriptMgr.h"
+#include "ObjectMgr.h"
+#include "Chat.h"
+#include "AnticheatMgr.h"
+
+class anticheat_commandscript : public CommandScript
+{
+public:
+    anticheat_commandscript() : CommandScript("anticheat_commandscript") { }
+
+    ChatCommand* GetCommands() const
+    {
+        static ChatCommand anticheatCommandTable[] =
+        {
+            { "global",         SEC_GAMEMASTER,     true,  &HandleAntiCheatGlobalCommand,         "", NULL },
+            { "player",         SEC_GAMEMASTER,     true,  &HandleAntiCheatPlayerCommand,         "", NULL },
+            { "delete",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatDeleteCommand,         "", NULL },
+            { "handle",         SEC_ADMINISTRATOR,  true,  &HandleAntiCheatHandleCommand,         "", NULL },
+            { "jail",           SEC_GAMEMASTER,     true,  &HandleAnticheatJailCommand,         "", NULL },
+            { "warn",           SEC_GAMEMASTER,     true,  &HandleAnticheatWarnCommand,         "", NULL },
+            { NULL,             0,                     false, NULL,                                           "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "anticheat",      SEC_GAMEMASTER,     true, NULL,                     "",  anticheatCommandTable},
+            { NULL,             0,                  false, NULL,                               "", NULL }
+        };
+
+        return commandTable;
+    }
+
+    static bool HandleAnticheatWarnCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+        }else
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+            return false;
+
+        WorldPacket data;
+
+        // need copy to prevent corruption by strtok call in LineFromMessage original string
+        char* buf = strdup("The anticheat system has reported several times that you may be cheating. You will be monitored to confirm if this is accurate.");
+        char* pos = buf;
+
+        while (char* line = handler->LineFromMessage(pos))
+        {
+            handler->BuildChatPacket(data, CHAT_MSG_SYSTEM, LANG_UNIVERSAL, NULL, NULL, line);
+            pTarget->GetSession()->SendPacket(&data);
+        }
+
+        free(buf);
+        return true;
+    }
+
+    static bool HandleAnticheatJailCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        Player* pTarget = NULL;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (command)
+        {
+            strCommand = command;
+            normalizePlayerName(strCommand);
+
+            pTarget = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+        }else
+            pTarget = handler->getSelectedPlayer();
+
+        if (!pTarget)
+        {
+            handler->SendSysMessage(LANG_PLAYER_NOT_FOUND);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (pTarget == handler->GetSession()->GetPlayer())
+            return false;
+
+        // teleport both to jail.
+        pTarget->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+        handler->GetSession()->GetPlayer()->TeleportTo(1,16226.5f,16403.6f,-64.5f,3.2f);
+
+        WorldLocation loc;
+
+        // the player should be already there, but no :(
+        // pTarget->GetPosition(&loc);
+
+        loc.m_mapId = 1;
+        loc.m_positionX = 16226.5f;
+        loc.m_positionY = 16403.6f;
+        loc.m_positionZ = -64.5f;
+        loc.m_orientation = 3.2f;
+
+        pTarget->SetHomebind(loc,876);
+        return true;
+    }
+
+    static bool HandleAntiCheatDeleteCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " "); //get entered name
+
+        if (!command)
+            return true;
+
+        strCommand = command;
+
+        if (strCommand.compare("deleteall") == 0)
+            sAnticheatMgr->AnticheatDeleteCommand(0);
+        else
+        {
+            normalizePlayerName(strCommand);
+            Player* player = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+            if (!player)
+                handler->PSendSysMessage("Player doesn't exist");
+            else
+                sAnticheatMgr->AnticheatDeleteCommand(player->GetGUIDLow());
+        }
+
+        return true;
+    }
+
+    static bool HandleAntiCheatPlayerCommand(ChatHandler* handler, const char* args)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+            return false;
+
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        uint32 guid = 0;
+        Player* player = NULL;
+
+        if (command)
+        {
+            strCommand = command;
+
+            normalizePlayerName(strCommand);
+            player = sObjectAccessor->FindPlayerByName(strCommand.c_str()); //get player by name
+
+            if (player)
+                guid = player->GetGUIDLow();
+        }else
+        {
+            player = handler->getSelectedPlayer();
+            if (player)
+                guid = player->GetGUIDLow();
+        }
+
+        if (!guid)
+        {
+            handler->PSendSysMessage("There is no player.");
+            return true;
+        }
+
+        float average = sAnticheatMgr->GetAverage(guid);
+        uint32 total_reports = sAnticheatMgr->GetTotalReports(guid);
+        uint32 speed_reports = sAnticheatMgr->GetTypeReports(guid,0);
+        uint32 fly_reports = sAnticheatMgr->GetTypeReports(guid,1);
+        uint32 jump_reports = sAnticheatMgr->GetTypeReports(guid,3);
+        uint32 waterwalk_reports = sAnticheatMgr->GetTypeReports(guid,2);
+        uint32 teleportplane_reports = sAnticheatMgr->GetTypeReports(guid,4);
+        uint32 climb_reports = sAnticheatMgr->GetTypeReports(guid,5);
+
+        handler->PSendSysMessage("Information about player %s",player->GetName().c_str());
+        handler->PSendSysMessage("Average: %f || Total Reports: %u ",average,total_reports);
+        handler->PSendSysMessage("Speed Reports: %u || Fly Reports: %u || Jump Reports: %u ",speed_reports,fly_reports,jump_reports);
+        handler->PSendSysMessage("Walk On Water Reports: %u  || Teleport To Plane Reports: %u",waterwalk_reports,teleportplane_reports);
+        handler->PSendSysMessage("Climb Reports: %u", climb_reports);
+
+        return true;
+    }
+
+    static bool HandleAntiCheatHandleCommand(ChatHandler* handler, const char* args)
+    {
+        std::string strCommand;
+
+        char* command = strtok((char*)args, " ");
+
+        if (!command)
+            return true;
+
+        if (!handler->GetSession()->GetPlayer())
+            return true;
+
+        strCommand = command;
+
+        if (strCommand.compare("on") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,true);
+            handler->SendSysMessage("The Anticheat System is now: Enabled!");
+        }
+        else if (strCommand.compare("off") == 0)
+        {
+            sWorld->setBoolConfig(CONFIG_ANTICHEAT_ENABLE,false);
+            handler->SendSysMessage("The Anticheat System is now: Disabled!");
+        }
+
+        return true;
+    }
+
+    static bool HandleAntiCheatGlobalCommand(ChatHandler* handler, const char* /* args */)
+    {
+        if (!sWorld->getBoolConfig(CONFIG_ANTICHEAT_ENABLE))
+        {
+            handler->PSendSysMessage("The Anticheat System is disabled.");
+            return true;
+        }
+
+        sAnticheatMgr->AnticheatGlobalCommand(handler);
+
+        return true;
+    }
+};
+
+void AddSC_anticheat_commandscript()
+{
+    new anticheat_commandscript();
+}
diff --git a/src/server/scripts/Commands/cs_guild.cpp b/src/server/scripts/Commands/cs_guild.cpp
index 7b07408..a329975 100644
--- a/src/server/scripts/Commands/cs_guild.cpp
+++ b/src/server/scripts/Commands/cs_guild.cpp
@@ -45,6 +45,9 @@ public:
             { "rank",     rbac::RBAC_PERM_COMMAND_GUILD_RANK,     true, &HandleGuildRankCommand,             "", NULL },
             { "rename",   rbac::RBAC_PERM_COMMAND_GUILD_RENAME,   true, &HandleGuildRenameCommand,           "", NULL },
             { "info",     rbac::RBAC_PERM_COMMAND_GUILD_INFO,     true, &HandleGuildInfoCommand,             "", NULL },
+            { "linfo",    rbac::RBAC_PERM_COMMAND_GUILD_LINFO,    true, &HandleGuildLInfoCommand,            "", NULL },
+            { "setlevel", rbac::RBAC_PERM_COMMAND_GUILD_SET_LEVEL,true, &HandleGuildSetLevelCommand,         "", NULL },
+            { "givexp",   rbac::RBAC_PERM_COMMAND_GUILD_GIVE_XP,  true, &HandleGuildGiveXpCommand,           "", NULL },
             { NULL,       0,                               false, NULL,                                "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -287,6 +290,124 @@ public:
         handler->PSendSysMessage(LANG_GUILD_INFO_EXTRA_INFO, guild->GetInfo().c_str()); // Extra Information
         return true;
     }
+
+    //Guild-Level-System
+    static bool HandleGuildLInfoCommand(ChatHandler* handler, char const* /*args*/)
+    {
+        Guild* guild = handler->GetSession()->GetPlayer()->GetGuild();
+
+        if (guild)
+        {
+            handler->PSendSysMessage(LANG_GUILDINFO_LEVEL, guild->GetLevel());
+
+            if (guild->GetLevel() >= GUILD_MAX_LEVEL)
+                handler->PSendSysMessage(LANG_GUILDINFO_XP_INFO, 0, 0);
+            else
+                handler->PSendSysMessage(LANG_GUILDINFO_XP_INFO, guild->GetCurrentXP(), guild->GetXpForNextLevel());
+
+            handler->PSendSysMessage("Active Bonus:");
+
+            if (guild->GetLevel() > 0)
+            {
+                if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_1))
+                    handler->PSendSysMessage("Gold bonus [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_XP_1))
+                    handler->PSendSysMessage("Bonus Experience [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_SCHNELLER_GEIST))
+                    handler->PSendSysMessage("Faster Ghost");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_1))
+                    handler->PSendSysMessage("Cheaper Repairs [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_GOLD_2))
+                    handler->PSendSysMessage("Gold bonus [Rank 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_1))
+                    handler->PSendSysMessage("Mount Speed [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_RUF_1))
+                    handler->PSendSysMessage("Reputation [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_XP_2))
+                    handler->PSendSysMessage("Bonus Experience [Rank 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    handler->PSendSysMessage("Cheaper Repairs [Rank 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REITTEMPO_2))
+                    handler->PSendSysMessage("Mount Speed [Rank 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_REPERATUR_2))
+                    handler->PSendSysMessage("Reputation [Rank 2]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_1))
+                    handler->PSendSysMessage("Bonus Honor [Rank 1]");
+                if (guild->HasLevelForBonus(GUILD_BONUS_EHRE_2))
+                    handler->PSendSysMessage("Bonus Honor [Rank 2]");
+            }
+            else
+                handler->PSendSysMessage("None");
+
+            return true;
+        }
+        else
+        {
+            handler->PSendSysMessage("You are not in a guild");
+            return false;
+        }
+    }
+
+    static bool HandleGuildSetLevelCommand(ChatHandler* handler, char const* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guildNameStr;
+        char* levelStr;
+        handler->extractOptFirstArg((char*)args, &guildNameStr, &levelStr);
+
+        if (!levelStr)
+            return false;
+
+        uint8 newLevel = uint8(atoi(levelStr));
+        Guild* guild = sGuildMgr->GetGuildByName(guildNameStr);
+
+        if (guild)
+        {
+            if (newLevel > GUILD_MAX_LEVEL)
+            {
+                handler->PSendSysMessage("Your guild is max level");
+                return false;
+            }
+            else
+                guild->SetLevel(newLevel, true);
+        }
+        else
+        {
+            handler->PSendSysMessage("There is no guild named [%s] found.", guildNameStr);
+            return false;
+        }
+
+        return true;
+    }
+
+    static bool HandleGuildGiveXpCommand(ChatHandler* handler, char const* args)
+    {
+        if (!*args)
+            return false;
+
+        char* guildNameStr;
+        char* xpStr;
+        handler->extractOptFirstArg((char*)args, &guildNameStr, &xpStr);
+
+        if (!xpStr)
+            return false;
+
+        uint32 value = uint32(atoi(xpStr));
+
+        Guild* guild = sGuildMgr->GetGuildByName(guildNameStr);
+
+        if (guild)
+            guild->GiveXp(value);
+        else
+        {
+            handler->PSendSysMessage("There was no guild with the name [%s] found.", guildNameStr);
+            return false;
+        }
+
+        return true;
+    }
 };
 
 void AddSC_guild_commandscript()
diff --git a/src/server/scripts/Commands/cs_modify.cpp b/src/server/scripts/Commands/cs_modify.cpp
index f70f172..7781ca3 100644
--- a/src/server/scripts/Commands/cs_modify.cpp
+++ b/src/server/scripts/Commands/cs_modify.cpp
@@ -70,6 +70,8 @@ public:
             { "spell",        rbac::RBAC_PERM_COMMAND_MODIFY_SPELL,        false, &HandleModifySpellCommand,         "", NULL },
             { "standstate",   rbac::RBAC_PERM_COMMAND_MODIFY_STANDSTATE,   false, &HandleModifyStandStateCommand,    "", NULL },
             { "talentpoints", rbac::RBAC_PERM_COMMAND_MODIFY_TALENTPOINTS, false, &HandleModifyTalentCommand,        "", NULL },
+            { "xpkill",       rbac::RBAC_PERM_COMMAND_MODIFY_XP_KILL,      false, &HandleModifyXpKillCommand, "", NULL },
+            { "xpquest",      rbac::RBAC_PERM_COMMAND_MODIFY_XP_QUEST,     false, &HandleModifyXpQuestCommand, "", NULL },
             { NULL,           0,                                     false, NULL,                              "", NULL }
         };
         static ChatCommand commandTable[] =
@@ -1393,6 +1395,68 @@ public:
 
         return true;
     }
+
+    static bool HandleModifyXpKillCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        float killRate = (float)atof((char*)args);
+
+        if (killRate < 1)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_LOW);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (killRate > 8)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_HIGH);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* player = handler->GetSession()->GetPlayer())
+        {
+            player->SetIndividualRate(INDIVIDUAL_XP_KILL, killRate);
+            handler->PSendSysMessage(LANG_INDIVIDUAL_KILLRATE_SET, killRate);
+            return true;
+        }
+
+        return true;
+    }
+
+    static bool HandleModifyXpQuestCommand(ChatHandler* handler, const char* args)
+    {
+        if (!*args)
+            return false;
+
+        float questRate = (float)atof((char*)args);
+
+        if (questRate < 1)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_LOW);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (questRate > 8)
+        {
+            handler->SendSysMessage(LANG_INDIVIDUAL_RATE_TO_HIGH);
+            handler->SetSentErrorMessage(true);
+            return false;
+        }
+
+        if (Player* player = handler->GetSession()->GetPlayer())
+        {
+            player->SetIndividualRate(INDIVIDUAL_XP_QUEST, questRate);
+            handler->PSendSysMessage(LANG_INDIVIDUAL_QUESTRATE_SET, questRate);
+            return true;
+        }
+
+        return true;
+    }
 };
 
 void AddSC_modify_commandscript()
diff --git a/src/server/scripts/Custom/ArenaGambler.cpp b/src/server/scripts/Custom/ArenaGambler.cpp
new file mode 100644
index 0000000..376d946
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGambler.cpp
@@ -0,0 +1,308 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGambler.cpp
+ * Description: This file is used to script the npc for the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#include "ScriptPCH.h"
+#include "ArenaGamblingSystem.h"
+#include "ScriptMgr.h"
+#include "Player.h"
+
+class ArenaGambler : public CreatureScript
+{
+    public:
+        ArenaGambler() : CreatureScript(ARENA_GAMBLER_SCRIPT_NAME) {}
+        bool OnGossipHello(Player *pPlayer, Creature *pCreature)
+        {
+            switch (urand(0,6))
+            {
+                case 0: pCreature->MonsterSay("|cffbbbbbbWelcome ye great warrior , fight to the last for the Lich King!",0,pPlayer); break;
+                case 1: pCreature->MonsterSay("|cffbbbbbbOnly great warriors are welcome!",0,pPlayer); break;
+                case 2: pCreature->MonsterSay("|cffbbbbbbMere mortals cannot be gods!",0,pPlayer); break;
+                case 3: pCreature->MonsterSay("|cffbbbbbbGreat warrior , you seek to duel!",0,pPlayer); break;
+                case 4: pCreature->MonsterSay("|cffbbbbbbDeath and glory await!",0,pPlayer); break;
+                case 5: pCreature->MonsterSay("|cffbbbbbbBegone, weaklings are unwelcome!",0,pPlayer); break;
+                case 6: pCreature->MonsterSay("|cffbbbbbbDeath and honor!",0,pPlayer); break;
+            }
+                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_ITEM, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+            return true;
+        }
+
+        bool OnGossipSelect(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_MAIN:
+                {
+                    if(GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer))
+                    {
+                            if(matchData->MatchStarted())
+                                return true;
+                            if(matchData->GetItemIdBy(pPlayer) == 0) // if there is match data, but no item was bet
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM,            ARENA_GAMBLER_MENU_BET_ITEM,            GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT, 0, true);
+                            if(matchData->GetItemIdBy(pPlayer) != 0 && matchData->GetItemCountBy(pPlayer) == 0) // if there is match data and an item, but no amount was entered
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM,    ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT,    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerItemId() && matchData->GetDefenderItemId() && matchData->GetItemCountBy(pPlayer) != 0 &&  matchData->HasSetReady(pPlayer) == false) // if everything checks out, but player is not yet ready.
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_ACCEPT,    ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE,    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            if(matchData->GetChallengerGUID() == pPlayer->GetGUIDLow())
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CANCEL,    ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE,    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                            else
+                                pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_DECLINE,    ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE,    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,    GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        }
+                        else // if no match data was found
+                        {
+                            pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_CHALLENGE, ARENA_GAMBLER_TEXT_CHALLENGE, ARENA_GAMBLER_MENU_CHALLENGE_PLAYER, GOSSIP_ACTION_INFO_DEF + 1, ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT, 0, true);
+                        }
+                        pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                        pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT:
+                {
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_10, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_20, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_30, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_40, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_50, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_100, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_200, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_300, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_500, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_BET_ITEM, ARENA_GAMBLER_TEXT_BET_AMOUNT_1000, ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000, GOSSIP_ACTION_INFO_DEF + 1, "", 0, false);
+
+                    pPlayer->PlayerTalkClass->GetGossipMenu().AddMenuItem(-1, ARENA_GAMBLER_ICON_EXIT, ARENA_GAMBLER_TEXT_EXIT, ARENA_GAMBLER_MENU_EXIT, GOSSIP_ACTION_INFO_DEF + 1, "", false);
+                    pPlayer->SEND_GOSSIP_MENU(pPlayer->GetGossipTextId(pCreature), pCreature->GetGUID());
+                }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 10) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 20) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 30) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40:
+                    {
+                        if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 40) == false)
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                        else
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                    case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 50) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 100) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 200) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 300) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 500) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000:
+                {
+                    if(sGamblingSystem->AddItemAmountForMatch(pPlayer, 1000) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                }break;
+                case ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE:
+                    {
+                        sGamblingSystem->AcceptChallenge(pPlayer);
+                        pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_CANCEL_CHALLENGE:
+                case ARENA_GAMBLER_MENU_DECLINE_CHALLENGE:
+                    {
+                    sGamblingSystem->CancelChallenge(pPlayer);
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+                case ARENA_GAMBLER_MENU_EXIT:{
+                    pPlayer->CLOSE_GOSSIP_MENU();
+                    }break;
+            }
+
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player *pPlayer, Creature *pCreature, uint32 sender, uint32 action, const char *pCode)
+        {
+            switch(sender)
+            {
+                case ARENA_GAMBLER_MENU_CHALLENGE_PLAYER:
+                {
+                    if(Player* pDefender = sObjectAccessor->FindPlayerByName(pCode))
+                    {
+                        if(sGamblingSystem->CanHaveMatch(pPlayer, pDefender) == false)
+                        {
+                            // General Error Message: Match not possible because:
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE);
+                            // Reason is: no gamemasters
+                            if(pPlayer->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_NO_GMS_ALLOWED);
+                            }
+                            // Reason is: you cannot duel your self!
+                            if(pPlayer->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_SAME_ACC_ID);
+                            }
+                            // Reason is: multiboxing is not allowed, or players have the same ip.
+                            if(pPlayer->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_MULTI_BOX);
+                            }
+                            // Reason is: your level is smaller than the minimum level required
+                            uint32 m_minRequiredLevel = 0;
+                            if(pPlayer->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel )
+                            {
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            }
+                            // Reason is: you are requesting a duel from someone who already is in a duel.
+                            ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_LOW_LEVEL);
+                            // Reason is: level diffrance is too high
+                            uint32 levelDiff = 0;
+                            if(pPlayer->getLevel() > pDefender->getLevel())
+                            {
+                                levelDiff = pPlayer->getLevel() - pDefender->getLevel();
+                            }
+                            else
+                            {
+                                levelDiff = pDefender->getLevel() - pPlayer->getLevel();
+                            }
+                            return true;
+                        }
+                        sGamblingSystem->SetupMatch(pPlayer, pDefender);
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_CHALLENGE_ISSUED, pDefender);
+                        ChatHandler(pDefender->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_CHALLENGED, pPlayer);
+                        OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                    }
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND);
+                }break;
+
+                case ARENA_GAMBLER_MENU_BET_ITEM:
+                {
+                    if(sGamblingSystem->AddItemForMatch(pPlayer, pCode) == false)
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_FAILED);
+                    else
+                        ChatHandler(pPlayer->GetSession()).PSendSysMessage(ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS);
+                    OnGossipSelect(pPlayer, pCreature, ARENA_GAMBLER_MENU_MAIN, GOSSIP_ACTION_INFO_DEF + 1);
+                }break;
+            }
+            return true;
+        }
+};
+
+// Arena Records GameObject
+class ArenaRecords : public GameObjectScript
+{ public:
+    ArenaRecords() : GameObjectScript(ARENA_RECORDS_SCRIPT_NAME) { }
+    bool OnGossipHello(Player* pPlayer, GameObject* pGo)
+    {
+        if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `playerGUID`,`duelsLost`,`duelsWon`,`duelsRefused`,`duelsTotal` FROM `custom_duel_statistics` WHERE `playerGUID` = '%u'", pPlayer->GetGUIDLow()))
+        {
+            uint32 playerGUID = queryResult->Fetch()[0].GetUInt32();
+            uint32 duelsLost = queryResult->Fetch()[1].GetUInt32();
+            uint32 duelsWon = queryResult->Fetch()[2].GetUInt32();
+            uint32 duelsRefused = queryResult->Fetch()[3].GetUInt32();
+            uint32 duelsTotal = queryResult->Fetch()[4].GetUInt32();
+
+            std::ostringstream Lost;
+            std::ostringstream Won;
+            std::ostringstream Refused;
+            std::ostringstream Total;
+
+            Lost << MSG_COLOR_SUBWHITE << "You have Lost : " << MSG_COLOR_LIGHTBLUE <<  duelsLost << " Duel(s)." ;
+            Won << MSG_COLOR_SUBWHITE << "You have Won : " << MSG_COLOR_LIGHTBLUE <<  duelsWon << " Duel(s)." ;
+            Refused << MSG_COLOR_SUBWHITE << "You have Refused : " << MSG_COLOR_LIGHTBLUE <<  duelsRefused << " Duel(s)." ;
+            Total << MSG_COLOR_SUBWHITE << "You have Fought : " << MSG_COLOR_LIGHTBLUE <<  duelsTotal << " Duel(s)." ;
+
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Lost.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Won.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Refused.str( ).c_str( ));
+            ChatHandler(pPlayer->GetSession()).SendSysMessage(Total.str( ).c_str( ));
+        }
+        else
+        {
+            switch (urand(0,5))
+            {
+            case 0: pPlayer->MonsterSay("I never fought once , i should be ashamed.",0,pPlayer);break;
+            case 1: pPlayer->MonsterSay("This book does not hold any records of me!",0,pPlayer);break;
+            case 2: pPlayer->MonsterSay("i have never challenged anyone here!",0,pPlayer);break;
+            case 3: pPlayer->MonsterSay("I should first challenge someone!",0,pPlayer);break;
+            case 4: pPlayer->MonsterSay("No Wins, No losses",0,pPlayer);break;
+            case 5: pPlayer->MonsterSay("I should hide in a cave, i don't deserve to be here!",0,pPlayer);break;
+            }
+        }
+        return true;
+    }
+};
+
+void AddSC_ArenaGambler()
+{
+    sGamblingSystem->Initalize();
+    new ArenaGambler();
+    new ArenaRecords();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.cpp b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
new file mode 100644
index 0000000..114e1f0
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.cpp
@@ -0,0 +1,723 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.cpp
+ * Description: This file is used to script the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#include "ScriptPCH.h"
+#include "ArenaGamblingSystem.h"
+
+using namespace std;
+
+const char *GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_MAX] =
+{
+    "playerGUID",
+    "duelsLost",
+    "duelsWon",
+    "duelsRefused",
+    "duelsTotal"
+};
+
+GamblingSystem::GamblingSystem() : WorldScript(GAMBLER_SYSTEM_SCRIPT_NAME)
+{
+    m_checkMatches.SetInterval(GAMBLER_SYSTEM_INTERVAL_TELE_CHECK);
+}
+
+GamblingSystem::~GamblingSystem()
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+        delete Itr->second;
+    m_matchStorage.clear();
+    ReleaseMatchLock();
+}
+
+// Creation
+void GamblingSystem::Initalize()
+{
+    LoadConfigData();
+    _loadPastMatches();
+    new GamblerDuelScript();
+}
+
+// Events
+// Called on every world tick (don't execute too heavy code here).
+void GamblingSystem::OnUpdate(uint32 diff)
+{
+    if(m_checkMatches.GetCurrent() >= 0)
+        m_checkMatches.Update(diff);
+    else
+        m_checkMatches.SetCurrent(0);
+    if(m_checkMatches.Passed())
+        m_checkMatches.Reset();
+
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetMatchStatus() != GAMBLER_MATCH_STATUS_TELEPORT)
+            continue;
+
+        Player *pChallenger = ObjectAccessor::FindPlayer(Itr->second->GetChallengerGUID());
+        Player *pDefender    = ObjectAccessor::FindPlayer(Itr->second->GetDefenderGUID());
+
+        if(pChallenger == NULL || pDefender == NULL)
+            continue;
+        if(pChallenger->IsBeingTeleported() || pChallenger->isBeingLoaded() || pDefender->IsBeingTeleported() || pDefender->isBeingLoaded())
+            continue;
+
+        pChallenger->CastSpell(pDefender, 7266, true);
+        Itr->second->SetMatchStatus(GAMBLER_MATCH_STATUS_RUNNING);
+    }
+    ReleaseMatchLock();
+}
+
+// Database Interaction
+void GamblingSystem::LoadConfigData()
+{
+    m_minRequiredLevel = 255;
+    m_maxLevelDiff       = 5;
+    m_maxBet           = 100;
+    m_awardFled           = false;
+    m_enableGM           = false;
+    m_enableSameip       = false;
+    m_enableLimits       = false;
+    m_onlyCurrency       = false;
+    m_equalDuels       = false;
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT `optionIndex`, `optionValue` FROM `custom_duel_config`"))
+    {
+        do
+        {
+            Field *Fields = queryResult->Fetch();
+            switch(Fields[0].GetUInt32())
+            {
+                case GAMBLER_CONFIG_OPTION_MAPID:                m_arenaCoords.m_mapId        = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_COORDSX:                m_arenaCoords.m_positionX    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSY:                m_arenaCoords.m_positionY    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSZ:                m_arenaCoords.m_positionZ    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_COORDSO:                m_arenaCoords.m_orientation    = Fields[1].GetFloat();        break;
+                case GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL:    m_minRequiredLevel            = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF:        m_maxLevelDiff                = Fields[1].GetUInt32();    break;
+                case GAMBLER_CONFIG_OPTION_AWARD_FLED:            m_awardFled                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_MAX_BET:
+                    m_maxBet                    = Fields[1].GetUInt32();
+                    if(m_maxBet > GAMBLER_SYSTEM_TOTAL_MAX_BET){
+                        m_maxBet = GAMBLER_SYSTEM_TOTAL_MAX_BET;
+                    }
+                break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_GM:            m_enableGM                    = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP:        m_enableSameip                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ENABLE_LIMITS:        m_enableLimits                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_ONLY_CURRENCY:        m_onlyCurrency                = Fields[1].GetBool();        break;
+                case GAMBLER_CONFIG_OPTION_EQUAL_DUELS:            m_equalDuels                = Fields[1].GetBool();        break;
+            }
+        }while(queryResult->NextRow());
+    }
+    else
+        TC_LOG_ERROR("Arena", "GamblingSystem: Unable to load duel_config, result was not returned");
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT MAX(`matchId`) FROM `custom_duel_storage`"))
+        m_highMatchId = queryResult->Fetch()[0].GetUInt32();
+    else
+        m_highMatchId = 0;
+}
+
+void GamblingSystem::_loadPastMatches()
+{
+    if(QueryResult queryResult = CharacterDatabase.Query("SELECT * FROM `custom_duel_storage`"))
+    {
+        do
+        {
+            GamblerMatchData *matchData = new GamblerMatchData(queryResult->Fetch());
+            if(matchData->GetMatchWinner() == 0)
+            {
+                _createItemAndMailToPlayer(NULL, matchData->GetChallengerGUID(), matchData->GetChallengerItemId(), matchData->GetChallengerItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(NULL, matchData->GetDefenderGUID(), matchData->GetDefenderItemId(), matchData->GetDefenderItemCount(), GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                continue;
+            }
+            AcquireMatchLock();
+            m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+            ReleaseMatchLock();
+        }while(queryResult->NextRow());
+    }
+    CharacterDatabase.PExecute("DELETE FROM `custom_duel_storage` WHERE `matchWinner` = '0'");
+}
+
+void GamblingSystem::_saveCurrentMatchProgress(GamblerMatchData *matchData)
+{
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT * FROM `custom_duel_storage` WHERE `matchId` = '%u'", matchData->GetMatchId()))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_storage` SET `matchWinner` = '%u'", matchData->GetMatchWinner());
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_storage` VALUES ('%u', '%u', '%u', '%u', '%u', '%u', '%u', NOW(), '%u')", matchData->GetMatchId(), matchData->GetChallengerGUID(), matchData->GetDefenderGUID(), matchData->GetChallengerItemId(),matchData->GetChallengerItemCount(), matchData->GetDefenderItemId(),matchData->GetDefenderItemCount(), matchData->GetMatchWinner());
+}
+
+void GamblingSystem::_updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue)
+{
+    if(statIndex > GAMBLER_PLAYER_STAT_MAX)
+    {
+        TC_LOG_ERROR("Arena", "GamblingSystem: _updatePlayerStats statIndex out of range");
+        return;
+    }
+    if(QueryResult queryResult = CharacterDatabase.PQuery("SELECT `%s` FROM `custom_duel_statistics` WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID))
+        CharacterDatabase.PExecute("UPDATE `custom_duel_statistics` SET `%s` = '%u' WHERE `%s` = '%u'", GamblerPlayerStatFields[statIndex], queryResult->Fetch()[0].GetUInt32()+statIncreaseValue, GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], playerGUID);
+    else
+        CharacterDatabase.PExecute("INSERT INTO `custom_duel_statistics` (`%s`,`%s`) VALUES('%u', '%u')", GamblerPlayerStatFields[GAMBLER_PLAYER_STAT_GUID], GamblerPlayerStatFields[statIndex], playerGUID, statIncreaseValue);
+}
+
+// Match Data Retrieval
+GamblerMatchData *GamblingSystem::GetMatchDataBy(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUIDLow() || Itr->second->GetDefenderGUID() == pPlayer->GetGUIDLow())
+        {
+            // Match is over, old data
+            if(Itr->second->GetMatchWinner())
+                continue;
+            ReleaseMatchLock();
+            return Itr->second;
+        }
+    }
+    ReleaseMatchLock();
+    return NULL;
+}
+
+// Match Requirements Checking
+bool GamblingSystem::CanHaveMatch(Player *pChallenger, Player *pDefender)
+{
+    // if same ip dueling is enabled in configuration
+    if(m_enableSameip == 1){
+        // no multibox or dueling with same ip
+        if(pChallenger->GetSession()->GetRemoteAddress().compare(pDefender->GetSession()->GetRemoteAddress()) == 0)
+            return false;
+    }
+
+    // if gm dueling is enabled in configuration
+    if(m_enableGM == 1){
+        // No gamemasters
+         if(pChallenger->GetSession()->GetSecurity() > 0 || pDefender->GetSession()->GetSecurity() > 0)
+            return false;
+    }
+
+    // no dueling on the same account
+    if(pChallenger->GetSession()->GetAccountId() == pDefender->GetSession()->GetAccountId())
+        return false;
+
+    // no dueling if any of the players are logging out!
+    if(pChallenger->GetSession()->isLogingOut() || pDefender->GetSession()->isLogingOut())
+        return false;
+
+    // No dueling if player already has a duel record in progress
+    if(GetMatchDataBy(pChallenger) || GetMatchDataBy(pDefender))
+        return false;
+
+    // No dueling if you don't meet the level requirement in the database
+    uint32 m_minRequiredLevel = 0;
+    if(pChallenger->getLevel() <= m_minRequiredLevel || pDefender->getLevel() <= m_minRequiredLevel)
+        return false;
+
+    // No dueling if your level differance is bigger than specified in the database
+    uint32 levelDiff = 0;
+    if(pChallenger->getLevel() > pDefender->getLevel())
+        levelDiff = pChallenger->getLevel() - pDefender->getLevel();
+    else
+        levelDiff = pDefender->getLevel() - pChallenger->getLevel();
+    if(levelDiff > m_maxLevelDiff)
+        return false;
+
+    return true;
+}
+
+// Match Setup
+void GamblingSystem::SetupMatch(Player *pChallenger, Player *pDefender)
+{
+    GamblerMatchData *matchData = new GamblerMatchData(_generateMatchId(), pChallenger->GetGUIDLow(), pDefender->GetGUIDLow());
+    AcquireMatchLock();
+    m_matchStorage.insert(make_pair(matchData->GetMatchId(), matchData));
+    ReleaseMatchLock();
+}
+
+std::string GamblingSystem::GetQualityColor(int32 qualityType) const
+{
+    switch(qualityType)
+    {
+        case ITEM_QUALITY_POOR:
+        {
+            return QUALITY_POOR;
+        }break;
+        case ITEM_QUALITY_NORMAL:
+        {
+            return QUALITY_NORMAL;
+        }break;
+        case ITEM_QUALITY_UNCOMMON:
+        {
+            return QUALITY_UNCOMMON;
+        }break;
+        case ITEM_QUALITY_RARE:
+        {
+            return QUALITY_RARE;
+        }break;
+        case ITEM_QUALITY_EPIC:
+        {
+            return QUALITY_EPIC;
+        }break;
+        case ITEM_QUALITY_LEGENDARY:
+        {
+            return QUALITY_LEGENDARY;
+        }break;
+        case ITEM_QUALITY_ARTIFACT:
+        {
+            return QUALITY_ARTIFACT;
+        }break;
+        case ITEM_QUALITY_HEIRLOOM:
+        {
+            return QUALITY_HEIRLOOM;
+        }break;
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemForMatch(Player *pPlayer, std::string itemName)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    WorldDatabase.EscapeString(itemName);
+    if(QueryResult queryResult = WorldDatabase.PQuery("SELECT `entry` FROM `item_template` WHERE `name` = '%s'", itemName.c_str()))
+    {
+        uint32 itemId = queryResult->Fetch()[0].GetUInt32();
+
+        ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+        if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+        {
+            // if its currency
+            if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS)
+            {
+                if(pItem == NULL)
+                    return false;
+            }else{ // if its a normal item, check if its valid.
+                if(_checkItemValidity(pItem) == false)
+                    return false;
+            }
+
+            if(m_enableLimits == 1){ // if item limits are enabled, check them.
+                if(_checkWithinLimits(pItem) == false)
+                    return false;
+            }
+
+            if(m_onlyCurrency == 1){ // if only currency is allowed, check the item proto, temporary.
+                if(itemProto->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){}else{return false;}
+            }
+
+            if(matchData->IsChallenger(pPlayer)){
+                matchData->SetChallengerItemId(itemId);
+            }
+            else{
+                matchData->SetDefenderItemId(itemId);
+            }
+            return true;
+        }
+    }
+    return false;
+}
+
+bool GamblingSystem::AddItemAmountForMatch(Player *pPlayer, uint32 amount)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return false;
+
+    uint32 itemId = matchData->GetItemIdBy(pPlayer);
+    ItemTemplate const *itemProto = sObjectMgr->GetItemTemplate(itemId);
+
+    if(Item *pItem = pPlayer->GetItemByEntry(itemId))
+    {
+        // if duels must be equal, then challenger item count must equal defender item count.
+        if(m_equalDuels == 1){
+            // if the player is challenger and his amount is not equal to the defender's item count, return false.
+            if(matchData->IsChallenger(pPlayer) && matchData->GetDefenderItemCount() != 0 && amount != matchData->GetDefenderItemCount())
+                return false;
+            // if the player is defender and his amount is not equal to challenger's item count, return false.
+            else if(matchData->IsDefender(pPlayer)  && matchData->GetChallengerItemCount() != 0 && amount != matchData->GetChallengerItemCount())
+                return false;
+        }
+
+        if(amount > m_maxBet)
+            return false;
+
+        if(!pPlayer->HasItemCount(itemId,amount))
+            return false;
+
+        if(matchData->IsChallenger(pPlayer)){
+            matchData->SetChallengerItemCount(amount);
+        }
+        else{
+            matchData->SetDefenderItemCount(amount);
+        }
+
+        Player *secondPlayer = NULL;
+        if(matchData->IsChallenger(pPlayer))
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());
+        else
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());
+        if(secondPlayer)
+            ChatHandler(secondPlayer->GetSession()).PSendSysMessage("|cffffffffThe player |cff00ccff%s |cffffffffhas bet |cff00ccff%u|cffffffffx of the item |%s|Hitem:%u:0:0:0:0:0:0:0:%u|h[%s]|h|r", pPlayer, amount, GetQualityColor(itemProto->Quality).c_str(),  pItem->GetEntry(), pPlayer->getLevel(),  itemProto->Name1.c_str());
+        return true;
+    }
+    return false;
+}
+
+void GamblingSystem::AcceptChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    if(matchData->IsChallenger(pPlayer))
+        matchData->SetChallengerReady(true);
+    else
+        matchData->SetDefenderReady(true);
+    if(matchData->GetChallengerReady() && matchData->GetDefenderReady())
+    {
+        Player *secondPlayer = NULL;
+
+        if(matchData->IsChallenger(pPlayer)){
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());}
+        else{
+            secondPlayer = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());}
+
+        // Don't start the duel if there is no second player
+        if(secondPlayer == NULL)
+        {
+            ChatHandler(pPlayer->GetSession()).PSendSysMessage(GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already in a duel
+        if(secondPlayer->duel || pPlayer->duel)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if they are already InCombat
+        if(secondPlayer->IsInCombat() || pPlayer->IsInCombat())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_DUEL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+        // Don't start the duel if the players are logging out
+        if(secondPlayer->GetSession()->isLogingOut() || pPlayer->GetSession()->isLogingOut())
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANT_START_LOGGING);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        uint32 itemId1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+        uint32 itemId2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+
+        uint32 amount1 = matchData->IsChallenger(pPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+        uint32 amount2 = matchData->IsChallenger(secondPlayer) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+
+        ItemTemplate const *Proto1 = sObjectMgr->GetItemTemplate(itemId1);
+        ItemTemplate const *Proto2 = sObjectMgr->GetItemTemplate(itemId2);
+
+        if(Proto1->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS || Proto2->BagFamily & BAG_FAMILY_MASK_CURRENCY_TOKENS){
+            // Missing data here, not important.
+        }else if(_checkItemValidity(pPlayer->GetItemByEntry(itemId1)) == false || _checkItemValidity(secondPlayer->GetItemByEntry(itemId2)) == false){
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the item in inventory
+        if(pPlayer->GetItemCount(itemId1) == 0 || secondPlayer->GetItemCount(itemId2) == 0)
+        {
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ITEM_NO_INV);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players don't have the amount of items betted
+        if(!pPlayer->GetItemCount(itemId1, amount1)  || !secondPlayer->GetItemCount(itemId2, amount2))
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        // Don't start the duel if the players have betted more than the maximum specified in configuration
+        if(pPlayer->GetItemCount(amount1) > m_maxBet || secondPlayer->GetItemCount(amount2) > m_maxBet)
+        {
+            SendMessageToPlayers(matchData, ARENA_GAMBLER_MSG_BET_ADD_FAILED, m_maxBet);
+            _deleteMatchData(matchData->GetMatchId());
+            return;
+        }
+
+        _saveCurrentMatchProgress(matchData);
+        _updatePlayerStats(pPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+        _updatePlayerStats(secondPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_TOTAL, 1);
+
+        pPlayer->DestroyItemCount(itemId1, amount1, true, true);
+        secondPlayer->DestroyItemCount(itemId2, amount2, true, true);
+
+        pPlayer->SaveToDB();
+        secondPlayer->SaveToDB();
+
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_MATCH_STARTING);
+
+        pPlayer->SetBattlegroundEntryPoint();
+        secondPlayer->SetBattlegroundEntryPoint();
+        pPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        secondPlayer->TeleportTo(m_arenaCoords.GetMapId(), m_arenaCoords.GetPositionX(), m_arenaCoords.GetPositionY(), m_arenaCoords.GetPositionZ(), m_arenaCoords.GetOrientation());
+        matchData->SetMatchStatus(GAMBLER_MATCH_STATUS_TELEPORT);
+    }
+    else
+        SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE, pPlayer);
+}
+
+void GamblingSystem::CancelChallenge(Player *pPlayer)
+{
+    GamblerMatchData *matchData = GetMatchDataBy(pPlayer);
+    if(matchData == NULL)
+        return;
+    SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_CANCELED, pPlayer, matchData->GetChallengerGUID() == pPlayer->GetGUIDLow() ? GAMBLER_SYSTEM_MSG_CANCELED_1 : GAMBLER_SYSTEM_MSG_CANCELED_2);
+    if(matchData->IsDefender(pPlayer))
+        _updatePlayerStats(pPlayer->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_REFUSED, 1);
+    _deleteMatchData(matchData->GetMatchId());
+}
+
+// Match Completion
+void GamblingSystem::HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType)
+{
+    uint32 itemId1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 itemId2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemId() : matchData->GetDefenderItemId();
+    uint32 amount1 = matchData->IsChallenger(pWinner) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    uint32 amount2 = matchData->IsChallenger(pLoser) ? matchData->GetChallengerItemCount() : matchData->GetDefenderItemCount();
+    switch(completeType)
+    {
+        case DUEL_INTERRUPTED:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            _createItemAndMailToPlayer(pLoser, pLoser->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED);
+        }break;
+        case DUEL_WON:
+        {
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+            SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+        }break;
+        case DUEL_FLED:
+        {
+            if(m_awardFled)
+            {
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_WON, pWinner);
+
+            }else{
+                _createItemAndMailToPlayer(pWinner, pWinner->GetGUIDLow(), itemId1, amount1, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                _createItemAndMailToPlayer(pLoser, pLoser->GetGUIDLow(), itemId2, amount2, GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE);
+                SendMessageToPlayers(matchData, GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD);
+            }
+        }break;
+    }
+    _updatePlayerStats(pWinner->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_WON, 1);
+    _updatePlayerStats(pLoser->GetGUIDLow(), GAMBLER_PLAYER_STAT_DUELS_LOST, 1);
+    matchData->SetMatchWinner(pWinner->GetGUIDLow());
+    _saveCurrentMatchProgress(matchData);
+    _deleteMatchData(matchData->GetMatchId());
+    pWinner->TeleportToBGEntryPoint();
+    pLoser->TeleportToBGEntryPoint();
+}
+
+// Match Data
+void GamblingSystem::_deleteMatchData(Player *pPlayer)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr;
+    for(Itr = m_matchStorage.begin(); Itr != m_matchStorage.end(); ++Itr)
+    {
+        if(Itr->second->GetChallengerGUID() == pPlayer->GetGUIDLow() || Itr->second->GetDefenderGUID() == pPlayer->GetGUIDLow())
+        {
+            delete Itr->second;
+            m_matchStorage.erase(Itr);
+            break;
+        }
+    }
+    ReleaseMatchLock();
+}
+
+bool GamblingSystem::_checkItemValidity(Item *pItem)
+{
+    if(pItem == NULL || pItem->IsSoulBound() || pItem->IsBoundAccountWide() || pItem->IsBoundByEnchant())
+        return false;
+    return true;
+}
+
+bool GamblingSystem::_checkWithinLimits(Item *pItem)
+{
+    /*
+    * Here you can add your items that you want players to be able to use in the system. this is temporary.
+    * uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {ITEMID1,ITEMID2,ITEMID3};
+    */
+    uint32 GAMBLER_SYSTEM_ITEM_LIMITS [] = {20559};
+    for (uint32 i = 0; i < sizeof(GAMBLER_SYSTEM_ITEM_LIMITS)/sizeof(uint32); ++i){
+        if (pItem->GetEntry() == GAMBLER_SYSTEM_ITEM_LIMITS[i])
+            return true;
+    }
+    return false;
+}
+
+void GamblingSystem::_deleteMatchData(uint32 matchId)
+{
+    AcquireMatchLock();
+    GamblerMatchMap::iterator Itr = m_matchStorage.find(matchId);
+    if(Itr != m_matchStorage.end())
+        m_matchStorage.erase(Itr);
+    ReleaseMatchLock();
+}
+
+uint32 GamblingSystem::_generateMatchId()
+{
+    m_highMatchId++;
+    return m_highMatchId;
+}
+
+// Messaging
+void GamblingSystem::SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...)
+{
+    Player *pChallenger = ObjectAccessor::FindPlayer(matchData->GetChallengerGUID());
+    Player *pDefender    = ObjectAccessor::FindPlayer(matchData->GetDefenderGUID());
+
+    char Result[1024];
+    va_list List;
+    va_start(List, msgToSend);
+    vsnprintf(Result, 1024, msgToSend, List);
+    va_end(List);
+
+    if(pChallenger)
+        ChatHandler(pChallenger->GetSession()).PSendSysMessage(Result);
+    if(pDefender)
+        ChatHandler(pDefender->GetSession()).PSendSysMessage(Result);
+}
+
+// Mail System
+void GamblingSystem::_createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage)
+{
+    MailSender toSend(MAIL_NORMAL, playerGUID, GAMBLER_SYSTEM_MAIL_TYPE);
+    SQLTransaction trans = CharacterDatabase.BeginTransaction();
+    MailDraft mailDraft(GAMBLER_SYSTEM_MSG_MAIL_SUBJECT, mailMessage.c_str());
+
+    // extract items
+    typedef std::pair<uint32, uint32> ItemPair;
+    typedef std::list< ItemPair > ItemPairs;
+    ItemPairs items;
+    ItemTemplate const* item_proto = sObjectMgr->GetItemTemplate(itemId);
+    while (amount > item_proto->GetMaxStackSize())
+    {
+        items.push_back(ItemPair(itemId, item_proto->GetMaxStackSize()));
+        amount -= item_proto->GetMaxStackSize();
+    }
+    items.push_back(ItemPair(itemId, amount));
+
+    // TODO: items to be send is higher than the maximum items that a mail can hold!, security measure.
+    if (items.size() > MAX_MAIL_ITEMS){}
+
+    for(ItemPairs::const_iterator itr = items.begin(); itr != items.end(); ++itr)
+    {
+        if (Item* pItem = Item::CreateItem(itr->first, itr->second,pPlayer))
+        {
+           pItem->SaveToDB(trans);   // save for prevent lost at next mail load, if send fail then item will deleted
+           mailDraft.AddItem(pItem);
+        }
+    }
+
+    if(pPlayer){
+        mailDraft.SendMailTo(trans, MailReceiver(pPlayer), toSend);
+    }
+    else{
+        mailDraft.SendMailTo(trans, MailReceiver(playerGUID), toSend);
+    }
+    CharacterDatabase.CommitTransaction(trans);
+}
+
+// Called when a duel begins, check if both players have match data with each other
+void GamblerDuelScript::OnDuelRequest(Player *pDefender, Player *pChallenger)
+{
+    // To make sure we have the players and bug reporting
+    if(pDefender == NULL || pChallenger == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pDefender or pChallenger is NULL!");
+        return;}
+
+    GamblerMatchData *ChallengerMatchData = sGamblingSystem->GetMatchDataBy(pChallenger);
+    GamblerMatchData *DefenderMatchData = sGamblingSystem->GetMatchDataBy(pDefender);
+
+    // if challenger or defender has no existing match data, return.
+    if(ChallengerMatchData == NULL || DefenderMatchData == NULL){
+        return;
+    }// if challenger or defender has match data existing
+    else{
+        // if challenger's match id is not the same as the defender, and they both have match data.
+        // then challenger has requested duel from someone else with match data.
+        if(ChallengerMatchData->GetMatchId() != DefenderMatchData->GetMatchId()){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_SAME_PLAYER);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if the challenger has not set ready, or the defender has not set ready!
+        if(ChallengerMatchData->HasSetReady(pChallenger) == false || ChallengerMatchData->HasSetReady(pDefender) == false){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NOT_READY);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has no item id set, or defender has no item id set!
+        if(ChallengerMatchData->GetChallengerItemId() == NULL || ChallengerMatchData->GetDefenderItemId() == NULL){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_ITEM);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+        // if challenger has not set item count yet, or defender has not set item count yet!
+        if(ChallengerMatchData->GetChallengerItemCount() == NULL || ChallengerMatchData->GetDefenderItemCount() == NULL){
+            ChatHandler(pChallenger->GetSession()).SendSysMessage(ARENA_GAMBLER_MSG_NO_AMOUNT);
+            sGamblingSystem->CancelChallenge(pChallenger);
+        }
+
+    }
+}
+
+// Called when a duel ends, check if there is a match running or not.
+void GamblerDuelScript::OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type)
+{
+    // To make sure we have the players and bug reporting
+    if(pWinner == NULL || pLoser == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnDuelEnd pWinner or pLoser is NULL!");
+        return;}
+
+    GamblerMatchData *WinnerData = sGamblingSystem->GetMatchDataBy(pWinner);
+    GamblerMatchData *LoserData = sGamblingSystem->GetMatchDataBy(pLoser);
+
+    if(WinnerData == NULL || LoserData == NULL){
+        return;}
+    else if(WinnerData->GetMatchId() == LoserData->GetMatchId()){
+    sGamblingSystem->HandleMatchComplete(pWinner, pLoser, WinnerData, type);
+    }
+}
+
+// Called when a player logsout, if a player exists, check match data, if it started, if yes then complete the duel
+void GamblerDuelScript::OnLogout(Player *pPlayer)
+{
+    // To make sure we have the player and bug reporting
+    if(pPlayer == NULL){
+        TC_LOG_ERROR("Arena", "GamblerDuelScript: OnLogout pPlayer is NULL!");
+        return;}
+
+    GamblerMatchData *matchData = sGamblingSystem->GetMatchDataBy(pPlayer);
+    if(matchData == NULL){
+        return;}
+    else if(matchData->MatchStarted() && (matchData->GetChallengerGUID() == pPlayer->GetGUIDLow() || matchData->GetDefenderGUID() == pPlayer->GetGUIDLow()))
+            pPlayer->DuelComplete(DUEL_FLED);
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/ArenaGamblingSystem.h b/src/server/scripts/Custom/ArenaGamblingSystem.h
new file mode 100644
index 0000000..1c256d3
--- /dev/null
+++ b/src/server/scripts/Custom/ArenaGamblingSystem.h
@@ -0,0 +1,458 @@
+/*
+ * Author: Xees
+ * FileName: ArenaGamblingSystem.h
+ * Description: This file is used for definitions and requirements of the Arena Gambling System
+ * Version: 1.9
+ * Status: functional
+*/
+#ifndef ArenaGambler_H
+#define ArenaGambler_H
+
+// scriptName
+#define GAMBLER_SYSTEM_SCRIPT_NAME "custom_gambling_system_script"
+#define GAMBLER_SYSTEM_DUEL_SCRIPT_NAME "custom_gambler_duel_script"
+
+#define ARENA_GAMBLER_SCRIPT_NAME "duel_system"
+#define ARENA_RECORDS_SCRIPT_NAME "duel_records_system"
+
+enum ARENA_GAMBLER_MENUS
+{
+    ARENA_GAMBLER_MENU_MAIN    = 1,
+    ARENA_GAMBLER_MENU_CHALLENGE_PLAYER,
+    ARENA_GAMBLER_MENU_BET_ITEM,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_10,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_20,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_30,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_40,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_50,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_100,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_200,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_300,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_500,
+    ARENA_GAMBLER_MENU_BET_ITEM_AMOUNT_1000,
+    ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE,
+    ARENA_GAMBLER_MENU_CANCEL_CHALLENGE,
+    ARENA_GAMBLER_MENU_DECLINE_CHALLENGE,
+    ARENA_GAMBLER_MENU_EXIT
+};
+
+enum ARENA_GAMBLER_MENU_ICONS
+{
+    ARENA_GAMBLER_ICON_CHALLENGE    = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_CHALLENGE_PLAYER
+    ARENA_GAMBLER_ICON_BET_ITEM        = GOSSIP_ICON_MONEY_BAG,        // ARENA_GAMBLER_MENU_BET_ITEM
+    ARENA_GAMBLER_ICON_ACCEPT        = GOSSIP_ICON_BATTLE,            // ARENA_GAMBLER_MENU_ACCEPT_CHALLENGE
+    ARENA_GAMBLER_ICON_CANCEL        = GOSSIP_ICON_DOT,                // ARENA_GAMBLER_MENU_CANCEL_CHALLENGE
+    ARENA_GAMBLER_ICON_DECLINE        = GOSSIP_ICON_TAXI,                // ARENA_GAMBLER_MENU_DECLINE_CHALLENGE
+    ARENA_GAMBLER_ICON_EXIT            = GOSSIP_ICON_TABARD,            // ARENA_GAMBLER_MENU_EXIT
+};
+
+// Menu Texts
+#define ARENA_GAMBLER_TEXT_CHALLENGE "I would like to Challenge a player to a duel!"
+#define ARENA_GAMBLER_TEXT_CHALLENGE_CODE_TEXT "Enter the name of a player you wish to challenge. (Case Sensitive)"
+#define ARENA_GAMBLER_TEXT_BET_ITEM "I would like to Bet an item"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_CODE_TEXT "Enter the name of the item you wish to bet"
+#define ARENA_GAMBLER_TEXT_BET_ITEM_AMOUNT "I would like to enter the amount"
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_TEXT "Select the amount of items you wish to bet"
+#define ARENA_GAMBLER_TEXT_ACCEPT_CHALLENGE "I accept the challenge!"
+#define ARENA_GAMBLER_TEXT_CANCEL_CHALLENGE "I do not want to this challenge!"
+#define ARENA_GAMBLER_TEXT_DECLINE_CHALLENGE "I do not accept this challenge!"
+#define ARENA_GAMBLER_TEXT_EXIT "Nevermind"
+
+// Amount of bets Menu text -- TODO: write a more efficient way to override Opcode OnGossipSelectWithCode string restrictions
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1 "1 item."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_10 "10 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_20 "20 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_30 "30 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_40 "40 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_50 "50 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_100 "100 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_200 "200 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_300 "300 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_500 "500 items."
+#define ARENA_GAMBLER_TEXT_BET_AMOUNT_1000 "1000 items."
+
+// Mail System Defines
+#define GAMBLER_SYSTEM_MSG_MAIL_SUBJECT "The Judgment Arena : Rewards !"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_INCOMPLETE "Your item is being returned as the result of an incomplete match"
+#define GAMBLER_SYSTEM_MSG_MAIL_BODY_MATCH_WON "You've won the match!"
+#define GAMBLER_SYSTEM_MAIL_TYPE MAIL_STATIONERY_GM
+
+// Messages
+#define GAMBLER_SYSTEM_MSG_ACCEPTED_CHALLENGE "%s has accepted the challenge!" // %s = accepters name
+#define GAMBLER_SYSTEM_MSG_ITEM_BET_PLACED "%s has placed item %s up for bet!" // %s1 = players name %s2 = items name
+#define GAMBLER_SYSTEM_MSG_CANCELED "%s has %s the match!" // the first %s will utilize one of the below defines considering the player is either, the challenger canceling the match, or the defender canceling the match
+#define GAMBLER_SYSTEM_MSG_CANCELED_1 "Canceled"
+#define GAMBLER_SYSTEM_MSG_CANCELED_2 "Forfeit"
+#define GAMBLER_SYSTEM_MSG_CANT_LOCATE_PLAYER "Could not locate the second player, match aborted!"
+#define GAMBLER_SYSTEM_MSG_CANT_START_DUEL "Cannot start match while currently in a duel, or in combat."
+#define GAMBLER_SYSTEM_MSG_CANT_START_LOGGING "Cannot start the match while one fo the players is logging out!"
+#define GAMBLER_SYSTEM_MSG_MATCH_STARTING "The match is now underway!"
+#define GAMBLER_SYSTEM_MSG_DUEL_INTERRUPTED "The duel has been interrupted, items have been mailed back to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_FLED_NON_AWARD "items have been mailed to their original owners"
+#define GAMBLER_SYSTEM_MSG_DUEL_WON "%s has been mailed his match winnings!" // %s = winnerName
+#define GAMBLER_SYSTEM_MSG_ITEM_VALIDATE_FAIL "An invalid item has caused the match to be stopped!"
+#define GAMBLER_SYSTEM_MSG_ITEM_NO_INV "The amount of items you can bet is invalid!"
+#define ARENA_GAMBLER_MSG_NOT_SAME_PLAYER "That is not the same person i requested the duel with!"
+#define ARENA_GAMBLER_MSG_PLAYER_NOT_FOUND "The player might be offline or away at the moment , i was not able to locate the player."
+#define ARENA_GAMBLER_MSG_MATCH_NOT_POSSIBLE "Duel is not accepted because of the following: "
+#define ARENA_GAMBLER_MSG_NO_GMS_ALLOWED "Game Masters are not allowed to duel!"
+#define ARENA_GAMBLER_MSG_SAME_ACC_ID "You cannot duel your self!"
+#define ARENA_GAMBLER_MSG_NOT_READY "You or your opponent has not set ready for the duel!"
+#define ARENA_GAMBLER_MSG_NO_ITEM "You or your opponent did not specify an item id!"
+#define ARENA_GAMBLER_MSG_NO_AMOUNT "You or your opponent did not specify an item amount!"
+#define ARENA_GAMBLER_MSG_MULTI_BOX "You cannot duel anyone with the same ip address!"
+#define ARENA_GAMBLER_MSG_LOW_LEVEL "Your level is too low to duel"
+#define ARENA_GAMBLER_MSG_MATCH_DATA "You have requested a duel from someone who already is in a duel."
+#define ARENA_GAMBLER_MSG_DIFF_NOT_MET "Your level is too high or too low to duel this player."
+#define ARENA_GAMBLER_MSG_CHALLENGE_ISSUED "You have challenged %s to a duel!"    // %s = defenders name
+#define ARENA_GAMBLER_MSG_CHALLENGED "%s wants to challenge you to a duel!"        // %s = challengers name
+#define ARENA_GAMBLER_MSG_ITEM_ADD_FAILED "You may not have the item, or the item could be soulbound, or you are not allowed to bet that item."
+#define ARENA_GAMBLER_MSG_BET_ADD_FAILED "The maximum amount of items you can bet is %u" // %u = maximum bet
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_FAILED "You may not have the item, or your bet is not the same as your opponent, or you have chosen a higher bet that allowed, your not allowed to duel this item."
+#define ARENA_GAMBLER_MSG_BET_AMOUNT_TOO_HIGH "The maximum number of items the player can recieve is lower than the amount betted."
+#define ARENA_GAMBLER_MSG_ITEM_AMOUNT_SUCCESS "Your bet amount was entered successfully, please accept or reject the duel!"
+#define ARENA_GAMBLER_MSG_ITEM_ADD_SUCCESS "Your item was selected successfully, now select the amount you would like to bet!"
+
+// Intervals
+#define GAMBLER_SYSTEM_INTERVAL_TELE_CHECK 10000
+
+// Vars
+#define GAMBLER_SYSTEM_TOTAL_MAX_BET 1000
+
+#define MSG_COLOR_LIGHTRED      "|cffff6060"
+#define MSG_COLOR_LIGHTBLUE     "|cff00ccff"
+#define MSG_COLOR_BLUE          "|cff0000ff"
+#define MSG_COLOR_GREEN         "|cff00ff00"
+#define MSG_COLOR_RED           "|cffff0000"
+#define MSG_COLOR_GOLD          "|cffffcc00"
+#define MSG_COLOR_GREY          "|cff888888"
+#define MSG_COLOR_WHITE         "|cffffffff"
+#define MSG_COLOR_SUBWHITE      "|cffbbbbbb"
+#define MSG_COLOR_MAGENTA       "|cffff00ff"
+#define MSG_COLOR_YELLOW        "|cffffff00"
+#define MSG_COLOR_CYAN          "|cff00ffff"
+#define MSG_COLOR_ORANGE        "|cffff9900"
+
+#define QUALITY_POOR                 "cff9d9d9d"              //GREY
+#define QUALITY_NORMAL               "cffffffff"             //WHITE
+#define QUALITY_UNCOMMON             "cff1eff00"             //GREEN
+#define QUALITY_RARE                 "cff0070dd"             //BLUE
+#define QUALITY_EPIC                 "cffa335ee"             //PURPLE
+#define QUALITY_LEGENDARY            "cffff8000"             //ORANGE
+#define QUALITY_ARTIFACT             "cffe6cc80"             //LIGHT YELLOW
+#define QUALITY_HEIRLOOM             "cffe6cc80"              //LIGHT YELLOW
+
+enum MatchParticipants
+{
+    GAMBLER_CHALLENGER,
+    GAMBLER_DEFENDER,
+    GAMBLER_WINNER,
+    GAMBLER_MAX_MEMBERS,
+};
+
+enum GamberSystemConfigIndex
+{
+    GAMBLER_CONFIG_OPTION_MAPID,
+    GAMBLER_CONFIG_OPTION_COORDSX,
+    GAMBLER_CONFIG_OPTION_COORDSY,
+    GAMBLER_CONFIG_OPTION_COORDSZ,
+    GAMBLER_CONFIG_OPTION_COORDSO,
+    GAMBLER_CONFIG_OPTION_MIN_REQUIREDLEVEL,
+    GAMBLER_CONFIG_OPTION_MAX_LEVELDIFF,
+    GAMBLER_CONFIG_OPTION_AWARD_FLED,
+    GAMBLER_CONFIG_OPTION_MAX_BET,
+    GAMBLER_CONFIG_OPTION_ENABLE_GM,
+    GAMBLER_CONFIG_OPTION_ENABLE_SAMEIP,
+    GAMBLER_CONFIG_OPTION_ENABLE_LIMITS,
+    GAMBLER_CONFIG_OPTION_ONLY_CURRENCY,
+    GAMBLER_CONFIG_OPTION_EQUAL_DUELS
+};
+
+enum GamblerPlayerStatIndex
+{
+    GAMBLER_PLAYER_STAT_GUID,
+    GAMBLER_PLAYER_STAT_DUELS_LOST,
+    GAMBLER_PLAYER_STAT_DUELS_WON,
+    GAMBLER_PLAYER_STAT_DUELS_REFUSED,
+    GAMBLER_PLAYER_STAT_DUELS_TOTAL,
+    GAMBLER_PLAYER_STAT_MAX
+};
+
+enum GamblerMatchStatus
+{
+    GAMBLER_MATCH_STATUS_SETUP,
+    GAMBLER_MATCH_STATUS_TELEPORT,
+    GAMBLER_MATCH_STATUS_RUNNING,
+};
+
+struct GamblerMatchData
+{
+    public:
+        GamblerMatchData(uint32 Id, uint32 challengerGUID, uint32 defenderGUID)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            SetChallengerGUID(challengerGUID);
+            SetDefenderGUID(defenderGUID);
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+            SetMatchWinner(0);
+            matchId = Id;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                itemStorage[i] = 0;
+
+            for(uint8 i = 0; i < GAMBLER_MAX_MEMBERS-1; i++)
+                CountStorage[i] = 0;
+        }
+
+        GamblerMatchData(Field *pFields)
+        {
+            SetMatchStatus(GAMBLER_MATCH_STATUS_SETUP);
+            matchId    = pFields[0].GetUInt32();
+            SetChallengerGUID(pFields[1].GetUInt32());
+            SetDefenderGUID(pFields[2].GetUInt32());
+            SetChallengerItemId(pFields[3].GetUInt32());
+            SetChallengerItemCount(pFields[4].GetUInt32());
+            SetDefenderItemId(pFields[5].GetUInt32());
+            SetDefenderItemCount(pFields[6].GetUInt32());
+            SetMatchDate(pFields[7].GetString());
+            SetMatchWinner(pFields[8].GetUInt32());
+            SetChallengerReady(false);
+            SetDefenderReady(false);
+        }
+
+        // External Assignment Functions
+        void SetChallengerGUID(uint32 challengerGUID)    { _setMemberGUID(GAMBLER_CHALLENGER,    challengerGUID);    }
+        void SetDefenderGUID(uint32 defenderGUID)        { _setMemberGUID(GAMBLER_DEFENDER,        defenderGUID);        }
+        void SetChallengerItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_CHALLENGER,    itemId);            }
+        void SetDefenderItemId(uint32 itemId)            { _setMemberItemId(GAMBLER_DEFENDER,    itemId);            }
+        void SetChallengerItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_CHALLENGER,    amount);        }
+        void SetDefenderItemCount(uint32 amount)        { _setMemberItemCount(GAMBLER_DEFENDER,    amount);            }
+        void SetChallengerReady(bool isReady)            { _setMemberReady(GAMBLER_CHALLENGER,    isReady);            }
+        void SetDefenderReady(bool isReady)                { _setMemberReady(GAMBLER_DEFENDER,        isReady);            }
+        void SetMatchWinner(uint32 winnerGUID)            { _setMemberGUID(GAMBLER_WINNER,        winnerGUID);        }
+        void SetMatchDate(std::string matchTime)        { matchDate = matchTime;                                    }
+        void SetMatchStatus(GamblerMatchStatus status)    { matchStatus = status;                                        }
+
+        // External Retrieval Functions
+        uint32 GetChallengerGUID()                        { return _getMemberGUID(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderGUID()                        { return _getMemberGUID(GAMBLER_DEFENDER);                    }
+        uint32 GetChallengerItemId()                    { return _getMemberItemId(GAMBLER_CHALLENGER);                }
+        uint32 GetDefenderItemId()                        { return _getMemberItemId(GAMBLER_DEFENDER);                }
+        uint32 GetChallengerItemCount()                    { return _getMemberItemCount(GAMBLER_CHALLENGER);            }
+        uint32 GetDefenderItemCount()                    { return _getMemberItemCount(GAMBLER_DEFENDER);                }
+        uint32 GetMatchWinner()                            { return _getMemberGUID(GAMBLER_WINNER);                    }
+        uint32 GetMatchId()                                { return matchId;                                            }
+        uint8 GetMatchStatus()                            { return matchStatus;                                        }
+        bool GetChallengerReady()                        { return _getMemberReadyStatus(GAMBLER_CHALLENGER);            }
+        bool GetDefenderReady()                            { return _getMemberReadyStatus(GAMBLER_DEFENDER);            }
+        std::string GetMatchDate()                        { return matchDate;                                            }
+
+        bool MatchStarted()
+        {
+            if(GetMatchStatus() >= GAMBLER_MATCH_STATUS_TELEPORT)
+                return true;
+            return false;
+        }
+
+        bool HasSetReady(Player *pPlayer)
+        {
+            if(IsChallenger(pPlayer))
+                return GetChallengerReady();
+            else
+                return GetDefenderReady();
+        }
+
+        uint32 GetItemIdBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return GetChallengerItemId();
+            else
+                return GetDefenderItemId();
+        }
+
+        uint32 GetItemCountBy(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return GetChallengerItemCount();
+            else
+                return GetDefenderItemCount();
+        }
+
+        // Misc Functions
+        bool IsChallenger(Player *pPlayer)
+        {
+            if(pPlayer->GetGUIDLow() == GetChallengerGUID())
+                return true;
+            return false;
+        }
+
+        bool IsDefender(Player *pPlayer) { return !IsChallenger(pPlayer); }
+
+    private:
+        // Internal Assignment Functions
+        void _setMemberGUID(MatchParticipants matchMember, uint32 memberGUID) { guidStorage[matchMember] = memberGUID; }
+        void _setMemberItemId(MatchParticipants matchMember, uint32 itemId)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            itemStorage[matchMember] = itemId;
+        }
+        void _setMemberItemCount(MatchParticipants matchMember, uint32 amount)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            CountStorage[matchMember] = amount;
+        }
+
+        void _setMemberReady(MatchParticipants matchMember, bool isReady)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return;
+            readyStatus[matchMember] = isReady;
+        }
+
+        // Internal Retrieval Functions
+        uint32 _getMemberGUID(MatchParticipants matchMember) { return guidStorage[matchMember]; }
+        uint32 _getMemberItemId(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return itemStorage[matchMember];
+        }
+        uint32 _getMemberItemCount(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return 0;
+            return CountStorage[matchMember];
+        }
+
+        bool _getMemberReadyStatus(MatchParticipants matchMember)
+        {
+            if(matchMember > GAMBLER_DEFENDER)
+                return false;
+            return readyStatus[matchMember];
+        }
+
+    protected:
+        uint32 guidStorage[GAMBLER_MAX_MEMBERS];
+        uint32 itemStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 CountStorage[GAMBLER_MAX_MEMBERS-1];
+        uint32 matchId;
+        GamblerMatchStatus matchStatus;
+        bool readyStatus[GAMBLER_MAX_MEMBERS-1];
+        std::string matchDate;
+};
+
+typedef std::map<uint32, GamblerMatchData*> GamblerMatchMap;
+class GamblingSystem : public WorldScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+        GamblingSystem();
+        ~GamblingSystem();
+
+        // Creation
+        void Initalize();
+
+        // Events
+        // Called on every world tick (don't execute too heavy code here).
+        void OnUpdate(uint32 diff);
+
+        // Database Interaction
+        void LoadConfigData();
+
+        // Match Data Retrieval
+        GamblerMatchData *GetMatchDataBy(Player *pPlayer);
+
+        // Match Requirements Checking
+        bool CanHaveMatch(Player *pChallenger, Player *pDefender);
+
+        // Match Setup
+        void SetupMatch(Player *pChallenger, Player *pDefender);
+        bool AddItemForMatch(Player *pPlayer, std::string itemName);
+        bool AddItemAmountForMatch(Player *pPlayer, uint32 amount);
+        void AcceptChallenge(Player *pPlayer);
+        void CancelChallenge(Player *pPlayer);
+
+        std::string GetQualityColor(int32 qualityType) const;
+
+        // Match Completion
+        void HandleMatchComplete(Player *pWinner, Player *pLoser, GamblerMatchData *matchData, DuelCompleteType completeType);
+
+        // Messaging
+        void SendMessageToPlayers(GamblerMatchData *matchData, const char *msgToSend, ...);
+
+
+    private:
+        // Database Interaction
+        void _loadPastMatches();
+        void _saveCurrentMatchProgress(GamblerMatchData *matchData);
+        void _updatePlayerStats(uint32 playerGUID, GamblerPlayerStatIndex statIndex, uint32 statIncreaseValue);
+
+        // Mail System
+        void _createItemAndMailToPlayer(Player *pPlayer, uint32 playerGUID, uint32 itemId, uint32 amount, std::string mailMessage);
+
+        // Mutex Wrappers
+        void AcquireMatchLock()
+        {
+            std::lock_guard<std::mutex> lock(_matchLock);
+        }
+        void ReleaseMatchLock()
+        {
+            std::lock_guard<std::mutex> unlock(_matchLock);
+        }
+        // Match Data
+        bool _checkItemValidity(Item *pItem);
+        bool _checkItemValidity(uint32 itemId);
+        bool _checkWithinLimits(Item *pItem);
+        void _deleteMatchData(Player *pPlayer);
+        void _deleteMatchData(uint32 matchId);
+        uint32 _generateMatchId();
+    protected:
+
+        // Matches
+        std::mutex _matchLock;
+        GamblerMatchMap m_matchStorage;
+        IntervalTimer m_checkMatches;
+
+        // Config Data
+        WorldLocation m_arenaCoords;
+        uint32 m_minRequiredLevel;
+        uint8 m_maxLevelDiff;
+        uint32 m_highMatchId;
+        bool m_awardFled;
+        uint32 m_maxBet;
+        bool m_enableGM;
+        bool m_enableSameip;
+        bool m_enableLimits;
+        bool m_onlyCurrency;
+        bool m_equalDuels;
+};
+
+class GamblerDuelScript : PlayerScript
+{
+    public:
+    static GamblingSystem* instance()
+    {
+        static GamblingSystem* instance = new GamblingSystem();
+        return instance;
+    }
+    GamblerDuelScript() : PlayerScript(GAMBLER_SYSTEM_DUEL_SCRIPT_NAME) {}
+
+     // Called when a duel is requested
+    void OnDuelRequest(Player *pDefender, Player *pChallenger);
+    // Called when a duel ends
+    void OnDuelEnd(Player *pWinner, Player *pLoser, DuelCompleteType type);
+    // Called when a player logsout
+    void OnLogout(Player *pPlayer);
+};
+
+#define sGamblingSystem GamblingSystem::instance()
+#endif
\ No newline at end of file
diff --git a/src/server/scripts/Custom/CMakeLists.txt b/src/server/scripts/Custom/CMakeLists.txt
index 80ebe36..20c2bc9 100644
--- a/src/server/scripts/Custom/CMakeLists.txt
+++ b/src/server/scripts/Custom/CMakeLists.txt
@@ -8,11 +8,11 @@
 # WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 # implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 
-# file(GLOB_RECURSE sources_Custom Custom/*.cpp Custom/*.h)
+file(GLOB_RECURSE sources_Custom Custom/*.cpp Custom/*.h)
 
 set(scripts_STAT_SRCS
   ${scripts_STAT_SRCS}
-#  ${sources_Custom}
+  ${sources_Custom}
 )
 
 message("  -> Prepared: Custom")
diff --git a/src/server/scripts/Custom/Reforging.cpp b/src/server/scripts/Custom/Reforging.cpp
new file mode 100644
index 0000000..ff16b5e
--- /dev/null
+++ b/src/server/scripts/Custom/Reforging.cpp
@@ -0,0 +1,646 @@
+#include "ScriptPCH.h"
+
+/*
+Reforging by Rochet2
+https://rochet2.github.io/?page=Transmogrification
+
+Rules of thumb:
+Item can be reforged once.
+Item reforge wont show to anyone but you in tooltips. Stats will be there nevertheless.
+You will see the increased stats on all tooltips of the same item you reforged.
+You can disable the stat changes to tooltips by setting send_cache_packets to false.
+Reforges are stripped when you mail, ah, guildbank the item etc. Only YOU can have the reforge.
+Only item base stats are reforgable. Enchants and random stats are not.
+
+This script is made blizzlike. This means that the reforgable stats etc are from CATACLYSM!
+I have been informed that some stats were removed etc that would be important to be reforgable.
+However I do not know what those stats are currently. Do look through the statTypes to add whatever you want.
+Edit IsReforgable is you want to tweak requirements
+
+*/
+
+static const bool send_cache_packets = true;    // change player cache?
+
+// Remember to add to GetStatName too
+static const ItemModType statTypes[] = { ITEM_MOD_SPIRIT, ITEM_MOD_DODGE_RATING, ITEM_MOD_PARRY_RATING, ITEM_MOD_HIT_RATING, ITEM_MOD_CRIT_RATING, ITEM_MOD_HASTE_RATING, ITEM_MOD_EXPERTISE_RATING };
+static const uint8 stat_type_max = sizeof(statTypes) / sizeof(*statTypes);
+
+static const char* GetStatName(uint32 ItemStatType)
+{
+    switch(ItemStatType)
+    {
+    case ITEM_MOD_SPIRIT                   	: return "Spirit"; break;
+    case ITEM_MOD_DODGE_RATING             	: return "Dodge rating"; break;
+    case ITEM_MOD_PARRY_RATING             	: return "Parry rating"; break;
+    case ITEM_MOD_HIT_RATING               	: return "Hit rating"; break;
+    case ITEM_MOD_CRIT_RATING              	: return "Crit rating"; break;
+    case ITEM_MOD_HASTE_RATING             	: return "Haste rating"; break;
+    case ITEM_MOD_EXPERTISE_RATING         	: return "Expertise rating"; break;
+    default: return NULL;
+    }
+}
+
+static const char* GetSlotName(uint8 slot, WorldSession* session)
+{
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD      : return "Head";
+    case EQUIPMENT_SLOT_NECK      : return "Neck";
+    case EQUIPMENT_SLOT_SHOULDERS : return "Shoulders";
+    case EQUIPMENT_SLOT_BODY      : return "Shirt";
+    case EQUIPMENT_SLOT_CHEST     : return "Chest";
+    case EQUIPMENT_SLOT_WAIST     : return "Waist";
+    case EQUIPMENT_SLOT_LEGS      : return "Legs";
+    case EQUIPMENT_SLOT_FEET      : return "Feet";
+    case EQUIPMENT_SLOT_WRISTS    : return "Wrists";
+    case EQUIPMENT_SLOT_HANDS     : return "Hands";
+    case EQUIPMENT_SLOT_FINGER1   : return "Right finger";
+    case EQUIPMENT_SLOT_FINGER2   : return "Left finger";
+    case EQUIPMENT_SLOT_TRINKET1  : return "Right trinket";
+    case EQUIPMENT_SLOT_TRINKET2  : return "Left trinket";
+    case EQUIPMENT_SLOT_BACK      : return "Back";
+    case EQUIPMENT_SLOT_MAINHAND  : return "Main hand";
+    case EQUIPMENT_SLOT_OFFHAND   : return "Off hand";
+    case EQUIPMENT_SLOT_TABARD    : return "Tabard";
+    case EQUIPMENT_SLOT_RANGED    : return "Ranged";
+    default: return NULL;
+    }
+}
+
+static uint32 Melt(uint8 i, uint8 j)
+{
+    return (i << 8) + j;
+}
+
+static void Unmelt(uint32 melt, uint8& i, uint8& j)
+{
+    i = melt >> 8;
+    j = melt & 0xFF;
+}
+
+static std::vector<Item*> GetItemList(const Player* player)
+{
+    std::vector<Item*> itemlist;
+
+    // Copy paste from Player::GetItemByGuid(guid)
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem);
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem);
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem);
+
+    return itemlist;
+}
+
+static Item* GetEquippedItem(Player* player, uint32 guidlow)
+{
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            if (pItem->GetGUIDLow() == guidlow)
+                return pItem;
+    return NULL;
+}
+
+void RemoveReforge(Player* player, uint32 itemguid, bool update);
+
+// Supply lowguid or reforge! (or both)
+// Warning, this function may modify player->reforgeMap when lowguid is supplied
+static void SendReforgePacket(Player* player, uint32 entry, uint32 lowguid = 0, const ReforgeData* reforge = NULL)
+{
+    ItemTemplate const* pProto = sObjectMgr->GetItemTemplate(entry);
+    if (!pProto)
+        return;
+
+    if (lowguid)
+    {
+        if (!player->reforgeMap.empty() && player->reforgeMap.find(lowguid) != player->reforgeMap.end())
+            reforge = &player->reforgeMap[lowguid];
+        else
+            RemoveReforge(player, lowguid, true);
+    }
+
+    // Update player cache (self only) pure visual.
+    // HandleItemQuerySingleOpcode copy paste
+    std::string Name        = pProto->Name1;
+    std::string Description = pProto->Description;
+    int loc_idx = player->GetSession()->GetSessionDbLocaleIndex();
+    if (loc_idx >= 0)
+    {
+        if (ItemLocale const* il = sObjectMgr->GetItemLocale(pProto->ItemId))
+        {
+            ObjectMgr::GetLocaleString(il->Name, loc_idx, Name);
+            ObjectMgr::GetLocaleString(il->Description, loc_idx, Description);
+        }
+    }
+    WorldPacket data(SMSG_ITEM_QUERY_SINGLE_RESPONSE, 600);
+    data << pProto->ItemId;
+    data << pProto->Class;
+    data << pProto->SubClass;
+    data << pProto->SoundOverrideSubclass;
+    data << Name;
+    data << uint8(0x00);                                //pProto->Name2; // blizz not send name there, just uint8(0x00); <-- \0 = empty string = empty name...
+    data << uint8(0x00);                                //pProto->Name3; // blizz not send name there, just uint8(0x00);
+    data << uint8(0x00);                                //pProto->Name4; // blizz not send name there, just uint8(0x00);
+    data << pProto->DisplayInfoID;
+    data << pProto->Quality;
+    data << pProto->Flags;
+    data << pProto->Flags2;
+    data << pProto->BuyPrice;
+    data << pProto->SellPrice;
+    data << pProto->InventoryType;
+    data << pProto->AllowableClass;
+    data << pProto->AllowableRace;
+    data << pProto->ItemLevel;
+    data << pProto->RequiredLevel;
+    data << pProto->RequiredSkill;
+    data << pProto->RequiredSkillRank;
+    data << pProto->RequiredSpell;
+    data << pProto->RequiredHonorRank;
+    data << pProto->RequiredCityRank;
+    data << pProto->RequiredReputationFaction;
+    data << pProto->RequiredReputationRank;
+    data << int32(pProto->MaxCount);
+    data << int32(pProto->Stackable);
+    data << pProto->ContainerSlots;
+    data << pProto->StatsCount + (reforge ? 1 : 0); // increase stat count by 1
+    bool decreased = false;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        data << pProto->ItemStat[i].ItemStatType;
+        if (reforge && !decreased && pProto->ItemStat[i].ItemStatType == reforge->decrease)
+        {
+            data << pProto->ItemStat[i].ItemStatValue-reforge->stat_value;
+            decreased = true;
+        }
+        else
+            data << pProto->ItemStat[i].ItemStatValue;
+    }
+    if (reforge)
+    {
+        data << reforge->increase;      // set new stat type
+        data << reforge->stat_value;    // and value
+    }
+    data << pProto->ScalingStatDistribution;            // scaling stats distribution
+    data << pProto->ScalingStatValue;                   // some kind of flags used to determine stat values column
+    for (int i = 0; i < MAX_ITEM_PROTO_DAMAGES; ++i)
+    {
+        data << pProto->Damage[i].DamageMin;
+        data << pProto->Damage[i].DamageMax;
+        data << pProto->Damage[i].DamageType;
+    }
+
+    // resistances (7)
+    data << pProto->Armor;
+    data << pProto->HolyRes;
+    data << pProto->FireRes;
+    data << pProto->NatureRes;
+    data << pProto->FrostRes;
+    data << pProto->ShadowRes;
+    data << pProto->ArcaneRes;
+
+    data << pProto->Delay;
+    data << pProto->AmmoType;
+    data << pProto->RangedModRange;
+
+    for (int s = 0; s < MAX_ITEM_PROTO_SPELLS; ++s)
+    {
+        // send DBC data for cooldowns in same way as it used in Spell::SendSpellCooldown
+        // use `item_template` or if not set then only use spell cooldowns
+        SpellInfo const* spell = sSpellMgr->GetSpellInfo(pProto->Spells[s].SpellId);
+        if (spell)
+        {
+            bool db_data = pProto->Spells[s].SpellCooldown >= 0 || pProto->Spells[s].SpellCategoryCooldown >= 0;
+
+            data << pProto->Spells[s].SpellId;
+            data << pProto->Spells[s].SpellTrigger;
+            data << uint32(-abs(pProto->Spells[s].SpellCharges));
+
+            if (db_data)
+            {
+                data << uint32(pProto->Spells[s].SpellCooldown);
+                data << uint32(pProto->Spells[s].SpellCategory);
+                data << uint32(pProto->Spells[s].SpellCategoryCooldown);
+            }
+            else
+            {
+                data << uint32(spell->RecoveryTime);
+                data << uint32(spell->GetCategory());
+                data << uint32(spell->CategoryRecoveryTime);
+            }
+        }
+        else
+        {
+            data << uint32(0);
+            data << uint32(0);
+            data << uint32(0);
+            data << uint32(-1);
+            data << uint32(0);
+            data << uint32(-1);
+        }
+    }
+    data << pProto->Bonding;
+    data << Description;
+    data << pProto->PageText;
+    data << pProto->LanguageID;
+    data << pProto->PageMaterial;
+    data << pProto->StartQuest;
+    data << pProto->LockID;
+    data << int32(pProto->Material);
+    data << pProto->Sheath;
+    data << pProto->RandomProperty;
+    data << pProto->RandomSuffix;
+    data << pProto->Block;
+    data << pProto->ItemSet;
+    data << pProto->MaxDurability;
+    data << pProto->Area;
+    data << pProto->Map;                                // Added in 1.12.x & 2.0.1 client branch
+    data << pProto->BagFamily;
+    data << pProto->TotemCategory;
+    for (int s = 0; s < MAX_ITEM_PROTO_SOCKETS; ++s)
+    {
+        data << pProto->Socket[s].Color;
+        data << pProto->Socket[s].Content;
+    }
+    data << pProto->socketBonus;
+    data << pProto->GemProperties;
+    data << pProto->RequiredDisenchantSkill;
+    data << pProto->ArmorDamageModifier;
+    data << pProto->Duration;                           // added in 2.4.2.8209, duration (seconds)
+    data << pProto->ItemLimitCategory;                  // WotLK, ItemLimitCategory
+    data << pProto->HolidayId;                          // Holiday.dbc?
+    player->GetSession()->SendPacket(&data);
+}
+
+static void SendReforgePackets(Player* player)
+{
+    if (!send_cache_packets)
+        return;
+
+    std::vector<Item*> items = GetItemList(player);
+    for (std::vector<Item*>::const_iterator it = items.begin(); it != items.end(); ++it)
+        SendReforgePacket(player, (*it)->GetEntry(), (*it)->GetGUIDLow());
+}
+
+void RemoveReforge(Player* player, uint32 itemguid, bool update)
+{
+    uint32 lowguid = player->GetGUIDLow();
+    if (!itemguid || player->reforgeMap.empty() ||
+        player->reforgeMap.find(itemguid) == player->reforgeMap.end())
+        return;
+
+    player->reforgeMap.erase(itemguid);
+    Item* invItem = update ? player->GetItemByGuid(MAKE_NEW_GUID(itemguid, 0, HIGHGUID_ITEM)) : NULL;
+    if (invItem)
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+    player->reforgeMap.erase(itemguid);
+    if (invItem)
+        player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+
+    //if (!database)
+    //    return;
+    //CharacterDatabase.PExecute("DELETE FROM `custom_reforging` WHERE `GUID` = %u", itemguid);
+    if (invItem)
+        SendReforgePacket(player, invItem->GetEntry());
+    //player->SaveToDB();
+}
+
+static bool IsReforgable(Item* invItem, Player* player)
+{
+    //if (!invItem->IsEquipped())
+    //    return false;
+    if (invItem->GetOwnerGUID() != player->GetGUID())
+        return false;
+    const ItemTemplate* pProto = invItem->GetTemplate();
+    //if (pProto->ItemLevel < 200)
+    //    return false;
+    //if (pProto->Quality == ITEM_QUALITY_HEIRLOOM) // block heirlooms necessary?
+    //    return false;
+    if (!pProto->StatsCount || pProto->StatsCount >= MAX_ITEM_PROTO_STATS) // Mandatory! Do NOT remove or edit
+        return false;
+    if (!player->reforgeMap.empty() && player->reforgeMap.find(invItem->GetGUIDLow()) != player->reforgeMap.end()) // Mandatory! Do NOT remove or edit
+        return false;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        if (!GetStatName(pProto->ItemStat[i].ItemStatType))
+            continue;
+        if (((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f)) > 1)
+            return true;
+    }
+    return false;
+}
+
+static void UpdatePlayerReforgeStats(Item* invItem, Player* player, uint32 decrease, uint32 increase) // stat types
+{
+    const ItemTemplate* pProto = invItem->GetTemplate();
+
+    int32 stat_diff = 0;
+    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+    {
+        if (pProto->ItemStat[i].ItemStatType == increase)
+            return; // Should not have the increased stat already
+        if (pProto->ItemStat[i].ItemStatType == decrease)
+            stat_diff = (int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f);
+    }
+    if (stat_diff <= 0)
+        return; // Should have some kind of diff
+
+    // Update player stats
+    player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+    uint32 guidlow = invItem->GetGUIDLow();
+    ReforgeData& data = player->reforgeMap[guidlow];
+    data.increase = increase;
+    data.decrease = decrease;
+    data.stat_value = stat_diff;
+    player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+    // CharacterDatabase.PExecute("REPLACE INTO `custom_reforging` (`GUID`, `increase`, `decrease`, `stat_value`) VALUES (%u, %u, %u, %i)", guidlow, increase, decrease, stat_diff);
+    player->ModifyMoney(pProto->SellPrice < (10*GOLD) ? (-10*GOLD) : -(int32)pProto->SellPrice);
+    SendReforgePacket(player, invItem->GetEntry(), 0, &data);
+    // player->SaveToDB();
+}
+
+class REFORGE_PLAYER : public PlayerScript
+{
+public:
+    REFORGE_PLAYER() : PlayerScript("REFORGE_PLAYER")
+    {
+        CharacterDatabase.DirectExecute("DELETE FROM `custom_reforging` WHERE NOT EXISTS (SELECT 1 FROM `item_instance` WHERE `item_instance`.`guid` = `custom_reforging`.`GUID`)");
+    }
+
+    class SendRefPackLogin : public BasicEvent
+    {
+    public:
+        SendRefPackLogin(Player* _player) : player(_player)
+        {
+            _player->m_Events.AddEvent(this, _player->m_Events.CalculateTime(1000));
+        }
+
+        bool Execute(uint64, uint32) override
+        {
+            SendReforgePackets(player);
+            return true;
+        }
+        Player* player;
+    };
+
+    void OnLogin(Player* player, bool firstLogin) override
+    {
+        uint32 playerGUID = player->GetGUIDLow();
+        QueryResult result = CharacterDatabase.PQuery("SELECT `GUID`, `increase`, `decrease`, `stat_value` FROM `custom_reforging` WHERE `Owner` = %u", playerGUID);
+        if (result)
+        {
+            do
+            {
+                uint32 lowGUID = (*result)[0].GetUInt32();
+                Item* invItem = player->GetItemByGuid(MAKE_NEW_GUID(lowGUID, 0, HIGHGUID_ITEM));
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), false);
+                ReforgeData& data = player->reforgeMap[lowGUID];
+                data.increase = (*result)[1].GetUInt32();
+                data.decrease = (*result)[2].GetUInt32();
+                data.stat_value = (*result)[3].GetInt32();
+                if (invItem)
+                    player->_ApplyItemMods(invItem, invItem->GetSlot(), true);
+                // SendReforgePacket(player, entry, lowGUID);
+            } while (result->NextRow());
+
+            // SendReforgePackets(player);
+            new SendRefPackLogin(player);
+        }
+    }
+
+    //void OnLogout(Player* player) override
+    //{
+    //    if (player->reforgeMap.empty())
+    //        return;
+    //    for (ReforgeMapType::const_iterator it = player->reforgeMap.begin(); it != player->reforgeMap.end();)
+    //    {
+    //        ReforgeMapType::const_iterator old_it = it++;
+    //        RemoveReforge(player, old_it->first, false);
+    //    }
+    //}
+
+    void OnSave(Player* player) override
+    {
+        uint32 lowguid = player->GetGUIDLow();
+        SQLTransaction trans = CharacterDatabase.BeginTransaction();
+        trans->PAppend("DELETE FROM `custom_reforging` WHERE `Owner` = %u", lowguid);
+        if (!player->reforgeMap.empty())
+        {
+            // Only save items that are in inventory / bank / etc
+            std::vector<Item*> items = GetItemList(player);
+            for (std::vector<Item*>::const_iterator it = items.begin(); it != items.end(); ++it)
+            {
+                ReforgeMapType::const_iterator it2 = player->reforgeMap.find((*it)->GetGUIDLow());
+                if (it2 == player->reforgeMap.end())
+                    continue;
+
+                trans->PAppend("REPLACE INTO `custom_reforging` (`GUID`, `increase`, `decrease`, `stat_value`, `Owner`) VALUES (%u, %u, %u, %i, %u)", it2->first, it2->second.increase, it2->second.decrease, it2->second.stat_value, lowguid);
+            }
+        }
+
+        if (trans->GetSize()) // basically never false
+            CharacterDatabase.CommitTransaction(trans);
+    }
+};
+
+class REFORGER_NPC : public CreatureScript
+{
+public:
+    REFORGER_NPC() : CreatureScript("REFORGER_NPC") { }
+
+    bool OnGossipHello(Player* player, Creature* creature) override
+    {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot of the item to reforge:", 0, Melt(MAIN_MENU, 0));
+        for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+        {
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                if (IsReforgable(invItem, player))
+                    if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, slotname, 0, Melt(SELECT_STAT_REDUCE, slot));
+        }
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, "Remove reforges", 0, Melt(SELECT_RESTORE, 0));
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", 0, Melt(MAIN_MENU, 0));
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        return true;
+    }
+
+    bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 melt) override
+    {
+        player->PlayerTalkClass->ClearMenus();
+
+        uint8 menu, action;
+        Unmelt(melt, menu, action);
+
+        switch (menu)
+        {
+        case MAIN_MENU: OnGossipHello(player, creature); break;
+        case SELECT_STAT_REDUCE:
+            // action = slot
+            if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+            {
+                if (IsReforgable(invItem, player))
+                {
+                    uint32 guidlow = invItem->GetGUIDLow();
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to decrease:", sender, melt);
+                    for (uint32 i = 0; i < pProto->StatsCount; ++i)
+                    {
+                        int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[i].ItemStatValue * 0.4f));
+                        if (stat_diff > 1)
+                            if (const char* stat_name = GetStatName(pProto->ItemStat[i].ItemStatType))
+                            {
+                                std::ostringstream oss;
+                                oss << stat_name << " (" << pProto->ItemStat[i].ItemStatValue << " |cFFDB2222-" << stat_diff << "|r)";
+                                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TRAINER, oss.str(), guidlow, Melt(SELECT_STAT_INCREASE, i));
+                            }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(MAIN_MENU, 0));
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            else
+            {
+                player->GetSession()->SendNotification("Invalid item selected");
+                OnGossipHello(player, creature);
+            }
+            break;
+        case SELECT_STAT_INCREASE:
+            // sender = item guidlow
+            // action = StatsCount id
+            {
+                Item* invItem = GetEquippedItem(player, sender);
+                if (invItem)
+                {
+                    const ItemTemplate* pProto = invItem->GetTemplate();
+                    int32 stat_diff = ((int32)floorf((float)pProto->ItemStat[action].ItemStatValue * 0.4f));
+
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Stat to increase:", sender, melt);
+                    for (uint8 i = 0; i < stat_type_max; ++i)
+                    {
+                        bool cont = false;
+                        for (uint32 j = 0; j < pProto->StatsCount; ++j)
+                        {
+                            if (statTypes[i] == pProto->ItemStat[j].ItemStatType) // skip existing stats on item
+                            {
+                                cont = true;
+                                break;
+                            }
+                        }
+                        if (cont)
+                            continue;
+                        if (const char* stat_name = GetStatName(statTypes[i]))
+                        {
+                            std::ostringstream oss;
+                            oss << stat_name << " |cFF3ECB3C+" << stat_diff << "|r";
+                            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, oss.str(), sender, Melt(i, (uint8)pProto->ItemStat[action].ItemStatType), "Are you sure you want to reforge\n\n" + pProto->Name1, (pProto->SellPrice < (10 * GOLD) ? (10 * GOLD) : pProto->SellPrice), false);
+                        }
+                    }
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(SELECT_STAT_REDUCE, invItem->GetSlot()));
+                    player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+                }
+                else
+                {
+                    player->GetSession()->SendNotification("Invalid item selected");
+                    OnGossipHello(player, creature);
+                }
+            }
+            break;
+        case SELECT_RESTORE:
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Select slot to remove reforge from:", sender, melt);
+                if (!player->reforgeMap.empty())
+                {
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (Item* invItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                            if (player->reforgeMap.find(invItem->GetGUIDLow()) != player->reforgeMap.end())
+                                if (const char* slotname = GetSlotName(slot, player->GetSession()))
+                                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_INTERACT_1, slotname, invItem->GetGUIDLow(), Melt(RESTORE, 0), "Remove reforge from\n\n" + invItem->GetTemplate()->Name1, 0, false);
+                    }
+                }
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Update menu", sender, melt);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, "Back..", 0, Melt(MAIN_MENU, 0));
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            }
+            break;
+        case RESTORE:
+            // sender = item guidlow
+            {
+                if (Item* invItem = player->GetItemByGuid(MAKE_NEW_GUID(sender, 0, HIGHGUID_ITEM)))
+                {
+                    if (!player->reforgeMap.empty() && player->reforgeMap.find(sender) != player->reforgeMap.end())
+                        RemoveReforge(player, sender, true);
+                }
+                OnGossipHello(player, creature);
+            }
+            break;
+        default: // Reforge
+            // sender = item guidlow
+            // menu = stat type to increase index to statTypes[]
+            // action = stat type to decrease
+            {
+                if (menu < stat_type_max)
+                {
+                    Item* invItem = GetEquippedItem(player, sender);
+                    if (invItem && IsReforgable(invItem, player))
+                    {
+                        if (player->HasEnoughMoney(invItem->GetTemplate()->SellPrice < (10 * GOLD) ? (10 * GOLD) : invItem->GetTemplate()->SellPrice))
+                        {
+                            // int32 stat_diff = ((int32)floorf((float)invItem->GetTemplate()->ItemStat[action].ItemStatValue * 0.4f));
+                            UpdatePlayerReforgeStats(invItem, player, action, statTypes[menu]); // rewrite this function
+                        }
+                        else
+                            player->GetSession()->SendNotification("Not enough money");
+                    }
+                    else
+                        player->GetSession()->SendNotification("Invalid item selected");
+                }
+                OnGossipHello(player, creature);
+            }
+        }
+        return true;
+    }
+
+    enum Menus
+    {
+        MAIN_MENU = 200, // stat_type_max
+        SELECT_ITEM,
+        SELECT_STAT_REDUCE,
+        SELECT_STAT_INCREASE,
+        SELECT_RESTORE,
+        RESTORE,
+        REFORGE,
+    };
+};
+
+void AddSC_REFORGER_NPC()
+{
+    new REFORGER_NPC;
+    new REFORGE_PLAYER;
+}
+
+#undef FOR_REFORGE_ITEMS
diff --git a/src/server/scripts/Custom/Transmogrification.cpp b/src/server/scripts/Custom/Transmogrification.cpp
new file mode 100644
index 0000000..ce95786
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.cpp
@@ -0,0 +1,838 @@
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Language.h"
+#include "Transmogrification.h"
+
+#ifdef PRESETS
+void Transmogrification::PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::PresetTransmog");
+
+    if (!EnableSets)
+        return;
+    if (!player || !itemTransmogrified)
+        return;
+    if (slot >= EQUIPMENT_SLOT_END)
+        return;
+    if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), sObjectMgr->GetItemTemplate(fakeEntry)))
+        return;
+
+    SetFakeEntry(player, itemTransmogrified, fakeEntry);
+
+    itemTransmogrified->UpdatePlayedTime(player);
+
+    itemTransmogrified->SetOwnerGUID(player->GetGUID());
+    itemTransmogrified->SetNotRefundable(player);
+    itemTransmogrified->ClearSoulboundTradeable(player);
+}
+
+void Transmogrification::LoadPlayerSets(Player* player)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadPlayerSets");
+
+    player->presetMap.clear();
+
+    QueryResult result = CharacterDatabase.PQuery("SELECT `PresetID`, `SetName`, `SetData` FROM `custom_transmogrification_sets` WHERE Owner = %u", player->GetGUIDLow());
+    if (!result)
+        return;
+
+    do
+    {
+        Field* field = result->Fetch();
+        uint8 PresetID = field[0].GetUInt8();
+        std::string SetName = field[1].GetString();
+        std::istringstream SetData(field[2].GetString());
+
+        player->presetMap[PresetID].name = SetName;
+
+        while (SetData.good())
+        {
+            uint32 slot;
+            uint32 entry;
+            SetData >> slot >> entry;
+            if (SetData.fail())
+                break;
+            if (slot >= EQUIPMENT_SLOT_END)
+            {
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) has invalid slot, ignoring.", entry, player->GetGUIDLow(), uint32(slot), uint32(PresetID));
+                continue;
+            }
+            if (sObjectMgr->GetItemTemplate(entry))
+            {
+                player->presetMap[PresetID].slotMap[slot] = entry;
+            }
+            else
+                TC_LOG_ERROR("custom.transmog", "Item entry (FakeEntry: %u, playerGUID: %u, slot: %u, presetId: %u) does not exist, ignoring.", entry, player->GetGUIDLow(), uint32(slot), uint32(PresetID));
+        }
+
+        if (player->presetMap[PresetID].slotMap.empty())
+        {
+            // Should never happen
+            player->presetMap.erase(PresetID);
+            CharacterDatabase.PExecute("DELETE FROM `custom_transmogrification_sets` WHERE Owner = %u AND PresetID = %u", player->GetGUIDLow(), uint32(PresetID));
+            return;
+        }
+
+    } while (result->NextRow());
+}
+#endif
+
+const char* Transmogrification::GetSlotName(uint8 slot, WorldSession* /*session*/) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotName");
+
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD: return  "Head";// session->GetTrinityString(LANG_SLOT_NAME_HEAD);
+    case EQUIPMENT_SLOT_SHOULDERS: return  "Shoulders";// session->GetTrinityString(LANG_SLOT_NAME_SHOULDERS);
+    case EQUIPMENT_SLOT_BODY: return  "Shirt";// session->GetTrinityString(LANG_SLOT_NAME_BODY);
+    case EQUIPMENT_SLOT_CHEST: return  "Chest";// session->GetTrinityString(LANG_SLOT_NAME_CHEST);
+    case EQUIPMENT_SLOT_WAIST: return  "Waist";// session->GetTrinityString(LANG_SLOT_NAME_WAIST);
+    case EQUIPMENT_SLOT_LEGS: return  "Legs";// session->GetTrinityString(LANG_SLOT_NAME_LEGS);
+    case EQUIPMENT_SLOT_FEET: return  "Feet";// session->GetTrinityString(LANG_SLOT_NAME_FEET);
+    case EQUIPMENT_SLOT_WRISTS: return  "Wrists";// session->GetTrinityString(LANG_SLOT_NAME_WRISTS);
+    case EQUIPMENT_SLOT_HANDS: return  "Hands";// session->GetTrinityString(LANG_SLOT_NAME_HANDS);
+    case EQUIPMENT_SLOT_BACK: return  "Back";// session->GetTrinityString(LANG_SLOT_NAME_BACK);
+    case EQUIPMENT_SLOT_MAINHAND: return  "Main hand";// session->GetTrinityString(LANG_SLOT_NAME_MAINHAND);
+    case EQUIPMENT_SLOT_OFFHAND: return  "Off hand";// session->GetTrinityString(LANG_SLOT_NAME_OFFHAND);
+    case EQUIPMENT_SLOT_RANGED: return  "Ranged";// session->GetTrinityString(LANG_SLOT_NAME_RANGED);
+    case EQUIPMENT_SLOT_TABARD: return  "Tabard";// session->GetTrinityString(LANG_SLOT_NAME_TABARD);
+    default: return NULL;
+    }
+}
+
+std::string Transmogrification::GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface";
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    const ItemDisplayInfoEntry* dispInfo = NULL;
+    if (temp)
+    {
+        dispInfo = sItemDisplayInfoStore.LookupEntry(temp->DisplayInfoID);
+        if (dispInfo)
+            ss << "/ICONS/" << dispInfo->inventoryIcon;
+    }
+    if (!dispInfo)
+        ss << "/InventoryItems/WoWUnknownItem01";
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSlotIcon");
+
+    std::ostringstream ss;
+    ss << "|TInterface/PaperDoll/";
+    switch (slot)
+    {
+    case EQUIPMENT_SLOT_HEAD: ss << "UI-PaperDoll-Slot-Head"; break;
+    case EQUIPMENT_SLOT_SHOULDERS: ss << "UI-PaperDoll-Slot-Shoulder"; break;
+    case EQUIPMENT_SLOT_BODY: ss << "UI-PaperDoll-Slot-Shirt"; break;
+    case EQUIPMENT_SLOT_CHEST: ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_WAIST: ss << "UI-PaperDoll-Slot-Waist"; break;
+    case EQUIPMENT_SLOT_LEGS: ss << "UI-PaperDoll-Slot-Legs"; break;
+    case EQUIPMENT_SLOT_FEET: ss << "UI-PaperDoll-Slot-Feet"; break;
+    case EQUIPMENT_SLOT_WRISTS: ss << "UI-PaperDoll-Slot-Wrists"; break;
+    case EQUIPMENT_SLOT_HANDS: ss << "UI-PaperDoll-Slot-Hands"; break;
+    case EQUIPMENT_SLOT_BACK: ss << "UI-PaperDoll-Slot-Chest"; break;
+    case EQUIPMENT_SLOT_MAINHAND: ss << "UI-PaperDoll-Slot-MainHand"; break;
+    case EQUIPMENT_SLOT_OFFHAND: ss << "UI-PaperDoll-Slot-SecondaryHand"; break;
+    case EQUIPMENT_SLOT_RANGED: ss << "UI-PaperDoll-Slot-Ranged"; break;
+    case EQUIPMENT_SLOT_TABARD: ss << "UI-PaperDoll-Slot-Tabard"; break;
+    default: ss << "UI-Backpack-EmptySlot";
+    }
+    ss << ":" << width << ":" << height << ":" << x << ":" << y << "|t";
+    return ss.str();
+}
+
+std::string Transmogrification::GetItemLink(Item* item, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    const ItemTemplate* temp = item->GetTemplate();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(temp->ItemId))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    if (int32 itemRandPropId = item->GetItemRandomPropertyId())
+    {
+        char* const* suffix = NULL;
+        if (itemRandPropId < 0)
+        {
+            const ItemRandomSuffixEntry* itemRandEntry = sItemRandomSuffixStore.LookupEntry(-item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        else
+        {
+            const ItemRandomPropertiesEntry* itemRandEntry = sItemRandomPropertiesStore.LookupEntry(item->GetItemRandomPropertyId());
+            if (itemRandEntry)
+                suffix = itemRandEntry->nameSuffix;
+        }
+        if (suffix)
+        {
+            std::string test(suffix[(name != temp->Name1) ? loc_idx : DEFAULT_LOCALE]);
+            if (!test.empty())
+            {
+                name += ' ';
+                name += test;
+            }
+        }
+    }
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << temp->ItemId << ":" <<
+        item->GetEnchantmentId(PERM_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_2) << ":" <<
+        item->GetEnchantmentId(SOCK_ENCHANTMENT_SLOT_3) << ":" <<
+        item->GetEnchantmentId(BONUS_ENCHANTMENT_SLOT) << ":" <<
+        item->GetItemRandomPropertyId() << ":" << item->GetItemSuffixFactor() << ":" <<
+        (uint32)item->GetOwner()->getLevel() << "|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+std::string Transmogrification::GetItemLink(uint32 entry, WorldSession* session) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetItemLink");
+
+    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+    int loc_idx = session->GetSessionDbLocaleIndex();
+    std::string name = temp->Name1;
+    if (ItemLocale const* il = sObjectMgr->GetItemLocale(entry))
+        ObjectMgr::GetLocaleString(il->Name, loc_idx, name);
+
+    std::ostringstream oss;
+    oss << "|c" << std::hex << ItemQualityColors[temp->Quality] << std::dec <<
+        "|Hitem:" << entry << ":0:0:0:0:0:0:0:0:0|h[" << name << "]|h|r";
+
+    return oss.str();
+}
+
+uint32 Transmogrification::GetFakeEntry(const Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetFakeEntry");
+
+    Player* owner = item->GetOwner();
+
+    if (!owner)
+        return 0;
+    if (owner->transmogMap.empty())
+        return 0;
+
+    TransmogMapType::const_iterator it = owner->transmogMap.find(item->GetGUID());
+    if (it == owner->transmogMap.end())
+        return 0;
+    return it->second;
+}
+
+void Transmogrification::UpdateItem(Player* player, Item* item) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::UpdateItem");
+
+    if (item->IsEquipped())
+    {
+        player->SetVisibleItemSlot(item->GetSlot(), item);
+        if (player->IsInWorld())
+            item->SendUpdateToPlayer(player);
+    }
+}
+
+void Transmogrification::DeleteFakeEntry(Player* player, Item* item)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::DeleteFakeEntry");
+
+    if (player->transmogMap.erase(item->GetGUID()) != 0)
+        UpdateItem(player, item);
+}
+
+void Transmogrification::SetFakeEntry(Player* player, Item* item, uint32 entry)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SetFakeEntry");
+
+    player->transmogMap[item->GetGUID()] = entry;
+    UpdateItem(player, item);
+}
+
+TransmogTrinityStrings Transmogrification::Transmogrify(Player* player, uint64 itemGUID, uint8 slot, bool no_cost)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify");
+
+    // slot of the transmogrified item
+    if (slot >= EQUIPMENT_SLOT_END)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify an item (lowguid: %u) with a wrong slot (%u) when transmogrifying items.", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID), slot);
+        return LANG_ERR_TRANSMOG_INVALID_SLOT;
+    }
+
+    Item* itemTransmogrifier = NULL;
+    // guid of the transmogrifier item, if it's not 0
+    if (itemGUID)
+    {
+        itemTransmogrifier = player->GetItemByGuid(itemGUID);
+        if (!itemTransmogrifier)
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify with an invalid item (lowguid: %u).", player->GetGUIDLow(), player->GetName().c_str(), GUID_LOPART(itemGUID));
+            return LANG_ERR_TRANSMOG_MISSING_SRC_ITEM;
+        }
+    }
+
+    // transmogrified item
+    Item* itemTransmogrified = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+    if (!itemTransmogrified)
+    {
+        TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) tried to transmogrify an invalid item in a valid slot (slot: %u).", player->GetGUIDLow(), player->GetName().c_str(), slot);
+        return LANG_ERR_TRANSMOG_MISSING_DEST_ITEM;
+    }
+
+    if (!itemTransmogrifier) // reset look newEntry
+    {
+        DeleteFakeEntry(player, itemTransmogrified);
+    }
+    else
+    {
+        if (!CanTransmogrifyItemWithItem(player, itemTransmogrified->GetTemplate(), itemTransmogrifier->GetTemplate()))
+        {
+            TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) failed CanTransmogrifyItemWithItem (%u with %u).", player->GetGUIDLow(), player->GetName().c_str(), itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+            return LANG_ERR_TRANSMOG_INVALID_ITEMS;
+        }
+
+        if (!no_cost)
+        {
+            if (RequireToken)
+            {
+                if (player->HasItemCount(TokenEntry, TokenAmount))
+                    player->DestroyItemCount(TokenEntry, TokenAmount, true);
+                else
+                    return LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS;
+            }
+
+            int32 cost = 0;
+            cost = GetSpecialPrice(itemTransmogrified->GetTemplate());
+            cost *= ScaledCostModifier;
+            cost += CopperCost;
+
+            if (cost) // 0 cost if reverting look
+            {
+                if (cost < 0)
+                    TC_LOG_DEBUG("custom.transmog", "Transmogrification::Transmogrify - Player (GUID: %u, name: %s) transmogrification invalid cost (non negative, amount %i). Transmogrified %u with %u", player->GetGUIDLow(), player->GetName().c_str(), -cost, itemTransmogrified->GetEntry(), itemTransmogrifier->GetEntry());
+                else
+                {
+                    if (!player->HasEnoughMoney(cost))
+                        return LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY;
+                    player->ModifyMoney(-cost, false);
+                }
+            }
+        }
+
+        SetFakeEntry(player, itemTransmogrified, itemTransmogrifier->GetEntry());
+
+        itemTransmogrified->UpdatePlayedTime(player);
+
+        itemTransmogrified->SetOwnerGUID(player->GetGUID());
+        itemTransmogrified->SetNotRefundable(player);
+        itemTransmogrified->ClearSoulboundTradeable(player);
+
+        if (itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_EQUIPED || itemTransmogrifier->GetTemplate()->Bonding == BIND_WHEN_USE)
+            itemTransmogrifier->SetBinding(true);
+
+        itemTransmogrifier->SetOwnerGUID(player->GetGUID());
+        itemTransmogrifier->SetNotRefundable(player);
+        itemTransmogrifier->ClearSoulboundTradeable(player);
+    }
+
+    return LANG_ERR_TRANSMOG_OK;
+}
+
+bool Transmogrification::CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* target, ItemTemplate const* source) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::CanTransmogrifyItemWithItem");
+
+    if (!target || !source)
+        return false;
+
+    if (source->ItemId == target->ItemId)
+        return false;
+
+    if (!SuitableForTransmogrification(player, target) || !SuitableForTransmogrification(player, source)) // if (!transmogrified->CanTransmogrify() || !transmogrifier->CanBeTransmogrified())
+        return false;
+
+    if (source->InventoryType == INVTYPE_BAG ||
+        source->InventoryType == INVTYPE_RELIC ||
+        // source->InventoryType == INVTYPE_BODY ||
+        source->InventoryType == INVTYPE_FINGER ||
+        source->InventoryType == INVTYPE_TRINKET ||
+        source->InventoryType == INVTYPE_AMMO ||
+        source->InventoryType == INVTYPE_QUIVER)
+        return false;
+
+    // TC doesnt check this? Checked by Inventory type check.
+    if (source->Class != target->Class)
+        return false;
+
+    if (source->SubClass != target->SubClass && !IsRangedWeapon(target->Class, target->SubClass))
+    {
+        if (source->Class == ITEM_CLASS_ARMOR && !AllowMixedArmorTypes)
+            return false;
+        if (source->Class == ITEM_CLASS_WEAPON && !AllowMixedWeaponTypes)
+            return false;
+    }
+
+    if (source->InventoryType != target->InventoryType)
+    {
+        if (source->Class == ITEM_CLASS_WEAPON &&
+            (IsRangedWeapon(target->Class, target->SubClass) != IsRangedWeapon(source->Class, source->SubClass) ||
+            source->InventoryType == INVTYPE_WEAPONMAINHAND ||
+            source->InventoryType == INVTYPE_WEAPONOFFHAND))
+            return false;
+        if (source->Class == ITEM_CLASS_ARMOR &&
+            !((source->InventoryType == INVTYPE_CHEST && target->InventoryType == INVTYPE_ROBE) ||
+            (source->InventoryType == INVTYPE_ROBE && target->InventoryType == INVTYPE_CHEST)))
+            return false;
+    }
+
+    return true;
+}
+
+bool Transmogrification::SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::SuitableForTransmogrification");
+
+    // ItemTemplate const* proto = item->GetTemplate();
+    if (!player || !proto)
+        return false;
+
+    if (proto->Class != ITEM_CLASS_ARMOR &&
+        proto->Class != ITEM_CLASS_WEAPON)
+        return false;
+
+    // Skip all checks for allowed items
+    if (IsAllowed(proto->ItemId))
+        return true;
+
+    if (IsNotAllowed(proto->ItemId))
+        return false;
+
+    if (!AllowFishingPoles && proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+        return false;
+
+    if (!IsAllowedQuality(proto->Quality)) // (proto->Quality == ITEM_QUALITY_LEGENDARY)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_HORDE_ONLY) && player->GetTeam() != HORDE)
+        return false;
+
+    if ((proto->Flags2 & ITEM_FLAGS_EXTRA_ALLIANCE_ONLY) && player->GetTeam() != ALLIANCE)
+        return false;
+
+    if (!IgnoreReqClass && (proto->AllowableClass & player->getClassMask()) == 0)
+        return false;
+
+    if (!IgnoreReqRace && (proto->AllowableRace & player->getRaceMask()) == 0)
+        return false;
+
+    if (!IgnoreReqSkill && proto->RequiredSkill != 0)
+    {
+        if (player->GetSkillValue(proto->RequiredSkill) == 0)
+            return false;
+        else if (player->GetSkillValue(proto->RequiredSkill) < proto->RequiredSkillRank)
+            return false;
+    }
+
+    if (!IgnoreReqSpell && proto->RequiredSpell != 0 && !player->HasSpell(proto->RequiredSpell))
+        return false;
+
+    if (!IgnoreReqLevel && player->getLevel() < proto->RequiredLevel)
+        return false;
+
+    // If World Event is not active, prevent using event dependant items
+    if (!IgnoreReqEvent && proto->HolidayId && !IsHolidayActive((HolidayIds)proto->HolidayId))
+        return false;
+
+    if (!IgnoreReqStats)
+    {
+        if (!proto->RandomProperty && !proto->RandomSuffix)
+        {
+            bool found = false;
+            for (uint8 i = 0; i < proto->StatsCount; ++i)
+            {
+                if (proto->ItemStat[i].ItemStatValue != 0)
+                {
+                    found = true;
+                    break;
+                }
+            }
+            if (!found)
+                return false;
+        }
+    }
+
+    return true;
+}
+
+/*
+bool Transmogrification::CanTransmogrify(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_TRANSMOG)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CAN_TRANSMOG)
+return true;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+bool Transmogrification::CanBeTransmogrified(Item const* item)
+{
+ItemTemplate const* proto = item->GetTemplate();
+
+if (!proto)
+return false;
+
+if (proto->Quality == ITEM_QUALITY_LEGENDARY)
+return false;
+
+if (proto->Class != ITEM_CLASS_ARMOR &&
+proto->Class != ITEM_CLASS_WEAPON)
+return false;
+
+if (proto->Class == ITEM_CLASS_WEAPON && proto->SubClass == ITEM_SUBCLASS_WEAPON_FISHING_POLE)
+return false;
+
+if (proto->Flags2 & ITEM_FLAGS_EXTRA_CANNOT_BE_TRANSMOG)
+return false;
+
+if (item->GetItemRandomPropertyId() == 0)
+return false;
+
+for (uint8 i = 0; i < MAX_ITEM_PROTO_STATS; ++i)
+if (proto->ItemStat[i].ItemStatValue != 0)
+return true;
+
+return false;
+}
+*/
+
+uint32 Transmogrification::GetSpecialPrice(ItemTemplate const* proto) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::GetSpecialPrice");
+
+    uint32 cost = proto->SellPrice < 10000 ? 10000 : proto->SellPrice;
+    return cost;
+}
+
+bool Transmogrification::IsRangedWeapon(uint32 Class, uint32 SubClass) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsRangedWeapon");
+
+    return Class == ITEM_CLASS_WEAPON && (
+        SubClass == ITEM_SUBCLASS_WEAPON_BOW ||
+        SubClass == ITEM_SUBCLASS_WEAPON_GUN ||
+        SubClass == ITEM_SUBCLASS_WEAPON_CROSSBOW);
+}
+
+bool Transmogrification::IsAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowed");
+
+    return Allowed.find(entry) != Allowed.end();
+}
+
+bool Transmogrification::IsNotAllowed(uint32 entry) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsNotAllowed");
+
+    return NotAllowed.find(entry) != NotAllowed.end();
+}
+
+bool Transmogrification::IsAllowedQuality(uint32 quality) const
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::IsAllowedQuality");
+
+    switch (quality)
+    {
+    case ITEM_QUALITY_POOR: return AllowPoor;
+    case ITEM_QUALITY_NORMAL: return AllowCommon;
+    case ITEM_QUALITY_UNCOMMON: return AllowUncommon;
+    case ITEM_QUALITY_RARE: return AllowRare;
+    case ITEM_QUALITY_EPIC: return AllowEpic;
+    case ITEM_QUALITY_LEGENDARY: return AllowLegendary;
+    case ITEM_QUALITY_ARTIFACT: return AllowArtifact;
+    case ITEM_QUALITY_HEIRLOOM: return AllowHeirloom;
+    default: return false;
+    }
+}
+
+void Transmogrification::LoadConfig(bool reload)
+{
+    TC_LOG_DEBUG("custom.transmog", "Transmogrification::LoadConfig");
+
+#ifdef PRESETS
+    EnableSetInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableSetInfo", true);
+    SetNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.SetNpcText", 50001));
+
+    EnableSets = sConfigMgr->GetBoolDefault("Transmogrification.EnableSets", true);
+    MaxSets = (uint8)sConfigMgr->GetIntDefault("Transmogrification.MaxSets", 10);
+    SetCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.SetCostModifier", 3.0f);
+    SetCopperCost = sConfigMgr->GetIntDefault("Transmogrification.SetCopperCost", 0);
+
+    if (MaxSets > MAX_OPTIONS)
+        MaxSets = MAX_OPTIONS;
+
+    if (reload) // dont store presets for nothing
+    {
+        // this should be thread safe as long as LoadConfig is triggered on thread safe env
+        SessionMap const& sessions = sWorld->GetAllSessions();
+        for (SessionMap::const_iterator it = sessions.begin(); it != sessions.end(); ++it)
+        {
+            if (Player* player = it->second->GetPlayer())
+            {
+                // skipping session check
+                if (EnableSets)
+                    LoadPlayerSets(player);
+            }
+        }
+    }
+#endif
+
+    EnableTransmogInfo = sConfigMgr->GetBoolDefault("Transmogrification.EnableTransmogInfo", true);
+    TransmogNpcText = uint32(sConfigMgr->GetIntDefault("Transmogrification.TransmogNpcText", 50000));
+
+    std::istringstream issAllowed(sConfigMgr->GetStringDefault("Transmogrification.Allowed", ""));
+    std::istringstream issNotAllowed(sConfigMgr->GetStringDefault("Transmogrification.NotAllowed", ""));
+    while (issAllowed.good())
+    {
+        uint32 entry;
+        issAllowed >> entry;
+        if (issAllowed.fail())
+            break;
+        Allowed.insert(entry);
+    }
+    while (issNotAllowed.good())
+    {
+        uint32 entry;
+        issNotAllowed >> entry;
+        if (issNotAllowed.fail())
+            break;
+        NotAllowed.insert(entry);
+    }
+
+    ScaledCostModifier = sConfigMgr->GetFloatDefault("Transmogrification.ScaledCostModifier", 1.0f);
+    CopperCost = sConfigMgr->GetIntDefault("Transmogrification.CopperCost", 0);
+
+    RequireToken = sConfigMgr->GetBoolDefault("Transmogrification.RequireToken", false);
+    TokenEntry = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenEntry", 49426));
+    TokenAmount = uint32(sConfigMgr->GetIntDefault("Transmogrification.TokenAmount", 1));
+
+    AllowPoor = sConfigMgr->GetBoolDefault("Transmogrification.AllowPoor", false);
+    AllowCommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowCommon", false);
+    AllowUncommon = sConfigMgr->GetBoolDefault("Transmogrification.AllowUncommon", true);
+    AllowRare = sConfigMgr->GetBoolDefault("Transmogrification.AllowRare", true);
+    AllowEpic = sConfigMgr->GetBoolDefault("Transmogrification.AllowEpic", true);
+    AllowLegendary = sConfigMgr->GetBoolDefault("Transmogrification.AllowLegendary", false);
+    AllowArtifact = sConfigMgr->GetBoolDefault("Transmogrification.AllowArtifact", false);
+    AllowHeirloom = sConfigMgr->GetBoolDefault("Transmogrification.AllowHeirloom", true);
+
+    AllowMixedArmorTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedArmorTypes", false);
+    AllowMixedWeaponTypes = sConfigMgr->GetBoolDefault("Transmogrification.AllowMixedWeaponTypes", false);
+    AllowFishingPoles = sConfigMgr->GetBoolDefault("Transmogrification.AllowFishingPoles", false);
+
+    IgnoreReqRace = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqRace", false);
+    IgnoreReqClass = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqClass", false);
+    IgnoreReqSkill = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSkill", false);
+    IgnoreReqSpell = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqSpell", false);
+    IgnoreReqLevel = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqLevel", false);
+    IgnoreReqEvent = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqEvent", false);
+    IgnoreReqStats = sConfigMgr->GetBoolDefault("Transmogrification.IgnoreReqStats", false);
+
+    if (!sObjectMgr->GetItemTemplate(TokenEntry))
+    {
+        TC_LOG_INFO("custom.transmog", "Transmogrification.TokenEntry (%u) does not exist. Using default (%u).", TokenEntry, 49426);
+        TokenEntry = 49426;
+    }
+}
+
+std::vector<uint64> Transmogrification::GetItemList(const Player* player) const
+{
+    std::vector<uint64> itemlist;
+
+    // Copy paste from Player::GetItemByGuid(guid)
+
+    for (uint8 i = EQUIPMENT_SLOT_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = KEYRING_SLOT_START; i < CURRENCYTOKEN_SLOT_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (int i = BANK_SLOT_ITEM_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Item* pItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i))
+            itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    for (uint8 i = BANK_SLOT_BAG_START; i < BANK_SLOT_BAG_END; ++i)
+        if (Bag* pBag = player->GetBagByPos(i))
+            for (uint32 j = 0; j < pBag->GetBagSize(); ++j)
+                if (Item* pItem = pBag->GetItemByPos(j))
+                    itemlist.push_back(pItem->GetGUID());
+
+    return itemlist;
+}
+
+namespace
+{
+    class PS_Transmogrification : public PlayerScript
+    {
+    public:
+        PS_Transmogrification(): PlayerScript("PS_Transmogrification") {}
+
+        void OnSave(Player* player) override
+        {
+            uint32 lowguid = player->GetGUIDLow();
+            SQLTransaction trans = CharacterDatabase.BeginTransaction();
+            trans->PAppend("DELETE FROM `custom_transmogrification` WHERE `Owner` = %u", lowguid);
+#ifdef PRESETS
+            trans->PAppend("DELETE FROM `custom_transmogrification_sets` WHERE `Owner` = %u", lowguid);
+#endif
+
+            if (!player->transmogMap.empty())
+            {
+                // Only save items that are in inventory / bank / etc
+                std::vector<uint64> items = sTransmogrification->GetItemList(player);
+                for (std::vector<uint64>::const_iterator it = items.begin(); it != items.end(); ++it)
+                {
+                    TransmogMapType::const_iterator it2 = player->transmogMap.find(*it);
+                    if (it2 == player->transmogMap.end())
+                        continue;
+
+                    trans->PAppend("REPLACE INTO custom_transmogrification (GUID, FakeEntry, Owner) VALUES (%u, %u, %u)", GUID_LOPART(it2->first), it2->second, lowguid);
+                }
+            }
+
+#ifdef PRESETS
+            if (!player->presetMap.empty())
+            {
+                for (PresetMapType::const_iterator it = player->presetMap.begin(); it != player->presetMap.end(); ++it)
+                {
+                    std::ostringstream ss;
+                    for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                        ss << uint32(it2->first) << ' ' << it2->second << ' ';
+                    trans->PAppend("REPLACE INTO `custom_transmogrification_sets` (`Owner`, `PresetID`, `SetName`, `SetData`) VALUES (%u, %u, \"%s\", \"%s\")", lowguid, uint32(it->first), it->second.name.c_str(), ss.str().c_str());
+                }
+            }
+#endif
+
+            if (trans->GetSize()) // basically never false
+                CharacterDatabase.CommitTransaction(trans);
+        }
+
+        void OnLogin(Player* player, bool /*firstLogin*/) override
+        {
+            QueryResult result = CharacterDatabase.PQuery("SELECT GUID, FakeEntry FROM custom_transmogrification WHERE Owner = %u", player->GetGUIDLow());
+
+            if (result)
+            {
+                do
+                {
+                    Field* field = result->Fetch();
+                    uint64 itemGUID = MAKE_NEW_GUID(field[0].GetUInt32(), 0, HIGHGUID_ITEM);
+                    uint32 fakeEntry = field[1].GetUInt32();
+                    // Only load items that are in inventory / bank / etc
+                    if (sObjectMgr->GetItemTemplate(fakeEntry) && player->GetItemByGuid(itemGUID))
+                    {
+                        player->transmogMap[itemGUID] = fakeEntry;
+                    }
+                    else
+                    {
+                        // Ignore, will be erased on next save.
+                        // Additionally this can happen if an item was deleted from DB but still exists for the player
+                        // TC_LOG_ERROR("custom.transmog", "Item entry (Entry: %u, itemGUID: %u, playerGUID: %u) does not exist, ignoring.", fakeEntry, GUID_LOPART(itemGUID), player->GetGUIDLow());
+                        // CharacterDatabase.PExecute("DELETE FROM custom_transmogrification WHERE FakeEntry = %u", fakeEntry);
+                    }
+                } while (result->NextRow());
+
+                if (!player->transmogMap.empty())
+                {
+                    for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                    {
+                        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                        {
+                            player->SetVisibleItemSlot(slot, item);
+                            if (player->IsInWorld())
+                                item->SendUpdateToPlayer(player);
+                        }
+                    }
+                }
+            }
+
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                sTransmogrification->LoadPlayerSets(player);
+#endif
+        }
+    };
+
+    class WS_Transmogrification : public WorldScript
+    {
+    public:
+        WS_Transmogrification(): WorldScript("WS_Transmogrification") {}
+
+        void OnConfigLoad(bool reload) override
+        {
+            sTransmogrification->LoadConfig(reload);
+        }
+
+        void OnStartup() override
+        {
+            TC_LOG_INFO("custom.transmog", "Deleting non-existing transmogrification entries...");
+            CharacterDatabase.DirectExecute("DELETE FROM custom_transmogrification WHERE NOT EXISTS (SELECT 1 FROM item_instance WHERE item_instance.guid = custom_transmogrification.GUID)");
+
+#ifdef PRESETS
+            // Clean even if disabled
+            // Dont delete even if player has more presets than should
+            CharacterDatabase.DirectExecute("DELETE FROM `custom_transmogrification_sets` WHERE NOT EXISTS(SELECT 1 FROM characters WHERE characters.guid = custom_transmogrification_sets.Owner)");
+#endif
+            sTransmogrification->LoadConfig(false);
+        }
+    };
+}
+
+void AddSC_PWS_Transmogrification()
+{
+    new WS_Transmogrification();
+    new PS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/Transmogrification.h b/src/server/scripts/Custom/Transmogrification.h
new file mode 100644
index 0000000..23f17be
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrification.h
@@ -0,0 +1,140 @@
+#ifndef DEF_TRANSMOGRIFICATION_H
+#define DEF_TRANSMOGRIFICATION_H
+
+#define PRESETS // comment this line to disable preset feature totally
+#define MAX_OPTIONS 25 // do not alter
+
+class Item;
+class Player;
+class WorldSession;
+struct ItemTemplate;
+
+enum TransmogTrinityStrings // Language.h might have same entries, appears when executing SQL, change if needed
+{
+    LANG_ERR_TRANSMOG_OK = 11100, // change this
+    LANG_ERR_TRANSMOG_INVALID_SLOT,
+    LANG_ERR_TRANSMOG_INVALID_SRC_ENTRY,
+    LANG_ERR_TRANSMOG_MISSING_SRC_ITEM,
+    LANG_ERR_TRANSMOG_MISSING_DEST_ITEM,
+    LANG_ERR_TRANSMOG_INVALID_ITEMS,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY,
+    LANG_ERR_TRANSMOG_NOT_ENOUGH_TOKENS,
+
+    LANG_ERR_UNTRANSMOG_OK,
+    LANG_ERR_UNTRANSMOG_NO_TRANSMOGS,
+
+#ifdef PRESETS
+    LANG_PRESET_ERR_INVALID_NAME,
+#endif
+};
+
+class Transmogrification
+{
+private:
+    Transmogrification() {};
+    ~Transmogrification() {};
+    Transmogrification(const Transmogrification&);
+    Transmogrification& operator=(const Transmogrification&);
+
+public:
+    static Transmogrification* instance()
+    {
+        // Thread safe in C++11 standard
+        static Transmogrification instance;
+        return &instance;
+    }
+
+#ifdef PRESETS
+    //typedef std::map<uint8, uint32> presetslotMap;
+    //struct presetData
+    //{
+    //    std::string name;
+    //    presetslotMap slotMap;
+    //};
+    //typedef std::map<uint8, presetData> presetIdMap; // remember to lock
+    // typedef KVRWHashMap<uint64, presetIdMap> presetPlayers;
+    // presetPlayers presetMap; // presetByName[pGUID][presetID] = presetData
+
+    bool EnableSetInfo;
+    uint32 SetNpcText;
+
+    bool EnableSets;
+    uint8 MaxSets;
+    float SetCostModifier;
+    int32 SetCopperCost;
+
+    void LoadPlayerSets(Player* player);
+
+    void PresetTransmog(Player* player, Item* itemTransmogrified, uint32 fakeEntry, uint8 slot);
+#endif
+
+    //typedef std::unordered_map<uint64, uint32> transmogData; // remember to lock
+    //typedef KVRWHashMap<uint64, transmogData> transmogMap;
+    //// typedef KVRWHashMap<uint64, uint64> transmogPlayers;
+    //transmogMap entryMap; // entryMap[pGUID][iGUID] = entry
+    //// transmogPlayers playerMap; // dataMap[iGUID] = pGUID
+
+    bool EnableTransmogInfo;
+    uint32 TransmogNpcText;
+
+    // Use IsAllowed() and IsNotAllowed()
+    // these are thread unsafe, but assumed to be static data so it should be safe
+    std::set<uint32> Allowed;
+    std::set<uint32> NotAllowed;
+
+    float ScaledCostModifier;
+    int32 CopperCost;
+
+    bool RequireToken;
+    uint32 TokenEntry;
+    uint32 TokenAmount;
+
+    bool AllowPoor;
+    bool AllowCommon;
+    bool AllowUncommon;
+    bool AllowRare;
+    bool AllowEpic;
+    bool AllowLegendary;
+    bool AllowArtifact;
+    bool AllowHeirloom;
+
+    bool AllowMixedArmorTypes;
+    bool AllowMixedWeaponTypes;
+    bool AllowFishingPoles;
+
+    bool IgnoreReqRace;
+    bool IgnoreReqClass;
+    bool IgnoreReqSkill;
+    bool IgnoreReqSpell;
+    bool IgnoreReqLevel;
+    bool IgnoreReqEvent;
+    bool IgnoreReqStats;
+
+    bool IsAllowed(uint32 entry) const;
+    bool IsNotAllowed(uint32 entry) const;
+    bool IsAllowedQuality(uint32 quality) const;
+    bool IsRangedWeapon(uint32 Class, uint32 SubClass) const;
+
+    void LoadConfig(bool reload); // thread unsafe
+
+    std::string GetItemIcon(uint32 entry, uint32 width, uint32 height, int x, int y) const;
+    std::string GetSlotIcon(uint8 slot, uint32 width, uint32 height, int x, int y) const;
+    const char * GetSlotName(uint8 slot, WorldSession* session) const;
+    std::string GetItemLink(Item* item, WorldSession* session) const;
+    std::string GetItemLink(uint32 entry, WorldSession* session) const;
+    uint32 GetFakeEntry(const Item* item);
+    void UpdateItem(Player* player, Item* item) const;
+    void DeleteFakeEntry(Player* player, Item* item);
+    void SetFakeEntry(Player* player, Item* item, uint32 entry);
+
+    TransmogTrinityStrings Transmogrify(Player* player, uint64 itemGUID, uint8 slot, bool no_cost = false);
+    bool CanTransmogrifyItemWithItem(Player* player, ItemTemplate const* destination, ItemTemplate const* source) const;
+    bool SuitableForTransmogrification(Player* player, ItemTemplate const* proto) const;
+    // bool CanBeTransmogrified(Item const* item);
+    // bool CanTransmogrify(Item const* item);
+    uint32 GetSpecialPrice(ItemTemplate const* proto) const;
+    std::vector<uint64> GetItemList(const Player* player) const;
+};
+#define sTransmogrification Transmogrification::instance()
+
+#endif
diff --git a/src/server/scripts/Custom/Transmogrifier.cpp b/src/server/scripts/Custom/Transmogrifier.cpp
new file mode 100644
index 0000000..a608f4e
--- /dev/null
+++ b/src/server/scripts/Custom/Transmogrifier.cpp
@@ -0,0 +1,399 @@
+/*
+6.0
+Transmogrification 3.3.5a - Gossip menu
+By Rochet2
+
+ScriptName for NPC:
+Creature_Transmogrify
+
+TODO:
+Fix the cost formula
+-- Too much data handling, use default costs
+
+Cant transmogrify rediculus items // Foereaper: would be fun to stab people with a fish
+-- Cant think of any good way to handle this easily, could rip flagged items from cata DB
+*/
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Language.h"
+#include "Transmogrification.h"
+
+#define GTS session->GetTrinityString
+
+namespace
+{
+    class CS_Transmogrification : public CreatureScript
+    {
+    public:
+        CS_Transmogrification(): CreatureScript("Creature_Transmogrify") {}
+
+        bool OnGossipHello(Player* player, Creature* creature) override
+        {
+            WorldSession* session = player->GetSession();
+            if (sTransmogrification->EnableTransmogInfo)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow transmogrification works", EQUIPMENT_SLOT_END + 9, 0);
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (const char* slotName = sTransmogrification->GetSlotName(slot, session))
+                {
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+                    uint32 entry = newItem ? sTransmogrification->GetFakeEntry(newItem) : 0;
+                    std::string icon = entry ? sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) : sTransmogrification->GetSlotIcon(slot, 30, 30, -18, 0);
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, icon + std::string(slotName), EQUIPMENT_SLOT_END, slot);
+                }
+            }
+#ifdef PRESETS
+            if (sTransmogrification->EnableSets)
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/RAIDFRAME/UI-RAIDFRAME-MAINASSIST:30:30:-18:0|tManage sets", EQUIPMENT_SLOT_END + 4, 0);
+#endif
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove all transmogrifications", EQUIPMENT_SLOT_END + 2, 0, "Remove transmogrifications from all equipped items?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 sender, uint32 action) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            WorldSession* session = player->GetSession();
+            switch (sender)
+            {
+            case EQUIPMENT_SLOT_END: // Show items you can use
+                ShowTransmogItems(player, creature, action);
+                break;
+            case EQUIPMENT_SLOT_END + 1: // Main menu
+                OnGossipHello(player, creature);
+                break;
+            case EQUIPMENT_SLOT_END + 2: // Remove Transmogrifications
+            {
+                bool removed = false;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        if (!sTransmogrification->GetFakeEntry(newItem))
+                            continue;
+                        sTransmogrification->DeleteFakeEntry(player, newItem);
+                        removed = true;
+                    }
+                }
+                if (removed)
+                    session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_UNTRANSMOG_OK));
+                else
+                    session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                OnGossipHello(player, creature);
+            } break;
+            case EQUIPMENT_SLOT_END + 3: // Remove Transmogrification from single item
+            {
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, action))
+                {
+                    if (sTransmogrification->GetFakeEntry(newItem))
+                    {
+                        sTransmogrification->DeleteFakeEntry(player, newItem);
+                        session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_UNTRANSMOG_OK));
+                    }
+                    else
+                        session->SendNotification(LANG_ERR_UNTRANSMOG_NO_TRANSMOGS);
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, action);
+            } break;
+#ifdef PRESETS
+            case EQUIPMENT_SLOT_END + 4: // Presets menu
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                if (sTransmogrification->EnableSetInfo)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Book_11:30:30:-18:0|tHow sets work", EQUIPMENT_SLOT_END + 10, 0);
+
+                if (!player->presetMap.empty())
+                {
+                    for (PresetMapType::const_iterator it = player->presetMap.begin(); it != player->presetMap.end(); ++it)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|t" + it->second.name, EQUIPMENT_SLOT_END + 6, it->first);
+
+                    if (player->presetMap.size() < sTransmogrification->MaxSets)
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                }
+                else
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", EQUIPMENT_SLOT_END + 8, 0);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 5: // Use preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+
+                PresetMapType::const_iterator it = player->presetMap.find(action);
+                if (it != player->presetMap.end())
+                {
+                    for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                        if (Item* item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, it2->first))
+                            sTransmogrification->PresetTransmog(player, item, it2->second, it2->first);
+                }
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 6, action);
+            } break;
+            case EQUIPMENT_SLOT_END + 6: // view preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+
+                PresetMapType::const_iterator it = player->presetMap.find(action);
+                if (it == player->presetMap.end())
+                {
+                    OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                    return true;
+                }
+
+                for (PresetslotMapType::const_iterator it2 = it->second.slotMap.begin(); it2 != it->second.slotMap.end(); ++it2)
+                    player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(it2->second, 30, 30, -18, 0) + sTransmogrification->GetItemLink(it2->second, session), sender, action);
+
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Misc_Statue_02:30:30:-18:0|tUse set", EQUIPMENT_SLOT_END + 5, action, "Using this set for transmogrify will bind transmogrified items to you and make them non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + it->second.name, 0, false);
+                player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-LeaveItem-Opaque:30:30:-18:0|tDelete set", EQUIPMENT_SLOT_END + 7, action, "Are you sure you want to delete " + it->second.name + "?", 0, false);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 7: // Delete preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // action = presetID
+
+                player->presetMap.erase(action);
+
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+            } break;
+            case EQUIPMENT_SLOT_END + 8: // Save preset
+            {
+                if (!sTransmogrification->EnableSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+
+                if (player->presetMap.size() >= sTransmogrification->MaxSets)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+
+                uint32 cost = 0;
+                bool canSave = false;
+                for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+                {
+                    if (!sTransmogrification->GetSlotName(slot, session))
+                        continue;
+                    if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                    {
+                        uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                        if (!entry)
+                            continue;
+                        const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                        if (!temp)
+                            continue;
+                        if (!sTransmogrification->SuitableForTransmogrification(player, temp)) // no need to check?
+                            continue;
+                        cost += sTransmogrification->GetSpecialPrice(temp);
+                        canSave = true;
+                        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(entry, 30, 30, -18, 0) + sTransmogrification->GetItemLink(entry, session), EQUIPMENT_SLOT_END + 8, 0);
+                    }
+                }
+                if (canSave)
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/GuildBankFrame/UI-GuildBankFrame-NewTab:30:30:-18:0|tSave set", 0, 0, "Insert set name", cost*sTransmogrification->SetCostModifier + sTransmogrification->SetCopperCost, true);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", sender, action);
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+            } break;
+            case EQUIPMENT_SLOT_END + 10: // Set info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 4, 0);
+                player->SEND_GOSSIP_MENU(sTransmogrification->SetNpcText, creature->GetGUID());
+            } break;
+#endif
+            case EQUIPMENT_SLOT_END + 9: // Transmog info
+            {
+                player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+                player->SEND_GOSSIP_MENU(sTransmogrification->TransmogNpcText, creature->GetGUID());
+            } break;
+            default: // Transmogrify
+            {
+                if (!sender && !action)
+                {
+                    OnGossipHello(player, creature);
+                    return true;
+                }
+                // sender = slot, action = display
+                TransmogTrinityStrings res = sTransmogrification->Transmogrify(player, MAKE_NEW_GUID(action, 0, HIGHGUID_ITEM), sender);
+                if (res == LANG_ERR_TRANSMOG_OK)
+                    session->SendAreaTriggerMessage("%s", GTS(LANG_ERR_TRANSMOG_OK));
+                else
+                    session->SendNotification(res);
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END, sender);
+            } break;
+            }
+            return true;
+        }
+
+#ifdef PRESETS
+        bool OnGossipSelectCode(Player* player, Creature* creature, uint32 sender, uint32 action, const char* code) override
+        {
+            player->PlayerTalkClass->ClearMenus();
+            if (sender || action)
+                return true; // should never happen
+            if (!sTransmogrification->EnableSets)
+            {
+                OnGossipHello(player, creature);
+                return true;
+            }
+
+            // Allow only alnum
+            std::string name = code;
+            static const char* allowedcharacters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz _.,'1234567890";
+            if (name.length() && name.find_first_not_of(allowedcharacters) != std::string::npos)
+            {
+                player->GetSession()->SendNotification(LANG_PRESET_ERR_INVALID_NAME);
+                OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+                return true;
+            }
+
+            int32 cost = 0;
+            PresetslotMapType items;
+            for (uint8 slot = EQUIPMENT_SLOT_START; slot < EQUIPMENT_SLOT_END; ++slot)
+            {
+                if (!sTransmogrification->GetSlotName(slot, player->GetSession()))
+                    continue;
+                if (Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot))
+                {
+                    uint32 entry = sTransmogrification->GetFakeEntry(newItem);
+                    if (!entry)
+                        continue;
+                    const ItemTemplate* temp = sObjectMgr->GetItemTemplate(entry);
+                    if (!temp)
+                        continue;
+                    if (!sTransmogrification->SuitableForTransmogrification(player, temp))
+                        continue;
+                    cost += sTransmogrification->GetSpecialPrice(temp);
+                    items[slot] = entry;
+                }
+            }
+
+            if (!items.empty())
+            {
+                // transmogrified items were found to be saved
+                cost *= sTransmogrification->SetCostModifier;
+                cost += sTransmogrification->SetCopperCost;
+
+                if (!player->HasEnoughMoney(cost))
+                {
+                    player->GetSession()->SendNotification(LANG_ERR_TRANSMOG_NOT_ENOUGH_MONEY);
+                }
+                else
+                {
+                    uint8 presetID = sTransmogrification->MaxSets;
+                    if (player->presetMap.size() < sTransmogrification->MaxSets)
+                    {
+                        for (uint8 i = 0; i < sTransmogrification->MaxSets; ++i) // should never reach over max
+                        {
+                            if (player->presetMap.find(i) == player->presetMap.end())
+                            {
+                                presetID = i;
+                                break;
+                            }
+                        }
+                    }
+
+                    if (presetID < sTransmogrification->MaxSets)
+                    {
+                        // Make sure code doesnt mess up SQL!
+                        player->presetMap[presetID].name = name;
+                        player->presetMap[presetID].slotMap = items;
+
+                        if (cost)
+                            player->ModifyMoney(-cost);
+                    }
+                }
+            }
+
+            OnGossipSelect(player, creature, EQUIPMENT_SLOT_END + 4, 0);
+            return true;
+        }
+#endif
+
+        void ShowTransmogItems(Player* player, Creature* creature, uint8 slot) // Only checks bags while can use an item from anywhere in inventory
+        {
+            WorldSession* session = player->GetSession();
+            Item* oldItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, slot);
+            if (oldItem)
+            {
+                uint32 limit = 0;
+                uint32 price = sTransmogrification->GetSpecialPrice(oldItem->GetTemplate());
+                price *= sTransmogrification->ScaledCostModifier;
+                price += sTransmogrification->CopperCost;
+                std::ostringstream ss;
+                ss << std::endl;
+                if (sTransmogrification->RequireToken)
+                    ss << std::endl << std::endl << sTransmogrification->TokenAmount << " x " << sTransmogrification->GetItemLink(sTransmogrification->TokenEntry, session);
+
+                for (uint8 i = INVENTORY_SLOT_ITEM_START; i < INVENTORY_SLOT_ITEM_END; ++i)
+                {
+                    if (limit >= MAX_OPTIONS)
+                        break;
+                    Item* newItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, i);
+                    if (!newItem)
+                        continue;
+                    if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                        continue;
+                    if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                        continue;
+                    ++limit;
+                    player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                }
+
+                for (uint8 i = INVENTORY_SLOT_BAG_START; i < INVENTORY_SLOT_BAG_END; ++i)
+                {
+                    Bag* bag = player->GetBagByPos(i);
+                    if (!bag)
+                        continue;
+                    for (uint32 j = 0; j < bag->GetBagSize(); ++j)
+                    {
+                        if (limit >= MAX_OPTIONS)
+                            break;
+                        Item* newItem = player->GetItemByPos(i, j);
+                        if (!newItem)
+                            continue;
+                        if (!sTransmogrification->CanTransmogrifyItemWithItem(player, oldItem->GetTemplate(), newItem->GetTemplate()))
+                            continue;
+                        if (sTransmogrification->GetFakeEntry(oldItem) == newItem->GetEntry())
+                            continue;
+                        ++limit;
+                        player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, sTransmogrification->GetItemIcon(newItem->GetEntry(), 30, 30, -18, 0) + sTransmogrification->GetItemLink(newItem, session), slot, newItem->GetGUIDLow(), "Using this item for transmogrify will bind it to you and make it non-refundable and non-tradeable.\nDo you wish to continue?\n\n" + sTransmogrification->GetItemIcon(newItem->GetEntry(), 40, 40, -15, -10) + sTransmogrification->GetItemLink(newItem, session) + ss.str(), price, false);
+                    }
+                }
+            }
+
+            player->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/INV_Enchant_Disenchant:30:30:-18:0|tRemove transmogrification", EQUIPMENT_SLOT_END + 3, slot, "Remove transmogrification from the slot?", 0, false);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/PaperDollInfoFrame/UI-GearManager-Undo:30:30:-18:0|tUpdate menu", EQUIPMENT_SLOT_END, slot);
+            player->ADD_GOSSIP_ITEM(GOSSIP_ICON_MONEY_BAG, "|TInterface/ICONS/Ability_Spy:30:30:-18:0|tBack..", EQUIPMENT_SLOT_END + 1, 0);
+            player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, creature->GetGUID());
+        }
+    };
+}
+
+void AddSC_CS_Transmogrification()
+{
+    new CS_Transmogrification();
+}
diff --git a/src/server/scripts/Custom/all-in-one.cpp b/src/server/scripts/Custom/all-in-one.cpp
new file mode 100644
index 0000000..db2b359
--- /dev/null
+++ b/src/server/scripts/Custom/all-in-one.cpp
@@ -0,0 +1,1330 @@
+/*
+
+
+Full NPC with lots of menus, and options.
+By: Blue
+Rewritten by: LordPsyan http://www.flaminglegion.net
+Version: 4.0a // Will be updated
+
+/*-------------------------------------
+*
+*
+        DEFINES
+*
+//------------------------------------*/
+#include "ScriptPCH.h"
+#include "Language.h"
+
+// Whisps
+#define notvip "You are not a VIP Member. Check website for details."
+#define yesvip "Welcome honored VIP Member"
+#define skillsmaxed "You skills are now maxed"
+#define votewhisper "Time to vote"
+#define donationhelp "Please donate to help the realm"
+#define normalhelp "If you need help, ask."
+#define ingamehelp "If you need help ingame, contact a GM"
+#define nosickness "You do not have Ressurection Sickness"
+#define nopet "You do not have a pet"
+#define welcome "Greetings Traveler. How can I help you?"
+
+// TOKEN ------------------------
+#define tokenbuy "I want to buy a %Servername% token."
+#define tokenchange "I want to change a %tokenname% to a %tokenname2%."
+
+// mails
+#define moneymail 60003
+
+// items
+#define token1 99999 // Token1 entry number (swap).
+#define token2 99998 // Token2 entry number (receive).
+#define vasarolhatotoken 100000 // Available as token -.-
+
+// Trainers
+#define dk        28474
+#define wari    914
+#define pala    23128
+#define sami    17204
+#define hunta    5115
+#define rogue    4584
+#define dudu    16655
+#define mage    28958
+#define priest    4090
+#define lock    23534
+
+//Teleport
+#define HMX -1854.022095f
+#define HMY -5412.382324f
+#define HMZ -12.428071f
+#define HMM 530
+
+#define AMX -1854.022095f
+#define AMY -5412.382324f
+#define AMZ -12.428071f
+#define AMM 530
+
+//Levelroad Teleport
+#define HLX 4613.816406f
+#define HLY -3589.231689f
+#define HLZ 994.164185f
+#define HLM 1
+
+#define ALX 6899.129883f
+#define ALY -2298.679932f
+#define ALZ 588.010986f
+#define ALM 1
+// DO NOT EDIT HERE //
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+
+
+
+class npc_all : public CreatureScript
+{
+public:
+    npc_all() : CreatureScript("npc_all") { }
+
+        //struct npc_allAI : public ScriptedAI
+        //{
+
+bool OnGossipHello(Player *player, Creature *_Creature)
+
+{
+    _Creature->MonsterWhisper(welcome, player);
+
+
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Morph", GOSSIP_SENDER_MAIN, 100);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Teleport", GOSSIP_SENDER_MAIN, 101); // 1.1
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Set My Skills to Maximum", GOSSIP_SENDER_MAIN, 102);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Trainers", GOSSIP_SENDER_MAIN, 103); // 1.2
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Server Menus", GOSSIP_SENDER_MAIN, 104);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Funny Things", GOSSIP_SENDER_MAIN, 105);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Announcer", GOSSIP_SENDER_MAIN, 106);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Buy", GOSSIP_SENDER_MAIN, 107); // Not configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Token Change", GOSSIP_SENDER_MAIN, 108); // Not Configured
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Vote", GOSSIP_SENDER_MAIN, 113); // Not Configured
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Remove Sickness", GOSSIP_SENDER_MAIN, 120);
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Reset Talent Points", GOSSIP_SENDER_MAIN, 121);
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Reputations", GOSSIP_SENDER_MAIN, 123); // Not Configured. No Data.
+    //player->ADD_GOSSIP_ITEM(0, "[Menu]Titles", GOSSIP_SENDER_MAIN, 124); // No Data for adding titles.
+    player->ADD_GOSSIP_ITEM(0, "[Menu]Buffs", GOSSIP_SENDER_MAIN, 125);
+
+
+        if (player->GetSession()->GetSecurity() >= 1)
+        {
+        _Creature->MonsterWhisper(yesvip, player);
+        player->ADD_GOSSIP_ITEM(0, "[Menu]Battleground Control", GOSSIP_SENDER_MAIN, 109);
+        //player->ADD_GOSSIP_ITEM(0, "[Menu]Vip functions", GOSSIP_SENDER_MAIN, 110);// No Data.
+        } else { _Creature->MonsterWhisper(notvip, player); }
+
+
+    player->SEND_GOSSIP_MENU(1, _Creature->GetGUID());
+    return true;
+}
+
+void SendDefaultMenu(Player *player, Creature *_Creature, uint32 action)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    _Creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    switch(action)
+
+    {
+
+        //////////////// MAIN MENUS -> Normal Menus //////////////////
+    case 100: // Morphs
+        player->ADD_GOSSIP_ITEM(0, "Illidan", GOSSIP_SENDER_MAIN, 500);
+        player->ADD_GOSSIP_ITEM(0, "Kil'jaeden", GOSSIP_SENDER_MAIN, 501);
+        player->ADD_GOSSIP_ITEM(0, "Akama", GOSSIP_SENDER_MAIN, 502);
+        player->ADD_GOSSIP_ITEM(0, "Deathknight", GOSSIP_SENDER_MAIN, 503);
+        player->ADD_GOSSIP_ITEM(0, "Tauren", GOSSIP_SENDER_MAIN, 504);
+        player->ADD_GOSSIP_ITEM(0, "Undead", GOSSIP_SENDER_MAIN, 505);
+        player->ADD_GOSSIP_ITEM(0, "Human", GOSSIP_SENDER_MAIN, 506);
+        player->ADD_GOSSIP_ITEM(0, "Lich King", GOSSIP_SENDER_MAIN, 507);
+        player->ADD_GOSSIP_ITEM(0, "Tirion", GOSSIP_SENDER_MAIN, 508);
+        player->ADD_GOSSIP_ITEM(0, "Uther Lightbringer", GOSSIP_SENDER_MAIN, 509);
+        player->ADD_GOSSIP_ITEM(0, "Arthas", GOSSIP_SENDER_MAIN, 510);
+        ///////////// From SPGM
+        player->ADD_GOSSIP_ITEM(4, "Algalon", GOSSIP_SENDER_MAIN, 711);
+        player->ADD_GOSSIP_ITEM(4, "Doomwalker", GOSSIP_SENDER_MAIN, 712);
+        player->ADD_GOSSIP_ITEM(4, "Doomlord kazzak", GOSSIP_SENDER_MAIN, 713);
+        player->ADD_GOSSIP_ITEM(4, "Onyxia", GOSSIP_SENDER_MAIN, 714);
+        player->ADD_GOSSIP_ITEM(4, "Thaddius", GOSSIP_SENDER_MAIN, 715);
+        player->ADD_GOSSIP_ITEM(4, "Gluth", GOSSIP_SENDER_MAIN, 716);
+        player->ADD_GOSSIP_ITEM(4, "Maexxna", GOSSIP_SENDER_MAIN, 717);
+        player->ADD_GOSSIP_ITEM(4, "Sapphiron", GOSSIP_SENDER_MAIN, 718);
+        player->ADD_GOSSIP_ITEM(4, "Noth The Plaguebringer", GOSSIP_SENDER_MAIN, 719);
+        player->ADD_GOSSIP_ITEM(4, "Kel'Thuzad", GOSSIP_SENDER_MAIN, 720);
+        player->ADD_GOSSIP_ITEM(4, "Kael'thas Sunstrider", GOSSIP_SENDER_MAIN, 721);
+        player->ADD_GOSSIP_ITEM(4, "C'thun", GOSSIP_SENDER_MAIN, 722);
+        player->ADD_GOSSIP_ITEM(4, "Thrall", GOSSIP_SENDER_MAIN, 723);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+    break;
+
+
+    case 101: // Teleport
+        player->ADD_GOSSIP_ITEM(1, "Raids/Dungeons", GOSSIP_SENDER_MAIN, 600);
+        player->ADD_GOSSIP_ITEM(1, "Cities", GOSSIP_SENDER_MAIN, 601);
+        //player->ADD_GOSSIP_ITEM(1, "Fun places", GOSSIP_SENDER_MAIN, 602); // Only For Funservers. Not Configured
+        //player->ADD_GOSSIP_ITEM(1, "Events", GOSSIP_SENDER_MAIN, 603); // Funservers. Not Configured
+        player->ADD_GOSSIP_ITEM(1, "Areas", GOSSIP_SENDER_MAIN, 604);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 102: // Skill maxer
+        player->CLOSE_GOSSIP_MENU();
+        player->UpdateSkillsToMaxSkillsForLevel();
+        _Creature->MonsterWhisper(skillsmaxed, player);
+        break;
+
+    case 103: // Trainers
+
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        //player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802); // Not Configured.
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 104: // Server Menus
+        player->ADD_GOSSIP_ITEM(1, "Help! I've got hacked (Lock Account)", GOSSIP_SENDER_MAIN, 900);
+        player->ADD_GOSSIP_ITEM(0, "Report Lagg", GOSSIP_SENDER_MAIN, 901);
+        player->ADD_GOSSIP_ITEM(0, "Help", GOSSIP_SENDER_MAIN, 903);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 105: // Funny Things, Need some more
+        player->ADD_GOSSIP_ITEM(0, "Money", GOSSIP_SENDER_MAIN, 1000); // DELETE THIS IF YOU DONT WANT PLAYERS TO GET MONEY
+        player->ADD_GOSSIP_ITEM(0, "Drunk", GOSSIP_SENDER_MAIN, 1001);
+        player->ADD_GOSSIP_ITEM(0, "Sober", GOSSIP_SENDER_MAIN, 1002);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 106: // Announcer Part
+        player->ADD_GOSSIP_ITEM(0, "Join Warsong Guilch!", GOSSIP_SENDER_MAIN, 1100);
+        player->ADD_GOSSIP_ITEM(0, "Join Arathi Basin!", GOSSIP_SENDER_MAIN, 1101);
+        player->ADD_GOSSIP_ITEM(0, "Join Wintergrasp!", GOSSIP_SENDER_MAIN, 1102);
+        player->ADD_GOSSIP_ITEM(0, "Join Strand of the ancients!", GOSSIP_SENDER_MAIN, 1103);
+        player->ADD_GOSSIP_ITEM(0, "Join Alterac Valley!", GOSSIP_SENDER_MAIN, 1104);
+        player->ADD_GOSSIP_ITEM(0, "Join Random Battleground!", GOSSIP_SENDER_MAIN, 1105);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 2v2!", GOSSIP_SENDER_MAIN, 1106);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 3v3!", GOSSIP_SENDER_MAIN, 1107);
+        player->ADD_GOSSIP_ITEM(0, "Join Arena 5v5!", GOSSIP_SENDER_MAIN, 1108);
+        player->ADD_GOSSIP_ITEM(0, "Join Eye of the Storm!", GOSSIP_SENDER_MAIN, 1109);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+    case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 109: // Battleground function
+        player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 110: // VIP Functions, from another script(by me :D)
+        player->ADD_GOSSIP_ITEM(0, "Repair", GOSSIP_SENDER_MAIN, 1500);
+        player->ADD_GOSSIP_ITEM(0, "Nyugit szeretnk", GOSSIP_SENDER_MAIN, 1501);
+        player->ADD_GOSSIP_ITEM(0, "Surgery", GOSSIP_SENDER_MAIN, 1502);
+        player->ADD_GOSSIP_ITEM(0, "Faction change", GOSSIP_SENDER_MAIN, 1503);
+        player->ADD_GOSSIP_ITEM(0, "Race Change", GOSSIP_SENDER_MAIN, 1504);
+        //player->ADD_GOSSIP_ITEM(0, "Move?", GOSSIP_SENDER_MAIN, 1505); Not yet implemented
+        player->ADD_GOSSIP_ITEM(0, "Name Change", GOSSIP_SENDER_MAIN, 1506);
+        player->ADD_GOSSIP_ITEM(0, "Save Character", GOSSIP_SENDER_MAIN, 1507);
+        player->ADD_GOSSIP_ITEM(0, "Mailbox", GOSSIP_SENDER_MAIN, 1508);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 111: // VOte
+        _Creature->MonsterWhisper(votewhisper, player);
+        player->ADD_GOSSIP_ITEM(0, "1 - %VOTE1%", GOSSIP_SENDER_MAIN, 1600);
+        player->ADD_GOSSIP_ITEM(0, "2 - %VOTE2%", GOSSIP_SENDER_MAIN, 1601);
+        player->ADD_GOSSIP_ITEM(0, "3 - %VOTE3%", GOSSIP_SENDER_MAIN, 1602);
+        player->ADD_GOSSIP_ITEM(0, "4 - %VOTE4%", GOSSIP_SENDER_MAIN, 1603);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+    case 124: // Titles, Not Ready Yet!
+        player->ADD_GOSSIP_ITEM(0, "Jenkins", GOSSIP_SENDER_MAIN, 3000);
+        player->ADD_GOSSIP_ITEM(0, "Loremaster", GOSSIP_SENDER_MAIN, 3001);
+        player->ADD_GOSSIP_ITEM(0, "the Seeker", GOSSIP_SENDER_MAIN, 3002);
+        player->ADD_GOSSIP_ITEM(0, "the Argent Defender", GOSSIP_SENDER_MAIN, 3003);
+        player->ADD_GOSSIP_ITEM(0, "Bane of the Fallen King", GOSSIP_SENDER_MAIN, 3004);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Frozen Wastes", GOSSIP_SENDER_MAIN, 3005);
+        player->ADD_GOSSIP_ITEM(0, "Champion of the Naaru", GOSSIP_SENDER_MAIN, 3006);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Naxxramas", GOSSIP_SENDER_MAIN, 3007);
+        player->ADD_GOSSIP_ITEM(0, "Conqueror of Ulduar", GOSSIP_SENDER_MAIN, 3008);
+        player->ADD_GOSSIP_ITEM(0, "Hand of A'dal", GOSSIP_SENDER_MAIN, 3009);
+        player->ADD_GOSSIP_ITEM(0, "the Immortal", GOSSIP_SENDER_MAIN, 3010);
+        player->ADD_GOSSIP_ITEM(0, "the Patient", GOSSIP_SENDER_MAIN, 3011);
+        player->ADD_GOSSIP_ITEM(0, "the Undying", GOSSIP_SENDER_MAIN, 3012);
+        player->ADD_GOSSIP_ITEM(0, "Ambassador", GOSSIP_SENDER_MAIN, 3013);
+        player->ADD_GOSSIP_ITEM(0, "Bloodsail Admiral", GOSSIP_SENDER_MAIN, 3014);
+        player->ADD_GOSSIP_ITEM(0, "Crusader", GOSSIP_SENDER_MAIN, 3015);
+        player->ADD_GOSSIP_ITEM(0, "the Diplomat", GOSSIP_SENDER_MAIN, 3016);
+        player->ADD_GOSSIP_ITEM(0, "the Exalted", GOSSIP_SENDER_MAIN, 3017);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        /// Buffer part
+    case 125: // buffer
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Power Word: Fortitude, Rank 8", GOSSIP_SENDER_MAIN, 4000);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Kings", GOSSIP_SENDER_MAIN, 4001);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Bleesing of Mights", GOSSIP_SENDER_MAIN,4002);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Greater Blessing of Wisdom", GOSSIP_SENDER_MAIN, 4003);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Mark of the Wild, Rank 9", GOSSIP_SENDER_MAIN, 4004);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Arcane Intellect, Rank 7", GOSSIP_SENDER_MAIN, 4005);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Soul Stone", GOSSIP_SENDER_MAIN, 4006);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Thorns, Rank 8", GOSSIP_SENDER_MAIN, 4007);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Divine Spirit, Rank 8", GOSSIP_SENDER_MAIN, 4008);
+        player->ADD_GOSSIP_ITEM(0, "[Buff]Shadow Protection, Rank 5", GOSSIP_SENDER_MAIN, 4009);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+         break;
+
+    case 4000:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48161, false); // target, spellid, triggered-e
+        break;
+
+        case 4001:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 25898, false);
+        break;
+
+        case 4002:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48934, false);
+        break;
+
+        case 4003:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48938, false);
+        break;
+
+        case 4004:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48469, false);
+        break;
+
+        case 4005:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 42995, false);
+        break;
+
+        case 4006:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 47883, false);
+        break;
+
+        case 4007:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 53307, false);
+        break;
+
+        case 4008:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48073, false);
+        break;
+
+        case 4009:
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->CastSpell(player, 48169, false);
+        break;
+
+
+        /////////// NORMAL MENUS -> ACTION OR MENU
+
+
+
+        ///-- Server Menus part start --///
+        case 900: // Hacked
+        // Closes the account
+        LoginDatabase.PQuery("UPDATE `account` SET `locked`=1 WHERE `id`='%s'", player->GetSession()->GetAccountId());
+        LoginDatabase.PQuery("INSERT INTO `hacked` (`charname`) VALUES ('%s'", player); // Report it to the DB.
+        break;
+
+        case 901: // Report lagg
+        /*player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper(('%s', player->GetSession()->GetAccountId()), player);
+        LoginDatabase.PExecute("INSERT INTO `lagreports` (`account`) VALUES ('%s'", player->GetSession()->GetAccountId());
+        _Creature->MonsterWhisper("Lagg report done.", player);*/
+        break;
+
+        case 902: // Help
+        player->ADD_GOSSIP_ITEM(0, "Donation Help", GOSSIP_SENDER_MAIN, 1700);
+        player->ADD_GOSSIP_ITEM(0, "Ingame Help", GOSSIP_SENDER_MAIN, 1701);
+        player->ADD_GOSSIP_ITEM(0, "Normal Help", GOSSIP_SENDER_MAIN, 1702);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 1700: // Donation Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Donations can be done on www.flaminglegion.net", player);
+        break;
+
+        case 1701: // INGAME HELP
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Contact a GM for help", player);
+        break;
+
+        case 1702: // Normal Help
+        player->CLOSE_GOSSIP_MENU();
+        _Creature->MonsterWhisper("Helpful information can be found on www.flaminglegion.net", player);
+        break;
+        /// -- Server Menus part End -- ///
+
+        /// -- Funny Things Menu Start -- /// money drunk sober
+
+        case 1000: // Money
+        player->CLOSE_GOSSIP_MENU();
+        player->GetMail(moneymail);
+        _Creature->MonsterWhisper("Check your mailbox.", player);
+        break;
+
+        case 1001: // Drunk
+        player->CLOSE_GOSSIP_MENU();
+        player->CastSpell(player, 46876, false);
+        break;
+
+        case 1002: // Sober
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDrunkValue(0, 9);
+        break;
+        /// -- Funny Things Menu End -- ///
+
+        /// -- Announcer Part Start -- ///
+
+        case 1100:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).PSendSysMessage(LANG_WSG);
+        break;
+
+        case 1101:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AB);
+        break;
+
+        case 1102:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_WG);
+        break;
+
+        case 1103:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_SOTA);
+        break;
+
+        case 1104:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_AV);
+        break;
+
+        case 1105:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_RANDOM);
+        break;
+
+        case 1106:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_1);
+        break;
+
+        case 1107:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_2);
+        break;
+
+        case 1108:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_ARENA_3);
+        break;
+
+        case 1109:
+        player->CLOSE_GOSSIP_MENU();
+        ChatHandler(player->GetSession()).SendSysMessage(LANG_EOTS);
+        break;
+
+        /// -- Announcer part end -- ///
+
+        /////////////////////////////////
+        //        BREAK           //
+        //////////////////////////////////
+        //////////////////////////////////
+
+    /*************************************************************************/
+
+        /// -- Morph Part Start -- ///
+
+               case 500:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(21135);
+        break;
+
+        case 501:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23200);
+        break;
+
+        case 502:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20681);
+        break;
+
+        case 503:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16508);
+        break;
+
+        case 504:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17332);
+        break;
+
+        case 505:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(2789);
+        break;
+
+        case 506:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16280);
+        break;
+
+        case 507:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24191);
+        break;
+
+        case 508:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(22209);
+        break;
+
+        case 509:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(23889);
+        break;
+
+        case 510:
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(24949);
+        break;
+
+        case 711: // Algalon
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(28641);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 712: // Doomwalker
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16630);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 713: // Doomlord kazzak
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(17887);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.10f);
+        break;
+
+        case 714: // Onyxia
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(8570);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 715: // Thaddius
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16137);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 716: // Gluth
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16064);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 717: // Maexxna
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15928);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.15f);
+        break;
+
+        case 718: // Sapphiron
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16033);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 719: // Noth The Plaguebringer
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(16590);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.7f);
+        break;
+
+        case 720: // Kel'Thuzad
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15945);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.2f);
+        break;
+
+        case 721: // Kael'thas Sunstrider
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(20023);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.5f);
+        break;
+
+        case 722: // C'thun
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(15786);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 0.1f);
+        break;
+
+        case 723: // Thrall
+        player->CLOSE_GOSSIP_MENU();
+        player->SetDisplayId(4527);
+        player->SetFloatValue(OBJECT_FIELD_SCALE_X, 1.0f);
+        break;
+
+/// -- Morph Part End -- ///
+
+
+
+
+
+
+
+/// -- Teleport Part Start -- ///
+        case 600: // Raid dungeon , cities
+        player->ADD_GOSSIP_ITEM(0, "ICC", GOSSIP_SENDER_MAIN, 1900);
+        player->ADD_GOSSIP_ITEM(0, "Naxxramas", GOSSIP_SENDER_MAIN, 1901);
+        player->ADD_GOSSIP_ITEM(0, "Ulduar", GOSSIP_SENDER_MAIN, 1902);
+        player->ADD_GOSSIP_ITEM(0, "Nexus", GOSSIP_SENDER_MAIN, 1903);
+        player->ADD_GOSSIP_ITEM(0, "Argent Tournament Grounds", GOSSIP_SENDER_MAIN, 1904);
+        player->ADD_GOSSIP_ITEM(0, "Azjol-Nerub", GOSSIP_SENDER_MAIN, 1905);
+        player->ADD_GOSSIP_ITEM(0, "Drak' Tharon Keep", GOSSIP_SENDER_MAIN, 1906);
+        player->ADD_GOSSIP_ITEM(0, "Gundrak", GOSSIP_SENDER_MAIN, 1907);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Keep", GOSSIP_SENDER_MAIN, 1908);
+        player->ADD_GOSSIP_ITEM(0, "Utgarde Pinnacle", GOSSIP_SENDER_MAIN, 1909);
+        player->ADD_GOSSIP_ITEM(0, "Vault of Archavon", GOSSIP_SENDER_MAIN, 1910);
+        player->ADD_GOSSIP_ITEM(0, "Violet Hold", GOSSIP_SENDER_MAIN, 1911);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 601: // Cities
+
+        player->ADD_GOSSIP_ITEM(0, "Teleport Stormwind", GOSSIP_SENDER_MAIN, 1800);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Ironforge", GOSSIP_SENDER_MAIN, 1801);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Darnassus", GOSSIP_SENDER_MAIN, 1802);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Exodar", GOSSIP_SENDER_MAIN, 1803);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Shattrath", GOSSIP_SENDER_MAIN, 1804);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Dalaran", GOSSIP_SENDER_MAIN, 1805);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Gurubashi Arena", GOSSIP_SENDER_MAIN, 1806);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Orgrimmar", GOSSIP_SENDER_MAIN, 1807);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Undercity", GOSSIP_SENDER_MAIN, 1808);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Silvermoon", GOSSIP_SENDER_MAIN, 1809);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Thunder Bluff", GOSSIP_SENDER_MAIN, 1810);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance Mall", GOSSIP_SENDER_MAIN, 5000);
+        player->ADD_GOSSIP_ITEM(0, "Teleport Alliance LevelRoad", GOSSIP_SENDER_MAIN, 9998);
+
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 604: // areas
+        player->ADD_GOSSIP_ITEM(0, "Azuremyst Isle", GOSSIP_SENDER_MAIN, 1850);
+        player->ADD_GOSSIP_ITEM(0, "Teldrassil", GOSSIP_SENDER_MAIN, 1851);
+        player->ADD_GOSSIP_ITEM(0, "Elwynn Forest", GOSSIP_SENDER_MAIN, 1852);
+        player->ADD_GOSSIP_ITEM(0, "Dun Morogh", GOSSIP_SENDER_MAIN, 1853);
+        player->ADD_GOSSIP_ITEM(0, "Durotar", GOSSIP_SENDER_MAIN, 1854);
+        player->ADD_GOSSIP_ITEM(0, "Mulgore", GOSSIP_SENDER_MAIN, 1855);
+        player->ADD_GOSSIP_ITEM(0, "Tirisfal Glades", GOSSIP_SENDER_MAIN, 1856);
+        player->ADD_GOSSIP_ITEM(0, "Eversong Woods", GOSSIP_SENDER_MAIN, 1857);
+        player->ADD_GOSSIP_ITEM(0, "Darkshore", GOSSIP_SENDER_MAIN, 1858);
+        player->ADD_GOSSIP_ITEM(0, "Loch Modan", GOSSIP_SENDER_MAIN, 1859);
+        player->ADD_GOSSIP_ITEM(0, "Redridge Mountains", GOSSIP_SENDER_MAIN, 1860);
+        player->ADD_GOSSIP_ITEM(0, "Barrens", GOSSIP_SENDER_MAIN, 1861);
+        player->ADD_GOSSIP_ITEM(0, "Stonetalon Mountains", GOSSIP_SENDER_MAIN, 1862);
+        player->ADD_GOSSIP_ITEM(0, "Ashenvale", GOSSIP_SENDER_MAIN, 1863);
+        player->ADD_GOSSIP_ITEM(0, "Wetlands", GOSSIP_SENDER_MAIN, 1864);
+        player->ADD_GOSSIP_ITEM(0, "Thousand Needles", GOSSIP_SENDER_MAIN, 1865);
+        player->ADD_GOSSIP_ITEM(0, "Hillsbrad Foothills", GOSSIP_SENDER_MAIN, 1866);
+        player->ADD_GOSSIP_ITEM(0, "Arathi Highlands", GOSSIP_SENDER_MAIN, 1867);
+        player->ADD_GOSSIP_ITEM(0, "Desolace", GOSSIP_SENDER_MAIN, 1868);
+        player->ADD_GOSSIP_ITEM(0, "Stranglethorn Vale", GOSSIP_SENDER_MAIN, 1869);
+        player->ADD_GOSSIP_ITEM(0, "Badlands", GOSSIP_SENDER_MAIN, 1870);
+        player->ADD_GOSSIP_ITEM(0, "Swamp of Sorrows", GOSSIP_SENDER_MAIN, 1871);
+        player->ADD_GOSSIP_ITEM(0, "The Hinterlands", GOSSIP_SENDER_MAIN, 1872);
+        player->ADD_GOSSIP_ITEM(0, "Tanaris", GOSSIP_SENDER_MAIN, 1873);
+        player->ADD_GOSSIP_ITEM(0, "Blasted Lands", GOSSIP_SENDER_MAIN, 1874);
+        player->ADD_GOSSIP_ITEM(0, "Searing Gorge", GOSSIP_SENDER_MAIN, 1875);
+        player->ADD_GOSSIP_ITEM(0, "Un Goro Crater", GOSSIP_SENDER_MAIN, 1876);
+        player->ADD_GOSSIP_ITEM(0, "Azshara", GOSSIP_SENDER_MAIN, 1877);
+        player->ADD_GOSSIP_ITEM(0, "Felwood", GOSSIP_SENDER_MAIN, 1878);
+        player->ADD_GOSSIP_ITEM(0, "Winterspring", GOSSIP_SENDER_MAIN, 1879);
+        player->ADD_GOSSIP_ITEM(0, "Silithus", GOSSIP_SENDER_MAIN, 1880);
+        player->ADD_GOSSIP_ITEM(0, "Western Plaguelands", GOSSIP_SENDER_MAIN, 1881);
+        player->ADD_GOSSIP_ITEM(0, "Burning Steppes", GOSSIP_SENDER_MAIN, 1882);
+        player->ADD_GOSSIP_ITEM(0, "Hellfire Peninsula", GOSSIP_SENDER_MAIN, 1883);
+        player->ADD_GOSSIP_ITEM(0, "Zangarmarsh", GOSSIP_SENDER_MAIN, 1884);
+        player->ADD_GOSSIP_ITEM(0, "Terokkar Forest", GOSSIP_SENDER_MAIN, 1885);
+        player->ADD_GOSSIP_ITEM(0, "Nagrand", GOSSIP_SENDER_MAIN, 1886);
+        player->ADD_GOSSIP_ITEM(0, "Blades Edge Mountain", GOSSIP_SENDER_MAIN, 1887);
+        player->ADD_GOSSIP_ITEM(0, "Netherstorm", GOSSIP_SENDER_MAIN, 1888);
+        player->ADD_GOSSIP_ITEM(0, "Shadowmoon Valley", GOSSIP_SENDER_MAIN, 1889);
+        player->ADD_GOSSIP_ITEM(0, "Borean Tundra", GOSSIP_SENDER_MAIN, 1890);
+        player->ADD_GOSSIP_ITEM(0, "Dragonblight", GOSSIP_SENDER_MAIN, 1891);
+        player->ADD_GOSSIP_ITEM(0, "Grizzly Hills", GOSSIP_SENDER_MAIN, 1892);
+        player->ADD_GOSSIP_ITEM(0, "Zul'Drak", GOSSIP_SENDER_MAIN, 1893);
+        player->ADD_GOSSIP_ITEM(0, "Sholazar Basin", GOSSIP_SENDER_MAIN, 1894);
+        player->ADD_GOSSIP_ITEM(0, "The Storm Peaks", GOSSIP_SENDER_MAIN, 1895);
+        player->ADD_GOSSIP_ITEM(0, "Howling Fjord", GOSSIP_SENDER_MAIN, 1896);
+        player->ADD_GOSSIP_ITEM(0, "Icecrown", GOSSIP_SENDER_MAIN, 1897);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        /// tele loactions
+
+        // RAIDS & Dungeons
+
+        case 1900: // icc
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5873.819824f, 2110.979980f, 636.010986f, 0.0f);
+            break;
+
+        case 1901: // Naxxramas
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3665.904053f, -1267.064575f, 243.512207f, 0.0f);
+            break;
+
+        case 1902: // Ulduar
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8948.200165f, -1268.270020f, 1025.500000f, 0.0f);
+            break;
+        case 1903: // Nexus
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3785.800049f, 6944.919922f, 104.620003f, 0.0f);
+            break;
+        case 1904: // Argent tournement
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 8513.266602f, 638.120728f, 547.324890f, 0.0f);
+            break;
+        case 1905: // Azjol-Nerub
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 3707.86f, 2150.23f, 36.7568f, 0.0f);
+            break;
+        case 1906: // Drak' Tharon Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 4774.6f, -2032.92f, 229.145f, 0.0f);
+            break;
+        case 1907: // Gundrak
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 6910.8f, -4603.23f, 450.61f, 0.0f);
+            break;
+        case 1908: // Utgarde Keep
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1219.72f, -4865.28f, 41.2479f, 0.0f);
+            break;
+        case 1909: // Utgarde Pinnacle
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 1259.33f, -4852.02f, 215.763f, 0.0f);
+            break;
+        case 1910: // Vault of Archavon
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5453.72f, 2840.79f, 421.277f, 0.0f);
+            break;
+        case 1911: // Violet Hold
+            player->CLOSE_GOSSIP_MENU();
+            player->TeleportTo(571, 5689.03f, 508.278f, 652.763f, 0.0f);
+            break;
+
+/////// cities
+
+        case 1800: // Stormwind
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8960.14f, 516.266f, 96.3568f, 0.0f); // Teleport(location)
+        break;
+
+        case 1801: // Ironforge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -4924.07f, -951.95f, 501.55f, 5.40f);
+        break;
+
+        case 1802: // Darnassus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 9947.52f, 2482.73f, 1316.21f, 0.0f);
+        break;
+
+        case 1803: // Exodar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3954.20f, -11656.54f, -138.69f, 0.0f);
+        break;
+
+        case 1804: // Shattrath
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1850.209961f, 5435.821777f, -10.961435f, 3.403913f);
+        break;
+
+        case 1805: // Dalaran
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5819.08f, 643.99f, 647.80f, 3.32f);
+        break;
+
+        case 1806: // Gurubashi Arena
+        player->CLOSE_GOSSIP_MENU();
+
+        player->TeleportTo(0,  -13277.4f, 127.372f, 26.1418f, 1.0f);
+        break;
+
+        case 1807: // Orgrimmar
+         player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1552.5f, -4420.66f, 8.94802f, 0.0f);
+        break;
+
+        case 1808: // Undercity
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1819.71f, 238.79f, 60.5321f, 0.0f);
+
+        break;
+
+        case 1809: // Silvermoon
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9338.74f, -7277.27f, 13.7895f, 0.0f);
+        break;
+
+        case 1810: // Thunder Bluff
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -1290.0f, 147.033997f, 129.682007f, 4.919000f);
+        break;
+
+        case 5001: // Horde Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HMM, HMX, HMY, HMZ, 0.0f);
+        break;
+
+        case 5000: // Alliance Mall
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(AMM, AMX, AMY, AMZ, 0.0f);
+        break;
+
+// Leveling Roads
+        case 9999:    // horde level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(HLM, HLX, HLY, HLZ, 0.0f);
+        break;
+
+        case 9998:    //alliance level road
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(ALM, ALX, ALY, ALZ, 0.0f);
+        break;
+// Zones
+        case 1850:  // Azuremyst Isle
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -4216.870117f, -12336.900391f, 4.340638f, 0.0f);
+        break;
+        case 1851:  // Teldrassil
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 10111.299805f, 1557.729980f, 1324.329956f, 0.0f);
+        break;
+        case 1852:  // Elwynn Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9617.059570f, -288.949005f, 57.305149f, 0.0f);
+        break;
+        case 1853:  // Dun Morogh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5451.549805f, -656.992004f, 392.674988f, 0.0f);
+        break;
+        case 1854:  // Durotar
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1007.780029f, -446.220215f, 11.202200f, 0.0f);
+        break;
+        case 1855:  // Mulgore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -2192.620117f, -736.317017f, -13.327400f, 0.0f);
+        break;
+        case 1856:  // Tirisfal Glades
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 2036.020020f, 161.330994f, 33.867401f, 0.0f);
+        break;
+        case 1857:  // Eversong Woods
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 9079.919922f, -7193.229980f, 55.601299f, 0.0f);
+        break;
+        case 1858:  // Darkshore
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 5756.250000f, 298.505005f, 20.604900f, 0.0f);
+        break;
+        case 1859:  // Loch Modan
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -5202.939941f, -2855.179932f, 335.953827f, 0.0f);
+        break;
+        case 1860:  // Redridge Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -9551.809570f, -2204.729980f, 93.473000f, 0.0f);
+        break;
+        case 1861:  // The Barrens
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 884.539978f, -3548.449951f, 91.853165f, 0.0f);
+        break;
+        case 1862:  // Stonetalon Mountains
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1570.920044f, 1031.520020f, 137.959000f, 0.0f);
+        break;
+        case 1863:  // Ashenvale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 1928.339966f, -2165.949951f, 93.789597f, 0.0f);
+        break;
+        case 1864:  // Wetlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -3242.810059f, -2469.040039f, 15.922600f, 0.0f);
+        break;
+        case 1865:  // Thousand Needles
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -4969.020020f, -1726.890015f, -62.126911f, 0.0f);
+        break;
+        case 1866:  // Hillsbrad Foothills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -436.657013f, -581.254028f, 53.594398f, 0.0f);
+        break;
+        case 1867:  // Arathi Highlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -1508.510010f, -2732.060059f, 32.498600f, 0.0f);
+        break;
+        case 1868:  // Desolace
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -606.395020f, 2211.750000f, 92.981796f, 0.0f);
+        break;
+        case 1869:  // Stranglethorn Vale
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -12644.299805f, -377.411011f, 10.102062f, 0.0f);
+        break;
+        case 1870:  // Badlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -6779.200195f, -3423.639893f, 241.667007f, 0.0f);
+        break;
+        case 1871:  // Spawm of Sorrows
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -10345.400391f, -2773.419922f, 21.990000f, 0.0f);
+        break;
+        case 1872:  // The Hinterlands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 119.387001f, -3190.370117f, 117.330994f, 0.0f);
+        break;
+        case 1873:  // Tanaris
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7931.200195f, -3414.280029f, 80.736496f, 0.0f);
+        break;
+        case 1874:  // Blasted Lands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -11182.500000f, -3016.669922f, 7.422350f, 0.0f);
+        break;
+        case 1875:  // Searing Gorge
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -7012.470215f, -1065.130005f, 241.785995f, 0.0f);
+        break;
+        case 1876:  // Un Goro Crater
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7943.220215f, -2119.090088f, -218.344589f, 0.0f);
+        break;
+        case 1877:  // Azshara
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 3341.360107f, -4603.790039f, 92.502701f, 0.0f);
+        break;
+        case 1878:  // Felwood
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 4102.250000f, -1006.789978f, 272.717010f, 0.0f);
+        break;
+        case 1879:  // Winterspring
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, 6759.180176f, -4419.629883f, 763.213989f, 0.0f);
+        break;
+        case 1880:  // Silithus
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(1, -7426.870117f, 1005.309998f, 1.133590f, 0.0f);
+        break;
+        case 1881:  // Western Plaguelands
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, 1728.650024f, -1602.250000f, 63.428963f, 0.0f);
+        break;
+        case 1882:  // Burning Steppes
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(0, -8118.540039f, -1633.829956f, 132.996002f, 0.0f);
+        break;
+        case 1883:  // Hellfire Peninsula
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -211.237000f, 4278.540039f, 86.567802f, 0.0f);
+        break;
+        case 1884:  // Zangarmarsh
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -54.862099f, 5813.439941f, 20.605900f, 0.0f);
+        break;
+        case 1885:  // Terokkar Forest
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -2000.469971f, 4451.540039f, 8.369170f, 0.0f);
+        break;
+        case 1886:  // Nagrand
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -1145.949951f, 8182.350098f, 3.602490f, 0.0f);
+        break;
+        case 1887:  // Blades Edge Mountain
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3037.669922f, 5962.859863f, 130.774002f, 0.0f);
+        break;
+        case 1888:  // Netherstorm
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, 3830.229980f, 3426.500000f, 88.614502f, 0.0f);
+        break;
+        case 1889:  // Shadowmoon Valley
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(530, -3077.271973f, 2878.689209f, 82.129242f, 0.0f);
+        break;
+        case 1890:  // Borean Tundra
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 3256.570068f, 5278.229980f, 40.804588f, 0.0f);
+        break;
+        case 1891:  // Dragonblight
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4103.359863f, 264.477997f, 50.501900f, 0.0f);
+        break;
+        case 1892:  // Grizzly Hills
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 4391.729980f, -3587.919922f, 238.531006f, 0.0f);
+        break;
+        case 1893:  // Zul' Drak
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5560.229980f, -3211.659912f, 371.709015f, 0.0f);
+        break;
+        case 1894:  // Sholazar Basin
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 5323.000000f, 4942.000000f, -133.558670f, 0.0f);
+        break;
+        case 1895:  // The Storm Peaks
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7527.140137f, -1260.890015f, 919.049011f, 0.0f);
+        break;
+        case 1896:  // Howling Fjord
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 1902.150024f, -4883.910156f, 161.363007f, 0.0f);
+        break;
+        case 1897:  // Icecrown
+        player->CLOSE_GOSSIP_MENU();
+        player->TeleportTo(571, 7253.640137f, 1644.780029f, 433.679993f, 0.0f);
+        break;
+
+
+        /// -- Tele part stop -- ///
+
+    /// -- Dungeons, Raids -- ///
+
+
+        /// -- BG Control Part Start -- ///
+            player->ADD_GOSSIP_ITEM(0, "WSG 100%", GOSSIP_SENDER_MAIN, 1400);
+        player->ADD_GOSSIP_ITEM(0, "EOTS 100%", GOSSIP_SENDER_MAIN, 1401);
+        player->ADD_GOSSIP_ITEM(0, "AB 100%", GOSSIP_SENDER_MAIN, 1402);
+        player->ADD_GOSSIP_ITEM(0, "SOTA 100%", GOSSIP_SENDER_MAIN, 1403);
+        player->ADD_GOSSIP_ITEM(0, "AV 100%", GOSSIP_SENDER_MAIN, 1404); // LOL!
+
+        case 1400: // WSG 100%
+        /* Comment: IDS:
+        SOTA - 9
+        AV - 1
+        WSG - 2
+        AB - 3
+        EOTS - 7*/
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=2");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1401: // EOTS 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 2, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=7");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1402: // AB 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 2, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=3");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1403: // Sota 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(1, 3, 7, 2)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=9");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        case 1404: // AV 100%
+        player->CLOSE_GOSSIP_MENU();
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=0 WHERE `id` IN(2, 3, 7, 9)");
+        WorldDatabase.PQuery("UPDATE `battleground_template` SET `Weight`=10 WHERE `id`=1");
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "Done", GOSSIP_SENDER_MAIN, 12345);
+        break;
+
+        /// -- BG Modify Part End -- ///
+
+        /* Break */
+
+
+
+
+
+        /// -- Token Part Start -- ///
+
+        /*
+            case 107: // Token -> BUY
+        player->ADD_GOSSIP_ITEM(0, tokenbuy, GOSSIP_SENDER_MAIN, 1200);
+        break;
+
+        case 108: // Token ->Change
+        player->ADD_GOSSIP_ITEM(0, tokenchange, GOSSIP_SENDER_MAIN, 1300);
+        break;
+        */
+
+        case 1201: // Token change
+        if(player->HasItemCount(token1, 1, false))
+        {
+        player->ItemRemovedQuestCheck(token1, 1);
+        player->AddItem(token2, 1);
+        } else {
+        player->ADD_GOSSIP_ITEM(GOSSIP_ICON_CHAT, "You don't have got enough token.", GOSSIP_SENDER_MAIN, 12345);
+        break;
+        }
+
+        case 1200:
+        player->ADD_GOSSIP_ITEM_EXTENDED(0, tokenbuy, GOSSIP_SENDER_MAIN, 2000, "Are you sure you want to buy a token?", -10000, 0);
+        break;
+        case 2000:
+        player->AddItem(vasarolhatotoken, 1);
+        break;
+
+        ///-- Token Part End --///
+
+        ///-- Trainers Part Start --///
+        /*
+        player->ADD_GOSSIP_ITEM(1, "Prof Trainer", GOSSIP_SENDER_MAIN, 800);
+        player->ADD_GOSSIP_ITEM(1, "Class Trainer", GOSSIP_SENDER_MAIN, 801);
+        player->ADD_GOSSIP_ITEM(1, "Weapon Trainer", GOSSIP_SENDER_MAIN, 802);
+        player->ADD_GOSSIP_ITEM(1, "Mount Trainer", GOSSIP_SENDER_MAIN, 803);
+        */
+
+        case 803: // Mount Trainer
+        {
+        player->CLOSE_GOSSIP_MENU();
+        player->LearnSpell(33388, false);
+        player->LearnSpell(33391, false);
+        player->LearnSpell(34090, false);
+        player->LearnSpell(34091, false);
+        player->LearnSpell(54197, false);
+        }
+
+        case 800: // profs
+        // SPGM
+        player->ADD_GOSSIP_ITEM(3, "Alchemy"                     , GOSSIP_SENDER_MAIN, 2100);
+        player->ADD_GOSSIP_ITEM(3, "Blacksmithing"           , GOSSIP_SENDER_MAIN, 2101);
+        player->ADD_GOSSIP_ITEM(3, "Enchanter"        , GOSSIP_SENDER_MAIN, 2102);
+        player->ADD_GOSSIP_ITEM(3, "Engineering"              , GOSSIP_SENDER_MAIN, 2103);
+        player->ADD_GOSSIP_ITEM(3, "Herbalism"            , GOSSIP_SENDER_MAIN, 2104);
+        player->ADD_GOSSIP_ITEM(3, "Inscription"        , GOSSIP_SENDER_MAIN, 2105);
+        player->ADD_GOSSIP_ITEM(3, "Jewelcrafting"           , GOSSIP_SENDER_MAIN, 2106);
+        player->ADD_GOSSIP_ITEM(3, "Leatherworking"           , GOSSIP_SENDER_MAIN, 2107);
+        player->ADD_GOSSIP_ITEM(3, "Mining"                , GOSSIP_SENDER_MAIN, 2108);
+        player->ADD_GOSSIP_ITEM(3, "Skinning"        , GOSSIP_SENDER_MAIN, 2109);
+        player->ADD_GOSSIP_ITEM(3, "Tailoring"                  , GOSSIP_SENDER_MAIN, 2110);
+        player->ADD_GOSSIP_ITEM(3, "Cooking"              , GOSSIP_SENDER_MAIN, 2111);
+        player->ADD_GOSSIP_ITEM(3, "First Aid"            , GOSSIP_SENDER_MAIN, 2112);
+        player->ADD_GOSSIP_ITEM(3, "Fishing"              , GOSSIP_SENDER_MAIN, 2113);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+        case 801: // Class Trainers
+
+        player->ADD_GOSSIP_ITEM(3, "Death Knight"          , GOSSIP_SENDER_MAIN, 2200);
+        player->ADD_GOSSIP_ITEM(3, "Druid"               , GOSSIP_SENDER_MAIN, 2201);
+        player->ADD_GOSSIP_ITEM(3, "Hunter"            , GOSSIP_SENDER_MAIN, 2202);
+        player->ADD_GOSSIP_ITEM(3, "Mage"            , GOSSIP_SENDER_MAIN, 2203);
+        player->ADD_GOSSIP_ITEM(3, "Paladin"             , GOSSIP_SENDER_MAIN, 2204);
+        player->ADD_GOSSIP_ITEM(3, "Priest"                , GOSSIP_SENDER_MAIN, 2205);
+        player->ADD_GOSSIP_ITEM(3, "Rogue"                       , GOSSIP_SENDER_MAIN, 2206);
+        player->ADD_GOSSIP_ITEM(3, "Shaman"               , GOSSIP_SENDER_MAIN, 2207);
+        player->ADD_GOSSIP_ITEM(3, "Warlock"        , GOSSIP_SENDER_MAIN, 2208);
+        player->ADD_GOSSIP_ITEM(3, "Warrior"                 , GOSSIP_SENDER_MAIN, 2209);
+        player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,_Creature->GetGUID());
+        break;
+
+        case 2200:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dk,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2201:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(dudu,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2202:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(hunta,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2203:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(mage,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2204:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(pala,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2205:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(priest,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2206:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(rogue,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2207:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(sami,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2208:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(lock,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+           case 2209:
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(wari,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        //Sickness,Reset Talent Start//
+        case 121: // Reset Talent Pont
+        player->CLOSE_GOSSIP_MENU();
+        player->SendTalentWipeConfirm(_Creature->GetGUID());
+        break;
+
+        case 120: //Sickness leszedse
+        if(!player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0))
+        {
+            _Creature->MonsterWhisper(nosickness, player);
+        }
+        else
+        {
+        _Creature->CastSpell(player,38588,false); // Flash Heal
+        player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+        player->CLOSE_GOSSIP_MENU();
+        break;
+        //Sickness,Reset Talent End//
+        ////// Prof trainers
+
+        case 2100: // Alchemy
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(33630,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        player->SummonCreature(28703,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+        case 2101: // Blacksmithing
+        player->CLOSE_GOSSIP_MENU();
+        player->SummonCreature(28694,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+        break;
+
+case 2102: // Enchanting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28693,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+    player->SummonCreature(33633,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2103: // Engineering
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28697,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2104: // Herbalism
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28704,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+case 2105: // Inscription
+ player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28702,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2106: // Jewelcrafting
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28701,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2107: // Leatherworking
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28700,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2108: // Mining
+    player->CLOSE_GOSSIP_MENU();    player->SummonCreature(28698,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2109: // Skinning
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28696,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2110: // Tailoring
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28699,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2111: // Cooking
+   player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28705,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+case 2112: // First Aid
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28706,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+
+        case 2113: // Fishing
+    player->CLOSE_GOSSIP_MENU();
+    player->SummonCreature(28742,player->GetPositionX() ,player->GetPositionY(), player->GetPositionZ(), 0,TEMPSUMMON_TIMED_DESPAWN,120000);
+break;
+}
+//return true;
+    }
+
+bool OnGossipSelect(Player* player, Creature* _Creature, uint32 sender, uint32 action)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (sender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, _Creature, action);
+
+return true;
+}
+};
+
+void AddSC_npc_all()
+{
+    new npc_all();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/beastmaster.cpp b/src/server/scripts/Custom/beastmaster.cpp
new file mode 100644
index 0000000..9cff63d
--- /dev/null
+++ b/src/server/scripts/Custom/beastmaster.cpp
@@ -0,0 +1,385 @@
+//Modified by Marcus rewritten by LordPsyan
+//original script created by ??
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "Pet.h"
+#include "SystemConfig.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define MSG_TYPE                100004
+#define MSG_PET                 100005
+#define MAIN_MENU               "<= [Main Menu]"
+
+class Npc_Beastmaster : public CreatureScript
+{
+public:
+        Npc_Beastmaster() : CreatureScript("Npc_Beastmaster") { }
+
+void CreatePet(Player *player, Creature * m_creature, uint32 entry) {
+
+    if(sConfigMgr->GetBoolDefault("BeastMaster.OnlyHunter", false)) // Checks to see if Only Hunters can have pets.
+     {
+        if(player->getClass() != CLASS_HUNTER) {
+            m_creature->MonsterWhisper("You are not a Hunter!", player);
+            return;
+        }
+     }
+
+    if(player->GetPet()) {
+        m_creature->MonsterWhisper("First you must abandon your Pet!", player);
+        return;
+    }
+
+    Creature *creatureTarget = m_creature->SummonCreature(entry, player->GetPositionX(), player->GetPositionY()+2, player->GetPositionZ(), player->GetOrientation(), TEMPSUMMON_CORPSE_TIMED_DESPAWN, 500);
+    if(!creatureTarget) return;
+
+    Pet* pet = player->CreateTamedPetFrom(creatureTarget, 0);
+
+    if(!pet) return;
+
+        // kill original creature
+    creatureTarget->setDeathState(JUST_DIED);
+    creatureTarget->RemoveCorpse();
+    creatureTarget->SetHealth(0);                       // just for nice GM-mode view
+
+    pet->SetPower(POWER_HAPPINESS, 1048000);
+
+    // prepare visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel() - 1);
+    pet->GetMap()->AddToMap((Creature*)pet);
+        // visual effect for levelup
+    pet->SetUInt32Value(UNIT_FIELD_LEVEL, player->getLevel());
+
+    if(!pet->InitStatsForLevel(player->getLevel()))
+        TC_LOG_ERROR("scripts", "Pet Create fail: no init stats for entry %u", entry);
+        pet->UpdateAllStats();
+
+    // caster have pet now
+        player->SetMinion(pet, true);
+
+        pet->SavePetToDB(PET_SAVE_AS_CURRENT);
+        pet->InitTalentForLevel();
+        player->PetSpellInitialize();
+    //end
+        player->CLOSE_GOSSIP_MENU();
+        m_creature->MonsterWhisper("Pet added. You might want to feed it and name it somehow.", player);
+        return;
+    }
+
+bool OnGossipHello(Player* player, Creature* m_creature)
+{
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+    // Main Menu
+
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+return true;
+}
+
+bool showNormalPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 0 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->MonsterWhisper("You don't have enough money.", player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showNormalPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showExoticPet(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 1 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ //m_creature->MonsterWhisper("You don't have enough money.", player);
+ //player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showExoticPet(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPetSpells(Player *player, Creature *m_creature, uint32 showFromId = 0)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `entry`, `name` FROM `beastmaster` WHERE `cat_number` = 2 ORDER BY `entry` ASC");
+
+ if (result)
+ {
+ uint32 entryNum = 0;
+ std::string petName = "";
+ uint8 tokenOrGold = 0;
+ uint32 price = 0;
+ uint32 nToken = 0;
+
+  do
+ {
+ Field *fields = result->Fetch();
+ entryNum = fields[0].GetInt32();
+ petName = fields[1].GetString();
+
+    player->ADD_GOSSIP_ITEM(9, petName, GOSSIP_SENDER_MAIN, entryNum);
+}
+ while (result->NextRow());
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ m_creature->MonsterWhisper("You don't have enough money.", player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPetSpells(player, m_creature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* player, Creature* m_creature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (player->IsInCombat())
+{
+    player->CLOSE_GOSSIP_MENU();
+    m_creature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableNormalPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableNormalPet", true);
+    bool EnableExoticPet = sConfigMgr->GetBoolDefault("BeastMaster.EnableExoticPet", true);
+
+  // send name as gossip item
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 cost = 0;
+        std::string spellName = "";
+        uint32 token = 0;
+        bool tokenOrGold = true;
+
+        result = WorldDatabase.PQuery("SELECT * FROM `beastmaster` WHERE `entry` = %u LIMIT 1", uiAction);
+
+if (result)
+{
+    do {
+        Field *fields = result->Fetch();
+        catNumber = fields[1].GetInt32();
+        tokenOrGold = fields[2].GetBool();
+        cost = fields[3].GetInt32();
+        token = fields[4].GetInt32();
+        spellName = fields[5].GetString();
+        spellId = fields[6].GetInt32();
+
+        if (tokenOrGold)
+        {
+            if (!player->HasItemCount(token, cost))
+                {
+                    m_creature->MonsterWhisper("You ain't gots no darn chips.", player);
+                    player->CLOSE_GOSSIP_MENU();
+                    return;
+                }
+            else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+            {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->DestroyItemCount(token, cost, true);
+            }
+            else if (catNumber = 2)
+            {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->MonsterWhisper("You already know this spell.", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->LearnSpell(spellId, false);
+    player->DestroyItemCount(token, cost, true);
+            }
+        }
+
+        } else {
+            if (player->GetMoney() < cost)
+            {
+                m_creature->MonsterWhisper("You dont have enough money!", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            }
+        else if (uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && catNumber != 2)
+        {
+    player->CLOSE_GOSSIP_MENU();
+    CreatePet(player, m_creature, spellId);
+    player->ModifyMoney(-int(cost));
+        }
+        else if (catNumber = 2)
+        {
+            if (player->HasSpell(spellId))
+            {
+                m_creature->MonsterWhisper("You already know this spell.", player);
+                player->CLOSE_GOSSIP_MENU();
+                return;
+            } else {
+    player->CLOSE_GOSSIP_MENU();
+    player->LearnSpell(spellId, false);
+    player->ModifyMoney(-int(cost));
+            }
+        }
+    }
+} while (result->NextRow());
+} else {
+//player->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+}
+
+ switch(uiAction)
+{
+
+case 1000: //Normal Pet
+        showNormalPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 2000: //Exotic Pet
+        showExoticPet(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 3000: //Pet Spells
+        showPetSpells(player, m_creature, 0);
+        player->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    player->SEND_GOSSIP_MENU(MSG_PET, m_creature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Normal Pet " is enabled or not
+    if(EnableNormalPet)
+        player->ADD_GOSSIP_ITEM( 7, "Normal Pets ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check if player can have an exotic pet, and check config if "Exotic" is enabled or not
+    if(player->CanTameExoticPets() && EnableExoticPet)
+        player->ADD_GOSSIP_ITEM( 7, "Exotic Pets ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Now to add the spells, vendor, and stable stuffs
+    player->ADD_GOSSIP_ITEM(4, "Teach Me Pet spells ->"      , GOSSIP_SENDER_MAIN, 3000);
+    player->ADD_GOSSIP_ITEM(2, "Take me to the Stable.", GOSSIP_SENDER_MAIN, 6006);
+    player->ADD_GOSSIP_ITEM(6, "Sell me some Food for my Pet.", GOSSIP_SENDER_MAIN, 6007);
+    player->SEND_GOSSIP_MENU(MSG_TYPE, m_creature->GetGUID());
+break;
+
+case 6006:
+    player->GetSession()->SendStablePet(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+case 6007:
+    player->GetSession()->SendListInventory(m_creature->GetGUID());
+    player->CLOSE_GOSSIP_MENU();
+    break;
+
+ player->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* player, Creature* m_creature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    player->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(player, m_creature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_Npc_Beastmaster()
+{
+    new Npc_Beastmaster();
+}
diff --git a/src/server/scripts/Custom/bountyhunter.cpp b/src/server/scripts/Custom/bountyhunter.cpp
new file mode 100644
index 0000000..389b457
--- /dev/null
+++ b/src/server/scripts/Custom/bountyhunter.cpp
@@ -0,0 +1,462 @@
+#include "ScriptPCH.h"
+#include <cstring>
+
+using namespace std;
+
+#define SET_CURRENCY 0  //0 for gold, 1 for honor, 2 for tokens
+#define TOKEN_ID 0 // token id
+
+#if SET_CURRENCY == 0
+#define BOUNTY_1 "1000g Kopfgeld."
+#define BOUNTY_2 "2000g Kopfgeld."
+#define BOUNTY_3 "5000g Kopfgeld."
+#define BOUNTY_4 "10000g Kopfgeld."
+#endif
+#if SET_CURRENCY == 1
+#define BOUNTY_1 "I would like to place a 20 honor bounty."
+#define BOUNTY_2 "I would like to place a 40 honor bounty."
+#define BOUNTY_3 "I would like to place a 100 honor bounty."
+#define BOUNTY_4 "I would like to place a 200 honor bounty."
+#endif
+#if SET_CURRENCY == 2
+#define BOUNTY_1 "I would like to place a 1 token bounty."
+#define BOUNTY_2 "I would like to place a 3 token bounty."
+#define BOUNTY_3 "I would like to place a 5 token bounty."
+#define BOUNTY_4 "I would like to place a 10 token bounty."
+#endif
+
+#define PLACE_BOUNTY "Ich will Jemanden tot sehen!"
+#define LIST_BOUNTY "Zeig mir die Liste der Opfer!"
+#define NVM "Ich moechte doch nichts."
+
+
+
+
+
+#if SET_CURRENCY != 2
+
+enum BountyPrice
+{
+    BOUNTY_PRICE_1 = 1000,
+    BOUNTY_PRICE_2 = 2000,
+    BOUNTY_PRICE_3 = 5000,
+    BOUNTY_PRICE_4 = 10000,
+};
+#else
+enum BountyPrice
+{
+    BOUNTY_PRICE_1 = 1,
+    BOUNTY_PRICE_2 = 3,
+    BOUNTY_PRICE_3 = 5,
+    BOUNTY_PRICE_4 = 10,
+};
+#endif
+
+bool passChecks(Player * pPlayer, const char * name)
+{
+
+    Player * pBounty = sObjectAccessor->FindPlayerByName(name);
+    WorldSession * m_session = pPlayer->GetSession();
+    if(!pBounty)
+    {
+        m_session->SendNotification("Es ist kein Spieler mit diesem Namen online!");
+        return false;
+    }
+    QueryResult result = CharacterDatabase.PQuery("SELECT * FROM bounties WHERE guid ='%u'", pBounty->GetGUID());
+    if(result)
+    {
+        m_session->SendNotification("Auf diesen Spieler wurde schon ein Kopfgeld ausgesetzt!");
+        return false;
+    }
+    if(pPlayer->GetGUID() == pBounty->GetGUID())
+    {
+        m_session->SendNotification("Du kannst auf dich kein Kopfgeld aussetzen!");
+        return false;
+    }
+    return true;
+}
+
+void alertServer(const char * name, int msg)
+{
+        std::string message;
+        if(msg == 1)
+        {
+                message = "Ein Kopfgeld wurde aufsgesetzt auf ";
+                message += name;
+                message += ". Ttet ihn und erlangt das Gold!";
+        }
+        else if(msg == 2)
+        {
+                message = "Das Kopfgeld von ";
+                message += name;
+                message += " wurde eingelst!";
+        }
+        sWorld->SendServerMessage(SERVER_MSG_STRING, message.c_str(), 0);
+}
+
+
+bool hasCurrency(Player * pPlayer, uint32 required, int currency)
+{
+    WorldSession *m_session = pPlayer->GetSession();
+    switch(currency)
+    {
+        case 0: //gold
+            {
+            uint32 currentmoney = pPlayer->GetMoney();
+            uint32 requiredmoney = (required * 10000);
+            if(currentmoney < requiredmoney)
+            {
+                m_session->SendNotification("Du hast nicht genug Gold!");
+                return false;
+            }
+            pPlayer->SetMoney(currentmoney - requiredmoney);
+            break;
+            }
+        case 1: //honor
+            {
+            uint32 currenthonor = pPlayer->GetHonorPoints();
+            if(currenthonor < required)
+            {
+                m_session->SendNotification("You don't have enough honor!");
+                return false;
+            }
+            pPlayer->SetHonorPoints(currenthonor - required);
+            break;
+            }
+        case 2: //tokens
+            {
+            if(!pPlayer->HasItemCount(TOKEN_ID, required))
+            {
+                m_session->SendNotification("You don't have enough tokens!");
+                return false;
+            }
+            pPlayer->DestroyItemCount(TOKEN_ID, required, true, false);
+            break;
+            }
+
+    }
+    return true;
+}
+
+void flagPlayer(const char * name)
+{
+    std::string message;
+    Player * pBounty = sObjectAccessor->FindPlayerByName(name);
+    pBounty->SetPvP(true);
+    pBounty->SetByteFlag(UNIT_FIELD_BYTES_2, 1, UNIT_BYTE2_FLAG_FFA_PVP);
+}
+
+class BountyHunter : public CreatureScript
+{
+    public:
+        BountyHunter() : CreatureScript("BountyHunter"){}
+        bool OnGossipHello(Player * Player, Creature * Creature)
+        {
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, PLACE_BOUNTY, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+1);
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, LIST_BOUNTY, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+2);
+            Player->ADD_GOSSIP_ITEM(GOSSIP_ICON_TALK, NVM, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+3);
+            Player->PlayerTalkClass->SendGossipMenu(907, Creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 /*uiSender*/, uint32 uiAction)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            switch(uiAction)
+            {
+                case GOSSIP_ACTION_INFO_DEF+1:
+                {
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_1, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+5, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_2, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+6, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_3, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+7, "", 0, true);
+                    pPlayer->ADD_GOSSIP_ITEM_EXTENDED(GOSSIP_ICON_BATTLE, BOUNTY_4, GOSSIP_SENDER_MAIN, GOSSIP_ACTION_INFO_DEF+8, "", 0, true);
+                    pPlayer->PlayerTalkClass->SendGossipMenu(365, pCreature->GetGUID());
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+2:
+                {
+                    QueryResult Bounties = CharacterDatabase.PQuery("SELECT * FROM bounties");
+
+                    if(!Bounties)
+                    {
+                        pPlayer->PlayerTalkClass->SendCloseGossip();
+                        return false;
+                    }
+#if SET_CURRENCY == 0
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " gold";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " gold";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+#if SET_CURRENCY == 1
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " honor";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " honor";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+#if SET_CURRENCY == 2
+                    if(    Bounties->GetRowCount() > 1)
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        do
+                        {
+                            Field * fields = Bounties->Fetch();
+                            std::string option;
+                            QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                            Field * names = name->Fetch();
+                            option = names[0].GetString();
+                            option +=" ";
+                            option += fields[1].GetString();
+                            option += " coins";
+                            pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+                        }while(Bounties->NextRow());
+                    }
+                    else
+                    {
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, "Kopfgeld: ", GOSSIP_SENDER_MAIN, 1);
+                        Field * fields = Bounties->Fetch();
+                        std::string option;
+                        QueryResult name = CharacterDatabase.PQuery("SELECT name FROM characters WHERE guid='%u'", fields[0].GetUInt64());
+                        Field * names = name->Fetch();
+                        option = names[0].GetString();
+                        option +=" ";
+                        option += fields[1].GetString();
+                        option += " coins";
+                        pPlayer->ADD_GOSSIP_ITEM(GOSSIP_ICON_BATTLE, option, GOSSIP_SENDER_MAIN, 1);
+
+                    }
+#endif
+                    pPlayer->PlayerTalkClass->SendGossipMenu(878, pCreature->GetGUID());
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+3:
+                {
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                    break;
+                }
+                case GOSSIP_ACTION_INFO_DEF+4:
+                {
+                    CharacterDatabase.PExecute("TRUNCATE TABLE bounties");
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                    break;
+                }
+            }
+            return true;
+        }
+
+        bool OnGossipSelectCode(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction, const char * code)
+        {
+            pPlayer->PlayerTalkClass->ClearMenus();
+            if ( uiSender == GOSSIP_SENDER_MAIN )
+            {
+                if(islower(code[0]))
+                    toupper(code[0]);
+
+                if(passChecks(pPlayer, code))
+                {
+                    Player * pBounty = sObjectAccessor->FindPlayerByName(code);
+                    switch (uiAction)
+                    {
+                        case GOSSIP_ACTION_INFO_DEF+5:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_1, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u','1000', '1')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u','1', '1')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+
+                        case GOSSIP_ACTION_INFO_DEF+6:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_2, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '2000', '2')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '3', '2')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+                        case GOSSIP_ACTION_INFO_DEF+7:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_3, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '5000', '3')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '5', '3')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+                        case GOSSIP_ACTION_INFO_DEF+8:
+                        {
+                            if(hasCurrency(pPlayer, BOUNTY_PRICE_4, SET_CURRENCY))
+                            {
+                                #if SET_CURRENCY != 2
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '10000', '4')", pBounty->GetGUID());
+                                #else
+                                CharacterDatabase.PExecute("INSERT INTO bounties VALUES('%u', '10', '3')", pBounty->GetGUID());
+                                #endif
+                                alertServer(code, 1);
+                                flagPlayer(code);
+                                pPlayer->PlayerTalkClass->SendCloseGossip();
+                            }
+                            break;
+                        }
+
+                    }
+                }
+                else
+                {
+                    pPlayer->PlayerTalkClass->SendCloseGossip();
+                }
+            }
+            return true;
+        }
+};
+
+
+class BountyKills : public PlayerScript
+{
+    public:
+        BountyKills() : PlayerScript("BountyKills"){}
+
+        void OnPVPKill(Player * Killer, Player * Bounty)
+        {
+            if(Killer->GetGUID() == Bounty->GetGUID())
+                return;
+
+            QueryResult result = CharacterDatabase.PQuery("SELECT * FROM bounties WHERE guid='%u'", Bounty->GetGUID());
+            if(!result)
+                return;
+
+            Field * fields = result->Fetch();
+#if SET_CURRENCY == 0
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_1 * 10000));
+                break;
+            case 2:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_2 * 10000));
+                break;
+            case 3:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_3 * 10000));
+                break;
+            case 4:
+                Killer->SetMoney(Killer->GetMoney() + (BOUNTY_PRICE_4 * 10000));
+                break;
+            }
+#endif
+#if SET_CURRENCY == 1
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_1));
+                break;
+            case 2:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_2));
+                break;
+            case 3:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_3));
+                break;
+            case 4:
+                Killer->SetHonorPoints(Killer->GetHonorPoints() + (BOUNTY_PRICE_4));
+                break;
+            }
+#endif
+#if SET_CURRENCY == 2
+            switch(fields[2].GetUInt64())
+            {
+            case 1:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_1);
+                break;
+            case 2:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_2);
+                break;
+            case 3:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_3);
+                break;
+            case 4:
+                Killer->AddItem(TOKEN_ID, BOUNTY_PRICE_4);
+                break;
+            }
+#endif
+            CharacterDatabase.PExecute("DELETE FROM bounties WHERE guid='%u'", Bounty->GetGUID());
+            alertServer(Bounty->GetName().c_str(), 2);
+
+        }
+};
+
+void AddSC_BountyHunter()
+{
+    new BountyHunter();
+    new BountyKills();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/enchant.cpp b/src/server/scripts/Custom/enchant.cpp
new file mode 100644
index 0000000..c6a7fdc
--- /dev/null
+++ b/src/server/scripts/Custom/enchant.cpp
@@ -0,0 +1,1621 @@
+enum Enchants
+{
+    ENCHANT_WEP_BERSERKING              = 3789,
+    ENCHANT_WEP_BLADE_WARD              = 3869,
+    ENCHANT_WEP_BLOOD_DRAINING          = 3870,
+    ENCHANT_WEP_ACCURACY                = 3788,
+    ENCHANT_WEP_AGILITY_1H              = 1103,
+    ENCHANT_WEP_SPIRIT                  = 3844,
+    ENCHANT_WEP_BATTLEMASTER            = 2675,
+    ENCHANT_WEP_BLACK_MAGIC             = 3790,
+    ENCHANT_WEP_ICEBREAKER              = 3239,
+    ENCHANT_WEP_LIFEWARD                = 3241,
+    ENCHANT_WEP_MIGHTY_SPELL_POWER      = 3834, // One-hand
+    ENCHANT_WEP_EXECUTIONER             = 3225,
+    ENCHANT_WEP_POTENCY                 = 3833,
+    ENCHANT_WEP_TITANGUARD              = 3851,
+    ENCHANT_2WEP_MASSACRE               = 3827,
+    ENCHANT_2WEP_SCOURGEBANE            = 3247,
+    ENCHANT_2WEP_GIANT_SLAYER            = 3251,
+    ENCHANT_2WEP_GREATER_SPELL_POWER    = 3854,
+    ENCHANT_2WEP_AGILITY                = 2670,
+    ENCHANT_2WEP_MONGOOSE               = 2673,
+
+    ENCHANT_SHIELD_DEFENSE              = 1952,
+    ENCHANT_SHIELD_INTELLECT            = 1128,
+    ENCHANT_SHIELD_RESILIENCE           = 3229,
+    ENCHANT_SHIELD_BLOCK                = 2655,
+    ENCHANT_SHIELD_STAMINA                = 1071,
+    ENCHANT_SHIELD_TOUGHSHIELD            = 2653,
+    ENCHANT_SHIELD_TITANIUM_PLATING     = 3849,
+
+    ENCHANT_HEAD_BLISSFUL_MENDING       = 3819,
+    ENCHANT_HEAD_BURNING_MYSTERIES      = 3820,
+    ENCHANT_HEAD_DOMINANCE              = 3796,
+    ENCHANT_HEAD_SAVAGE_GLADIATOR       = 3842,
+    ENCHANT_HEAD_STALWART_PROTECTOR     = 3818,
+    ENCHANT_HEAD_TORMENT                = 3817,
+    ENCHANT_HEAD_TRIUMPH                = 3795,
+    ENCHANT_HEAD_ECLIPSED_MOON            = 3815,
+    ENCHANT_HEAD_FLAME_SOUL                = 3816,
+    ENCHANT_HEAD_FLEEING_SHADOW            = 3814,
+    ENCHANT_HEAD_FROSTY_SOUL            = 3812,
+    ENCHANT_HEAD_TOXIC_WARDING            = 3813,
+
+    ENCHANT_SHOULDER_MASTERS_AXE        = 3835,
+    ENCHANT_SHOULDER_MASTERS_CRAG       = 3836,
+    ENCHANT_SHOULDER_MASTERS_PINNACLE   = 3837,
+    ENCHANT_SHOULDER_MASTERS_STORM      = 3838,
+    ENCHANT_SHOULDER_GREATER_AXE        = 3808,
+    ENCHANT_SHOULDER_GREATER_CRAG       = 3809,
+    ENCHANT_SHOULDER_GREATER_GLADIATOR  = 3852,
+    ENCHANT_SHOULDER_GREATER_PINNACLE   = 3811,
+    ENCHANT_SHOULDER_GREATER_STORM      = 3810,
+    ENCHANT_SHOULDER_DOMINANCE          = 3794,
+    ENCHANT_SHOULDER_TRIUMPH            = 3793,
+
+    ENCHANT_CLOAK_DARKGLOW_EMBROIDERY   = 3728,
+    ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY = 3730,
+    ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY = 3722,
+    ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE  = 3859,
+    ENCHANT_CLOAK_WISDOM                = 3296,
+    ENCHANT_CLOAK_TITANWEAVE            = 1951,
+    ENCHANT_CLOAK_SPELL_PIERCING        = 3243,
+    ENCHANT_CLOAK_SHADOW_ARMOR          = 3256,
+    ENCHANT_CLOAK_MIGHTY_ARMOR          = 3294,
+    ENCHANT_CLOAK_MAJOR_AGILITY         = 1099,
+    ENCHANT_CLOAK_GREATER_SPEED         = 3831,
+
+    ENCHANT_LEG_EARTHEN                    = 3853,
+    ENCHANT_LEG_FROSTHIDE                = 3822,
+    ENCHANT_LEG_ICESCALE                = 3823,
+    ENCHANT_LEG_BRILLIANT_SPELLTHREAD    = 3719,
+    ENCHANT_LEG_SAPPHIRE_SPELLTHREAD    = 3721,
+    ENCHANT_LEG_DRAGONSCALE                = 3331,
+    ENCHANT_LEG_WYRMSCALE                = 3332,
+
+    ENCHANT_GLOVES_GREATER_BLASTING        = 3249,
+    ENCHANT_GLOVES_ARMSMAN                = 3253,
+    ENCHANT_GLOVES_CRUSHER                = 1603,
+    ENCHANT_GLOVES_AGILITY                = 3222,
+    ENCHANT_GLOVES_PRECISION            = 3234,
+    ENCHANT_GLOVES_EXPERTISE            = 3231,
+
+    ENCHANT_BRACERS_MAJOR_STAMINA        = 3850,
+    ENCHANT_BRACERS_SUPERIOR_SP            = 2332,
+    ENCHANT_BRACERS_GREATER_ASSUALT        = 3845,
+    ENCHANT_BRACERS_MAJOR_SPIRT            = 1147,
+    ENCHANT_BRACERS_EXPERTISE            = 3231,
+    ENCHANT_BRACERS_GREATER_STATS        = 2661,
+    ENCHANT_BRACERS_INTELLECT            = 1119,
+    ENCHANT_BRACERS_FURL_ARCANE            = 3763,
+    ENCHANT_BRACERS_FURL_FIRE            = 3759,
+    ENCHANT_BRACERS_FURL_FROST            = 3760,
+    ENCHANT_BRACERS_FURL_NATURE            = 3762,
+    ENCHANT_BRACERS_FURL_SHADOW            = 3761,
+    ENCHANT_BRACERS_FURL_ATTACK            = 3756,
+    ENCHANT_BRACERS_FURL_STAMINA        = 3757,
+    ENCHANT_BRACERS_FURL_SPELLPOWER        = 3758,
+
+    ENCHANT_CHEST_POWERFUL_STATS        = 3832,
+    ENCHANT_CHEST_SUPER_HEALTH            = 3297,
+    ENCHANT_CHEST_GREATER_MAINA_REST        = 2381,
+    ENCHANT_CHEST_EXCEPTIONAL_RESIL        = 3245,
+    ENCHANT_CHEST_GREATER_DEFENSE        = 1953,
+
+    ENCHANT_BOOTS_GREATER_ASSULT        = 1597,
+    ENCHANT_BOOTS_TUSKARS_VITLIATY        = 3232,
+    ENCHANT_BOOTS_SUPERIOR_AGILITY        = 983,
+    ENCHANT_BOOTS_GREATER_SPIRIT        = 1147,
+    ENCHANT_BOOTS_GREATER_VITALITY        = 3244,
+    ENCHANT_BOOTS_ICEWALKER                = 3826,
+    ENCHANT_BOOTS_GREATER_FORTITUDE        = 1075,
+    ENCHANT_BOOTS_NITRO_BOOTS            = 3606,
+    ENCHANT_BOOTS_PYRO_ROCKET            = 3603,
+    ENCHANT_BOOTS_HYPERSPEED            = 3604,
+    ENCHANT_BOOTS_ARMOR_WEBBING            = 3860,
+
+    ENCHANT_RING_ASSULT                    = 3839,
+    ENCHANT_RING_GREATER_SP                = 3840,
+    ENCHANT_RING_STAMINA                = 3791,
+};
+
+#include "ScriptPCH.h"
+
+void Enchant(Player* player, Item* item, uint32 enchantid)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You must first equip the item you are trying to enchant in order to enchant it!");
+        return;
+    }
+
+
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    item->SetEnchantment(PERM_ENCHANTMENT_SLOT, enchantid, 0, 0);
+    player->GetSession()->SendNotification("|cff800080%s |cffFF0000succesfully enchanted!", item->GetTemplate()->Name1.c_str());
+}
+
+void RemoveEnchant(Player* player, Item* item)
+{
+    if (!item)
+    {
+        player->GetSession()->SendNotification("You don't have the item equipped?");
+        return;
+    }
+
+    item->ClearEnchantment(PERM_ENCHANTMENT_SLOT);
+    player->GetSession()->SendNotification("|cff800080%s's |cffFF0000enchant has successfully been removed!", item->GetTemplate()->Name1.c_str());
+}
+
+class npc_enchantment : public CreatureScript
+{
+public:
+    npc_enchantment() : CreatureScript("npc_enchantment") { }
+
+        bool OnGossipHello(Player* player, Creature* creature)
+        {
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+            player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+            if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+            {
+                player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+            }
+            player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+            player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+            return true;
+        }
+
+        bool OnGossipSelect(Player* player, Creature* creature, uint32 /*sender*/, uint32 action)
+        {
+            player->PlayerTalkClass->ClearMenus();
+            Item * item;
+
+            switch (action)
+            {
+
+                case 1: // Enchant Weapon
+                    if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 102);
+                        player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 103);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 100);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 101);
+                    player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                    player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 105);
+                    player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 106);
+                    player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 107);
+                    player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 108);
+                    player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 109);
+                    player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 110);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 111);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 112);
+                    player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                    player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 2: // Enchant 2H Weapon
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a Two-Handed weapon first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 104);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Spellpower", GOSSIP_SENDER_MAIN, 115);
+                            player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 116);
+                            player->ADD_GOSSIP_ITEM(1, "Massacre", GOSSIP_SENDER_MAIN, 117);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 113);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 114);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100003, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 3: // Enchant Shield
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendNotification("You must equip a shield first.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Defense", GOSSIP_SENDER_MAIN, 118);
+                            player->ADD_GOSSIP_ITEM(1, "Greater Intellect", GOSSIP_SENDER_MAIN, 119);
+                            player->ADD_GOSSIP_ITEM(1, "Resilience", GOSSIP_SENDER_MAIN, 120);
+                            player->ADD_GOSSIP_ITEM(1, "Titanium Plating", GOSSIP_SENDER_MAIN, 121);
+                            player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 122);
+                            player->ADD_GOSSIP_ITEM(1, "Tough Shield", GOSSIP_SENDER_MAIN, 123);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100004, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 4: // Enchant Head
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Blissful Mending", GOSSIP_SENDER_MAIN, 124);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Burning Mysteries", GOSSIP_SENDER_MAIN, 125);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Dominance", GOSSIP_SENDER_MAIN, 126);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Savage Gladiator", GOSSIP_SENDER_MAIN, 127);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of The Stalwart Protector", GOSSIP_SENDER_MAIN, 128);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Torment", GOSSIP_SENDER_MAIN, 129);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Triumph", GOSSIP_SENDER_MAIN, 130);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Eclipsed Moon", GOSSIP_SENDER_MAIN, 131);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Flame's Soul", GOSSIP_SENDER_MAIN, 132);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Fleeing Shadow", GOSSIP_SENDER_MAIN, 133);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of the Frosty Soul", GOSSIP_SENDER_MAIN, 134);
+                    player->ADD_GOSSIP_ITEM(1, "Arcanum of Toxic Warding", GOSSIP_SENDER_MAIN, 135);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100005, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 5: // Enchant Shoulders
+                    if (player->HasSkill(SKILL_INSCRIPTION) && player->GetSkillValue(SKILL_INSCRIPTION) == 450)
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Axe", GOSSIP_SENDER_MAIN, 136);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Crag", GOSSIP_SENDER_MAIN, 137);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 138);
+                        player->ADD_GOSSIP_ITEM(1, "Master's Inscription of the Storm", GOSSIP_SENDER_MAIN, 139);
+                    }
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Axe", GOSSIP_SENDER_MAIN, 140);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Crag", GOSSIP_SENDER_MAIN, 141);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Pinnacle", GOSSIP_SENDER_MAIN, 142);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Gladiator", GOSSIP_SENDER_MAIN, 143);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Inscription of the Storm", GOSSIP_SENDER_MAIN, 144);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Dominance", GOSSIP_SENDER_MAIN, 145);
+                    player->ADD_GOSSIP_ITEM(1, "Inscription of Triumph", GOSSIP_SENDER_MAIN, 146);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100006, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 6: // Enchant Cloak
+                    player->ADD_GOSSIP_ITEM(1, "Springy Arachnoweave", GOSSIP_SENDER_MAIN, 147);
+                    player->ADD_GOSSIP_ITEM(1, "Shadow Armor", GOSSIP_SENDER_MAIN, 148);
+                    player->ADD_GOSSIP_ITEM(1, "Darkglow Embroidery", GOSSIP_SENDER_MAIN, 149);
+                    player->ADD_GOSSIP_ITEM(1, "Lightweave Embroidery", GOSSIP_SENDER_MAIN, 150);
+                    player->ADD_GOSSIP_ITEM(1, "Swordguard Embroidery", GOSSIP_SENDER_MAIN, 151);
+                    player->ADD_GOSSIP_ITEM(1, "Wisdom", GOSSIP_SENDER_MAIN, 152);
+                    player->ADD_GOSSIP_ITEM(1, "Titanweave", GOSSIP_SENDER_MAIN, 153);
+                    player->ADD_GOSSIP_ITEM(1, "Spell Piercing", GOSSIP_SENDER_MAIN, 154);
+                    player->ADD_GOSSIP_ITEM(1, "Mighty Armor", GOSSIP_SENDER_MAIN, 155);
+                    player->ADD_GOSSIP_ITEM(1, "Major Agility", GOSSIP_SENDER_MAIN, 156);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Speed", GOSSIP_SENDER_MAIN, 157);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100007, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 7: //Enchant chest
+                    player->ADD_GOSSIP_ITEM(1, "Powerful Stats", GOSSIP_SENDER_MAIN, 158);
+                    player->ADD_GOSSIP_ITEM(1, "Super Health", GOSSIP_SENDER_MAIN, 159);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Mana Restoration", GOSSIP_SENDER_MAIN, 160);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Resilience", GOSSIP_SENDER_MAIN, 161);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Defense", GOSSIP_SENDER_MAIN, 162);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100008, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 8: //Enchant Bracers
+                    player->ADD_GOSSIP_ITEM(1, "Major Stamina", GOSSIP_SENDER_MAIN, 163);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Spell Power", GOSSIP_SENDER_MAIN, 164);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 165);
+                    player->ADD_GOSSIP_ITEM(1, "Major Spirit", GOSSIP_SENDER_MAIN, 166);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 167);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Stats", GOSSIP_SENDER_MAIN, 168);
+                    player->ADD_GOSSIP_ITEM(1, "Exceptional Intellect", GOSSIP_SENDER_MAIN, 169);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Arcane Resist", GOSSIP_SENDER_MAIN, 170);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Fire Resist", GOSSIP_SENDER_MAIN, 171);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Frost Resist", GOSSIP_SENDER_MAIN, 172);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Nature Resist", GOSSIP_SENDER_MAIN, 173);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Shadow Resist", GOSSIP_SENDER_MAIN, 174);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Attack power", GOSSIP_SENDER_MAIN, 175);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Stamina", GOSSIP_SENDER_MAIN, 176);
+                    player->ADD_GOSSIP_ITEM(1, "Fur Lining - Spellpower", GOSSIP_SENDER_MAIN, 177);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100009, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 9: //Enchant Gloves
+                    player->ADD_GOSSIP_ITEM(1, "Greater Blasting", GOSSIP_SENDER_MAIN, 178);
+                    player->ADD_GOSSIP_ITEM(1, "Armsman", GOSSIP_SENDER_MAIN, 179);
+                    player->ADD_GOSSIP_ITEM(1, "Crusher", GOSSIP_SENDER_MAIN, 180);
+                    player->ADD_GOSSIP_ITEM(1, "Agility", GOSSIP_SENDER_MAIN, 181);
+                    player->ADD_GOSSIP_ITEM(1, "Precision", GOSSIP_SENDER_MAIN, 182);
+                    player->ADD_GOSSIP_ITEM(1, "Expertise", GOSSIP_SENDER_MAIN, 183);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100010, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 10: //Enchant legs
+                    player->ADD_GOSSIP_ITEM(1, "Earthen Leg Armor", GOSSIP_SENDER_MAIN, 184);
+                    player->ADD_GOSSIP_ITEM(1, "Frosthide Leg Armor", GOSSIP_SENDER_MAIN, 185);
+                    player->ADD_GOSSIP_ITEM(1, "Icescale Leg Armor", GOSSIP_SENDER_MAIN, 186);
+                    player->ADD_GOSSIP_ITEM(1, "Brilliant Spellthread", GOSSIP_SENDER_MAIN, 187);
+                    player->ADD_GOSSIP_ITEM(1, "Sapphire Spellthread", GOSSIP_SENDER_MAIN, 188);
+                    player->ADD_GOSSIP_ITEM(1, "Dragonscale Leg Armor", GOSSIP_SENDER_MAIN, 189);
+                    player->ADD_GOSSIP_ITEM(1, "Wyrmscale Leg Armor", GOSSIP_SENDER_MAIN, 190);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100011, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 11: //Enchant feet
+                    player->ADD_GOSSIP_ITEM(1, "Greater Assult", GOSSIP_SENDER_MAIN, 191);
+                    player->ADD_GOSSIP_ITEM(1, "Tuskars Vitliaty", GOSSIP_SENDER_MAIN, 192);
+                    player->ADD_GOSSIP_ITEM(1, "Superior Agility", GOSSIP_SENDER_MAIN, 193);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spirit", GOSSIP_SENDER_MAIN, 194);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Vitality", GOSSIP_SENDER_MAIN, 195);
+                    player->ADD_GOSSIP_ITEM(1, "Icewalker", GOSSIP_SENDER_MAIN, 196);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Fortitude", GOSSIP_SENDER_MAIN, 197);
+                    player->ADD_GOSSIP_ITEM(1, "Nitro Boots", GOSSIP_SENDER_MAIN, 198);
+                    player->ADD_GOSSIP_ITEM(1, "Hand-Mounted Pyro Rocket", GOSSIP_SENDER_MAIN, 199);
+                    player->ADD_GOSSIP_ITEM(1, "Hyperspeed Accedlerators", GOSSIP_SENDER_MAIN, 200);
+                    player->ADD_GOSSIP_ITEM(1, "Reticulated Armor Webbing", GOSSIP_SENDER_MAIN, 201);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100012, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 12: //Enchant rings
+                    player->ADD_GOSSIP_ITEM(1, "Assult", GOSSIP_SENDER_MAIN, 202);
+                    player->ADD_GOSSIP_ITEM(1, "Greater Spell Power", GOSSIP_SENDER_MAIN, 203);
+                    player->ADD_GOSSIP_ITEM(1, "Stamina", GOSSIP_SENDER_MAIN, 204);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100013, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 13: //Enchant Off-Hand weapons
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendNotification("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "Blade Ward", GOSSIP_SENDER_MAIN, 205);
+                            player->ADD_GOSSIP_ITEM(1, "Blood Draining", GOSSIP_SENDER_MAIN, 219);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Agility", GOSSIP_SENDER_MAIN, 206);
+                            player->ADD_GOSSIP_ITEM(1, "Exceptional Spirit", GOSSIP_SENDER_MAIN, 207);
+                            player->ADD_GOSSIP_ITEM(1, "Berserking", GOSSIP_SENDER_MAIN, 208);
+                            player->ADD_GOSSIP_ITEM(1, "Accuracy", GOSSIP_SENDER_MAIN, 209);
+                            player->ADD_GOSSIP_ITEM(1, "Black Magic", GOSSIP_SENDER_MAIN, 210);
+                            player->ADD_GOSSIP_ITEM(1, "Battlemaster", GOSSIP_SENDER_MAIN, 211);
+                            player->ADD_GOSSIP_ITEM(1, "Icebreaker", GOSSIP_SENDER_MAIN, 212);
+                            player->ADD_GOSSIP_ITEM(1, "Lifeward", GOSSIP_SENDER_MAIN, 213);
+                            player->ADD_GOSSIP_ITEM(1, "Titanguard", GOSSIP_SENDER_MAIN, 214);
+                            player->ADD_GOSSIP_ITEM(1, "Superior Potency", GOSSIP_SENDER_MAIN, 215);
+                            player->ADD_GOSSIP_ITEM(1, "Mighty Spellpower", GOSSIP_SENDER_MAIN, 216);
+                            player->ADD_GOSSIP_ITEM(1, "Mongoose", GOSSIP_SENDER_MAIN, 217);
+                            player->ADD_GOSSIP_ITEM(1, "Executioner", GOSSIP_SENDER_MAIN, 218);
+                            player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                            player->PlayerTalkClass->SendGossipMenu(100002, creature->GetGUID());
+                            return true;
+                        }
+                        else
+                        {
+                            player->GetSession()->SendNotification("Your Off-Hand is not a weapon.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 14: //Remove enchant menu
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Main-hand", GOSSIP_SENDER_MAIN, 400);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Off-hand", GOSSIP_SENDER_MAIN, 401);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Head", GOSSIP_SENDER_MAIN, 402);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Shoulders", GOSSIP_SENDER_MAIN, 403);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Cloak", GOSSIP_SENDER_MAIN, 404);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Chest", GOSSIP_SENDER_MAIN, 405);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Bracers", GOSSIP_SENDER_MAIN, 406);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Gloves", GOSSIP_SENDER_MAIN, 407);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Legs", GOSSIP_SENDER_MAIN, 408);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Feet", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "Remove enchant on Rings", GOSSIP_SENDER_MAIN, 409);
+                    player->ADD_GOSSIP_ITEM(1, "<-Back", GOSSIP_SENDER_MAIN, 300);
+                    player->PlayerTalkClass->SendGossipMenu(100014, creature->GetGUID());
+                    return true;
+                    break;
+
+                case 100:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_AGILITY_1H);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 101:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 102:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLADE_WARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 103:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 104:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BERSERKING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 105:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ACCURACY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 106:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BLACK_MAGIC);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 107:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_BATTLEMASTER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 108:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_ICEBREAKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 109:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_LIFEWARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 110:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_TITANGUARD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 111:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_POTENCY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 112:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 113:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MONGOOSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 114:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_WEP_EXECUTIONER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 115:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_GREATER_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 116:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_AGILITY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 117:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND);
+
+                        if (!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a 2H weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_2HWEAPON)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND), ENCHANT_2WEP_MASSACRE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a Two-Handed weapon equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 118:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_DEFENSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 119:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_INTELLECT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 120:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_RESILIENCE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 121:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TITANIUM_PLATING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 122:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_STAMINA);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 123:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_SHIELD)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_SHIELD_TOUGHSHIELD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("You don't have a shield equipped.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 124:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BLISSFUL_MENDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 125:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_BURNING_MYSTERIES);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 126:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 127:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_SAVAGE_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 128:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_STALWART_PROTECTOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 129:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TORMENT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 130:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 131:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_ECLIPSED_MOON);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 132:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLAME_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 133:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FLEEING_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 134:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_FROSTY_SOUL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 135:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD), ENCHANT_HEAD_TOXIC_WARDING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 136:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 137:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 138:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 139:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_MASTERS_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 140:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_AXE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 141:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_CRAG);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 142:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_GLADIATOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 143:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_PINNACLE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 144:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_GREATER_STORM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 145:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_DOMINANCE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 146:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS), ENCHANT_SHOULDER_TRIUMPH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 147:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPRINGY_ARACHNOWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 148:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SHADOW_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 149:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_DARKGLOW_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 150:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_LIGHTWEAVE_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 151:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SWORDGUARD_EMBROIDERY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 152:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_WISDOM);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 153:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_TITANWEAVE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 154:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_SPELL_PIERCING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 155:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MIGHTY_ARMOR);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 156:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_MAJOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 157:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK), ENCHANT_CLOAK_GREATER_SPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 158:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_POWERFUL_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 159:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_SUPER_HEALTH);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 160:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_MAINA_REST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 161:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_EXCEPTIONAL_RESIL);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 162:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST), ENCHANT_CHEST_GREATER_DEFENSE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 163:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 164:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_SUPERIOR_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 165:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_ASSUALT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 166:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_MAJOR_SPIRT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 167:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 168:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_GREATER_STATS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 169:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_INTELLECT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 170:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ARCANE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 171:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FIRE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 172:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_FROST);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 173:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_NATURE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 174:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SHADOW);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 175:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_ATTACK);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 176:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 177:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS), ENCHANT_BRACERS_FURL_SPELLPOWER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 178:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_GREATER_BLASTING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 179:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_ARMSMAN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 180:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_CRUSHER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 181:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 182:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_PRECISION);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 183:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS), ENCHANT_GLOVES_EXPERTISE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 184:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_EARTHEN);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 185:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_FROSTHIDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 186:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_ICESCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 187:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_BRILLIANT_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 188:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_SAPPHIRE_SPELLTHREAD);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 189:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_DRAGONSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 190:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS), ENCHANT_LEG_WYRMSCALE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 191:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 192:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_TUSKARS_VITLIATY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 193:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_SUPERIOR_AGILITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 194:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_SPIRIT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 195:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_VITALITY);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 196:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ICEWALKER);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 197:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_GREATER_FORTITUDE);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 198:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_NITRO_BOOTS);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 199:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_PYRO_ROCKET);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 200:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_HYPERSPEED);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 201:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET), ENCHANT_BOOTS_ARMOR_WEBBING);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 202:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_ASSULT);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_ASSULT);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 203:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_GREATER_SP);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_GREATER_SP);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 204:
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1), ENCHANT_RING_STAMINA);
+                    Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2), ENCHANT_RING_STAMINA);
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 205:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLADE_WARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 206:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_AGILITY_1H);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 207:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_SPIRIT);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 208:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BERSERKING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 209:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ACCURACY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 210:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLACK_MAGIC);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 211:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BATTLEMASTER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 212:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_ICEBREAKER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 213:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_LIFEWARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 214:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_TITANGUARD);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 215:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_POTENCY);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 216:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_MIGHTY_SPELL_POWER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 217:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_2WEP_MONGOOSE);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 218:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_EXECUTIONER);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 219:
+                    {
+                        item = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND);
+
+                        if(!item)
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                            return false;
+                        }
+
+                        if (item->GetTemplate()->InventoryType == INVTYPE_WEAPONOFFHAND)
+                        {
+                            Enchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND), ENCHANT_WEP_BLOOD_DRAINING);
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                        else
+                        {
+                            player->GetSession()->SendAreaTriggerMessage("This enchant needs a one-hand weapon equipped in the off-hand.");
+                            player->PlayerTalkClass->SendCloseGossip();
+                        }
+                    }
+                    break;
+
+                case 300: //<-Back menu
+                    {
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Weapon-]", GOSSIP_SENDER_MAIN, 1);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Off-Hand Weapon-]", GOSSIP_SENDER_MAIN, 13);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant 2H Weapon-]", GOSSIP_SENDER_MAIN, 2);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shield-]", GOSSIP_SENDER_MAIN, 3);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Head-]", GOSSIP_SENDER_MAIN, 4);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Shoulders-]", GOSSIP_SENDER_MAIN, 5);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Cloak-]", GOSSIP_SENDER_MAIN, 6);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Chest-]", GOSSIP_SENDER_MAIN, 7);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Bracers-]", GOSSIP_SENDER_MAIN, 8);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Gloves-]", GOSSIP_SENDER_MAIN, 9);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Legs-]", GOSSIP_SENDER_MAIN, 10);
+                        player->ADD_GOSSIP_ITEM(1, "[-Enchant Feet-]", GOSSIP_SENDER_MAIN, 11);
+
+                        if (player->HasSkill(SKILL_ENCHANTING) && player->GetSkillValue(SKILL_ENCHANTING) == 450)
+                        {
+                            player->ADD_GOSSIP_ITEM(1, "[-Enchant Rings-]", GOSSIP_SENDER_MAIN, 12);
+                        }
+                        player->ADD_GOSSIP_ITEM(1, "[-I wish to remove my enchant-]", GOSSIP_SENDER_MAIN, 14);
+
+                        player->PlayerTalkClass->SendGossipMenu(100001, creature->GetGUID());
+                        return true;
+                    }
+                        break;
+
+                case 400: //Remove enchant for mainhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 401: //Remove enchant for offhand
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 402: //Remove enchant for head
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HEAD));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 403: //Remove enchant for shoulders
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_SHOULDERS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 404: //remove enchant for cloak
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_BACK));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 405: //remove enchant for chest
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_CHEST));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 406: //remove enchant for bracers
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_WRISTS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 407: //remove enchant for gloves
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_HANDS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 408: //remove enchant for legs
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_LEGS));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 409: //remove enchant for feet
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FEET));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                case 410:
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER1));
+                    RemoveEnchant(player, player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_FINGER2));
+                    player->PlayerTalkClass->SendCloseGossip();
+                    break;
+
+                }
+            return true;
+        }
+    };
+
+
+void AddSC_npc_enchantment()
+{
+  new npc_enchantment();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/event.cpp b/src/server/scripts/Custom/event.cpp
new file mode 100644
index 0000000..52941fb
--- /dev/null
+++ b/src/server/scripts/Custom/event.cpp
@@ -0,0 +1,646 @@
+#include "Pet.h"
+#include <mutex>
+
+#define LILDEBUG
+
+void LilDebug(std::string str, uint32 line)
+{
+#ifdef LILDEBUG
+    std::cout << "Line: " << line << " " << str << std::endl;
+#endif
+}
+
+#define LILLOG(x) LilDebug(x, __LINE__)
+
+namespace Lil
+{
+    enum
+    {
+        LEVENT_NONE,
+        LEVENT_LEVELUP,
+        LEVENT_KILLCREATURE,
+        LEVENT_CREATUREKILL,
+        LEVENT_DUELSTART,
+        LEVENT_DUELEND,
+        LEVENT_DUELWIN,
+        LEVENT_DUELLOSS,
+        LEVENT_ONSPELLCAST,
+        LEVENT_ONLOGIN,
+        LEVENT_ONLOGOUT,
+        LEVENT_NEWZONE,
+        LEVENT_FIRSTLOGIN,
+        LEVENT_MAX,
+    };
+
+    enum
+    {
+        LACTION_NONE,
+        LACTION_MODMONEY,
+        LACTION_GIVEITEM,
+        LACTION_CASTSPELL,
+        LACTION_LEARNSPELL,
+        LACTION_TELEPORT,
+        LACTION_TEMPSUMMON,
+        LACTION_SETHEALTH,
+        LACTION_SETPOWER,
+        LACTION_ADDTITLE,
+        LACTION_GIVEXP,
+        LACTION_ADDITEMSET,
+        LACTION_MAX,
+    };
+
+    std::string MoneyString(uint32 incopper)
+    {
+        uint32 gold = incopper / 10000;
+        incopper -= gold * 10000;
+        uint32 silver = incopper / 100;
+        incopper -= silver * 100;
+        uint32 copper = incopper;
+
+        std::ostringstream ss;
+
+        if (gold)
+            ss << gold << " Gold";
+        if (gold && silver)
+            ss << ", ";
+        if (silver)
+            ss << silver << " Silver";
+        if (silver && copper)
+            ss << ", ";
+        if (copper)
+            ss << copper << " Copper";
+
+        if (!gold && !silver && !copper)
+            ss << "NAH!";
+
+        // #Lovestreams!
+
+        return ss.str();
+    }
+
+    std::string GetItemLink(uint32 itemid)
+    {
+        auto item = sObjectMgr->GetItemTemplate(itemid);
+        if (!itemid)
+            return "ITEM DOESN'T EXIST";
+
+        std::ostringstream ss;
+        std::string color = "cffffffff";
+
+        switch (item->Quality)
+        {
+        case 0:
+            color = "cff9d9d9d";
+            break;
+        case 1:
+            color = "cffffffff";
+            break;
+        case 2:
+            color = "cff1eff00";
+            break;
+        case 3:
+            color = "cff0070dd";
+            break;
+        case 4:
+            color = "cffa335ee";
+            break;
+        case 5:
+            color = "cffff8000";
+            break;
+        case 6:
+        case 7:
+            color = "cffe6cc80";
+            break;
+        default:
+            break;
+        }
+
+        ss << "|" << color << "| Hitem:" << item->ItemId << " : 0 : 0 : 0 : 0 : 0 : 0 : 0 : 0 | h[" << item->Name1 << "] | h | r";
+
+        return ss.str();
+
+        //| cffffffff | Hitem:%d : 0 : 0 : 0 : 0 : 0 : 0 : 0 : 0 | h[%s] | h | r
+    }
+
+    std::string GetSpellLink(uint32 spellid)
+    {
+        auto spell = sSpellStore.LookupEntry(spellid);
+        if (!spell)
+            return "SPELL NOT FOUND";
+
+        std::ostringstream ss;
+
+        ss << spell->Id << " - |cffffffff|Hspell:" << spell->Id << "|h[" << spell->SpellName << "]|h|r";
+
+        return ss.str();
+    }
+}
+
+
+class LilCondition
+{
+public:
+    bool ConditionMet(Player* pPlayer, uint32 etype, uint32 evalue)
+    {
+        if (CValue != evalue && CValue != 0)
+        {
+            LILLOG("Condition Failed! EventCondition value invalid");
+            return false;
+        }
+
+        if (pPlayer->getRace() != PRace && PRace != 0)
+        {
+            LILLOG("Condition Failed! Wrong race");
+            return false;
+        }
+
+        if (pPlayer->getClass() != PClass && PClass != 0)
+        {
+            LILLOG("Condition Failed! Wrong class");
+            return false;
+        }
+
+        if (TCConditionType && TCConditionEntry)
+        {
+            auto list = sConditionMgr->GetConditionsForNotGroupedEntry(ConditionSourceType(TCConditionType), TCConditionEntry);
+
+            if (!sConditionMgr->IsObjectMeetToConditions(pPlayer, list))
+            {
+                LILLOG("Condition Failed! TC Condition not met");
+                return false;
+            }
+        }
+
+        if (TCGameEventEntry)
+        {
+            auto activeEvents = sGameEventMgr->GetActiveEventList();
+
+            if (activeEvents.find(TCGameEventEntry) == activeEvents.end())
+            {
+                LILLOG("Condition Failed! Game event not running");
+                return false;
+            }
+        }
+
+        LILLOG("Condition OK!");
+
+        return true;
+    }
+
+    uint32 id;
+    uint32 TCConditionType;
+    uint32 TCConditionEntry;
+    uint16 TCGameEventEntry;
+    uint8 PRace;
+    uint8 PClass;
+    uint32 CValue;
+};
+
+class LilEvent
+{
+public:
+    uint32 id;
+    uint32 type;
+    uint32 condition;
+    uint32 action;
+};
+
+class LilAction
+{
+public:
+    void PerformAction(Player* pPlayer)
+    {
+        bool codemsg = message.find("CODEMSG") != std::string::npos;
+
+        ChatHandler handler = ChatHandler(pPlayer->GetSession());
+
+        switch (type)
+        {
+        case Lil::LACTION_MODMONEY:
+        {
+                                      pPlayer->ModifyMoney(int32(avalue[0]));
+                                      if (codemsg && avalue[0] >= 1)
+                                          handler.PSendSysMessage("You received %s", Lil::MoneyString(uint32(avalue[0])).c_str());
+        }
+            break;
+
+        case Lil::LACTION_GIVEITEM:
+        {
+                                      if (avalue[0] < 1 || avalue[1] < 1)
+                                          return;
+
+                                      if (auto item = sObjectMgr->GetItemTemplate(uint32(avalue[0])))
+                                      {
+                                          pPlayer->StoreNewItemInBestSlots(item->ItemId, uint32(avalue[1]));
+
+                                          if (codemsg)
+                                              handler.PSendSysMessage("You were rewarded with %s", Lil::GetItemLink(item->ItemId).c_str());
+                                      }
+        }
+            break;
+
+        case Lil::LACTION_CASTSPELL:
+        {
+                                       if (avalue[0] < 1)
+                                           return;
+
+                                       auto spell = sSpellStore.LookupEntry(uint32(avalue[0]));
+                                       if (!spell)
+                                           return;
+
+                                       pPlayer->CastSpell(pPlayer, spell->Id, true);
+                                       if (codemsg)
+                                           handler.PSendSysMessage("%s was caster on you!", Lil::GetSpellLink(spell->Id).c_str());
+        }
+            break;
+
+        case Lil::LACTION_LEARNSPELL:
+        {
+                                        if (avalue[0] < 1)
+                                            return;
+
+                                        pPlayer->LearnSpell(uint32(avalue[0]), false);
+        }
+            break;
+
+        case Lil::LACTION_TELEPORT:
+        {
+                                      if (avalue[0] < 0)
+                                          return;
+
+                                      pPlayer->TeleportTo(uint32(avalue[0]), avalue[1], avalue[2], avalue[3], Position::NormalizeOrientation(avalue[4]));
+
+                                      if (codemsg)
+                                      {
+                                          auto area = sAreaStore.LookupEntry(pPlayer->GetAreaId());
+                                          handler.PSendSysMessage("You have been teleported to %s", area->area_name);
+                                      }
+        }
+            break;
+
+        case Lil::LACTION_TEMPSUMMON:
+        {
+                                        if (avalue[0] < 0 || avalue[1] < 0 || avalue[2] < 0)
+                                            return;
+
+                                        auto creature = sObjectMgr->GetCreatureTemplate(uint32(avalue[0]));
+                                        if (!creature)
+                                            return;
+
+                                        Position pos;
+                                        pos.m_positionX = pPlayer->GetPositionX();
+                                        pos.m_positionY = pPlayer->GetPositionY();
+                                        pos.m_positionZ = pPlayer->GetPositionZ();
+                                        pos.m_orientation = pPlayer->GetOrientation();
+
+                                        pPlayer->SummonCreature(creature->Entry, pos, TempSummonType(uint32(avalue[1])), uint32(avalue[2]));
+
+                                        if (codemsg)
+                                            handler.PSendSysMessage("You have summoned %s!", creature->Name.c_str());
+        }
+        case Lil::LACTION_SETHEALTH:
+        {
+                                       pPlayer->SetHealth(float(pPlayer->GetHealth()) * (avalue[0] / 100.f));
+                                       if (Pet* pPet = pPlayer->GetPet())
+                                       if (avalue[1] > 0)
+                                           pPet->SetHealth(float(pPet->GetHealth()) * (avalue[0] / 100.f));
+
+                                       if (codemsg)
+                                           handler.PSendSysMessage("Your health was set to %u", pPlayer->GetHealth());
+
+        }
+            break;
+
+        case Lil::LACTION_SETPOWER:
+        {
+                                      pPlayer->SetPower(pPlayer->getPowerType(), pPlayer->GetPower(pPlayer->getPowerType()) * (avalue[0] / 100.f));
+                                      if (Pet* pPet = pPlayer->GetPet())
+                                      if (avalue[1] > 0)
+                                          pPet->SetPower(pPet->getPowerType(), pPet->GetPower(pPet->getPowerType()) * (avalue[0] / 100.f));
+
+                                      if (codemsg)
+                                      {
+                                          std::string powername = "power";
+
+                                          switch (pPlayer->getPowerType())
+                                          {
+                                          case POWER_MANA:
+                                              powername = "mana";
+                                              break;
+                                          case POWER_RAGE:
+                                              powername = "rage";
+                                              break;
+                                          case POWER_ENERGY:
+                                              powername = "energy";
+                                              break;
+                                          case POWER_RUNIC_POWER:
+                                              powername = "runic power";
+                                              break;
+                                          default:
+                                              break;
+                                          }
+
+                                          handler.PSendSysMessage("Your %s has been set to %u", powername.c_str(), pPlayer->GetPower(pPlayer->getPowerType()));
+                                      }
+        }
+            break;
+
+        case Lil::LACTION_ADDTITLE:
+        {
+                                      CharTitlesEntry const* title = sCharTitlesStore.LookupEntry(uint32(avalue[0]));
+                                      if (!title)
+                                          return;
+
+                                      pPlayer->SetTitle(title);
+
+                                      if (codemsg)
+                                          handler.PSendSysMessage("You were awarded with |Htitle:id|h[name]|h!", title->ID, (pPlayer->getGender() == GENDER_MALE ? title->nameMale : title->nameFemale));
+        }
+            break;
+
+        case Lil::LACTION_GIVEXP:
+        {
+                                    if (avalue[0] < 1)
+                                        return;
+
+                                    pPlayer->GiveXP(uint32(avalue[0]), NULL);
+
+                                    if (codemsg)
+                                        handler.PSendSysMessage("%u experience was given to you!", uint32(avalue[0]));
+        }
+            break;
+
+        case Lil::LACTION_ADDITEMSET:
+        {
+                                        auto set = sItemSetStore.LookupEntry(uint32(avalue[0]));
+                                        if (!set)
+                                            return;
+
+                                        for (auto i = 0; i < 10; ++i)
+                                        if (auto item = sObjectMgr->GetItemTemplate(set->itemId[i]))
+                                            pPlayer->StoreNewItemInBestSlots(item->ItemId, 1);
+
+                                        if (codemsg)
+                                            handler.PSendSysMessage("You have been rewarded with itemset |Hitemset:%u|h[%s]|h", uint32(avalue[0]), set->name);
+        }
+            break;
+
+        default:
+            break;
+        }
+
+        if (!message.empty() && !codemsg)
+            handler.PSendSysMessage("%s", message.c_str());
+    }
+
+    uint32 id;
+    uint32 type;
+    float avalue[5];
+    std::string message;
+};
+
+std::mutex LilMTX;
+
+class LilEvents
+{
+public:
+    static LilEvents* Instance()
+    {
+        static LilEvents instance;
+        return &instance;
+    }
+
+    void HandleEvent(Player* pPlayer, uint32 etype, uint32 evalue)
+    {
+        std::ostringstream ss;
+        ss << "HandleEvent: etype: " << etype << " evalue: " << evalue;
+
+        LILLOG(ss.str().c_str());
+
+        for (auto& i : m_Events) // Loop all events
+        if (i.type == etype) // Find event with this type
+        if (m_Conditions.find(i.condition)->second.ConditionMet(pPlayer, etype, evalue)) // Check if we fullful all conditions
+            m_Actions.find(i.action)->second.PerformAction(pPlayer); // Perform the action
+    }
+
+    void ForceAction(Player* pPlayer, uint32 id)
+    {
+        if (m_Actions.find(id) != m_Actions.end())
+            m_Actions.find(id)->second.PerformAction(pPlayer);
+        else
+            ChatHandler(pPlayer->GetSession()).PSendSysMessage("Event with specified id doesn't exist.");
+    }
+
+    void LoadEvents()
+    {
+        m_Events.clear();
+        m_Actions.clear();
+        m_Conditions.clear();
+
+        auto result1 = WorldDatabase.PQuery("SELECT * FROM lil_events");
+        if (!result1)
+            return;
+
+        do
+        {
+            auto fields = result1->Fetch();
+            LilEvent curevent;
+            curevent.id         = fields[0].GetUInt32();
+            curevent.type       = fields[1].GetUInt32();
+            curevent.condition  = fields[2].GetUInt32();
+            curevent.action     = fields[3].GetUInt32();
+
+            m_Events.push_back(curevent);
+        } while (result1->NextRow());
+
+        auto result2 = WorldDatabase.PQuery("SELECT * FROM lil_actions");
+        if (!result2)
+            return;
+
+        do
+        {
+            auto fields = result2->Fetch();
+            LilAction curaction;
+            curaction.id        = fields[0].GetUInt32();
+            curaction.type      = fields[1].GetUInt32();
+            curaction.avalue[0] = fields[2].GetFloat();
+            curaction.avalue[1] = fields[3].GetFloat();
+            curaction.avalue[2] = fields[4].GetFloat();
+            curaction.avalue[3] = fields[5].GetFloat();
+            curaction.avalue[4] = fields[6].GetFloat();
+            curaction.message   = fields[7].GetString();
+
+            m_Actions.insert(std::make_pair(curaction.id, curaction));
+        } while (result2->NextRow());
+
+        auto result3 = WorldDatabase.PQuery("SELECT * FROM lil_conditions");
+        if (!result3)
+            return;
+
+        do
+        {
+            auto fields = result3->Fetch();
+            LilCondition curcondition;
+            curcondition.id                 = fields[0].GetUInt32();
+            curcondition.TCConditionType    = fields[1].GetUInt32();
+            curcondition.TCConditionEntry   = fields[2].GetUInt32();
+            curcondition.TCGameEventEntry   = fields[3].GetUInt32();
+            curcondition.PRace              = fields[4].GetUInt8();
+            curcondition.PClass             = fields[5].GetUInt8();
+            curcondition.CValue             = fields[6].GetUInt32();
+
+            m_Conditions.insert(std::make_pair(curcondition.id, curcondition));
+        } while (result3->NextRow());
+
+        bool removedentry = true;
+
+        while (removedentry) // This will be useful when i add conditions stacking, loop useless for now.
+        {
+            removedentry = false;
+
+            for (auto itr = m_Events.begin(); itr != m_Events.end();)
+            {
+                if (m_Actions.find(itr->action) == m_Actions.end() ||
+                    m_Conditions.find(itr->condition) == m_Conditions.end())
+                {
+                    removedentry = true;
+                    itr = m_Events.erase(itr);
+                }
+                else
+                    ++itr;
+            }
+        }
+
+        TC_LOG_INFO("server.loading", "Loaded %u Lilevent events", m_Events.size());
+        TC_LOG_INFO("server.loading", "Loaded %u Lilevent actions", m_Actions.size());
+        TC_LOG_INFO("server.loading", "Loaded %u Lilevent conditions", m_Conditions.size());
+    }
+
+private:
+    std::vector<LilEvent> m_Events;
+    std::unordered_map<uint32, LilAction> m_Actions;
+    std::unordered_map<uint32, LilCondition> m_Conditions;
+};
+
+#define sLilEvents LilEvents::Instance()
+
+
+class PlayerEvents : public PlayerScript
+{
+public:
+    PlayerEvents() : PlayerScript("PlayerEvents") { }
+
+    void OnLevelChanged(Player* pPlayer, uint8)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_LEVELUP, pPlayer->getLevel());
+    }
+
+    void OnCreatureKill(Player* pPlayer, Creature* pCreature)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_KILLCREATURE, pCreature->GetEntry());
+    }
+
+    void OnPlayerKilledByCreature(Creature* pCreature, Player* pPlayer)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_CREATUREKILL, pCreature->GetEntry());
+    }
+
+    void OnDuelStart(Player* pPlayer1, Player* pPlayer2)
+    {
+        sLilEvents->HandleEvent(pPlayer1, Lil::LEVENT_DUELSTART, 0);
+        sLilEvents->HandleEvent(pPlayer2, Lil::LEVENT_DUELSTART, 0);
+    }
+
+    void OnDuelEnd(Player* pWinner, Player* pLoser, DuelCompleteType type)
+    {
+        sLilEvents->HandleEvent(pWinner, Lil::LEVENT_DUELEND, type);
+        sLilEvents->HandleEvent(pLoser, Lil::LEVENT_DUELEND, type);
+
+        sLilEvents->HandleEvent(pWinner, Lil::LEVENT_DUELWIN, type);
+        sLilEvents->HandleEvent(pLoser, Lil::LEVENT_DUELLOSS, type);
+    }
+
+    void OnSpellCast(Player* pPlayer, Spell* pSpell, bool)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_ONSPELLCAST, pSpell->GetSpellInfo()->Id);
+    }
+
+    void OnLogin(Player* pPlayer, bool firstlogin)
+    {
+        if (firstlogin)
+            sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_FIRSTLOGIN, 0);
+        else
+            sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_ONLOGIN, 0);
+    }
+
+    void OnLogout(Player* pPlayer)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_ONLOGOUT, 0);
+    }
+
+    void OnUpdateZone(Player* pPlayer, uint32 newzone, uint32)
+    {
+        sLilEvents->HandleEvent(pPlayer, Lil::LEVENT_NEWZONE, newzone);
+    }
+};
+
+class EventLoader : public WorldScript
+{
+public:
+    EventLoader() : WorldScript("EventLoader") { }
+
+    void OnStartup()
+    {
+        sLilEvents->LoadEvents();
+    }
+};
+
+class EventCommands : public CommandScript
+{
+public:
+    EventCommands() : CommandScript("EventCommands") { }
+
+    ChatCommand* GetCommands() const override
+    {
+        static ChatCommand eventCommandTable[] =
+        {
+            { "reload", rbac::RBAC_PERM_COMMAND_RELOAD_GAME_TELE, true,  &HandleReloadLevelEvents, "", NULL },
+            { "test",   rbac::RBAC_PERM_COMMAND_RELOAD_GAME_TELE, false, &HandleTestAction       , "", NULL },
+            { NULL, 0, false, NULL, "", NULL }
+        };
+
+        static ChatCommand commandTable[] =
+        {
+            { "onevent", rbac::RBAC_PERM_COMMAND_RELOAD_GAME_TELE, false, NULL, "", eventCommandTable },
+            { NULL, 0, false, NULL, "", NULL }
+        };
+        return commandTable;
+    }
+
+    static bool HandleReloadLevelEvents(ChatHandler* handler, const char*)
+    {
+        sLilEvents->LoadEvents();
+        handler->PSendSysMessage("onlevelup reloaded");
+
+        return true;
+    }
+
+    static bool HandleTestAction(ChatHandler* handler, const char* args)
+    {
+        uint32 ID = atoi(args);
+        if (!ID)
+            return false;
+
+        sLilEvents->ForceAction(handler->GetSession()->GetPlayer(), ID);
+
+        return true;
+    }
+};
+
+
+void AddSC_LevelEvents()
+{
+    new PlayerEvents;
+    new EventLoader;
+    new EventCommands;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/guildmaster.cpp b/src/server/scripts/Custom/guildmaster.cpp
new file mode 100644
index 0000000..4a8b012
--- /dev/null
+++ b/src/server/scripts/Custom/guildmaster.cpp
@@ -0,0 +1,313 @@
+#include "ScriptPCH.h"
+#include "Config.h"
+
+//extern DatabaseMysql SD2Database;
+
+//extern WorldDatabaseWorkerPool WorldDatabase;
+
+#define MSG_GOSSIP_TELE          "Teleport to GuildHouse"
+#define MSG_GOSSIP_BUY           "Buy GuildHouse"
+#define MSG_GOSSIP_SELL          "Sell GuildHouse"
+#define MSG_GOSSIP_NEXTPAGE      "Next -->"
+#define MSG_INCOMBAT             "You are in combat and cannot be teleported to your GuildHouse."
+#define MSG_NOGUILDHOUSE         "Your guild currently does not own a GuildHouse."
+#define MSG_NOFREEGH             "Unfortunately, all GuildHouses are in use."
+#define MSG_ALREADYHAVEGH        "Sorry, but you already own a GuildHouse (%s)."
+#define MSG_NOTENOUGHMONEY       "You do not have the %u gold required to purchase a GuildHouse."
+#define MSG_GHOCCUPIED           "This GuildHouse is unavailable for purchase as it is currently in use."
+#define MSG_CONGRATULATIONS      "Congratulations! You have successfully purchased a GuildHouse."
+#define MSG_SOLD                 "You have sold your GuildHouse and have received %u gold."
+#define MSG_NOTINGUILD           "You need to be in a guild before you can use a GuildHouse."
+#define MSG_SELL_CONFIRM         "Are you sure you want to sell your guildhouse for half the buy price?"
+
+#define OFFSET_GH_ID_TO_ACTION 1500
+#define OFFSET_SHOWBUY_FROM 10000
+
+#define ACTION_TELE 1001
+#define ACTION_SHOW_BUYLIST 1002 //deprecated. Use (OFFSET_SHOWBUY_FROM + 0) instead
+#define ACTION_SELL_GUILDHOUSE 1003
+
+#define ICON_GOSSIP_BALOON 0
+#define ICON_GOSSIP_WING 2
+#define ICON_GOSSIP_BOOK 3
+#define ICON_GOSSIP_WHEEL1 4
+#define ICON_GOSSIP_WHEEL2 5
+#define ICON_GOSSIP_GOLD 6
+#define ICON_GOSSIP_BALOONDOTS 7
+#define ICON_GOSSIP_TABARD 8
+#define ICON_GOSSIP_XSWORDS 9
+
+#define COST_GH_BUY 10000000 //1000 g.
+#define COST_GH_SELL 5000000 //500 g.
+
+#define GOSSIP_COUNT_MAX 10
+
+class guildmaster : public CreatureScript
+{
+ public:
+ guildmaster() : CreatureScript("guildmaster") { }
+
+bool isPlayerGuildLeader(Player *player)
+{
+ return (player->GetRank() == 0) && (player->GetGuildId() != 0);
+}
+
+bool getGuildHouseCoords(uint32 guildId, float &x, float &y, float &z, uint32 &map)
+{
+ if (guildId == 0)
+ {
+ //if player has no guild
+ return false;
+ }
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `x`, `y`, `z`, `map` FROM `guildhouses` WHERE `guildId` = %u", guildId);
+ if (result)
+ {
+ Field *fields = result->Fetch();
+ x = fields[0].GetFloat();
+ y = fields[1].GetFloat();
+ z = fields[2].GetFloat();
+ map = fields[3].GetUInt32();
+ return true;
+ }
+
+ return false;
+}
+
+void teleportPlayerToGuildHouse(Player *player, Creature *_creature)
+{
+ if (player->GetGuildId() == 0)
+ {
+ //if player has no guild
+ _creature->MonsterWhisper(MSG_NOTINGUILD, player);
+ return;
+ }
+
+ if (!player->getAttackers().empty())
+ {
+ //if player in combat
+ _creature->MonsterSay(MSG_INCOMBAT, LANG_UNIVERSAL, player);
+ return;
+ }
+
+ float x, y, z;
+ uint32 map;
+
+ if (getGuildHouseCoords(player->GetGuildId(), x, y, z, map))
+ {
+ //teleport player to the specified location
+ player->TeleportTo(map, x, y, z, 0.0f);
+ }
+ else
+ _creature->MonsterWhisper(MSG_NOGUILDHOUSE, player);
+}
+
+bool showBuyList(Player *player, Creature *_creature, uint32 showFromId = 0)
+{
+ //show not occupied guildhouses
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `id`, `comment` FROM `guildhouses` WHERE `guildId` = 0 AND `id` > %u ORDER BY `id` ASC LIMIT %u",
+ showFromId, GOSSIP_COUNT_MAX);
+
+ if (result)
+ {
+ uint32 guildhouseId = 0;
+ std::string comment = "";
+ do
+ {
+ Field *fields = result->Fetch();
+ guildhouseId = fields[0].GetInt32();
+ comment = fields[1].GetString();
+
+ //send comment as a gossip item
+ //transmit guildhouseId in Action variable
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_TABARD, comment, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_GH_ID_TO_ACTION);
+ }
+ while (result->NextRow());
+
+ if (result->GetRowCount() == GOSSIP_COUNT_MAX)
+ {
+ //assume that we have additional page
+ //add link to next GOSSIP_COUNT_MAX items
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOONDOTS, MSG_GOSSIP_NEXTPAGE, GOSSIP_SENDER_MAIN,
+ guildhouseId + OFFSET_SHOWBUY_FROM);
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+
+ return true;
+ }
+ else if (!result)
+ {
+ //all guildhouses are occupied
+ _creature->MonsterWhisper(MSG_NOFREEGH, player);
+ player->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+ //this condition occurs when COUNT(guildhouses) % GOSSIP_COUNT_MAX == 0
+ //just show GHs from beginning
+ showBuyList(player, _creature, 0);
+ }
+
+ return false;
+}
+
+bool isPlayerHasGuildhouse(Player *player, Creature *_creature, bool whisper = false)
+{
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `comment` FROM `guildhouses` WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ if (result)
+ {
+ if (whisper)
+ {
+ //whisper to player "already have etc..."
+ Field *fields = result->Fetch();
+ char msg[100];
+ sprintf(msg, MSG_ALREADYHAVEGH, fields[0].GetCString());
+ _creature->MonsterWhisper(msg, player);
+ }
+
+ return true;
+ }
+
+ return false;
+}
+
+void buyGuildhouse(Player *player, Creature *_creature, uint32 guildhouseId)
+{
+
+ bool token = sConfigMgr->GetBoolDefault("GuildHouse.TokenOrGold", false);
+ int cost = sConfigMgr->GetBoolDefault("GuildHouse.Cost", false);
+
+ if (player->GetMoney() < COST_GH_BUY)
+ {
+ //show how much money player need to buy GH (in gold)
+ char msg[100];
+ sprintf(msg, MSG_NOTENOUGHMONEY, COST_GH_BUY - sConfigMgr->GetBoolDefault("GuildHouse.Cost", false));
+ _creature->MonsterWhisper(msg, player);
+ return;
+ }
+
+ if (isPlayerHasGuildhouse(player, _creature, true))
+ {
+ //player already have GH
+ return;
+ }
+
+ QueryResult result;
+
+ //check if somebody already occupied this GH
+ result = WorldDatabase.PQuery("SELECT `id` FROM `guildhouses` WHERE `id` = %u AND `guildId` <> 0", guildhouseId);
+
+ if (result)
+ {
+ _creature->MonsterWhisper(MSG_GHOCCUPIED, player);
+ return;
+ }
+
+ //update DB
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = %u WHERE `id` = %u",
+ player->GetGuildId(), guildhouseId);
+
+
+ player->ModifyMoney(-sConfigMgr->GetIntDefault("GuildHouse.BuyCost", false) * 10000);
+
+ //player->DestroyItemCount(token, cost, true);
+ _creature->MonsterSay(MSG_CONGRATULATIONS, LANG_UNIVERSAL, player);
+
+}
+
+void sellGuildhouse(Player *player, Creature *_creature)
+{
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ QueryResult result;
+ result = WorldDatabase.PQuery("UPDATE `guildhouses` SET `guildId` = 0 WHERE `guildId` = %u",
+ player->GetGuildId());
+
+ player->ModifyMoney(sConfigMgr->GetIntDefault("GuildHouse.SellCost", false) * 10000);
+
+ //display message e.g. "here your money etc."
+ char msg[100];
+ sprintf(msg, MSG_SOLD, sConfigMgr->GetIntDefault("GuildHouse.SellCost", false));
+ _creature->MonsterWhisper(msg, player);
+ }
+}
+
+ bool OnGossipSelect(Player *player, Creature *_creature, uint32 sender, uint32 action)
+ {
+ player->PlayerTalkClass->ClearMenus();
+ if (sender != GOSSIP_SENDER_MAIN)
+ return false;
+
+ switch (action)
+ {
+ case ACTION_TELE:
+ //teleport player to GH
+ player->CLOSE_GOSSIP_MENU();
+ teleportPlayerToGuildHouse(player, _creature);
+ break;
+ case ACTION_SHOW_BUYLIST:
+ //show list of GHs which currently not occupied
+ showBuyList(player, _creature);
+ break;
+ case ACTION_SELL_GUILDHOUSE:
+  sellGuildhouse(player, _creature);
+  player->CLOSE_GOSSIP_MENU();
+ break;
+ default:
+ if (action > OFFSET_SHOWBUY_FROM)
+ {
+ showBuyList(player, _creature, action - OFFSET_SHOWBUY_FROM);
+ }
+ else if (action > OFFSET_GH_ID_TO_ACTION)
+ {
+ //player clicked on buy list
+ player->CLOSE_GOSSIP_MENU();
+
+ //get guildhouseId from action
+ //guildhouseId = action - OFFSET_GH_ID_TO_ACTION
+ buyGuildhouse(player, _creature, action - OFFSET_GH_ID_TO_ACTION);
+ }
+ break;
+ }
+
+ return true;
+ }
+
+
+ bool OnGossipHello(Player *player, Creature *_creature)
+ {
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_BALOON, MSG_GOSSIP_TELE, GOSSIP_SENDER_MAIN, ACTION_TELE);
+
+ if (isPlayerGuildLeader(player))
+ {
+ if (isPlayerHasGuildhouse(player, _creature))
+ {
+ //and additional for guildhouse owner (Removed :
+ player->ADD_GOSSIP_ITEM_EXTENDED(ICON_GOSSIP_GOLD, MSG_GOSSIP_SELL, GOSSIP_SENDER_MAIN, ACTION_SELL_GUILDHOUSE, MSG_SELL_CONFIRM, 0, false);
+
+ }
+ else
+ {
+ //show additional menu for guild leader
+ player->ADD_GOSSIP_ITEM(ICON_GOSSIP_GOLD, MSG_GOSSIP_BUY, GOSSIP_SENDER_MAIN, ACTION_SHOW_BUYLIST);
+ }
+ }
+
+ player->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE, _creature->GetGUID());
+ return true;
+ }
+
+
+};
+void AddSC_guildmaster()
+{
+ new guildmaster();
+}
diff --git a/src/server/scripts/Custom/killstreak.cpp b/src/server/scripts/Custom/killstreak.cpp
new file mode 100644
index 0000000..b0cad26
--- /dev/null
+++ b/src/server/scripts/Custom/killstreak.cpp
@@ -0,0 +1,63 @@
+/*
+Originally by Kjanko
+Edited by Tommy
+Edited by Rochet2 ~ Made dynamic
+Last Edit By Estorn
+Change : Fix For Last Rev
+*/
+
+#include "ScriptPCH.h"
+
+class System_OnKill : public PlayerScript
+{
+public:
+    System_OnKill() : PlayerScript("System_OnKill") {}
+
+    void OnPVPKill(Player * Killer, Player * Victim)
+    {
+        uint32 KillerGUID = Killer->GetGUIDLow();
+        uint32 VictimGUID = Victim->GetGUIDLow();
+
+        struct KillStreak_Info
+        {
+            uint32 killstreak;
+            uint32 lastkill;
+        };
+
+        static std::map<uint32, KillStreak_Info> KillStreakData;
+
+        if (KillerGUID == VictimGUID || KillStreakData[KillerGUID].lastkill == VictimGUID)
+            return;
+
+        if (KillStreakData[VictimGUID].killstreak >= 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has Ended |cFFFFFFFF" << Victim->GetName() << " !!!! ";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+        ++KillStreakData[KillerGUID].killstreak;
+        KillStreakData[KillerGUID].lastkill = VictimGUID;
+        KillStreakData[VictimGUID].killstreak = 0;
+        KillStreakData[VictimGUID].lastkill = 0;
+
+        if (KillStreakData[KillerGUID].killstreak % 10 == 0) // send killstreak message every 10 kills
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Has A KillStreak Of |cFF42A0CF" << KillStreakData[KillerGUID].killstreak << "|r!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+        else if (KillStreakData[KillerGUID].killstreak == 3)
+        {
+            std::ostringstream ss;
+            ss << "|cFF81CF42" << Killer->GetName() << "|r Server Killer Is On A KillingSpree!!!!!!";
+            sWorld->SendServerMessage(SERVER_MSG_STRING, ss.str().c_str());
+        }
+
+    }
+};
+
+void AddSC_PvP_System()
+{
+    new System_OnKill;
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/levelnpc.cpp b/src/server/scripts/Custom/levelnpc.cpp
new file mode 100644
index 0000000..20b4331
--- /dev/null
+++ b/src/server/scripts/Custom/levelnpc.cpp
@@ -0,0 +1,192 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ * Created by LordPsyan for Flaminglegion.net
+ *
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+class levelnpc : public CreatureScript
+{
+public:
+    levelnpc() : CreatureScript("levelnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("LevelNPC.OnlyGMs", false)) // If LevelNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only add levels to Platinum Members.", pPlayer);
+            return true;
+        }
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    else
+    {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+    }
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableLevel80 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel80", true);
+    bool EnableLevel100 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel100", true);
+    bool EnableLevel150 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel150", true);
+    bool EnableLevel200 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel200", true);
+    bool EnableLevel255 = sConfigMgr->GetBoolDefault("LevelNPC.EnableLevel255", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("LevelNPC.ItemEntryNum",0)), 0))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer);
+    return;
+}
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+
+switch(uiAction)
+{
+
+//////////////////////////////////////////////////Leveling///////////////////////////////////////////////////////////////
+case 1000: //Leveling
+    if(EnableLevel80 && pPlayer->getLevel() < 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(1 Donation Chip) Instant 80 ->"         , GOSSIP_SENDER_MAIN, 1001);
+    if(EnableLevel100 && pPlayer->getLevel() < 100 && pPlayer->getLevel() >= 80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(2 Donation Chips) Instant 100 ->"        , GOSSIP_SENDER_MAIN, 1002);
+    if(EnableLevel150 && pPlayer->getLevel() < 150 && pPlayer->getLevel() >= 100)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(5 Donation Chips) Instant 150 ->"        , GOSSIP_SENDER_MAIN, 1003);
+    if(EnableLevel200 && pPlayer->getLevel() < 200 && pPlayer->getLevel() >= 150)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(10 Donation Chips) Instant 200 ->"       , GOSSIP_SENDER_MAIN, 1004);
+    if(EnableLevel255 && pPlayer->getLevel() < 255 && pPlayer->getLevel() >= 200)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "(20 Donation Chips) Instant 255 ->"       , GOSSIP_SENDER_MAIN, 1005);
+        pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                       , GOSSIP_SENDER_MAIN, 3000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 3000: //Leveling
+    if(EnableLevel80)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Instant Levels ->"        , GOSSIP_SENDER_MAIN, 1000);
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+case 1001: // Leveling
+    pPlayer->GiveLevel(80);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1002: // Leveling
+    pPlayer->GiveLevel(100);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 2, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1003: // Leveling
+    pPlayer->GiveLevel(150);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 5, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1004: // Leveling
+    pPlayer->GiveLevel(200);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 10, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 1005: // Leveling
+    pPlayer->GiveLevel(255);
+    if(sConfigMgr->GetBoolDefault("LevelNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99998, 20, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("LevelNPC.SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+    {
+        pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_levelnpc()
+{
+
+new levelnpc();
+
+}
diff --git a/src/server/scripts/Custom/npc_teleport.cpp b/src/server/scripts/Custom/npc_teleport.cpp
new file mode 100644
index 0000000..07d1ae2
--- /dev/null
+++ b/src/server/scripts/Custom/npc_teleport.cpp
@@ -0,0 +1,222 @@
+/**
+ *
+ * @File : npc_teleport.cpp
+ *
+ * @Authors : Wilibald09
+ *
+ * @Date : 19/08/2008
+ *
+ * @Version : 1.2
+ *
+ **/
+
+
+
+#include "ScriptPCH.h"
+#include "sc_npc_teleport.h"
+#include <sstream>
+
+#define GOSSIP_SHOW_DEST        1000
+#define GOSSIP_TELEPORT         1001
+#define GOSSIP_NEXT_PAGEC       1002
+#define GOSSIP_PREV_PAGEC       1003
+#define GOSSIP_NEXT_PAGED       1004
+#define GOSSIP_PREV_PAGED       1005
+#define GOSSIP_MAIN_MENU        1006
+
+#define SPELL_ID_PASSIVE_RESURRECTION_SICKNESS  15007
+#define SPELL_VISUAL_TELEPORT   35517
+
+#define NB_ITEM_PAGE            15
+#define MSG_CAT                 100000
+#define MSG_DEST                100001
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+
+using namespace nsNpcTel;
+
+
+namespace
+{
+    Page PageC, PageD;
+    Page Cat;
+
+    // Conversion function int->string
+    std::string ConvertStr(const int64 &val)
+    {
+        std::ostringstream ostr;
+        ostr << val;
+        return ostr.str();
+    }
+
+    // Conversion function intMoney->stringMoney
+    std::string ConvertMoney(const uint32 &Money)
+    {
+        std::string Str(ConvertStr(Money));
+        uint32 SizeStr = Str.length();
+
+        if (SizeStr > 4)
+            Str = Str.insert(Str.length()-4, "po");
+        if (SizeStr > 2)
+            Str = Str.insert(Str.length()-2, "pa");
+        Str += "pc";
+
+        return Str;
+    }
+
+    // Teleport Player
+    void Teleport(Player * const player, const uint16 &map,
+                  const float &X, const float &Y, const float &Z, const float &orient)
+    {
+        player->CastSpell(player, SPELL_VISUAL_TELEPORT, true);
+        player->TeleportTo(map, X, Y, Z, orient);
+    }
+
+    // Display categories
+    void AffichCat(Player * const player, Creature * const creature)
+    {
+        if (PageC[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGEC, 0);
+
+        VCatDest_t i (PageC[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest.size() && i < (NB_ITEM_PAGE * (PageC[player] + 1)); ++i)
+        {
+            if (TabCatDest[i].IsAllowedToTeleport(player))
+                player->ADD_GOSSIP_ITEM(7, TabCatDest[i].GetName(player->IsGameMaster()).c_str(), GOSSIP_SHOW_DEST, i);
+        }
+
+        if (i < TabCatDest.size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGEC, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_CAT, creature->GetGUID());
+    }
+
+    // Display destination categories
+    void AffichDest(Player * const player, Creature * const creature)
+    {
+        if (PageD[player] > 0)
+            player->ADD_GOSSIP_ITEM(7, PREV_PAGE, GOSSIP_PREV_PAGED, 0);
+
+        CatDest::VDest_t i (PageD[player] * NB_ITEM_PAGE);
+        for ( ; i < TabCatDest[Cat[player]].size() && i < (NB_ITEM_PAGE * (PageD[player] + 1)); ++i)
+        {
+            player->ADD_GOSSIP_ITEM(5, TabCatDest[Cat[player]].GetDest(i).m_name.c_str(), GOSSIP_TELEPORT, i);
+        }
+
+        if (i < TabCatDest[Cat[player]].size())
+            player->ADD_GOSSIP_ITEM(7, NEXT_PAGE, GOSSIP_NEXT_PAGED, 0);
+
+        if (CatDest::CountOfCategoryAllowedBy(player) > 1)
+            player->ADD_GOSSIP_ITEM(7, MAIN_MENU, GOSSIP_MAIN_MENU, 0);
+
+        player->SEND_GOSSIP_MENU(MSG_DEST, creature->GetGUID());
+    }
+
+    // Verification before teleportation
+    void ActionTeleport(Player * const player, Creature * const creature, const uint32 &id)
+    {
+        Dest dest (TabCatDest[Cat[player]].GetDest(id));
+
+        if (player->getLevel() < dest.m_level && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have the required level. This destination requires level " + ConvertStr(dest.m_level) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (player->GetMoney() < dest.m_cost && !player->IsGameMaster())
+        {
+            std::string msg ("You do not have enough money. The price for teleportation is " + ConvertMoney(dest.m_cost) + ".");
+            creature->MonsterWhisper(msg.c_str(), player);
+            return;
+        }
+
+        if (!player->IsGameMaster() && dest.m_cost)
+            player->ModifyMoney(-1 * dest.m_cost);
+
+        Teleport(player, dest.m_map, dest.m_X, dest.m_Y, dest.m_Z, dest.m_orient);
+    }
+}
+
+class npc_teleport : public CreatureScript
+{
+public:
+    npc_teleport() : CreatureScript("npc_teleport") {}
+
+bool OnGossipHello(Player *player, Creature *creature)
+{
+    PageC(player) = PageD(player) = Cat(player) = 0;
+
+    if(player->IsInCombat())
+    {
+        player->CLOSE_GOSSIP_MENU();
+        creature->MonsterWhisper("You are in combat. Come back later", player);
+        return true;
+    }
+    AffichCat(player, creature);
+    return true;
+}
+
+bool OnGossipSelect(Player *player, Creature *creature, uint32 sender, uint32 param)
+{
+    player->PlayerTalkClass->ClearMenus();
+    switch(sender)
+    {
+      // Display destinations
+      case GOSSIP_SHOW_DEST:
+        Cat(player) = param;
+        AffichDest(player, creature);
+        break;
+
+      // Previous categories page
+      case GOSSIP_PREV_PAGEC:
+        --PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Next page categories
+      case GOSSIP_NEXT_PAGEC:
+        ++PageC(player);
+        AffichCat(player, creature);
+        break;
+
+      // Previous destinations page
+      case GOSSIP_PREV_PAGED:
+        --PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Next destination page
+      case GOSSIP_NEXT_PAGED:
+        ++PageD(player);
+        AffichDest(player, creature);
+        break;
+
+      // Display main menu
+      case GOSSIP_MAIN_MENU:
+        OnGossipHello(player, creature);
+        break;
+
+      // Teleportation
+      case GOSSIP_TELEPORT:
+        player->CLOSE_GOSSIP_MENU();
+        if(player->HasAura(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS,0)) {
+            creature->CastSpell(player,38588,false); // Healing effect
+            player->RemoveAurasDueToSpell(SPELL_ID_PASSIVE_RESURRECTION_SICKNESS);
+        }
+
+        ActionTeleport(player, creature, param);
+        break;
+    }
+    return true;
+}
+};
+
+void AddSC_npc_teleport()
+{
+    new npc_teleport;
+}
+// End of TeleNPC2
diff --git a/src/server/scripts/Custom/npcbuff.cpp b/src/server/scripts/Custom/npcbuff.cpp
new file mode 100644
index 0000000..9ecd4f3
--- /dev/null
+++ b/src/server/scripts/Custom/npcbuff.cpp
@@ -0,0 +1,426 @@
+/* Copyright (C) 2010 SAMCC Studios <http://www.samccstudios.com/>
+ * Written by LordPsyan
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+ /*
+Script Name: npc_buff v1.1
+Complete: 100%
+Comment: Database Driven Buff Master
+*/
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "SystemConfig.h"
+
+#define GOSSIP_SENDER_MAIN      1000
+#define GOSSIP_SMALLBUFF        2000
+#define GOSSIP_LARGEBUFF        3000
+#define GOSSIP_GMBUFF           4000
+#define GOSSIP_PLAYERTOOLS      5000
+
+#define SPELL_RESURRECTION_SICKNESS_15007  15007
+
+#define NB_BUFF_PAGE            10
+#define MSG_TYPE                100002
+#define MSG_BUFF                100003
+
+#define NEXT_PAGE               "-> [Next Page]"
+#define PREV_PAGE               "<- [Previous Page]"
+#define MAIN_MENU               "<= [Main Menu]"
+
+class npc_buff : public CreatureScript
+{
+public:
+    npc_buff() : CreatureScript("npc_buff") {}
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("Npc_Buff.OnlyGMs", false)) // If Npc_Buff.OnlyGMs is enabled in worldserver.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only Buff Platinum Members.", pPlayer);
+            return true;
+        }
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+    // Main Menu
+
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_SENDER_MAIN, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_SENDER_MAIN, 4000);
+
+    // Check config file if "Remove res sickness" option is enabled or not
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+
+return true;
+}
+
+bool showSmallBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showSmallBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGreatBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 3000 AND `cat_number` > 2000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGreatBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showGmBuff(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 4000 AND `cat_number` > 3000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showGmBuff(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+bool showPlayerTools(Player *pPlayer, Creature *pCreature, uint32 showFromId = 0)
+{
+
+
+ QueryResult result;
+ result = WorldDatabase.PQuery("SELECT `name`, `cat_number` FROM `npc_buff_spells` WHERE `cat_number` < 5000 AND `cat_number` > 4000 ORDER BY `cat_number` ASC");
+
+ if (result)
+ {
+ std::string name = "";
+ uint32 catNumber = 0;
+  do
+ {
+ Field *fields = result->Fetch();
+ name = fields[0].GetString();
+ catNumber = fields[1].GetInt32();
+
+    pPlayer->ADD_GOSSIP_ITEM(9, name, GOSSIP_SENDER_MAIN, catNumber);
+}
+ while (result->NextRow());
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+ return true;
+ }
+ else
+ {
+ if (showFromId = 0)
+ {
+ //you are too poor
+ pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+ else
+ {
+
+ //show Spells from beginning
+ showPlayerTools(pPlayer, pCreature, 0);
+ }
+ }
+
+ return false;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableSmallBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableSmallBuff", true);
+    bool EnableGreatBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGreatBuff", true);
+    bool EnableGMBuff = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGMBuff", true);
+    bool EnablePlayerTools = sConfigMgr->GetBoolDefault("Npc_Buff.EnablePlayerTools", true);
+    bool EnableResSickness = sConfigMgr->GetBoolDefault("Npc_Buff.EnableRemoveResSickness", true);
+    bool EnableGivemeGold = sConfigMgr->GetBoolDefault("Npc_Buff.EnableGivemeGold", false);
+
+//Money Check
+if (pPlayer->GetMoney() < (sConfigMgr->GetFloatDefault("BuffGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+
+
+  // send name as gossip item
+
+
+       QueryResult result;
+        uint32 spellId = 0;
+        uint32 catNumber = 0;
+        uint32 goldCost = 0;
+        std::string spellName = "";
+
+        result = WorldDatabase.PQuery("SELECT `spell_id`, `cat_number`, `cost`, `name` FROM `npc_buff_spells` WHERE `cat_number` = %u LIMIT 1", uiAction);
+
+        if (result)
+        {
+
+            do {
+
+            Field *fields = result->Fetch();
+            spellId = fields[0].GetInt32();
+            catNumber = fields[1].GetInt32();
+            goldCost = fields[2].GetInt32();
+            spellName = fields[3].GetString();
+
+            if (pPlayer->GetMoney() < goldCost)
+            {
+                pCreature->MonsterWhisper("You dont have enough money!", pPlayer);
+                pPlayer->CLOSE_GOSSIP_MENU();
+                return;
+            }
+            else if (uiAction < 5000 && uiAction != 1000 && uiAction != 2000 && uiAction != 3000 && uiAction != 4000 && uiAction != 5005)
+            {
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pPlayer->CastSpell(pPlayer,spellId,false);
+    pPlayer->ModifyMoney(-goldCost);
+
+            }
+
+            } while (result->NextRow());
+        } else {
+            //pPlayer->ADD_GOSSIP_ITEM( 7, MAIN_MENU, GOSSIP_SENDER_MAIN, 5005);
+        }
+
+ switch(uiAction)
+{
+
+case 1000: //Small  Buff
+         showSmallBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 2000: //Great Buff
+
+
+        showGreatBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF, pCreature->GetGUID());
+break;
+
+case 3000: //GM  Buff
+
+        showGmBuff(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 4000: //Player Tools
+    // Check config if "Give me Gold" is enabled or not
+
+        showPlayerTools(pPlayer, pCreature, 0);
+        //pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"                            , GOSSIP_SENDER_MAIN, 5005);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_BUFF,pCreature->GetGUID());
+break;
+
+case 5005: //Back To Main Menu
+    // Main Menu
+    // Check config if "Small  Buff " is enabled or not
+    if(EnableSmallBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Small Buff ->"              , GOSSIP_SMALLBUFF, 1000);
+    // Check config if "Great Buff" is enabled or not
+    if(EnableGreatBuff)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Great Buff ->"              , GOSSIP_LARGEBUFF, 2000);
+    // Check config if "GM Buff" is enabled or not
+    if(EnableGMBuff)
+    {
+    if (pPlayer->GetSession()->GetSecurity() > SEC_PLAYER)
+        {
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Platinum Members Buff ->"                 , GOSSIP_SENDER_MAIN, 3000);
+        }
+    }
+    // Check config if "Player Tools" is enabled or not
+    if(EnablePlayerTools)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Player Tools ->"            , GOSSIP_PLAYERTOOLS, 4000);
+    // Check if Ress Sickness option is enabled
+    if(EnableResSickness)
+        pPlayer->ADD_GOSSIP_ITEM( 10, "Remove Resurrect Sickness" , GOSSIP_SENDER_MAIN, 5000);
+
+    pPlayer->SEND_GOSSIP_MENU(MSG_TYPE, pCreature->GetGUID());
+break;
+
+case 5000://Remove Res Sickness
+    if(!pPlayer->HasAura(SPELL_RESURRECTION_SICKNESS_15007,0))
+    {
+        pCreature->MonsterWhisper("You don't have resurrection sickness.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pCreature->CastSpell(pPlayer,38588,false); // Healing effect
+    pPlayer->RemoveAurasDueToSpell(SPELL_RESURRECTION_SICKNESS_15007,0);
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+ pPlayer->CLOSE_GOSSIP_MENU();
+ }
+
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+void AddSC_Npc_Buff()
+{
+    new npc_buff();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Custom/professionnpc.cpp b/src/server/scripts/Custom/professionnpc.cpp
new file mode 100644
index 0000000..3407d40
--- /dev/null
+++ b/src/server/scripts/Custom/professionnpc.cpp
@@ -0,0 +1,396 @@
+/* Copyright (C) 2006 - 2009 ScriptDev2 <https://scriptdev2.svn.sourceforge.net/>
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ */
+
+#include "ScriptPCH.h"
+#include "Config.h"
+#include "SystemConfig.h"
+
+class professionnpc : public CreatureScript
+{
+public:
+    professionnpc() : CreatureScript("professionnpc") {}
+
+
+bool OnGossipHello(Player* pPlayer, Creature* pCreature)
+{
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.OnlyGMs", false)) // If ProfessionNPC.OnlyGMs is enabled in trinitycore.conf
+        if (pPlayer->GetSession()->GetSecurity() == SEC_PLAYER)
+        {
+            pCreature->MonsterWhisper("Sorry, I can only trade to game masters.", pPlayer);
+            return true;
+        }
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+
+return true;
+}
+
+void SendDefaultMenu(Player* pPlayer, Creature* pCreature, uint32 uiAction)
+{
+
+// Not allow in combat
+if (pPlayer->IsInCombat())
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterSay("You are in combat!", LANG_UNIVERSAL, NULL);
+    return;
+}
+
+    bool EnableProfessions = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableProfessions", true);
+    bool EnableSecondarySkills = sConfigMgr->GetBoolDefault("ProfessionNPC.EnableSecondarySkills", true);
+
+//Mony Check
+if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+{
+if (!pPlayer->HasItemCount((sConfigMgr->GetIntDefault("ProfessionNPC.ItemEntryNum",0)), 1))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You ain't gots no darn chips.", pPlayer);
+    return;
+}
+else if(pPlayer->GetMoney() < (sConfigMgr->GetIntDefault("SkillGoldCost",0)))
+{
+    pPlayer->CLOSE_GOSSIP_MENU();
+    pCreature->MonsterWhisper("You don't have enough money.", pPlayer);
+    return;
+}
+}
+switch(uiAction)
+{
+
+case 1000: //Profession
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Alchemy."              , GOSSIP_SENDER_MAIN, 1001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Blacksmithing."        , GOSSIP_SENDER_MAIN, 1002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Enchanting."           , GOSSIP_SENDER_MAIN, 1003);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Engineering."          , GOSSIP_SENDER_MAIN, 1004);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Herbalism."            , GOSSIP_SENDER_MAIN, 1005);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Inscription."          , GOSSIP_SENDER_MAIN, 1006);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Jewelcrafting."        , GOSSIP_SENDER_MAIN, 1007);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Leatherworking."       , GOSSIP_SENDER_MAIN, 1008);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Mining."               , GOSSIP_SENDER_MAIN, 1009);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Skinning."             , GOSSIP_SENDER_MAIN, 1010);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "10 points in Tailoring."            , GOSSIP_SENDER_MAIN, 1011);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 2000: //Secondary Skills
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Cooking."              , GOSSIP_SENDER_MAIN, 2001);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "First Aid."            , GOSSIP_SENDER_MAIN, 2002);
+            pPlayer->ADD_GOSSIP_ITEM( 5, "Fishing."              , GOSSIP_SENDER_MAIN, 2003);
+            pPlayer->ADD_GOSSIP_ITEM( 7, "<- Main Menu"          , GOSSIP_SENDER_MAIN, 3000);
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+case 3000: //Back To Main Menu
+    // Main Menu for Alliance
+    if (pPlayer->GetTeam() == ALLIANCE)
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+    else // Main Menu for Horde
+    {
+    // Check config if "Professions" is enabled or not
+    if(EnableProfessions)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Professions ->"        , GOSSIP_SENDER_MAIN, 1000);
+    // Check config if "Secondary Skills" is enabled or not
+    if(EnableSecondarySkills)
+        pPlayer->ADD_GOSSIP_ITEM( 7, "Secondary Skills ->"   , GOSSIP_SENDER_MAIN, 2000);
+    }
+
+    pPlayer->SEND_GOSSIP_MENU(DEFAULT_GOSSIP_MESSAGE,pCreature->GetGUID());
+break;
+
+//////////////////////////////////////////////////Professions///////////////////////////////////////////////////////////////
+
+case 1001: // Alchemy
+    if(!pPlayer->UpdateSkill(171,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(171,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1002: // Blacksmithing
+    if(!pPlayer->UpdateSkill(164,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(164,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1003: // Enchanting
+    if(!pPlayer->UpdateSkill(333,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(333,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1004: // Engineering
+    if(!pPlayer->UpdateSkill(202,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(202,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1005: // Herbalism
+    if(!pPlayer->UpdateSkill(182,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(182,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1006: // Inscription
+    if(!pPlayer->UpdateSkill(773,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(773,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1007: // Jewelcrafting
+    if(!pPlayer->UpdateSkill(755,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(755,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1008: // Leatherworking
+    if(!pPlayer->UpdateSkill(165,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(165,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1009: // Mining
+    if(!pPlayer->UpdateSkill(186,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(186,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1010: // Skinning
+    if(!pPlayer->UpdateSkill(393,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(393,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 1011: // Tailoring
+    if(!pPlayer->UpdateSkill(197,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(197,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+//////////////////////////////////////////////////Secondary Skills///////////////////////////////////////////////////////////////
+
+case 2001: // Cooking
+    if(!pPlayer->UpdateSkill(185,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(185,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2002: // First Aid
+    if(!pPlayer->UpdateSkill(129,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(129,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+case 2003: // Fishing
+    if(!pPlayer->UpdateSkill(356,0))
+      {
+        pCreature->MonsterWhisper("You don't have this skill or you allready have the maximum skill value $C.", pPlayer);
+        OnGossipHello(pPlayer, pCreature);
+        return;
+    }
+
+    pPlayer->UpdateSkill(356,(sConfigMgr->GetIntDefault("SkillPoints",0)));
+    if(sConfigMgr->GetBoolDefault("ProfessionNPC.UseTokens", true))
+    pPlayer->DestroyItemCount(99999, 1, true);
+    else
+    pPlayer->ModifyMoney(-(sConfigMgr->GetIntDefault("SkillGoldCost",0)));
+    pPlayer->CLOSE_GOSSIP_MENU();
+break;
+
+ pPlayer->CLOSE_GOSSIP_MENU();
+
+} // end of switch
+} //end of function
+
+bool OnGossipSelect(Player* pPlayer, Creature* pCreature, uint32 uiSender, uint32 uiAction)
+{
+    // Main menu
+    pPlayer->PlayerTalkClass->ClearMenus();
+    if (uiSender == GOSSIP_SENDER_MAIN)
+    SendDefaultMenu(pPlayer, pCreature, uiAction);
+
+return true;
+}
+};
+
+void AddSC_professionnpc()
+{
+
+new professionnpc();
+
+}
diff --git a/src/server/scripts/Custom/summon.cpp b/src/server/scripts/Custom/summon.cpp
new file mode 100644
index 0000000..ce7ea24
--- /dev/null
+++ b/src/server/scripts/Custom/summon.cpp
@@ -0,0 +1,46 @@
+#include "ScriptPCH.h"
+
+class summon : public ItemScript
+{
+        public:
+                summon() : ItemScript("summon")
+                {
+                }
+                bool OnUse(Player* pPlayer, Item* pItem, SpellCastTargets const& /*targets*/)
+                {
+   uint32 sSpell = 18282; //Icerune Visual Spell when used
+   if (pPlayer->IsInCombat())
+   {
+        pPlayer->GetSession()->SendNotification("You are in combat.");
+   }
+
+   else if (pPlayer->isMoving())
+   {
+        pPlayer->GetSession()->SendNotification("You can not do that while moving.");
+   }
+
+   else if (pPlayer->FindNearestCreature(80410, 40) || pPlayer->FindNearestCreature(100000, 8))
+   {
+        pPlayer->GetSession()->SendNotification("Teleportercan not be summoned because another Teleporter is within range.");
+   }
+
+   else
+   {
+        float x, y, z, o = pPlayer->GetOrientation();
+
+        if (o >= 3.141592)
+         o = o - 3.141592;
+        else
+         o = o + 3.141592;
+        pPlayer->GetClosePoint(x, y, z, pPlayer->GetObjectSize());
+        Creature* pCreature = pPlayer->SummonCreature(100000, x, y, z+2.2, o, TEMPSUMMON_TIMED_DESPAWN, 5000);
+        pCreature->CastSpell(pCreature, 63660);
+        return false;
+   }
+  return false;
+                }
+};
+void AddSC_summon()
+{
+        new summon();
+}
\ No newline at end of file
diff --git a/src/server/scripts/Spells/spell_generic.cpp b/src/server/scripts/Spells/spell_generic.cpp
index e198a6a..40d88be 100644
--- a/src/server/scripts/Spells/spell_generic.cpp
+++ b/src/server/scripts/Spells/spell_generic.cpp
@@ -37,6 +37,7 @@
 #include "SpellScript.h"
 #include "SpellAuraEffects.h"
 #include "Vehicle.h"
+#include "../Custom/Transmogrification.h"
 
 class spell_gen_absorb0_hitlimit1 : public SpellScriptLoader
 {
@@ -811,7 +812,12 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* mainItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_MAINHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            {
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(mainItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, mainItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID));
@@ -825,7 +831,12 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* offItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_OFFHAND))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
+                            {
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(offItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, offItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 1));
@@ -838,7 +849,12 @@ class spell_gen_clone_weapon_aura : public SpellScriptLoader
                         if (Player* player = caster->ToPlayer())
                         {
                             if (Item* rangedItem = player->GetItemByPos(INVENTORY_SLOT_BAG_0, EQUIPMENT_SLOT_RANGED))
-                                target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
+                            {
+                                if (uint32 entry = sTransmogrification->GetFakeEntry(rangedItem))
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, entry);
+                                else
+                                    target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, rangedItem->GetEntry());
+                            }
                         }
                         else
                             target->SetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2, caster->GetUInt32Value(UNIT_VIRTUAL_ITEM_SLOT_ID + 2));
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.cpp b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
index aa584d0..0a8b7cd 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.cpp
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.cpp
@@ -22,6 +22,11 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     if (!m_reconnecting)
         m_stmts.resize(MAX_CHARACTERDATABASE_STATEMENTS);
 
+    PrepareStatement(FAKE_CHAR_SEL_RACE_BY_NAME, "SELECT race FROM characters_fake WHERE name = ?", CONNECTION_SYNCH);
+    PrepareStatement(FAKE_CHAR_SEL_RACE_BY_NAME_IS_ONLINE, "SELECT race FROM characters_fake WHERE HOUR(online) BETWEEN HOUR(NOW()) AND (HOUR(NOW()) + ?) AND name = ?", CONNECTION_SYNCH);
+    PrepareStatement(FAKE_CHAR_ONLINE, "SELECT name,race,class,level,zone,gender FROM characters_fake WHERE HOUR(online) BETWEEN HOUR(NOW()) AND (HOUR(NOW()) + ?)", CONNECTION_SYNCH);
+    PrepareStatement(FAKE_CHAR_ONLINE_SEARCH, "SELECT name,race,class,level,zone,gender FROM characters_fake WHERE HOUR(online) BETWEEN HOUR(NOW()) AND (HOUR(NOW()) + ?) AND name = ?", CONNECTION_SYNCH);
+
     PrepareStatement(CHAR_DEL_QUEST_POOL_SAVE, "DELETE FROM pool_quest_save WHERE pool_id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_INS_QUEST_POOL_SAVE, "INSERT INTO pool_quest_save (pool_id, quest_id) VALUES (?, ?)", CONNECTION_ASYNC);
     PrepareStatement(CHAR_DEL_NONEXISTENT_GUILD_BANK_ITEM, "DELETE FROM guild_bank_item WHERE guildid = ? AND TabId = ? AND SlotId = ?", CONNECTION_ASYNC);
@@ -142,6 +147,9 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_UPD_MAIL_RETURNED, "UPDATE mail SET sender = ?, receiver = ?, expire_time = ?, deliver_time = ?, cod = 0, checked = ? WHERE id = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_MAIL_ITEM_RECEIVER, "UPDATE mail_items SET receiver = ? WHERE item_guid = ?", CONNECTION_ASYNC);
     PrepareStatement(CHAR_UPD_ITEM_OWNER, "UPDATE item_instance SET owner_guid = ? WHERE guid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_GET_EXTERNAL_MAIL, "SELECT id, receiver, subject, message, money, item, item_count FROM mail_external ORDER BY id ASC", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_DEL_EXTERNAL_MAIL, "DELETE FROM mail_external WHERE id = ?", CONNECTION_ASYNC);
+
 
     PrepareStatement(CHAR_SEL_ITEM_REFUNDS, "SELECT player_guid, paidMoney, paidExtendedCost FROM item_refund_instance WHERE item_guid = ? AND player_guid = ? LIMIT 1", CONNECTION_SYNCH);
     PrepareStatement(CHAR_SEL_ITEM_BOP_TRADE, "SELECT allowedPlayers FROM item_soulbound_trade_data WHERE itemGuid = ? LIMIT 1", CONNECTION_SYNCH);
@@ -605,5 +613,36 @@ void CharacterDatabaseConnection::DoPrepareStatements()
     PrepareStatement(CHAR_SEL_PVPSTATS_MAXID, "SELECT MAX(id) FROM pvpstats_battlegrounds", CONNECTION_SYNCH);
     PrepareStatement(CHAR_INS_PVPSTATS_BATTLEGROUND, "INSERT INTO pvpstats_battlegrounds (id, winner_faction, bracket_id, type, date) VALUES (?, ?, ?, ?, NOW())", CONNECTION_ASYNC);
     PrepareStatement(CHAR_INS_PVPSTATS_PLAYER, "INSERT INTO pvpstats_players (battleground_id, character_guid, score_killing_blows, score_deaths, score_honorable_kills, score_bonus_honor, score_damage_done, score_healing_done, attr_1, attr_2, attr_3, attr_4, attr_5) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)", CONNECTION_ASYNC);
-
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    //Guild-Level-System
+    //Load
+    PrepareStatement(CHAR_SEL_GUILD_BONUS_INFO, "SELECT RequiredGuildLevel FROM guild_bonus_config WHERE BonusId = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_GUILD_LEVEL_INFO, "SELECT xp, level FROM guild WHERE guildid = ?", CONNECTION_SYNCH);
+    PrepareStatement(CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL, "SELECT xp_for_next_level FROM guild_xp_for_next_level WHERE level = ?", CONNECTION_SYNCH);
+
+    //Save
+    PrepareStatement(CHAR_UPD_GUILD_LEVEL, "UPDATE guild SET level = ? WHERE guildid = ?", CONNECTION_ASYNC);
+    PrepareStatement(CHAR_UPD_GUILD_XP, "UPDATE guild SET xp = (xp + ?) WHERE guildid = ?", CONNECTION_ASYNC);
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
 }
diff --git a/src/server/shared/Database/Implementation/CharacterDatabase.h b/src/server/shared/Database/Implementation/CharacterDatabase.h
index 19b5fef..2a0bfdb 100644
--- a/src/server/shared/Database/Implementation/CharacterDatabase.h
+++ b/src/server/shared/Database/Implementation/CharacterDatabase.h
@@ -42,6 +42,11 @@ enum CharacterDatabaseStatements
         name for a suiting suffix.
     */
 
+    FAKE_CHAR_SEL_RACE_BY_NAME,
+    FAKE_CHAR_SEL_RACE_BY_NAME_IS_ONLINE,
+    FAKE_CHAR_ONLINE,
+    FAKE_CHAR_ONLINE_SEARCH,
+
     CHAR_DEL_QUEST_POOL_SAVE,
     CHAR_INS_QUEST_POOL_SAVE,
     CHAR_DEL_NONEXISTENT_GUILD_BANK_ITEM,
@@ -142,6 +147,8 @@ enum CharacterDatabaseStatements
     CHAR_UPD_MAIL_RETURNED,
     CHAR_UPD_MAIL_ITEM_RECEIVER,
     CHAR_UPD_ITEM_OWNER,
+    CHAR_GET_EXTERNAL_MAIL,
+    CHAR_DEL_EXTERNAL_MAIL,
     CHAR_SEL_ITEM_REFUNDS,
     CHAR_SEL_ITEM_BOP_TRADE,
     CHAR_DEL_ITEM_BOP_TRADE,
@@ -537,7 +544,35 @@ enum CharacterDatabaseStatements
     CHAR_SEL_PVPSTATS_MAXID,
     CHAR_INS_PVPSTATS_BATTLEGROUND,
     CHAR_INS_PVPSTATS_PLAYER,
-
+    // Prepatch by LordPsyan
+    // 01
+    // 02
+    //Guild-Level-System
+    CHAR_SEL_GUILD_BONUS_INFO,
+    CHAR_SEL_GUILD_LEVEL_INFO,
+    CHAR_SEL_GUILD_XP_FOR_NEXT_LEVEL,
+    CHAR_UPD_GUILD_LEVEL,
+    CHAR_UPD_GUILD_XP,
+    // 04
+    // 05
+    // 06
+    // 07
+    // 08
+    // 09
+    // 10
+    // 11
+    // 12
+    // 13
+    // 14
+    // 15
+    // 16
+    // 17
+    // 18
+    // 19
+    // 20
+    // Visit http://www.realmsofwarcraft.com/bb for forums and information
+    //
+    // End of prepatch
     MAX_CHARACTERDATABASE_STATEMENTS
 };
 
diff --git a/src/server/worldserver/worldserver.conf.dist b/src/server/worldserver/worldserver.conf.dist
index 3fec136..f9fc0ef 100644
--- a/src/server/worldserver/worldserver.conf.dist
+++ b/src/server/worldserver/worldserver.conf.dist
@@ -3,6 +3,28 @@
 ################################################
 [worldserver]
 
+################################################
+#         Prepatch config by LordPsyan         #
+#       http://www.realmsofwarcraft.com/       #
+################################################
+
+###################################################################################################
+#
+# Prepatch Configuration
+#
+#
+# If you add GuildLevelSystem or Individual XP Rate patches, you must
+# set this to 1.
+#
+# PrepatchGI Added
+#         default = 0 (GuildLevelSystem and Individual XP Rate not added)
+#                 = 1 (GuildLevelSystem and/or Individual XP Rate added)
+
+PrepatchGI.Added = 0
+
+#
+###################################################################################################
+
 ###################################################################################################
 # SECTION INDEX
 #
@@ -770,6 +792,13 @@ RecruitAFriend.MaxDifference = 4
 DisableWaterBreath = 4
 
 #
+#    Enable or Disable "Fatigue" timer
+#           default = 1 (enabled)
+#                   = 0 (disabled)
+
+fatigue.enabled = 1
+
+#
 #    AllFlightPaths
 #        Description: Character knows all flight paths (of both factions) after creation.
 #        Default:     0 - (Disabled)
@@ -2628,6 +2657,40 @@ LevelReq.Auction = 1
 LevelReq.Mail = 1
 
 #
+#     Anticheat.Enable
+#        Description: Enables or disables the Anticheat System functionality
+#        Default:     1 - (Enabled)
+#                     0 - (Disabled)
+
+Anticheat.Enable = 1
+
+#     Anticheat.ReportsForIngameWarnings
+#        Description: How many reports the player must have to notify to GameMasters ingame when he generates a new report.
+#        Default:     70
+
+Anticheat.ReportsForIngameWarnings = 70
+
+#     Anticheat.DetectionsEnabled
+#        Description: It represents which detections are enabled.
+#
+#        SPEED_HACK_DETECTION            = 1
+#        FLY_HACK_DETECTION              = 2
+#        WALK_WATER_HACK_DETECTION       = 4
+#        JUMP_HACK_DETECTION             = 8
+#        TELEPORT_PLANE_HACK_DETECTION   = 16
+#        CLIMB_HACK_DETECTION            = 32
+#
+#        Default:     31
+
+Anticheat.DetectionsEnabled = 31
+
+#     Anticheat.MaxReportsForDailyReport
+#        Description: How many reports must the player have to make a report that it is in DB for a day (not only during the player's session).
+#        Default:     70
+
+Anticheat.MaxReportsForDailyReport = 70
+
+#
 #     PlayerDump.DisallowPaths
 #        Description: Disallow using paths in PlayerDump output files
 #        Default:     1
@@ -2650,6 +2713,20 @@ PlayerDump.DisallowOverwrite = 1
 UI.ShowQuestLevelsInDialogs = 0
 
 #
+#    External.Mail.Enable
+#        Enable external mail delivery from mail_external table.
+#        Default: 0 (disabled)
+#                 1 (enabled)
+#
+#    External.Mail.Interval
+#        Mail delivery delay time for item sending from mail_external table, in minutes.
+#        Default: 5 minutes
+#
+
+External.Mail.Enable = 1
+External.Mail.Interval = 5
+
+#
 ###################################################################################################
 
 ###################################################################################################
@@ -2952,6 +3029,16 @@ AuctionHouseBot.forceExcludeItems = ""
 #
 ###################################################################################################
 
+#    Fake.WHO.List
+#        Add fake players to fill in WHO LIST (who is online list, "O" button) if there is less then
+#        49 real players online
+#        Default: 0 (disabled)
+#                 1 (enabled)
+
+Fake.WHO.List = 0
+Fake.WHO.Online.Interval = 5
+Fake.WHO.LevelUp.Interval = 2
+
 ###################################################################################################
 #    AHBot Buyer config
 #
@@ -3194,3 +3281,479 @@ PacketSpoof.BanDuration = 86400
 
 #
 ###################################################################################################
+
+###################################################################################################
+#
+# BeastMaster Configuration
+#
+# BeastMaster Hunter Only
+#                 = 0 (Anyone can use)
+#         default = 1 (Hunter only)
+
+BeastMaster.OnlyHunter = 1
+
+#
+# BeastMaster Enable Normal Pets
+#                 = 0  (Normal pets disabled)
+#         default = 1  (Normal Pets enabled)
+#
+
+BeastMaster.EnableNormalPet = 1
+
+#
+# BeastMaster Enable Exotic Pets
+#                 = 0  (Anyone Can get Exotic pets)
+#         default = 1  (Can only get Exotic Pets if you know how)
+#
+
+BeastMaster.EnableExoticPet = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.SpeedGame
+# Set it to a number upper than 1 to speed up realm timer
+# Default : 1 (Real Time)
+# Example : 60 to force 1scde (real time) = 1 minute (realm timer)
+#
+
+Custom.SpeedGame = 1
+
+#
+# Custom.NoCastTime
+# Set it to 1 to disable cast time
+# Default : 0 (Cast Time Enable)
+#
+
+Custom.NoCastTime = 0
+
+#
+# Custom.NoCooldown
+# Set it to 1 to disable cooldown
+# Default : 0 (Cooldown Enable)
+#
+
+Custom.NoCooldown = 0
+
+#
+# Custom.HurtInRealTime
+# Set it to 1 to disable autohurt with weapon
+# Default : 0 (Autohurt Enable)
+#
+
+Custom.HurtInRealTime = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# CROSSFACTION BG CONFIG
+#
+#    CrossfactionBG.enable = 1 - Mixed battleground enabled.
+#    CrossfactionBG.enable = 0 - Mixed battleground disabled.
+
+CrossfactionBG.enable = 1
+
+#
+###################################################################################################
+
+#
+# Custom.AttackSpeedForPlayer
+# Set it to a number upper than 1 to speed up the attack of the player
+# Default : 1.0 (Normal speed)
+# Example : 2.0 (Player attack speed is 200% faster)
+#
+
+Custom.AttackSpeedForPlayer = 1.0
+
+#
+# Custom.AttackSpeedForMobs
+# Set it to a number upper than 1 to speed up the attack of the mobs
+# Default : 1.0 (Normal speed)
+# Example : 0.5 (Mobs attack speed is 50% slower)
+#
+
+Custom.AttackSpeedForMobs = 1.0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.FastFishing
+# Set it to 1 to make fishing a lot faster!
+# Default : 0 (Fishing is normal)
+#
+
+Custom.FastFishing = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.GainHonorOnGuardKill
+# Set it to 1 to gain honor when you kill a guard.
+# Note that not all city guards will give you honor. It seems only capital and big city guards are flagged
+# as so in the database.
+# Default : 0 (No honor when you kill a guard)
+#
+
+Custom.GainHonorOnGuardKill = 0
+
+#
+# Custom.GainHonorOnEliteKill
+# Set it to 1 to gain honor when you kill an elite mob (this does not apply on rare mob, unless he is also elite).
+# Default : 0 (No honor when you kill an elite mob)
+#
+
+Custom.GainHonorOnEliteKill = 0
+
+#
+###################################################################################################
+
+###################################################################################################
+# GuildHouse
+#
+# Settings for the GuildHouse Keeper.
+#
+#    Guildhouse.TokenOrGold
+#        Description: Use tokens or money to buy guild houses.
+#        Default:     0 - Use Money
+#                     1 - Use Token
+#
+
+Guildhouse.TokenOrGold = 0
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens to buy guildhouse.
+#        Default:     1000 - 1000 gold
+#
+
+Guildhouse.BuyCost = 1000
+
+#    GuildHouse.BuyCost
+#        Description: Amount of gold or quantity of tokens gained when selling guildhouse.
+#        Default:     5000000 - 500 gold
+#
+
+Guildhouse.SellCost = 500
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# NPC Buff rewritten by LordPsyan
+#
+#        GM Only
+#         Default 0 = Any Player
+#                 1 = GM1 or higher
+
+Npc_Buff.OnlyGMs = 0
+
+#     Enables Small Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableSmallBuff = 1
+
+#     Enables Geat Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGreatBuff = 1
+
+#     Enables GM Only Buff
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableGMBuff = 1
+
+#     Enables Player Tools
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnablePlayerTools = 1
+
+#     Enables Remove Res Sickness
+#         Default 0 = Disable
+#                 1 = Enable
+
+Npc_Buff.EnableRemoveResSickness = 1
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+#       Profession NPC
+#
+# Enable or Disable Primary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableProfessions = 1
+
+# Enable or Disable Secondary Professions
+#         default = 1 (Enabled)
+#                   = 0 (Disabled)
+
+ProfessionNPC.EnableSecondarySkills = 1
+
+# Number of Skill points
+#         default = 10
+
+SkillPoints = 10
+
+# GM Only
+#         default = 0 (Anyone can use)
+#                   = 1 (GM only)
+
+ProfessionNPC.OnlyGMs = 0
+
+# Cost of skill points (in copper)
+#         default = 10000 (10 gold)
+
+SkillGoldCost = 10000
+
+# Use Tokens instead of gold
+#         default = 0 (Use Gold)
+#                 = 1 (Use Tokens)
+
+ProfessionNPC.UseTokens = 1
+
+# Entry number of "token" Item
+#         default = 0 (No item. ProfessionNPC.UseTokens must = 0)
+#                 = n (n = entry number of item)
+
+ProfessionNPC.ItemEntryNum = 99999
+
+#
+###################################################################################################
+
+###################################################################################################
+#
+# Custom.RespawnSpeed
+# Set it to a number upper than 1 to speed up the respawn of mobs (and lower than 1 to slow down).
+# Default : 1.0 (Normal speed)
+#
+
+Custom.RespawnSpeed = 1.0
+
+#
+###################################################################################################
+
+###################################################################################################
+#    Transmogrification config
+###################################################################################################
+#
+#    SETTINGS
+#
+#    Logger.custom.transmog
+#        Description: Transmogrification logging setting, see logger settings
+#        Default:    3, Console Server
+#
+#    Transmogrification.EnableTransmogInfo
+#        Description: Enables / Disables the info button for transmogrification
+#        Default:    1
+#
+#    Transmogrification.TransmogNpcText
+#        Description: The npc_text entry of the info menu for transmogrification
+#        Default:    50000
+#
+#    Transmogrification.Allowed
+#        Description: A list of item entries that are allowed for transmogrification (skips quality and CanUseItem check)
+#					  Example: "25 35674 5623"
+#        Default:    ""
+#
+#    Transmogrification.NotAllowed
+#        Description: A list of item entries that are NOT allowed for transmogrification
+#					  Example: "25 35674 5623"
+#        Default:    ""
+
+Logger.custom.transmog = 3, Console Server
+
+Transmogrification.EnableTransmogInfo = 1
+Transmogrification.TransmogNpcText = 50000
+
+Transmogrification.Allowed = ""
+Transmogrification.NotAllowed = ""
+
+#
+#    COPPER COST
+#
+#    Transmogrification.ScaledCostModifier
+#        Description: A multiplier for the default gold cost (change to 0 for no default cost)
+#        Default:    1.0
+#
+#    Transmogrification.CopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+#
+#    For custom gold cost set ScaledCostModifier to 0.0 and CopperCost to what ever cost you want
+
+Transmogrification.ScaledCostModifier = 1.0
+Transmogrification.CopperCost = 0
+
+#
+#    TOKEN COST
+#
+#    Transmogrification.RequireToken
+#        Description: Adds/disables token cost
+#        Default:    0
+#
+#    Transmogrification.TokenEntry
+#        Description: Entry of the token item
+#        Default:    49426
+#
+#    Transmogrification.TokenAmount
+#        Description: Amount of tokens required
+#        Default:    1
+
+Transmogrification.RequireToken = 0
+Transmogrification.TokenEntry = 49426
+Transmogrification.TokenAmount = 1
+
+#
+#    REQUIREMENTS
+#
+#    Transmogrification.AllowPoor
+#        Description: Allow poor quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowCommon
+#        Description: Allow common quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowUncommon
+#        Description: Allow uncommon quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowRare
+#        Description: Allow rare quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowEpic
+#        Description: Allow epic quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowLegendary
+#        Description: Allow legendary quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowArtifact
+#        Description: Allow artifact quality items to be used as source and target items
+#        Default:    0
+#
+#    Transmogrification.AllowHeirloom
+#        Description: Allow heirloom quality items to be used as source and target items
+#        Default:    1
+#
+#    Transmogrification.AllowMixedArmorTypes
+#        Description: Allow cloth items to be transmogrified with plate for example
+#        Default:    0
+#
+#    Transmogrification.AllowMixedWeaponTypes
+#        Description: Allow axe to be transmogrified with dagger for example
+#        Default:    0
+#
+#    Transmogrification.AllowFishingPoles
+#        Description: Allow fishing poles to be transmogrified
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqRace
+#        Description: Ignore required race for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqClass
+#        Description: Ignore required class for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSkill
+#        Description: Ignore required skill for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqSpell
+#        Description: Ignore required spell for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqLevel
+#        Description: Ignore required level for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqEvent
+#        Description: Ignore required event for source items
+#        Default:    0
+#
+#    Transmogrification.IgnoreReqStats
+#        Description: Ignore stat count > 0 requirement for source items
+#        Default:    0
+
+Transmogrification.AllowPoor = 0
+Transmogrification.AllowCommon = 0
+Transmogrification.AllowUncommon = 1
+Transmogrification.AllowRare = 1
+Transmogrification.AllowEpic = 1
+Transmogrification.AllowLegendary = 0
+Transmogrification.AllowArtifact = 0
+Transmogrification.AllowHeirloom = 1
+
+Transmogrification.AllowMixedArmorTypes = 0
+Transmogrification.AllowMixedWeaponTypes = 0
+Transmogrification.AllowFishingPoles = 0
+
+Transmogrification.IgnoreReqRace = 0
+Transmogrification.IgnoreReqClass = 0
+Transmogrification.IgnoreReqSkill = 0
+Transmogrification.IgnoreReqSpell = 0
+Transmogrification.IgnoreReqLevel = 0
+Transmogrification.IgnoreReqEvent = 0
+Transmogrification.IgnoreReqStats = 0
+
+#
+#    SET FEATURE
+#
+#    Transmogrification.EnableSets
+#        Description: Enables / Disables the set feature. If you want permanent disable, check Transmogrification.h
+#        Default:    1
+#
+#    Transmogrification.MaxSets
+#        Description: Maximum amount of sets a player can save (hardcap at 25)
+#        Default:    10
+#
+#    Transmogrification.EnableSetInfo
+#        Description: Enables / Disables the info button for set fature
+#        Default:    1
+#
+#    Transmogrification.SetNpcText
+#        Description: The npc_text entry of the info menu for the set feature
+#        Default:    50001
+#
+#    Transmogrification.SetCostModifier
+#        Description: A multiplier for the default gold cost (all costs summed together) (change to 0 for no default cost)
+#        Default:    3.0
+#
+#    Transmogrification.SetCopperCost
+#        Description: Cost added on top of other costs (can be negative)
+#        Default:    0
+
+Transmogrification.EnableSets = 1
+Transmogrification.MaxSets = 10
+
+Transmogrification.EnableSetInfo = 1
+Transmogrification.SetNpcText = 50001
+
+Transmogrification.SetCostModifier = 3.0
+Transmogrification.SetCopperCost = 0
+
+#
+###################################################################################################
+
+#
+# Prepatch by LordPsyan.
+# See http://www.realmsofwarcraft.com/bb for forums and information.
+#
-- 
2.1.0.rc1

